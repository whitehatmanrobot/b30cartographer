T;

    }

    if( _wcsicmp( ProviderName, RWAN_NAME ) == 0 ) {

        RtlCopyMemory(
            ProviderGuid,
            &AtmProviderGuid,
            sizeof(GUID)
            );

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetProviderGuid


INT
WINAPI
WSHIoctl (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD IoControlCode,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned,
    IN LPWSAOVERLAPPED Overlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine,
    OUT LPBOOL NeedsCompletion
    )

/*++

Routine Description:

    Performs queries & controls on the socket. This is basically an
    "escape hatch" for IOCTLs not supported by MSAFD.DLL. Any unknown
    IOCTLs are routed to the socket's helper DLL for protocol-specific
    processing.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're controlling.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    IoControlCode - Control code of the operation to perform.

    InputBuffer - Address of the input buffer.

    InputBufferLength - The length of InputBuffer.

    OutputBuffer - Address of the output buffer.

    OutputBufferLength - The length of OutputBuffer.

    NumberOfBytesReturned - Receives the number of bytes actually written
        to the output buffer.

    Overlapped - Pointer to a WSAOVERLAPPED structure for overlapped
        operations.

    CompletionRoutine - Pointer to a completion routine to call when
        the operation is completed.

    NeedsCompletion - WSAIoctl() can be overlapped, with all the gory
        details that involves, such as setting events, queuing completion
        routines, and posting to IO completion ports. Since the majority
        of the IOCTL codes can be completed quickly "in-line", MSAFD.DLL
        can optionally perform the overlapped completion of the operation.

        Setting *NeedsCompletion to TRUE (the default) causes MSAFD.DLL
        to handle all of the IO completion details iff this is an
        overlapped operation on an overlapped socket.

        Setting *NeedsCompletion to FALSE tells MSAFD.DLL to take no
        further action because the helper DLL will perform any necessary
        IO completion.

        Note that if a helper performs its own IO completion, the helper
        is responsible for maintaining the "overlapped" mode of the socket
        at socket creation time and NOT performing overlapped IO completion
        on non-overlapped sockets.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    INT err;
    PWSHATM_SOCKET_CONTEXT context;

    //
    // Quick sanity checks.
    //

    if( HelperDllSocketContext == NULL ||
        SocketHandle == INVALID_SOCKET ||
        NumberOfBytesReturned == NULL ||
        NeedsCompletion == NULL ) {

        return WSAEINVAL;

    }

        context = (PWSHATM_SOCKET_CONTEXT)HelperDllSocketContext;
    *NeedsCompletion = TRUE;

        DBGPRINT(("WSHIoctl: IoControlCode x%x, InBuf: x%x/%d, OutBuf: x%x/%d\n",
                                        IoControlCode,
                                        InputBuffer,
                                        InputBufferLength,
                                        OutputBuffer,
                                        OutputBufferLength));

        switch (IoControlCode) {
        
        case SIO_ASSOCIATE_PVC:

                context->SocketHandle = SocketHandle;
                err = AtmAssociatePVC(
                                        SocketHandle,
                                        HelperDllSocketContext,
                                        TdiAddressObjectHandle,
                                        TdiConnectionObjectHandle,
                                        InputBuffer,
                                        InputBufferLength
                                        );

                DBGPRINT(("WSHIoctl: ASSOCIATE_PVC: context %x, LocalFlags %x, err %d\n",
                                        context, context->LocalFlags, err));

                if ( (err == NO_ERROR) && 
                         (( context->LocalFlags & WSHATM_SOCK_IS_BOUND ) == 0 )) { 

                        SOCKADDR_ATM    addr;
                        INT                             len = sizeof(addr);

                        (VOID) WSHGetWildcardSockaddr (
                                        HelperDllSocketContext,
                                        (struct sockaddr *)&addr,
                                        &len);

                        DBGPRINT(("WSHIoctl: ASSOCIATE_PVC: will bind\n"));
                        err = bind(SocketHandle, (struct sockaddr *)&addr, len);

#if DBG
                        if ( err != NO_ERROR ) {

                                DbgPrint("WSHATM: bind err %d, context %x, LocalFlags %x\n",
                                                        err, context, context->LocalFlags);
                        
                        }
#endif
                
                }

                if ( err == NO_ERROR ) {

                        SOCKADDR_ATM    addr;
                        INT                             len = sizeof(addr);

                        (VOID) WSHGetWildcardSockaddr (
                                        HelperDllSocketContext,
                                        (struct sockaddr *)&addr,
                                        &len);

                        addr.satm_family = AF_ATM;
                        addr.satm_number.AddressType = ATM_NSAP;
                        addr.satm_number.NumofDigits = ATM_ADDR_SIZE;

                        err = WSAConnect(
                                        SocketHandle,
                                        (struct sockaddr *)&addr,
                                        len,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL);


                        if ( err != NO_ERROR ) {
                                DBGPRINT(("WSHIoctl: connect (%d) returned %d\n",
                                                SocketHandle, err));

                                if ( err == SOCKET_ERROR ) {
                                        err = WSAGetLastError();
                                }
                        }
                }

                break;

        case SIO_SET_QOS:
                err = WSHAtmSetQoS(
                                        HelperDllSocketContext,
                                        SocketHandle,
                                        InputBuffer,
                                        InputBufferLength
                                        );
                break;

        case SIO_GET_QOS:
                err = WSHAtmGetQoS(
                                        HelperDllSocketContext,
                                        SocketHandle,
                                        OutputBuffer,
                                        OutputBufferLength,
                                        NumberOfBytesReturned
                                        );
                break;

        case SIO_GET_GROUP_QOS:
                *NumberOfBytesReturned = 0;
                err = NO_ERROR;
                break;

        case SIO_SET_GROUP_QOS:
                *NumberOfBytesReturned = 0;
                err = WSAEOPNOTSUPP;
                break;

        case SIO_GET_NUMBER_OF_ATM_DEVICES:
                err = AtmQueryAtmGlobalInformation(
                                ATMSP_OID_NUMBER_OF_DEVICES,
                                NULL,
                                0,
                                OutputBuffer,
                                OutputBufferLength,
                                NumberOfBytesReturned
                                );
                break;
        
        case SIO_GET_ATM_ADDRESS:
                err = AtmQueryAtmGlobalInformation(
                                ATMSP_OID_ATM_ADDRESS,
                                InputBuffer,
                                InputBufferLength,
                                OutputBuffer,
                                OutputBufferLength,
                                NumberOfBytesReturned
                                );
                break;
        
        case SIO_GET_ATM_CONNECTION_ID:

                if ( TdiConnectionObjectHandle == NULL ) {

                        //
                        //  Check if this is a PVC. If so, the Connection ID is
                        //  available locally.
                        //
                        if ( context && ( context->LocalFlags & WSHATM_SOCK_IS_PVC )) {

                                if ( ( OutputBuffer != NULL ) &&
                                         ( OutputBufferLength >= sizeof(ATM_CONNECTION_ID) ) ) {
                                
                                        ATM_CONNECTION_ID * pConnId = OutputBuffer;

                                        *pConnId = context->ConnectionId;

                                        err = NO_ERROR;

                                } else {

                                        err = WSAEFAULT;
                                
                                }

                        } else {

                                err = WSAENOTCONN;
                        
                        }
                
                } else {

                        err = AtmGetAtmObjectInformation(
                                        TdiConnectionObjectHandle,
                                        IOCTL_RWAN_MEDIA_SPECIFIC_CONN_HANDLE_QUERY,
                                        ATMSP_OID_CONNECTION_ID,
                                        InputBuffer,
                                        InputBufferLength,
                                        OutputBuffer,
                                        OutputBufferLength,
                                        NumberOfBytesReturned
                                        );
                }
                break;
                                        
        case SIO_ENABLE_CIRCULAR_QUEUEING:
                err = NO_ERROR;
                break;

        default:
                err = WSAEINVAL;
                break;
        }

    DBGPRINT(("WSHIoctl: IoControlCode x%x, returning %d\n",
                        IoControlCode, err));

    return err;

}   // WSHIoctl



INT
WSHAtmSetQoS(
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength
    )
/*++

Routine Description:

        This routine is called to process a SIO_SET_QOS Ioctl. The QoS is represented
        by a basic QOS structure, and an optional provider-specific part. We first
        copy this two-part structure into a single flat buffer, and then call
        setsockopt(SO_CONNOPT) to get MSAFD to copy this down to AFD. Later, if/when
        a WSAConnect() is made, AFD will pass these "connection options" in the TDI
        connect to the transport.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're controlling.

    InputBuffer - Address of the input buffer.

    InputBufferLength - The length of InputBuffer.

Return Value:

    INT - The completion status.

--*/
{
        INT                     err;
        LPQOS           lpQOS;

        PUCHAR          pQoSBuffer;                     // Flat buffer for use in SO_CONNOPT
        INT                     QoSBufferLength;
        LPQOS           lpOutputQOS;

        err = NO_ERROR;
        lpQOS = (LPQOS)InputBuffer;

        DBGPRINT(("SetQoS: Context x%x, Handle x%x, InBuf x%x, InBufLen %d\n",
                                HelperDllSocketContext,
                                SocketHandle,
                                InputBuffer,
                                InputBufferLength));
        do
        {
                if (lpQOS == NULL)
                {
                        err = WSAEINVAL;
                        break;
                }

                //
                //  Expect atleast the base QOS structure to be present.
                //
                if (InputBufferLength < sizeof(*lpQOS))
                {
                        err = WSAENOBUFS;
                        break;
                }

                //
                //  Sanity check the provider-specific part.
                //
                if (((lpQOS->ProviderSpecific.buf != NULL) &&
                         (lpQOS->ProviderSpecific.len == 0))
                                ||
                        ((lpQOS->ProviderSpecific.buf == NULL) &&
                         (lpQOS->ProviderSpecific.len != 0)))
                {
                        DBGPRINT(("lpQOS %x, buf %x, len %x, not consistent\n",
                                        lpQOS, lpQOS->ProviderSpecific.buf,
                                        lpQOS->ProviderSpecific.len));

                        err = WSAEINVAL;
                        break;
                }

                //
                //  Compute the total length we need.
                //
                QoSBufferLength = sizeof(QOS) + lpQOS->ProviderSpecific.len;

                pQoSBuffer = RTL_ALLOCATE_HEAP(RtlProcessHeap(), 0, QoSBufferLength);

                if (pQoSBuffer == NULL)
                {
                        err = WSAENOBUFS;
                        break;
                }

                lpOutputQOS = (LPQOS)pQoSBuffer;

                //
                //  Copy in the generic QOS part.
                //
                RtlCopyMemory(
                        lpOutputQOS,
                        lpQOS,
                        sizeof(QOS)
                        );

                //
                //  Copy in the provider-specific QOS just after the generic part.
                //
                if (lpQOS->ProviderSpecific.len != 0)
                {
                        RtlCopyMemory(
                                (PCHAR)pQoSBuffer+sizeof(QOS),
                                lpQOS->ProviderSpecific.buf,
                                lpQOS->ProviderSpecific.len
                                );
                        
                        //
                        //  Set up the offset to provider-specific part. Note that we
                        //  use the "buf" to mean the offset from the beginning of the
                        //  flat QOS buffer and not a pointer.
                        //
                        lpOutputQOS->ProviderSpecific.buf = (char FAR *)sizeof(QOS);
                }
                else
                {
                        lpOutputQOS->ProviderSpecific.buf = NULL;
                }


                //
                //  Request the Winsock DLL to set the options.
                //
                err = setsockopt(
                                SocketHandle,
                                SOL_SOCKET,
                                SO_CONNOPT,
                                pQoSBuffer,
                                QoSBufferLength
                                );

                RTL_FREE_HEAP(
                                RtlProcessHeap(),
                                0,
                                pQoSBuffer
                                );

                break;
        }
        while (FALSE);

        DBGPRINT(("SetQoS: returning err %d\n", err));
        return (err);
}



INT
WSHAtmGetQoS(
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned
    )
/*++

Routine Description:

        This routine is called to process a SIO_GET_QOS Ioctl. We translate
        this to a "Get Connect Options" and ask MSAFD to get them for us.
        The connect options for ATM will contain the base QoS structure and
        optionally a provider-specific part that contains additional information
        elements.

        One of the places this might be called is when processing a WSAAccept
        with a condition function specified. MSAFD calls us to get the QoS,
        and we in turn request MSAFD to get SO_CONNOPT.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're controlling.

    OutputBuffer - Address of the Output buffer.

    OutputBufferLength - The length of OutputBuffer.

    NumberOfBytesReturned - where we return the number of bytes we filled into
        OutputBuffer.

Return Value:

    INT - The completion status.

--*/
{
        INT                     err;
        DWORD           BytesReturned;
        LPQOS           lpQOS;

        err = NO_ERROR;

        DBGPRINT(("GetQoS: Context x%x, Handle x%x, OutBuf x%x, OutBufLen %d\n",
                                HelperDllSocketContext,
                                SocketHandle,
                                OutputBuffer,
                                OutputBufferLength));

        do
        {
                //
                //  Expect atleast enough space to fit in the base QoS structure.
                //
                if (OutputBufferLength < sizeof(QOS))
                {
                        *NumberOfBytesReturned = MAX_ATM_OPTIONS_LENGTH;
                        err = WSAEFAULT;
                        break;
                }

                //
                //  Request the Winsock DLL to get the options.
                //
                BytesReturned = OutputBufferLength;
                err = getsockopt(
                                SocketHandle,
                                SOL_SOCKET,
                                SO_CONNOPT,
                                OutputBuffer,
                                &BytesReturned
                                );
        
                if ((err == NO_ERROR) && (BytesReturned != 0))
                {
                        *NumberOfBytesReturned = BytesReturned;

                        lpQOS = (LPQOS)OutputBuffer;

                        //
                        //  Fix up the provider-specific part, if any.
                        //
                        if (BytesReturned > sizeof(QOS))
                        {
                                lpQOS->ProviderSpecific.buf = (PCHAR)((PCHAR)lpQOS + sizeof(QOS));
                        }
                        else
                        {
                                lpQOS->ProviderSpecific.buf = NULL;
                                lpQOS->ProviderSpecific.len = 0;
                        }
                        DBGPRINT(("GetQoS: lpQOS %x, ProvSpec buf %x, len %d\n",
                                                lpQOS, lpQOS->ProviderSpecific.buf, lpQOS->ProviderSpecific.len));
                }
                else
                {
                        if (BytesReturned == 0)
                        {
                                //
                                //  Probably because we aren't connected yet? Let's return
                                //  all "NOT_SPECIFIED" values:
                                //
                                *NumberOfBytesReturned = sizeof(QOS);

                                lpQOS = (LPQOS)OutputBuffer;
                                lpQOS->ProviderSpecific.buf = NULL;
                                lpQOS->ProviderSpecific.len = 0;

                                lpQOS->SendingFlowspec.TokenRate =
                                lpQOS->SendingFlowspec.TokenBucketSize =
                                lpQOS->SendingFlowspec.PeakBandwidth =
                                lpQOS->SendingFlowspec.Latency =
                                lpQOS->SendingFlowspec.DelayVariation =
                                lpQOS->SendingFlowspec.ServiceType =
                                lpQOS->SendingFlowspec.MaxSduSize =
                                lpQOS->SendingFlowspec.MinimumPolicedSize = QOS_NOT_SPECIFIED;
                                lpQOS->ReceivingFlowspec = lpQOS->SendingFlowspec;

                        } else {

                                err = WSAGetLastError();
                        }
                }

                break;
        }
        while (FALSE);


        return (err);
}


INT
AtmAssociatePVC(
    IN SOCKET SocketHandle,
        IN PVOID HelperDllSocketContext,
        IN HANDLE TdiAddressObjectHandle,
        IN HANDLE TdiConnectionObjectHandle,
        IN LPVOID InputBuffer,
        IN DWORD InputBufferLength
        )
{
        INT err;
    PWSHATM_SOCKET_CONTEXT context;
    ATM_PVC_PARAMS * pInPvcParams;

        context = (PWSHATM_SOCKET_CONTEXT)HelperDllSocketContext;

        DBGPRINT(("AssociatePVC: InputBuffer %x, Length %d, sizeof(ATM_PVC_PARAMS) %d\n",
                        InputBuffer, InputBufferLength, sizeof(ATM_PVC_PARAMS)));

        do {

                if ( InputBuffer == NULL ||
                         InputBufferLength < sizeof(ATM_PVC_PARAMS) ) {
                        
                        err = WSAEFAULT;
                        break;
                }

                if ( context == NULL ) {

                        err = WSAEINVAL;
                        break;
                }

                //
                //  We want to allow the user to change the PVC info any number of times
                //  before connecting, but not after the fact.
                //
                if ( TdiConnectionObjectHandle != NULL ) {

                        err = WSAEISCONN;
                        break;
                }

                if ( context->LocalFlags & WSHATM_SOCK_IS_PVC ) {
                        //
                        //  Already associated. Fail this.
                        //

                        err = WSAEISCONN;
                        break;
                }


                //
                //  Use the standard QoS mechanism to associate the QOS info
                //  with this socket.
                //
                pInPvcParams = InputBuffer;

                err = setsockopt(
                                SocketHandle,
                                SOL_SOCKET,
                                SO_CONNOPT,
                                (PCHAR)&pInPvcParams->PvcQos,
                                InputBufferLength - (DWORD)((PUCHAR)&pInPvcParams->PvcQos - (PUCHAR)pInPvcParams)
                                );


                DBGPRINT(("AssociatePVC: setsockopt, ptr %x, length %d, ret %d\n",
                                &pInPvcParams->PvcQos,
                                InputBufferLength - (DWORD)((PUCHAR)&pInPvcParams->PvcQos - (PUCHAR)pInPvcParams),
                                err));
                                
                if ( err != NO_ERROR ) {

                        break;
                }

                //
                //  Store the Connection Id.
                //
                context->ConnectionId = pInPvcParams->PvcConnectionId;
                context->LocalFlags |= WSHATM_SOCK_IS_PVC;

                if ( TdiAddressObjectHandle == NULL ) {
                
                        //
                        // We've got an ASSOCIATE_PVC before this socket has been
                        // bound. Just remember this, so that we do the rest when
                        // the bind actually happens.
                        //
                        context->LocalFlags |= WSHATM_SOCK_ASSOCIATE_PVC_PENDING;
                        err = NO_ERROR;
                        break;
                }

                //
                //  The socket is bound, so send info about the PVC Connection
                //  ID to the transport.
                //
                err = AtmDoAssociatePVC(
                                context,
                                TdiAddressObjectHandle
                                );
                DBGPRINT(("AssociatePVC: DoAssociatePVC ret %d\n", err));

                break;
        }
        while (FALSE);

        DBGPRINT(("AssociatePVC: context Flags %x, LocalFlags %x, returning %d\n",
                        context? context->Flags: 0,
                        context? context->LocalFlags: 0,
                        err));

        return err;
}


INT
AtmDoAssociatePVC(
        IN PWSHATM_SOCKET_CONTEXT Context,
        IN HANDLE TdiAddressObjectHandle
        )
{
        INT err;

        DBGPRINT(("DoAssociatePVC: Context %x, LocalFlags %x\n",
                                Context, LocalFlags));

        Context->LocalFlags &= ~WSHATM_SOCK_ASSOCIATE_PVC_PENDING;

        err = AtmSetAtmObjectInformation(
                        TdiAddressObjectHandle,
                        IOCTL_RWAN_MEDIA_SPECIFIC_ADDR_HANDLE_SET,
                        ATMSP_OID_PVC_ID,
                        &Context->ConnectionId,
                        sizeof(ATM_CONNECTION_ID)
                        );

        return err;
}


INT
AtmQueryAtmGlobalInformation(
        IN ATM_OBJECT_ID ObjectId,
        IN LPVOID pContext,
        IN DWORD ContextLength,
        IN LPVOID OutputBuffer,
        IN DWORD OutputBufferLength,
        OUT LPDWORD NumberOfBytesReturned
        )
{
        INT err;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING deviceName;
    HANDLE deviceHandle = NULL;
    PIO_STATUS_BLOCK ioStatusBlock;
    PATM_QUERY_INFORMATION_EX pQueryInfo;

        do
        {
                ioStatusBlock = RTL_ALLOCATE_HEAP(
                                                        RtlProcessHeap( ),
                                                        0,
                                                        sizeof(*ioStatusBlock) + sizeof(ATM_QUERY_INFORMATION_EX) + ContextLength
                                                        );
                
                if ( ioStatusBlock == NULL ) {
                        err = WSAENOBUFS;
                        break;
                }


                //
                // Open a handle to the ATM device.
                //

                RtlInitUnicodeString(
                        &deviceName,
                        DD_ATM_DEVICE_NAME
                        );

                InitializeObjectAttributes(
                        &objectAttributes,
                        &deviceName,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

                status = NtCreateFile(
                                        &deviceHandle,
                                        SYNCHRONIZE | GENERIC_EXECUTE,
                                        &objectAttributes,
                                        ioStatusBlock,
                                        NULL,
                                        FILE_ATTRIBUTE_NORMAL,
                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        FILE_OPEN_IF,
                                        FILE_SYNCHRONOUS_IO_NONALERT,
                                        NULL,
                                        0
                                        );

                if( !NT_SUCCESS(status) ) {

                        if (status == STATUS_INSUFFICIENT_RESOURCES) {
                                err = WSAEFAULT;
                        } else {
                                err = WSAEINVAL;
                        }

                        break;

                }

                pQueryInfo = (PATM_QUERY_INFORMATION_EX)(ioStatusBlock + 1);
                pQueryInfo->ObjectId = ObjectId;
                pQueryInfo->ContextLength = ContextLength;

                if ( pQueryInfo->ContextLength > 0 ) {

                        RtlCopyMemory(
                                pQueryInfo->Context,
                                pContext,
                                pQueryInfo->ContextLength
                                );

                }

                status = NtDeviceIoControlFile(
                                        deviceHandle,
                                        NULL,   // No Event
                                        NULL,   // No completion APC
                                        NULL,   // No completion APC Context
                                        ioStatusBlock,
                                        IOCTL_RWAN_MEDIA_SPECIFIC_GLOBAL_QUERY,
                                        pQueryInfo,
                                        sizeof(ATM_QUERY_INFORMATION_EX) + ContextLength,
                                        OutputBuffer,
                                        OutputBufferLength
                                        );

                DBGPRINT(("DevIoControl (Oid %x) returned x%x, Info %d\n",
                                                pQueryInfo->ObjectId, status, ioStatusBlock->Information));

                if ( NT_SUCCESS(status) ) {
                        err = NO_ERROR;
                        *NumberOfBytesReturned = (ULONG)ioStatusBlock->Information;
                }
                else {
                        if (status == STATUS_INSUFFICIENT_RESOURCES) {
                                err = WSAEFAULT;
                        } else {
                                err = WSAEINVAL;
                        }
                }
        
        }
        while (FALSE);

    if( deviceHandle != NULL ) {

        NtClose( deviceHandle );

    }

        if ( ioStatusBlock != NULL ) {
                RTL_FREE_HEAP( RtlProcessHeap( ), 0, ioStatusBlock );
        }

        return err;
}


INT
AtmSetGenericObjectInformation (
    IN HANDLE TdiObjectHandle,
    IN ULONG IoControlCode,
    IN RWAN_OBJECT_ID ObjectId,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

        Performs a RWAN Set Information action to the Raw Wan driver. This operation
        is directed to either an Address Object or to a Connection object, according
        to TdiObjectHandle.

Arguments:

    TdiObjectHandle - a TDI handle to either an Address or a Connection object
        on which to perform the Set Info operation.

    IoControlCode - IOCTL_RWAN_GENERIC_XXXSET

    ObjectId - value to put in the ObjectId field of the Set Info structure.

        InputBuffer - Points to buffer containing value for the Object.

        InputBufferLength - Length of the above.

Return Value:

    INT - NO_ERROR, or a Windows Sockets error code.

--*/

{
    NTSTATUS status;
    INT err;
    PRWAN_SET_INFORMATION_EX pSetInfo;
    PIO_STATUS_BLOCK ioStatusBlock;

        do
        {
                ioStatusBlock = RTL_ALLOCATE_HEAP(
                                                        RtlProcessHeap( ),
                                                        0,
                                                        sizeof(*ioStatusBlock) + sizeof(RWAN_SET_INFORMATION_EX) + InputBufferLength
                                                        );
                
                if ( ioStatusBlock == NULL ) {
                        err = WSAENOBUFS;
                        break;
                }

                pSetInfo = (PRWAN_SET_INFORMATION_EX)(ioStatusBlock + 1);
                pSetInfo->ObjectId = ObjectId;
                pSetInfo->BufferSize = InputBufferLength;

                if ( pSetInfo->BufferSize > 0 ) {

                        RtlCopyMemory(
                                pSetInfo->Buffer,
                                InputBuffer,
                                pSetInfo->BufferSize
                                );

                }

                status = NtDeviceIoControlFile(
                                        TdiObjectHandle,
                                        NULL,   // No Event
                                        NULL,   // No completion APC
                                        NULL,   // No completion APC Context
                                        ioStatusBlock,
                                        IoControlCode,
                                        pSetInfo,
                                        sizeof(RWAN_SET_INFORMATION_EX) + InputBufferLength,
                                        NULL,   // No output buffer
                                        0               // output buffer length
                                        );

                DBGPRINT(("AtmSetInfo: IOCTL (Oid %x) returned x%x\n", pSetInfo->ObjectId, status));

                if ( NT_SUCCESS(status) ) {
                        err = NO_ERROR;
                }
                else {
                        if (status == STATUS_INSUFFICIENT_RESOURCES) {
                                err = WSAEFAULT;
                        } else {
                                err = WSAEINVAL;
                        }
                }
        
        }
        while (FALSE);

        if ( ioStatusBlock != NULL ) {
                RTL_FREE_HEAP( RtlProcessHeap( ), 0, ioStatusBlock );
        }

        return err;
}


INT
AtmGetGenericObjectInformation (
    IN HANDLE TdiObjectHandle,
    IN ULONG IoControlCode,
    IN RWAN_OBJECT_ID ObjectId,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
        OUT LPDWORD NumberOfBytesReturned
    )

/*++

Routine Description:

        Performs a RWAN Get Information action to the Raw Wan driver. This operation
        is directed to either an Address Object or to a Connection object, according
        to TdiObjectHandle.

Arguments:

    TdiObjectHandle - a TDI handle to either an Address or a Connection object
        on which to perform the Set Info operation.

    IoControlCode - IOCTL_RWAN_GENERIC_XXXGET

    ObjectId - value to put in the ObjectId field of the Set Info structure.

        InputBuffer - Points to buffer containing context for the Object.

        InputBufferLength - Length of the above.

        OutputBuffer - place to return value

        OutputBufferLength - bytes available in OutputBuffer

        NumberOfBytesReturned - place to return bytes written

Return Value:

    INT - NO_ERROR, or a Windows Sockets error code.

--*/

{
    NTSTATUS status;
    INT err;
    PRWAN_QUERY_INFORMATION_EX pQueryInfo;
    PIO_STATUS_BLOCK ioStatusBlock;

        do
        {
                ioStatusBlock = RTL_ALLOCATE_HEAP(
                                                        RtlProcessHeap( ),
                                                        0,
                                                        sizeof(*ioStatusBlock) + sizeof(RWAN_QUERY_INFORMATION_EX) + InputBufferLength
                                                        );
                
                if ( ioStatusBlock == NULL ) {
                        err = WSAENOBUFS;
                        break;
                }

                pQueryInfo = (PRWAN_QUERY_INFORMATION_EX)(ioStatusBlock + 1);
                pQueryInfo->ObjectId = ObjectId;
                pQueryInfo->ContextLength = InputBufferLength;

                if ( pQueryInfo->ContextLength > 0 ) {

                        RtlCopyMemory(
                                pQueryInfo->Context,
                                InputBuffer,
                                pQueryInfo->ContextLength
                                );
                }

                status = NtDeviceIoControlFile(
                                        TdiObjectHandle,
                                        NULL,   // No Event
                                        NULL,   // No completion APC
                                        NULL,   // No completion APC Context
                                        ioStatusBlock,
                                        IoControlCode,
                                        pQueryInfo,
                                        sizeof(RWAN_QUERY_INFORMATION_EX) + InputBufferLength,
                                        OutputBuffer,
                                        OutputBufferLength              // output buffer length
                                        );

                DBGPRINT(("AtmGetGenericInfo: IOCTL (Oid %x) returned x%x\n", pQueryInfo->ObjectId, status));
                if ( NT_SUCCESS(status) ) {
                        err = NO_ERROR;
                        *NumberOfBytesReturned = (ULONG)ioStatusBlock->Information;
                }
                else {
                        if (status == STATUS_INSUFFICIENT_RESOURCES) {
                                err = WSAEFAULT;
                        } else {
                                err = WSAEINVAL;
                        }

                }
        
        }
        while (FALSE);

        if ( ioStatusBlock != NULL ) {
                RTL_FREE_HEAP( RtlProcessHeap( ), 0, ioStatusBlock );
        }

        return err;
}



INT
AtmSetAtmObjectInformation (
    IN HANDLE TdiObjectHandle,
    IN ULONG IoControlCode,
    IN ATM_OBJECT_ID ObjectId,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
    )

/*++

Routine Description:

        Performs a Media-specific Set Information action to the Raw Wan driver.
        This operation is directed to either an Address Object or to a Connection
        object, according to TdiObjectHandle.

Arguments:

    TdiObjectHandle - a TDI handle to either an Address or a Connection object
        on which to perform the Set Info operation.

    IoControlCode - IOCTL_RWAN_MEDIA_SPECIFIC_XXX

    ObjectId - value to put in the ObjectId field of the Set Info structure.

        InputBuffer - Points to buffer containing value for the Object.

        InputBufferLength - Length of the above.

Return Value:

    INT - NO_ERROR, or a Windows Sockets error code.

--*/

{
    NTSTATUS status;
    INT err;
    PATM_SET_INFORMATION_EX pSetInfo;
    PIO_STATUS_BLOCK ioStatusBlock;

        do
        {
                ioStatusBlock = RTL_ALLOCATE_HEAP(
                                                        RtlProcessHeap( ),
                                                        0,
                                                        sizeof(*ioStatusBlock) + sizeof(ATM_SET_INFORMATION_EX) + InputBufferLength
                                                        );
                
                if ( ioStatusBlock == NULL ) {
                        err = WSAENOBUFS;
                        break;
                }

                pSetInfo = (PATM_SET_INFORMATION_EX)(ioStatusBlock + 1);
                pSetInfo->ObjectId = ObjectId;
                pSetInfo->BufferSize = InputBufferLength;

                if ( pSetInfo->BufferSize > 0 ) {

                        RtlCopyMemory(
                                pSetInfo->Buffer,
                                InputBuffer,
                                pSetInfo->BufferSize
                                );

                }

                status = NtDeviceIoControlFile(
                                        TdiObjectHandle,
                                        NULL,   // No Event
                                        NULL,   // No completion APC
                                        NULL,   // No completion APC Context
                                        ioStatusBlock,
                                        IoControlCode,
                                        pSetInfo,
                                        sizeof(ATM_SET_INFORMATION_EX) + InputBufferLength,
                                        NULL,   // No output buffer
                                        0               // output buffer length
                                        );

                DBGPRINT(("AtmSetInfo: IOCTL (Oid %x) returned x%x\n", pSetInfo->ObjectId, status));

                if ( NT_SUCCESS(status) ) {
                        err = NO_ERROR;
                }
                else {
                        if (status == STATUS_INSUFFICIENT_RESOURCES) {
                                err = WSAEFAULT;
                        } else {
                                err = WSAEINVAL;
                        }
                }
        
        }
        while (FALSE);

        if ( ioStatusBlock != NULL ) {
                RTL_FREE_HEAP( RtlProcessHeap( ), 0, ioStatusBlock );
        }

        return err;
}


INT
AtmGetAtmObjectInformation (
    IN HANDLE TdiObjectHandle,
    IN ULONG IoControlCode,
    IN ATM_OBJECT_ID ObjectId,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
        OUT LPDWORD NumberOfBytesReturned
    )

/*++

Routine Description:

        Performs a Media-specific Get Information action to the Raw Wan driver.
        This operation is directed to either an Address Object or to a Connection
        object, according to TdiObjectHandle.

Arguments:

    TdiObjectHandle - a TDI handle to either an Address or a Connection object
        on which to perform the Set Info operation.

    IoControlCode - IOCTL_RWAN_MEDIA_SPECIFIC_XXX

    ObjectId - value to put in the ObjectId field of the Set Info structure.

        InputBuffer - Points to buffer containing context for the Object.

        InputBufferLength - Length of the above.

        OutputBuffer - place to return value

        OutputBufferLength - bytes available in OutputBuffer

        NumberOfBytesReturned - place to return bytes written

Return Value:

    INT - NO_ERROR, or a Windows Sockets error code.

--*/

{
    NTSTATUS status;
    INT err;
    PATM_QUERY_INFORMATION_EX pQueryInfo;
    PIO_STATUS_BLOCK ioStatusBlock;

        do
        {

                *NumberOfBytesReturned = 0;

                ioStatusBlock = RTL_ALLOCATE_HEAP(
                                                        RtlProcessHeap( ),
                                                        0,
                                                        sizeof(*ioStatusBlock) + sizeof(ATM_QUERY_INFORMATION_EX) + InputBufferLength
                                                        );
                
                if ( ioStatusBlock == NULL ) {
                        err = WSAENOBUFS;
                        break;
                }

                pQueryInfo = (PATM_QUERY_INFORMATION_EX)(ioStatusBlock + 1);
                pQueryInfo->ObjectId = ObjectId;
                pQueryInfo->ContextLength = InputBufferLength;

                if ( pQueryInfo->ContextLength > 0 ) {

                        RtlCopyMemory(
                                pQueryInfo->Context,
                                InputBuffer,
                                pQueryInfo->ContextLength
                                );
                }

                status = NtDeviceIoControlFile(
                                        TdiObjectHandle,
                                        NULL,   // No Event
                                        NULL,   // No completion APC
                                        NULL,   // No completion APC Context
                                        ioStatusBlock,
                                        IoControlCode,
                                        pQueryInfo,
                                        sizeof(ATM_QUERY_INFORMATION_EX) + InputBufferLength,
                                        OutputBuffer,
                                        OutputBufferLength
                                        );

                DBGPRINT(("AtmGetAtmObjInfo: IOCTL (Oid %x) returned x%x\n",
                                        pQueryInfo->ObjectId, status));

                if ( NT_SUCCESS(status) ) {
                        err = NO_ERROR;
                        *NumberOfBytesReturned = (ULONG)ioStatusBlock->Information;
                }
                else {
                        if (status == STATUS_INSUFFICIENT_RESOURCES) {
                                err = WSAEFAULT;
                        } else {
                                err = WSAEINVAL;
                        }
                }
        
        }
        while (FALSE);

        if ( ioStatusBlock != NULL ) {
                RTL_FREE_HEAP( RtlProcessHeap( ), 0, ioStatusBlock );
        }

        return err;
}

#if DBG
PVOID
MyRtlAllocateHeap(
        IN      PVOID   HeapHandle,
        IN      ULONG   Flags,
        IN      ULONG   Size,
        IN      ULONG   LineNumber
        )
{
        PVOID   pRetValue;

        pRetValue = RtlAllocateHeap(HeapHandle, Flags, Size);

#if DBG2
        DbgPrint("WSHATM: AllocHeap size %d at line %d, ret x%x\n",
                        Size, LineNumber, pRetValue);
#endif
        return (pRetValue);
}


VOID
MyRtlFreeHeap(
        IN PVOID        HeapHandle,
        IN ULONG        Flags,
        IN PVOID        MemPtr,
        IN ULONG        LineNumber
        )
{
#if DBG2
        DbgPrint("WSHATM: FreeHeap x%x, line %d\n", MemPtr, LineNumber);
#endif
        RtlFreeHeap(HeapHandle, Flags, MemPtr);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\atm\samples\atmsmpl\inc\atmsample.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    atmsample.h

Abstract:

    Common header file defined for ATM Sample client. This file defines the
    IOCTLs used for communicating with the driver

Author:

    Anil Francis Thomas (10/98)

Environment:

    Kernel \ User

Revision History:
   DChen    092499   Cleanup 

--*/
#ifndef _ATMSAMPLE__
#define _ATMSAMPLE__

#define ATMSM_SERVICE_NAME             "AtmSmDrv"
#define ATMSM_SERVICE_NAME_L           L"AtmSmDrv"

#define ATM_SAMPLE_CLIENT_DOS_NAME_L   L"\\\\.\\ATMSampleClient"
#define ATM_SAMPLE_CLIENT_DOS_NAME     "\\\\.\\ATMSampleClient"

#ifndef NSAP_ADDRESS_LEN
#define NSAP_ADDRESS_LEN               20
#endif

#define ACCESS_FROM_CTL_CODE(ctrlCode) (((ULONG)(ctrlCode & 0x0000C000)) >> 14)
#define METHOD_FROM_CTL_CODE(ctrlCode) ((ULONG)(ctrlCode & 0x0000C0003))


#define FILE_DEVICE_ATMSM              0x00009900
#define _ATMSM_CTL_CODE(function, method, access) \
          CTL_CODE(FILE_DEVICE_ATMSM, function, method, access)

//
// IOCTL function codes
//
enum _ATMSM_IOCTL
{
   DIOC_ENUMERATE_ADAPTERS, 
   DIOC_OPEN_FOR_RECV,      
   DIOC_RECV_DATA,          
   DIOC_CLOSE_RECV_HANDLE,  
   DIOC_CONNECT_TO_DSTS,    
   DIOC_SEND_TO_DSTS,                 
   DIOC_CLOSE_SEND_HANDLE,  
   ATMSM_NUM_IOCTLS
};

#define ATMSM_MIN_FUNCTION_CODE     DIOC_ENUMERATE_ADAPTERS
#define ATMSM_MAX_FUNCTION_CODE     DIOC_CLOSE_SEND_HANDLE

////////////////////////////////////////////////////////////////////
// IOCTL to enumerate adapters                                    //
////////////////////////////////////////////////////////////////////
#define IOCTL_ENUMERATE_ADAPTERS  \
        _ATMSM_CTL_CODE(DIOC_ENUMERATE_ADAPTERS, METHOD_BUFFERED, \
                                                    FILE_READ_ACCESS)

//  - IN -
//  None

//  - OUT -
// The structure contains an array of adapter ATM addresses
typedef struct _AdapterInfo
{
   ULONG   ulNumAdapters;
   UCHAR   ucLocalATMAddr[1][NSAP_ADDRESS_LEN];
} ADAPTER_INFO, *PADAPTER_INFO;

/////////////////////////////////////////////////////////////////////
// IOCTL to open the adapter for recv                              //
/////////////////////////////////////////////////////////////////////
#define IOCTL_OPEN_FOR_RECV  \
        _ATMSM_CTL_CODE(DIOC_OPEN_FOR_RECV, METHOD_BUFFERED, \
                                                    FILE_READ_ACCESS)

//  - IN -
//  structure used for opening for recv
//  Note! - Only 1 open for Recv is permitted per adapter
//  
typedef struct _OpenForRecvInfo
{
   UCHAR   ucLocalATMAddr[NSAP_ADDRESS_LEN];
} OPEN_FOR_RECV_INFO, *POPEN_FOR_RECV_INFO;

//  - OUT -
//  return is a context handle, used in read IOCTL

/////////////////////////////////////////////////////////////////////
// IOCTL to recv packets from an adapter opened for recvs          //
/////////////////////////////////////////////////////////////////////
#define IOCTL_RECV_DATA  \
        _ATMSM_CTL_CODE(DIOC_RECV_DATA, METHOD_OUT_DIRECT, \
                                                    FILE_READ_ACCESS)

//  - IN -
//  context obtained when the adapter was opened for read
//  and a buffer for reading

//  - OUT -
//  data in the the buffer


/////////////////////////////////////////////////////////////////////
// IOCTL to stop receiving                                         //
/////////////////////////////////////////////////////////////////////
#define IOCTL_CLOSE_RECV_HANDLE  \
        _ATMSM_CTL_CODE(DIOC_CLOSE_RECV_HANDLE, METHOD_BUFFERED, \
                                                    FILE_READ_ACCESS)

//  - IN -
//  context obtained when the adapter was opened for read

/////////////////////////////////////////////////////////////////////
// IOCTL to connect to destinations                                //
/////////////////////////////////////////////////////////////////////
#define IOCTL_CONNECT_TO_DSTS  \
        _ATMSM_CTL_CODE(DIOC_CONNECT_TO_DSTS, METHOD_BUFFERED, \
                                FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//  - IN -
// Connect to 1 or multiple destinations (P-P or PMP connections)
// The structure contains an array of destinations ATM addresses
//
typedef struct _ConnectInfo
{
   ULONG   bPMP;
   ULONG   ulNumDsts;
   UCHAR   ucLocalATMAddr[NSAP_ADDRESS_LEN];
   UCHAR   ucDstATMAddrs[1][NSAP_ADDRESS_LEN];
}CONNECT_INFO, *PCONNECT_INFO;

//  - OUT -
//  return is a context handle, used in send IOCTL

/////////////////////////////////////////////////////////////////////
// IOCTL to send to destinations                                   //
/////////////////////////////////////////////////////////////////////
#define IOCTL_SEND_TO_DSTS  \
        _ATMSM_CTL_CODE(DIOC_SEND_TO_DSTS, METHOD_IN_DIRECT, \
                               FILE_READ_ACCESS  | FILE_WRITE_ACCESS)

//  - IN -
//  context obtained when the adapter was opened for sends
//  - OUT -
//  a buffer and size that needs to be send


/////////////////////////////////////////////////////////////////////
// IOCTL to stop receiving                                         //
/////////////////////////////////////////////////////////////////////
#define IOCTL_CLOSE_SEND_HANDLE  \
        _ATMSM_CTL_CODE(DIOC_CLOSE_SEND_HANDLE, METHOD_BUFFERED, \
                                                    FILE_READ_ACCESS)

//  - IN -
//  context obtained when the adapter was opened for sends

#endif // _ATMSAMPLE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\naming.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       N A M I N G . C P P
//
//  Contents:   Generates Connection Names Automatically
//
//  Notes:
//
//  Author:     deonb    27 Feb 2001
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncnetcfg.h"
#include "netcon.h"
#include "netconp.h"
#include <ntddndis.h>
#include <ndisprv.h>
#include <devioctl.h>
#include <ndispnp.h>
#include "naming.h"


extern const WCHAR c_szBiNdisAtm[];
extern const WCHAR c_szInfId_MS_AtmElan[];
const WCHAR        c_szDevice[] = L"\\DEVICE\\";

//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::CIntelliName
//
//  Purpose:    Constructor
//
//  Arguments:
//      hInstance [in]  Resource instance of binary with naming.rc included
//
//      pFNDuplicateNameCheck [in]   Callback function of duplicate check. Can be NULL \
//                                   or otherwise of the following callback type:
//         + typedef BOOL FNDuplicateNameCheck
//         +              pIntelliName  [in]  CIntelliName this pointer (for HrGetPseudoMediaTypes callback)
//         +              szName        [in]  Name to check for
//         +              pncm          [out] NetCon Media Type of conflicting connection
//         +              pncms         [out] NetCon SubMedia Type of conflicting connection
//         +        return TRUE - if conflicting found or FALSE if no conflicting connection found
//
//  Returns: None        
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:      
//
CIntelliName::CIntelliName(HINSTANCE hInstance, FNDuplicateNameCheck *pFNDuplicateNameCheck)
{
    m_pFNDuplicateNameCheck = pFNDuplicateNameCheck;
    m_hInstance = hInstance;
}

//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::NameExists
//
//  Purpose:    Check if a name already exists
//
//  Arguments:
//      szName [in]  Name to check for
//      pncm   [out] NetCon Media Type of conflicting connection
//      pncms  [out] NetCon SubMedia Type of conflicting connection
//
//  Returns: TRUE if exists, FALSE if not        
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:      
//
BOOL CIntelliName::NameExists(IN LPCWSTR szName, IN OUT NETCON_MEDIATYPE *pncm, IN NETCON_SUBMEDIATYPE *pncms)
{
    if (m_pFNDuplicateNameCheck)
    {
        Assert(pncm);
        Assert(pncms);

        if (IsReservedName(szName))
        {
            return TRUE;
        }

        return (*m_pFNDuplicateNameCheck)(this, szName, pncm, pncms);
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::IsReservedName
//
//  Purpose:    Check if a name is a reserved name
//
//  Arguments:
//      szName [in]  Name to check for
//
//  Returns: TRUE if reserved, FALSE if not
//
//  Author:     deonb   12 Mar 2001
//
//  Notes:      
//
BOOL CIntelliName::IsReservedName(LPCWSTR szName)
{
    UINT  uiReservedNames[] = {IDS_RESERVED_INCOMING, 
                               IDS_RESERVED_NCW, 
                               IDS_RESERVED_HNW};

    for (int x = 0; x < celems(uiReservedNames); x++)
    {
        WCHAR szReservedName[MAX_PATH];
        int nSiz = LoadString (m_hInstance, uiReservedNames[x], szReservedName, MAX_PATH);
        if (nSiz)
        {
            if (0 == lstrcmpi(szName, szReservedName))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::GenerateNameRenameOnConflict
//
//  Purpose:    Generate a name, rename if it conflicts with an existing name
//
//  Arguments:
//      guid              [in]  GUID of connection
//      ncm               [in]  NetCon Media Type of Connection 
//      dwCharacteristics [in]  NCCF_ Characteristics of Connection (Pass 0 if you don't know)
//      szHintName        [in]  Hint of name (will use as is if not conflicting)
//      szHintType        [in]  String of NetCon Media Type
//      szName            [out] Resulting connection name - free with CoTaskMemFree
//
//  Returns: HRESULT
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:   
//
HRESULT CIntelliName::GenerateNameRenameOnConflict(IN REFGUID guid, IN NETCON_MEDIATYPE ncm, IN DWORD dwCharacteristics, IN LPCWSTR szHintName, IN LPCWSTR szHintType, OUT LPWSTR *szName)
{
    WCHAR szTemp[MAX_PATH+1];
    WCHAR szBaseName[MAX_PATH +1];

    Assert(szName)
    *szName = NULL;

    wcsncpy(szTemp, szHintName, MAX_PATH-45); // reserve last 45 bytes to include specialized info.

    BOOL fHasName = FALSE;

    DWORD dwInstance = 2;
    wcsncpy(szBaseName, szTemp, MAX_PATH);

    NETCON_MEDIATYPE ncmdup; 
    NETCON_SUBMEDIATYPE ncmsdup;
    if (NameExists(szTemp, &ncmdup, &ncmsdup))
    {
        fHasName = TRUE;

        BOOL fHasTypeAlready = FALSE;
        if ( (ncmdup == ncm) || (NCM_LAN == ncm) )
        {
            fHasTypeAlready = TRUE;
        }

        if (!fHasTypeAlready)
        {
            wsprintf(szTemp, L"%s (%s)", szBaseName, szHintType);
            Assert(wcslen(szTemp) <= MAX_PATH);
            wcsncpy(szBaseName, szTemp, MAX_PATH);
        }
        else
        {
            wsprintf(szTemp, L"%s %d", szBaseName, dwInstance);
            Assert(wcslen(szTemp) <= MAX_PATH);
            dwInstance++;
        }

        while (NameExists(szTemp, &ncmdup, &ncmsdup) && (dwInstance < 65535) )
        {
            wsprintf(szTemp, L"%s %d", szBaseName, dwInstance);
            Assert(wcslen(szTemp) <= MAX_PATH);
            dwInstance++;
        }

        if ( (dwInstance >= 65535) && NameExists(szTemp, &ncmdup, &ncmsdup) )
        {
            fHasName = FALSE;
        }
    }
    else
    {
        fHasName = TRUE;
    }

    if (fHasName)
    {
        HRESULT hr = HrCoTaskMemAllocAndDupSz(szTemp, szName);
        return hr;
    }
    else
    {
        return E_FAIL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::GenerateNameFromResource
//
//  Purpose:    Generate a name, rename if it conflicts with an existing name
//
//  Arguments:
//      guid              [in]  GUID of connection
//      ncm               [in]  NetCon Media Type of Connection 
//      dwCharacteristics [in]  NCCF_ Characteristics of Connection (Pass 0 if you don't know)
//      szHintName        [in]  Hint of name (will use as is if not conflicting)
//      uiNameID          [in]  Resource id of default name
//      uiTypeId          [in]  Resource id of default type
//      szName            [out] Resulting connection name - free with CoTaskMemFree
//
//  Returns: HRESULT
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:   
//
HRESULT CIntelliName::GenerateNameFromResource(IN REFGUID guid, IN NETCON_MEDIATYPE ncm, IN DWORD dwCharacteristics, IN LPCWSTR szHint, IN UINT uiNameID, IN UINT uiTypeId, OUT LPWSTR *szName)
{
    Assert(szName);
    *szName = NULL;

    WCHAR szHintName[MAX_PATH+1];
    WCHAR szTypeName[MAX_PATH+1];

    if (!szHint || *szHint == L'\0')
    {
        int nSiz = LoadString (m_hInstance, uiNameID, szHintName, MAX_PATH);
        AssertSz(nSiz, "Resource string not found");
    }
    else
    {
        wcsncpy(szHintName, szHint, MAX_PATH);
    }

    int nSiz = LoadString (m_hInstance, uiTypeId, szTypeName, MAX_PATH);
    AssertSz(nSiz, "Resource string not found");
    
    return GenerateNameRenameOnConflict(guid, ncm, dwCharacteristics, szHintName, szTypeName, szName);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::HrGetPseudoMediaTypes
//
//  Purpose:    Generate a name, rename if it conflicts with an existing name
//
//  Arguments:
//      guid     [in]  GUID of connection
//      pncm     [out] Pseudo-NetCon Media Type of Connection (Only NCM_PHONE or NCM_LAN)
//      pncms    [out] SubMedia Type for LAN connections
//
//  Returns: HRESULT
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:   
//
HRESULT CIntelliName::HrGetPseudoMediaTypes(IN REFGUID guid, OUT NETCON_MEDIATYPE *pncm, OUT NETCON_SUBMEDIATYPE* pncms)
{
    Assert(pncms);
    Assert(pncm);
    Assert(guid != GUID_NULL);

    HRESULT hr;

    *pncms = NCSM_NONE;

    INetCfg* pNetCfg;
    hr = CoCreateInstance(
            CLSID_CNetCfg,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            IID_INetCfg,
            reinterpret_cast<LPVOID *>(&pNetCfg));
    if (SUCCEEDED(hr))
    {
        hr = pNetCfg->Initialize(NULL);
        if (SUCCEEDED(hr))
        {
            CIterNetCfgComponent nccIter(pNetCfg, &GUID_DEVCLASS_NET);
            INetCfgComponent* pnccAdapter = NULL;
            BOOL fFound = FALSE;

            while (!fFound && SUCCEEDED(hr) &&
                   (S_OK == (hr = nccIter.HrNext(&pnccAdapter))))
            {
                GUID guidDev;
                hr = pnccAdapter->GetInstanceGuid(&guidDev);

                if (S_OK == hr)
                {
                    if (guid == guidDev)
                    {
                        hr = HrIsLanCapableAdapter(pnccAdapter);
                        Assert(SUCCEEDED(hr));
                        if (SUCCEEDED(hr))
                        {
                            fFound = TRUE;
                            if (S_FALSE == hr)
                            {
                                *pncm = NCM_PHONE;
                            } 
                            else if (S_OK == hr)
                            {
                                *pncm = NCM_LAN;

                                BOOL            bRet;

                                DWORD dwMediaType;
                                DWORD dwMediaTypeSize = sizeof(DWORD);
                                hr = HrQueryNDISAdapterOID(guid, 
                                                          OID_GEN_PHYSICAL_MEDIUM, 
                                                          &dwMediaTypeSize,
                                                          &dwMediaType);
                                if (S_OK == hr)
                                {
                                    switch (dwMediaType)
                                    {
                                        case NdisPhysicalMedium1394:
                                            *pncms = NCSM_1394;
                                            break;
                                        case NdisPhysicalMediumWirelessLan:
                                        case NdisPhysicalMediumWirelessWan:
                                            *pncms = NCSM_WIRELESS;
                                            break;
                                        default:
                                            hr = S_FALSE;
                                            break;
                                    }
                                }
                                
                                if (S_OK != hr) // Couldn't determine the Physical Media type. Try bindings next.
                                {
                                    HRESULT hrPhysicalMedia = hr;

                                    *pncms = NCSM_LAN;

                                    INetCfgComponentBindings* pnccb;
                                    hr = pnccAdapter->QueryInterface(IID_INetCfgComponentBindings,
                                                                       reinterpret_cast<LPVOID *>(&pnccb));
                                    if (SUCCEEDED(hr))
                                    {
                                        hr = pnccb->SupportsBindingInterface(NCF_UPPER, c_szBiNdisAtm);
                                        if (S_OK == hr)
                                        {
                                            *pncms = NCSM_ATM;
                                        }
                                        pnccb->Release();
                                    }

                                    if (NCSM_ATM != *pncms)
                                    {
                                        // Not ATM
                                        PWSTR pszwCompId;
                                        hr = pnccAdapter->GetId(&pszwCompId);
                                        if (SUCCEEDED(hr) && (0 == lstrcmpiW(c_szInfId_MS_AtmElan, pszwCompId)))
                                        {
                                            // ATM Elan
                                            *pncms = NCSM_ELAN;

                                            CoTaskMemFree(pszwCompId);
                                        }
                                    }

                                    if ( (FAILED(hrPhysicalMedia)) && 
                                         (NCSM_LAN == *pncms) )
                                    {
                                        // Couldn't determine anything specific from the bindings.
                                        // Return the hr from the Physical Media call if it was an error
                                        hr = hrPhysicalMedia;
                                    }
                                }
                            } 
                        } // HrIsLanCapableAdapter SUCCEEDED
                    } // guid == guidDev
                } // SUCCEEDED(pnccAdapter->GetInstanceGuid(&guidDev)
                else
                {
                    AssertSz(FALSE, "Could not get instance GUID for Adapter");
                }
                pnccAdapter->Release();
            } // while loop

            HRESULT hrT = pNetCfg->Uninitialize();
            TraceError("INetCfg failed to uninitialize", hrT);
        } // SUCCEEDED(pNetConfig->Initialize(NULL))
        pNetCfg->Release();
    } // SUCCEEDED(CoCreateInstance(pNetCfg))
    else
    {
        AssertSz(FALSE, "Could not create INetCfg");
    }

    TraceErrorOptional("HrGetPseudoMediaTypes", hr, (S_FALSE == hr));

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::GenerateName
//
//  Purpose:    Generate a name based on a hint
//
//  Arguments:
//      guid              [in] GUID of connection
//      ncm               [in] NetCon Media Type of Connection
//      dwCharacteristics [in]  NCCF_ Characteristics of Connection (Pass 0 if you don't know)
//      szHintName        [in]  Hint of name (will use as is if not conflicting)
//      szName            [out] Resulting connection name - free with CoTaskMemFree
//
//  Returns: HRESULT
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:   
//
HRESULT CIntelliName::GenerateName(IN REFGUID guid, IN NETCON_MEDIATYPE ncm, IN DWORD dwCharacteristics, IN LPCWSTR szHint, OUT LPWSTR * szName)
{
    Assert(szName);
    *szName = NULL;
    
    HRESULT hr = S_OK;

    if (dwCharacteristics & NCCF_INCOMING_ONLY)
    {
        WCHAR szIncomingName[MAX_PATH];
        int nSiz = LoadString(m_hInstance, IDS_DEFAULT_IncomingName, szIncomingName, MAX_PATH);
        AssertSz(nSiz, "Resource string IDS_TO_THE_INTERNET not found");
        if (nSiz)
        {
            hr = HrCoTaskMemAllocAndDupSz(szIncomingName, szName);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        switch (ncm)
        { 
            case NCM_NONE:
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_IncomingName, IDS_DEFAULT_IncomingName_Type, szName);
                break;
            case NCM_ISDN:
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_ISDNName, IDS_DEFAULT_ISDNName_Type, szName);
                break;
            case NCM_DIRECT: 
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_DIRECTName, IDS_DEFAULT_DIRECTName_Type, szName);
                break;
            case NCM_PHONE: 
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_PHONEName, IDS_DEFAULT_PHONEName_Type, szName);
                break;
            case NCM_TUNNEL: 
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_VPNName, IDS_DEFAULT_VPNName_Type, szName);
                break;
            case NCM_PPPOE: 
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_PPPOEName, IDS_DEFAULT_PPPOEName_Type, szName);
                break;
            case NCM_BRIDGE: 
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_BRIDGEName, IDS_DEFAULT_BRIDGEName_Type, szName);
                break;
            case NCM_SHAREDACCESSHOST_LAN:
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_SAHLANName, IDS_DEFAULT_SAHLANName_Type, szName);
                break;
            case NCM_SHAREDACCESSHOST_RAS: 
                hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_SAHRASName, IDS_DEFAULT_SAHRASName_Type, szName);
                break;
            case NCM_LAN: 
                NETCON_MEDIATYPE ncmCheck;
                NETCON_SUBMEDIATYPE pncms;
                {
                    DWORD dwRetries = 15;
                    HRESULT hrT;
                    do
                    {
                        hrT = HrGetPseudoMediaTypes(guid, &ncmCheck, &pncms);
                        if (FAILED(hrT))
                        {
                            Sleep(500); // This is probably being called during device install, so give the adapter some
                                        // time to get itself enabled first.

                            if (dwRetries > 1)
                            {
                                TraceTag(ttidError, "HrGetPseudoMediaTypes failed during device name initialization. Retrying...");
                            }
                            else
                            {
                                TraceTag(ttidError, "HrGetPseudoMediaTypes failed during device name initialization. Giving up.");
                            }
                                
                        }
                    } while (FAILED(hrT) && --dwRetries);

                    if (SUCCEEDED(hrT))
                    {
                        AssertSz(ncmCheck == NCM_LAN, "This LAN adapter thinks it's something else");
                    }
                    else
                    {
                        pncms = NCSM_LAN; // If we run out of time, just give up and assume LAN.
                        TraceTag(ttidError, "Could not determine the exact Media SubType for this adapter. Assuming LAN (and naming it such).");
                    }

                    switch (pncms)
                    {
                        case NCSM_NONE:
                            AssertSz(FALSE, "LAN Connections should not be NCSM_NONE");
                            hr = E_FAIL;
                            break;
                        case NCSM_LAN:
                            hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_LANName, IDS_DEFAULT_LANName_Type, szName);
                            break;
                        case NCSM_ATM:
                            hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_ATMName, IDS_DEFAULT_ATMName_Type, szName);
                            break;
                        case NCSM_ELAN:
                            hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_ELANName, IDS_DEFAULT_ELANName_Type, szName);
                            break;
                        case NCSM_WIRELESS:
                            hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_WirelessName, IDS_DEFAULT_WirelessName_Type, szName);
                            break;
                        case NCSM_1394:
                            hr = GenerateNameFromResource(guid, ncm, dwCharacteristics, szHint, IDS_DEFAULT_1394Name, IDS_DEFAULT_1394Name_Type, szName);
                            break;
                        default:
                            AssertSz(FALSE, "Unknown submedia type");
                            hr = E_FAIL;
                            break;
                    }
                }
                break;
            default:
                AssertSz(FALSE, "Unknown media type");
                hr= E_FAIL;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::GenerateInternetName
//
//  Purpose:    Generate a name with " to the Internet" appened to it
//
//  Arguments:
//      guid              [in] GUID of connection
//      ncm               [in] NetCon Media Type of Connection
//      dwCharacteristics [in]  NCCF_ Characteristics of Connection (Pass 0 if you don't know)
//      szName            [out] Resulting connection name - free with CoTaskMemFree
//
//  Returns: HRESULT
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:   Will append " to the Internet" to a name
//
HRESULT CIntelliName::GenerateInternetName(REFGUID guid, NETCON_MEDIATYPE ncm, DWORD dwCharacteristics, OUT LPWSTR * szName)
{
    LPWSTR szTmpName;
    WCHAR szBuffer[MAX_PATH];
    WCHAR szHint[MAX_PATH];
    HRESULT hr = E_FAIL;

    CIntelliName IntelliNameNoDupCheck(m_hInstance, NULL); // Generate the original name 
    hr = IntelliNameNoDupCheck.GenerateName(guid, ncm, dwCharacteristics, szHint, &szTmpName);
    if (SUCCEEDED(hr))
    {
        int nSiz = LoadString(m_hInstance, IDS_TO_THE_INTERNET, szBuffer, MAX_PATH);
        AssertSz(nSiz, "Resource string IDS_TO_THE_INTERNET not found");
        if (nSiz)
        {
            wcsncpy(szHint, szTmpName, MAX_PATH - nSiz);
            wcsncat(szHint, szBuffer, MAX_PATH);
            CoTaskMemFree(szTmpName);

            return GenerateName(guid, ncm, dwCharacteristics, szHint, szName);
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::GenerateHomeNetName
//
//  Purpose:    Generate a name with " on my Home Network" appened to it
//
//  Arguments:
//      guid              [in] GUID of connection
//      ncm               [in] NetCon Media Type of Connection
//      dwCharacteristics [in]  NCCF_ Characteristics of Connection (Pass 0 if you don't know)
//      szName            [out] Resulting connection name - free with CoTaskMemFree
//
//  Returns: HRESULT
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:   Will append " on my Home Network" to a name
//
HRESULT CIntelliName::GenerateHomeNetName(REFGUID guid, NETCON_MEDIATYPE ncm, DWORD dwCharacteristics, OUT LPWSTR * szName)
{
    LPWSTR szTmpName;
    WCHAR szBuffer[MAX_PATH];
    WCHAR szHint[MAX_PATH];
    HRESULT hr = E_FAIL;

    CIntelliName IntelliNameNoDupCheck(m_hInstance, NULL); // Generate the original name 
    hr = IntelliNameNoDupCheck.GenerateName(guid, ncm, dwCharacteristics, szHint, &szTmpName);
    if (SUCCEEDED(hr))
    {
        int nSiz = LoadString(m_hInstance, IDS_ON_THE_HOMENET, szBuffer, MAX_PATH);
        AssertSz(nSiz, "Resource string IDS_ON_THE_HOMENET not found");
        if (nSiz)
        {
            wcsncpy(szHint, szTmpName, MAX_PATH - nSiz);
            wcsncat(szHint, szBuffer, MAX_PATH);
            CoTaskMemFree(szTmpName);

            return GenerateName(guid, ncm, dwCharacteristics, szHint, szName);
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   OpenDevice
//
//  Purpose:    Open a Driver
//
//  Arguments:
//      DeviceName [in]   Name of device
//
//  Returns: HANDLE of Device or NULL 
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:  Use GetLastError() for error info
//
HANDLE  OpenDevice(IN	PUNICODE_STRING	DeviceName)
{
	OBJECT_ATTRIBUTES	ObjAttr;
	NTSTATUS			Status;
	IO_STATUS_BLOCK		IoStsBlk;
	HANDLE				Handle;

	InitializeObjectAttributes(&ObjAttr,
							   DeviceName,
							   OBJ_CASE_INSENSITIVE,
							   NULL,
							   NULL);

	Status = NtOpenFile(&Handle,
						FILE_GENERIC_READ | FILE_GENERIC_WRITE,
						&ObjAttr,
						&IoStsBlk,
						FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
						FILE_SYNCHRONOUS_IO_NONALERT);
	if (Status != STATUS_SUCCESS)
	{
		SetLastError(RtlNtStatusToDosError(Status));
	}
	return(Handle);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrQueryDeviceOIDByName
//
//  Purpose:    Query an driver for an IOCTL & OID
//
//  Arguments:
//      Device      [in]     Name of device
//      NDIS_OID    [in]     OID to query for
//      pnSize      [in out] pnSize - size of buffer
//      pBuffer     [out]    Buffer
//
//  Returns: HRESULT
//
//  Author:     deonb   4 April 2001
//
//  Notes: 
//
HRESULT HrQueryDeviceOIDByName(IN     LPCWSTR         szDeviceName,
                               IN     DWORD           dwIoControlCode,
                               IN     ULONG           Oid,
                               IN OUT LPDWORD         pnSize,
                               OUT    LPVOID          pbValue)
{
    HRESULT hr = S_OK;
    NDIS_STATISTICS_VALUE StatsBuf;
    HANDLE  hDevice;
    BOOL    fResult = FALSE;

    UNICODE_STRING  ustrDevice;
    ::RtlInitUnicodeString(&ustrDevice, szDeviceName);

    Assert(pbValue);
    ZeroMemory(pbValue, *pnSize);
    
    hDevice = OpenDevice(&ustrDevice);

    if (hDevice != NULL)
    {
        ULONG  cb;

        DWORD dwStatsBufLen = sizeof(NDIS_STATISTICS_VALUE) - sizeof(UCHAR) + *pnSize;
        PNDIS_STATISTICS_VALUE pStatsBuf = reinterpret_cast<PNDIS_STATISTICS_VALUE>(new BYTE[dwStatsBufLen]);
        if (pStatsBuf)
        {
            fResult = DeviceIoControl(hDevice,
                                      dwIoControlCode,                  // IOCTL code
                                      &Oid,                             // input buffer
                                      sizeof(ULONG),                    // input buffer size
                                      pStatsBuf,                        // output buffer
                                      dwStatsBufLen,                    // output buffer size
                                      &cb,                              // bytes returned
                                      NULL);                            // OVERLAPPED structure

            if (fResult)
            {
                *pnSize = cb;
                if (0 == cb)
                {
                    hr = S_FALSE;
                }
                else
                {
                    if (pStatsBuf->DataLength > *pnSize)
                    {
                        AssertSz(FALSE, "Pass a larger buffer for this OID");
                        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                        *pnSize = 0;
                    }
                    else
                    {
                        memcpy(pbValue, &(pStatsBuf->Data), pStatsBuf->DataLength);
                    }
                }
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
            delete pStatsBuf;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        
        CloseHandle(hDevice);
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr(ttidError, FAL, hr, S_FALSE == hr, "HrQueryDeviceOIDByName could not read the device properties for device %S", szDeviceName);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrQueryNDISAdapterOID
//
//  Purpose:    Query an NDIS Driver for an OID
//
//  Arguments:
//      Device      [in]     Name of device
//      NDIS_OID    [in]     OID to query for
//      pnSize      [in out] pnSize - size of buffer
//      pBuffer     [out]    Buffer
//
//  Returns: HRESULT
//
//  Author:     deonb   4 April 2001
//
//  Notes: 
//

HRESULT HrQueryNDISAdapterOID(IN     REFGUID         guidId,
                              IN     NDIS_OID        Oid,
                              IN OUT LPDWORD         pnSize,
                              OUT    LPVOID          pbValue)
{
    WCHAR  szDeviceName[c_cchGuidWithTerm + celems(c_szDevice)];

    wcscpy(szDeviceName, c_szDevice);
    ::StringFromGUID2(guidId, szDeviceName + (celems(c_szDevice)-1), c_cchGuidWithTerm);
    
    Assert(wcslen(szDeviceName) < c_cchGuidWithTerm + celems(c_szDevice));
    
    return HrQueryDeviceOIDByName(szDeviceName, IOCTL_NDIS_QUERY_SELECTED_STATS, Oid, pnSize, pbValue);
}
                         
//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::IsMediaWireless
//
//  Purpose:    Queries a LAN Card to see if it's 802.1x
//
//  Arguments:
//      gdDevice [in] GUID of Network Card
//  
//  Returns:    TRUE if WireLess, FALSE if not
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:
//
BOOL IsMediaWireless(NETCON_MEDIATYPE ncm, const GUID &gdDevice)
{
    BOOL            bRet;

    Assert(gdDevice != GUID_NULL);

    bRet = FALSE;
    // Prime the structure
    
    switch( ncm ) 
    {
        case NCM_LAN:
            // Retrieve the statistics
   
            DWORD dwMediaType;
            DWORD dwMediaTypeSize = sizeof(dwMediaType);
            HRESULT hr = HrQueryNDISAdapterOID(gdDevice, 
                                      OID_GEN_PHYSICAL_MEDIUM, 
                                      &dwMediaTypeSize,
                                      &dwMediaType);
            if (SUCCEEDED(hr))
            {
               bRet = (dwMediaType == NdisPhysicalMediumWirelessLan) ||
                      (dwMediaType == NdisPhysicalMediumWirelessWan);
            }
    }

    return bRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CIntelliName::IsMedia1394
//
//  Purpose:    Queries a LAN Card to see if it's 1394 (FireWire / iLink)
//
//  Arguments:
//      gdDevice [in] GUID of Network Card
//
//  Returns:    TRUE if WireLess, FALSE if not
//
//  Author:     deonb   27 Feb 2001
//
//  Notes:
//
BOOL IsMedia1394(NETCON_MEDIATYPE ncm, const GUID &gdDevice)
{
    BOOL            bRet;

    Assert(gdDevice != GUID_NULL);

    bRet = FALSE;
    // Prime the structure
    
    switch( ncm ) 
    {
        case NCM_LAN:
            // Retrieve the statistics
            DWORD dwMediaType;
            DWORD dwMediaTypeSize = sizeof(DWORD);
            HRESULT hr = HrQueryNDISAdapterOID(gdDevice, 
                                      OID_GEN_PHYSICAL_MEDIUM, 
                                      &dwMediaTypeSize,
                                      &dwMediaType);
            if (SUCCEEDED(hr))
            {
               bRet = (dwMediaType == NdisPhysicalMedium1394);
            }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\afilestr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A F I L E S T R . C P P
//
//  Contents:   Strings found in the answer file.
//
//  Notes:
//
//  Author:     kumarp   17 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

// __declspec(selectany) tells the compiler that the string should be in
// its own COMDAT.  This allows the linker to throw out unused strings.
// If we didn't do this, the COMDAT for this module would reference the
// strings so they wouldn't be thrown out.
//
#define CONST_GLOBAL    extern const DECLSPEC_SELECTANY

// ----------------------------------------------------------------------
// General

CONST_GLOBAL WCHAR c_szAfNone[]                         = L"None";
CONST_GLOBAL WCHAR c_szAfUnknown[]                      = L"Unknown";
CONST_GLOBAL WCHAR c_szAfListDelimiter[]                = L",";

CONST_GLOBAL WCHAR c_szAfDisplay[]                      = L"Display";
CONST_GLOBAL WCHAR c_szAfAllowChanges[]                 = L"AllowChanges";
CONST_GLOBAL WCHAR c_szAfOnlyOnError[]                  = L"OnlyOnError";

CONST_GLOBAL WCHAR c_szAfParams[]                       = L"params.";

CONST_GLOBAL WCHAR c_szAfSectionIdentification[]        = L"Identification";
CONST_GLOBAL WCHAR c_szAfSectionNetAdapters[]           = L"NetAdapters";
CONST_GLOBAL WCHAR c_szAfSectionNetProtocols[]          = L"NetProtocols";
CONST_GLOBAL WCHAR c_szAfSectionNetServices[]           = L"NetServices";
CONST_GLOBAL WCHAR c_szAfSectionNetClients[]            = L"NetClients";
CONST_GLOBAL WCHAR c_szAfSectionNetBindings[]           = L"NetBindings";



CONST_GLOBAL WCHAR c_szAfAdapterSections[]              = L"AdapterSections";
CONST_GLOBAL WCHAR c_szAfSpecificTo[]                   = L"SpecificTo";
CONST_GLOBAL WCHAR c_szAfCleanup[]                      = L"CleanUp";

CONST_GLOBAL WCHAR c_szAfInfid[]                        = L"InfID";
CONST_GLOBAL WCHAR c_szAfInfidReal[]                    = L"InfIDReal";
CONST_GLOBAL WCHAR c_szAfInstance[]                     = L"Instance";

CONST_GLOBAL WCHAR c_szAfInstallDefaultComponents[]     = L"InstallDefaultComponents";

// ----------------------------------------------------------------------
// ZAW related
//
CONST_GLOBAL WCHAR c_szAfNetComponentsToRemove[]        = L"NetComponentsToRemove";

// ----------------------------------------------------------------------
// OEM upgrade related
//
CONST_GLOBAL WCHAR c_szAfOemSection[]                   = L"OemSection";
CONST_GLOBAL WCHAR c_szAfOemDir[]                       = L"OemDir";
CONST_GLOBAL WCHAR c_szAfOemDllToLoad[]                 = L"OemDllToLoad";
CONST_GLOBAL WCHAR c_szAfOemInf[]                       = L"OemInfFile";
CONST_GLOBAL WCHAR c_szAfSkipInstall[]                  = L"SkipInstall";

// ----------------------------------------------------------------------
// Network upgrade related
//
CONST_GLOBAL WCHAR c_szAfSectionNetworking[]            = L"Networking";
CONST_GLOBAL WCHAR c_szAfUpgradeFromProduct[]           = L"UpgradeFromProduct";
CONST_GLOBAL WCHAR c_szAfBuildNumber[]                  = L"BuildNumber";

CONST_GLOBAL WCHAR c_szAfProcessPageSections[]          = L"ProcessPageSections";

CONST_GLOBAL WCHAR c_szAfNtServer[]                     = L"WindowsNTServer";
CONST_GLOBAL WCHAR c_szAfNtSbServer[]                   = L"WindowsNTSBServer";
CONST_GLOBAL WCHAR c_szAfNtWorkstation[]                = L"WindowsNTWorkstation";
CONST_GLOBAL WCHAR c_szAfWin95[]                        = L"Windows95";
CONST_GLOBAL WCHAR c_szAfDisableServices[]              = L"DisableServices";

CONST_GLOBAL CHAR c_szaOemUpgradeFunction[]             = "HrOemUpgrade";

CONST_GLOBAL WCHAR c_szRegKeyAnswerFileMap[]            = L"SYSTEM\\Setup\\AnswerFileMap";

CONST_GLOBAL WCHAR c_szAfPreUpgradeRouter[]             = L"PreUpgradeRouter";
CONST_GLOBAL WCHAR c_szAfNwSapAgentParams[]             = L"Sap.Parameters";
CONST_GLOBAL WCHAR c_szAfIpRipParameters[]              = L"IpRip.Parameters";
CONST_GLOBAL WCHAR c_szAfDhcpRelayAgentParameters[]     = L"RelayAgent.Parameters";
CONST_GLOBAL WCHAR c_szAfRadiusParameters[]             = L"Radius.Parameters";


CONST_GLOBAL WCHAR c_szAfMiscUpgradeData[]              = L"MiscUpgradeData";
CONST_GLOBAL WCHAR c_szAfSapAgentUpgrade[]              = L"SapAgentUpgrade";

CONST_GLOBAL WCHAR c_szAfServiceStartTypes[]            = L"ServiceStartTypes";
CONST_GLOBAL WCHAR c_szAfTapiSrvRunInSeparateInstance[] = L"TapiServerRunInSeparateInstance";

// ----------------------------------------------------------------------
// Net card related

//Hardware Bus-Types

CONST_GLOBAL WCHAR c_szAfInfIdWildCard[]                = L"*";

CONST_GLOBAL WCHAR c_szAfNetCardAddr[]                  = L"NetCardAddress";

CONST_GLOBAL WCHAR c_szAfBusType[]                      = L"BusType";

CONST_GLOBAL WCHAR c_szAfBusInternal[]                  = L"Internal";
CONST_GLOBAL WCHAR c_szAfBusIsa[]                       = L"ISA";
CONST_GLOBAL WCHAR c_szAfBusEisa[]                      = L"EISA";
CONST_GLOBAL WCHAR c_szAfBusMicrochannel[]              = L"MCA";
CONST_GLOBAL WCHAR c_szAfBusTurbochannel[]              = L"TurboChannel";
CONST_GLOBAL WCHAR c_szAfBusPci[]                       = L"PCI";
CONST_GLOBAL WCHAR c_szAfBusVme[]                       = L"VME";
CONST_GLOBAL WCHAR c_szAfBusNu[]                        = L"Nu";
CONST_GLOBAL WCHAR c_szAfBusPcmcia[]                    = L"PCMCIA";
CONST_GLOBAL WCHAR c_szAfBusC[]                         = L"C";
CONST_GLOBAL WCHAR c_szAfBusMpi[]                       = L"MPI";
CONST_GLOBAL WCHAR c_szAfBusMpsa[]                      = L"MPSA";
CONST_GLOBAL WCHAR c_szAfBusProcessorinternal[]         = L"ProcessorInternal";
CONST_GLOBAL WCHAR c_szAfBusInternalpower[]             = L"InternalPower";
CONST_GLOBAL WCHAR c_szAfBusPnpisa[]                    = L"PNPISA";

//Net card parameters
CONST_GLOBAL WCHAR c_szAfAdditionalParams[]             = L"AdditionalParams";
CONST_GLOBAL WCHAR c_szAfPseudoAdapter[]                = L"PseudoAdapter";
CONST_GLOBAL WCHAR c_szAfDetect[]                       = L"Detect";
CONST_GLOBAL WCHAR c_szAfIoAddr[]                       = L"IOAddr";
CONST_GLOBAL WCHAR c_szAfIrq[]                          = L"IRQ";
CONST_GLOBAL WCHAR c_szAfDma[]                          = L"DMA";
CONST_GLOBAL WCHAR c_szAfMem[]                          = L"MEM";
CONST_GLOBAL WCHAR c_szAfTransceiverType[]              = L"TransceiverType";
CONST_GLOBAL WCHAR c_szAfSlotNumber[]                   = L"SlotNumber";
CONST_GLOBAL WCHAR c_szAfConnectionName[]               = L"ConnectionName";

//Transceiver Types
CONST_GLOBAL WCHAR c_szAfThicknet[]                     = L"ThickNet";
CONST_GLOBAL WCHAR c_szAfThinnet[]                      = L"ThinNet";
CONST_GLOBAL WCHAR c_szAfTp[]                           = L"TP";
CONST_GLOBAL WCHAR c_szAfAuto[]                         = L"Auto";

// Netcard upgrade specific
CONST_GLOBAL WCHAR c_szAfPreUpgradeInstance[]           = L"PreUpgradeInstance";


// ----------------------------------------------------------------------
// Identification Page related

CONST_GLOBAL WCHAR c_szAfComputerName[]                 = L"ComputerName";
CONST_GLOBAL WCHAR c_szAfJoinWorkgroup[]                = L"JoinWorkgroup";
CONST_GLOBAL WCHAR c_szAfJoinDomain[]                   = L"JoinDomain";

CONST_GLOBAL WCHAR c_szAfDomainAdmin[]                  = L"DomainAdmin";
CONST_GLOBAL WCHAR c_szAfDomainAdminPassword[]          = L"DomainAdminPassword";
CONST_GLOBAL WCHAR c_szAfMachineObjectOU[]              = L"MachineObjectOU";
CONST_GLOBAL WCHAR c_szAfUnsecureJoin[]                 = L"DoOldStyleDomainJoin";

// For Secure Domain Join Support, the computer account password
CONST_GLOBAL WCHAR c_szAfComputerPassword[]             = L"ComputerPassword";


// ----------------------------------------------------------------------
// Protocols related

//TCPIP
CONST_GLOBAL WCHAR c_szAfEnableSecurity[]               = L"EnableSecurity";
CONST_GLOBAL WCHAR c_szAfEnableICMPRedirect[]           = L"EnableICMPRedirect";
CONST_GLOBAL WCHAR c_szAfDeadGWDetectDefault[]          = L"DeadGWDetectDefault";
CONST_GLOBAL WCHAR c_szAfDontAddDefaultGatewayDefault[] = L"DontAddDefaultGatewayDefault";

CONST_GLOBAL WCHAR c_szAfIpAllowedProtocols[]           = L"IpAllowedProtocols";
CONST_GLOBAL WCHAR c_szAfTcpAllowedPorts[]              = L"TcpAllowedPorts";
CONST_GLOBAL WCHAR c_szAfUdpAllowedPorts[]              = L"UdpAllowedPorts";

CONST_GLOBAL WCHAR c_szDatabasePath[]                   = L"DatabasePath";
CONST_GLOBAL WCHAR c_szAfForwardBroadcasts[]            = L"ForwardBroadcasts";
CONST_GLOBAL WCHAR c_szAfPPTPTcpMaxDataRetransmissions[]= L"PPTPTcpMaxDataRetransmissions";
CONST_GLOBAL WCHAR c_szAfUseZeroBroadcast[]             = L"UseZeroBroadcast";
CONST_GLOBAL WCHAR c_szAfArpAlwaysSourceRoute[]         = L"ArpAlwaysSourceRoute";
CONST_GLOBAL WCHAR c_szAfArpCacheLife[]                 = L"ArpCacheLife";
CONST_GLOBAL WCHAR c_szAfArpTRSingleRoute[]             = L"ArpTRSingleRoute";
CONST_GLOBAL WCHAR c_szAfArpUseEtherSNAP[]              = L"ArpUseEtherSNAP";
CONST_GLOBAL WCHAR c_szAfDefaultTOS[]                   = L"DefaultTOS";
CONST_GLOBAL WCHAR c_szDefaultTTL[]                     = L"DefaultTTL";
CONST_GLOBAL WCHAR c_szEnableDeadGWDetect[]             = L"EnableDeadGWDetect";
CONST_GLOBAL WCHAR c_szEnablePMTUBHDetect[]             = L"EnablePMTUBHDetect";
CONST_GLOBAL WCHAR c_szEnablePMTUDiscovery[]            = L"EnablePMTUDiscovery";
CONST_GLOBAL WCHAR c_szForwardBufferMemory[]            = L"ForwardBufferMemory";
CONST_GLOBAL WCHAR c_szHostname[]                       = L"HostName";
CONST_GLOBAL WCHAR c_szIGMPLevel[]                      = L"IGMPLevel";
CONST_GLOBAL WCHAR c_szKeepAliveInterval[]              = L"KeepAliveInterval";
CONST_GLOBAL WCHAR c_szKeepAliveTime[]                  = L"KeepAliveTime";
CONST_GLOBAL WCHAR c_szMaxForwardBufferMemory[]         = L"MaxForwardBufferMemory";
CONST_GLOBAL WCHAR c_szMaxForwardPending[]              = L"MaxForwardPending";
CONST_GLOBAL WCHAR c_szMaxNumForwardPackets[]           = L"MaxNumForwardPackets";
CONST_GLOBAL WCHAR c_szMaxUserPort[]                    = L"MaxUserPort";
CONST_GLOBAL WCHAR c_szMTU[]                            = L"MTU";
CONST_GLOBAL WCHAR c_szNumForwardPackets[]              = L"NumForwardPackets";
CONST_GLOBAL WCHAR c_szTcpMaxConnectRetransmissions[]   = L"TcpMaxConnectRetransmissions";
CONST_GLOBAL WCHAR c_szTcpMaxDataRetransmissions[]      = L"TcpMaxDataRetransmissions";
CONST_GLOBAL WCHAR c_szTcpNumConnections[]              = L"TcpNumConnections";
CONST_GLOBAL WCHAR c_szTcpTimedWaitDelay []             = L"TcpTimedWaitDelay";
CONST_GLOBAL WCHAR c_szTcpUseRFC1122UrgentPointer[]     = L"TcpUseRFC1122UrgentPointer";
CONST_GLOBAL WCHAR c_szDefaultGateway[]                 = L"DefaultGateway";
CONST_GLOBAL WCHAR c_szDomain[]                         = L"Domain";
CONST_GLOBAL WCHAR c_szEnableSecurityFilters[]          = L"EnableSecurityFilters";
CONST_GLOBAL WCHAR c_szNameServer[]                     = L"NameServer";
CONST_GLOBAL WCHAR c_szMaxFreeTcbs[]                    = L"MaxFreeTcbs";
CONST_GLOBAL WCHAR c_szMaxHashTableSize[]               = L"MaxHashTableSize";
CONST_GLOBAL WCHAR c_szEnableAddrMaskReply[]            = L"EnableAddrMaskReply";
CONST_GLOBAL WCHAR c_szPersistentRoutes[]               = L"PersistentRoutes";
CONST_GLOBAL WCHAR c_szArpCacheMinReferencedLife[]      = L"ArpCacheMinReferencedLife";
CONST_GLOBAL WCHAR c_szArpRetryCount[]                  = L"ArpRetryCount";
CONST_GLOBAL WCHAR c_szTcpMaxConnectresponseRetransmissions[] = L"TcpMaxConnectresponseRetransmissions";
CONST_GLOBAL WCHAR c_szTcpMaxDupAcks[]                  = L"TcpMaxDupAcks";
CONST_GLOBAL WCHAR c_szSynAttackProtect[]               = L"SynAttackProtect";
CONST_GLOBAL WCHAR c_szTCPMaxPortsExhausted[]           = L"TCPMaxPortsExhausted";
CONST_GLOBAL WCHAR c_szTCPMaxHalfOpen[]                 = L"TCPMaxHalfOpen";
CONST_GLOBAL WCHAR c_szTCPMaxHalfOpenRetried[]          = L"TCPMaxHalfOpenRetried";
CONST_GLOBAL WCHAR c_szDontAddDefaultGateway[]          = L"DontAddDefaultGateway";
CONST_GLOBAL WCHAR c_szPPTPFiltering[]                  = L"PPTPFiltering";
CONST_GLOBAL WCHAR c_szDhcpClassId[]                    = L"DhcpClassId";
CONST_GLOBAL WCHAR c_szSyncDomainWithMembership[]       = L"SyncDomainWithMembership";

CONST_GLOBAL WCHAR c_szAfSectionWinsock[]               = L"Winsock";
CONST_GLOBAL WCHAR c_szAfKeyWinsockOrder[]              = L"ProviderOrder";

//NetBt
CONST_GLOBAL WCHAR c_szBcastNameQueryCount[]            = L"BcastNameQueryCount";
CONST_GLOBAL WCHAR c_szBcastQueryTimeout[]              = L"BcastQueryTimeout";
CONST_GLOBAL WCHAR c_szCacheTimeout[]                   = L"CacheTimeout";
CONST_GLOBAL WCHAR c_szNameServerPort[]                 = L"NameServerPort";
CONST_GLOBAL WCHAR c_szNameSrvQueryCount[]              = L"NameSrvQueryCount";
CONST_GLOBAL WCHAR c_szNameSrvQueryTimeout[]            = L"NameSrvQueryTimeout";
CONST_GLOBAL WCHAR c_szSessionKeepAlive[]               = L"SessionKeepAlive";
CONST_GLOBAL WCHAR c_szSizeSmallMediumLarge[]           = L"Size/Small/Medium/Large";
CONST_GLOBAL WCHAR c_szBroadcastAddress[]               = L"BroadcastAddress";
CONST_GLOBAL WCHAR c_szEnableProxyRegCheck[]            = L"EnableProxyRegCheck";
CONST_GLOBAL WCHAR c_szInitialRefreshTimeout[]          = L"InitialRefreshTimeout";
CONST_GLOBAL WCHAR c_szLmhostsTimeout[]                 = L"LmhostsTimeout";
CONST_GLOBAL WCHAR c_szMaxDgramBuffering[]              = L"MaxDgramBuffering";
CONST_GLOBAL WCHAR c_szNodeType[]                       = L"NodeType";
CONST_GLOBAL WCHAR c_szRandomAdapter[]                  = L"RandomAdapter";
CONST_GLOBAL WCHAR c_szRefreshOpCode[]                  = L"RefreshOpCode";
CONST_GLOBAL WCHAR c_szSingleResponse[]                 = L"SingleResponse";
CONST_GLOBAL WCHAR c_szWinsDownTimeout[]                = L"WinsDownTimeout";
CONST_GLOBAL WCHAR c_szEnableProxy[]                    = L"EnableProxy";

//DNS
CONST_GLOBAL WCHAR c_szAfDns[]                          = L"DNS";
CONST_GLOBAL WCHAR c_szAfDnsHostname[]                  = L"DNSHostName";
CONST_GLOBAL WCHAR c_szAfDnsDomain[]                    = L"DNSDomain";
CONST_GLOBAL WCHAR c_szAfDnsServerSearchOrder[]         = L"DNSServerSearchOrder";
CONST_GLOBAL WCHAR c_szAfDnsSuffixSearchOrder[]         = L"DNSSuffixSearchOrder";
CONST_GLOBAL WCHAR c_szAfUseDomainNameDevolution[]      = L"UseDomainNameDevolution";
CONST_GLOBAL WCHAR c_szAfDisableDynamicUpdate[]         = L"DisableDynamicUpdate";
CONST_GLOBAL WCHAR c_szAfEnableAdapterDomainNameRegistration[]      
                                                        = L"EnableAdapterDomainNameRegistration";

//DHCP
CONST_GLOBAL WCHAR c_szAfDhcp[]                         = L"DHCP";
CONST_GLOBAL WCHAR c_szAfIpaddress[]                    = L"IPAddress";
CONST_GLOBAL WCHAR c_szAfSubnetmask[]                   = L"SubnetMask";
CONST_GLOBAL WCHAR c_szAfDefaultGateway[]               = L"DefaultGateway";
CONST_GLOBAL WCHAR c_szAfBindToDhcpServer[]             = L"BindToDhcpServer";

//WINS
CONST_GLOBAL WCHAR c_szAfWins[]                         = L"WINS";
CONST_GLOBAL WCHAR c_szAfWinsServerList[]               = L"WINSServerList";
CONST_GLOBAL WCHAR c_szAfScopeid[]                      = L"ScopeID";
CONST_GLOBAL WCHAR c_szAfEnableLmhosts[]                = L"EnableLMHosts";
CONST_GLOBAL WCHAR c_szAfImportLmhostsFile[]            = L"ImportLMHostsFile";
CONST_GLOBAL WCHAR c_szAfNetBIOSOptions[]               = L"NetBIOSOptions";

//IPX
CONST_GLOBAL WCHAR c_szAfInternalNetworkNumber[]        = L"VirtualNetworkNumber";
CONST_GLOBAL WCHAR c_szAfFrameType[]                    = L"FrameType";

// ----------------------------------------------------------------------
// Services

//MS_NetClient
CONST_GLOBAL WCHAR c_szAfMsNetClient[]                  = L"MS_NetClient";
CONST_GLOBAL WCHAR c_szAfComputerBrowser[]              = L"ComputerBrowser";
CONST_GLOBAL WCHAR c_szAfBrowseDomains[]                = L"BrowseDomains";
CONST_GLOBAL WCHAR c_szAfDefaultProvider[]              = L"DefaultSecurityProvider";
CONST_GLOBAL WCHAR c_szAfNameServiceAddr[]              = L"NameServiceNetworkAddress";
CONST_GLOBAL WCHAR c_szAfNameServiceProtocol[]          = L"NameServiceProtocol";

//LanmanServer
CONST_GLOBAL WCHAR c_szAfBrowserParameters[]            = L"Browser.Parameters";
CONST_GLOBAL WCHAR c_szAfNetLogonParameters[]           = L"NetLogon.Parameters";

CONST_GLOBAL WCHAR c_szAfLmServerShares[]               = L"LanmanServer.Shares";
CONST_GLOBAL WCHAR c_szAfLmServerParameters[]           = L"LanmanServer.Parameters";
CONST_GLOBAL WCHAR c_szAfLmServerAutotunedParameters[]  = L"LanmanServer.AutotunedParameters";

CONST_GLOBAL WCHAR c_szAfLmServerOptimization[]         = L"Optimization";
CONST_GLOBAL WCHAR c_szAfBroadcastToClients[]           = L"BroadcastsToLanman2Clients";

CONST_GLOBAL WCHAR c_szAfMinmemoryused[]                = L"MinMemoryUsed";
CONST_GLOBAL WCHAR c_szAfBalance[]                      = L"Balance";
CONST_GLOBAL WCHAR c_szAfMaxthroughputforfilesharing[]  = L"MaxThroughputForFileSharing";
CONST_GLOBAL WCHAR c_szAfMaxthrouputfornetworkapps[]    = L"MaxThroughputForNetworkApps";



//RAS
CONST_GLOBAL WCHAR c_szAfParamsSection[]                = L"ParamsSection";

CONST_GLOBAL WCHAR c_szAfPortSections[]                 = L"PortSections";
CONST_GLOBAL WCHAR c_szAfPortname[]                     = L"PortName";
CONST_GLOBAL WCHAR c_szAfPortUsage[]                    = L"PortUsage";
CONST_GLOBAL WCHAR c_szAfPortUsageClient[]              = L"Client";
CONST_GLOBAL WCHAR c_szAfPortUsageServer[]              = L"Server";
CONST_GLOBAL WCHAR c_szAfPortUsageRouter[]              = L"Router";

CONST_GLOBAL WCHAR c_szAfSetDialinUsage[]               = L"SetDialInUsage";

CONST_GLOBAL WCHAR c_szAfForceEncryptedPassword[]       = L"ForceEncryptedPassword";
CONST_GLOBAL WCHAR c_szAfForceEncryptedData[]           = L"ForceEncryptedData";
CONST_GLOBAL WCHAR c_szAfForceStrongEncryption[]        = L"ForceStrongEncryption";
CONST_GLOBAL WCHAR c_szAfMultilink[]                    = L"Multilink";
CONST_GLOBAL WCHAR c_szAfRouterType[]                   = L"RouterType";
CONST_GLOBAL WCHAR c_szAfSecureVPN[]                    = L"SecureVPN";

CONST_GLOBAL WCHAR c_szAfDialinProtocols[]              = L"DialinProtocols";

CONST_GLOBAL WCHAR c_szAfDialIn[]                       = L"DialIn";
CONST_GLOBAL WCHAR c_szAfDialOut[]                      = L"DialOut";
CONST_GLOBAL WCHAR c_szAfDialInOut[]                    = L"DialInOut";

CONST_GLOBAL WCHAR c_szAfAppleTalk[]                    = L"APPLETALK";
CONST_GLOBAL WCHAR c_szAfNetbeui[]                      = L"NETBEUI";
CONST_GLOBAL WCHAR c_szAfTcpip[]                        = L"TCP/IP";
CONST_GLOBAL WCHAR c_szAfIpx[]                          = L"IPX";

CONST_GLOBAL WCHAR c_szAfNetbeuiClientAccess[]          = L"NetBEUIClientAccess";
CONST_GLOBAL WCHAR c_szAfTcpipClientAccess[]            = L"TcpIpClientAccess";
CONST_GLOBAL WCHAR c_szAfIpxClientAccess[]              = L"IpxClientAccess";
CONST_GLOBAL WCHAR c_szAfNetwork[]                      = L"Network";
CONST_GLOBAL WCHAR c_szAfThisComputer[]                 = L"ThisComputer";

CONST_GLOBAL WCHAR c_szAfUseDhcp[]                      = L"UseDHCP";
CONST_GLOBAL WCHAR c_szAfIpAddressStart[]               = L"IpAddressStart";
CONST_GLOBAL WCHAR c_szAfIpAddressEnd[]                 = L"IpAddressEnd";
CONST_GLOBAL WCHAR c_szAfExcludeAddress[]               = L"ExcludeAddress";

CONST_GLOBAL WCHAR c_szAfClientCanReqIpaddr[]           = L"ClientCanRequestIPAddress";
CONST_GLOBAL WCHAR c_szAfWanNetPoolSize[]               = L"WanNetpoolSize";
CONST_GLOBAL WCHAR c_szAfAutoNetworkNumbers[]           = L"AutomaticNetworkNumbers";
CONST_GLOBAL WCHAR c_szAfNetNumberFrom[]                = L"NetworkNumberFrom";
CONST_GLOBAL WCHAR c_szAfSameNetworkNumber[]            = L"AssignSameNetworkNumber";
CONST_GLOBAL WCHAR c_szAfClientReqNodeNumber[]          = L"ClientsCanRequestIpxNodeNumber";

//L2TP
CONST_GLOBAL WCHAR c_szAfL2tpMaxVcs[]                   = L"MaxVcs";
CONST_GLOBAL WCHAR c_szAfL2tpEndpoints[]                = L"WanEndpoints";

//PPTP
CONST_GLOBAL WCHAR c_szAfPptpEndpoints[]                = L"NumberLineDevices";

//Bindings
CONST_GLOBAL WCHAR c_szAfDisable[]                      = L"Disable";
CONST_GLOBAL WCHAR c_szAfEnable[]                       = L"Enable";
CONST_GLOBAL WCHAR c_szAfPromote[]                      = L"Promote";
CONST_GLOBAL WCHAR c_szAfDemote[]                       = L"Demote";

CONST_GLOBAL WCHAR c_szAfDhcpServerParameters[]         = L"DhcpServer.Parameters";
CONST_GLOBAL WCHAR c_szAfDhcpServerConfiguration[]      = L"DhcpServer.Configuration";

CONST_GLOBAL WCHAR c_szAfNWCWorkstationParameters[]     = L"NWCWorkstation.Parameters";
CONST_GLOBAL WCHAR c_szAfNWCWorkstationShares[]         = L"NWCWorkstation.Shares";
CONST_GLOBAL WCHAR c_szAfNWCWorkstationDrives[]         = L"NWCWorkstation.Drives";

// ----------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncatlui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C A T L U I . C P P
//
//  Contents:   UI common code relying on ATL.
//
//  Notes:
//
//  Author:     shaunco   13 Oct 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>
#include "ncatlui.h"
#include "ncatl.h"
#include "ncstring.h"

//+---------------------------------------------------------------------------
//
//  Function:   NcMsgBox
//
//  Purpose:    Displays a message box using resource strings and replaceable
//              parameters.
//
//  Arguments:
//      hwnd        [in] parent window handle
//      unIdCaption [in] resource id of caption string
//      unIdFormat  [in] resource id of text string (with %1, %2, etc.)
//      unStyle     [in] standard message box styles
//      ...         [in] replaceable parameters (optional)
//                          (these must be LPCWSTRs as that is all
//                          FormatMessage handles.)
//
//  Returns:    the return value of MessageBox()
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      FormatMessage is used to do the parameter substitution.
//
NOTHROW
int
WINAPIV
NcMsgBox (
        HWND    hwnd,
        UINT    unIdCaption,
        UINT    unIdFormat,
        UINT    unStyle,
        ...)
{
    PCWSTR pszCaption = SzLoadIds(unIdCaption);
    PCWSTR pszFormat  = SzLoadIds(unIdFormat);

    PWSTR  pszText = NULL;
    va_list val;
    va_start (val, unStyle);
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                   pszFormat, 0, 0, (PWSTR)&pszText, 0, &val);
    va_end (val);

    if(!pszText)
    {
        // This is what MessageBox returns if it fails.
        return 0;
    }

    int nRet = MessageBox (hwnd, pszText, pszCaption, unStyle);
    LocalFree (pszText);

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\nccfgmgr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C C F G M G R . C P P
//
//  Contents:   Common code useful when using the Configuration Manager APIs.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   6 May 1998
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "nccfgmgr.h"

//+---------------------------------------------------------------------------
//
//  Function:   HrFromConfigManagerError
//
//  Purpose:    Convert a CONFIGRET into an HRESULT.
//
//  Arguments:
//      cr        [in] CONFIGRET to convert.
//      hrDefault [in] Default HRESULT to use if mapping not found.
//
//  Returns:    HRESULT
//
//  Author:     shaunco   6 May 1998
//
//  Notes:
//
NOTHROW
HRESULT
HrFromConfigManagerError (
    CONFIGRET   cr,
    HRESULT     hrDefault)
{
    switch (cr)
    {
        case CR_SUCCESS:
            return NO_ERROR;

        case CR_OUT_OF_MEMORY:
            return E_OUTOFMEMORY;

        case CR_INVALID_POINTER:
            return E_POINTER;

        case CR_INVALID_DEVINST:
            return HRESULT_FROM_WIN32 (ERROR_NO_SUCH_DEVINST);

        case CR_ALREADY_SUCH_DEVINST:
            return HRESULT_FROM_WIN32 (ERROR_DEVINST_ALREADY_EXISTS);

        case CR_INVALID_DEVICE_ID:
            return HRESULT_FROM_WIN32 (ERROR_INVALID_DEVINST_NAME);

        case CR_INVALID_MACHINENAME:
            return HRESULT_FROM_WIN32 (ERROR_INVALID_MACHINENAME);

        case CR_REMOTE_COMM_FAILURE:
            return HRESULT_FROM_WIN32 (ERROR_REMOTE_COMM_FAILURE);

        case CR_MACHINE_UNAVAILABLE:
            return HRESULT_FROM_WIN32 (ERROR_MACHINE_UNAVAILABLE);

        case CR_NO_CM_SERVICES:
            return HRESULT_FROM_WIN32 (ERROR_NO_CONFIGMGR_SERVICES);

        case CR_ACCESS_DENIED:
            return E_ACCESSDENIED;

        case CR_CALL_NOT_IMPLEMENTED:
            return E_NOTIMPL;

        case CR_INVALID_REFERENCE_STRING :
            return HRESULT_FROM_WIN32 (ERROR_INVALID_REFERENCE_STRING);

        default:
            return hrDefault;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncinf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C I N F . C P P
//
//  Contents:   ???
//
//  Notes:
//
//  Author:     ???
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncinf.h"
#include "ncsetup.h"
#include "ncstring.h"

//+---------------------------------------------------------------------------
//
//  Function:   HrProcessInfExtension
//
//  Purpose:    Given the appropriate keywords, returns information about an
//              INF file that contains extended commands to add and remove
//              fixed components such as WinSock or SNMP Agent support.
//
//  Arguments:
//      hinfInstallFile  [in]    The handle to the inf file to install
//                              from
//      pszSectionName   [in]    The Base install section name.
//      pszSuffix        [in]    Suffix to append to base. (i.e. "Winsock")
//      pszAddLabel      [in]    Label for Add command (i.e. "AddSock")
//      pszRemoveLabel   [in]    Label for Remove command (i.e. "DelSock")
//      pfnHrAdd         [in]    Callback function to be called when adding.
//      pfnHrRemove      [in]    Callback function to be called when removing.
//
//  Returns:    HRESULT, S_OK on success
//
//  Author:     danielwe   27 Apr 1997
//
//  Notes:
//
HRESULT
HrProcessInfExtension (
    IN HINF                hinfInstallFile,
    IN PCWSTR              pszSectionName,
    IN PCWSTR              pszSuffix,
    IN PCWSTR              pszAddLabel,
    IN PCWSTR              pszRemoveLabel,
    IN PFNADDCALLBACK      pfnHrAdd,
    IN PFNREMOVECALLBACK   pfnHrRemove)
{
    Assert(IsValidHandle(hinfInstallFile));

    BOOL        fAdd;
    HRESULT     hr = S_OK;
    tstring     strSectionName;
    INFCONTEXT  infContext;
    WCHAR       szCmd[LINE_LEN];    // LINE_LEN defined in setupapi.h as 256

    // Construct the section name for which we're looking
    // (ie.  "Inst_Section.Winsock")
    strSectionName = pszSectionName;
    strSectionName += L".";
    strSectionName += pszSuffix;

    // Loop over the elements of the section and process the
    // appropriate AddSock/DelSock sections found
    hr = HrSetupFindFirstLine(hinfInstallFile, strSectionName.c_str(),
                              NULL, &infContext);
    if (S_OK == hr)
    {
        tstring strName;

        do
        {
            // Retrieve a line from the section, hopefully in the format:
            // AddSock=section_name   or   DelSock=section_name
            hr = HrSetupGetStringField(infContext, 0, szCmd, celems(szCmd),
                                       NULL);
            if (FAILED(hr))
            {
                goto Done;
            }

            // Check for the <add> or <remove> command
            szCmd[celems(szCmd)-1] = L'\0';
            if (!lstrcmpiW(szCmd, pszAddLabel))
            {
                fAdd = TRUE;
            }
            else if (!lstrcmpiW(szCmd, pszRemoveLabel))
            {
                fAdd = FALSE;
            }
            else
            {
                continue;   // Other things are in this install section
            }

            // Query the Add/Remove value from the .inf
            hr = HrSetupGetStringField(infContext, 1, &strName);
            if (S_OK == hr)
            {
                if (fAdd)
                {
                    // Call Add callback
                    hr = pfnHrAdd(hinfInstallFile, strName.c_str());
                }
                else
                {
                    // Call remove callback
                    hr = pfnHrRemove(hinfInstallFile, strName.c_str());
                }

                if (FAILED(hr))
                {
                    goto Done;
                }
            }
            else
            {
                goto Done;
            }
        }
        while (S_OK == (hr = HrSetupFindNextLine(infContext, &infContext)));
    }

    if (hr == S_FALSE)
    {
        // S_FALSE will terminate the loop successfully, so convert it to S_OK
        // here.
        hr = S_OK;
    }

Done:
    TraceHr (ttidError, FAL, hr, (SPAPI_E_LINE_NOT_FOUND == hr),
        "HrProcessInfExtension");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncipaddr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C I P A D D R . C P P
//
//  Contents:   WCHAR support for Winsock inet_ functions.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncipaddr.h"

VOID
IpHostAddrToPsz(
    IN  DWORD  dwAddr,
    OUT PWSTR  pszBuffer)
{
    BYTE* pb = (BYTE*)&dwAddr;
    static const WCHAR c_szIpAddr [] = L"%d.%d.%d.%d";
    wsprintfW (pszBuffer, c_szIpAddr, pb[3], pb[2], pb[1], pb[0]);
}

DWORD
IpPszToHostAddr(
    IN  PCWSTR cp)
{
    DWORD val, base, n;
    WCHAR c;
    DWORD parts[4], *pp = parts;

again:
    // Collect number up to ``.''.
    // Values are specified as for C:
    // 0x=hex, 0=octal, other=decimal.
    //
    val = 0; base = 10;
    if (*cp == L'0')
    {
        base = 8, cp++;
    }
    if (*cp == L'x' || *cp == L'X')
    {
        base = 16, cp++;
    }
    while (c = *cp)
    {
        if ((c >= L'0') && (c <= L'9'))
        {
            val = (val * base) + (c - L'0');
            cp++;
            continue;
        }
        if ((base == 16) &&
            ( ((c >= L'0') && (c <= L'9')) ||
              ((c >= L'A') && (c <= L'F')) ||
              ((c >= L'a') && (c <= L'f')) ))
        {
            val = (val << 4) + (c + 10 - (
                        ((c >= L'a') && (c <= L'f'))
                            ? L'a'
                            : L'A' ) );
            cp++;
            continue;
        }
        break;
    }
    if (*cp == L'.')
    {
        // Internet format:
        //  a.b.c.d
        //  a.b.c   (with c treated as 16-bits)
        //  a.b (with b treated as 24 bits)
        //
        if (pp >= parts + 3)
        {
            return (DWORD) -1;
        }
        *pp++ = val, cp++;
        goto again;
    }

    // Check for trailing characters.
    //
    if (*cp && (*cp != L' '))
    {
        return 0xffffffff;
    }

    *pp++ = val;

    // Concoct the address according to
    // the number of parts specified.
    //
    n = pp - parts;
    switch (n)
    {
        case 1:             // a -- 32 bits
            val = parts[0];
            break;

        case 2:             // a.b -- 8.24 bits
            val = (parts[0] << 24) | (parts[1] & 0xffffff);
            break;

        case 3:             // a.b.c -- 8.8.16 bits
            val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                (parts[2] & 0xffff);
            break;

        case 4:             // a.b.c.d -- 8.8.8.8 bits
            val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                  ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
            break;

        default:
            return 0xffffffff;
    }

    return val;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncbase.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C B A S E . C P P
//
//  Contents:   Basic common code.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   20 Sep 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncbase.h"
#include "ncdebug.h"
#include "ncperms.h"
#include "ncstring.h"

//+---------------------------------------------------------------------------
//
//  Function:   AddRefObj
//
//  Purpose:    AddRef's the object pointed to by punk by calling
//              punk->AddRef();
//
//  Arguments:
//      punk [in]   Object to be AddRef'd. Can be NULL.
//
//  Returns:    Result of AddRef call.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      Using this function to AddRef an object will reduce
//              our code size.
//
NOTHROW
ULONG
AddRefObj (
    IUnknown* punk)
{
    return (punk) ? punk->AddRef () : 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseObj
//
//  Purpose:    Releases the object pointed to by punk by calling
//              punk->Release();
//
//  Arguments:
//      punk [in]   Object to be released. Can be NULL.
//
//  Returns:    Result of Release call.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      Using this function to release a (possibly NULL) object will
//              reduce our code size.
//
NOTHROW
ULONG
ReleaseObj (
    IUnknown* punk)
{
    return (punk) ? punk->Release () : 0;
}

//+--------------------------------------------------------------------------
//
//  Function:   DwWin32ErrorFromHr
//
//  Purpose:    Converts the HRESULT to a Win32 error or SetupApi error.
//
//  Arguments:
//      hr [in] The HRESULT to convert
//
//  Returns:    Converted DWORD value.
//
//  Author:     billbe   22 Apr 1997
//
//  Notes:
//
NOTHROW
DWORD
DwWin32ErrorFromHr (
    HRESULT hr)
{
    DWORD dw = ERROR_SUCCESS;

    // All success codes convert to ERROR_SUCCESS so we only need to handle
    // failures.
    if (FAILED(hr))
    {
        DWORD dwFacility = HRESULT_FACILITY(hr);

        if (FACILITY_SETUPAPI == dwFacility)
        {
            // reconstruct the SetupApi error using the correct masks
            dw = HRESULT_CODE(hr) | APPLICATION_ERROR_MASK |
                    ERROR_SEVERITY_ERROR;

            // Check to make sure dw maps to a known SetupApi error
            AssertSz(FDwordWithinRange(ERROR_EXPECTED_SECTION_NAME,
                            dw, ERROR_GENERAL_SYNTAX) ||
                     FDwordWithinRange(ERROR_WRONG_INF_STYLE,
                            dw, ERROR_NO_BACKUP) ||
                     FDwordWithinRange(ERROR_NO_ASSOCIATED_CLASS,
                            dw, ERROR_SET_SYSTEM_RESTORE_POINT),
                    "The mapped SetupApi error is not known "
                    "(or is new)!!!");
        }
        else if (FACILITY_WIN32 == dwFacility)
        {
            dw = HRESULT_CODE(hr);
        }
        else if (FACILITY_ITF == dwFacility)
        {
            dw = ERROR_GEN_FAILURE;
        }
        else
        {
            // cannot convert it
            AssertSz(FALSE, "Facility was not SETUP or WIN32!");
            dw = hr;
        }
    }

    return dw;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCoTaskMemAlloc
//
//  Purpose:    Call CoTaskMemAlloc but return an HRESULT.
//
//  Arguments:
//      cb  [in]    Count of bytes to allocate.
//      ppv [out]   Returned pointer to bytes.
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//  Author:     shaunco   31 May 1997
//
//  Notes:
//
HRESULT
HrCoTaskMemAlloc (
    ULONG   cb,
    VOID**  ppv)
{
    HRESULT hr = S_OK;
    *ppv = CoTaskMemAlloc (cb);
    if (!*ppv)
    {
        hr = E_OUTOFMEMORY;
    }
    TraceError ("HrCoTaskMemAlloc", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCoTaskMemAllocAndDupSzLen
//
//  Purpose:    Allocate memory using CoTaskMemAlloc and copy a string
//              into it.  This is used by the implementation of COM interfaces
//              that return strings.
//
//  Arguments:
//      pszSrc  [in]  Pointer to source string.
//      cchSrc  [in]  Number of characters to copy from source string.
//      ppszDst [out] Address of pointer to destination string.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Author:     shaunco   14 Jan 1999
//
//  Notes:      NULL input pointers are allocated as empty strings
//              deliberately.
//              The returned string is guaranteed to be NULL terminated.
//
HRESULT
HrCoTaskMemAllocAndDupSzLen (
    IN PCWSTR pszSrc,
    IN ULONG cchSrc,
    OUT PWSTR* ppszDst)
{
    Assert (ppszDst);

    HRESULT hr;
    DWORD cb = cchSrc * sizeof(WCHAR);

    hr = E_OUTOFMEMORY;
    *ppszDst = (PWSTR)CoTaskMemAlloc (cb + sizeof(WCHAR));
    if (*ppszDst)
    {
        hr = S_OK;
        wcsncpy (*ppszDst, pszSrc, cchSrc);
        (*ppszDst)[cchSrc] = 0;
    }

    TraceError ("HrCoTaskMemAllocAndDupSz", hr);
    return hr;
}

HRESULT
HrCoTaskMemAllocAndDupSz (
    IN PCWSTR pszSrc,
    OUT PWSTR* ppszDst)
{
    return HrCoTaskMemAllocAndDupSzLen (
            pszSrc,
            CchOfSzSafe(pszSrc),
            ppszDst);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFromLastWin32Error
//
//  Purpose:    Converts the GetLastError() Win32 call into a proper HRESULT.
//
//  Arguments:
//      (none)
//
//  Returns:    Converted HRESULT value.
//
//  Author:     danielwe   24 Mar 1997
//
//  Notes:      This is not inline as it actually generates quite a bit of
//              code.
//              If GetLastError returns an error that looks like a SetupApi
//              error, this function will convert the error to an HRESULT
//              with FACILITY_SETUP instead of FACILITY_WIN32
//
NOTHROW
HRESULT
HrFromLastWin32Error ()
{
    DWORD dwError = GetLastError();
    HRESULT hr;

    // This test is testing SetupApi errors only (this is
    // temporary because the new HRESULT_FROM_SETUPAPI macro will
    // do the entire conversion)
    if (dwError & (APPLICATION_ERROR_MASK | ERROR_SEVERITY_ERROR))
    {
        hr = HRESULT_FROM_SETUPAPI(dwError);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwError);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetProcAddress
//
//  Purpose:    Loads a libray and returns the address of a procedure within
//                  the library
//
//  Arguments:
//      hModule      [in] The handle to the library module instance
//      pszaFunction [in]  Function to retrieve
//      ppfn         [out] Address of szFunction
//
//  Returns:    S_OK if successful, Win32 converted error if failure.
//
//  Author:     billbe   10 June 1997
//
//  Notes:
//
HRESULT
HrGetProcAddress (
    HMODULE     hModule,
    PCSTR       pszaFunction,
    FARPROC*    ppfn)
{
    Assert(hModule);
    Assert(pszaFunction);
    Assert(ppfn);

    HRESULT hr = S_OK;
    *ppfn = GetProcAddress(hModule, pszaFunction);
    if (!*ppfn)
    {
        hr = HrFromLastWin32Error();
        TraceTag(ttidError, "HrGetProcAddress failed: szFunction: %s",
                 pszaFunction);
    }

    TraceError("HrGetProcAddress", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLoadLibAndGetProcs
//
//  Purpose:    Load a dynamic link library and the addresses of one or
//              more procedures within that library.
//
//  Arguments:
//      pszLibPath         [in]  Path to the DLL to load.
//      cFunctions         [in]  Number of procedures to load.
//      apszaFunctionNames [in]  Array of function names.  (Must be 'cFunctions'
//                               of them.)
//      phmod              [out] Returned handle to the loaded module.
//      apfn               [out] Array of returned pointers to the procedures
//                               loaded.  (Must be 'cFunctions' of them.)
//
//  Returns:    S_OK if all procedures were loaded, S_FALSE if only
//              some of them were, or a Win32 error code.  If only
//              one procedure is to be loaded and it is not, S_FALSE will
//              not be returned, rather, the reason for why the single
//              procedure could not be loaded will be returned.  This allows
//              HrLoadLibAndGetProc to be implemented using this function.
//
//  Author:     shaunco   19 Jan 1998
//
//  Notes:      phmod should be freed by the caller using FreeLibrary if
//              the return value is S_OK.
//
HRESULT
HrLoadLibAndGetProcs (
    PCWSTR          pszLibPath,
    UINT            cFunctions,
    const PCSTR*    apszaFunctionNames,
    HMODULE*        phmod,
    FARPROC*        apfn)
{
    Assert (pszLibPath);
    Assert (cFunctions);
    Assert (apszaFunctionNames);
    Assert (phmod);
    Assert (apfn);

    HRESULT hr = S_OK;

    // Load the module and initialize the output parameters.
    //
    HMODULE hmod = LoadLibrary (pszLibPath);
    *phmod = hmod;
    ZeroMemory (apfn, cFunctions * sizeof(FARPROC));

    if (hmod)
    {
        // Get the proc address of each function.
        //
        for (UINT i = 0; i < cFunctions; i++)
        {
            apfn[i] = GetProcAddress (hmod, apszaFunctionNames[i]);

            if (!apfn[i])
            {
                // Couldn't load all functions.  We'll be returning S_FALSE
                // (if their are more than one function.)
                //
                hr = S_FALSE;

                TraceTag (ttidError, "HrLoadLibAndGetProcs: GetProcAddress "
                    "for '%s' failed.",
                    apszaFunctionNames[i]);
            }
        }

        // If we're only loading one function, and it failed,
        // return the failure.
        //
        if ((1 == cFunctions) && !apfn[0])
        {
            hr = HrFromLastWin32Error ();
            FreeLibrary (hmod);
        }
    }
    else
    {
        hr = HrFromLastWin32Error ();
        TraceTag (ttidError, "HrLoadLibAndGetProcs: LoadLibrary (%S) failed.",
            pszLibPath);
    }

    TraceError ("HrLoadLibAndGetProcs", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetProcAddressesVa
//
// Purpose:   Get proc-address of each function-name passed
//
// Arguments:
//    hModule [in]  handle of DLL
//    arglist [in]  list of var-args. the expected format is
//                  "func-name", FARPROC*, ..., NULL
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 29-December-97
//
// Notes:
//
HRESULT
HrGetProcAddressesVa (
    HMODULE hModule,
    va_list arglist)
{
    PCSTR szFunctionName;
    FARPROC* ppfn;
    HRESULT hr = S_OK;
    typedef FARPROC* PFARPROC;

    while (NULL != (szFunctionName = va_arg(arglist, CHAR*)))
    {
        ppfn = va_arg(arglist, PFARPROC);
        *ppfn = GetProcAddress(hModule, szFunctionName);

        if (!*ppfn)
        {
            hr = HrFromLastWin32Error();
            TraceTag(ttidError, "HrGetProcAddressesVa failed: szFunction: %s",
                     szFunctionName);
            break;
        }
    }

    TraceError("HrGetProcAddressesVa", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetProcAddressesV
//
// Purpose:   Get proc-address of each function-name passed
//
// Arguments:
//    hModule [in]  handle of DLL
//    ...     [in]  list of var-args. the expected format is
//                  "func-name", FARPROC*, ..., NULL
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 29-December-97
//
// Notes:
//
HRESULT
HrGetProcAddressesV (
    HMODULE hModule,
    ...)
{
    HRESULT hr=S_OK;
    va_list arglist;

    va_start(arglist, hModule);

    hr = HrGetProcAddressesVa(hModule, arglist);

    va_end(arglist);

    TraceError("HrGetProcAddressesV", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrLoadLibAndGetProcsV
//
// Purpose:   Get proc-address of each function-name passed
//
// Arguments:
//    pszLibPath [in]   DLL to load
//    phModule   [out]  pointer to handle of DLL loaded
//    ...        [in]   list of var-args. the expected format is
//                      "func-name", FARPROC*, ..., NULL
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 29-December-97
//
// Notes:
//
HRESULT
HrLoadLibAndGetProcsV (
    PCWSTR      pszLibPath,
    HMODULE*    phModule,
    ...)
{
    Assert(pszLibPath);
    Assert(phModule);

    HRESULT hr = S_OK;

    // Attempt to load the library
    *phModule = LoadLibrary(pszLibPath);

    if (*phModule)
    {
        va_list arglist;

        va_start(arglist, phModule);

        hr = HrGetProcAddressesVa(*phModule, arglist);

        va_end(arglist);

        if (FAILED(hr))
        {
            // Free the library
            FreeLibrary(*phModule);
        }
    }
    else
    {
        hr = HrFromLastWin32Error();
        TraceTag(ttidError, "HrLoadLibAndGetProcsV failed: szLibPath: %S",
                 pszLibPath);
    }

    // if we failed then we should set *phModule to NULL since we might
    // have successfully loaded it and failed getting the proc
    if (FAILED(hr))
    {
        *phModule = NULL;
    }

    TraceError("HrLoadLibAndGetProcsV", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateEventWithWorldAccess
//
//  Purpose:    Creates a event with permissions to allow access to
//              everyone.
//
//  Arguments:
//      pszName         [in]  Name for the event.
//      fManualReset    [in]  See Win32 docs.
//      fInitialState   [in]  See Win32 docs.
//      pfAlreadyExists [out] TRUE if the event already existed.
//                            FALSE otherwise.
//      phEvent         [out] The created event.
//
//  Returns:    S_OK on success. An error code otherwise.
//
//  Author:     BillBe   16 Nov 1998
//
//  Notes:
//
HRESULT
HrCreateEventWithWorldAccess(PCWSTR pszName, BOOL fManualReset,
        BOOL fInitialState, BOOL* pfAlreadyExists, HANDLE* phEvent)
{
    Assert(pszName);
    Assert(phEvent);

    if (pfAlreadyExists)
    {
        *pfAlreadyExists = FALSE;
    }

    *phEvent = NULL;

    // Create the correct descriptor.
    PSECURITY_DESCRIPTOR pSd;
    HRESULT hr = HrAllocateSecurityDescriptorAllowAccessToWorld(&pSd);
    if (SUCCEEDED(hr))
    {
        SECURITY_ATTRIBUTES sa = {0};
        sa.nLength = sizeof(sa);
        sa.lpSecurityDescriptor = pSd;
        sa.bInheritHandle = FALSE;

        // Create Event
        //
        *phEvent = CreateEvent(&sa, fManualReset, fInitialState, pszName);

        hr = HrFromLastWin32Error();
        if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr)
        {
            if (pfAlreadyExists)
            {
                *pfAlreadyExists = TRUE;
            }
            hr = S_OK;
        }

        MemFree(pSd);
    }

    TraceError("HrCreateEventWithWorldAccess", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateMutexWithWorldAccess
//
//  Purpose:    Creates a mutex with permissions to allow access to
//              everyone.
//
//  Arguments:
//      pszName         [in]  Name for the mutex.
//      fInitialOwner   [in]  See Win32 docs.
//      pfAlreadyExists [out] TRUE if the mutex already existed,
//                            FALSE otherwise.
//      phMutex         [out] The created mutex.
//
//  Returns:    S_OK on success. An error code otherwise.
//
//  Author:     BillBe   16 Nov 1998
//
//  Notes:
//
HRESULT
HrCreateMutexWithWorldAccess (
    PCWSTR pszName,
    BOOL fInitialOwner,
    BOOL* pfAlreadyExists,
    HANDLE* phMutex)
{
    Assert(pszName);
    Assert(phMutex);

    if (pfAlreadyExists)
    {
        *pfAlreadyExists = FALSE;
    }

    *phMutex = NULL;

    // Create the correct descriptor.
    PSECURITY_DESCRIPTOR pSd;
    HRESULT hr = HrAllocateSecurityDescriptorAllowAccessToWorld(&pSd);
    if (S_OK == hr)
    {
        SECURITY_ATTRIBUTES sa = {0};
        sa.nLength = sizeof(sa);
        sa.lpSecurityDescriptor = pSd;
        sa.bInheritHandle = FALSE;

        // Create Mutex
        //
        *phMutex = CreateMutex(&sa, fInitialOwner, pszName);

        hr = HrFromLastWin32Error();
        if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr)
        {
            if (pfAlreadyExists)
            {
                *pfAlreadyExists = TRUE;
            }
            hr = S_OK;
        }

        MemFree(pSd);
    }

    TraceError("HrCreateMutexWithWorldAccess", hr);
    return hr;
}


//+---------------------------------------------------------------------------
// The standard parameterization of CoSetProxyBlanket.  Call this instead
// of CoSetProxyBlanket so you get the same security and authentication
// settings as everyone else.  This version saves code space at the call-site
// because it pushes only one parameter instead of eight.
// This does not return an error because it does not invalidate the use of
// pUnk after it's called.
//
VOID
NcSetProxyBlanket (
    IN IUnknown* pUnk)
{
    HRESULT hr;

    hr = CoSetProxyBlanket (
            pUnk,
            RPC_C_AUTHN_WINNT,      // use NT default security
            RPC_C_AUTHZ_NONE,       // use NT default authentication
            NULL,                   // must be null if default
            RPC_C_AUTHN_LEVEL_CALL, // call
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL,                   // use process token
            EOAC_NONE);

    if(SUCCEEDED(hr)) 
    {
        IUnknown * pUnkSet = NULL;
        hr = pUnk->QueryInterface(&pUnkSet);
        if(SUCCEEDED(hr)) 
        {
            hr = CoSetProxyBlanket (
                    pUnkSet,
                    RPC_C_AUTHN_WINNT,      // use NT default security
                    RPC_C_AUTHZ_NONE,       // use NT default authentication
                    NULL,                   // must be null if default
                    RPC_C_AUTHN_LEVEL_CALL, // call
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,                   // use process token
                    EOAC_NONE);
            ReleaseObj(pUnkSet);
        }
    }

    TraceHr(ttidError, FAL, hr, (E_NOINTERFACE == hr), "NcSetProxyBlanket");
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateInstanceBase
//
//  Purpose:    Creates a COM object and sets default proxy settings.
//
//  Arguments:
//      rclsid          [in]  See documentation for CoCreateInstance.
//      dwClsContext    [in]  ""
//      riid            [in]  ""
//      ppv             [out] ""
//
//  Returns:    S_OK on success. An error code otherwise.
//
//  Author:     mbend   1 Mar 2000
//
//  Notes:      Call type safe version HrCreateInstance
//
HRESULT
HrCreateInstanceBase (
    REFCLSID rclsid,
    DWORD dwClsContext,
    REFIID riid,
    LPVOID * ppv)
{
    HRESULT hr = S_OK;

    hr = ::CoCreateInstance(rclsid, NULL, dwClsContext, riid, ppv);

    if(SUCCEEDED(hr) && (dwClsContext & CLSCTX_LOCAL_SERVER)) 
    {
        NcSetProxyBlanket(reinterpret_cast<IUnknown*>(*ppv));
    }

    TraceError("HrCreateInstanceBase", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrQIAndSetProxyBlanketBase
//
//  Purpose:    Performs QueryInterface and sets default proxy settings.
//
//  Arguments:
//      pUnk            [in]  Interface pointer to perform QueryInterface on.
//      riid            [in]  See documentation of QueryInterface
//      ppv             [out] ""
//
//  Returns:    S_OK on success. An error code otherwise.
//
//  Author:     mbend   1 Mar 2000
//
//  Notes:      Call type safe version HrQIAndSetProxyBlanket
//
HRESULT
HrQIAndSetProxyBlanketBase(IUnknown * pUnk, REFIID riid, void ** ppv)
{
    HRESULT hr = pUnk->QueryInterface(riid, ppv);
    if(SUCCEEDED(hr)) 
    {
        NcSetProxyBlanket(reinterpret_cast<IUnknown*>(*ppv));
    }

    TraceError("HrQIAndSetProxyBlanketBase", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncmisc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       N C M I S C . C P P
//
//  Contents:   Miscellaneous common code.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   10 Oct 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "ncsvc.h"
#include "ncexcept.h"
#include <eh.h>

//+---------------------------------------------------------------------------
//
//  Function:   FInSystemSetup
//
//  Purpose:    Determines whether the machine is in GUI mode setup or not.
//
//  Arguments:
//      (none)
//
//  Returns:    TRUE if in GUI mode (system) setup, FALSE if not.
//
//  Author:     danielwe   13 Jun 1997
//
//  Notes:      The state is cached (since it can't change without a reboot)
//              so call as often as you like.  No need to keep you're own
//              cached copy.
//
BOOL
FInSystemSetup ()
{
    enum SETUP_STATE
    {
        SS_UNKNOWN = 0,         // state unknown
        SS_NOTINSETUP,          // not in setup mode
        SS_SYSTEMSETUP          // in GUI mode setup
    };

    static SETUP_STATE s_CachedSetupState = SS_UNKNOWN;

    if (SS_UNKNOWN == s_CachedSetupState)
    {
        s_CachedSetupState = SS_NOTINSETUP;

        // Open the setup key
        //
        HRESULT hr;
        HKEY hkeySetup;
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\Setup",
                KEY_READ, &hkeySetup);

        if (S_OK == hr)
        {
            // get the value of the setup in progress
            //
            DWORD   dwSysSetup;

            hr = HrRegQueryDword(hkeySetup, L"SystemSetupInProgress",
                    &dwSysSetup);

            if ((S_OK == hr) && dwSysSetup)
            {
                s_CachedSetupState = SS_SYSTEMSETUP;
            }

            RegCloseKey(hkeySetup);
        }
    }

    Assert (SS_UNKNOWN != s_CachedSetupState);

    return (SS_SYSTEMSETUP == s_CachedSetupState);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetProductFlavor
//
//  Purpose:    Returns the flavor of NT currenty running on the machine.
//
//  Arguments:
//      pvReserved [in]     Reserved.  Must be NULL.
//      ppf        [out]    Returned flavor.
//
//  Returns:    nothing
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:
//
NOTHROW
VOID
GetProductFlavor (
    const void*     pvReserved,
    PRODUCT_FLAVOR* ppf)
{
    NT_PRODUCT_TYPE Type;

    Assert(!pvReserved);
    Assert(ppf);

    // Assume workstation product
    //
    *ppf = PF_WORKSTATION;

    // Even if RtlGetProductType fails, its documented to return
    // NtProductWinNt.
    //
    RtlGetNtProductType (&Type);
    if (NtProductWinNt != Type)
    {
        *ppf = PF_SERVER;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsNetworkingInstalled
//
//  Purpose:    Returns whether networking is installed.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if networking is installed, S_FALSE if not, Win32 error
//              otherwise.
//
//  Author:     danielwe   25 Jun 1997
//
//  Notes:      To determine if networking is installed, the ProviderOrder
//              value of System\CurrentControlSet\Control\NetworkProvider\Order
//              registry key is queried. If any data is present, networking
//              is installed.
//
HRESULT
HrIsNetworkingInstalled ()
{
    HRESULT     hr = S_OK;
    HKEY        hkeyProvider;
    DWORD       cbSize = 0;
    DWORD       dwType;

    extern const WCHAR c_szRegKeyCtlNPOrder[];
    extern const WCHAR c_szProviderOrder[];

    // open the provider key
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyCtlNPOrder,
            KEY_READ, &hkeyProvider);

    if (S_OK == hr)
    {
        // get the count in bytes of the provider order value
        hr = HrRegQueryValueEx(hkeyProvider, c_szProviderOrder,
                &dwType, (LPBYTE)NULL, &cbSize);

        if (S_OK == hr)
        {
            if (cbSize > 2)
            {
                // if the value was present and it contained information
                // then we have networking of some sorts
                //
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            hr = S_FALSE;
        }

        RegCloseKey(hkeyProvider);
    }

    TraceError("HrIsNetworkingInstalled", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

#ifdef REMOTEBOOT
//+---------------------------------------------------------------------------
//
//  Function:   HrIsRemoteBootMachine
//
//  Purpose:    Returns whether this is a remote boot client.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if it is remote boot, S_FALSE if not.
//
//  Author:     adamba   27 Mar 1998
//
//  Notes:      Calls GetSystemInfoEx to determine whether this is a
//              remote boot client.
//
HRESULT HrIsRemoteBootMachine()
{
    BOOL        fIsRemoteBoot;
    BOOL        ok;
    DWORD       size = sizeof(fIsRemoteBoot);

    ok = GetSystemInfoEx(SystemInfoRemoteBoot, &fIsRemoteBoot, &size);
    Assert(ok);

    if (fIsRemoteBoot) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}
#endif  // defined(REMOTEBOOT)

//+---------------------------------------------------------------------------
//
//  Function:   HrRegisterOrUnregisterComObject
//
//  Purpose:    Handles registration or unregistration of one or more COM
//                  objects contained in a DLL that supports the
//                  DllRegisterServer or DllUnregisterServer entry points.
//
//  Arguments:
//      pszDllPath [in]  Path to DLL that contains COM object(s) to (un)register.
//      rf         [in]  Function to perform
//
//  Returns:    S_OK if successful, Win32 or OLE HRESULT if failure.
//
//  Author:     danielwe   6 May 1997
//
//  Notes:
//
HRESULT
HrRegisterOrUnregisterComObject (
        PCWSTR              pszDllPath,
        REGISTER_FUNCTION   rf)
{
    BOOL fCoUninitialize = TRUE;

    HRESULT hr = CoInitializeEx( NULL,
                    COINIT_DISABLE_OLE1DDE | COINIT_MULTITHREADED  );
    if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
        fCoUninitialize =  FALSE;
    }
    if (SUCCEEDED(hr))
    {
        // ANSI only
        const CHAR c_szaRegisterFunction[]   = "DllRegisterServer";
        const CHAR c_szaUnregisterFunction[] = "DllUnregisterServer";

        typedef HRESULT (CALLBACK *HCRET)(void);

        HCRET   pfnRegister;
        HMODULE hModule;

        // Get a pointer the the registration function in the Dll
        hr = HrLoadLibAndGetProc (pszDllPath,
                ((RF_REGISTER == rf) ?
                    c_szaRegisterFunction : c_szaUnregisterFunction),
                &hModule,
                reinterpret_cast<FARPROC*>(&pfnRegister));

        if (S_OK == hr)
        {
            // Call the registration function
            hr = (*pfnRegister)();

            // RAID #160109 (danielwe) 21 Apr 1998: Handle this error and
            // ignore it.
            if (RPC_E_CHANGED_MODE == hr)
            {
                hr = S_OK;
            }

            TraceError ("HrRegisterOrUnregisterComObject - "
                    "Dll(Un)RegisterServer failed!", hr);
            FreeLibrary (hModule);
        }

        // Balances call to CoInitialize() above. Not harmful if CoInitialize()
        // was called more than once before this.
        if (fCoUninitialize)
        {
            CoUninitialize();
        }
    }

    TraceError ("HrRegisterOrUnregisterComObject", hr);
    return hr;
}

//
// Special case handling for Netbios stopping
//

#include <nb30p.h>      // Netbios IOCTLs and netbios name #define

//+---------------------------------------------------------------------------
//
//  Func:   ScStopNetbios
//
//  Desc:   This function checks if the driver being unloaded is NETBIOS.SYS.
//          If so it performs some special case processing for Netbios.
//
//  Args:   none
//
//  Return: STATUS_SUCCESS if successful, or an error status
//
// History: 28-Apr-98   SumitC      got from VRaman
//
//----------------------------------------------------------------------------
DWORD
ScStopNetbios()
{
    OBJECT_ATTRIBUTES   ObjAttr;
    UNICODE_STRING      NbDeviceName;
    IO_STATUS_BLOCK     IoStatus, StopStatus;
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    HANDLE              NbHandle = NULL;

    do
    {
        //
        // Driver being stopped is netbios
        //

        //
        // 1. Open a handle to the \\Device\Netbios
        //

        RtlInitUnicodeString(&NbDeviceName, NB_DEVICE_NAME);

        InitializeObjectAttributes(
                &ObjAttr,                           // obj attr to initialize
                &NbDeviceName,                      // string to use
                OBJ_CASE_INSENSITIVE,               // Attributes
                NULL,                               // Root directory
                NULL);                              // Security Descriptor

        ntStatus = NtCreateFile(
                        &NbHandle,                  // ptr to handle
                        GENERIC_READ|GENERIC_WRITE, // desired access
                        &ObjAttr,                   // name & attributes
                        &IoStatus,                  // I/O status block.
                        NULL,                       // alloc size.
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_DELETE           // share...
                        | FILE_SHARE_READ
                        | FILE_SHARE_WRITE,         // ...access
                        FILE_OPEN_IF,               // create disposition
                        0,                          // ...options
                        NULL,                       // EA buffer
                        0L                          // Ea buffer len
                        );

        if (!NT_SUCCESS(ntStatus))
        {
            TraceTag(ttidError, "Failed to open file handle to Netbios device (%08lx)",
                     ntStatus);
            break;
        }

        //
        // 2. Send a stop IOCTL to it.
        //

        ntStatus = NtDeviceIoControlFile(
                        NbHandle,                   // Handle to device
                        NULL,                       // Event to be signalled
                        NULL,                       // No post routine
                        NULL,                       // no context for post
                        &StopStatus,                // return status block
                        IOCTL_NB_STOP,              // IOCTL
                        NULL,                       // No input parameters
                        0,
                        NULL,                       // No output paramters
                        0
                        );

        if (!NT_SUCCESS(ntStatus))
        {
            TraceTag(ttidSvcCtl, "Failed to send STOP IOCTL to netbios (%08lx).",
                     "probably means Netbios isn't running... anyway, we can't stop it",
                     ntStatus);
            break;
        }

    } while (FALSE);


    //
    // 4. Close the handle just opened to the driver
    //

    if (NULL != NbHandle)
    {
        NtClose( NbHandle );
    }

    TraceError("ScStopNetbios", HRESULT_FROM_WIN32(ntStatus));

    return ntStatus;
}

// ----------------------------------------------------------------------
//
// Function:  HrEnableAndStartSpooler
//
// Purpose:   Start spooler, enable if necessary
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 19-May-98
//
// Notes:
//
HRESULT HrEnableAndStartSpooler ()
{
    static const WCHAR c_szSpooler[] = L"Spooler";

    TraceTag(ttidNetcfgBase, "entering ---> HrEnableAndStartSpooler" );

    // Try to start the spooler.  Need to explicitly open the service
    // control manager with all access first, so that in case we need to
    // change the start type, we have the proper permission.
    //
    CServiceManager scm;
    HRESULT hr = scm.HrOpen (NO_LOCK, SC_MANAGER_ALL_ACCESS);
    if (S_OK == hr)
    {
        hr = scm.HrStartServiceAndWait (c_szSpooler);
        if (HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED) == hr)
        {
            TraceTag(ttidNetcfgBase, "HrEnableAndStartSpooler: spooler is "
                "disabled trying to enable it..." );

            // Have to lock the service controller before changing the
            // configuration of a service.  Do so and unlock before trying to
            // start the service.
            //
            hr = scm.HrLock ();
            if (S_OK == hr)
            {
                CService svc;

                hr = scm.HrOpenService (&svc, c_szSpooler,
                            NO_LOCK,
                            SC_MANAGER_ALL_ACCESS,
                            STANDARD_RIGHTS_REQUIRED
                            | SERVICE_CHANGE_CONFIG);
                if (S_OK == hr)
                {
                    hr = svc.HrSetStartType (SERVICE_DEMAND_START);
                }

                scm.Unlock ();
            }

            if (S_OK == hr)
            {
                TraceTag(ttidNetcfgBase, "HrEnableAndStartSpooler: succeeded "
                    "in enabling spooer.  Now starting..." );

                hr = scm.HrStartServiceAndWait(c_szSpooler);
            }
        }
    }

    TraceError("HrEnableAndStartSpooler", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateDirectoryTree
//
//  Purpose:    Creates (or ensures existence of) all directories on the path
//              specified in szPath.
//
//  Arguments:
//      pszPath [in]    Full path of one or more directories to create
//                      (i.e. c:\this\is\a\directory\path)
//      psa     [in]    Security attributes
//
//  Returns:    S_OK if success, Win32 error code otherwise
//
//  Author:     shaunco (copied from RASUI by danielwe)   26 Jun 1998
//
//  Notes:
//
HRESULT HrCreateDirectoryTree(PWSTR pszPath, LPSECURITY_ATTRIBUTES psa)
{
    HRESULT hr = S_OK;

    if (pszPath)
    {
        DWORD   dwErr = ERROR_SUCCESS;

        // Loop through the path.
        //
        PWSTR pch;
        for (pch = pszPath; *pch; pch++)
        {
            // Stop at each backslash and make sure the path
            // is created to that point.  Do this by changing the
            // backslash to a null-terminator, calling CreateDirecotry,
            // and changing it back.
            //
            if (L'\\' == *pch)
            {
                BOOL fOk;

                *pch = 0;
                fOk = CreateDirectory(pszPath, psa);
                *pch = L'\\';

                // Any errors other than path alredy exists and we should
                // bail out.  We also get access denied when trying to
                // create a root drive (i.e. c:) so check for this too.
                //
                if (!fOk)
                {
                    dwErr = GetLastError();
                    if (ERROR_ALREADY_EXISTS == dwErr)
                    {
                        dwErr = ERROR_SUCCESS;
                    }
                    else if ((ERROR_ACCESS_DENIED == dwErr) &&
                             (pch - 1 > pszPath) && (L':' == *(pch - 1)))
                    {
                        dwErr = ERROR_SUCCESS;
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }

        if (ERROR_ALREADY_EXISTS == dwErr)
        {
            dwErr = ERROR_SUCCESS;
        }

        if (dwErr != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
        }
    }

    TraceError("HrCreateDirectoryTree", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDeleteFileSpecification
//
//  Purpose:    Delete the files specified with pszFileSpec from the
//              directory given by pszDirectoryPath.
//
//  Arguments:
//      pszFileSpec      [in] File specificaion to delete.  e.g. *.mdb
//      pszDirectoryPath [in] Directory path to delete from
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   4 Jun 1998
//
//  Notes:
//
HRESULT
HrDeleteFileSpecification (
    PCWSTR pszFileSpec,
    PCWSTR pszDirectoryPath)
{
    Assert (pszFileSpec && *pszFileSpec);
    Assert (pszDirectoryPath && *pszDirectoryPath);

    HRESULT hr = S_OK;

    INT cchSpec = lstrlenW (pszFileSpec);
    INT cchDir  = lstrlenW (pszDirectoryPath);

    // Make sure the length of the directory and filespec combined is less
    // than MAX_PATH before continuing.  The '+1' is for the backslash
    // that we may add.
    //
    if (cchDir + 1 + cchSpec > MAX_PATH)
    {
        hr = HRESULT_FROM_WIN32 (ERROR_BAD_PATHNAME);
    }
    else
    {
        WCHAR szPath[MAX_PATH];

        // Form the path by copying the directory and making sure it
        // is terminated with a backslash if needed.
        //
        lstrcpyW (szPath, pszDirectoryPath);
        if (cchDir &&
            (L':' != pszDirectoryPath[cchDir - 1]) &&
            (L'\\' != pszDirectoryPath[cchDir - 1]))
        {
            lstrcatW (szPath, L"\\");
            cchDir++;
        }

        // Append the filespec to the directory and look for the first
        // file.
        lstrcatW (szPath, pszFileSpec);

        TraceTag (ttidNetcfgBase, "Looking to delete %S (cchDir=%u)",
            szPath, cchDir);

        WIN32_FIND_DATA FindData;
        HANDLE hFind = FindFirstFile (szPath, &FindData);
        if (INVALID_HANDLE_VALUE != hFind)
        {
            PCWSTR  pszFileName;
            INT     cchFileName;

            do
            {
                // Skip files with these attributes.
                //
                if (FindData.dwFileAttributes & (FILE_ATTRIBUTE_DIRECTORY |
                                                 FILE_ATTRIBUTE_HIDDEN    |
                                                 FILE_ATTRIBUTE_READONLY  |
                                                 FILE_ATTRIBUTE_SYSTEM))
                {
                    continue;
                }

                // Use the shortname where possible to give us a chance
                // of using a path within MAX_PATH first.
                //
                pszFileName = FindData.cAlternateFileName;
                cchFileName = lstrlenW (pszFileName);
                if (!cchFileName)
                {
                    pszFileName = FindData.cFileName;
                    cchFileName = lstrlenW (pszFileName);
                }

                // If the length of the directory and filename don't exceed
                // MAX_PATH, form the full pathname and delete it.
                //
                if (cchDir + cchFileName < MAX_PATH)
                {
                    lstrcpyW (&szPath[cchDir], pszFileName);

                    TraceTag (ttidNetcfgBase, "Deleting %S", szPath);

                    if (!DeleteFile (szPath))
                    {
                        hr = HrFromLastWin32Error ();
                        TraceError ("DeleteFile failed.  Ignoring.", hr);
                    }
                }
            }
            while (FindNextFile (hFind, &FindData));

            // FindNextFile should set last error to ERROR_NO_MORE_FILES
            // on a succesful termination.
            //
            hr = HrFromLastWin32Error ();
            if (HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES) == hr)
            {
                hr = S_OK;
            }


            FindClose (hFind);
        }
        else
        {
            // If FindFirstFile didn't find anything, that's okay.
            //
            hr = HrFromLastWin32Error ();
            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_OK;
            }
        }
    }

    TraceError ("HrDeleteFileSpecification", hr);
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrDeleteDirectory
//
// Purpose:   Recursively delete a directory and its all sub-dirs.
//
// Arguments:
//    pszDir           [in]  full path to a dir
//    fContinueOnError [in]  whether to continue deleting others when we
//                           error when deleting one
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp    19-December-97
//            danielwe  15-December-98 (moved to common and revised)
//
// Notes:
//
HRESULT HrDeleteDirectory(IN PCWSTR pszDir,
                          IN BOOL fContinueOnError)
{
    HRESULT             hr = S_OK;
    WCHAR               szPrefix[MAX_PATH];
    WCHAR               szFileSpec[MAX_PATH];
    WCHAR               szAllFiles[MAX_PATH];
    HANDLE              hFileContext;
    WIN32_FIND_DATA     fd;

    TraceTag(ttidNetcfgBase, "Deleting directory %S", pszDir);
    lstrcpyW(szPrefix, pszDir);
    lstrcatW(szPrefix, L"\\");

    lstrcpyW(szAllFiles, pszDir);
    lstrcatW(szAllFiles, L"\\");
    lstrcatW(szAllFiles, L"*");

    hFileContext = FindFirstFile(szAllFiles, &fd);

    if (hFileContext != INVALID_HANDLE_VALUE)
    {
        do
        {
            lstrcpyW(szFileSpec, szPrefix);
            lstrcatW(szFileSpec, fd.cFileName);

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (!(!lstrcmpiW(fd.cFileName, L".") ||
                      !lstrcmpiW(fd.cFileName, L"..")))
                {
                    hr = HrDeleteDirectory(szFileSpec, fContinueOnError);
                    if (FAILED(hr) && fContinueOnError)
                    {
                        hr = S_OK;
                    }
                }
            }
            else
            {
                TraceTag(ttidNetcfgBase, "Deleting file %S", szFileSpec);

                if (DeleteFile(szFileSpec))
                {
                    hr = S_OK;
                }
                else
                {
                    TraceTag(ttidNetcfgBase, "Error deleting file %S",
                             szFileSpec);
                    TraceError("HrDeleteDirectory", hr);
                    hr = fContinueOnError ? S_OK : HrFromLastWin32Error();
                }
            }

            if ((S_OK == hr) && FindNextFile(hFileContext, &fd))
            {
                hr = S_OK;
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
        }
        while (S_OK == hr);

        if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES))
        {
            hr = S_OK;
        }

        FindClose(hFileContext);

        if (S_OK == hr)
        {
            if (RemoveDirectory(pszDir))
            {
                hr = S_OK;
            }
            else
            {
                TraceTag(ttidNetcfgBase, "Error deleting directory %S", pszDir);
                TraceLastWin32Error("HrDeleteDirectory");
                hr = fContinueOnError ? S_OK : HrFromLastWin32Error();
            }
        }
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrDeleteDirectory", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   LowerCaseComputerName
//
//  Purpose:    Utility function to lowercase a name obtained either from
//              the user via an UPPERCASE edit control, or via GetComputerName.
//
//  Arguments:
//      szName [in,out] Computername, which is modified in-place
//
//  Returns:    VOID
//
//  Author:     SumitC  29 Sep 1999
//
//  Notes:      The conversion only fails if CharLowerBuffW fails.  Per the user
//              guys, CharLowerBuff never actually returns any indication of
//              failure, so we can't tell anyway.  I've been assured that the
//              conversion is VERY unlikely to fail.
//
VOID
LowerCaseComputerName(
        IN OUT  PWSTR szName)
{
    // try the conversion
    Assert(szName);
    DWORD dwLen = wcslen(szName);
    DWORD dwConverted = CharLowerBuff(szName, dwLen);
    Assert(dwConverted == dwLen);
}

void __cdecl nc_trans_func( unsigned int uSECode, EXCEPTION_POINTERS* pExp )
{
    throw NC_SEH_Exception( uSECode );
}

void EnableCPPExceptionHandling()
{
    _set_se_translator(nc_trans_func);
}

void DisableCPPExceptionHandling()
{
    _set_se_translator(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncmsz.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C M S Z . C P P
//
//  Contents:   Common multi-sz routines.
//
//  Notes:      Split out from ncstring.cpp
//
//  Author:     shaunco   7 Jun 1998
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncstring.h"

//+---------------------------------------------------------------------------
//
//  Function:   CchOfMultiSzSafe
//
//  Purpose:    Count the number of characters of a double NULL terminated
//              multi-sz, including all NULLs except for the final terminating
//              NULL.
//
//  Arguments:
//      pmsz [in]   The multi-sz to count characters for.
//
//  Returns:    The count of characters.
//
//  Author:     tongl   17 June 1997
//
//  Notes:
//
ULONG
CchOfMultiSzSafe (
    IN PCWSTR pmsz)
{
    // NULL strings have zero length by definition.
    if (!pmsz)
        return 0;

    ULONG cchTotal = 0;
    ULONG cch;
    while (*pmsz)
    {
        cch = wcslen (pmsz) + 1;
        cchTotal += cch;
        pmsz += cch;
    }

    // Return the count of characters.
    return cchTotal;
}


//+---------------------------------------------------------------------------
//
//  Function:   CchOfMultiSzAndTermSafe
//
//  Purpose:    Count the number of characters of a double NULL terminated
//              multi-sz, including all NULLs.
//
//  Arguments:
//      pmsz [in]   The multi-sz to count characters for.
//
//  Returns:    The count of characters.
//
//  Author:     tongl   17 June 1997
//
//  Notes:
//
ULONG
CchOfMultiSzAndTermSafe (
    IN PCWSTR pmsz)
{
    // NULL strings have zero length by definition.
    if (!pmsz)
        return 0;

    // Return the count of characters plus room for the
    // extra null terminator.
    return CchOfMultiSzSafe (pmsz) + 1;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsSzInMultiSzSafe
//
//  Purpose:    Determine if a given string is present in a Multi-Sz string
//              by doing a case insensitive compare.
//
//  Arguments:
//      psz     [in]  String to search for in pmsz
//      pmsz    [in]  The multi-sz to search
//
//  Returns:    TRUE if the specified string 'psz' was found in 'pmsz'.
//
//  Author:     scottbri   25 Feb 1997
//
//  Notes:      Note that the code can handle Null input values.
//
BOOL
FIsSzInMultiSzSafe (
    IN PCWSTR psz,
    IN PCWSTR pmsz)
{
    if (!pmsz || !psz)
    {
        return FALSE;
    }

    while (*pmsz)
    {
        if (0 == _wcsicmp (pmsz, psz))
        {
            return TRUE;
        }
        pmsz += wcslen (pmsz) + 1;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FGetSzPositionInMultiSzSafe
//
//  Purpose:    Determine if a given string is present in a Multi-Sz string
//              by doing a case insensitive compare.
//
//  Arguments:
//      psz                [in]  String to search for in pmsz
//      pmsz               [in]  The multi-sz to search
//      pdwIndex           [out] The index of the first matching psz in pmsz
//      pfDuplicatePresent [out] Optional. TRUE if the string is present in
//                               the multi-sz more than once. FALSE otherwise.
//      pcStrings          [out] Optional. The number of strings in pmsz
//
//  Returns:    TRUE if the specified string 'psz' was found in 'pmsz'.
//
//  Author:     BillBe   9 Oct 1998
//
//  Notes:      Note that the code can handle Null input values.
//
BOOL
FGetSzPositionInMultiSzSafe (
    IN PCWSTR psz,
    IN PCWSTR pmsz,
    OUT DWORD* pdwIndex,
    OUT BOOL *pfDuplicatePresent,
    OUT DWORD* pcStrings)
{
    // initialize out params.
    //
    *pdwIndex = 0;

    if (pfDuplicatePresent)
    {
        *pfDuplicatePresent = FALSE;
    }

    if (pcStrings)
    {
        *pcStrings = 0;
    }

    if (!pmsz || !psz)
    {
        return FALSE;
    }

    // Need to keep track if duplicates are found
    BOOL fFoundAlready = FALSE;
    DWORD dwIndex = 0;

    while (*pmsz)
    {
        if (0 == _wcsicmp (pmsz, psz))
        {
            if (!fFoundAlready)
            {
                *pdwIndex = dwIndex;
                fFoundAlready = TRUE;
            }
            else if (pfDuplicatePresent)
            {
                *pfDuplicatePresent = TRUE;
            }
        }
        pmsz += wcslen (pmsz) + 1;
        ++dwIndex;
    }

    if (pcStrings)
    {
        *pcStrings = dwIndex;
    }

    return fFoundAlready;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrAddSzToMultiSz
//
//  Purpose:    Add a string into a REG_MULTI_SZ registry value
//
//  Arguments:
//      pszAddString    [in]    The string to add to the multi-sz
//      pmszIn          [in]    (OPTIONAL) The original Multi-Sz to add to.
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_ALLOW_DUPLICATES
//                                  Don't remove duplicate values when adding
//                                  the string to the list. Default is to
//                                  remove all other instance of this string.
//                              STRING_FLAG_ENSURE_AT_FRONT
//                                  Ensure the string is the first element of
//                                  the list. If the string is present and
//                                  duplicates aren't allowed, move the
//                                  string to the end.
//                              STRING_FLAG_ENSURE_AT_END
//                                  Ensure the string is the last
//                                  element of the list. This can not be used
//                                  with STRING_FLAG_ENSURE_AT_FRONT.  If the
//                                  string is present and duplicates aren't
//                                  allowed, move the string to the end.
//                              STRING_FLAG_ENSURE_AT_INDEX
//                                  Ensure that the string is at dwStringIndex
//                                  in the multi-sz.  If the index specified
//                                  is greater than the number of strings
//                                  in the multi-sz, the string will be
//                                  placed at the end.
//                              STRING_FLAG_DONT_MODIFY_IF_PRESENT
//                                  If the string already exists in the
//                                  multi-sz then no modication will take
//                                  place.  Note: This takes precedent
//                                  over the presence/non-presence of the
//                                  STRING_FLAG_ALLOW_DUPLICATES flag.
//                                  i.e nothing will be added or removed
//                                  if this flag is set and the string was
//                                  present in the multi-sz
//      dwStringIndex   [in]    If STRING_FLAG_ENSURE_AT_INDEX is specified,
//                              this is the index for the string position.
//                              Otherwise, this value is ignored.
//
//      pmszOut         [out]   The new multi-sz.
//      pfChanged       [out]   TRUE if the multi-sz changed in any way,
//                              FALSE otherwise.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
//  Modified:   BillBe      6 Oct 1998
//              (Extracted from HrRegAddStringTo MultiSz and modified)
//
HRESULT
HrAddSzToMultiSz(
    IN PCWSTR pszAddString,
    IN PCWSTR pmszIn,
    IN DWORD dwFlags,
    IN DWORD dwStringIndex,
    OUT PWSTR* ppmszOut,
    OUT BOOL* pfChanged)
{
    Assert(pszAddString && *pszAddString);
    Assert(ppmszOut);
    Assert(pfChanged);

    HRESULT hr = S_OK;

    BOOL fEnsureAtFront = dwFlags & STRING_FLAG_ENSURE_AT_FRONT;
    BOOL fEnsureAtEnd = dwFlags & STRING_FLAG_ENSURE_AT_END;
    BOOL fEnsureAtIndex = dwFlags & STRING_FLAG_ENSURE_AT_INDEX;

    // Can't specify more than one of these flags
    if ((fEnsureAtFront && fEnsureAtEnd) ||
        (fEnsureAtFront && fEnsureAtIndex) ||
        (fEnsureAtEnd && fEnsureAtIndex))
    {
        AssertSz(FALSE, "Invalid flags in HrAddSzToMultiSz");
        return E_INVALIDARG;
    }

    // Must specify at least one
    if (!fEnsureAtFront && !fEnsureAtEnd && !fEnsureAtIndex)
    {
        AssertSz(FALSE, "No operation flag specified in HrAddSzToMultiSz");
        return E_INVALIDARG;
    }

    // Initialize the output parameters.
    //
    *ppmszOut = NULL;
    *pfChanged = TRUE;
    DWORD dwIndex;
    BOOL fDupePresent;
    DWORD cItems;

    // If the string to add is not empty...
    //
    if (*pszAddString)
    {
        // Check if the string is already present in the MultiSz
        BOOL fPresent = FGetSzPositionInMultiSzSafe (pszAddString, pmszIn,
                &dwIndex, &fDupePresent, &cItems);

        if (fPresent)
        {
            // If the flag don't modify is present then we aren't changing
            // anything
            //
            if (dwFlags & STRING_FLAG_DONT_MODIFY_IF_PRESENT)
            {
                *pfChanged = FALSE;
            }

            // if there are no duplicates present and we are not allowing
            // duplicates, then we need to determine if the string is already in
            // the correct position
            //
            if (!fDupePresent && !(dwFlags & STRING_FLAG_ALLOW_DUPLICATES))
            {
                // If we are to insert the string at front but it is already
                // there, then we aren't changing anything
                //
                if (fEnsureAtFront && (0 == dwIndex))
                {
                    *pfChanged = FALSE;
                }

                // If we are to insert the string at the end but it is already
                // there, then we aren't changing anything
                //
                if (fEnsureAtEnd && (dwIndex == (cItems - 1)))
                {
                    *pfChanged = FALSE;
                }

                if (fEnsureAtIndex && (dwIndex == dwStringIndex))
                {
                    *pfChanged = FALSE;
                }
            }
        }
    }
    else
    {
        // If string to add was empty so we aren't changing anything
        *pfChanged = FALSE;
    }


    // If we are still going to change things...
    //
    if (*pfChanged)
    {

        DWORD cchDataSize = CchOfMultiSzSafe (pmszIn);

        // Enough space for the old data plus the new string and NULL, and for the
        // second trailing NULL (multi-szs are double-terminated)
        DWORD cchAllocSize = cchDataSize + wcslen (pszAddString) + 1 + 1;

        PWSTR pmszOrderNew = (PWSTR) MemAlloc(cchAllocSize * sizeof(WCHAR));

        if (pmszOrderNew)
        {
            // If we've gotten the "insert at front" flag, do the insert. Otherwise,
            // the default is "insert at end"
            //
            DWORD cchOffsetNew = 0;
            DWORD dwCurrentIndex = 0;
            if (fEnsureAtFront || (fEnsureAtIndex && (0 == dwStringIndex)))
            {
                // Insert our passed-in value at the beginning of the new buffer.
                //
                wcscpy (pmszOrderNew + cchOffsetNew, pszAddString);
                cchOffsetNew += wcslen ((PWSTR)pmszOrderNew) + 1;
                ++dwCurrentIndex;
            }

            // Loop through the old buffer, and copy all of the strings that are not
            // identical to our insertion string.
            //
            DWORD cchOffsetOld = 0;
            PWSTR pszCurrent;
            while ((cchOffsetOld + 1) < cchDataSize)
            {
                if (fEnsureAtIndex && (dwCurrentIndex == dwStringIndex))
                {
                    // Insert our passed-in value at the current index of the
                    // new buffer.
                    //
                    wcscpy (pmszOrderNew + cchOffsetNew, pszAddString);
                    cchOffsetNew += wcslen (pmszOrderNew + cchOffsetNew) + 1;
                    ++dwCurrentIndex;
                }
                else
                {
                    BOOL    fCopyThisElement    = FALSE;

                    // Get the next string in the list.
                    //
                    pszCurrent = (PWSTR) (pmszIn + cchOffsetOld);

                    // If we allow duplicates, then copy this element, else
                    // check for a match, and if there's no match, then
                    // copy this element.
                    if (dwFlags & STRING_FLAG_ALLOW_DUPLICATES)
                    {
                        fCopyThisElement = TRUE;
                    }
                    else
                    {
                        if (_wcsicmp (pszCurrent, pszAddString) != 0)
                        {
                            fCopyThisElement = TRUE;
                        }
                    }

                    // If we're allowing the copy, then copy!
                    if (fCopyThisElement)
                    {
                        wcscpy (pmszOrderNew + cchOffsetNew, pszCurrent);
                        cchOffsetNew +=
                                wcslen (pmszOrderNew + cchOffsetNew) + 1;
                        ++dwCurrentIndex;
                    }

                    // Update the offset
                    //
                    cchOffsetOld += wcslen (pmszIn + cchOffsetOld) + 1;
                }
            }


            // If we have the ENSURE_AT_END flag set or if the ENSURE_AT_INDEX
            // flag was set and the index was greater than the possible
            // index, this means we want to insert at the end
            //
            if (fEnsureAtEnd ||
                    (fEnsureAtIndex && (dwCurrentIndex <= dwStringIndex)))
            {
                wcscpy (pmszOrderNew + cchOffsetNew, pszAddString);
                cchOffsetNew += wcslen (pmszOrderNew + cchOffsetNew) + 1;
            }

            // Put the last of the double-NULL chars on the end.
            //
            pszCurrent = pmszOrderNew + cchOffsetNew;
            pszCurrent[0] = (WCHAR) 0;

            *ppmszOut = pmszOrderNew;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceError("HrAddSzToMultiSz", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrCreateArrayOfStringPointersIntoMultiSz
//
//  Purpose:    Allocates and initializes an array of string pointers.
//              The array of pointers is initialized to point to the
//              individual strings in a multi-sz.
//
//  Arguments:
//      pmszSrc   [in]  The multi-sz to index.
//      pcStrings [out] Returned count of string pointers in the array.
//      papsz     [out] Returned array of string pointers.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Author:     shaunco   20 Jun 1998
//
//  Notes:      It is the callers responsibility to ensure there is at
//              least one string. The restriction is explicitly chosen to
//              reduce confusion about what would be returned if the
//              multi-sz were empty.
//
//              Free the returned array with free.
//
HRESULT
HrCreateArrayOfStringPointersIntoMultiSz (
    IN PCWSTR pmszSrc,
    OUT UINT* pcStrings,
    OUT PCWSTR** papsz)
{
    Assert (pmszSrc && *pmszSrc);
    Assert (papsz);

    // First, count the number of strings in the multi-sz.
    //
    UINT    cStrings = 0;
    PCWSTR pmsz;
    for (pmsz = pmszSrc; *pmsz; pmsz += wcslen(pmsz) + 1)
    {
        cStrings++;
    }

    Assert (cStrings);  // See Notes above.
    *pcStrings = cStrings;

    // Allocate enough memory for the array.
    //
    HRESULT hr = HrMalloc (cStrings * sizeof(PWSTR*),
            reinterpret_cast<VOID**>(papsz));

    if (S_OK == hr)
    {
        // Initialize the returned array. ppsz is a pointer to each
        // element of the array.  It is incremented after each element
        // is initialized.
        //
        PCWSTR* ppsz = *papsz;

        for (pmsz = pmszSrc; *pmsz; pmsz += wcslen(pmsz) + 1)
        {
            *ppsz = pmsz;
            ppsz++;
        }
    }

    TraceError ("HrCreateArrayOfStringPointersIntoMultiSz", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RemoveSzFromMultiSz
//
//  Purpose:    Remove all occurrences of a string from a multi-sz.  The
//              removals are performed in place.
//
//  Arguments:
//      psz       [in]     The string to remove.
//      pmsz      [in out] The multi-sz to remove psz from.
//      dwFlags   [in]     Can contain one or more of the following
//                         values:
//
//                         STRING_FLAG_REMOVE_SINGLE
//                             Don't remove more than one value, if
//                             multiple are present.
//                         [default] STRING_FLAG_REMOVE_ALL
//                             If multiple matching values are present,
//                             remove them all.
//      pfRemoved [out]    Set to TRUE on return if one or more strings
//                         were removed.
//
//  Returns:    nothing
//
//  Author:     shaunco   8 Jun 1998
//
//  Notes:
//
VOID
RemoveSzFromMultiSz (
    IN PCWSTR psz,
    IN OUT PWSTR pmsz,
    IN DWORD dwFlags,
    OUT BOOL* pfRemoved)
{
    Assert (pfRemoved);

    // Initialize the output parameters.
    //
    *pfRemoved = FALSE;

    if (!pmsz || !psz || !*psz)
    {
        return;
    }

    // Look for all occurrences of psz in pmsz.  When one is found, move
    // the remaining part of the multi-sz over it.
    //
    while (*pmsz)
    {
        if (0 == _wcsicmp (pmsz, psz))
        {
            PWSTR  pmszRemain = pmsz + (wcslen (pmsz) + 1);
            INT    cchRemain = CchOfMultiSzAndTermSafe (pmszRemain);

            MoveMemory (pmsz, pmszRemain, cchRemain * sizeof(WCHAR));

            *pfRemoved = TRUE;

            if (dwFlags & STRING_FLAG_REMOVE_SINGLE)
            {
                break;
            }
        }
        else
        {
            pmsz += wcslen (pmsz) + 1;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SzListToMultiSz
//
//  Purpose:    Converts a comma-separated list into a multi-sz style list.
//
//  Arguments:
//      psz     [in]    String to be converted. It is not modified.
//      pcb     [out]   Number of *bytes* in the resulting string. If NULL,
//                      size is not returned.
//      ppszOut [out]   Resulting string.
//
//  Returns:    Nothing.
//
//  Author:     danielwe   3 Apr 1997
//
//  Notes:      Resulting string must be freed with MemFree.
//
VOID
SzListToMultiSz (
    IN PCWSTR psz,
    OUT DWORD* pcb,
    OUT PWSTR* ppszOut)
{
    Assert(psz);
    Assert(ppszOut);

    PCWSTR      pch;
    INT         cch;
    PWSTR       pszOut;
    const WCHAR c_chSep = L',';

    // Add 2 to the length. One for final NULL, and one for second NULL.
    cch = wcslen (psz) + 2;

    pszOut = (PWSTR)MemAlloc(CchToCb(cch));
    if (pszOut)
    {
        ZeroMemory(pszOut, CchToCb(cch));

        if (pcb)
        {
            *pcb = CchToCb(cch);
        }

        *ppszOut = pszOut;

        // count the number of separator chars and put NULLs there
        //
        for (pch = psz; *pch; pch++)
        {
            if (*pch == c_chSep)
            {
                *pszOut++ = 0;
            }
            else
            {
                *pszOut++ = *pch;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncmem.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C M E M . C P P
//
//  Contents:   Common memory management routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncmem.h"

// This global heap handle will be set to the process heap when the
// first request to allocate memory through MemAlloc is made.
//
HANDLE g_hHeap;

//+---------------------------------------------------------------------------
//
//  Function:   HrMalloc
//
//  Purpose:    HRESULT returning version of malloc.
//
//  Arguments:
//      cb  [in]    Count of bytes to allocate.
//      ppv [out]   Address of returned allocation.
//
//  Returns:    S_OK or E_OUTOFMEMORY;
//
//  Author:     shaunco   31 Mar 1998
//
//  Notes:      Free the returned buffer with free.
//
HRESULT
HrMalloc (
    size_t  cb,
    PVOID*  ppv)
{
    Assert (ppv);

    HRESULT hr = S_OK;

    *ppv = MemAlloc (cb);
    if (!*ppv)
    {
        hr = E_OUTOFMEMORY;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMalloc");
    return hr;
}

VOID*
MemAlloc (
    size_t cb)
{
#ifdef USE_HEAP_ALLOC
    if (!g_hHeap)
    {
        g_hHeap = GetProcessHeap();
    }
    return HeapAlloc (g_hHeap, 0, cb);
#else
    return malloc (cb);
#endif
}

VOID*
MemAllocRaiseException (
    size_t  cb)
{
    VOID* pv = MemAlloc (cb);
    if (!pv)
    {
        RaiseException (E_OUTOFMEMORY, 0, 0, NULL);
    }
    return pv;
}

VOID
MemFree (
    VOID*   pv)
{
#ifdef USE_HEAP_ALLOC
    if (!g_hHeap)
    {
        g_hHeap = GetProcessHeap();
    }
    if(pv) HeapFree (g_hHeap, 0, pv);
#else
    free (pv);
#endif
}

//+---------------------------------------------------------------------------
// CRT memory function overloads
//

const raiseexception_t raiseexception;

VOID*
__cdecl
operator new (
    size_t cb,
    const raiseexception_t&)
{
    return MemAllocRaiseException (cb);
}


const extrabytes_t extrabytes;

VOID*
__cdecl
operator new (
    size_t cb,
    const extrabytes_t&,
    size_t cbExtra)
{
    return MemAlloc (cb + cbExtra);
}


VOID*
__cdecl
operator new (
    size_t cb)
{
    return MemAlloc (cb);
}

VOID
__cdecl
operator delete (
    VOID* pv)
{
    MemFree (pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncperms.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       N C P E R M S . C P P
//
//  Contents:   Common routines for dealing with permissions.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   20 Sep 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include <ntseapi.h>
#include "ncbase.h"
#include "ncdebug.h"
#include "ncperms.h"
#include "netconp.h"
#include "ncreg.h"
#include "lm.h"

CGroupPolicyBase* g_pNetmanGPNLA = NULL;

#define INITGUID
#include <nmclsid.h>



//+---------------------------------------------------------------------------
//
//  Function:   FCheckGroupMembership
//
//  Purpose:    Returns TRUE if the logged on user is a member of the
//              specified group.
//
//  Arguments:
//      dwRID -
//
//  Returns:    TRUE if the logged on user is a member of the specified group
//
//  Author:     scottbri   14 Sept 1998
//
//  Notes:
//
BOOL FCheckGroupMembership(DWORD dwRID)
{
    SID_IDENTIFIER_AUTHORITY    SidAuth = SECURITY_NT_AUTHORITY;
    PSID                        psid;
    BOOL                        fIsMember = FALSE;

    // Allocate a SID for the Administrators group and check to see
    // if the user is a member.
    //
    if (AllocateAndInitializeSid (&SidAuth, 2,
                 SECURITY_BUILTIN_DOMAIN_RID,
                 dwRID,
                 0, 0, 0, 0, 0, 0,
                 &psid))
    {
        if (!CheckTokenMembership (NULL, psid, &fIsMember))
        {
            fIsMember = FALSE;
            TraceLastWin32Error ("FCheckGroupMembership - CheckTokenMemberShip failed.");
        }

        FreeSid (psid);
    }
    else
    {
        TraceLastWin32Error ("FCheckGroupMembership - AllocateAndInitializeSid failed.");
    }

    return fIsMember;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsUserAdmin
//
//  Purpose:    Returns TRUE if the logged on user is a member of the
//              Administrators local group.
//
//  Arguments:
//      (none)
//
//  Returns:    TRUE if the logged on user is a member of the
//              Administrators local group.  False otherwise.
//
//  Author:     shaunco   19 Mar 1998
//
//  Notes:
//
BOOL
FIsUserAdmin()
{
    BOOL fIsMember;

    // Check the administrators group
    //
    fIsMember = FCheckGroupMembership(DOMAIN_ALIAS_RID_ADMINS);

    return fIsMember;
}

//#define ALIGN_DWORD(_size) (((_size) + 3) & ~3)
//#define ALIGN_QWORD(_size) (((_size) + 7) & ~7)
#define SIZE_ALIGNED_FOR_TYPE(_size, _type) \
    (((_size) + sizeof(_type)-1) & ~(sizeof(_type)-1))




//+---------------------------------------------------------------------------
//
//  Function:   HrAllocateSecurityDescriptorAllowAccessToWorld
//
//  Purpose:    Allocate a security descriptor and initialize it to
//              allow access to everyone.
//
//  Arguments:
//      ppSd [out] Returned security descriptor.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   10 Nov 1998
//
//  Notes:      Free *ppSd with MemFree.
//
HRESULT
HrAllocateSecurityDescriptorAllowAccessToWorld (
    PSECURITY_DESCRIPTOR*   ppSd)
{
    PSECURITY_DESCRIPTOR    pSd = NULL;
    PSID                    pSid = NULL;
    PACL                    pDacl = NULL;
    DWORD                   dwErr = NOERROR;
    DWORD                   dwAlignSdSize;
    DWORD                   dwAlignDaclSize;
    DWORD                   dwSidSize;
    PVOID                   pvBuffer = NULL;

    // Here is the buffer we are building.
    //
    //   |<- a ->|<- b ->|<- c ->|
    //   +-------+--------+------+
    //   |      p|      p|       |
    //   | SD   a| DACL a| SID   |
    //   |      d|      d|       |
    //   +-------+-------+-------+
    //   ^       ^       ^
    //   |       |       |
    //   |       |       +--pSid
    //   |       |
    //   |       +--pDacl
    //   |
    //   +--pSd (this is returned via *ppSd)
    //
    //   pad is so that pDacl and pSid are aligned properly.
    //
    //   a = dwAlignSdSize
    //   b = dwAlignDaclSize
    //   c = dwSidSize
    //

    // Initialize output parameter.
    //
    *ppSd = NULL;

    // Compute the size of the SID.  The SID is the well-known SID for World
    // (S-1-1-0).
    //
    dwSidSize = GetSidLengthRequired(1);

    // Compute the size of the DACL.  It has an inherent copy of SID within
    // it so add enough room for it.  It also must sized properly so that
    // a pointer to a SID structure can come after it.  Hence, we use
    // SIZE_ALIGNED_FOR_TYPE.
    //
    dwAlignDaclSize = SIZE_ALIGNED_FOR_TYPE(
                        sizeof(ACCESS_ALLOWED_ACE) + sizeof(ACL) + dwSidSize,
                        PSID);

    // Compute the size of the SD.  It must be sized propertly so that a
    // pointer to a DACL structure can come after it.  Hence, we use
    // SIZE_ALIGNED_FOR_TYPE.
    //
    dwAlignSdSize   = SIZE_ALIGNED_FOR_TYPE(
                        sizeof(SECURITY_DESCRIPTOR),
                        PACL);

    // Allocate the buffer big enough for all.
    //
    dwErr = ERROR_OUTOFMEMORY;
    pvBuffer = MemAlloc(dwSidSize + dwAlignDaclSize + dwAlignSdSize);
    if (pvBuffer)
    {
        SID_IDENTIFIER_AUTHORITY SidIdentifierWorldAuth
                                    = SECURITY_WORLD_SID_AUTHORITY;
        PULONG  pSubAuthority;

        dwErr = NOERROR;

        // Setup the pointers into the buffer.
        //
        pSd   = pvBuffer;
        pDacl = (PACL)((PBYTE)pvBuffer + dwAlignSdSize);
        pSid  = (PSID)((PBYTE)pDacl + dwAlignDaclSize);

        // Initialize pSid as S-1-1-0.
        //
        if (!InitializeSid(
                pSid,
                &SidIdentifierWorldAuth,
                1))  // 1 sub-authority
        {
            dwErr = GetLastError();
            goto finish;
        }

        pSubAuthority = GetSidSubAuthority(pSid, 0);
        *pSubAuthority = SECURITY_WORLD_RID;

        // Initialize pDacl.
        //
        if (!InitializeAcl(
                pDacl,
                dwAlignDaclSize,
                ACL_REVISION))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Add an access-allowed ACE for S-1-1-0 to pDacl.
        //
        if (!AddAccessAllowedAce(
                pDacl,
                ACL_REVISION,
                STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL,
                pSid))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Initialize pSd.
        //
        if (!InitializeSecurityDescriptor(
                pSd,
                SECURITY_DESCRIPTOR_REVISION))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set pSd to use pDacl.
        //
        if (!SetSecurityDescriptorDacl(
                pSd,
                TRUE,
                pDacl,
                FALSE))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set the owner for pSd.
        //
        if (!SetSecurityDescriptorOwner(
                pSd,
                NULL,
                FALSE))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set the group for pSd.
        //
        if (!SetSecurityDescriptorGroup(
                pSd,
                NULL,
                FALSE))
        {
            dwErr = GetLastError();
            goto finish;
        }

finish:
        if (!dwErr)
        {
            *ppSd = pSd;
        }
        else
        {
            MemFree(pvBuffer);
        }
    }

    return HRESULT_FROM_WIN32(dwErr);
}

//+--------------------------------------------------------------------------
//
//  Function:   HrEnablePrivilege
//
//  Purpose:    Enables the specified privilege for the current process
//
//  Arguments:
//      pszPrivilegeName [in] The name of the privilege
//
//  Returns:    HRESULT. S_OK if successful,
//                       a converted Win32 error code otherwise
//
//  Author:     billbe   13 Dec 1997
//
//  Notes:
//
HRESULT
HrEnablePrivilege (
    IN PCWSTR pszPrivilegeName)
{
    HANDLE hToken;

    // Open the thread token in case it is impersonating
    BOOL fWin32Success = OpenThreadToken (GetCurrentThread(),
            TOKEN_ADJUST_PRIVILEGES, TRUE, &hToken);

    // If there was no token for the thread, open the process token
    //
    if (!fWin32Success && (ERROR_NO_TOKEN == GetLastError ()))
    {
        // Get token to adjust privileges for this process
        fWin32Success = OpenProcessToken (GetCurrentProcess(),
                TOKEN_ADJUST_PRIVILEGES, &hToken);
    }


    if (fWin32Success)
    {
        // get the luid that represents the privilege name
        LUID luid;
        fWin32Success = LookupPrivilegeValue(NULL, pszPrivilegeName, &luid);

        if (fWin32Success)
        {
            // set up the privilege structure
            TOKEN_PRIVILEGES tpNewPrivileges;
            tpNewPrivileges.PrivilegeCount = 1;
            tpNewPrivileges.Privileges[0].Luid = luid;
            tpNewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // turn on the privilege
            AdjustTokenPrivileges (hToken, FALSE, &tpNewPrivileges, 0,
                    NULL, NULL);

            if (ERROR_SUCCESS != GetLastError())
            {
                fWin32Success = FALSE;
            }
        }

        CloseHandle(hToken);
    }

    HRESULT hr;
    // Convert any errors to an HRESULT
    if (!fWin32Success)
    {
        hr = HrFromLastWin32Error();
    }
    else
    {
        hr = S_OK;
    }

    TraceError ("HrEnablePrivilege", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrEnableAllPrivileges
//
//  Purpose:    Enables all privileges for the current process.
//
//  Arguments:
//      pptpOld  [out]  Returns the previous state of privileges so that they can
//                      be restored.
//
//  Returns:    S_OK if successful, Win32 Error otherwise
//
//  Author:     danielwe   11 Aug 1997
//
//  Notes:      The pptpOld parameter should be freed with delete [].
//
HRESULT
HrEnableAllPrivileges (
    TOKEN_PRIVILEGES**  pptpOld)
{
    Assert(pptpOld);

    HRESULT hr = S_OK;
    HANDLE hTok;
    ULONG cbTok = 4096;
    BOOL fres;

    // Try opening the thread token first in case of impersonation
    fres = OpenThreadToken(GetCurrentThread(),
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, TRUE, &hTok);

    if (!fres && (ERROR_NO_TOKEN == GetLastError()))
    {
        // If there was no thread token open the process token
        fres = OpenProcessToken(GetCurrentProcess(),
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                         &hTok);
    }

    if (fres)
    {
        PTOKEN_PRIVILEGES ptpNew;
        hr = E_OUTOFMEMORY;
        ptpNew = (PTOKEN_PRIVILEGES)MemAlloc(cbTok);
        if (ptpNew)
        {
            hr = S_OK;

            fres = GetTokenInformation(hTok, TokenPrivileges,
                        ptpNew, cbTok, &cbTok);
            if (fres)
            {
                //
                // Set the state settings so that all privileges are enabled...
                //

                if (ptpNew->PrivilegeCount > 0)
                {
                    for (ULONG iPriv = 0; iPriv < ptpNew->PrivilegeCount; iPriv++)
                    {
                        ptpNew->Privileges[iPriv].Attributes = SE_PRIVILEGE_ENABLED;
                    }
                }

                *pptpOld = reinterpret_cast<PTOKEN_PRIVILEGES>(new BYTE[cbTok]);

                fres = AdjustTokenPrivileges(hTok, FALSE, ptpNew, cbTok, *pptpOld,
                                             &cbTok);
            }

            MemFree(ptpNew);
        }

        CloseHandle(hTok);
    }

    if (!fres)
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrEnableAllPrivileges", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRestorePrivileges
//
//  Purpose:    Restores the privileges for the current process after they have
//              have been modified by HrEnableAllPrivileges().
//
//  Arguments:
//      ptpRestore [in]     Previous state of privileges as returned by
//                          HrEnableAllPrivileges().
//
//  Returns:    S_OK if successful, Win32 Error otherwise
//
//  Author:     danielwe   11 Aug 1997
//
//  Notes:
//
HRESULT
HrRestorePrivileges (
    TOKEN_PRIVILEGES*   ptpRestore)
{
    HRESULT     hr = S_OK;
    HANDLE      hTok = NULL ;
    BOOL        fres = FALSE;

    Assert(ptpRestore);

    if (OpenProcessToken(GetCurrentProcess(),
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                         &hTok))
    {
        if (AdjustTokenPrivileges(hTok, FALSE, ptpRestore, 0, NULL, NULL))
        {
            fres = TRUE;
        }

        CloseHandle(hTok);
    }

    if (!fres)
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrRestorePrivileges", hr);
    return hr;
}

extern const DECLSPEC_SELECTANY WCHAR c_szConnectionsPolicies[] =
        L"Software\\Policies\\Microsoft\\Windows\\Network Connections";

// User types
const DWORD USER_TYPE_ADMIN         = 0x00000001;
const DWORD USER_TYPE_NETCONFIGOPS  = 0x00000002;
const DWORD USER_TYPE_POWERUSER     = 0x00000004;
const DWORD USER_TYPE_USER          = 0x00000008;
const DWORD USER_TYPE_GUEST         = 0x00000010;

typedef struct
{
    DWORD   dwShift;
    PCWSTR  pszValue;
    DWORD   dwApplyMask;
} PERM_MAP_STRUCT;

extern const DECLSPEC_SELECTANY PERM_MAP_STRUCT USER_PERM_MAP[] =
{
    {NCPERM_NewConnectionWizard,        L"NC_NewConnectionWizard", APPLY_TO_ALL_USERS},
    {NCPERM_Statistics,                 L"NC_Statistics", APPLY_TO_ALL_USERS},
    {NCPERM_AddRemoveComponents,        L"NC_AddRemoveComponents", APPLY_TO_ADMIN},
    {NCPERM_RasConnect,                 L"NC_RasConnect", APPLY_TO_ALL_USERS},
    {NCPERM_LanConnect,                 L"NC_LanConnect", APPLY_TO_ALL_USERS},
    {NCPERM_DeleteConnection,           L"NC_DeleteConnection", APPLY_TO_ALL_USERS},
    {NCPERM_DeleteAllUserConnection,    L"NC_DeleteAllUserConnection", APPLY_TO_ALL_USERS},
    {NCPERM_RenameConnection,           L"NC_RenameConnection", APPLY_TO_ALL_USERS},
    {NCPERM_RenameMyRasConnection,      L"NC_RenameMyRasConnection", APPLY_TO_ALL_USERS},
    {NCPERM_ChangeBindState,            L"NC_ChangeBindState", APPLY_TO_ADMIN},
    {NCPERM_AdvancedSettings,           L"NC_AdvancedSettings", APPLY_TO_ADMIN},
    {NCPERM_DialupPrefs,                L"NC_DialupPrefs", APPLY_TO_ALL_USERS},
    {NCPERM_LanChangeProperties,        L"NC_LanChangeProperties", APPLY_TO_OPS_OR_ADMIN},
    {NCPERM_RasChangeProperties,        L"NC_RasChangeProperties", APPLY_TO_ALL_USERS},
    {NCPERM_LanProperties,              L"NC_LanProperties", APPLY_TO_ALL_USERS},
    {NCPERM_RasMyProperties,            L"NC_RasMyProperties", APPLY_TO_ALL_USERS},
    {NCPERM_RasAllUserProperties,       L"NC_RasAllUserProperties", APPLY_TO_ALL_USERS},
    {NCPERM_ShowSharedAccessUi,         L"NC_ShowSharedAccessUi", APPLY_TO_LOCATION},
    {NCPERM_AllowAdvancedTCPIPConfig,   L"NC_AllowAdvancedTCPIPConfig", APPLY_TO_ALL_USERS},
    {NCPERM_PersonalFirewallConfig,     L"NC_PersonalFirewallConfig", APPLY_TO_LOCATION},
    {NCPERM_AllowNetBridge_NLA,         L"NC_AllowNetBridge_NLA", APPLY_TO_LOCATION},
    {NCPERM_ICSClientApp,               L"NC_ICSClientApp", APPLY_TO_LOCATION},
    {NCPERM_EnDisComponentsAllUserRas,  L"NC_EnDisComponentsAllUserRas", APPLY_TO_NON_ADMINS},
    {NCPERM_EnDisComponentsMyRas,       L"NC_EnDisComponentsMyRas", APPLY_TO_NON_ADMINS},
    {NCPERM_ChangeMyRasProperties,      L"NC_ChangeMyRasProperties", APPLY_TO_NON_ADMINS},
    {NCPERM_ChangeAllUserRasProperties, L"NC_ChangeAllUserRasProperties", APPLY_TO_NON_ADMINS},
    {NCPERM_RenameLanConnection,        L"NC_RenameLanConnection", APPLY_TO_NON_ADMINS},
    {NCPERM_RenameAllUserRasConnection, L"NC_RenameAllUserRasConnection", APPLY_TO_NON_ADMINS},
    {NCPERM_IpcfgOperation,             L"NC_IPConfigOperation", APPLY_TO_ALL_USERS},
    {NCPERM_Repair,                     L"NC_Repair", APPLY_TO_ALL_USERS},
};

extern const DECLSPEC_SELECTANY PERM_MAP_STRUCT MACHINE_PERM_MAP[] =
{
    {NCPERM_ShowSharedAccessUi,     L"NC_ShowSharedAccessUi", APPLY_TO_LOCATION},
    {NCPERM_PersonalFirewallConfig, L"NC_PersonalFirewallConfig", APPLY_TO_LOCATION},
    {NCPERM_ICSClientApp,           L"NC_ICSClientApp", APPLY_TO_LOCATION},
    {NCPERM_AllowNetBridge_NLA,     L"NC_AllowNetBridge_NLA", APPLY_TO_LOCATION}
};

extern const LONG NCPERM_Min = NCPERM_NewConnectionWizard;
extern const LONG NCPERM_Max = NCPERM_Repair;

// External policies (for now, only explorer has polices that affect our processing
//
extern const WCHAR c_szExplorerPolicies[] =
        L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer";

extern const WCHAR c_szNCPolicyForAdministrators[] =
        L"NC_EnableAdminProhibits";

extern const WCHAR c_szNoNetworkConnectionPolicy[] =
        L"NoNetworkConnections";


static DWORD g_dwPermMask;
static BOOL  g_fPermsInited = FALSE;

inline
VOID NCPERM_SETBIT(DWORD dw, DWORD dwVal)
{
    DWORD dwBit = (1 << dw);
    g_dwPermMask = (g_dwPermMask & ~dwBit) | ((0==dwVal) ? 0 : dwBit);
}

inline
BOOL NCPERM_CHECKBIT(DWORD dw)
{
    #ifdef DBG
        if (!FIsPolicyConfigured(dw))
        {
            if (0xFFFFFFFF != g_dwDbgPermissionsFail)
            {
                if (FProhibitFromAdmins() || !FIsUserAdmin())
                {
                    if ( (1 << dw) & g_dwDbgPermissionsFail)
                    {
                        TraceTag(ttidDefault, "Failing permissions check due to g_dwDbgPermissionsFail set");
                        return FALSE;
                    }
                }
            }
        }
    #endif  // DBG

    return !!(g_dwPermMask & (1 << dw));
}

inline
BOOL NCPERM_USER_IS_ADMIN(DWORD dwUserType)
{
    return (dwUserType & USER_TYPE_ADMIN);
}

inline
BOOL NCPERM_USER_IS_NETCONFIGOPS(DWORD dwUserType)
{
    return (dwUserType & USER_TYPE_NETCONFIGOPS);
}

inline
BOOL NCPERM_USER_IS_POWERUSER(DWORD dwUserType)
{
    return (dwUserType & USER_TYPE_POWERUSER);
}

inline
BOOL NCPERM_USER_IS_USER(DWORD dwUserType)
{
    return (dwUserType & USER_TYPE_USER);
}

inline
BOOL NCPERM_USER_IS_GUEST(DWORD dwUserType)
{
    return (dwUserType & USER_TYPE_GUEST);
}

inline
BOOL NCPERM_APPLIES_TO_CURRENT_USER(DWORD dwUserType, DWORD dwApplyMask)
{
    return (dwUserType & dwApplyMask);
}

inline
int NCPERM_FIND_MAP_ENTRY(ULONG ulPerm)
{

    for (int i = 0; i < celems(USER_PERM_MAP); i++)

    {
        if (USER_PERM_MAP[i].dwShift == ulPerm)
        {
            return i;
        }
    }

    return -1;
}

inline
BOOL NCPERM_APPLIES_TO_LOCATION(ULONG ulPerm)
{
    BOOL bAppliesToLocation = FALSE;

    int nIdx = NCPERM_FIND_MAP_ENTRY(ulPerm);

    if (nIdx != -1)
    {
        bAppliesToLocation = (USER_PERM_MAP[nIdx].dwApplyMask & APPLY_TO_LOCATION);
    }
    else
    {
        bAppliesToLocation = FALSE;
    }
    return bAppliesToLocation;
}


inline
BOOL NCPERM_APPLY_BASED_ON_LOCATION(ULONG ulPerm, DWORD dwPermission)
{
    DWORD fSameNetwork = FALSE;

    if (g_pNetmanGPNLA)
    {
        fSameNetwork = g_pNetmanGPNLA->IsSameNetworkAsGroupPolicies();
    }

    if (!fSameNetwork && NCPERM_APPLIES_TO_LOCATION(ulPerm))
    {
        dwPermission = TRUE;
    }
    return dwPermission;
}

inline
DWORD NCPERM_USER_TYPE()
{
    if (FIsUserAdmin())
    {
        return USER_TYPE_ADMIN;
    }
    else if (FIsUserNetworkConfigOps())
    {
        return USER_TYPE_NETCONFIGOPS;
    }
    else if (FIsUserPowerUser())
    {
        return USER_TYPE_POWERUSER;
    }
    else if (FIsUserGuest())
    {
        return USER_TYPE_GUEST;
    }

    return USER_TYPE_USER;
}

inline
BOOL IsOsLikePersonal()
{
    OSVERSIONINFOEXW verInfo = {0};
    ULONGLONG ConditionMask = 0;
    static BOOL fChecked = FALSE;
    static BOOL fOsLikePersonal = FALSE;
    
    // Optimization, since OS can't change on the fly.  Even a domain join requires a reboot.
    // If that ever changes then this logic needs to be revisited.

    if (fChecked)
    {
        return fOsLikePersonal;
    }

    verInfo.dwOSVersionInfoSize = sizeof(verInfo);
    verInfo.wProductType = VER_NT_WORKSTATION;
    
    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);
    
    if(VerifyVersionInfo(&verInfo, VER_PRODUCT_TYPE, ConditionMask))
    {
        LPWSTR pszDomain;
        NETSETUP_JOIN_STATUS njs = NetSetupUnknownStatus;
        if (NERR_Success == NetGetJoinInformation(NULL, &pszDomain, &njs))
        {
            NetApiBufferFree(pszDomain);
        }
        
        if (NetSetupDomainName == njs)
        {
            fOsLikePersonal = FALSE;    // connected to domain
        }
        else
        {
            fOsLikePersonal = TRUE;    // Professional, but not a domain member
        }
    }
    else
    {
        fOsLikePersonal = FALSE;
    }

    fChecked = TRUE;
    
    return fOsLikePersonal;
}


const ULONG c_arrayHomenetPerms[] =
{
    NCPERM_PersonalFirewallConfig,
    NCPERM_AllowNetBridge_NLA,
    NCPERM_ICSClientApp,
    NCPERM_ShowSharedAccessUi
};

#ifdef DBG
ULONG g_dwDbgPermissionsFail = 0xFFFFFFFF;
ULONG g_dwDbgWin2kPoliciesSet = 0xFFFFFFFF;
#endif // DBG

//+---------------------------------------------------------------------------
//
//  Function:   FHasPermission
//
//  Purpose:    Called to determine if the requested permissions are available
//
//  Arguments:
//      ulPerm [in]     permission flags
//
//  Returns:    BOOL, TRUE if the requested permission is granted to the user
//
BOOL
FHasPermission(ULONG ulPerm, CGroupPolicyBase* pGPBase)
{
    TraceFileFunc(ttidDefault);

    DWORD dwCurrentUserType;

    Assert(static_cast<LONG>(ulPerm) >= NCPERM_Min);
    Assert(static_cast<LONG>(ulPerm) <= NCPERM_Max);

    g_pNetmanGPNLA = pGPBase;

    //if the requested is from a homenet component and we are using DataCenter or
    //Advanced Server, than dont grant the permission
    for (int i = 0; i < celems(c_arrayHomenetPerms); i++)
    {
        if (c_arrayHomenetPerms[i] == ulPerm)
        {
// On IA64, all homenet technologies are unavailable.
#ifndef _WIN64
            // Look for the enterprise SKUs
            OSVERSIONINFOEXW verInfo = {0};
            ULONGLONG ConditionMask = 0;
            verInfo.dwOSVersionInfoSize = sizeof(verInfo);
            verInfo.wSuiteMask = VER_SUITE_ENTERPRISE;

            VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_AND);

            if(VerifyVersionInfo(&verInfo, VER_SUITENAME, ConditionMask))
#endif
            {
                return FALSE;
            }
        }
    }

    dwCurrentUserType = NCPERM_USER_TYPE();

    if (NCPERM_USER_IS_ADMIN(dwCurrentUserType) && !FProhibitFromAdmins() && !NCPERM_APPLIES_TO_LOCATION(ulPerm))
    {
        // If user is admin and we're not supposed to revoke
        // anything from admins and this is not a location aware policy
        // then just return TRUE
        return TRUE;
    }

    if (!g_fPermsInited)
    {
        TraceTag(ttidDefault, "Initializing permissions");
        g_fPermsInited = TRUE;
        RefreshAllPermission();
    }
    else
    {
        // update the requested permission only
        HRESULT hr      = S_OK;
        HKEY    hkey    = NULL;
        DWORD   dw      = 0;

        switch(ulPerm)
        {
        case NCPERM_OpenConnectionsFolder:
            TraceTag(ttidDefault, "Reading OpenConnectionsFolder permissions");
            hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, c_szExplorerPolicies,
                                KEY_READ, &hkey);

            if (S_OK == hr)
            {
                TraceTag(ttidDefault, "Opened explorer policies");
                hr = HrRegQueryDword(hkey, c_szNoNetworkConnectionPolicy, &dw);
                if (SUCCEEDED(hr) && dw)
                {
                    TraceTag(ttidDefault,
                        "Explorer 'No open connections folder' policy: %d", dw);
                    NCPERM_SETBIT(NCPERM_OpenConnectionsFolder, 0);

                }

                RegCloseKey(hkey);
                hkey = NULL;
            }
            break;

        default:
            hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, c_szConnectionsPolicies,
                                KEY_READ, &hkey);
            if (S_OK == hr)
            {
                DWORD dw;

                // Read the User Policy
                for (UINT nIdx=0; nIdx<celems(USER_PERM_MAP); nIdx++)
                {
                    if (ulPerm == USER_PERM_MAP[nIdx].dwShift && NCPERM_APPLIES_TO_CURRENT_USER(dwCurrentUserType, USER_PERM_MAP[nIdx].dwApplyMask))
                    {
                        hr = HrRegQueryDword(hkey, USER_PERM_MAP[nIdx].pszValue, &dw);
                        if (SUCCEEDED(hr))
                        {
                            NCPERM_SETBIT(USER_PERM_MAP[nIdx].dwShift, dw);
                        }
                    }
                }

                RegCloseKey(hkey);
            }

            // Read the machine policy
            //
            hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szConnectionsPolicies,
                                KEY_READ, &hkey);
            if (S_OK == hr)
            {
                DWORD dw;

                for (UINT nIdx=0; nIdx<celems(MACHINE_PERM_MAP); nIdx++)
                {
                    if (ulPerm == MACHINE_PERM_MAP[nIdx].dwShift)
                    {
                        hr = HrRegQueryDword(hkey, MACHINE_PERM_MAP[nIdx].pszValue, &dw);
                        if (S_OK == hr)
                        {
                            NCPERM_SETBIT(MACHINE_PERM_MAP[nIdx].dwShift, NCPERM_APPLY_BASED_ON_LOCATION(ulPerm, dw));
                        }
                    }
                }

                RegCloseKey(hkey);
            }
            break;
        }
    }
    return NCPERM_CHECKBIT(ulPerm);
}


BOOL
FHasPermissionFromCache(ULONG ulPerm)
{
    Assert(static_cast<LONG>(ulPerm) >= NCPERM_Min);
    Assert(static_cast<LONG>(ulPerm) <= NCPERM_Max);

    if (!g_fPermsInited)
    {
        g_fPermsInited = TRUE;
        RefreshAllPermission();
    }

    return NCPERM_CHECKBIT(ulPerm);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRestorePrivileges
//
//  Purpose:    Restores the privileges for the current process after they have
//              have been modified by HrEnableAllPrivileges().
//
//  Arguments:
//      ptpRestore [in]     Previous state of privileges as returned by
//                          HrEnableAllPrivileges().
//
//  Returns:    S_OK if successful, Win32 Error otherwise
//
//  Author:     danielwe   11 Aug 1997
//
//  Notes:
//
BOOL FProhibitFromAdmins()
{
    HRESULT hr = S_OK;
    HKEY hKey;
    DWORD dw;
    BOOL bEnabled = FALSE;

#ifdef DBG
    if (0xFFFFFFFF != g_dwDbgWin2kPoliciesSet)
    {
        return g_dwDbgWin2kPoliciesSet;
    }
#endif // DBG

    hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, c_szConnectionsPolicies,
        KEY_READ, &hKey);

    if (S_OK == hr)
    {
        hr = HrRegQueryDword(hKey, c_szNCPolicyForAdministrators, &dw);
        bEnabled = (dw) ? TRUE : FALSE;
        RegCloseKey(hKey);
    }

    TraceErrorOptional("FProhibitFromAdmins", hr, (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr));

    return bEnabled;
}

VOID RefreshAllPermission()
{
    DWORD dwCurrentUserType;
    HKEY hkey;
    HRESULT hr;
    DWORD dw;

    dwCurrentUserType = NCPERM_USER_TYPE();

    g_dwPermMask = 0;

    // If Admin assume all rights
    //
    if (NCPERM_USER_IS_ADMIN(dwCurrentUserType))
    {
        // Cheat a little by setting all bits to one
        //
        g_dwPermMask = 0xFFFFFFFF;

        // If this policy is not set, then we don't need to worry about reading the regkeys
        // since we can never take anything away from Admins.
    }
    else if (NCPERM_USER_IS_NETCONFIGOPS(dwCurrentUserType))
    {
        NCPERM_SETBIT(NCPERM_NewConnectionWizard, 1);
        NCPERM_SETBIT(NCPERM_Statistics, 1);
        NCPERM_SETBIT(NCPERM_RasConnect, 1);
        NCPERM_SETBIT(NCPERM_DeleteConnection, 1);
        NCPERM_SETBIT(NCPERM_DeleteAllUserConnection, 1);
        NCPERM_SETBIT(NCPERM_RenameConnection, 1);
        NCPERM_SETBIT(NCPERM_RenameMyRasConnection, 1);
        NCPERM_SETBIT(NCPERM_RenameAllUserRasConnection, 1);
        NCPERM_SETBIT(NCPERM_RenameLanConnection, 1);
        NCPERM_SETBIT(NCPERM_DialupPrefs, 1);
        NCPERM_SETBIT(NCPERM_RasChangeProperties, 1);
        NCPERM_SETBIT(NCPERM_RasMyProperties, 1);
        NCPERM_SETBIT(NCPERM_RasAllUserProperties, 1);
        NCPERM_SETBIT(NCPERM_ChangeAllUserRasProperties, 1);
        NCPERM_SETBIT(NCPERM_LanProperties, 1);
        NCPERM_SETBIT(NCPERM_LanChangeProperties, 1);
        NCPERM_SETBIT(NCPERM_AllowAdvancedTCPIPConfig, 1);
        NCPERM_SETBIT(NCPERM_OpenConnectionsFolder, 1);
        NCPERM_SETBIT(NCPERM_LanConnect, 1);
        NCPERM_SETBIT(NCPERM_EnDisComponentsAllUserRas, 1);
        NCPERM_SETBIT(NCPERM_EnDisComponentsMyRas, 1);
        NCPERM_SETBIT(NCPERM_IpcfgOperation, 1);
        NCPERM_SETBIT(NCPERM_Repair, 1);
    }
    else if (NCPERM_USER_IS_POWERUSER(dwCurrentUserType))
    {
        NCPERM_SETBIT(NCPERM_Repair, 1);

        // Rest should be like NCPERM_USER_IS_USER
        NCPERM_SETBIT(NCPERM_NewConnectionWizard, 1);
        NCPERM_SETBIT(NCPERM_Statistics, 1);
        NCPERM_SETBIT(NCPERM_RasConnect, 1);
        NCPERM_SETBIT(NCPERM_DeleteConnection, 1);
        NCPERM_SETBIT(NCPERM_RenameMyRasConnection, 1);
        NCPERM_SETBIT(NCPERM_DialupPrefs, 1);
        NCPERM_SETBIT(NCPERM_RasChangeProperties, 1);
        NCPERM_SETBIT(NCPERM_RasMyProperties, 1);
        NCPERM_SETBIT(NCPERM_AllowAdvancedTCPIPConfig, 1);
        NCPERM_SETBIT(NCPERM_LanProperties, 1);
        NCPERM_SETBIT(NCPERM_OpenConnectionsFolder, 1);
        if (IsOsLikePersonal())
        {
            NCPERM_SETBIT(NCPERM_RasAllUserProperties, 1);
            NCPERM_SETBIT(NCPERM_ChangeAllUserRasProperties, 1);
        }
    }
    else if (NCPERM_USER_IS_USER(dwCurrentUserType))
    {
        NCPERM_SETBIT(NCPERM_NewConnectionWizard, 1);
        NCPERM_SETBIT(NCPERM_Statistics, 1);
        NCPERM_SETBIT(NCPERM_RasConnect, 1);
        NCPERM_SETBIT(NCPERM_DeleteConnection, 1);
        NCPERM_SETBIT(NCPERM_RenameMyRasConnection, 1);
        NCPERM_SETBIT(NCPERM_DialupPrefs, 1);
        NCPERM_SETBIT(NCPERM_RasChangeProperties, 1);
        NCPERM_SETBIT(NCPERM_RasMyProperties, 1);
        NCPERM_SETBIT(NCPERM_AllowAdvancedTCPIPConfig, 1);
        NCPERM_SETBIT(NCPERM_LanProperties, 1);
        NCPERM_SETBIT(NCPERM_OpenConnectionsFolder, 1);
        if (IsOsLikePersonal())
        {
            NCPERM_SETBIT(NCPERM_RasAllUserProperties, 1);
            NCPERM_SETBIT(NCPERM_ChangeAllUserRasProperties, 1);
        }
    }
    else if (NCPERM_USER_IS_GUEST(dwCurrentUserType))
    {
        NCPERM_SETBIT(NCPERM_Statistics, 1);
        NCPERM_SETBIT(NCPERM_OpenConnectionsFolder, 1);
    }

    if (FProhibitFromAdmins() || !NCPERM_USER_IS_ADMIN(dwCurrentUserType))
    {
       // Read folder policy
        hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, c_szExplorerPolicies,
                            KEY_READ, &hkey);
        if (S_OK == hr)
        {
            TraceTag(ttidDefault, "Opened Explorer Policy reg key");

            hr = HrRegQueryDword(hkey, c_szNoNetworkConnectionPolicy, &dw);
            if (SUCCEEDED(hr) && dw)
            {
                TraceTag(ttidDefault,  "Explorer 'No open connections folder' policy: %d", dw);
                NCPERM_SETBIT(NCPERM_OpenConnectionsFolder, 0);
            }

            RegCloseKey(hkey);

            hkey = NULL;
        }

        // Read the user policy
        //
        hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, c_szConnectionsPolicies,
                            KEY_READ, &hkey);

        if (S_OK == hr)
        {
            for (UINT nIdx=0; nIdx<celems(USER_PERM_MAP); nIdx++)
            {
                if (NCPERM_APPLIES_TO_CURRENT_USER(dwCurrentUserType, USER_PERM_MAP[nIdx].dwApplyMask))
                {
                    hr = HrRegQueryDword(hkey, USER_PERM_MAP[nIdx].pszValue, &dw);

                    if (SUCCEEDED(hr))
                    {
                        NCPERM_SETBIT(USER_PERM_MAP[nIdx].dwShift, dw);
                    }
                }
            }

            RegCloseKey(hkey);

        }
    }

    // Read the machine policy
    //
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szConnectionsPolicies,
                        KEY_READ, &hkey);
    if (S_OK == hr)
    {
        DWORD dw;

        for (UINT nIdx=0; nIdx<celems(MACHINE_PERM_MAP); nIdx++)
        {
            hr = HrRegQueryDword(hkey, MACHINE_PERM_MAP[nIdx].pszValue, &dw);
            if (S_OK == hr)
            {
                NCPERM_SETBIT(MACHINE_PERM_MAP[nIdx].dwShift, NCPERM_APPLY_BASED_ON_LOCATION(MACHINE_PERM_MAP[nIdx].dwShift, dw));
            }
        }

        RegCloseKey(hkey);
    }
}





//+---------------------------------------------------------------------------
//
// Function:    IsHNetAllowed
//
// Purpose:     Verify the permission to use/enable (ICS/Firewall and create bridge network)
//
// Checks the following:
//
// Does the architecture / SKU permit the use of homenet technologies?
// Does group policy allow the particular technology?
// Is the user an Admin and are admins allowed access to this technology?
//
// Example scenario. The user is a Admin but ITG disables the right to create bridge this function would return FALSE
//
BOOL
IsHNetAllowed(
    DWORD dwPerm
    )
{
#ifndef _WIN64
    BOOL                fPermission = false;
    OSVERSIONINFOEXW    verInfo = {0};
    ULONGLONG           ConditionMask = 0;

    // Look for the enterprise SKUs
    verInfo.dwOSVersionInfoSize = sizeof(verInfo);
    verInfo.wSuiteMask = VER_SUITE_ENTERPRISE;

    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_AND);

    if ( VerifyVersionInfo(&verInfo, VER_SUITENAME, ConditionMask) )
    {
        // Homenet technologies are not available on enterprise SKUs
        return FALSE;
    }

    if ( FIsUserAdmin() && !FProhibitFromAdmins() )
    {
        HRESULT hr;
        INetMachinePolicies* pMachinePolicy;

        hr = CoCreateInstance(
            CLSID_NetGroupPolicies,
            NULL,
            CLSCTX_SERVER,
            IID_INetMachinePolicies,
            reinterpret_cast<void **>(&pMachinePolicy)
            );

            if ( SUCCEEDED(hr) )
        {
            hr = pMachinePolicy->VerifyPermission(dwPerm, &fPermission);
            pMachinePolicy->Release();
        }
    }

    return fPermission;

#else   // #ifndef _WIN64

    // On IA64, homenet technologies are not available at all.
    return FALSE;

#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   FIsUserNetworkConfigOps
//
//  Purpose:    Checks to see if the current user is a NetConfig Operator
//
//
//  Arguments:
//              none.
//
//
//  Returns:    BOOL.
//
//  Author:     ckotze   12 Jun 2000
//
//  Notes:
//
BOOL FIsUserNetworkConfigOps()
{
    BOOL fIsMember;

    fIsMember = FCheckGroupMembership(DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS);

    return fIsMember;
}


//+---------------------------------------------------------------------------
//
//  Function:   FIsUserPowerUser
//
//  Purpose:    Checks to see if the current user is a Power User
//
//
//  Arguments:
//              none.
//
//
//  Returns:    BOOL.
//
//  Author:     deonb   9 May 2001
//
//  Notes:
//
BOOL FIsUserPowerUser()
{
    BOOL fIsMember;

    fIsMember = FCheckGroupMembership(DOMAIN_ALIAS_RID_POWER_USERS);

    return fIsMember;
}


//+---------------------------------------------------------------------------
//
//  Function:   FIsUserGuest
//
//  Purpose:    Checks to see if the current user is a Guest
//
//
//  Arguments:
//              none.
//
//
//  Returns:    BOOL.
//
//  Author:     ckotze   12 Jun 2000
//
//  Notes:
//
BOOL FIsUserGuest()
{
    BOOL fIsMember;
    
    fIsMember = FCheckGroupMembership(DOMAIN_ALIAS_RID_GUESTS);
    
    return fIsMember;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsPolicyConfigured
//
//  Purpose:    Checks to see if the specific policy is configured
//
//
//  Arguments:
//              none.
//
//
//  Returns:    BOOL.
//
//  Author:     ckotze   12 Jun 2000
//
//  Notes:
//
BOOL FIsPolicyConfigured(DWORD ulPerm)
{
    HRESULT hr;
    HKEY hkey;
    BOOL bConfigured = FALSE;

    hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, c_szConnectionsPolicies, KEY_READ, &hkey);

    if (S_OK == hr)
    {
        DWORD dw;

        if (ulPerm == USER_PERM_MAP[ulPerm].dwShift)
        {
            DWORD dw;

            hr = HrRegQueryDword(hkey, USER_PERM_MAP[static_cast<DWORD>(ulPerm)].pszValue, &dw);
            if (SUCCEEDED(hr))
            {
                bConfigured = TRUE;
            }
        }

        RegCloseKey(hkey);
    }

    return bConfigured;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsSameNetworkAsGroupPolicies
//
//  Purpose:    Checks to see if the current network is the same as where the
//              Group Policies were assigned from.
//
//  Arguments:
//              none.
//
//
//  Returns:    BOOL
//
//  Author:     ckotze   05 Jan 2001
//
//  Notes:
//
BOOL IsSameNetworkAsGroupPolicies()
{
    return g_pNetmanGPNLA->IsSameNetworkAsGroupPolicies();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncreg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R E G . C P P
//
//  Contents:   Common routines for dealing with the registry.
//
//  Notes:
//
//  Author:     danielwe   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncreg.h"
#include "ncstring.h"
#include "ncperms.h"

extern const WCHAR c_szAdapters[];
extern const WCHAR c_szBackslash[];
extern const WCHAR c_szParameters[];
extern const WCHAR c_szRegKeyServices[];

//+---------------------------------------------------------------------------
//
//  Function:   HrRegAddStringToMultiSz
//
//  Purpose:    Add a string into a REG_MULTI_SZ registry value
//
//  Arguments:
//      pszAddString    [in]    The string to add to the multi-sz
//      hkeyRoot        [in]    An open registry key, or one of the
//                              predefined hkey values (HKEY_LOCAL_MACHINE,
//                              for instance)
//      pszKeySubPath   [in]    Name of the subkey to open.
//      pszValueName    [in]    Name of the registry value that we're going to
//                              modify.
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_ALLOW_DUPLICATES
//                                  Don't remove duplicate values when adding
//                                  the string to the list. Default is to
//                                  remove all other instance of this string.
//                              STRING_FLAG_ENSURE_AT_FRONT
//                                  Ensure the string is the first element of
//                                  the list. If the string is present and
//                                  duplicates aren't allowed, move the
//                                  string to the end.
//                              STRING_FLAG_ENSURE_AT_END
//                                  Ensure the string is the last
//                                  element of the list. This can not be used
//                                  with STRING_FLAG_ENSURE_AT_FRONT.  If the
//                                  string is present and duplicates aren't
//                                  allowed, move the string to the end.
//                              STRING_FLAG_ENSURE_AT_INDEX
//                                  Ensure that the string is at dwStringIndex
//                                  in the multi-sz.  If the index specified
//                                  is greater than the number of strings
//                                  in the multi-sz, the string will be
//                                  placed at the end.
//                              STRING_FLAG_DONT_MODIFY_IF_PRESENT
//                                  If the string already exists in the
//                                  multi-sz then no modication will take
//                                  place.  Note: This takes precedent
//                                  over the presence/non-presence of the
//                                  STRING_FLAG_ALLOW_DUPLICATES flag.
//                                  i.e nothing will be added or removed
//                                  if this flag is set and the string was
//                                  present in the multi-sz
//      dwIndex         [in]    If STRING_FLAG_ENSURE_AT_INDEX is specified,
//                              this is the index for the string position.
//                              Otherwise, this value is ignored.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
HRESULT
HrRegAddStringToMultiSz (
    IN PCWSTR  pszAddString,
    IN HKEY    hkeyRoot,
    IN PCWSTR  pszKeySubPath,
    IN PCWSTR  pszValueName,
    IN DWORD   dwFlags,
    IN DWORD   dwIndex)
{
    HRESULT     hr              = S_OK;
    DWORD       dwRegType       = 0;        // Should be REG_MULTI_SZ
    HKEY        hkeyOpen        = NULL;     // Return value from RegCreateKeyEx
    HKEY        hkeyUse         = NULL;     // The key value that we'll actually use
    LPBYTE      pbOrderOld      = NULL;     // Return buffer for order reg value
    LPBYTE      pbOrderNew      = NULL;     // Build buffer for order swap

    // Check for valid parameters
    if (!pszAddString || !hkeyRoot || !pszValueName)
    {
        Assert(pszAddString);
        Assert(hkeyRoot);
        Assert(pszValueName);

        hr = E_INVALIDARG;
        goto Exit;
    }

    // Check to make sure that no "remove" flags are being used, and that
    // mutually exclusive flags aren't being used together
    //
    if ((dwFlags & STRING_FLAG_REMOVE_SINGLE)      ||
        (dwFlags & STRING_FLAG_REMOVE_ALL)         ||
        ((dwFlags & STRING_FLAG_ENSURE_AT_FRONT)   &&
         (dwFlags & STRING_FLAG_ENSURE_AT_END)))
    {
        AssertSz(FALSE, "Invalid flags in HrRegAddStringToMultiSz");

        hr = E_INVALIDARG;
        goto Exit;
    }

    // If the user passed in a subkey string, then we should attempt to open
    // the subkey of the passed in root, else we'll just use the
    // pre-opened hkeyRoot
    //
    if (pszKeySubPath)
    {
        // Open the key, creating if necessary
        //
        hr = HrRegCreateKeyEx (
                hkeyRoot,                           // Base hive
                pszKeySubPath,                      // Our reg path
                0,                                  // dwOptions
                KEY_QUERY_VALUE | KEY_SET_VALUE,    // samDesired
                NULL,                               // lpSecurityAttributes
                &hkeyOpen,                          // Our return hkey.
                NULL);
        if (FAILED(hr))
        {
            goto Exit;
        }

        hkeyUse = hkeyOpen;
    }
    else
    {
        // Use the passed in key for the Query.
        //
        hkeyUse = hkeyRoot;
    }

    // Retrieve the existing REG_MULTI_SZ
    //
    hr = HrRegQueryValueWithAlloc (
            hkeyUse,
            pszValueName,
            &dwRegType,
            &pbOrderOld,
            NULL);
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            // This is OK. It just means that the value was missing, and we
            // should continue on, and create the value ourselves.
            hr = S_OK;
        }
        else
        {
            // Since there's an error that we didn't expect, drop out,
            // returning this error to the caller.
            //
            goto Exit;
        }
    }
    else
    {
        // If we did retrieve a value, then check to make sure that we're
        // dealing with a MULTI_SZ
        //
        if (dwRegType != REG_MULTI_SZ)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE);
            goto Exit;
        }
    }

    BOOL fChanged;
    hr = HrAddSzToMultiSz (pszAddString, (PCWSTR)pbOrderOld,
            dwFlags, dwIndex, (PWSTR*)&pbOrderNew, &fChanged);

    if ((S_OK == hr) && fChanged)
    {
        DWORD cbNew = CbOfMultiSzAndTermSafe ((PWSTR)pbOrderNew);

        // Save our string back into the registry
        //
        hr = HrRegSetValueEx (
                hkeyUse,
                pszValueName,
                REG_MULTI_SZ,
                (const BYTE *)pbOrderNew,
                cbNew);
    }

Exit:
    // Close the key, if opened
    //
    RegSafeCloseKey (hkeyOpen);

    // Clean up the registry buffers
    //
    MemFree (pbOrderOld);
    MemFree (pbOrderNew);

    TraceError ("HrRegAddStringToMultiSz", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegAddStringToSz
//
//  Purpose:    Add a string into a REG_MULTI_SZ registry value
//
//  Arguments:
//      pszAddString    [in]    The string to add to the multi-sz
//      hkeyRoot        [in]    An open registry key, or one of the
//                              predefined hkey values (HKEY_LOCAL_MACHINE,
//                              for instance)
//      pszKeySubPath   [in]    Name of the subkey to open.
//      pszValueName    [in]    Name of the registry value that we're going to
//                              modify.
//      chDelimiter     [in]    The character to be used to delimit the
//                              values. Most multi-valued REG_SZ strings are
//                              delimited with either ',' or ' '. This will
//                              be used to delimit the value that we add,
//                              as well.
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_ALLOW_DUPLICATES
//                                  Don't remove duplicate values when adding
//                                  the string to the list. Default is to
//                                  remove all other instance of this string.
//                              STRING_FLAG_ENSURE_AT_FRONT
//                                  Insert the string as the first element of
//                                  the list.
//                              STRING_FLAG_ENSURE_AT_END
//                                  Insert the string as the last
//                                  element of the list. This can not be used
//                                  with STRING_FLAG_ENSURE_AT_FRONT.
//                              STRING_FLAG_ENSURE_AT_INDEX
//                                  Ensure that the string is at dwStringIndex
//                                  in the sz.  If the index specified
//                                  is greater than the number of strings
//                                  in the sz, the string will be
//                                  placed at the end.
//      dwStringIndex   [in]    If STRING_FLAG_ENSURE_AT_INDEX is specified,
//                              this is the index for the string position.
//                              Otherwise, this value is ignored.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
//
//  Note:
//      Might want to allow for the removal of leading/trailing spaces
//
HRESULT
HrRegAddStringToSz (
    IN PCWSTR  pszAddString,
    IN HKEY    hkeyRoot,
    IN PCWSTR  pszKeySubPath,
    IN PCWSTR  pszValueName,
    IN WCHAR   chDelimiter,
    IN DWORD   dwFlags,
    IN DWORD   dwStringIndex)
{
    HRESULT    hr              = S_OK;
    DWORD      dwRegType       = 0;        // Should be REG_MULTI_SZ
    HKEY       hkeyOpen        = NULL;     // Open key to open
    PWSTR      pszOrderOld     = NULL;     // Return buffer for order reg value
    PWSTR      pszOrderNew     = NULL;     // Build buffer for order swap

    // Check for all of the required args
    //
    if (!pszAddString || !hkeyRoot || !pszValueName)
    {
        Assert(pszAddString);
        Assert(hkeyRoot);
        Assert(pszValueName);

        hr = E_INVALIDARG;
        goto Exit;
    }

    // Check to make sure that no "remove" flags are being used, and that
    // mutually exclusive flags aren't being used together
    //
    if ((dwFlags & STRING_FLAG_REMOVE_SINGLE) ||
        (dwFlags & STRING_FLAG_REMOVE_ALL))
    {
        AssertSz(FALSE, "Invalid flags in HrRegAddStringToSz");
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Open the key, creating if necessary
    //
    hr = HrRegCreateKeyEx(
            hkeyRoot,                           // Base hive
            pszKeySubPath,                      // Our reg path
            0,                                  // dwOptions
            KEY_QUERY_VALUE | KEY_SET_VALUE,    // samDesired
            NULL,                               // lpSecurityAttributes
            &hkeyOpen,                          // Our return hkey.
            NULL);
    if (FAILED(hr))
    {
        goto Exit;
    }

    // Retrieve the existing REG_SZ
    //
    hr = HrRegQueryValueWithAlloc(
            hkeyOpen,
            pszValueName,
            &dwRegType,
            (LPBYTE *) &pszOrderOld,
            NULL);
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND))
        {
            // This is OK. It just means that the value is missing. We
            // can handle this.
            hr = S_OK;
        }
        else
        {
            goto Exit;
        }
    }
    else
    {
        // If we did retrieve a value, then check to make sure that we're
        // dealing with a MULTI_SZ
        //
        if (dwRegType != REG_SZ)
        {
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATATYPE);
            goto Exit;
        }
    }

    hr = HrAddStringToDelimitedSz(pszAddString, pszOrderOld, chDelimiter,
            dwFlags, dwStringIndex, &pszOrderNew);

    if (S_OK == hr)
    {

        // Save our string back into the registry
        //
        hr = HrRegSetSz(hkeyOpen, pszValueName, pszOrderNew);
        if (FAILED(hr))
        {
            goto Exit;
        }
    }

Exit:
    // Close the key, if open
    //
    RegSafeCloseKey (hkeyOpen);

    // Clean up the registry buffers
    //
    MemFree (pszOrderOld);
    MemFree (pszOrderNew);

    TraceError ("HrRegAddStringToSz", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegRemoveStringFromSz
//
//  Purpose:    Removes a string from a REG_SZ registry value
//
//  Arguments:
//      pszRemoveString [in]    The string to be removed from the multi-sz
//      hkeyRoot        [in]    An open registry key, or one of the
//                              predefined hkey values (HKEY_LOCAL_MACHINE,
//                              for instance)
//      pszKeySubPath   [in]    Name of the subkey to open.
//      pszValueName    [in]    Name of the registry value that we're going to
//                              modify.
//      chDelimiter     [in]    The character to be used to delimit the
//                              values. Most multi-valued REG_SZ strings are
//                              delimited with either ',' or ' '.
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_REMOVE_SINGLE
//                                  Don't remove more than one value, if
//                                  multiple are present.
//                              STRING_FLAG_REMOVE_ALL
//                                  If multiple matching values are present,
//                                  remove them all.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
//
//  Note:
//      Might want to allow for the removal of leading/trailing spaces
//
HRESULT
HrRegRemoveStringFromSz (
    IN PCWSTR pszRemoveString,
    IN HKEY hkeyRoot,
    IN PCWSTR pszKeySubPath,
    IN PCWSTR pszValueName,
    IN WCHAR chDelimiter,
    IN DWORD dwFlags )
{
    HRESULT     hr              = S_OK;
    DWORD       dwRegType       = 0;        // Should be REG_MULTI_SZ
    HKEY        hkeyOpen        = NULL;     // Open key to open
    PWSTR       pszOrderOld     = NULL;     // Return buffer for order reg value
    PWSTR       pszOrderNew     = NULL;     // Build buffer for order swap
    DWORD       dwDataSize      = 0;

    // Check for all of the required args
    //
    if (!pszRemoveString || !hkeyRoot || !pszValueName)
    {
        Assert(pszRemoveString);
        Assert(hkeyRoot);
        Assert(pszValueName);

        hr = E_INVALIDARG;
        goto Exit;
    }

    // Check to make sure that no "remove" flags are being used, and that
    // mutually exclusive flags aren't being used together
    //
    if ((dwFlags & STRING_FLAG_ENSURE_AT_FRONT)    ||
        (dwFlags & STRING_FLAG_ENSURE_AT_END)      ||
        ((dwFlags & STRING_FLAG_REMOVE_SINGLE)     &&
         (dwFlags & STRING_FLAG_REMOVE_ALL)))
    {
        AssertSz(FALSE, "Invalid flags in HrRegAddStringToSz");
        hr = E_INVALIDARG;
        goto Exit;
    }

    // Open the key, creating if necessary
    //
    hr = HrRegOpenKeyEx (
            hkeyRoot,                           // Base hive
            pszKeySubPath,                      // Our reg path
            KEY_QUERY_VALUE | KEY_SET_VALUE,    // samDesired
            &hkeyOpen);                         // Our return hkey
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            hr = S_OK;
        }
        goto Exit;
    }

    // Retrieve the existing REG_SZ
    //
    hr = HrRegQueryValueWithAlloc (
            hkeyOpen,
            pszValueName,
            &dwRegType,
            (LPBYTE *) &pszOrderOld,
            &dwDataSize);
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            // This is OK. It just means that the value is missing. We
            // can handle this.
            hr = S_OK;
        }
        goto Exit;
    }
    else
    {
        // If we did retrieve a value, then check to make sure that we're
        // dealing with a REG_SZ
        //
        if (dwRegType != REG_SZ)
        {
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATATYPE);
            goto Exit;
        }

        if (dwDataSize == 0)
        {
            // This is OK, but we're going to assert here anyway, because this is not
            // a case that I know about
            //
            AssertSz(dwDataSize > 0, "How did we retrieve something from the "
                    "registry with 0 size?");

            hr = S_OK;
            goto Exit;
        }
    }

    hr = HrRemoveStringFromDelimitedSz (pszRemoveString, pszOrderOld,
            chDelimiter, dwFlags, &pszOrderNew);

    if (S_OK == hr)
    {
        // Save our string back into the registry
        //
        hr = HrRegSetSz (hkeyOpen, pszValueName, pszOrderNew);
    }

Exit:
    // Close the key, if open
    //
    RegSafeCloseKey (hkeyOpen);

    // Clean up the registry buffers
    //
    MemFree (pszOrderOld);
    MemFree (pszOrderNew);

    TraceError("HrRegRemoveStringFromSz", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrRegRemoveStringFromMultiSz
//
//  Purpose:    Removes the specified string from a multi-sz, if it is present.
//
//  Arguments:
//      pszRemoveString [in]
//      hkeyRoot        [in]
//      pszKeySubPath   [in]
//      pszValueName    [in]
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_REMOVE_SINGLE
//                                  Don't remove more than one value, if
//                                  multiple are present.
//                              [default] STRING_FLAG_REMOVE_ALL
//                                  If multiple matching values are present,
//                                  remove them all.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     ScottBri 11-Apr-1997
//
//  Notes:
//
HRESULT
HrRegRemoveStringFromMultiSz (
    IN PCWSTR  pszRemoveString,
    IN HKEY    hkeyRoot,
    IN PCWSTR  pszKeySubPath,
    IN PCWSTR  pszValueName,
    IN DWORD   dwFlags)
{
    DWORD   dwDataSize;
    DWORD   dwRegType;
    HKEY    hkey = NULL;
    HKEY    hkeyUse = hkeyRoot;
    HRESULT hr;
    PWSTR   psz = NULL;

    // Valid the input parameters
    if ((NULL == pszRemoveString) || (NULL == pszValueName) ||
        (NULL == hkeyRoot))
    {
        Assert(NULL != pszRemoveString);
        Assert(NULL != pszValueName);
        Assert(NULL != hkeyRoot);
        return E_INVALIDARG;
    }

    if ((STRING_FLAG_REMOVE_SINGLE & dwFlags) &&
        (STRING_FLAG_REMOVE_ALL & dwFlags))
    {
        AssertSz(FALSE, "Can't specify both 'remove all' and 'remove single'");
        return E_INVALIDARG;
    }

    if (NULL != pszKeySubPath)
    {
        hr = HrRegOpenKeyEx (hkeyRoot, pszKeySubPath, KEY_READ_WRITE, &hkey);
        if (S_OK != hr)
        {
            return hr;
        }

        hkeyUse = hkey;
    }

    // Retrieve the existing REG_SZ
    //
    hr = HrRegQueryValueWithAlloc (hkeyUse, pszValueName, &dwRegType,
                                    (LPBYTE *)&psz, &dwDataSize);
    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hr)
        {
            // This is OK. It just means that the value is missing. We
            // can handle this.
            hr = S_OK;
        }

        goto Done;
    }
    else
    {
        // If we did retrieve a value, then check to make sure that we're
        // dealing with a MULTI_SZ
        //
        if (dwRegType != REG_MULTI_SZ)
        {
            hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATATYPE);
            goto Done;
        }
    }

    // Search for and extract the specified string if present
    Assert(psz);
    BOOL fRemoved;
    RemoveSzFromMultiSz (pszRemoveString, psz, dwFlags, &fRemoved);

    // Rewrite the registry value if it was changed
    if (fRemoved)
    {
        dwDataSize = CbOfMultiSzAndTermSafe (psz);
        hr = HrRegSetValueEx (hkeyUse, pszValueName, REG_MULTI_SZ,
                               (const LPBYTE)psz, dwDataSize);
    }

Done:
    RegSafeCloseKey (hkey);
    MemFree (psz);

    TraceError ("HrRegRemoveStringFromMultiSz", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegCopyHive
//
//  Purpose:    Copies the contents of one hive to another.  It does this
//              by using RegSaveKey and RegRestoreKey to a temporary file.
//
//  Arguments:
//      hkeySrc [in] The source key to copy from.
//      hkeyDst [in] The destination key to copy to.
//
//  Returns:    S_OK or an error
//
//  Author:     shaunco   12 Jan 1998
//
//  Notes:
//
HRESULT
HrRegCopyHive (
    IN HKEY    hkeySrc,
    IN HKEY    hkeyDst)
{
    HRESULT hr;

    // Enable the needed privileges.
    //
    if ((S_OK == (hr = HrEnablePrivilege(SE_BACKUP_NAME))) &&
        (S_OK == (hr = HrEnablePrivilege(SE_RESTORE_NAME))))
    {
        // Create a temporary file name to save the source hive to.
        //
        static const WCHAR c_szPrefix [] = L"~ch";
        WCHAR szTempPath [MAX_PATH];
        WCHAR szTempFile [MAX_PATH];

        // If GetTempPath fails, we'd like to know about it (via the trace)
        // but it's not fatal as we'll just use the current directory
        // as the path.
        //
        if (!GetTempPath (celems(szTempPath), szTempPath))
        {
            TraceError ("HrRegCopyHive: GetTempPath failed (benign)",
                HrFromLastWin32Error ());

            *szTempFile = 0;
        }

        // Create the temporary filename and delete it because RegSaveKey
        // won't write to an existing file.
        //
        if (GetTempFileName (szTempPath, c_szPrefix, 0, szTempFile))
        {
            DeleteFile (szTempFile);

            // Save the source key to the temp file.
            //
            hr = HrRegSaveKey (hkeySrc, szTempFile, NULL);
            if (S_OK == hr)
            {
                // Restore the temp file to the destination key.
                //
                hr = HrRegRestoreKey (hkeyDst, szTempFile, NULL);
            }

            // We're done with the temp file so we delete it.  We shoudln't
            // have any error doing this, but it will be nice to see it
            // should it occur.
            //
            if (!DeleteFile (szTempFile))
            {
                TraceError ("HrRegCopyHive: DeleteFile failed on the "
                    "temporary file (benign)",
                    HrFromLastWin32Error ());
            }
        }
        else
        {
            hr = HrFromLastWin32Error ();
        }
    }

    TraceError ("HrRegCopyHive", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegCreateKeyEx
//
//  Purpose:    Creates a registry key by calling RegCreateKeyEx.
//
//  Arguments:
//      hkey                 [in]
//      pszSubkey            [in]
//      dwOptions            [in]   See the Win32 documentation for the
//      samDesired           [in]   RegCreateKeyEx function.
//      lpSecurityAttributes [in]
//      phkResult            [out]
//      pdwDisposition       [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:
//
HRESULT
HrRegCreateKeyEx (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD pdwDisposition)
{
    Assert (hkey);
    Assert (pszSubkey);
    Assert (phkResult);

    LONG lr = RegCreateKeyExW (hkey, pszSubkey, 0, NULL, dwOptions, samDesired,
            lpSecurityAttributes, phkResult, pdwDisposition);

    HRESULT hr = HRESULT_FROM_WIN32 (lr);
    if (FAILED(hr))
    {
        *phkResult = NULL;
    }

    TraceError("HrRegCreateKeyEx", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegDeleteKey
//
//  Purpose:    Delete the specified registry key.
//
//  Arguments:
//      hkey     [in]   See the Win32 documentation for the RegDeleteKey.
//      pszSubkey [in]   function.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   1 Apr 1997
//
//  Notes:
//
HRESULT
HrRegDeleteKey (
    IN HKEY hkey,
    IN PCWSTR pszSubkey)
{
    Assert (hkey);
    Assert (pszSubkey);

    LONG lr = RegDeleteKeyW (hkey, pszSubkey);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    // Did we open the key with incorrect access?
    Assert(E_ACCESSDENIED != hr);

    TraceHr (ttidError, FAL, hr, ERROR_FILE_NOT_FOUND == lr,
        "HrRegDeleteKey");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegDeleteKeyTree
//
//  Purpose:    Deletes an entire registry hive.
//
//  Arguments:
//      hkeyParent  [in]   Handle to open key where the desired key resides.
//      pszRemoveKey [in]   Name of key to delete.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      ckotze Changed to use KEY_READ_WRITE_DELETE as opposed to 
//              KEY_ALL_ACCESS, which is far too much access for what is
//              required.
//
HRESULT
HrRegDeleteKeyTree (
    IN HKEY hkeyParent,
    IN PCWSTR pszRemoveKey)
{
    Assert (hkeyParent);
    Assert (pszRemoveKey);

    // Open the key we want to remove
    HKEY hkeyRemove;
    HRESULT hr = HrRegOpenKeyEx(hkeyParent, pszRemoveKey, KEY_READ_WRITE_DELETE,
            &hkeyRemove);

    // Did we open the key with incorrect access?
    Assert(E_ACCESSDENIED != hr);

    if (S_OK == hr)
    {
        WCHAR       szValueName [MAX_PATH];
        DWORD       cchBuffSize = MAX_PATH;
        FILETIME    ft;
        LONG        lr;

        // Enum the keys children, and remove those sub-trees
        while (ERROR_SUCCESS == (lr = RegEnumKeyExW (hkeyRemove,
                0,
                szValueName,
                &cchBuffSize,
                NULL,
                NULL,
                NULL,
                &ft)))
        {
            HrRegDeleteKeyTree (hkeyRemove, szValueName);
            cchBuffSize = MAX_PATH;
        }
        RegCloseKey (hkeyRemove);

        if ((ERROR_SUCCESS == lr) || (ERROR_NO_MORE_ITEMS == lr))
        {
            lr = RegDeleteKeyW (hkeyParent, pszRemoveKey);
        }

        hr = HRESULT_FROM_WIN32 (lr);
    }

    TraceHr (ttidError, FAL, hr,
            HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr,
            "HrRegDeleteKeyTree");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegDeleteValue
//
//  Purpose:    Deletes the given registry value.
//
//  Arguments:
//      hkey        [in]    See the Win32 documentation for the RegDeleteValue
//      pszValueName [in]    function.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:
//
HRESULT
HrRegDeleteValue (
    IN HKEY hkey,
    IN PCWSTR pszValueName)
{
    Assert (hkey);
    Assert (pszValueName);

    LONG lr = RegDeleteValueW (hkey, pszValueName);
    HRESULT hr = HRESULT_FROM_WIN32(lr);

    TraceErrorOptional("HrRegDeleteValue", hr, (ERROR_FILE_NOT_FOUND == lr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegEnumKey
//
//  Purpose:    Enumerates subkeys of the specified open registry key.
//
//  Arguments:
//      hkey             [in]
//      dwIndex          [in]   See the Win32 documentation for the
//      pszSubkeyName    [out]  RegEnumKeyEx function.
//      pcchSubkeyName   [inout]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   30 Mar 1997
//
//  Notes:
//
HRESULT
HrRegEnumKey (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PWSTR  pszSubkeyName,
    IN DWORD cchSubkeyName)
{
    Assert (hkey);
    Assert (pszSubkeyName);
    Assert (cchSubkeyName);

    LONG lr = RegEnumKeyW (hkey, dwIndex, pszSubkeyName, cchSubkeyName);

    HRESULT hr = HRESULT_FROM_WIN32(lr);

    TraceHr (ttidError, FAL, hr, ERROR_NO_MORE_ITEMS == lr,
            "HrRegEnumKey");
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrRegEnumKeyEx
//
//  Purpose:    Enumerates subkeys of the specified open registry key.
//
//  Arguments:
//      hkey             [in]
//      dwIndex          [in]   See the Win32 documentation for the
//      pszSubkeyName    [out]  RegEnumKeyEx function.
//      pcchSubkeyName   [inout]
//      pszClass         [out]
//      pcchClass        [inout]
//      pftLastWriteTime [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   30 Mar 1997
//
//  Notes:
//
HRESULT
HrRegEnumKeyEx (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PWSTR  pszSubkeyName,
    IN OUT LPDWORD pcchSubkeyName,
    OUT PWSTR  pszClass,
    IN OUT LPDWORD pcchClass,
    OUT FILETIME* pftLastWriteTime)
{
    Assert (hkey);
    Assert (pszSubkeyName);
    Assert (pcchSubkeyName);
    Assert (pftLastWriteTime);

    LONG lr = RegEnumKeyExW (hkey, dwIndex, pszSubkeyName, pcchSubkeyName,
                            NULL, pszClass, pcchClass, pftLastWriteTime);
    HRESULT hr = HRESULT_FROM_WIN32(lr);

    TraceHr (ttidError, FAL, hr, ERROR_NO_MORE_ITEMS == lr,
            "HrRegEnumKeyEx");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegEnumValue
//
//  Purpose:    Enumerates the values for the specified open registry key.
//
//  Arguments:
//      hkey          [in]
//      dwIndex       [in]      See the Win32 documentation for the
//      pszValueName  [out]     RegEnumValue function.
//      pcbValueName  [inout]
//      pdwType       [out]
//      pbData        [out]
//      pcbData       [inout]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   30 Mar 1997
//
//  Notes:
//
HRESULT
HrRegEnumValue (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PWSTR  pszValueName,
    IN OUT LPDWORD pcbValueName,
    OUT LPDWORD pdwType,
    OUT LPBYTE  pbData,
    IN OUT LPDWORD pcbData)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (pcbValueName);
    Assert (FImplies(pbData, pcbData));

    LONG lr = RegEnumValueW (hkey, dwIndex, pszValueName, pcbValueName,
                            NULL, pdwType, pbData, pcbData);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    TraceErrorOptional("HrRegEnumValue", hr, (ERROR_NO_MORE_ITEMS == lr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegOpenKeyEx
//
//  Purpose:    Opens a registry key by calling RegOpenKeyEx.
//
//  Arguments:
//      hkey       [in]
//      pszSubkey  [in]     See the Win32 documentation for the
//      samDesired [in]     RegOpenKeyEx function.
//      phkResult  [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:
//
HRESULT
HrRegOpenKeyEx (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    IN REGSAM samDesired,
    OUT PHKEY phkResult)
{
    Assert (hkey);
    Assert (pszSubkey);
    Assert (phkResult);

    LONG lr = RegOpenKeyExW (hkey, pszSubkey, 0, samDesired, phkResult);
    HRESULT hr = HRESULT_FROM_WIN32(lr);
    if (FAILED(hr))
    {
        *phkResult = NULL;
        TraceTag(ttidDefault, "Error Opening Key:%s hr: 0x%x", pszSubkey, hr);
    }

    TraceErrorOptional("HrRegOpenKeyEx",  hr, (ERROR_FILE_NOT_FOUND == lr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegOpenKeyBestAccess
//
//  Purpose:    Opens a registry key by calling RegOpenKeyEx with the highest
//              access possible.
//
//  Arguments:
//      hkey       [in]
//      pszSubkey  [in]     See the Win32 documentation for the
//      phkResult  [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     scottbri    31-Oct-1997
//
//  Notes:
//
HRESULT
HrRegOpenKeyBestAccess (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    OUT PHKEY phkResult)
{
    Assert (hkey);
    Assert (pszSubkey);
    Assert (phkResult);

    TraceTag(ttidDefault, "Why do you call this function?  Either you can write or you can't.");

    LONG lr = RegOpenKeyExW (hkey, pszSubkey, 0, KEY_ALL_ACCESS, phkResult);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);
    if (E_ACCESSDENIED == hr)
    {
        lr = RegOpenKeyExW (hkey, pszSubkey, 0, KEY_READ_WRITE_DELETE, phkResult);
        hr = HRESULT_FROM_WIN32 (lr);

        if (E_ACCESSDENIED == hr)
        {
            lr = RegOpenKeyExW (hkey, pszSubkey, 0, KEY_READ_WRITE, phkResult);
            hr = HRESULT_FROM_WIN32 (lr);
            if (E_ACCESSDENIED == hr)
            {
                lr = RegOpenKeyExW (hkey, pszSubkey, 0, KEY_READ, phkResult);
                hr = HRESULT_FROM_WIN32 (lr);
                if (E_ACCESSDENIED == hr)
                {
                    lr = RegOpenKeyExW (hkey, pszSubkey, 0, STANDARD_RIGHTS_READ | KEY_QUERY_VALUE, phkResult);
                    hr = HRESULT_FROM_WIN32 (lr);
                }
            }
        }
    }

    if (FAILED(hr))
    {
        *phkResult = NULL;
    }

    TraceErrorOptional("HrRegOpenKeyEx",  hr, (ERROR_FILE_NOT_FOUND == lr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegDuplicateKeyEx
//
//  Purpose:    Duplicates a registry key by calling RegOpenKeyEx.
//
//  Arguments:
//      hkey       [in]
//      samDesired [in]     RegOpenKeyEx function.
//      phkResult  [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     mikemi   09 Apr 1997
//
//  Notes:
//
HRESULT
HrRegDuplicateKeyEx (
    IN HKEY hkey,
    IN REGSAM samDesired,
    OUT PHKEY phkResult)

{
    Assert (hkey);
    Assert (phkResult);

    LONG lr = RegOpenKeyExW (hkey, NULL, 0, samDesired, phkResult);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);
    if (FAILED(hr))
    {
        *phkResult = NULL;
    }

    TraceError("HrRegDuplicateKeyEx", hr);
    return hr;
}

HRESULT
HrRegSetBool (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN BOOL fValue)
{
    DWORD dwValue = !!fValue;
    return HrRegSetValueEx (hkey, pszValueName,
                REG_DWORD,
                (LPBYTE)&dwValue, sizeof(DWORD));
}

HRESULT
HrRegSetDword (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN DWORD dwValue)
{
    return HrRegSetValueEx (hkey, pszValueName,
                REG_DWORD,
                (LPBYTE)&dwValue, sizeof(DWORD));
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetGuidAsSz
//
//  Purpose:    Converts a given guid to a string and sets the given registry
//              value.
//
//  Arguments:
//      hkey         [in]
//      pszValueName [in]
//      guid         [in]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     BillBe   21 Feb 1999
//
//  Notes:
//
HRESULT
HrRegSetGuidAsSz (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN const GUID& guid)
{
    HRESULT hr;
    INT cch;
    WCHAR szGuid[c_cchGuidWithTerm];

    Assert (hkey);
    Assert (pszValueName && *pszValueName);

    cch = StringFromGUID2 (guid, szGuid, c_cchGuidWithTerm);
    Assert (c_cchGuidWithTerm == cch);

    hr = HrRegSetSz (hkey, pszValueName, szGuid);

    TraceHr (ttidError, FAL, hr, FALSE, "HrRegSetGuidAsSz");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetValueEx
//
//  Purpose:    Sets the data for the given registry value by calling the
//              RegSetValueEx function.
//
//  Arguments:
//      hkey         [in]
//      pszValueName [in]
//      dwType       [in]    See the Win32 documentation for the RegSetValueEx
//      pbData       [in]    function.
//      cbData       [in]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:
//
HRESULT
HrRegSetValueEx (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN DWORD dwType,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    Assert (hkey);
    Assert (FImplies (cbData > 0, pbData));

    LONG lr = RegSetValueExW(hkey, pszValueName, 0, dwType, pbData, cbData);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    // Did we open the key with incorrect access?
    Assert(E_ACCESSDENIED != hr);

    TraceError("HrRegSetValue", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   RegSafeCloseKey
//
//  Purpose:    Closes the given registry key if it is non-NULL.
//
//  Arguments:
//      hkey [in]   Key to be closed. Can be NULL.
//
//  Returns:    Nothing.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      If hkey is NULL this function does nothing.
//
VOID
RegSafeCloseKey (
    IN HKEY hkey)
{
    if (hkey)
    {
        RegCloseKey(hkey);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegRestoreKey
//
//  Purpose:    Wrapper for RegRestoreKey
//
//  Arguments:
//      hkey        [in]    Parent key to restore into
//      pszFileName [in]    Name of file containing registry info
//      dwFlags     [in]    Flags for restore
//
//  Returns:    Win32 HRESULT if failure, otherwise S_OK
//
//  Author:     danielwe   8 Aug 1997
//
//  Notes:      See docs for RegRestoreKey for more info
//
HRESULT
HrRegRestoreKey (
    IN HKEY hkey,
    IN PCWSTR pszFileName,
    IN DWORD dwFlags)
{
    HRESULT     hr = S_OK;
    LONG        lres;

    Assert(hkey);
    Assert(pszFileName);

    lres = RegRestoreKeyW(hkey, pszFileName, dwFlags);
    hr = HRESULT_FROM_WIN32(lres);

    // Did we open the key with incorrect access?
    Assert(E_ACCESSDENIED != hr);

    TraceError("HrRegRestoreKey", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSaveKey
//
//  Purpose:    Wrapper for RegSaveKey
//
//  Arguments:
//      hkey        [in]     Parent key to restore into
//      pszFileName [in]     Name of file containing registry info
//      psa         [in]     Security attributes for the file
//
//  Returns:    Win32 HRESULT if failure, otherwise S_OK
//
//  Author:     BillBe   2 Jan 1998
//
//  Notes:      See docs for RegSaveKey for more info
//
HRESULT
HrRegSaveKey (
    IN HKEY hkey,
    IN PCWSTR pszFileName,
    IN LPSECURITY_ATTRIBUTES psa)
{
    HRESULT     hr;
    LONG        lres;

    Assert(hkey);
    Assert(pszFileName);

    lres = RegSaveKeyW (hkey, pszFileName, psa);
    hr = HRESULT_FROM_WIN32(lres);

    // Did we open the key with incorrect access?
    Assert(E_ACCESSDENIED != hr);

    TraceError("HrRegSaveKey", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegGetKeySecurity
//
//  Purpose:    Retrieves the Security of a Key using RegGetKeySecurity
//
//  Arguments:
//      hkey       [in]
//      pszSubkey  [in]     See the Win32 documentation for the
//      samDesired [in]     RegOpenKeyEx function.
//      phkResult  [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     ckotze   06 July 2000
//
//  Notes:
//
HRESULT
HrRegGetKeySecurity(
    HKEY                    hKey,
    SECURITY_INFORMATION    SecurityInformation,
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    LPDWORD                 lpcbSecurityDescriptor)
{
    Assert (hKey);
    Assert (SecurityInformation);
    Assert (pSecurityDescriptor);

    LONG lr = RegGetKeySecurity(hKey, SecurityInformation, pSecurityDescriptor, lpcbSecurityDescriptor);
    HRESULT hr = HRESULT_FROM_WIN32(lr);

    // Did we open the key with incorrect access?
    Assert(E_ACCESSDENIED != hr);

    if (FAILED(hr))
    {
        pSecurityDescriptor = NULL;
    }

    TraceErrorOptional("HrRegGetKeySecurity", hr, (lr != ERROR_INSUFFICIENT_BUFFER));

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegOpenKeyEx
//
//  Purpose:    Opens a registry key by calling RegOpenKeyEx.
//
//  Arguments:
//      hkey       [in]
//      pszSubkey  [in]     See the Win32 documentation for the
//      samDesired [in]     RegOpenKeyEx function.
//      phkResult  [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:
//
HRESULT HrRegSetKeySecurity (
    HKEY                    hKey,
    SECURITY_INFORMATION    SecurityInformation,
    PSECURITY_DESCRIPTOR    pSecurityDescriptor)
{
    Assert (hKey);
    Assert (SecurityInformation);
    Assert (pSecurityDescriptor);

    LONG lr = RegSetKeySecurity(hKey, SecurityInformation, pSecurityDescriptor);
    HRESULT hr = HRESULT_FROM_WIN32(lr);

     // Did we open the key with incorrect access?
    Assert(E_ACCESSDENIED != hr);

    TraceError("HrRegSetKeySecurity", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     HrRegOpenAdapterKey
//
//  Purpose:    This creates or opens the Adapters subkey to a component
//
//  Arguments:
//      pszComponentName [in]   The name of the component being
//      fCreate [in]            TRUE if the directory is to be created
//      phkey [out]             The handle to the Adapters subkey
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     CWill       06/11/97
//
//  Notes:      The handle has to be release by the calling app on SUCCESS
//
HRESULT
HrRegOpenAdapterKey (
    IN PCWSTR pszComponentName,
    IN BOOL fCreate,
    OUT HKEY* phkey)
{
    HRESULT     hr              = S_OK;
    DWORD       dwDisposition   = 0x0;
    tstring     strKey;

    // Build the registry path
    strKey = c_szRegKeyServices;

    strKey.append(c_szBackslash);
    strKey.append(pszComponentName);

    strKey.append(c_szBackslash);
    strKey.append(c_szParameters);

    strKey.append(c_szBackslash);
    strKey.append(c_szAdapters);

    // Create the key if we are asked
    if (fCreate)
    {
        hr = HrRegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                strKey.c_str(),
                REG_OPTION_NON_VOLATILE,
                KEY_READ_WRITE_DELETE,
                NULL,
                phkey,
                &dwDisposition);
    }
    else
    {
        hr = HrRegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                strKey.c_str(),
                KEY_READ,
                phkey);
    }

    TraceError("HrRegOpenAdapterKey", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryColString
//
//  Purpose:    Allocates strings and appends to collects as read from the registry.
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to get.
//      pcolstr      [out]   The returned collection of tstrings*. empty collection otherwise.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     mikemi   30 Apr 1997
//
//  Notes:      If the function succeeds, you must call DeleteColString on the
//              return parameter.
//              This will empty and delete the collection passed in
//
//---------------------------------------------------------------------------
template<class T>
HRESULT
HrRegQueryColString (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    OUT T* pcolstr )
{
    WCHAR* pmsz;
    HRESULT hr;

    DeleteColString (pcolstr);
    hr = HrRegQueryMultiSzWithAlloc (hkey, pszValueName, &pmsz);

    if (S_OK == hr)
    {
        MultiSzToColString (pmsz, pcolstr);
        MemFree (pmsz);
    }

    TraceHr (ttidError, FAL, hr,
            HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr, "HrRegQueryColString");
    return hr;
}

typedef list<tstring*>  list_of_tstring_ptr;
template HRESULT HrRegQueryColString <list_of_tstring_ptr>   ( HKEY a, PCWSTR b, list_of_tstring_ptr* c );
typedef vector<tstring*>  vector_of_tstring_ptr;
template HRESULT HrRegQueryColString <vector_of_tstring_ptr> ( HKEY a, PCWSTR b, vector_of_tstring_ptr* c );

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetColString
//
//  Purpose:    Sets a multi-sz in the registry using the collection of strings
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to set.
//      colstr       [in]    The collection of tstrings to set.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     mikemi   30 Apr 1997
//
//  Notes:
//
//---------------------------------------------------------------------------
template<class T>
HRESULT
HrRegSetColString (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN const T& colstr)
{
    WCHAR* pmsz;
    HRESULT hr;

    ColStringToMultiSz (colstr, &pmsz);
    hr = HrRegSetMultiSz (hkey, pszValueName, (pmsz ? pmsz : c_szEmpty));
    MemFree (pmsz);

    TraceError ("HrRegSetColString", hr);
    return hr;
}

template HRESULT HrRegSetColString <list_of_tstring_ptr>   ( HKEY a, PCWSTR b, const list_of_tstring_ptr& c );
template HRESULT HrRegSetColString <vector_of_tstring_ptr> ( HKEY a, PCWSTR b, const vector_of_tstring_ptr& c );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncregq.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R E G Q . C P P
//
//  Contents:   HrRegQuery functions.
//
//  Notes:
//
//  Author:     shaunco   5 Jun 1998
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncreg.h"

//+---------------------------------------------------------------------------
//
//  Function:   ExpandEnvironmentStringsIntoTstring
//
//  Purpose:    Call ExpandEnvironmentStrings and provide a buffer that
//              is a tstring.
//
//  Arguments:
//      pszSrc  [in]  The string to expand.  Can be empty, but not NULL.
//      pstrDst [out] The expanded version.
//
//  Returns:    nothing
//
//  Author:     shaunco   6 Jun 1998
//
//  Notes:
//
VOID
ExpandEnvironmentStringsIntoTstring (
    PCWSTR      pszSrc,
    tstring*    pstrDst)
{
    // Initialize the output parameter.
    //
    pstrDst->erase();

    DWORD cch = lstrlenW (pszSrc);
    if (cch)
    {
        // Start with 64 more characters than are in pszSrc.
        //
        cch += 64;

        // assign will reserve cch characters and set them all to 0.
        // checking capacity afterwards ensures the allocation made
        // internally didn't fail.
        //
        pstrDst->assign (cch, 0);
        if (cch <= pstrDst->capacity ())
        {
            DWORD cchIncludingNull;

            cchIncludingNull = ExpandEnvironmentStringsW (
                                    pszSrc,
                                    (PWSTR)pstrDst->data (),
                                    cch + 1);

            Assert (cchIncludingNull);
            cch = cchIncludingNull - 1;

            // If we didn't have enough room, reserve the required amount.
            //
            if (cch > pstrDst->capacity ())
            {
                pstrDst->assign (cch, 0);
                if (cch <= pstrDst->capacity ())
                {
                    ExpandEnvironmentStringsW (
                            pszSrc,
                            (PWSTR)pstrDst->data (),
                            cch + 1);
                }
            }

            // Make sure the string's inards are correct.
            //
            pstrDst->resize (cch);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryTypeWithAlloc
//
//  Purpose:    Retrieves a type'd value from the registry and returns a
//              pre-allocated buffer with the data and optionally the size of
//              the returned buffer.
//
//  Arguments:
//      hkey         [in]    Handle of parent key
//      pszValueName [in]    Name of value to query
//      ppbValue     [out]   Buffer with binary data
//      pcbValue     [out]   Size of buffer in bytes. If NULL, size is not
//                           returned.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   16 Apr 1997
//
//  Notes:      Free the returned buffer with MemFree.
//
HRESULT
HrRegQueryTypeWithAlloc (
    HKEY    hkey,
    PCWSTR  pszValueName,
    DWORD   dwType,
    LPBYTE* ppbValue,
    DWORD*  pcbValue)
{
    HRESULT hr;
    DWORD   dwTypeRet;
    LPBYTE  pbData;
    DWORD   cbData;

    Assert(hkey);
    Assert(ppbValue);

    // Get the value.
    //
    hr = HrRegQueryValueWithAlloc(hkey, pszValueName, &dwTypeRet,
                                  &pbData, &cbData);

    // It's type should be REG_BINARY. (duh).
    //
    if ((S_OK == hr) && (dwTypeRet != dwType))
    {
        MemFree(pbData);
        pbData = NULL;

        TraceTag(ttidError, "Expected a type of REG_BINARY for %S.",
            pszValueName);
        hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATATYPE);
    }

    // Assign the output parameters.
    if (S_OK == hr)
    {
        *ppbValue = pbData;
        if (pcbValue)
        {
            *pcbValue = cbData;
        }
    }
    else
    {
        *ppbValue = NULL;
        if (pcbValue)
        {
            *pcbValue = 0;
        }
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr),
        "HrRegQueryTypeWithAlloc");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryDword
//
//  Purpose:    Gets a DWORD from the registry.  Checks that its type and
//              size are correct.  Easier to understand than HrRegQueryValueEx
//              with 5 parameters.  Type safe (no LPBYTE stuff).
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to get.
//      pdwValue     [out]   The returned DWORD value if successful.  Zero
//                           if not.
//
//  Returns:    S_OK or HRESULT_FROM_WIN32.
//
//  Author:     shaunco   27 Mar 1997
//
//  Side Effects:   On error, the output DWORD is set to zero to line-up
//                  with the rules of COM in this regard.
//
HRESULT
HrRegQueryDword (
    HKEY    hkey,
    PCWSTR  pszValueName,
    LPDWORD pdwValue)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (pdwValue);

    // Get the value.
    DWORD dwType;
    DWORD cbData = sizeof(DWORD);
    HRESULT hr = HrRegQueryValueEx (hkey, pszValueName, &dwType,
            (LPBYTE)pdwValue, &cbData);

    // It's type should be REG_DWORD. (duh).
    //
    if ((S_OK == hr) && (REG_DWORD != dwType))
    {
        TraceTag (ttidError, "Expected a type of REG_DWORD for %S.",
            pszValueName);
        hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATATYPE);
    }

    // It's size should be correct too.
    //
    AssertSz (FImplies(S_OK == hr, sizeof(DWORD) == cbData),
              "Expected sizeof(DWORD) bytes to be returned.");

    // Make sure we initialize the output value on error.
    // (We don't know for sure that RegQueryValueEx does this.)
    //
    if (S_OK != hr)
    {
        *pdwValue = 0;
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr),
        "HrRegQueryDword");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryExpandString
//
//  Purpose:    Query a REG_EXPAND_SZ value from the registry and
//              expand it using ExpandEnvironmentStrings.  Return the
//              result in a tstring.
//
//  Arguments:
//      hkey         [in]  The parent HKEY of szValueName
//      pszValueName [in]  The name of the value to query.
//      pstrValue    [out] The returned (expanded) value.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   6 Jun 1998
//
//  Notes:
//
HRESULT
HrRegQueryExpandString (
    HKEY        hkey,
    PCWSTR      pszValueName,
    tstring*    pstrValue)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (pstrValue);

    tstring strToExpand;
    HRESULT hr = HrRegQueryTypeString (hkey, pszValueName,
            REG_EXPAND_SZ, &strToExpand);

    if (S_OK == hr)
    {
        ExpandEnvironmentStringsIntoTstring (strToExpand.c_str(), pstrValue);
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ||
        (HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE) == hr),
        "HrRegQueryExpandString");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryInfoKey
//
//  Purpose:    Retrieves information about a registry key by calling
//              RegQueryInfoKey.
//
//  Arguments:
//      hkey                  [in]
//      pszClass              [out]
//      pcbClass              [inout]
//      pcSubKeys             [out]
//      pcbMaxSubKeyLen       [out]    See the Win32 documentation for the
//      pcbMaxClassLen        [out]    RegQueryInfoKey function.
//      pcValues              [out]
//      pcbMaxValueNameLen    [out]
//      pcbMaxValueLen        [out]
//      pcbSecurityDescriptor [out]
//      pftLastWriteTime      [out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     BillBe   28 Aug 1998
//
//  Notes:      Note that pcbClass is an *in/out* param. Set this to the size
//              of the buffer pointed to by pszClass *before* calling this
//              function!
//
HRESULT
HrRegQueryInfoKey (
    IN HKEY         hkey,
    OUT PWSTR       pszClass,
    IN OUT LPDWORD  pcbClass,
    OUT LPDWORD     pcSubKeys,
    OUT LPDWORD     pcbMaxSubKeyLen,
    OUT LPDWORD     pcbMaxClassLen,
    OUT LPDWORD     pcValues,
    OUT LPDWORD     pcbMaxValueNameLen,
    OUT LPDWORD     pcbMaxValueLen,
    OUT LPDWORD     pcbSecurityDescriptor,
    OUT PFILETIME   pftLastWriteTime)
{
    Assert(hkey);

    LONG lr = RegQueryInfoKeyW(hkey, pszClass, pcbClass, NULL,pcSubKeys,
            pcbMaxSubKeyLen, pcbMaxClassLen, pcValues, pcbMaxValueNameLen,
            pcbMaxValueLen, pcbSecurityDescriptor, pftLastWriteTime);

    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    TraceHr (ttidError, FAL, hr, FALSE, "HrRegQueryInfoKey");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryStringAsUlong
//
//  Purpose:    Reads a REG_SZ from the registry and converts it to a ulong
//              before returning
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to get.
//      nBase        [in]    The numeric base to convert to
//      pulValue     [out]   The returned converted string if successful.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     billbe   13 Jun 1997
//
//  Notes:
//
//
HRESULT
HrRegQueryStringAsUlong (
    IN HKEY     hkey,
    IN PCWSTR   pszValueName,
    IN int      nBase,
    OUT ULONG*  pulValue)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (nBase);
    Assert (pulValue);

    // Get the value.
    //
    tstring strValue;
    HRESULT hr = HrRegQueryString (hkey, pszValueName, &strValue);

    if (S_OK == hr)
    {
        // Convert and assign the output parameters.
        PWSTR pszStopString;
        *pulValue = wcstoul (strValue.c_str(), &pszStopString, nBase);
    }
    else
    {
        *pulValue = 0;
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr),
        "HrRegQueryStringAsUlong");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryTypeString
//
//  Purpose:    Query a REG_SZ or REG_EXPAND_SZ value and returns it
//              in a tstring.
//
//  Arguments:
//      hkey         [in]  The parent HKEY of szValueName
//      pszValueName [in]  The name of the value to query.
//      dwType       [in]  REG_SZ or REG_EXPAND_SZ
//      pstr         [out] The returned value.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   6 Jun 1998
//
//  Notes:      REG_EXPAND_SZ values ARE NOT expanded using
//              ExpandEnvironentStrings.  Use HrRegQueryExpandString instead.
//
HRESULT
HrRegQueryTypeString (
    IN HKEY       hkey,
    IN PCWSTR     pszValueName,
    IN DWORD      dwType,
    OUT tstring*  pstr)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (pstr);

    AssertSz ((REG_SZ == dwType) ||
              (REG_EXPAND_SZ == dwType), "Only REG_SZ or REG_EXPAND_SZ "
              "types accepted.");

    BOOL fErase = TRUE;

    // Get size of the data.
    //
    DWORD  dwTypeRet;
    DWORD  cbData = 0;
    HRESULT hr = HrRegQueryValueEx (hkey, pszValueName, &dwTypeRet,
            NULL, &cbData);

    // Make sure it has the correct type.
    //
    if ((S_OK == hr) && (dwTypeRet != dwType))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE);
    }

    if (S_OK == hr)
    {
        // Compute the number of characters in the data including the
        // NULL terminator.  After dividing the number of bytes by
        // the sizeof a WCHAR, add 1 if there is a remainder.  If we didn't,
        // and the number of bytes was not a multiple of the sizeof a WCHAR,
        // we'd come up short because integer division rounds down.
        // (The only time I can think of cbData would not be a multiple
        // of sizeof(WCHAR) is if the registry data were somehow corrupted.
        // It's not that I think corruption deserves a special case, but
        // we shouldn't AV in light of it.)
        //
        DWORD cchIncludingNull;

        cchIncludingNull  = cbData / sizeof(WCHAR);
        if (cbData % sizeof(WCHAR))
        {
            cchIncludingNull++;
        }

        // If we have more than just the terminator, allocate and
        // get the string.  Otherwise, we want it empty.
        //
        if (cchIncludingNull > 1)
        {
            // Reserve room for the correct number of characters.
            // cch is the count of characters without the terminator
            // since that is what tstring operates with.
            //
            DWORD cch = cchIncludingNull - 1;
            Assert (cch > 0);

            // assign will reserve cch characters and set them all to 0.
            // checking capacity afterwards ensures the allocation made
            // internally didn't fail.
            //
            pstr->assign (cch, 0);
            if (cch <= pstr->capacity ())
            {
                hr = HrRegQueryValueEx (hkey, pszValueName, &dwType,
                        (LPBYTE)pstr->data (), &cbData);

                if (S_OK == hr)
                {
                    // If everything went according to plan, the length
                    // of the string should now match what wcslen
                    // returns on the string itself.  The reason it will
                    // match is because we passed cch to assign.
                    //
                    Assert (pstr->length() == (size_t)wcslen (pstr->c_str()));
                    fErase = FALSE;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    // Empty the output string on failure or if we think it should be
    // empty.
    //
    if (FAILED(hr) || fErase)
    {
        pstr->erase();
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ||
        (HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE) == hr),
        "HrRegQueryTypeString");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryTypeSzBuffer
//
//  Purpose:    Gets a string from the registry using the given buffer. Checks
//              that its type is correct. Type safe (no LPBYTE stuff).
//
//  Arguments:
//      hkey         [in]        The registry key.
//      pszValueName [in]        The name of the value to get.
//      dwType       [in]        Desired type. (REG_SZ, REG_EXPAND_SZ, etc.)
//      szData       [out]       String buffer to hold the data.
//      pcbData      [in,out]    IN: Number of *bytes* in buffer pointed to by
//                              szData. OUT: Number of bytes actually copied
//                              into the buffer.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   3 Apr 1997
//
//  Notes:      If the function fails, the buffer passed in is guaranteed to
//              be an empty string.
//
HRESULT
HrRegQueryTypeSzBuffer (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN DWORD dwType,
    OUT PWSTR pszData,
    OUT DWORD* pcbData)
{
    Assert (hkey);
    Assert (pszValueName);
    Assert (pcbData);

    DWORD dwTypeRet;
    HRESULT hr = HrRegQueryValueEx (hkey, pszValueName, &dwTypeRet,
            (LPBYTE)pszData, pcbData);

    if ((S_OK == hr) && (dwTypeRet != dwType))
    {
        TraceTag (ttidError, "Expected a type of 0x%x for %S.",
            dwType, pszValueName);

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATATYPE);
    }

    if (FAILED(hr) && pszData)
    {
        // Make sure empty string is returned on failure.
        //
        *pszData = 0;
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr),
        "HrRegQueryTypeSzBuffer");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryValueEx
//
//  Purpose:    Retrieves the data from the given registry value by calling
//              RegQueryValueEx.
//
//  Arguments:
//      hkey         [in]
//      pszValueName [in]
//      pdwType      [out]   See the Win32 documentation for the
//      pbData       [out]   RegQueryValueEx function.
//      pcbData      [in,out]
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   25 Feb 1997
//
//  Notes:      Note that pcbData is an *in/out* param. Set this to the size
//              of the buffer pointed to by pbData *before* calling this
//              function!
//
HRESULT
HrRegQueryValueEx (
    IN HKEY       hkey,
    IN PCWSTR     pszValueName,
    OUT LPDWORD   pdwType,
    OUT LPBYTE    pbData,
    OUT LPDWORD   pcbData)
{
    Assert (hkey);

    AssertSz (FImplies(pbData && pcbData, pdwType),
              "pdwType not provided to HrRegQueryValueEx.  You should be "
              "retrieving the type as well so you can make sure it is "
              "correct.");

    LONG lr = RegQueryValueExW (hkey, pszValueName, NULL, pdwType,
                    pbData, pcbData);
    HRESULT hr = HRESULT_FROM_WIN32 (lr);

    TraceHr (ttidError, FAL, hr,
        (ERROR_MORE_DATA == lr) || (ERROR_FILE_NOT_FOUND == lr),
        "HrRegQueryValueEx (%S)", pszValueName);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegQueryValueWithAlloc
//
//  Purpose:    Retrieve a registry value in a buffer allocated by this
//              function. This goes through the mess of checking the value
//              size, allocating the buffer, and then calling back to get the
//              actual value. Returns the buffer to the user.
//
//  Arguments:
//      hkey         [in]        An open HKEY (the one that contains the value
//                              to be read)
//      pszValueName [in]        Name of the registry value
//      pdwType      [in/out]    The REG_ type that we plan to be reading
//      ppbBuffer    [out]       Pointer to an LPBYTE buffer that will contain
//                              the registry value
//      pdwSize      [out]       Pointer to a DWORD that will contain the size
//                              of the ppbBuffer.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
HRESULT
HrRegQueryValueWithAlloc (
    IN HKEY       hkey,
    IN PCWSTR     pszValueName,
    LPDWORD     pdwType,
    LPBYTE*     ppbBuffer,
    LPDWORD     pdwSize)
{
    HRESULT hr;
    BYTE abData [256];
    DWORD cbData;
    BOOL fReQuery = FALSE;

    Assert (hkey);
    Assert (pdwType);
    Assert (ppbBuffer);

    // Initialize the output parameters.
    //
    *ppbBuffer = NULL;
    if (pdwSize)
    {
        *pdwSize = 0;
    }

    // Get the size of the data, and if it will fit, the data too.
    //
    cbData = sizeof(abData);
    hr = HrRegQueryValueEx (
            hkey,
            pszValueName,
            pdwType,
            abData,
            &cbData);
    if (HRESULT_FROM_WIN32(ERROR_MORE_DATA) == hr)
    {
        // The data didn't fit, so we'll have to requery for it after
        // we allocate our buffer.
        //
        fReQuery = TRUE;
        hr = S_OK;
    }

    if (S_OK == hr)
    {
        // Allocate the buffer for the required size.
        //
        BYTE* pbBuffer = (BYTE*)MemAlloc (cbData);
        if (pbBuffer)
        {
            if (fReQuery)
            {
                hr = HrRegQueryValueEx (
                        hkey,
                        pszValueName,
                        pdwType,
                        pbBuffer,
                        &cbData);
            }
            else
            {
                CopyMemory (pbBuffer, abData, cbData);
            }

            if (S_OK == hr)
            {
                // Fill in the return values.
                //
                *ppbBuffer = pbBuffer;

                if (pdwSize)
                {
                    *pdwSize = cbData;
                }
            }
            else
            {
                MemFree (pbBuffer);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr),
        "HrRegQueryValueWithAlloc");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncreg2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R E G 2 . C P P
//
//  Contents:   Common routines for dealing with the registry.
//
//  Notes:
//
//  Author:     CWill   27 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncerror.h"
#include "ncipaddr.h"
#include "ncmem.h"
#include "ncreg.h"
#include "ncstring.h"
#include <regstr.h>

static const WCHAR  c_szSubkeyServices[] = REGSTR_PATH_SERVICES;

const struct REG_TYPE_MAP
{
    DWORD   dwPsuedoType;
    DWORD   dwType;
};

REG_TYPE_MAP    c_rgrtmTypes[] =
{
    {REG_BOOL,  REG_DWORD},
    {REG_IP,    REG_SZ},
};



DWORD DwRealTypeFromPsuedoType(const DWORD dwPsuedoType)
{
    for (UINT cLoop = 0; cLoop < celems(c_rgrtmTypes); cLoop++)
    {
        if (dwPsuedoType == c_rgrtmTypes[cLoop].dwPsuedoType)
        {
            return c_rgrtmTypes[cLoop].dwType;
        }
    }

    return dwPsuedoType;
}

struct SPECIAL_KEY_MAP
{
    HKEY        hkeyPseudo;
    HKEY        hkeyRoot;
    PCWSTR      pszSubKey;
};

static const SPECIAL_KEY_MAP c_rgskmSpec[] =
{
    HKLM_SVCS,      HKEY_LOCAL_MACHINE,     c_szSubkeyServices,
};



//+---------------------------------------------------------------------------
//
//  Member:     HkeyTrueParent
//
//  Purpose:    To get a real handle to a key from a pseudo handle
//
//  Arguments:
//      hkeyIn          The pseudo key name
//      samDesired      The access requested of the key
//      rghkeySpec      An array of the special keys.
//
//  Returns:    The handle to the opened key or NULL
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
HKEY HkeyTrueParent(const HKEY hkeyIn, const REGSAM samDesired,
        HKEY rghkeySpec[])
{
    HKEY    hkeyRet     = hkeyIn;

    for (UINT cKey = 0; cKey < celems(c_rgskmSpec); cKey++)
    {
        // Check arb->hkey for one of "our" well known keys.
        if (c_rgskmSpec[cKey].hkeyPseudo == hkeyIn)
        {
            if (!rghkeySpec[cKey])
            {
                // First time a special key was used.  We need to cache it.
#ifdef DBG
                HRESULT hr =
#endif // DBG
                HrRegOpenKeyEx(
                        c_rgskmSpec[cKey].hkeyRoot,
                        c_rgskmSpec[cKey].pszSubKey,
                        samDesired,
                        &rghkeySpec[cKey]);

                // If we fail to open the key, make sure the output
                // parameter was nulled.  This will allow us to proceed
                // without really handling the error as hkeyParent
                // will be set to null below and the following
                // HrRegOpenKey will fail.  We will then handle the failure
                // of that.
                AssertSz(FImplies(FAILED(hr), !rghkeySpec[cKey]), "Key not NULL");
            }

            hkeyRet = rghkeySpec[cKey];
            break;
        }
    }

    return hkeyRet;
}



VOID RegSafeCloseKeyArray(HKEY rghkey[], UINT cElems)
{
    for (UINT cKey = 0; cKey < cElems; cKey++)
    {
        RegSafeCloseKey(rghkey[cKey]);
    }

    return;
}



//+---------------------------------------------------------------------------
//
//  Member:     TranslateFromRegToData
//
//  Purpose:    Translates the data retrieved from the registry to a the user
//              data's storage format
//
//  Arguments:
//      dwType          The registry pseudo type that is being translated
//      pbData          Where the data gets stored
//      pbBuf           A buffer that stores the registry data
//
//  Returns:    Nothing.
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
VOID TranslateFromRegToData(DWORD dwType, BYTE* pbData, BYTE* pbBuf)
{
     // Take the data from the registry and happily convert it into
     // usable data
    switch (dwType)
    {

#ifdef DBG
    default:
    {
        AssertSz(FALSE, "Unknown registry type");
        break;
    }
#endif // DBG

    case REG_IP:
    {
        // Convert the stringized form of the ip address
        // into a DWORD.  (The actual 32-bit IP address.)
        DWORD dwIpAddr = IpPszToHostAddr((WCHAR*)pbBuf);
        *((DWORD*)pbData) = dwIpAddr;
        break;
    }

    case REG_BOOL:
    {
        // Form the boolean as 'TRUE' or 'FALSE' based on
        // whether the data is non-zero or zero respectively.
        DWORD   dwData = *((DWORD*)pbBuf);
        *((BOOL*)pbData) = (!!dwData);
        break;
    }

    case REG_DWORD:
    {
        // DWORDs are direct assignments
        *((DWORD*)pbData) = *((DWORD*)pbBuf);
        break;
    }

    case REG_SZ:
    {
        // Make a copy of the string
        *((PWSTR*) pbData) = SzDupSz((PWSTR)pbBuf);
        break;
    }
    }

    return;
}



inline VOID UseDefaultRegValue(DWORD dwType, BYTE* pbData, BYTE* pbDefault)
{
    AssertSz((pbData && pbDefault), "UseDefaultRegValue : Invalid params");
    AssertSz(pbDefault, "There is no default registry value");

    TranslateFromRegToData(dwType, pbData, pbDefault);

    return;
}



//+---------------------------------------------------------------------------
//
//  Member:     CbSizeOfDataToReg
//
//  Purpose:    To determine the size of buffer needed to store the data
//
//  Arguments:
//      dwType          The registry pseudo type that is being translated
//      pbData          The data that has to be translated
//
//  Returns:    The size of buffer need to store the data
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
DWORD CbSizeOfDataToReg(DWORD dwType, const BYTE* pbData)
{
    DWORD cbData = 0;

    switch (dwType)
    {
#ifdef DBG
    default:
    {
        AssertSz(FALSE, "Unknown registry type");
        break;
    }
#endif // DBG

    case REG_IP:
    {
        // Convert the 32-bit IP address to a stringized form.
        DWORD dwIpAddr = *((DWORD*)pbData);

        WCHAR pszIpAddr [32];
        IpHostAddrToPsz(dwIpAddr, pszIpAddr);

        cbData = CbOfSzAndTerm(pszIpAddr);
        break;
    }

    // Boolean values are stored as DWORDs
    case REG_BOOL:
    case REG_DWORD:
    {
        cbData = sizeof(DWORD);
        break;
    }

    case REG_SZ:
    case REG_EXPAND_SZ:
    {
        cbData = CbOfSzAndTerm(*((PCWSTR*)pbData));
        break;
    }
    }

    AssertSz(cbData, "We should have a size");

    return cbData;
}



//+---------------------------------------------------------------------------
//
//  Member:     TranslateFromDataToReg
//
//  Purpose:    Translates user data to a format the can be stored in the
//              registry
//
//  Arguments:
//      dwType          The registry pseudo type that is being translated
//      pbData          The data that has to be translated
//      pbBuf           A buffer that stores the registry data
//
//  Returns:    Nothing.
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
VOID
TranslateFromDataToReg(
    IN DWORD dwType,
    IN const BYTE* pbData,
    OUT const BYTE* pbBuf)
{
    switch (dwType)
    {
#ifdef DBG
    default:
    {
        AssertSz(FALSE, "Unknown registry type");
        break;
    }
#endif // DBG

    case REG_IP:
    {
        // Convert the 32-bit IP address to a stringized form.
        DWORD dwIpAddr = *((DWORD*)pbData);

        WCHAR pszIpAddr [32];
        IpHostAddrToPsz (dwIpAddr, pszIpAddr);

        // Copy the string
        lstrcpyW((PWSTR)pbBuf, pszIpAddr);
        break;
    }

    case REG_BOOL:
    {
        // Form the boolean as 'TRUE' or 'FALSE' based on
        // whether the data is non-zero or zero respectively.
        DWORD   dwData = *((DWORD*)pbData);
        *((BOOL*)pbBuf) = (!!dwData);
        break;
    }

    case REG_DWORD:
    {
        // DWORDs are direct assignments
        *((DWORD*)pbBuf) = *((DWORD*)pbData);
        break;
    }

    case REG_SZ:
    case REG_EXPAND_SZ:
    {
        // Make a copy of the string
        lstrcpyW((PWSTR)pbBuf, *((PCWSTR*)pbData));

        AssertSz(CbOfSzAndTerm(*((PCWSTR*)pbData)), "Zero length string");
        break;
    }
    }

    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     RegReadValues
//
//  Purpose:    To read a table of information from the registry into a user
//              defined data structure.
//
//  Arguments:
//      crb             The count of entries in the REGBATCH structure
//      arb             The pointer to the REGBATCH structure
//      pbUserData      The pointer to the source structure that is to retrieve
//                      the data from the registry
//      samDesired      The requested key access mask
//
//  Returns:    Nothing.
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
VOID RegReadValues(
    IN INT crb,
    IN const REGBATCH* arb,
    OUT const BYTE* pbUserData,
    IN REGSAM samDesired)
{
    AssertSz(FImplies(crb, arb), "Count without an array");

    HRESULT                 hr                                  = S_OK;
    const REGBATCH*         prbLast                             = NULL;
    HKEY                    rghkeySpec[celems(c_rgskmSpec)]     = {0};
    HKEY                    hkey                                = NULL;

    while (crb--)
    {
        BYTE*   pbData = (BYTE*)(pbUserData + arb->cbOffset);

        // Open the key if we need to.
        // We don't need to if it was the same as the previous one used.
        if ((!prbLast )
            || (prbLast->hkey != arb->hkey)
            || (prbLast->pszSubkey != arb->pszSubkey))
        {
            HKEY    hkeyParent;

            hkeyParent = HkeyTrueParent (arb->hkey, samDesired, rghkeySpec);

            // Close the previous key we used.
            RegSafeCloseKey (hkey);

            // Open the new key.
#ifdef DBG
            hr =
#endif // DBG
            HrRegOpenKeyEx (hkeyParent, arb->pszSubkey, samDesired, &hkey);
            AssertSz(FImplies(FAILED(hr), !hkey), "HrRegOpenKey not NULLing");
        }

        // Only continue if we have a key.
        if (hkey)
        {
            DWORD   dwType = arb->dwType;

            // We can't read NULL registry values
            if (REG_CREATE != dwType)
            {
                DWORD   cbData      = 0;
                BYTE*   pbStack     = NULL;
                DWORD   dwRealType  = DwRealTypeFromPsuedoType(dwType);

                // Ensure that we fail the first time around so that we can see how
                // big a buffer is needed
                (VOID) HrRegQueryValueEx(hkey, arb->pszValueName, &dwRealType,
                        NULL, &cbData);

                // Allocate memory on the stack to serve as our temporary buffer.
#ifndef STACK_ALLOC_DOESNT_WORK
                pbStack = (BYTE*)MemAlloc (cbData);
#else // !STACK_ALLOC_DOESNT_WORK
                pbStack = (BYTE*)PvAllocOnStack(cbData);
#endif // !STACK_ALLOC_DOESNT_WORK

                if(pbStack) 
                {
                    hr = HrRegQueryValueEx(hkey, arb->pszValueName, &dwRealType,
                                            pbStack, &cbData);
                }
                else 
                {
                    hr = E_OUTOFMEMORY;
                }

                if (S_OK == hr)
                {
                    // Make sure its the type we were expecting.
                    AssertSz((dwRealType == DwRealTypeFromPsuedoType(dwType)),
                            "Value types do no match");

                    TranslateFromRegToData(dwType, pbData, pbStack);
                }
                else
                {
                    UseDefaultRegValue(dwType, pbData, arb->pbDefault);

                    TraceHr (ttidError, FAL, hr,
                        HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr,
                        "RegReadValues: Could not open value %S", arb->pszValueName);
                }
#ifndef STACK_ALLOC_DOESNT_WORK
                MemFree (pbStack);
#endif // STACK_ALLOC_DOESNT_WORK
            }
        }
        else
        {
            TraceTag(ttidError, "RegReadValues: NULL key for %S", arb->pszSubkey);
            UseDefaultRegValue(arb->dwType, pbData, arb->pbDefault);
        }

        // Advance prbLast or set it to the first one if this is the
        // first time through.
        if (prbLast)
        {
            prbLast++;
        }
        else
        {
            prbLast = arb;
        }

        arb++;
    }

    // Clean up
    RegSafeCloseKey(hkey);
    RegSafeCloseKeyArray(rghkeySpec, celems(rghkeySpec));

    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     HrRegWriteValues
//
//  Purpose:    To write a table of information to the registry from a user
//              defined data structure.
//
//  Arguments:
//      crb             The count of entries in the REGBATCH structure
//      arb             The pointer to the REGBATCH structure
//      pbUserData      The pointer to the source structure that provides
//                      the data that is to be written to the registry
//      dwOptions       Options to be used when creating the registry keys
//      samDesired      The requested key access mask
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     CWill   Apr 30 1997
//
//  Notes:
//
HRESULT HrRegWriteValues(
        INT crb,
        const REGBATCH* arb,
        const BYTE* pbUserData,
        DWORD dwOptions,
        REGSAM samDesired)
{
    AssertSz(FImplies(crb, arb), "HrWriteValues : Count with no array");

    HRESULT                 hr                                  = S_OK;
    const REGBATCH*         prbLast                             = NULL;
    HKEY                    hkey                                = NULL;
    HKEY                    rghkeySpec[celems(c_rgskmSpec)]     = {0};

    while (crb--)
    {
        BYTE*   pbData = const_cast<BYTE*>(pbUserData + arb->cbOffset);

        // Open the key if we need to.
        // We don't need to if it was the same as the previous one used.
        if ((!prbLast)
            || (prbLast->hkey != arb->hkey)
            || (prbLast->pszSubkey != arb->pszSubkey))
        {
            HKEY    hkeyParent;

            hkeyParent = HkeyTrueParent(arb->hkey, samDesired, rghkeySpec);

            // Close the previous key we used.
            RegSafeCloseKey(hkey);

            // Open the new key.
            DWORD dwDisposition;
            hr = HrRegCreateKeyEx(hkeyParent, arb->pszSubkey, dwOptions,
                    samDesired, NULL, &hkey, &dwDisposition);

            AssertSz(FImplies(FAILED(hr), !hkey), "HrRegCreateKey not NULLing");

            if (FAILED(hr))
            {
                TraceError("HrRegWriteValues: failed to open parent key", hr);
                break;
            }
        }

        // Should definately have hkey by now.
        AssertSz(hkey, "Why no key?");

        //
        // Format the data to be put into the registry
        //

        DWORD   dwType  = arb->dwType;

        // If all we want to do is create the key, then we are already done.
        if (REG_CREATE != dwType)
        {
            DWORD           dwRealType  = DwRealTypeFromPsuedoType(dwType);
            DWORD           cbReg       = CbSizeOfDataToReg(dwType, pbData);
            BYTE*           pbReg       = NULL;

            AssertSz(cbReg, "We must have some data");

#ifndef STACK_ALLOC_DOESNT_WORK
            pbReg = new BYTE[cbReg];
#else // !STACK_ALLOC_DOESNT_WORK
            pbReg = reinterpret_cast<BYTE*>(PvAllocOnStack(cbReg));
#endif // !STACK_ALLOC_DOESNT_WORK

            if(!pbReg) 
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            TranslateFromDataToReg(dwType, pbData, pbReg);

            // Write the data to the registry.
            hr = HrRegSetValueEx(
                    hkey,
                    arb->pszValueName,
                    dwRealType,
                    pbReg,
                    cbReg);

#ifndef STACK_ALLOC_DOESNT_WORK
            // Must have this call before the break
            delete [] pbReg;
#endif // STACK_ALLOC_DOESNT_WORK

        }

        if (FAILED(hr))
        {
            break;
        }

        // Advance prbLast or set it to the first one if this is the
        // first time through.
        if (prbLast)
        {
            prbLast++;
        }
        else
        {
            prbLast = arb;
        }

        arb++;
    }

    RegSafeCloseKey(hkey);
    RegSafeCloseKeyArray(rghkeySpec, celems(rghkeySpec));

    TraceError("HrWriteValues", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrRegWriteValueTable
//
//  Purpose:    To write a table of values to the registry from a user
//              defined data structure.
//
//  Arguments:
//      hkeyRoot        The key to which the values are written
//      cvt             The count of entries in the VALUETABLE structure
//      avt             The pointer to the VALUETABLE structure
//      pbUserData      The pointer to the source structure that provides
//                      the data that is to be written to the registry
//      dwOptions       Options to be used when creating the registry keys
//      samDesired      The requested key access mask
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     CWill   06/26/97
//
//  Notes:
//
HRESULT HrRegWriteValueTable(
        HKEY hkeyRoot,
        INT cvt,
        const VALUETABLE* avt,
        const BYTE* pbUserData,
        DWORD dwOptions,
        REGSAM samDesired)
{
    HRESULT             hr          = S_OK;

    while (cvt--)
    {
        BYTE*   pbData  = NULL;
        DWORD   dwType  = REG_NONE;

        //
        // Format the data to be put into the registry
        //

        dwType = avt->dwType;
        pbData = const_cast<BYTE*>(pbUserData + avt->cbOffset);

        // If all we want to do is create the key, then we are already done.
        if (REG_CREATE != dwType)
        {
            DWORD           dwRealType  = DwRealTypeFromPsuedoType(dwType);
            DWORD           cbReg       = CbSizeOfDataToReg(dwType, pbData);
            BYTE*           pbReg       = NULL;

            AssertSz(cbReg, "We must have some data");

#ifndef STACK_ALLOC_DOESNT_WORK
            pbReg = new BYTE[cbReg];
#else // !STACK_ALLOC_DOESNT_WORK
            pbReg = reinterpret_cast<BYTE*>(PvAllocOnStack(cbReg));
#endif // !STACK_ALLOC_DOESNT_WORK

            if(!pbReg) 
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            TranslateFromDataToReg(dwType, pbData, pbReg);

            // Write the data to the registry.
            hr = HrRegSetValueEx(
                    hkeyRoot,
                    avt->pszValueName,
                    dwRealType,
                    pbReg,
                    cbReg);

#ifndef STACK_ALLOC_DOESNT_WORK
            // Must have this call before the break
            delete [] pbReg;
#endif // STACK_ALLOC_DOESNT_WORK
        }

        if (FAILED(hr))
        {
            break;
        }

        avt++;
    }

    TraceError("HrRegWriteValueTable", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncstring.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S T R I N G . C P P
//
//  Contents:   Common string routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncdebug.h"
#include "ncstring.h"

//+---------------------------------------------------------------------------
//
//  Function:   CbOfSzSafe, CbOfSzaSafe,
//              CbOfSzAndTermSafe, CbOfSzaAndTermSafe
//
//  Purpose:    Count the bytes required to hold a string.  The string
//              may be NULL in which case zero is returned.
//
//  Arguments:
//      psz [in] String to return count of bytes for.
//
//  Returns:    Count of bytes required to store string.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      'AndTerm' variants includes space for the null-terminator.
//
ULONG
CbOfSzSafe (
    IN PCWSTR psz)
{
    return (psz) ? CbOfSz(psz) : 0;
}

ULONG
CbOfSzaSafe (
    IN PCSTR psza)
{
    return (psza) ? CbOfSza(psza) : 0;
}

ULONG
CbOfSzAndTermSafe (
    IN PCWSTR psz)
{
    return (psz) ? CbOfSzAndTerm(psz) : 0;
}

ULONG
CbOfSzaAndTermSafe (
    IN PCSTR psza)
{
    return (psza) ? CbOfSzaAndTerm(psza) : 0;
}

ULONG
CchOfSzSafe (
    IN PCWSTR psz)
{
    return (psz) ? wcslen(psz) : 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   DwFormatString
//
//  Purpose:    Uses FormatMessage to format a string from variable arguments.
//              The string is formatted into a fixed-size buffer the caller
//              provides.
//              See the description of FormatMessage in the Win32 API.
//
//  Arguments:
//      pszFmt  [in]    pointer to format string
//      pszBuf  [out]   pointer to formatted output
//      cchBuf  [in]    count of characters in pszBuf
//      ...     [in]    replaceable string parameters
//
//  Returns:    the return value of FormatMessage
//
//  Author:     shaunco   15 Apr 1997
//
//  Notes:      The variable arguments must be strings otherwise
//              FormatMessage will barf.
//
DWORD
WINAPIV
DwFormatString (
    IN PCWSTR pszFmt,
    OUT PWSTR  pszBuf,
    IN DWORD   cchBuf,
    IN ...)
{
    Assert (pszFmt);

    va_list val;
    va_start(val, cchBuf);
    DWORD dwRet = FormatMessage (FORMAT_MESSAGE_FROM_STRING,
            pszFmt, 0, 0, pszBuf, cchBuf, &val);
    va_end(val);
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   DwFormatStringWithLocalAlloc
//
//  Purpose:    Uses FormatMessage to format a string from variable arguments.
//              The string is allocated by FormatMessage using LocalAlloc.
//              See the description of FormatMessage in the Win32 API.
//
//  Arguments:
//      pszFmt  [in]    pointer to format string
//      ppszBuf [out]   the returned formatted string
//      ...     [in]    replaceable string parameters
//
//  Returns:    the return value of FormatMessage
//
//  Author:     shaunco   3 May 1997
//
//  Notes:      The variable arguments must be strings otherwise
//              FormatMessage will barf.
//
DWORD
WINAPIV
DwFormatStringWithLocalAlloc (
    IN PCWSTR pszFmt,
    OUT PWSTR* ppszBuf,
    IN ...)
{
    Assert (pszFmt);

    va_list val;
    va_start(val, ppszBuf);
    DWORD dwRet = FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_STRING,
                                 pszFmt, 0, 0,
                                 (PWSTR)ppszBuf,
                                 0, &val);
    va_end(val);
    return dwRet;
}

//+--------------------------------------------------------------------------
//
//  Function:   FFindStringInCommaSeparatedList
//
//  Purpose:    Given a comma separated list, pszList, and a search string,
//                  pszSubString, this routine will try to locate pszSubString
//                  in the list,
//
//  Arguments:
//      pszSubString   [in]  The string to search for
//      pszList        [in]  The list to search in
//      eIgnoreSpaces [in]  If NC_IGNORE, skip leading and trailing spaces
//                          when comparing.
//                          If NC_DONT_IGNORE, don't skip leading and
//                          trailing spaces.
//      dwPosition    [out] Optional. If found, the position of the first
//                          occurrence of the substring in the list. The first
//                          position is 0.
//
//  Returns:    BOOL. TRUE if pszSubString is in pszList, FALSE otherwise
//
//  Author:     billbe   09 Sep 1997
//
//  Notes:
//
BOOL
FFindStringInCommaSeparatedList (
    IN PCWSTR pszSubString,
    IN PCWSTR pszList,
    IN NC_IGNORE_SPACES eIgnoreSpaces,
    OUT DWORD* pdwPosition)
{

    Assert(pszSubString);
    Assert(pszList);

    int         cchSubString = lstrlenW (pszSubString);
    int         cchList = lstrlenW (pszList);

    BOOL        fFound = FALSE;
    PCWSTR     pszTemp = pszList;
    int         nIndex;
    const WCHAR c_chDelim = L',';

    // Initialize out param if specified.
    if (pdwPosition)
    {
        *pdwPosition = 0;
    }

    // This routine searches the list for a substring matching pszSubString
    // If found, checks are made to ensure the substring is not part of
    // a larger substring.  We continue until we find the substring or we
    // have searched through the entire list.
    //
    while (!fFound)
    {
        // Search for the next occurence of the substring.
        if (pszTemp = wcsstr (pszTemp, pszSubString))
        {
            // we found an occurrence, so now we make sure it is not part of
            // a larger string.
            //

            fFound = TRUE;
            nIndex = pszTemp - pszList;

            // If the substring was not found at the beginning of the list
            // we check the previous character to ensure it is the delimiter.
            if (nIndex > 0)
            {
                int cchSubtract = 1;

                // If we are to ignore leading spaces, find the first
                // non-space character if there is one.
                //
                if (NC_IGNORE == eIgnoreSpaces)
                {
                    // Keep skipping leading spaces until we either find a
                    // non-space or pass the beginning of the list.
                    while ((L' ' == *(pszTemp - cchSubtract)) &&
                            cchSubtract <= nIndex)
                    {
                        cchSubtract--;
                    }
                }

                // If we haven't passed the beginning of the list, compare the
                // character.
                if (cchSubtract <= nIndex)
                {
                    fFound = (*(pszTemp - cchSubtract) == c_chDelim);
                }
            }

            // If the end of the substring is not the end of the list
            // we check the character after the substring to ensure
            // it is a delimiter.
            if (fFound && ((nIndex + cchSubString) < cchList))
            {
                int cchAdd = cchSubString;

                // If we are ignoring white spaces, we have to check the next
                // available non-space character
                //
                if (NC_IGNORE == eIgnoreSpaces)
                {
                    // Search for a non-space until we find one or pass
                    // the end of the list
                    while ((L' ' == *(pszTemp + cchAdd)) &&
                            (cchAdd + nIndex) < cchList)
                    {
                        cchAdd++;
                    }
                }

                // If we haven't passed the end of the list, check the
                // character
                if (nIndex + cchAdd < cchList)
                {
                    fFound = (*(pszTemp + cchSubString) == c_chDelim);
                }


                if (NC_IGNORE == eIgnoreSpaces)
                {
                    // advance pointer the number of white spaces we skipped
                    // so we won't check those characters on the next pass
                    Assert(cchAdd >= cchSubString);
                    pszTemp += (cchAdd - cchSubString);
                }
            }

            // At this point, if the checks worked out, we found our string
            // and will be exiting the loop
            //

            // Advance the temp pointer the length of the sub string we are
            // searching for so we can search the rest of the list
            // if we need to
            pszTemp += cchSubString;
        }
        else
        {
            // Search string wasn't found
            break;
        }
    }

    // If we found the string and the out param exists,
    // then we need to return the strings position in the list.
    //
    if (fFound && pdwPosition)
    {
        // We will use the number of delimters found before the string
        // as an indicator of the strings position.
        //

        // Start at the beginning
        pszTemp = pszList;
        PWSTR pszDelim;

        // The string is nIndex characters in the list so lets get
        // its correct address.
        PCWSTR pszFoundString = pszList + nIndex;

        // As long as we keep finding a delimiter in the list...
        while (pszDelim = wcschr(pszTemp, c_chDelim))
        {
            // If the delimiter we just found is before our string...
            if (pszDelim < pszFoundString)
            {
                // Increase our position indicator
                ++(*pdwPosition);

                // Move the temp pointer to the next string
                pszTemp = pszDelim + 1;

                continue;
            }

            // The delimiter we just found is located after our
            // found string so get out of the loop.
            break;
        }
    }

    return fFound;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsSubstr
//
//  Purpose:    Case *insensitive* substring search.
//
//  Arguments:
//      pszSubString [in]    Substring to look for.
//      pszString    [in]    String to search in.
//
//  Returns:    TRUE if substring was found, FALSE otherwise.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      Allocates temp buffers on stack so they do not need to be
//              freed.
//
BOOL
FIsSubstr (
    IN PCWSTR pszSubString,
    IN PCWSTR pszString)
{
    PWSTR      pszStringUpper;
    PWSTR      pszSubStringUpper;

    Assert(pszString);
    Assert(pszSubString);

#ifndef STACK_ALLOC_DOESNT_WORK
    pszStringUpper = (PWSTR)
        (PvAllocOnStack (CbOfSzAndTerm(pszString)));

    pszSubStringUpper = (PWSTR)
        (PvAllocOnStack (CbOfSzAndTerm(pszSubString)));
#else
    pszStringUpper    = MemAlloc(CbOfSzAndTerm(pszString));
    pszSubStringUpper = MemAlloc(CbOfSzAndTerm(pszSubString));
#endif

    lstrcpyW (pszStringUpper, pszString);
    lstrcpyW (pszSubStringUpper, pszSubString);

    // Convert both strings to uppercase before calling strstr
    CharUpper (pszStringUpper);
    CharUpper (pszSubStringUpper);

#ifndef STACK_ALLOC_DOESNT_WORK
    return NULL != wcsstr(pszStringUpper, pszSubStringUpper);
#else
    BOOL fRet = (NULL != wcsstr (pszStringUpper, pszSubStringUpper));
    MemFree(pszStringUpper);
    MemFree(pszSubStringUpper);

    return fRet;
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   HrRegAddStringToDelimitedSz
//
//  Purpose:    Add a string into a REG_MULTI_SZ registry value.
//
//  Arguments:
//      pszAddString    [in]    The string to add to the delimited psz.
//      pszIn           [in]    The delimited psz list.
//      chDelimiter     [in]    The character to be used to delimit the
//                              values. Most multi-valued REG_SZ strings are
//                              delimited with either ',' or ' '. This will
//                              be used to delimit the value that we add,
//                              as well.
//      dwFlags         [in]    Can contain one or more of the following
//                              values:
//
//                              STRING_FLAG_ALLOW_DUPLICATES
//                                  Don't remove duplicate values when adding
//                                  the string to the list. Default is to
//                                  remove all other instance of this string.
//                              STRING_FLAG_ENSURE_AT_FRONT
//                                  Insert the string as the first element of
//                                  the list.
//                              STRING_FLAG_ENSURE_AT_END
//                                  Insert the string as the last
//                                  element of the list. This can not be used
//                                  with STRING_FLAG_ENSURE_AT_FRONT.
//                              STRING_FLAG_ENSURE_AT_INDEX
//                                  Ensure that the string is at dwStringIndex
//                                  in the psz.  If the index specified
//                                  is greater than the number of strings
//                                  in the psz, the string will be
//                                  placed at the end.
//      dwStringIndex   [in]    If STRING_FLAG_ENSURE_AT_INDEX is specified,
//                              this is the index for the string position.
//                              Otherwise, this value is ignored.
//      pmszOut         [out]   The new delimited psz.
//
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
//  Modified:   BillBe      9 Nov 1998
//              (Extracted from HrRegAddStringToSz and modified)
//
//
//  Note:
//      Might want to allow for the removal of leading/trailing spaces
//
HRESULT
HrAddStringToDelimitedSz (
    IN PCWSTR pszAddString,
    IN PCWSTR pszIn,
    IN WCHAR chDelimiter,
    IN DWORD dwFlags,
    IN DWORD dwStringIndex,
    OUT PWSTR* ppszOut)
{
    Assert(pszAddString);
    Assert(ppszOut);

    HRESULT hr = S_OK;

    // Don't continue if the pointers are NULL
    if (!pszAddString || !ppszOut)
    {
        hr =  E_POINTER;
    }

    if (S_OK == hr)
    {
        // Initialize out param
        *ppszOut = NULL;
    }

    BOOL fEnsureAtFront = dwFlags & STRING_FLAG_ENSURE_AT_FRONT;
    BOOL fEnsureAtEnd = dwFlags & STRING_FLAG_ENSURE_AT_END;
    BOOL fEnsureAtIndex = dwFlags & STRING_FLAG_ENSURE_AT_INDEX;

    // Can't specify more than one of these flags
    if ((fEnsureAtFront && fEnsureAtEnd) ||
        (fEnsureAtFront && fEnsureAtIndex) ||
        (fEnsureAtEnd && fEnsureAtIndex))
    {
        AssertSz(FALSE, "Invalid flags in HrAddStringToSz");
        hr = E_INVALIDARG;
    }

    // Have to specify at least one of these
    if (!fEnsureAtFront && !fEnsureAtEnd && !fEnsureAtIndex)
    {
        AssertSz(FALSE, "Must specify a STRING_FLAG_ENSURE flag");
        hr = E_INVALIDARG;
    }


    if (S_OK == hr)
    {
        // Alloc the new blob, including enough space for the trailing comma
        //
        *ppszOut = (PWSTR) MemAlloc (CbOfSzAndTermSafe(pszIn) +
                CbOfSzSafe(pszAddString) + sizeof(WCHAR));

        if (!*ppszOut)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (S_OK == hr)
    {
        DWORD dwCurrentIndex = 0; // Current index in the new buffer

        // Prime the new string
        //
        (*ppszOut)[0] = L'\0';

        // If we have the "ensure at front" flag, do so with the passed in
        // value. We also do this if we have the ensure at index flag
        // set with index of 0 or if the ensure at index is set but
        // the input string is null or empty
        //
        if (fEnsureAtFront || (fEnsureAtIndex && (0 == dwStringIndex)) ||
                (fEnsureAtIndex && (!pszIn || !*pszIn)))
        {
            lstrcpyW (*ppszOut, pszAddString);
            ++dwCurrentIndex;
        }

        // If there was a previous value, walk through it and copy as needed.
        // If not, then we're done.
        if (pszIn && *pszIn)
        {
            PCWSTR pszCurrent = pszIn;

            // Loop through the old buffer, and copy all of the strings that
            // are not identical to our insertion string.
            //

            // Find the first string's end (at the delimiter).
            PCWSTR pszEnd = wcschr (pszCurrent, chDelimiter);

            while (*pszCurrent)
            {
                // If the delimiter didn't exist, set the end to the end of the
                // entire string
                //
                if (!pszEnd)
                {
                    pszEnd = pszCurrent + lstrlenW (pszCurrent);
                }

                LONG lLength = lstrlenW (*ppszOut);
                if (fEnsureAtIndex && (dwCurrentIndex == dwStringIndex))
                {
                    // We know we are not at the first item since
                    // this would mean dwStringIndex is 0 and we would
                    // have copied the string before this point
                    //
                    (*ppszOut)[lLength++] = chDelimiter;
                    (*ppszOut)[lLength++] = L'\0';

                    // Append the string.
                    lstrcatW (*ppszOut, pszAddString);
                    ++dwCurrentIndex;
                }
                else
                {
                    DWORD cch = pszEnd - pszCurrent;
                    // If we are allowing duplicates or the current string
                    // doesn't match the string we want to add, then we will
                    // copy it.
                    //
                    if ((dwFlags & STRING_FLAG_ALLOW_DUPLICATES) ||
                            (_wcsnicmp (pszCurrent, pszAddString, cch) != 0))
                    {
                        // If we're not the first item, then add the delimiter.
                        //
                        if (lLength > 0)
                        {
                            (*ppszOut)[lLength++] = chDelimiter;
                            (*ppszOut)[lLength++] = L'\0';
                        }

                        // Append the string.
                        wcsncat (*ppszOut, pszCurrent, cch);
                        ++dwCurrentIndex;
                    }

                    // Advance the pointer to one past the end of the current
                    // string unless, the end is not the delimiter but NULL.
                    // In that case, set the current point to equal the end
                    // pointer
                    //
                    pszCurrent = pszEnd + (*pszEnd ? 1 : 0);

                    // If the current pointer is not at the end of the input
                    // string, then find the next delimiter
                    //
                    if (*pszCurrent)
                    {
                        pszEnd = wcschr (pszCurrent, chDelimiter);
                    }
                }
            }
        }

        // If we don't have the "insert at front" flag, then we should insert
        // at the end (this is the same as having the
        // STRING_FLAG_ENSURE_AT_END flag set)
        //
        if (fEnsureAtEnd ||
                (fEnsureAtIndex && (dwCurrentIndex <= dwStringIndex)))
        {
            LONG lLength = lstrlenW (*ppszOut);

            // If we're not the first item, add the delimiter.
            //
            if (lstrlenW (*ppszOut) > 0)
            {
                (*ppszOut)[lLength++] = chDelimiter;
                (*ppszOut)[lLength++] = L'\0';
            }

            // Append the string.
            //
            lstrcatW (*ppszOut, pszAddString);
        }
    }

    TraceError ("HrAddStringToDelimitedSz", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegRemoveStringFromDelimitedSz
//
//  Purpose:    Removes a string from a delimited string value
//
//  Arguments:
//      pszRemove  [in] The string to be removed from the multi-sz
//      pszIn      [in] The delimited list to scan for pszRemove
//      cDelimiter [in] The character to be used to delimit the
//                      values. Most multi-valued REG_SZ strings are
//                      delimited with either ',' or ' '.
//      dwFlags    [in] Can contain one or more of the following
//                      values:
//
//                      STRING_FLAG_REMOVE_SINGLE
//                          Don't remove more than one value, if
//                          multiple are present.
//                      STRING_FLAG_REMOVE_ALL
//                          If multiple matching values are present,
//                          remove them all.
//      ppszOut   [out] The string with pszRemove removed. Note
//                      that the output parameter is always set even
//                      if pszRemove did not exist in the list.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     jeffspr     27 Mar 1997
//
//  Modified:   BillBe      10 Nov 1998
//              (Extracted from HrRegAddStringToSz and modified)
//
//
//
//  Note:
//      Might want to allow for the removal of leading/trailing spaces
//
HRESULT
HrRemoveStringFromDelimitedSz(
    IN PCWSTR pszRemove,
    IN PCWSTR pszIn,
    IN WCHAR chDelimiter,
    IN DWORD dwFlags,
    OUT PWSTR* ppszOut)
{

    Assert(pszIn && *pszIn);
    Assert(ppszOut);

    HRESULT hr = S_OK;

    // If the out param is not specified, get out
    if (!ppszOut)
    {
        return E_INVALIDARG;
    }

    // Alloc the new blob
    //
    hr = E_OUTOFMEMORY;
    *ppszOut = (PWSTR) MemAlloc (CbOfSzAndTermSafe (pszIn));

    if (*ppszOut)
    {
        hr = S_OK;
        // Prime the new string
        //
        (*ppszOut)[0] = L'\0';

        // If there was a previous value, walk through it and copy as needed.
        // If not, then we're done
        //
        if (pszIn)
        {
            // Loop through the old buffer, and copy all of the strings that
            // are not identical to our insertion string.
            //
            PCWSTR pszCurrent = pszIn;

            // Loop through the old buffer, and copy all of the strings that
            // are not identical to our insertion string.
            //

            // Find the first string's end (at the delimiter).
            PCWSTR pszEnd = wcschr (pszCurrent, chDelimiter);

            // Keep track of how many instances have been removed.
            DWORD   dwNumRemoved    = 0;

            while (*pszCurrent)
            {
                // If the delimiter didn't exist, set the end to the end of
                // the entire string.
                //
                if (!pszEnd)
                {
                    pszEnd = pszCurrent + lstrlenW (pszCurrent);
                }

                DWORD cch = pszEnd - pszCurrent;
                INT iCompare;
                // If we have a match, and we want to remove it (meaning that
                // if we have the remove-single set, that we haven't removed
                // one already).

                iCompare = _wcsnicmp (pszCurrent, pszRemove, cch);

                if ((iCompare) ||
                    ((dwFlags & STRING_FLAG_REMOVE_SINGLE) &&
                     (dwNumRemoved > 0)))
                {
                    LONG lLength = lstrlenW (*ppszOut);

                    // If we're not the first item, then add the delimiter.
                    //
                    if (lLength > 0)
                    {
                        (*ppszOut)[lLength++] = chDelimiter;
                        (*ppszOut)[lLength++] = L'\0';
                    }

                    // Append the string.
                    wcsncat (*ppszOut, pszCurrent, cch);
                }
                else
                {
                    dwNumRemoved++;
                }

                // Advance the pointer to one past the end of the current
                // string unless, the end is not the delimiter but NULL.
                // In that case, set the current point to equal the end
                // pointer
                //
                pszCurrent = pszEnd + (*pszEnd ? 1 : 0);

                // If the current pointer is not at the end of the input
                // string, then find the next delimiter
                //
                if (*pszCurrent)
                {
                    pszEnd = wcschr (pszCurrent, chDelimiter);
                }
            }
        }
    }

    TraceError("HrRemoveStringFromDelimitedSz", hr);
    return hr;
}

PWSTR
PszAllocateAndCopyPsz (
    IN PCWSTR pszSrc)
{
    if (!pszSrc)
    {
        return NULL;
    }

    ULONG cb = (wcslen (pszSrc) + 1) * sizeof(WCHAR);
    PWSTR psz = (PWSTR)MemAlloc (cb);
    if (psz)
    {
        CopyMemory (psz, pszSrc, cb);
    }

    return psz;
}

//+---------------------------------------------------------------------------
//
//  Function:   SzLoadStringPcch
//
//  Purpose:    Load a resource string.  (This function will never return NULL.)
//
//  Arguments:
//      hinst [in]  Instance handle of module with the string resource.
//      unId  [in]  Resource ID of the string to load.
//      pcch  [out] Pointer to returned character length.
//
//  Returns:    Pointer to the constant string.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      The loaded string is pointer directly into the read-only
//              resource section.  Any attempt to write through this pointer
//              will generate an access violation.
//
//              The implementations is referenced from "Win32 Binary Resource
//              Formats" (MSDN) 4.8 String Table Resources
//
//              User must have RCOPTIONS = -N turned on in your sources file.
//
PCWSTR
SzLoadStringPcch (
    IN HINSTANCE   hinst,
    IN UINT        unId,
    OUT int*       pcch)
{
    Assert(hinst);
    Assert(unId);
    Assert(pcch);

    static const WCHAR c_szSpace[] = L" ";

    PCWSTR psz = c_szSpace;
    int    cch = 1;

    // String Tables are broken up into 16 string segments.  Find the segment
    // containing the string we are interested in.
    HRSRC hrsrcInfo = FindResource (hinst,
                        (PWSTR)ULongToPtr( ((LONG)(((USHORT)unId >> 4) + 1)) ),
                        RT_STRING);
    if (hrsrcInfo)
    {
        // Page the resource segment into memory.
        HGLOBAL hglbSeg = LoadResource (hinst, hrsrcInfo);
        if (hglbSeg)
        {
            // Lock the resource.
            psz = (PCWSTR)LockResource(hglbSeg);
            if (psz)
            {
                // Move past the other strings in this segment.
                // (16 strings in a segment -> & 0x0F)
                unId &= 0x0F;

                cch = 0;
                do
                {
                    psz += cch;                // Step to start of next string
                    cch = *((WCHAR*)psz++);    // PASCAL like string count
                }
                while (unId--);

                // If we have a non-zero count, it includes the
                // null-terminiator.  Subtract this off for the return value.
                //
                if (cch)
                {
                    cch--;
                }
                else
                {
                    AssertSz(0, "String resource not found");
                    psz = c_szSpace;
                    cch = 1;
                }
            }
            else
            {
                psz = c_szSpace;
                cch = 1;
                TraceLastWin32Error("SzLoadStringPcch: LockResource failed.");
            }
        }
        else
            TraceLastWin32Error("SzLoadStringPcch: LoadResource failed.");
    }
    else
        TraceLastWin32Error("SzLoadStringPcch: FindResource failed.");

    *pcch = cch;
    Assert(*pcch);
    Assert(psz);
    return psz;
}

//+---------------------------------------------------------------------------
//
//  Function:   SzaDupSza
//
//  Purpose:    Duplicates a string
//
//  Arguments:
//      pszaSrc [in]  string to be duplicated
//
//  Returns:    Pointer to the new copy of the string
//
//  Author:     CWill   25 Mar 1997
//
//  Notes:      The string return must be freed (MemFree).
//
PSTR
SzaDupSza (
        PCSTR pszaSrc)
{
    AssertSz(pszaSrc, "Invalid source string");

    PSTR  pszaDst;
    pszaDst = (PSTR) MemAlloc (CbOfSzaAndTerm(pszaSrc));

    if(pszaDst) lstrcpyA(pszaDst, pszaSrc);

    return pszaDst;
}

//+---------------------------------------------------------------------------
//
//  Function:   SzDupSz
//
//  Purpose:    Duplicates a string
//
//  Arguments:
//      pszSrc [in]  string to be duplicated
//
//  Returns:    Pointer to the new copy of the string
//
//  Author:     CWill   25 Mar 1997
//
//  Notes:      The string return must be freed.
//
PWSTR
SzDupSz (
    IN PCWSTR pszSrc)
{
    AssertSz(pszSrc, "Invalid source string");

    PWSTR   pszDst;
    pszDst = (PWSTR) MemAlloc (CbOfSzAndTerm(pszSrc));
    if(pszDst) lstrcpyW (pszDst, pszSrc);

    return pszDst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncshell.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       N C S H E L L . C P P
//
//  Contents:   Common routines for dealing with shell interfaces.
//
//  Notes:
//
//  Author:     anbrad  08  Jun 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include "shlobj.h"
#include <shlobjp.h>

#include "pidlutil.h"

//+---------------------------------------------------------------------------
//
//  Function:   GenerateEvent
//
//  Purpose:    Generate a Shell Notification event.
//
//  Arguments:
//      lEventId   [in]     The event ID to post
//      pidlFolder [in]     Folder pidl
//      pidlIn     [in]     First pidl that we reference
//      pidlNewIn  [in]     If needed, the second pidl.
//
//  Returns:
//
//  Author:     jeffspr   16 Dec 1997
//
//  Notes:
//
VOID GenerateEvent(
    LONG            lEventId,
    LPCITEMIDLIST   pidlFolder,
    LPCITEMIDLIST   pidlIn,
    LPCITEMIDLIST   pidlNewIn)
{
    // Build an absolute pidl from the folder pidl + the object pidl
    //
    LPITEMIDLIST pidl = ILCombine(pidlFolder, pidlIn);
    if (pidl)
    {
        // If we have two pidls, call the notify with both
        //
        if (pidlNewIn)
        {
            // Build the second absolute pidl
            //
            LPITEMIDLIST pidlNew = ILCombine(pidlFolder, pidlNewIn);
            if (pidlNew)
            {
                // Make the notification, and free the new pidl
                //
                SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, pidlNew);
                FreeIDL(pidlNew);
            }
        }
        else
        {
            // Make the single-pidl notification
            //
            SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, NULL);
        }

        // Always refresh, then free the newly allocated pidl
        //
        SHChangeNotifyHandleEvents();
        FreeIDL(pidl);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncsetup.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S E T U P . C P P
//
//  Contents:   HRESULT wrappers for the Setup Api.
//
//  Notes:
//
//  Author:     shaunco   16 Apr 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncsetup.h"
#include "ncbase.h"
#include "ncmem.h"
#include "ncstring.h"
#include "ncmisc.h"
#include <swenum.h>

extern const WCHAR c_szNo[];
extern const WCHAR c_szYes[];

// dwFieldIndex parameter for the first field.  Fields indexes are 1 based
// in Setup Api.
//
const DWORD c_dwFirstField = 1;

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupCommitFileQueue
//
//  Purpose:    Initializes the context used by the default queue callback
//                  routine included with the Setup API in the same manner
//                  as SetupInitDefaultQueueCallback, except that an
//                  additional window is provided to the callback function
//                  to accept progress messages.
//
//  Arguments:
//      hwndOwner   [in] See SetupApi for information
//      hfq         [in]
//      pfc         [in]
//      pvCtx       [in]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     billbe   23 July 1997
//
//  Notes:
//
HRESULT HrSetupCommitFileQueue(HWND hwndOwner, HSPFILEQ hfq,
                               PSP_FILE_CALLBACK pfc, PVOID pvCtx)
{
    Assert(hfq);
    Assert(INVALID_HANDLE_VALUE != hfq);
    Assert(pfc);
    Assert(pvCtx);

    HRESULT hr = S_OK;

    // Try to commit the queue
    if (!SetupCommitFileQueue(hwndOwner, hfq, pfc, pvCtx))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError ("HrSetupCommitFileQueue", (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupInitDefaultQueueCallbackEx
//
//  Purpose:    Initializes the context used by the default queue callback
//                  routine included with the Setup API in the same manner
//                  as SetupInitDefaultQueueCallback, except that an
//                  additional window is provided to the callback function
//                  to accept progress messages.
//
//  Arguments:
//      hwndOwner       [in] See SetupApi for information
//      hwndAlternate   [in]
//      uMsg            [in]
//      dwReserved1     [in]
//      dwReserved2     [in]
//      ppvCtx          [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     billbe   23 July 1997
//
//  Notes:
//
HRESULT HrSetupInitDefaultQueueCallbackEx(HWND hwndOwner, HWND hwndAlternate,
                                          UINT uMsg, DWORD dwReserved1,
                                          PVOID pvReserved2, PVOID* ppvCtx)
{
    Assert(ppvCtx);

    // Try to init default queue callback.
    //
    HRESULT hr;
    PVOID pvCtx = SetupInitDefaultQueueCallbackEx(hwndOwner, hwndAlternate,
            uMsg, dwReserved1, pvReserved2);


    if (pvCtx)
    {
        hr = S_OK;
        *ppvCtx = pvCtx;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        *ppvCtx = NULL;
    }

    TraceError ("HrSetupInitDefaultQueueCallbackEx", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupOpenFileQueue
//
//  Purpose:    Creates a setup file queue.
//
//  Arguments:
//      phfq [out] See SetupApi for information
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     billbe   23 July 1997
//
//  Notes:
//
HRESULT HrSetupOpenFileQueue(HSPFILEQ* phfq)
{
    Assert(phfq);
    // Try to open the file queue.
    //
    HRESULT hr;
    HSPFILEQ hfq = SetupOpenFileQueue();
    if (INVALID_HANDLE_VALUE != hfq)
    {
        hr = S_OK;
        *phfq = hfq;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        *phfq = NULL;
    }
    TraceError ("HrSetupOpenFileQueue", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupOpenInfFile
//
//  Purpose:    Open an INF file.
//
//  Arguments:
//      pszFileName  [in]   See the Setup API documentation.
//      pszInfClass  [in]
//      dwInfStyle   [in]
//      punErrorLine [out]
//      phinf        [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   17 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupOpenInfFile (
    PCWSTR pszFileName,
    PCWSTR pszInfClass,
    DWORD dwInfStyle,
    UINT* punErrorLine,
    HINF* phinf)
{
    HRESULT hr;
    HINF hinf;

    Assert (pszFileName);
    Assert (phinf);

    // Try to open the file.
    //
    hinf = SetupOpenInfFile (pszFileName, pszInfClass,
                                  dwInfStyle, punErrorLine);
    if (INVALID_HANDLE_VALUE != hinf)
    {
        hr = S_OK;
        *phinf = hinf;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        *phinf = NULL;
        if (punErrorLine)
        {
            *punErrorLine = 0;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "HrSetupOpenInfFile (%S)", pszFileName);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupFindFirstLine
//
//  Purpose:    Find the first line in an INF file with a matching section
//              and key.
//
//  Arguments:
//      hinf       [in]     See the Setup API documentation.
//      pszSection [in]
//      pszKey     [in]
//      pctx       [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupFindFirstLine (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN PCWSTR pszKey,
    OUT INFCONTEXT* pctx)
{
    Assert (hinf);
    Assert (pszSection);
    Assert (pctx);

    HRESULT hr;
    if (SetupFindFirstLine (hinf, pszSection, pszKey, pctx))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();
    }
    TraceErrorOptional ("HrSetupFindFirstLine", hr,
                        (SPAPI_E_LINE_NOT_FOUND == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupFindNextLine
//
//  Purpose:    Find the next line in an INF file relative to ctxIn.
//
//  Arguments:
//      ctxIn   [in]    See the Setup API documentation.
//      pctxOut [out]
//
//  Returns:    S_OK if successful, S_FALSE if there are no more lines, or a
//              Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT HrSetupFindNextLine (const INFCONTEXT& ctxIn, INFCONTEXT* pctxOut)
{
    Assert (pctxOut);

    HRESULT hr;
    if (SetupFindNextLine (const_cast<PINFCONTEXT>(&ctxIn), pctxOut))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        if (SPAPI_E_LINE_NOT_FOUND == hr)
        {
            // Translate ERROR_LINE_NOT_FOUND into S_FALSE
            hr = S_FALSE;
        }
    }
    TraceError ("HrSetupFindNextLine", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupFindNextMatchLine
//
//  Purpose:    Find the next line in an INF file relative to ctxIn and
//              matching an optional key.
//
//  Arguments:
//      ctxIn   [in]    See the Setup API documentation.
//      pszKey  [in]
//      pctxOut [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupFindNextMatchLine (
    IN const INFCONTEXT& ctxIn,
    IN PCWSTR pszKey,
    OUT INFCONTEXT* pctxOut)
{
    Assert (pctxOut);

    HRESULT hr;
    if (SetupFindNextMatchLine ((PINFCONTEXT)&ctxIn, pszKey, pctxOut))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error();
        if (SPAPI_E_LINE_NOT_FOUND == hr)
        {
            // Translate ERROR_LINE_NOT_FOUND into S_FALSE
            hr = S_FALSE;
        }
    }
    TraceError ("HrSetupFindNextMatchLine", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetLineByIndex
//
//  Purpose:    Locates a line in an INF file by its index value in the
//              specified section.
//
//  Arguments:
//      hinf       [in]     See the Setup API documentation.
//      pszSection [in]
//      dwIndex    [in]
//      pctx       [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupGetLineByIndex (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN DWORD dwIndex,
    OUT INFCONTEXT* pctx)
{
    Assert (pszSection);
    Assert (pctx);

    HRESULT hr;
    if (SetupGetLineByIndex (hinf, pszSection, dwIndex, pctx))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();
    }
    TraceError ("HrSetupGetLineByIndex", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetLineCount
//
//  Purpose:    Get the number of lines in the specified section on an
//              INF file.
//
//  Arguments:
//      hinf       [in]     See the Setup API documentation.
//      pszSection [in]
//      pulCount   [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupGetLineCount (
    IN HINF hinf,
    IN PCWSTR pszSection,
    OUT ULONG* pulCount)
{
    Assert (pszSection);
    Assert (pulCount);

    HRESULT hr;
    LONG lCount = SetupGetLineCount (hinf, pszSection);
    if (-1 != lCount)
    {
        *pulCount = lCount;
        hr = S_OK;
    }
    else
    {
        *pulCount = 0;
        hr = HrFromLastWin32Error ();
    }
    TraceError ("HrSetupGetLineCount", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetBinaryField
//
//  Purpose:    Gets a binary value from an INF field.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      pbBuf        [out]
//      cbBuf        [in]
//      pbRequired   [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupGetBinaryField (
    IN const INFCONTEXT& ctx,
    IN DWORD dwFieldIndex,
    OUT BYTE* pbBuf,
    IN DWORD cbBuf,
    OUT DWORD* pbRequired)
{
    HRESULT hr;
    if (SetupGetBinaryField ((PINFCONTEXT)&ctx, dwFieldIndex, pbBuf,
            cbBuf, pbRequired))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        if (pbBuf)
        {
            *pbBuf = 0;
        }
        if (pbRequired)
        {
            *pbRequired = 0;
        }
    }
    TraceError ("HrSetupGetBinaryField", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetIntField
//
//  Purpose:    Gets an integer value from an INF field.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      pnValue      [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupGetIntField (
    IN const INFCONTEXT& ctx,
    IN DWORD dwFieldIndex,
    OUT INT* pnValue)
{
    Assert (pnValue);

    HRESULT hr;
    if (SetupGetIntField (const_cast<PINFCONTEXT>(&ctx),
                            dwFieldIndex, pnValue))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        *pnValue = 0;
    }
    TraceError ("HrSetupGetIntField", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetMultiSzField
//
//  Purpose:    Gets a multi-sz value from an INF field.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      pszBuf       [out]
//      cchBuf       [in]
//      pcchRequired [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupGetMultiSzField (
    const INFCONTEXT& ctx,
    DWORD dwFieldIndex,
    PWSTR pszBuf,
    DWORD cchBuf,
    DWORD* pcchRequired)
{
    HRESULT hr;
    if (SetupGetMultiSzField (const_cast<PINFCONTEXT>(&ctx),
                                dwFieldIndex, pszBuf, cchBuf, pcchRequired))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        if (pszBuf)
        {
            *pszBuf = 0;
        }
        if (pcchRequired)
        {
            *pcchRequired = 0;
        }
    }
    TraceError ("HrSetupGetMultiSzField", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetMultiSzFieldWithAlloc
//
//  Purpose:    Gets a multi-sz value from an INF field.  Allocates space for
//              it automatically.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      ppszBuf      [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:      Free the returned multi-sz with MemFree.
//
HRESULT HrSetupGetMultiSzFieldWithAlloc (
    const INFCONTEXT& ctx,
    DWORD dwFieldIndex,
    PWSTR* ppszBuf)
{
    Assert (ppszBuf);

    // Initialize the output parameter.
    *ppszBuf = NULL;

    // First, get the size required.
    //
    HRESULT hr;
    DWORD cchRequired;

    hr = HrSetupGetMultiSzField (ctx, dwFieldIndex, NULL, 0, &cchRequired);
    if (S_OK == hr)
    {
        // Allocate the buffer.
        //
        PWSTR pszBuf = (PWSTR)MemAlloc(cchRequired * sizeof(WCHAR));
        if (pszBuf)
        {
            // Now fill the buffer.
            //
            hr = HrSetupGetMultiSzField (ctx, dwFieldIndex, pszBuf,
                    cchRequired, NULL);
            if (S_OK == hr)
            {
                *ppszBuf = pszBuf;
            }
            else
            {
                MemFree (pszBuf);
            }
        }
    }
    TraceError ("HrSetupGetMultiSzFieldWithAlloc", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetStringField
//
//  Purpose:    Gets a string from an INF field.  Returns it as a tstring.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      pstr         [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT HrSetupGetStringField (const INFCONTEXT& ctx,
                               DWORD dwFieldIndex,
                               tstring* pstr)
{
    Assert (pstr);

    // First, get the size required.
    //
    DWORD cchRequired = 0;
    HRESULT hr = HrSetupGetStringField (ctx, dwFieldIndex, NULL, 0, &cchRequired);

    // 412390: workaround for bug in NT4 SETUPAPI.dll 
    //
    if ((S_OK == hr) && (0 == cchRequired))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    if (S_OK == hr)
    {
        // Allocate a buffer on the stack.
        //
        PWSTR pszBuf;
        pszBuf = (PWSTR)PvAllocOnStack(cchRequired * sizeof(WCHAR));

        // Now fill the buffer.
        //
        hr = HrSetupGetStringField (ctx, dwFieldIndex, pszBuf, cchRequired, NULL);
        if (S_OK == hr)
        {
            *pstr = pszBuf;
        }
    }
    // If we failed for any reason, initialize the output parameter.
    //
    if (FAILED(hr))
    {
        pstr->erase ();
    }
    TraceError ("HrSetupGetStringField", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetStringField
//
//  Purpose:    Gets a string from an INF field.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      pszBuf       [out]
//      cchBuf       [in]
//      pcchRequired [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT HrSetupGetStringField (
    IN const INFCONTEXT& ctx,
    IN DWORD dwFieldIndex,
    OUT PWSTR pszBuf,
    IN DWORD cchBuf,
    OUT DWORD* pcchRequired)
{
    HRESULT hr;
    if (SetupGetStringField ((PINFCONTEXT)&ctx, dwFieldIndex, pszBuf,
            cchBuf, pcchRequired))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();

        if (pszBuf)
        {
            *pszBuf = 0;
        }
        if (pcchRequired)
        {
            *pcchRequired = 0;
        }
    }
    TraceError ("HrSetupGetStringField", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupScanFileQueueWithNoCallback
//
//  Purpose:    Scans a setup file queue, performing an operation on each node
//                  in its copy list. The operation is specified by a set of
//                  flags. This function can be called either before or after
//                  the queue has been committed.
//
//  Arguments:
//      hfq         [in] See SetupApi for information
//      dwFlags     [in]
//      hwnd        [in]
//      pdwResult   [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     billbe   23 July 1997
//
//  Notes:      This differs from the SetupApi version in that no callback
//                  can be specified through this wrapper.  This is because
//                  errors from the callback cannot not be reliably mapped
//                  to an HRESULT.  If a user defined callback is needed,
//                  the original SetupApi function must be used.
//
HRESULT HrSetupScanFileQueueWithNoCallback(HSPFILEQ hfq, DWORD dwFlags,
                                           HWND hwnd, PDWORD pdwResult)
{
    Assert(hfq);
    Assert(INVALID_HANDLE_VALUE != hfq);
    Assert(pdwResult);

    HRESULT hr = S_OK;

    // Scan the given queue
    if (!SetupScanFileQueue(hfq, dwFlags, hwnd, NULL, NULL, pdwResult))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError ("HrSetupScanFileQueueWithNoCallback", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetMultiSzFieldMapToDword
//
//  Purpose:    Gets the values represented as mult-sz in an INF
//              and returns the value as a DWORD of bit flags.
//              The mapping is specified by the caller through an array of
//              pointers to string values and their associated DWORD values.
//
//              Example: The value in the INF might be "Ip,Ipx,Nbf".
//              This function can map these values to the DWORD
//              representation of FLAG_IP | FLAG_IPX | FLAG_NBF.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      aMapSzDword  [in]   array of elements mapping a string to a DWORD.
//      cMapSzDword  [in]   count of elements in the array.
//      pdwValue     [out]  the returned value.
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:      _wcsicmp is used to make the string comparisons.
//
HRESULT HrSetupGetMultiSzFieldMapToDword (const INFCONTEXT& ctx,
                                          DWORD dwFieldIndex,
                                          const MAP_SZ_DWORD* aMapSzDword,
                                          UINT cMapSzDword,
                                          DWORD* pdwValue)
{
    Assert (aMapSzDword);
    Assert (cMapSzDword);
    Assert (pdwValue);

    // Initialize the output parameter.
    *pdwValue = 0;

    // Get the multi-sz value.
    //
    HRESULT hr;
    PWSTR pszBuf;

    hr = HrSetupGetMultiSzFieldWithAlloc (ctx, dwFieldIndex, &pszBuf);
    if (S_OK == hr)
    {
        DWORD dwValue = 0;

        // Map each value in the multi-sz to a DWORD and OR it into
        // the result.
        for (PCWSTR pszValue = pszBuf;  *pszValue;
             pszValue += lstrlenW (pszValue) + 1)
        {
            // Search the map for a matching value.  When found, update
            // dwValue.
            for (UINT i = 0; i < cMapSzDword; i++)
            {
                if (0 == lstrcmpiW (aMapSzDword[i].pszValue, pszValue))
                {
                    dwValue |= aMapSzDword[i].dwValue;
                    break;
                }
            }
        }

        // Assign the output parameter.
        *pdwValue = dwValue;

        MemFree (pszBuf);
    }
    TraceError ("HrSetupGetMultiSzFieldMapToDword", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetStringFieldMapToDword
//
//  Purpose:    Gets a value represented as multiple strings in an INF
//              and returns it as a DWORD.  The mapping is specified
//              by the caller through an array of pointers to string
//              values and their associated DWORD values.
//
//              Example: Values in the INF might be "Yes" or "No".
//              This function can map these values to DWORD representations
//              of "1" and "0" respectively.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      aMapSzDword  [in]   array of elements mapping a string to a DWORD.
//      cMapSzDword  [in]   count of elements in the array.
//      pdwValue     [out]  the returned value.
//
//  Returns:    S_OK if a match was found.  If a match wasn't found,
//              HRESULT_FROM_WIN32(ERROR_INVALID_DATA) is returned.
//              Other Win32 error codes.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:      lstrcmpiW is used to make the string comparisons.
//
HRESULT HrSetupGetStringFieldMapToDword  (const INFCONTEXT& ctx,
                                          DWORD dwFieldIndex,
                                          const MAP_SZ_DWORD* aMapSzDword,
                                          UINT cMapSzDword,
                                          DWORD* pdwValue)
{
    Assert (aMapSzDword);
    Assert (cMapSzDword);
    Assert (pdwValue);

    // Initialize the output parameter.
    *pdwValue = 0;

    // Get the string value.
    //
    tstring strValue;
    HRESULT hr = HrSetupGetStringField (ctx, dwFieldIndex, &strValue);
    if (SUCCEEDED(hr))
    {
        // Search the map for a matching value.  When found, pass
        // the DWORD value out.
        // If the none of the strings matched, we'll return
        // an invalid data error code.
        hr = HRESULT_FROM_WIN32 (ERROR_INVALID_DATA);
        while (cMapSzDword--)
        {
            if (0 == lstrcmpiW (aMapSzDword->pszValue, strValue.c_str()))
            {
                *pdwValue = aMapSzDword->dwValue;
                hr = S_OK;
                break;
            }
            aMapSzDword++;
        }
    }
    TraceError ("HrSetupGetStringFieldMapToDword", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetStringFieldAsBool
//
//  Purpose:    Gets the value of a boolean field represented as the
//              strings "Yes" and "No" in an INF file.
//
//  Arguments:
//      ctx          [in]   See the Setup API documentation.
//      dwFieldIndex [in]
//      pfValue      [out]  the returned value.
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
HRESULT HrSetupGetStringFieldAsBool (const INFCONTEXT& ctx,
                                     DWORD dwFieldIndex,
                                     BOOL* pfValue)
{
    Assert (pfValue);

    // Initialize the output parameter.
    *pfValue = FALSE;

    static const MAP_SZ_DWORD aMapYesNo [] =
    {
        { c_szYes, TRUE  },
        { c_szNo,  FALSE },
    };
    DWORD dwValue;
    HRESULT hr = HrSetupGetStringFieldMapToDword (ctx, dwFieldIndex,
                                                  aMapYesNo, celems(aMapYesNo),
                                                  &dwValue);
    if (SUCCEEDED(hr))
    {
        *pfValue = !!dwValue;
    }
    TraceError ("HrSetupGetStringFieldAsBool", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetFirstDword
//
//  Purpose:    Get a DWORD value from a section in the INF file.
//
//  Arguments:
//      hinf       [in]     handle to an open INF file.
//      pszSection [in]     specifies the section that contains the value.
//      pszKey     [in]     specifies the key that contains the value.
//      pdwValue   [out]    the returned value.
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   17 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupGetFirstDword (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN PCWSTR pszKey,
    OUT DWORD* pdwValue)
{
    Assert (pszSection);
    Assert (pszKey);

    // Initialize the output parameter.
    *pdwValue = 0;

    INFCONTEXT ctx;
    HRESULT hr = HrSetupFindFirstLine (hinf, pszSection, pszKey, &ctx);
    if (S_OK == hr)
    {
        INT nValue;
        hr = HrSetupGetIntField (ctx, c_dwFirstField, &nValue);
        if (S_OK == hr)
        {
            *pdwValue = nValue;
        }
    }
    TraceErrorOptional ("HrSetupGetFirstDword", hr,
                        (SPAPI_E_LINE_NOT_FOUND == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetFirstString
//
//  Purpose:    Get a string value from a section in the INF file.
//
//  Arguments:
//      hinf       [in]     handle to an open INF file.
//      pszSection [in]     specifies the section that contains the value.
//      pszKey     [in]     specifies the key that contains the value.
//      pdwValue   [out]    the returned value.
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   17 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupGetFirstString (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN PCWSTR pszKey,
    OUT tstring* pstr)
{
    Assert (pszSection);
    Assert (pszKey);

    INFCONTEXT ctx;
    HRESULT hr = HrSetupFindFirstLine (hinf, pszSection, pszKey, &ctx);
    if (S_OK == hr)
    {
        hr = HrSetupGetStringField (ctx, c_dwFirstField, pstr);
    }
    // If we failed for any reason, initialize the output parameter.
    //
    if (FAILED(hr))
    {
        pstr->erase ();
    }
    TraceErrorOptional ("HrSetupGetFirstString", hr,
                        (SPAPI_E_SECTION_NOT_FOUND == hr) ||
                        (SPAPI_E_LINE_NOT_FOUND    == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetFirstMultiSzFieldWithAlloc
//
//  Purpose:    Retrieves the first occurrance of the given key in the given
//              section of an INF file, allocates memory for it, and returns
//              it in the parameter pszOut.
//
//  Arguments:
//      hinf       [in]     handle to an open INF file.
//      pszSection [in]     specifies the section that contains the value.
//      pszKey     [in]     specifies the key that contains the value.
//      pszOut     [out]    Returns multi-sz field.
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     danielwe   7 May 1997
//
//  Notes:      Free the resulting string with MemFree.
//
HRESULT
HrSetupGetFirstMultiSzFieldWithAlloc (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN PCWSTR pszKey,
    OUT PWSTR* ppszOut)
{
    Assert(pszSection);
    Assert(pszKey);
    Assert(ppszOut);

    // Initialize the output parameter.
    *ppszOut = 0;

    INFCONTEXT ctx;
    HRESULT hr = HrSetupFindFirstLine (hinf, pszSection, pszKey, &ctx);
    if (S_OK == hr)
    {
        hr = HrSetupGetMultiSzFieldWithAlloc(ctx, c_dwFirstField, ppszOut);
    }

    TraceErrorOptional("HrSetupGetFirstMultiSzFieldWithAlloc", hr,
                       (SPAPI_E_LINE_NOT_FOUND == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetFirstMultiSzMapToDword
//
//  Purpose:    Get a DWORD value from a section in the INF file.
//              The value is represented in the INF file as a multi-sz, but
//              it is mapped to a DWORD value based on a caller-specified
//              mapping.  The string values in the map are compared using
//              a case insensitive compare.
//
//              Use this when the INF value can be one or more of a fixed
//              set of values represented as strings.
//
//  Example:    [MySection]             with a map of:
//              MyKey = Ip,Nbf            { "Ip",   0x01 }
//                                        { "Ipx",  0x02 }
//                                        { "Nbf",  0x04 }
//
//                  yields *pdwValue returned as 0x01 | 0x04 = 0x05.
//
//  Arguments:
//      hinf         [in]   handle to an open INF file.
//      pszSection   [in]   specifies the section that contains the value.
//      pszKey       [in]   specifies the key that contains the value.
//      aMapSzDword  [in]   array of elements mapping a string to a DWORD.
//      cMapSzDword  [in]   count of elements in the array.
//      pdwValue     [out]  the returned value.
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   17 Apr 1997
//
//  Notes:      HrOpen must have been called before this call.
//
HRESULT
HrSetupGetFirstMultiSzMapToDword (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN PCWSTR pszKey,
    IN const MAP_SZ_DWORD* aMapSzDword,
    IN UINT cMapSzDword,
    OUT DWORD* pdwValue)
{
    Assert (pszSection);
    Assert (pszKey);

    // Initialize the output parameter.
    *pdwValue = 0;

    INFCONTEXT ctx;
    HRESULT hr = HrSetupFindFirstLine (hinf, pszSection, pszKey, &ctx);
    if (S_OK == hr)
    {
        hr = HrSetupGetMultiSzFieldMapToDword (ctx, c_dwFirstField,
                                               aMapSzDword, cMapSzDword,
                                               pdwValue);
    }
    TraceErrorOptional ("HrSetupGetFirstMultiSzMapToDword", hr,
                        (SPAPI_E_LINE_NOT_FOUND == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrSetupGetFirstStringMapToDword
//
//  Purpose:    Get a DWORD value from a section in the INF file.
//              The value is represented in the INF file as a string, but
//              it is mapped to a DWORD value based on a caller-specified
//              mapping.  The string values in the map are compared using
//              a case insensitive compare.
//
//              Use this when the INF value can be one of a fixed set of
//              values represented as strings.
//
//  Example:    [MySection]             with a map of:
//              MyKey = ThisComputer      { "Network",      1 }
//                                        { "ThisComputer", 2 }
//
//                  yields *pdwValue returned as 2.
//
//  Arguments:
//      hinf         [in]   handle to an open INF file.
//      pszSection   [in]   specifies the section that contains the value.
//      pszKey       [in]   specifies the key that contains the value.
//      aMapSzDword  [in]   array of elements mapping a string to a DWORD.
//      cMapSzDword  [in]   count of elements in the array.
//      pdwValue     [out]  the returned value.
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   17 Apr 1997
//
//  Notes:      HrOpen must have been called before this call.
//
HRESULT
HrSetupGetFirstStringMapToDword (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN PCWSTR pszKey,
    IN const MAP_SZ_DWORD* aMapSzDword,
    IN UINT cMapSzDword,
    OUT DWORD* pdwValue)
{
    Assert (pszSection);
    Assert (pszKey);

    // Initialize the output parameter.
    *pdwValue = 0;

    INFCONTEXT ctx;
    HRESULT hr = HrSetupFindFirstLine (hinf, pszSection, pszKey, &ctx);
    if (S_OK == hr)
    {
        hr = HrSetupGetStringFieldMapToDword (ctx, c_dwFirstField,
                                              aMapSzDword, cMapSzDword,
                                              pdwValue);
    }
    TraceErrorOptional ("HrSetupGetFirstStringMapToDword", hr,
                        (SPAPI_E_LINE_NOT_FOUND == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetFirstStringAsBool
//
//  Purpose:    Get a boolean value from a section in the INF file.
//              The boolean value is represented in the INF file as
//              "Yes" or "No" (case insensitive) but the value is returned
//              as a BOOL type.
//
//  Example:    [MySection]
//              MyKey = yes
//
//                  yields *pfValue returned as TRUE.
//
//  Arguments:
//      hinf       [in]     handle to an open INF file.
//      pszSection [in]     specifies the section that contains the value.
//      pszKey     [in]     specifies the key that contains the value.
//      pdwValue   [out]    the returned value.
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     shaunco   17 Apr 1997
//
//  Notes:
//
HRESULT
HrSetupGetFirstStringAsBool (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN PCWSTR pszKey,
    OUT BOOL* pfValue)
{
    Assert (hinf);
    Assert (pszSection);
    Assert (pszKey);
    Assert (pfValue);

    // Initialize the output parameter.
    *pfValue = FALSE;

    INFCONTEXT ctx;
    HRESULT hr = HrSetupFindFirstLine (hinf, pszSection, pszKey, &ctx);
    if (S_OK == hr)
    {
        hr = HrSetupGetStringFieldAsBool (ctx, c_dwFirstField, pfValue);
    }
    TraceErrorOptional ("HrSetupGetFirstStringAsBool", hr,
                        (SPAPI_E_LINE_NOT_FOUND == hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetInfInformation
//
//  Purpose:    Returns the SP_INF_INFORMATION structure for the specified
//              INF file to a caller-supplied buffer.
//
//  Arguments:
//      pvInfSpec       [in] See SetupApi documentation for more info
//      dwSearchControl [in]
//      ppinfInfo       [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     BillBe   18 Jan 1998
//
//  Notes:
//
HRESULT
HrSetupGetInfInformation (
    IN LPCVOID pvInfSpec,
    IN DWORD dwSearchControl,
    OUT PSP_INF_INFORMATION* ppinfInfo)
{
    DWORD dwSize;
    BOOL  fSuccess;

    *ppinfInfo = NULL;

    if (fSuccess = SetupGetInfInformation (pvInfSpec, dwSearchControl,
            NULL, 0, &dwSize))
    {
        *ppinfInfo = (PSP_INF_INFORMATION)MemAlloc (dwSize);
        fSuccess = SetupGetInfInformation (pvInfSpec, dwSearchControl,
                *ppinfInfo, dwSize, 0);
    }

    HRESULT hr = S_OK;
    if (!fSuccess)
    {
        hr = HrFromLastWin32Error();
        MemFree (*ppinfInfo);
        *ppinfInfo = NULL;
    }

    TraceError("HrSetupGetInfInformation", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupIsValidNt5Inf
//
//  Purpose:    Determines if an inf file is a valid NT5 inf by examining
//              its signature.
//
//  Arguments:
//      hinf [in] Handle to the inf file
//
//  Returns:    S_OK if valid, SPAPI_E_WRONG_INF_STYLE if invalid,
//              or a Win32 error code.
//
//  Author:     BillBe   18 Jan 1998
//
//  Notes:  $WINDOWS 95$ is invalid and $CHICAGO$ is
//              only valid if it has the required Compatible inf key in
//              the version info.
//
HRESULT
HrSetupIsValidNt5Inf (
    IN HINF hinf)
{
    static const WCHAR c_szSignature[] = INFSTR_KEY_SIGNATURE;
    static const WCHAR c_szCompatible[] = L"Compatible";
    static const WCHAR c_szChicagoSig[] = L"$Chicago$";
    static const WCHAR c_szWinntSig[] = L"$Windows NT$";
    static const WCHAR c_szCompatibleValue[] = L"1";

    PSP_INF_INFORMATION pinfInfo;

    // Get the inf's version info
    HRESULT hr = HrSetupGetInfInformation (hinf, INFINFO_INF_SPEC_IS_HINF,
            &pinfInfo);

    if (S_OK == hr)
    {
        PWSTR pszSignature;

        // Get the signature info
        hr = HrSetupQueryInfVersionInformation (pinfInfo, 0,
                c_szSignature, &pszSignature);

        if (S_OK == hr)
        {

            // if the inf signature is not windows nt...
            if (0 != lstrcmpiW (pszSignature, c_szWinntSig))
            {
                // if it isn't Chicago, then we don't support it
                if (0 != lstrcmpiW (pszSignature, c_szChicagoSig))
                {
                    hr = SPAPI_E_WRONG_INF_STYLE;
                }
                else
                {
                    // The signature is Chicago so now we check if
                    // the compatible line exists.
                    //
                    PWSTR pszCompatible;
                    hr = HrSetupQueryInfVersionInformation (pinfInfo, 0,
                            c_szCompatible, &pszCompatible);

                    if (S_OK == hr)
                    {
                        // We found the compatible line, now make sure
                        // it is set to c_szCompatibleValue.
                        //
                        if (0 != lstrcmpiW (pszCompatible, c_szCompatibleValue))
                        {
                            hr = SPAPI_E_WRONG_INF_STYLE;
                        }

                        MemFree (pszCompatible);
                    }
                    else if (HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr)
                    {
                        // The Compatible key didn't exist so this is
                        // considered a windows 95 net inf
                        hr = SPAPI_E_WRONG_INF_STYLE;
                    }
                }
            }
            MemFree (pszSignature);
        }
        MemFree (pinfInfo);
    }

    TraceError("HrSetupIsValidNt5Inf",
            (SPAPI_E_WRONG_INF_STYLE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupQueryInfVersionInformation
//
//  Purpose:    Returns INF file version information from an
//              SP_INF_INFORMATION structure to a caller-supplied buffer.
//
//
//
//  Arguments:
//      pinfInfo   [in] See SetupApi documentation for more info
//      uiIndex    [in]
//      szKey      [in]
//      ppszInfo   [out]
//
//  Returns:    S_OK or a Win32 error code.
//
//  Author:     BillBe   18 Jan 1998
//
//  Notes:
//
HRESULT
HrSetupQueryInfVersionInformation (
    IN  PSP_INF_INFORMATION pinfInfo,
    IN UINT uiIndex,
    IN PCWSTR pszKey,
    OUT PWSTR* ppszInfo)
{
    Assert(pinfInfo);

    *ppszInfo = NULL;

    DWORD dwSize;
    BOOL fSuccess = SetupQueryInfVersionInformation (pinfInfo, uiIndex,
            pszKey, NULL, 0, &dwSize);

    if (fSuccess)
    {
        *ppszInfo = (PWSTR)MemAlloc (dwSize * sizeof (WCHAR));
        fSuccess = SetupQueryInfVersionInformation (pinfInfo, uiIndex, pszKey,
                *ppszInfo, dwSize, NULL);
    }

    HRESULT hr = S_OK;
    if (!fSuccess)
    {
        MemFree (*ppszInfo);
        *ppszInfo = NULL;
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupQueryInfVersionInformation", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSetupInfFile::Close
//
//  Purpose:    Close the INF file.  It must have previously opened with
//              a call to HrOpen().
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
void CSetupInfFile::Close ()
{
    AssertSz (m_hinf, "You shouldn't be closing a file that is already closed.");
    ::SetupCloseInfFile (m_hinf);
    m_hinf = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSetupInfFile::EnsureClosed
//
//  Purpose:    Ensure the INF file represented by this object is closed.
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   16 Apr 1997
//
//  Notes:
//
void CSetupInfFile::EnsureClosed()
{
    if (m_hinf)
    {
        Close ();
    }
}



//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiCallClassInstaller
//
//  Purpose:    calls the appropriate class installer with the specified
//                  installation request (DI_FUNCTION).
//
//  Arguments:
//      dif     [in]   See SetupApi for more info
//      hdi     [in]   See SetupApi for more info
//      pdeid   [in]   See SetupApi for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   25 June 1997
//
//  Notes:  SPAPI_E_DI_DO_DEFAULT is mapped to S_OK
//
HRESULT
HrSetupDiCallClassInstaller(
    IN DI_FUNCTION dif,
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid)
{
    Assert(INVALID_HANDLE_VALUE != hdi);
    Assert(hdi);

    HRESULT hr = S_OK;

    // Call the class installer and convert any errors
    if (!SetupDiCallClassInstaller(dif, hdi, pdeid))
    {
        hr = HrFromLastWin32Error();
        if (SPAPI_E_DI_DO_DEFAULT == hr)
        {
            hr = S_OK;
        }
    }

    TraceError("HrSetupDiCallClassInstaller",
               (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr) ? S_OK : hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupCopyOEMInf
//
//  Purpose:    HRESULT wrapper for SetupCopyOEMInf that returns the
//                  new file path and name as tstrings
//
//  Arguments:
//      szSourceName              [in]  See SetupApi for more info
//      szSourceMediaLocation     [in]
//      dwSourceMediaType         [in]
//      dwCopyStyle               [in]
//      pstrDestFilename          [out]
//      pstrDestFilenameComponent [out]
//
//  Returns:    HRESULT. S_OK if successful, or Win32 converted error code
//
//  Author:     billbe   15 May 1997
//
//  Notes: See SetupCopyOEMInf in SetupApi for more info
//
HRESULT
HrSetupCopyOemInf(
    IN const tstring& strSourceName,
    IN const tstring& strSourceMediaLocation, OPTIONAL
    IN DWORD dwSourceMediaType,
    IN DWORD dwCopyStyle,
    OUT tstring* pstrDestFilename, OPTIONAL
    OUT tstring* pstrDestFilenameComponent OPTIONAL)
{
    Assert(!strSourceName.empty());

    BOOL        fWin32Success = TRUE;
    DWORD       cchRequiredSize;

    // Copy the file and get the size for the new filename in case it is
    // needed
    if (fWin32Success = SetupCopyOEMInf(strSourceName.c_str(),
            strSourceMediaLocation.c_str(), dwSourceMediaType, dwCopyStyle,
            NULL, NULL, &cchRequiredSize, NULL))
    {
        // If any of the out parameters are specified, we need to get the
        // information
        if (pstrDestFilename || pstrDestFilenameComponent)
        {
            PWSTR      pszDestPath = NULL;
            PWSTR      pszDestFilename = NULL;
            // now we allocate space to get the destination file path.
            // We allocate on the stack for automatic clean-up
            // Note: dwRequiredSize includes the terminating NULL
            //
            pszDestPath = (PWSTR)_alloca(cchRequiredSize * sizeof(WCHAR));

            // Get the new file path and filename
            if (fWin32Success = SetupCopyOEMInf(strSourceName.c_str(),
                    strSourceMediaLocation.c_str(), dwSourceMediaType,
                    dwCopyStyle, pszDestPath, cchRequiredSize, NULL,
                    &pszDestFilename))
            {
                // if the file path is needed, assign it
                if (pstrDestFilename)
                {
                    *pstrDestFilename = pszDestPath;
                }

                // If the user wants just the filename, assign it to the
                // string
                if (pstrDestFilenameComponent)
                {
                    *pstrDestFilenameComponent = pszDestFilename;
                }
            }
            else
            {
                // initialize out params on failure
                //
                if (pstrDestFilename)
                {
                    pstrDestFilename->erase();
                }

                if (pstrDestFilenameComponent)
                {
                    pstrDestFilenameComponent->erase();
                }
            }
        }

    }

    HRESULT hr = S_OK;
    if (!fWin32Success)
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupCopyOEMInf", hr);
    return hr;

}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupCopyOEMInf
//
//  Purpose:    HRESULT wrapper for SetupCopyOEMInf that returns the
//                  new file path and name as tstrings
//
//  Arguments:
//      pszSourceName             [in]  See SetupApi for more info
//      pszSourceMediaLocation    [in]
//      dwSourceMediaType         [in]
//      dwCopyStyle               [in]
//      pszDestFilename           [out] // must be at least _MAX_PATH chars.
//      ppszDestFilenameComponent [out]
//
//  Returns:    HRESULT. S_OK if successful, or Win32 converted error code
//
//  Author:     billbe   15 May 1997
//
//  Notes: See SetupCopyOEMInf in SetupApi for more info
//
HRESULT
HrSetupCopyOemInfBuffer(
    IN PCWSTR pszSourceName,
    IN PCWSTR pszSourceMediaLocation, OPTIONAL
    IN DWORD SourceMediaType,
    IN DWORD CopyStyle,
    OUT PWSTR pszDestFilename,
    IN DWORD cchDestFilename,
    OUT PWSTR* ppszDestFilenameComponent OPTIONAL)
{
    Assert(pszSourceName);
    Assert(pszDestFilename);

    BOOL        fWin32Success = TRUE;

    if (!(fWin32Success = SetupCopyOEMInf(pszSourceName,
            pszSourceMediaLocation, SourceMediaType,
            CopyStyle, pszDestFilename, cchDestFilename, NULL,
            ppszDestFilenameComponent)))
    {
        // initialize out params on failure
        //
        *pszDestFilename = 0;
        if (*ppszDestFilenameComponent)
        {
            *ppszDestFilenameComponent = NULL;
        }
    }

    HRESULT hr = S_OK;
    if (!fWin32Success)
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrSetupCopyOEMInf");
    return hr;

}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiBuildDriverInfoList
//
//  Purpose:    builds a list of drivers associated with a specified device
//                  instance or with the device information set's global
//                  class driver list.
//
//  Arguments:
//      hdi             [in]        See SetupApi for more info
//      pdeid           [in, out]
//      dwDriverType    [in]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiBuildDriverInfoList(IN HDEVINFO hdi, IN OUT PSP_DEVINFO_DATA pdeid,
                             IN DWORD dwDriverType)
{
    Assert(IsValidHandle(hdi));

    HRESULT hr = S_OK;

    // Build the list
    if (!SetupDiBuildDriverInfoList(hdi, pdeid, dwDriverType))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiBuildDriverInfoList", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiCreateDeviceInfo
//
//  Purpose:    creates a new device information element and adds it as a
//                  new member to the specified device information set.
//
//  Arguments:
//      hdi             [in]   See SetupApi for more info
//      pszDeviceName   [in]   See SetupApi for more info
//      guidClass       [in]   See SetupApi for more info
//      pszDesc         [in]   See SetupApi for more info
//      hwndParent      [in]   See SetupApi for more info
//      dwFlags         [in]   See SetupApi for more info
//      pdeid           [out]  See SetupApi for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:  pdeid is initialized and its cbSize field set by this fcn
//
HRESULT
HrSetupDiCreateDeviceInfo(
    IN HDEVINFO hdi,
    IN PCWSTR pszDeviceName,
    IN const GUID& guidClass,
    IN PCWSTR pszDesc, OPTIONAL
    IN HWND hwndParent, OPTIONAL
    IN DWORD dwFlags,
    OUT PSP_DEVINFO_DATA pdeid OPTIONAL)
{
    Assert(IsValidHandle(hdi));
    Assert(pszDeviceName);

    if (pdeid)
    {
        ZeroMemory(pdeid, sizeof(SP_DEVINFO_DATA));
        pdeid->cbSize = sizeof(SP_DEVINFO_DATA);
    }

    HRESULT hr = S_OK;

    // Create the device info node
    if (!SetupDiCreateDeviceInfo (hdi, pszDeviceName, &guidClass, pszDesc,
            hwndParent, dwFlags, pdeid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError ("HrSetupDiCreateDeviceInfo", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiEnumDeviceInfo
//
//  Purpose:    Enumerates the members of the specified device information
//                   set.
//
//  Arguments:
//      hdi          [in]   See SetupApi for more info
//      dwIndex      [in]   See SetupApi for more info
//      pdeid        [in]   See SetupApi for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   13 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiEnumDeviceInfo(
    IN HDEVINFO hdi,
    IN DWORD dwIndex,
    OUT PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    HRESULT hr;

    ZeroMemory(pdeid, sizeof(SP_DEVINFO_DATA));
    pdeid->cbSize = sizeof(SP_DEVINFO_DATA);

    if (SetupDiEnumDeviceInfo (hdi, dwIndex, pdeid))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    TraceErrorOptional("HrSetupDiEnumDeviceInfo", hr,
            HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiEnumDriverInfo
//
//  Purpose:    Enumerates the members of a driver information list.
//
//  Arguments:
//      hdi          [in]   See SetupApi for more info
//      pdeid        [in]
//      dwDriverType [in]
//      dwIndex      [in]
//      pdrid        [out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiEnumDriverInfo(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwDriverType,
    IN DWORD dwIndex,
    OUT PSP_DRVINFO_DATA pdrid)
{

    Assert(IsValidHandle(hdi));
    Assert(pdrid);

    HRESULT hr = S_OK;

    // initialize the out param
    ZeroMemory(pdrid, sizeof(SP_DRVINFO_DATA));
    pdrid->cbSize = sizeof(SP_DRVINFO_DATA);

    // call the enum fcn
    if (!SetupDiEnumDriverInfo(hdi, pdeid, dwDriverType, dwIndex, pdrid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceErrorOptional("HrSetupDiEnumDriverInfo", hr,
            HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr);

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiSelectBestCompatDrv
//
//  Purpose:    Finds and selects the best driver for the current device.
//
//  Arguments:
//      hdi          [in]   See SetupApi for more info
//      pdeid        [in][out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//

HRESULT
HrSetupDiSelectBestCompatDrv(
    IN     HDEVINFO         hdi,
    IN OUT PSP_DEVINFO_DATA pdeid)
{

    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    HRESULT hr = S_OK;

    // call the SelectBestCompatDrv fcn
    if (!SetupDiSelectBestCompatDrv(hdi, pdeid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceErrorOptional("HrSetupDiSelectBestCompatDrv", hr,
            HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr);

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetDeviceInfoListClass
//
//  Purpose:    Retrieves the class GUID associated with a device
//                  information set if it has an associated class.
//
//  Arguments:
//      hdi   [in]  See SetupApi for more info
//      pguid [out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiGetDeviceInfoListClass (
    IN HDEVINFO hdi,
    OUT GUID* pguid)
{
    Assert(IsValidHandle(hdi));
    Assert(pguid);

    HRESULT hr = S_OK;

    // Get the guid for the HDEVINFO
    if (!SetupDiGetDeviceInfoListClass (hdi, pguid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetDeviceInfoListClass", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetClassDevs
//
//  Purpose:    Returns a device information set that contains all installed
//              devices of a specified class.
//
//  Arguments:
//      pguidClass    [in]   See SetupApi for more info
//      pszEnumerator [in]   See SetupApi for more info
//      hwndParent    [in]   See SetupApi for more info
//      dwFlags       [in]   See SetupApi for more info
//      phdi          [out]  See SetupApi for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   13 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiGetClassDevs (
    IN const GUID* pguidClass, OPTIONAL
    IN PCWSTR pszEnumerator, OPTIONAL
    IN HWND hwndParent, OPTIONAL
    IN DWORD dwFlags,
    OUT HDEVINFO* phdi)
{
    Assert(phdi);

    HRESULT hr;

    HDEVINFO hdi = SetupDiGetClassDevsW (pguidClass, pszEnumerator,
            hwndParent, dwFlags);

    if (INVALID_HANDLE_VALUE != hdi)
    {
        hr = S_OK;
        *phdi = hdi;
    }
    else
    {
        hr = HrFromLastWin32Error();
        *phdi = NULL;
    }

    TraceError ("HrSetupDiGetClassDevs", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetDeviceInstanceId
//
//  Purpose:    HRESULT wrapper for SetupDiGetDeviceInstanceId.
//
//  Arguments:
//      hdi          [in]  See SetupApi for more info.
//      pdeid        [in]  See SetupApi for more info.
//      pszId        [out] The device instance Id for the net card.
//      cchId        [in]  The size of pszId in characters.
//      pcchRequired [out] Optional. The required buffer size in characters.
//
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise.
//
//  Author:     billbe   26 Mar 1997
//
//  Notes: See SetupDiGetDeviceInstanceId in Device Installer for more info.
//
HRESULT
HrSetupDiGetDeviceInstanceId(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    OUT PWSTR pszId,
    IN DWORD cchId,
    OUT OPTIONAL DWORD* pcchRequired)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    DWORD   cchRequiredSize;
    BOOL    fSuccess = TRUE;
    HRESULT hr = S_OK;

    // Get the buffer length required for the instance Id.
    if (!(fSuccess = SetupDiGetDeviceInstanceIdW(hdi, pdeid, NULL, 0,
            &cchRequiredSize)))
    {
        // If all went well, we should have a buffer error.
        if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
        {
            // Since ERROR_INSUFFICIENT_BUFFER is really a success
            // for us, we will reset the success flag.
            fSuccess = TRUE;

            // Set the out param if it was specified.
            if (pcchRequired)
            {
                *pcchRequired = cchRequiredSize;
            }

            // If the buffer sent in was large enough, go ahead and use it.
            if (cchId >= cchRequiredSize)
            {
                fSuccess = SetupDiGetDeviceInstanceIdW(hdi, pdeid,
                        pszId, cchId, NULL);
            }
        }
    }
#ifdef DBG  // Just being safe
    else
    {
        // This should never happen since we sent in no buffer
        AssertSz(FALSE, "SetupDiGetDeviceInstanceId returned success"
                " even though it was given no buffer");
    }
#endif // DBG

    // We used SetupApi so we need to convert any errors
    if (!fSuccess)
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetDeviceInstanceId", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiInstallDevice
//
//  Purpose:    Wrapper for SetupDiInstallDevice
//
//  Arguments:
//      hdi                     [in] See SetupApi for more info
//      pdeid                   [in]
//
//  Returns:    HRESULT. S_OK if successful, Win32 error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiInstallDevice (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    HRESULT hr = S_OK;

    // Let SetupApi install the specfied device
    if (!SetupDiInstallDevice (hdi, pdeid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiInstallDevice", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiOpenDevRegKey
//
//  Purpose: Return an HKEY to the hardware device's driver instance key
//
//  Arguments:
//      hdi                     [in] See SetupApi for more info
//      pdeid                   [in]
//      dwScope                 [in]
//      dwHwProfile             [in]
//      dwKeyType               [in]
//      samDesired              [in]
//      phkey                   [out]
//
//
//  Returns:    HRESULT. S_OK if successful, Win32 error code otherwise
//
//  Author:     billbe   7 May 1997
//
//  Notes:
//
HRESULT
HrSetupDiOpenDevRegKey (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwScope,
    IN DWORD dwHwProfile,
    IN DWORD dwKeyType,
    IN REGSAM samDesired,
    OUT HKEY* phkey)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);
    Assert(phkey);

    // Try to open the registry key
    //

    HRESULT hr;

    HKEY hkey = SetupDiOpenDevRegKey(hdi, pdeid, dwScope, dwHwProfile,
            dwKeyType, samDesired);

    if (INVALID_HANDLE_VALUE != hkey)
    {
        hr = S_OK;
        *phkey = hkey;
    }
    else
    {
        hr = HrFromLastWin32Error();
        *phkey = NULL;
    }

    TraceErrorOptional("HrSetupDiOpenDevRegKey", hr,
            (SPAPI_E_DEVINFO_NOT_REGISTERED == hr) ||
            (SPAPI_E_KEY_DOES_NOT_EXIST == hr));

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiSetClassInstallParams
//
//  Purpose:    sets or clears class install parameters for a device
//                  information set or a particular device information element.
//
//  Arguments:
//      hdi    [in] See Device Installer API for more info
//      pdeid  [in]
//      pcih   [in]
//      cbSize [in]
//
//
//  Returns:    HRESULT. S_OK if successful, Win32 error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiSetClassInstallParams (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid, OPTIONAL
    IN PSP_CLASSINSTALL_HEADER pcih, OPTIONAL
    IN DWORD cbSize)
{
    Assert(IsValidHandle(hdi));

    HRESULT hr = S_OK;

    // Set or clear the params
    if (!SetupDiSetClassInstallParams(hdi, pdeid, pcih, cbSize))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiSetClassInstallParams", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetFixedSizeClassInstallParams
//
//  Purpose:    Gets a fixed size of an info list's ot device's class install
//                  parameters for a device.
//
//  Arguments:
//      hdi    [in] See Device Installer for more info
//      pdeid  [in]
//      pcih   [in]
//      cbSize [in]
//
//
//  Returns:    HRESULT. S_OK if successful, Win32 error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiGetFixedSizeClassInstallParams (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN PSP_CLASSINSTALL_HEADER pcih,
    IN INT cbSize)
{
    Assert(IsValidHandle(hdi));
    Assert(pcih);

    HRESULT hr = S_OK;

    ZeroMemory(pcih, cbSize);
    pcih->cbSize = sizeof(SP_CLASSINSTALL_HEADER);

    // Device Installer Api uses an all purpose GetClassInstallParams
    // function. Several structures contain an SP_CLASSINSTALL_HEADER
    // as their first member.
    if (!SetupDiGetClassInstallParams(hdi, pdeid, pcih, cbSize, NULL))
    {
        hr = HrFromLastWin32Error();
    }

    TraceErrorOptional("HrSetupDiGetFixedSizeClassInstallParams", hr,
            SPAPI_E_NO_CLASSINSTALL_PARAMS == hr);

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetSelectedDriver
//
//  Purpose:    Retrieves the member of a driver list that has been selected
//                  as the controlling driver.
//
//  Arguments:
//      hdi                     [in] See SetupApi for more info
//      pdeid                   [in]
//      pdrid                   [out]
//
//
//  Returns:    HRESULT. S_OK if successful, Win32 error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiGetSelectedDriver (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    OUT PSP_DRVINFO_DATA pdrid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdrid);

    // initialize and set the cbSize field
    ZeroMemory(pdrid, sizeof(*pdrid));
    pdrid->cbSize = sizeof(*pdrid);

    HRESULT hr = S_OK;

    // Set pdrid as the selected driver
    if (!SetupDiGetSelectedDriver(hdi, pdeid, pdrid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetSelectedDriver",
        (SPAPI_E_NO_DRIVER_SELECTED == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetDriverInfoDetail
//
//  Purpose:    Gets details on the driver referenced by the given parameters.
//
//  Arguments:
//      hdi     []
//      pdeid   [] See SetupAPI for more info
//      pdrid   []
//      ppdridd []
//
//  Returns:    HRESULT. S_OK if successful, Win32 error code otherwise
//
//  Author:     danielwe   5 May 1998
//
//  Notes:
//
HRESULT
HrSetupDiGetDriverInfoDetail (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN PSP_DRVINFO_DATA pdrid,
    OUT PSP_DRVINFO_DETAIL_DATA* ppdridd)
{
    HRESULT     hr = S_OK;
    BOOL        fSuccess = TRUE;
    DWORD       dwRequiredSize = 0;

    Assert(IsValidHandle(hdi));
    Assert(pdrid);
    Assert(ppdridd);
    Assert(pdrid);

    *ppdridd = NULL;

    // Get the size needed for the driver detail
    if (!(fSuccess = SetupDiGetDriverInfoDetailW (hdi, pdeid, pdrid, NULL,
            0, &dwRequiredSize)))
    {
        // We should have received an insufficient buffer error since we
        // sent no buffer
        if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
        {
            // Since this is ERROR_INSUFFICIENT_BUFFER is really a
            // success for us, we will reset the success flag.
            fSuccess = TRUE;

            // Now we allocate our buffer for the driver detail data
            // The size of the buffer is variable but it is a
            // PSP_DEVINFO_DETAIL_DATA.
            *ppdridd = (PSP_DRVINFO_DETAIL_DATA)MemAlloc (dwRequiredSize);

            if (*ppdridd)
            {
                //initialize the variable
                ZeroMemory(*ppdridd, dwRequiredSize);
                (*ppdridd)->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

                // Get detailed info
                fSuccess = SetupDiGetDriverInfoDetailW (hdi, pdeid, pdrid,
                        *ppdridd, dwRequiredSize, NULL);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        // This should NEVER happen
        AssertSz(FALSE, "HrSetupDiGetDriverInfoDetail succeeded with no "
                 "buffer!");
    }

    // We have been using Device Installer Api so convert any errors
    if (!fSuccess)
    {
        hr = HrFromLastWin32Error();
    }

    // clean up on failure
    if (FAILED(hr))
    {
        MemFree (*ppdridd);
        *ppdridd = NULL;
    }

    TraceError("HrSetupDiGetDriverInfoDetail", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiSetSelectedDriver
//
//  Purpose:    Sets the specified member of a driver list as the
//                  currently-selected driver. It can also be used to reset
//                  the driver list so that there is no currently-selected
//                  driver.
//
//  Arguments:
//      hdi                     [in] See SetupApi for more info
//      pdeid                   [in]
//      pdrid                   [in, out]
//
//
//  Returns:    HRESULT. S_OK if successful, Win32 error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiSetSelectedDriver (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN OUT PSP_DRVINFO_DATA pdrid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdrid);

    HRESULT hr = S_OK;

    // Set pdrid as the selected driver
    if (!SetupDiSetSelectedDriver(hdi, pdeid, pdrid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiSetSelectedDriver", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiCreateDevRegKey
//
//  Purpose: Creates and returns an HKEY to the hardware device's driver
//              instance key
//
//  Arguments:
//      hdi                     [in] See SetupApi for more info
//      pdeid                   [in]
//      dwScope                 [in]
//      dwHwProfile             [in]
//      dwKeyType               [in]
//      hinf                    [in] OPTIONAL
//      pszInfSectionName       [in] OPTIONAL
//      phkey                   [out]
//
//
//  Returns:    HRESULT. S_OK if successful, Win32 error code otherwise
//
//  Author:     billbe   4 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiCreateDevRegKey (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwScope,
    IN DWORD dwHwProfile,
    IN DWORD dwKeyType,
    IN HINF hinf,
    PCWSTR pszInfSectionName,
    OUT HKEY* phkey)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);
    Assert(phkey);

    // Try to create the registry key and process the inf section, if
    // specified
    //

    HRESULT hr;

    HKEY hkey = SetupDiCreateDevRegKeyW(hdi, pdeid, dwScope, dwHwProfile,
            dwKeyType, hinf, pszInfSectionName);

    if (INVALID_HANDLE_VALUE != hkey)
    {
        hr = S_OK;
        *phkey = hkey;
    }
    else
    {
        hr = HrFromLastWin32Error();
        *phkey = NULL;
    }

    TraceError("HrSetupDiCreateDevRegKey", hr);

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetActualSectionToInstall
//
//  Purpose: The sections in an inf file may have OS and platform suffixes
//              appended to them.  This function searches for a section that
//              has pszSectionName as its base and has a certain suffix.
//              For example on an x86 NT machine, given a section name of
//              INSTALL, the search would start with INSTALL.NTx86, if that
//              is not found, then INSTALL.NT is searched for.
//              If that is not found INSTALL is returned.
//
//  Arguments:
//      hinf                  [in] SetupApi inf file handle
//      pszSectionName        [in] the section name to base the search on
//      pstrActualSectionName [out] The actual section name with extension
//      pstrExtension         [out] OPTIONAL. The extension part of the
//                                      pstrActualSectionName.
//                                      This includes "."
//
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   27 Mar 1997
//
//  Notes: See SetupDiGetActualSectionToInstall in SetupApi documention
//              for more info
//
HRESULT
HrSetupDiGetActualSectionToInstall(
    IN HINF hinf,
    IN PCWSTR pszSectionName,
    OUT tstring* pstrActualSectionName,
    OUT tstring* pstrExtension OPTIONAL)
{
    Assert(IsValidHandle(hinf));
    Assert(pszSectionName);
    Assert(pstrActualSectionName);

    // strSectionName might need to be decorated with OS
    // and Platform specific suffixes.  The next call will return the actual
    // decorated section name or our current section name if the decorated
    // one does not exist.
    //

    BOOL    fSuccess = TRUE;
    DWORD   cchRequiredSize;

    // Get the buffer length required
    if (fSuccess = SetupDiGetActualSectionToInstallW(hinf,
            pszSectionName, NULL, 0, &cchRequiredSize, NULL))
    {
        // now we allocate space to get the actual section name
        // we allocate on the stack for automatic clean-up
        // Note: dwRequiredSize includes the terminating NULL
        //
        PWSTR pszActualSection = NULL;
        pszActualSection = (PWSTR)_alloca(cchRequiredSize * sizeof(WCHAR));

        PWSTR pszExtension = NULL;
        // Now fill the temporary and assign it to the OUT parameter
        if (fSuccess = SetupDiGetActualSectionToInstallW(hinf,
                pszSectionName, pszActualSection, cchRequiredSize,
                NULL, &pszExtension))
        {
            *pstrActualSectionName = pszActualSection;

            // If the user wants the extension assign it to the string
            // or assign the empty string if no extension was found
            if (pstrExtension)
            {
                *pstrExtension = (pszExtension ? pszExtension : c_szEmpty);
            }
        }
        else
        {
            // initialize out params on failure
            pstrActualSectionName->erase();
            if (pstrExtension)
            {
                pstrExtension->erase();
            }
        }
    }

    // We used SetupApi so errors have to be converted
    HRESULT hr = S_OK;
    if (!fSuccess)
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetActualSectionToInstall", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetActualSectionToInstallWithAlloc
//
//  Purpose: The sections in an inf file may have OS and platform suffixes
//              appended to them.  This function searches for a section that
//              has pszSectionName as its base and has a certain suffix.
//              For example on an x86 NT machine, given a section name of
//              INSTALL, the search would start with INSTALL.NTx86, if that
//              is not found, then INSTALL.NT is searched for.
//              If that is not found INSTALL is returned.
//
//  Arguments:
//      hinf              [in] SetupApi inf file handle.
//      pszSection        [in] the section name to base the search on.
//      ppszActualSection [out] The actual section name with extension.
//                              If the actual section is the same as
//                              pszSectionName, *ppszActualSectionName
//                              will be NULL.
//      ppszExtension     [out] OPTIONAL. The extension part of the
//                              *ppszActualSectionName. This includes "."
//
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   27 Mar 1997
//
//  Notes: See SetupDiGetActualSectionToInstall in SetupApi documention
//              for more info
//
HRESULT
HrSetupDiGetActualSectionToInstallWithAlloc(
    IN  HINF hinf,
    IN  PWSTR pszSection,
    OUT PWSTR* ppszActualSection,
    OUT PWSTR* ppszExtension OPTIONAL)
{
    Assert(IsValidHandle(hinf));
    Assert(pszSection);
    Assert(ppszActualSection);

    // pszSectionName might need to be decorated with OS
    // and Platform specific suffixes.  The next call will return the actual
    // decorated section name or our current section name if the decorated
    // one does not exist.
    //
    HRESULT hr = S_OK;
    BOOL    fSuccess = TRUE;
    DWORD   cchRequiredSize;

    *ppszActualSection = NULL;
    if (ppszExtension)
    {
        *ppszExtension = NULL;
    }

    // Get the buffer length required
    if (fSuccess = SetupDiGetActualSectionToInstallW(hinf,
            pszSection, NULL, 0, &cchRequiredSize, NULL))
    {
        // We are assuming the section is not changing.  If cchRequired is
        // larger than the current section name buffer than we will allocate
        // and fill the out param.
        //
        // If the section name is teh same, then we will not allocate.  But
        // if ppszExtension is specified then we need to send in the original
        // section name buffer since ppszExtension will point to a location
        // within it.
        //
        PWSTR pszBuffer = pszSection;
        if ((wcslen(pszSection) + 1) < cchRequiredSize)
        {
            hr = E_OUTOFMEMORY;
            *ppszActualSection = new WCHAR[cchRequiredSize * sizeof(WCHAR)];
            pszBuffer = *ppszActualSection;
        }

        // if the section name is different (we allocated) or the
        // extension out param was specified, then we need to call the fcn.
        if (pszBuffer && ((pszBuffer != pszSection) || ppszExtension))
        {
            // Now fill the temporary and assign it to the OUT parameter
            if (!(fSuccess = SetupDiGetActualSectionToInstallW(hinf,
                    pszSection, pszBuffer, cchRequiredSize,
                    NULL, ppszExtension)))
            {
                // initialize out params on failure
                delete [] *ppszActualSection;
                *ppszActualSection = NULL;

                if (ppszExtension)
                {
                    *ppszExtension = NULL;
                }
            }
        }
    }

    // We used SetupApi so errors have to be converted
    if (SUCCEEDED(hr) && !fSuccess)
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetActualSectionToInstallWithAlloc", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetActualSectionToInstallWithBuffer
//
//  Purpose: The sections in an inf file may have OS and platform suffixes
//              appended to them.  This function searches for a section that
//              has pszSectionName as its base and has a certain suffix.
//              For example on an x86 NT machine, given a section name of
//              INSTALL, the search would start with INSTALL.NTx86, if that
//              is not found, then INSTALL.NT is searched for.
//              If that is not found INSTALL is returned.
//
//  Arguments:
//      hinf              [in]  SetupApi inf file handle.
//      pszSection        [in]  The section name to base the search on.
//      pszActualSection  [out] The actual section name with extension
//                              Buffer must be LINE_LEN characters.
//      cchActualSection  [in]  Size of pszActualSection in characters.
//      pcchRequired      [out] OPTIONAL. Reuqired size of buffer in
//                              characters.
//      ppszExtension     [out] OPTIONAL. The extension part of the
//                              pszActualSection. This includes "."
//
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   27 Mar 1997
//
//  Notes: See SetupDiGetActualSectionToInstall in SetupApi documention
//              for more info
//
HRESULT
HrSetupDiGetActualSectionToInstallWithBuffer(
    IN  HINF hinf,
    IN  PCWSTR pszSection,
    OUT PWSTR  pszActualSection,
    IN  DWORD  cchActualSection,
    OUT DWORD* pcchRequired,
    OUT PWSTR* ppszExtension OPTIONAL)
{
    Assert(IsValidHandle(hinf));
    Assert(pszSection);
    Assert(pszActualSection);

    // pszSectionName might need to be decorated with OS
    // and Platform specific suffixes.  The next call will return the actual
    // decorated section name or our current section name if the decorated
    // one does not exist.
    //

    BOOL    fSuccess = TRUE;
    DWORD   cchRequiredSize;
    *pszActualSection = 0;
    if (ppszExtension)
    {
        *ppszExtension = NULL;
    }

    // Get the buffer length required
    if (fSuccess = SetupDiGetActualSectionToInstallW(hinf,
            pszSection, NULL, 0, &cchRequiredSize, NULL))
    {
        if (pcchRequired)
        {
            *pcchRequired = cchRequiredSize;
        }

        // If the buffer sent in is large enough, get the section name.
        if (cchActualSection >= cchRequiredSize)
        {
            if (!(fSuccess = SetupDiGetActualSectionToInstallW(hinf,
                    pszSection, pszActualSection, cchActualSection,
                    NULL, ppszExtension)))
            {
                // cleanup on failure.
                *pszActualSection = 0;
            }
        }
    }

    // We used SetupApi so errors have to be converted
    HRESULT hr = S_OK;
    if (!fSuccess)
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetActualSectionToInstallWithBuffer", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetDeviceInstallParams
//
//  Purpose:    Returns the device install params header of a
//              device info set/data.  Set SetupDiGetDeviceInstallParams
//              in the SetupApi for more info.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]  See SetupApi for more info
//      pdeip       [out] See SetupApi for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 May 1997
//
//  Notes:  This function will clear the variable pdeip and set its
//              cbSize field.
//
HRESULT
HrSetupDiGetDeviceInstallParams (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid, OPTIONAL
    OUT PSP_DEVINSTALL_PARAMS pdeip)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeip);

    HRESULT hr = S_OK;

    // initialize out parameter and set its cbSize field
    //
    ZeroMemory(pdeip, sizeof(SP_DEVINSTALL_PARAMS));
    pdeip->cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    // get the header
    if (!SetupDiGetDeviceInstallParams(hdi, pdeid, pdeip))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetDeviceInstallParams", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetDriverInstallParams
//
//  Purpose:    Retrieves install parameters for the specified driver.
//              See SetupApi for more info.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]
//      pdrid       [in]
//      pdrip       [out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:  This function will clear the variable pdrip and set its
//              cbSize field.
//
HRESULT
HrSetupDiGetDriverInstallParams (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid, OPTIONAL
    IN PSP_DRVINFO_DATA pdrid,
    OUT PSP_DRVINSTALL_PARAMS pdrip)
{
    Assert(IsValidHandle(hdi));
    Assert(pdrid);
    Assert(pdrip);

    HRESULT hr = S_OK;

    // initialize out parameter and set its cbSize field
    //
    ZeroMemory(pdrip, sizeof(SP_DRVINSTALL_PARAMS));
    pdrip->cbSize = sizeof(SP_DRVINSTALL_PARAMS);

    // get the header
    if (!SetupDiGetDriverInstallParams(hdi, pdeid, pdrid, pdrip))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetDriverInstallParams", hr);
    return hr;
}

VOID
SetupDiSetConfigFlags (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwFlags,
    IN SD_FLAGS_BINARY_OP eOp)
{
    DWORD   dwConfigFlags = 0;

    // Get the current config flags
    (VOID) HrSetupDiGetDeviceRegistryProperty(hdi, pdeid,
            SPDRP_CONFIGFLAGS, NULL, (BYTE*)&dwConfigFlags,
            sizeof(dwConfigFlags), NULL);

    // Perform the requested operation
    switch (eOp)
    {
        case SDFBO_AND:
            dwConfigFlags &= dwFlags;
            break;
        case SDFBO_OR:
            dwConfigFlags |= dwFlags;
            break;
        case SDFBO_XOR:
            dwConfigFlags ^= dwFlags;
            break;
        default:
            AssertSz(FALSE, "Invalid binary op in HrSetupDiSetConfigFlags");
    }

    (VOID) HrSetupDiSetDeviceRegistryProperty(hdi, pdeid, SPDRP_CONFIGFLAGS,
            (BYTE*)&dwConfigFlags, sizeof(dwConfigFlags));
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiSetDeviceInstallParams
//
//  Purpose:    Sets the device install params header of a
//              device info set/data.  Set SetupDiSetDeviceInstallParams
//              in the SetupApi for more info.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]  See SetupApi for more info
//      pdeip       [in] See SetupApi for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 May 1997
//
//  Notes:
//
HRESULT
HrSetupDiSetDeviceInstallParams (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid, OPTIONAL
    IN PSP_DEVINSTALL_PARAMS pdeip)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeip);
    Assert(pdeip->cbSize == sizeof(SP_DEVINSTALL_PARAMS));

    HRESULT hr = S_OK;

    // set the header
    if (!SetupDiSetDeviceInstallParams(hdi, pdeid, pdeip))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiSetDeviceInstallParams", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiSetDriverInstallParams
//
//  Purpose:    Establishes install parameters for the specified driver.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]
//      pdrid       [in]
//      pdrip       [in]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiSetDriverInstallParams (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid, OPTIONAL
    IN PSP_DRVINFO_DATA pdrid,
    IN PSP_DRVINSTALL_PARAMS pdrip)
{
    Assert(IsValidHandle(hdi));
    Assert(pdrid);
    Assert(pdrip);
    Assert(pdrip->cbSize == sizeof(SP_DRVINSTALL_PARAMS));

    HRESULT hr = S_OK;

    // set the header
    if (!SetupDiSetDriverInstallParams(hdi, pdeid, pdrid, pdrip))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiSetDriverInstallParams", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiSetDeipFlags
//
//  Purpose:    This sets given flags in a dev info data
//
//  Arguments:
//      hdi         [in] See Device Installer Api for more info
//      pdeid       [in] See Device Installer Api for more info
//      dwFlags     [in] Flags to set
//      eFlagType   [in] Which flags field to set with dwFlags
//      eClobber    [in] Whether to add to existing flags or relace them
//
//  Returns:    HRESULT. S_OK if successful,
//                       a Win32 converted error otherwise
//
//
//  Author:     billbe   3 Feb 1998
//
//  Notes:
//
HRESULT
HrSetupDiSetDeipFlags (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwFlags, SD_DEID_FLAG_TYPE eFlagType,
    IN SD_FLAGS_BINARY_OP eOp)
{
    Assert(IsValidHandle(hdi));

    SP_DEVINSTALL_PARAMS deip;
    // Get the install params
    HRESULT hr = HrSetupDiGetDeviceInstallParams (hdi, pdeid, &deip);

    if (S_OK == hr)
    {
        DWORD* pFlags;

        // Set our pointer to the right flag type
        switch (eFlagType)
        {
            case SDDFT_FLAGS:
                pFlags = &deip.Flags;
                break;
            case SDDFT_FLAGSEX:
                pFlags = &deip.FlagsEx;
                break;
            default:
                AssertSz(FALSE, "Invalid Flag type in HrSetupDiSetDeipFlags");
                break;
        }


        // Perform the requested operation
        switch (eOp)
        {
            case SDFBO_AND:
                *pFlags &= dwFlags;
                break;
            case SDFBO_OR:
                *pFlags |= dwFlags;
                break;
            case SDFBO_XOR:
                *pFlags ^= dwFlags;
                break;
            default:
                AssertSz(FALSE, "Invalid binary op in HrSetupDiSetDeipFlags");
        }

        // update the params
        hr = HrSetupDiSetDeviceInstallParams (hdi, pdeid, &deip);
    }

    TraceError ("HrSetupDiSetDeipFlags", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiRemoveDevice
//
//  Purpose:    Calls SetupApi to remove a device. See
//              SetupDiRemoveDevice for more info.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]  See SetupApi for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   27 May 1997
//
//  Notes:  This is used for enumerated Net class components
//
HRESULT
HrSetupDiRemoveDevice(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    HRESULT hr = S_OK;

    if (!SetupDiRemoveDevice(hdi,pdeid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiRemoveDevice", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiOpenDeviceInfo
//
//  Purpose:    Retrieves information about an existing device instance and
//              adds it to the specified device information set
//
//  Arguments:
//      hdi              [in]   See SetupApi for more info
//      pszPnpInstanceId [in]   See SetupApi for more info
//      hwndParent       [in]   See SetupApi for more info
//      dwOpenFlags      [in]   See SetupApi for more info
//      pdeid            [out]  See SetupApi for more info OPTIONAL
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   27 May 1997
//
//  Notes:  This is used for enumerated Net class components
//
HRESULT
HrSetupDiOpenDeviceInfo(
    IN const HDEVINFO hdi,
    IN PCWSTR pszPnpInstanceId,
    IN HWND hwndParent,
    IN DWORD dwOpenFlags,
    OUT PSP_DEVINFO_DATA pdeid OPTIONAL)
{
    Assert(IsValidHandle(hdi));
    Assert(pszPnpInstanceId);

    // If the out param was specified, clear it and set its cbSize field
    //
    if (pdeid)
    {
        ZeroMemory(pdeid, sizeof(*pdeid));
        pdeid->cbSize = sizeof(*pdeid);
    }

    HRESULT hr = S_OK;

    if (!SetupDiOpenDeviceInfo(hdi, pszPnpInstanceId, hwndParent, dwOpenFlags,
            pdeid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr (ttidError, FAL, hr, SPAPI_E_NO_SUCH_DEVINST == hr,
            "HrSetupDiOpenDeviceInfo");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiCreateDeviceInfoList
//
//  Purpose:    Creates an empty device information set.
//
//  Arguments:
//      pguidClass [in]   See SetupApi for more info
//      hwndParent [in]   See SetupApi for more info
//      phdi       [out]  See SetupApi for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   27 May 1997
//
//  Notes:
//
HRESULT
HrSetupDiCreateDeviceInfoList (
    IN const GUID* pguidClass,
    IN HWND hwndParent,
    OUT HDEVINFO* phdi)
{
    Assert(phdi);

    HRESULT hr;

    // Try to create the info set
    //
    HDEVINFO hdi = SetupDiCreateDeviceInfoList (pguidClass, hwndParent);

    if (INVALID_HANDLE_VALUE != hdi)
    {
        hr = S_OK;
        *phdi = hdi;
    }
    else
    {
        hr = HrFromLastWin32Error();
        *phdi = NULL;
    }

    TraceError("HrSetupDiCreateDeviceInfoList", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetDeviceRegistryPropertyWithAlloc
//
//  Purpose:    Returns the requested property of a device
//              See SetupApi for more info.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]
//      dwProperty  [in]
//      pdwRegType  [out]
//      ppbBuffer   [out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   1 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiGetDeviceRegistryPropertyWithAlloc(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwProperty,
    OUT DWORD* pdwRegType, OPTIONAL
    OUT BYTE** ppbBuffer)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);
    Assert(ppbBuffer);

    *ppbBuffer = NULL;

    DWORD cbReqSize;
    HRESULT hr = S_OK;

    // Get the size needed for the buffer
    BOOL fWin32Success = SetupDiGetDeviceRegistryPropertyW(hdi, pdeid,
            dwProperty, NULL, NULL, 0, &cbReqSize);

    // We expect failure since we want the buffer size and sent in no buffer
    if (!fWin32Success)
    {
        if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
        {
            // Not really an error
            fWin32Success = TRUE;
        }

        if (fWin32Success)
        {
            *ppbBuffer = (BYTE*) MemAlloc (cbReqSize);

            if (*ppbBuffer)
            {
                // Now get the actual information
                fWin32Success = SetupDiGetDeviceRegistryPropertyW(hdi, pdeid,
                        dwProperty, pdwRegType, *ppbBuffer, cbReqSize, NULL);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    // All failures are converted to HRESULTS
    if (SUCCEEDED(hr) && !fWin32Success)
    {
        MemFree (*ppbBuffer);
        *ppbBuffer = NULL;
        hr = HrFromLastWin32Error();
    }

    TraceHr (ttidError, FAL, hr ,
             (HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr) ||
            (SPAPI_E_NO_SUCH_DEVINST == hr),
             "HrSetupDiGetDeviceRegistryPropertyWithAlloc");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetDeviceRegistryProperty
//
//  Purpose:    Returns the requested property of a device
//              See SetupApi for more info.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]
//      dwProperty  [in]
//      pdwRegType  [out]
//      ppbBuffer   [out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   1 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiGetDeviceRegistryProperty(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwProperty,
    OUT DWORD* pdwRegType, OPTIONAL
    OUT BYTE* pbBuffer,
    IN DWORD cbBufferSize,
    OUT DWORD* pcbRequiredSize OPTIONAL)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    // Get the size needed for the buffer
    BOOL fWin32Success = SetupDiGetDeviceRegistryPropertyW(hdi, pdeid, dwProperty,
            pdwRegType, pbBuffer, cbBufferSize, pcbRequiredSize);

    HRESULT hr = S_OK;

    // All failures are converted to HRESULTS
    if (!fWin32Success)
    {
        if (pbBuffer)
        {
            *pbBuffer = 0;
        }
        hr = HrFromLastWin32Error();
    }

    TraceHr (ttidError, FAL, hr ,
             (HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr) ||
            (SPAPI_E_NO_SUCH_DEVINST == hr),
             "HrSetupDiGetDeviceRegistryProperty");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetDeviceName
//
//  Purpose:    Helper function to get the name of the device specified in
//              hdi and pdeid. Trys the friendly name first and if not there
//              falls back to driver name which must be there.
//
//  Arguments:
//      hdi      [in]
//      pdeid    [in]      See SetupApi for more info
//      ppszName [out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     danielwe   11 Feb 1998
//
//  Notes:
//
HRESULT
HrSetupDiGetDeviceName (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    OUT PWSTR* ppszName)
{

    Assert(IsValidHandle(hdi));
    Assert(pdeid);
    Assert(ppszName);

    DWORD   dwType;
    HRESULT hr = S_OK;

    hr = HrSetupDiGetDeviceRegistryPropertyWithAlloc(
            hdi, pdeid, SPDRP_FRIENDLYNAME, &dwType, (BYTE**)ppszName);
    if (FAILED(hr))
    {
        // Try again with the device desc which MUST be there.
        hr = HrSetupDiGetDeviceRegistryPropertyWithAlloc(
                hdi, pdeid, SPDRP_DEVICEDESC, &dwType, (BYTE**)ppszName);
    }
    AssertSz(FImplies(SUCCEEDED(hr), (dwType == REG_SZ)), "Not a string?!");

    TraceError("HrSetupDiGetDeviceName", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupDiSetDeviceName
//
//  Purpose:    Helper function to set the name of the device specified in
//              hdi and pdeid.
//
//  Arguments:
//      hdi       [in]
//      pdeid     [in]      See SetupApi for more info
//      ppbBuffer [out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     sumitc     23 apr 1998
//
//  Notes:
//
HRESULT
HrSetupDiSetDeviceName(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN PCWSTR pszDeviceName)
{

    Assert(IsValidHandle(hdi));
    Assert(pszDeviceName);

    HRESULT hr = S_OK;

    hr = HrSetupDiSetDeviceRegistryProperty(hdi,
                                            pdeid,
                                            SPDRP_FRIENDLYNAME,
                                            (const BYTE*)pszDeviceName,
                                            sizeof(WCHAR) * (wcslen(pszDeviceName) + 1));
    TraceError("HrSetupDiSetDeviceName", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiSetDeviceRegistryProperty
//
//  Purpose:    Sets the specified Plug and Play device registry property.
//              See SetupApi for more info.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]
//      dwProperty  [in]
//      pbBuffer    [in]
//      cbSize      [in]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 June 1997
//
//  Notes:
//
HRESULT
HrSetupDiSetDeviceRegistryProperty(IN HDEVINFO hdi,
                                   IN OUT PSP_DEVINFO_DATA pdeid,
                                   IN DWORD dwProperty,
                                   IN const BYTE* pbBuffer,
                                   IN DWORD cbSize)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);
    Assert(pbBuffer);

    HRESULT hr = S_OK;

    // Set the property
    if (!SetupDiSetDeviceRegistryProperty(hdi, pdeid, dwProperty, pbBuffer,
            cbSize))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiSetDeviceRegistryProperty", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiSendPropertyChangeNotification
//
//  Purpose:    This sends a DIF_PROPERTCHANGE notification to the
//                  class installer
//
//  Arguments:
//      hdi             [in] See Device Isntaller Api
//      pdeid           [in]
//      dwStateChange   [in]
//      dwScope         [in]
//      dwProfileId     [in]
//
//  Returns:    HRESULT. S_OK if no error, a Win32 error converted
//                       code otherwise
//
//  Author:     billbe   4 Nov 1997
//
//  Notes:
//
HRESULT
HrSetupDiSendPropertyChangeNotification(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                                        DWORD dwStateChange, DWORD dwScope,
                                        DWORD dwProfileId)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    // First we create the property change structure and fill out its fields
    //
    SP_PROPCHANGE_PARAMS pcp;
    ZeroMemory(&pcp, sizeof(pcp));
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    pcp.StateChange = dwStateChange;
    pcp.Scope = dwScope;
    pcp.HwProfile = dwProfileId;

    // Now we set the structure as the device info data's
    // class install params
    HRESULT hr = HrSetupDiSetClassInstallParams(hdi, pdeid,
            reinterpret_cast<SP_CLASSINSTALL_HEADER*>(&pcp),
            sizeof(pcp));

    if (SUCCEEDED(hr))
    {
        // Now we need to set the "we have a class install params" flag
        // in the device install params
        //
        SP_DEVINSTALL_PARAMS deip;
        hr = HrSetupDiGetDeviceInstallParams(hdi, pdeid, &deip);
        if (SUCCEEDED(hr))
        {
            deip.Flags |= DI_CLASSINSTALLPARAMS;
            hr = HrSetupDiSetDeviceInstallParams(hdi, pdeid, &deip);

            if (SUCCEEDED(hr))
            {
                // Notify the driver that the state has changed
                hr = HrSetupDiCallClassInstaller(DIF_PROPERTYCHANGE, hdi,
                        pdeid);

                if (SUCCEEDED(hr))
                {
                    // Set the properties change flag in the device info to
                    // let anyone who cares know that their ui might need
                    // updating to reflect any change in the device's status
                    // We can't let any failures here stop us so we ignore
                    // return values
                    //
                    (void) HrSetupDiGetDeviceInstallParams(hdi, pdeid,
                            &deip);
                    deip.Flags |= DI_PROPERTIES_CHANGE;
                    (void) HrSetupDiSetDeviceInstallParams(hdi, pdeid,
                            &deip);
                }
            }
        }
    }

    TraceError("HrSetupDiSendPropertyChangeNotification", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   FSetupDiCheckIfRestartNeeded
//
//  Purpose:    Checks the hdi and pdeid for the presence of the
//                  restart flag in the install params structure.
//                  See Device Installer Api for more info.
//
//  Arguments:
//      hdi     [in] See Device Installer Api
//      pdeid   [in]
//
//  Returns:    BOOL. TRUE if a restart is required, FALSE otherwise
//
//  Author:     billbe   28 Apr 1997
//
//  Notes:
//
BOOL
FSetupDiCheckIfRestartNeeded(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    SP_DEVINSTALL_PARAMS    deip;
    BOOL fRestart = FALSE;

    // Get the install params for the device pdeid.
    HRESULT hr = HrSetupDiGetDeviceInstallParams(hdi, pdeid, &deip);
    if (SUCCEEDED(hr))
    {
        // Check for the presence of the flag
        if ((deip.Flags & DI_NEEDRESTART) || (deip.Flags & DI_NEEDREBOOT))
        {
            fRestart = TRUE;
        }
    }

    // We don't return any failures from this function since it is just
    // a check but we should trace them
    TraceError("FSetupDiCheckIfRestartNeeded", hr);
    return fRestart;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetClassImageList
//
//  Purpose:    Builds an image list that contains bitmaps for every
//              installed class and returns the list in a data structure
//
//  Arguments:
//      pcild    [out]  See Device Installer Api for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 Nov 1997
//
//  Notes:  The image list will be in the ImageList field of the pcild
//                  structure
//
HRESULT
HrSetupDiGetClassImageList(PSP_CLASSIMAGELIST_DATA pcild)
{
    Assert(pcild);

    HRESULT hr = S_OK;

    ZeroMemory(pcild, sizeof(*pcild));
    pcild->cbSize = sizeof(*pcild);

    if (!SetupDiGetClassImageList(pcild))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetClassImageList", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiDestroyClassImageList
//
//  Purpose:    Destroys a class image list that was built with
//              (Hr)SetupDiGetClassImageList
//
//  Arguments:
//      pcild    [in]  See Device Installer Api for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 Nov 1997
//
//  Notes:
//
HRESULT
HrSetupDiDestroyClassImageList(PSP_CLASSIMAGELIST_DATA pcild)
{
    Assert(pcild);

    HRESULT hr = S_OK;

    if (!SetupDiDestroyClassImageList(pcild))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiDestroyClassImageList", hr);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetClassImageIndex
//
//  Purpose:    Retrieves the index within the class image list of a
//              specified class
//
//  Arguments:
//      pcild     [in]  See Device Installer Api for more info
//      guidClass [in]
//      pnIndex   [out]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 Nov 1997
//
//  Notes:
//
HRESULT
HrSetupDiGetClassImageIndex(PSP_CLASSIMAGELIST_DATA pcild,
                            const GUID* pguidClass, INT* pnIndex)
{
    Assert(pcild);
    Assert(pguidClass);
    Assert(pnIndex);

    HRESULT hr = S_OK;

    if (!SetupDiGetClassImageIndex(pcild, pguidClass, pnIndex))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupDiGetClassImageIndex", hr);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrSetupDiGetParentWindow
//
//  Purpose:    Returns the window handle found in the install params of a
//              device info set/data.  Set SP_DEVINSTALL_PARAMS in the
//              SetupApi for more info.
//
//  Arguments:
//      hdi         [in]  See SetupApi for more info
//      pdeid       [in]  See SetupApi for more info
//      phwndParent [out] Pointer to the parent window handle
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   12 May 1997
//
//  Notes:
//
HRESULT HrSetupDiGetParentWindow (HDEVINFO hdi,
                                  PSP_DEVINFO_DATA pdeid, OPTIONAL
                                  HWND* phwndParent)
{
    Assert(IsValidHandle(hdi));
    Assert(phwndParent);

    // Initialize the output parameter.
    *phwndParent = NULL;

    // Get the install params of the device
    SP_DEVINSTALL_PARAMS deip;
    HRESULT hr = HrSetupDiGetDeviceInstallParams(hdi, pdeid, &deip);
    if (SUCCEEDED(hr))
    {
        // Only assign the output if we have a valid window handle
        if (IsWindow(deip.hwndParent))
        {
            *phwndParent = deip.hwndParent;
        }
    }

    TraceError("HrSetupDiGetParentWindow", hr);
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   HrSetupInstallFilesFromInfSection
//
//  Purpose:    Queues all the files specified in the Copy Files sections
//                  listed by an Install section for installation.
//
//  Arguments:
//      hinf          [in]  See SetupApi for more info
//      hinfLayout    [in] Optional
//      hfq           [in]
//      pszSection    [in]
//      pszSourcePath [in] Optional
//      ulFlags       [in] Optional
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   21 July 1997
//
//  Notes:
//
HRESULT
HrSetupInstallFilesFromInfSection (
    IN HINF hinf,
    IN HINF hinfLayout,
    IN HSPFILEQ hfq,
    IN PCWSTR pszSection,
    IN PCWSTR pszSourcePath,
    IN UINT ulFlags)
{
    Assert(IsValidHandle(hinf));
    Assert(FImplies(hinfLayout, INVALID_HANDLE_VALUE != hinfLayout));
    Assert(pszSection);

    HRESULT hr = S_OK;

    if (!SetupInstallFilesFromInfSection(hinf, hinfLayout, hfq, pszSection,
            pszSourcePath, ulFlags))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("HrSetupInstallFilesFromInfSection", hr);
    return hr;

}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupInstallFromInfSection
//
//  Purpose:    Carries out all the directives in an INF file Install section.
//
//  Arguments:
//      hwnd        [in]  See SetupApi for more info
//      hinf        [in]
//      pszSection  [in]
//      ulFlags     [in]
//      hkey        [in]
//      pszSource   [in]
//      ulCopyFlags [in]
//      pfc         [in]
//      pvCtx       [in]
//      hdi         [in]
//      pdeid       [in]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   5 July 1997
//
//  Notes:
//
HRESULT
HrSetupInstallFromInfSection (
    IN HWND hwnd,
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN UINT ulFlags,
    IN HKEY hkey,
    IN PCWSTR pszSource,
    IN UINT ulCopyFlags,
    IN PSP_FILE_CALLBACK pfc,
    IN PVOID pvCtx,
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hinf));
    Assert(pszSection);

    HRESULT hr = S_OK;

    if (!SetupInstallFromInfSection(hwnd, hinf, pszSection, ulFlags, hkey,
            pszSource, ulCopyFlags, pfc, pvCtx, hdi, pdeid))
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrSetupInstallFromInfSection (%S)",
            pszSection);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrSetupInstallServicesFromInfSection
//
//  Purpose:    Carries out all the service directives in an INF file Install
//                  section.
//
//  Arguments:
//      hinf        [in] See SetupApi for more info
//      pszSection  [in]
//      dwFlags     [in]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   19 Feb 1998
//
//  Notes:
//
HRESULT
HrSetupInstallServicesFromInfSection (
    IN HINF hinf,
    IN PCWSTR pszSection,
    IN DWORD dwFlags)
{
    Assert(IsValidHandle(hinf));
    Assert(pszSection);

    HRESULT hr = S_OK;

    if (!SetupInstallServicesFromInfSection(hinf, pszSection, dwFlags))
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr (ttidError, FAL, hr, (SPAPI_E_SECTION_NOT_FOUND == hr),
        "HrSetupInstallServicesFromInfSection (%S)", pszSection);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOpenSoftwareDeviceEnumerator
//
//  Purpose:    Opens the swenum device driver used to install software-
//              enumerated device drivers.
//
//  Arguments:
//      dwFlagsAndAttributes [in]  See CreateFile.
//      phFile               [out] The returned handle to the swenum device.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   30 Mar 1998
//
//  Notes:
//
HRESULT
HrOpenSoftwareDeviceEnumerator (
    DWORD   dwFlagsAndAttributes,
    HANDLE* phFile)
{
    Assert (phFile);

    // Initialize the output parameter.
    //
    *phFile = INVALID_HANDLE_VALUE;

    // Get the devices in software device enumerator class.  There should
    // only be one.  (Or rather, we're only interested in the first one.)
    //
    HDEVINFO hdi;
    HRESULT hr = HrSetupDiGetClassDevs (&BUSID_SoftwareDeviceEnumerator,
                    NULL, NULL, DIGCF_PRESENT | DIGCF_INTERFACEDEVICE,
                    &hdi);
    if (S_OK == hr)
    {
        // Enumerate the first device in this class.  This will
        // initialize did.
        //
        SP_DEVICE_INTERFACE_DATA did;
        ZeroMemory (&did, sizeof(did));
        did.cbSize = sizeof(did);

        if (SetupDiEnumDeviceInterfaces (hdi, NULL,
                const_cast<LPGUID>(&BUSID_SoftwareDeviceEnumerator),
                0, &did))
        {
            // Now get the details so we can open the device.
            //
            const ULONG cbDetail = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                                    (MAX_PATH * sizeof(WCHAR));
            PSP_DEVICE_INTERFACE_DETAIL_DATA pDetail;

            hr = HrMalloc (cbDetail, (PVOID*)&pDetail);
            if (S_OK == hr)
            {
                pDetail->cbSize = sizeof(*pDetail);

                if (SetupDiGetDeviceInterfaceDetail (hdi, &did,
                        pDetail, cbDetail, NULL, NULL))
                {
                    // Now open the device (swenum).
                    //
                    HANDLE hFile = CreateFile (pDetail->DevicePath,
                                        GENERIC_READ | GENERIC_WRITE,
                                        0, NULL, OPEN_EXISTING,
                                        dwFlagsAndAttributes, NULL);
                    if (hFile && (INVALID_HANDLE_VALUE != hFile))
                    {
                        *phFile = hFile;
                    }
                    else
                    {
                        hr = HrFromLastWin32Error ();
                    }
                }
                else
                {
                    hr = HrFromLastWin32Error ();
                }

                MemFree (pDetail);
            }
        }
        else
        {
            hr = HrFromLastWin32Error ();
        }

        SetupDiDestroyDeviceInfoList (hdi);
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrOpenSoftwareDeviceEnumerator");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindDeviceOnInterface
//
//  Purpose:    Searches for a specific device on a given interface.
//              It does this by using setup api to return all of the
//              devices in the class given by pguidInterfaceId.  It then
//              gets device path for each of these device interfaces and
//              looks for pguidDeviceId and pszReferenceString as substrings.
//
//  Arguments:
//      pguidDeviceId        [in]  The device id to find.
//      pguidInterfaceId     [in]  The interface on which to look.
//      pszReferenceString  [in]  Optional.  Further match on this ref string.
//      dwFlagsAndAttributes [in]  See CreateFile.  This is how the device is
//                                 opened if it is found.
//      phFile               [out] The returned device handle.
//
//  Returns:    S_OK if found and opened, S_FALSE if not found, or an error.
//
//  Author:     shaunco   30 Mar 1998
//
//  Notes:
//
HRESULT
HrFindDeviceOnInterface (
    IN const GUID* pguidDeviceId,
    IN const GUID* pguidInterfaceId,
    IN PCWSTR      pszReferenceString,
    IN DWORD       dwFlagsAndAttributes,
    OUT HANDLE*    phFile)
{
    Assert (pguidDeviceId);
    Assert (pguidInterfaceId);
    Assert (phFile);

    // Initialize the output parameter.
    //
    *phFile = INVALID_HANDLE_VALUE;

    WCHAR szDeviceId [c_cchGuidWithTerm];
    INT cch = StringFromGUID2 (*pguidDeviceId, szDeviceId,
                c_cchGuidWithTerm);
    Assert (c_cchGuidWithTerm == cch);
    CharLower (szDeviceId);

    // Get the devices in this class.
    //
    HDEVINFO hdi;
    HRESULT hr = HrSetupDiGetClassDevs (pguidInterfaceId, NULL, NULL,
                    DIGCF_PRESENT | DIGCF_INTERFACEDEVICE, &hdi);
    if (S_OK == hr)
    {
        BOOL fFound = FALSE;

        // abBuffer is a buffer used to get device interface detail for each
        // device interface enumerated below.
        //
        const ULONG cbDetail = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) +
                                (MAX_PATH * sizeof(WCHAR));
        PSP_DEVICE_INTERFACE_DETAIL_DATA pDetail;

        hr = HrMalloc (cbDetail, (PVOID*)&pDetail);
        if (S_OK == hr)
        {
            // Enumerate the device interfaces looking for the one specified.
            //
            SP_DEVICE_INTERFACE_DATA did;
            ZeroMemory (&did, sizeof(did));

            for (DWORD i = 0;
                 did.cbSize = sizeof(did),
                 SetupDiEnumDeviceInterfaces (hdi, NULL,
                        const_cast<LPGUID>(pguidInterfaceId), i, &did);
                 i++)
            {
                // Now get the details so we can compare the device path.
                //
                pDetail->cbSize = sizeof(*pDetail);
                if (SetupDiGetDeviceInterfaceDetailW (hdi, &did,
                        pDetail, cbDetail, NULL, NULL))
                {
                    CharLower (pDetail->DevicePath);

                    // Look for a substring containing szDeviceId.  Also
                    // look for a substring containing pszReferenceString if
                    // it is specified.
                    //
                    if (wcsstr (pDetail->DevicePath, szDeviceId) &&
                        (!pszReferenceString || !*pszReferenceString ||
                         wcsstr (pDetail->DevicePath, pszReferenceString)))
                    {
                        // We found it, so open the device and return it.
                        //
                        HANDLE hFile = CreateFile (pDetail->DevicePath,
                                            GENERIC_READ | GENERIC_WRITE,
                                            0, NULL, OPEN_EXISTING,
                                            dwFlagsAndAttributes, NULL);
                        if (hFile && (INVALID_HANDLE_VALUE != hFile))
                        {
                            TraceTag (ttidNetcfgBase, "Found device id '%S'",
                                szDeviceId);

                            TraceTag (ttidNetcfgBase, "Opening device '%S'",
                                pDetail->DevicePath);

                            *phFile = hFile;
                            fFound = TRUE;
                        }
                        else
                        {
                            hr = HrFromLastWin32Error ();
                        }

                        // Now that we've found it, break out of the loop.
                        //
                        break;
                    }
                }
                else
                {
                    hr = HrFromLastWin32Error ();
                }
            }

            MemFree (pDetail);
        }

        SetupDiDestroyDeviceInfoList (hdi);

        if (SUCCEEDED(hr) && !fFound)
        {
            hr = S_FALSE;
        }
    }

    TraceHr(ttidError, FAL, hr, S_FALSE == hr,
        "HrFindDeviceOnInterface (device=%S)", szDeviceId);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallSoftwareDeviceOnInterface
//
//  Purpose:    Install a software-enumerated device on the given interface.
//
//  Arguments:
//      pguidDeviceId       [in] The device id to install.
//      pguidInterfaceId    [in] The interface to install it on.
//      pszReferenceString [in] The reference string.
//      fForceInstall       [in] Usually specify FALSE.  Specify TRUE to
//                               force installation of the device using
//                               pguidClass and pszHardwareId.
//                               Typically this is used during GUI mode setup
//                               where swenum won't be able to fully install
//                               the device.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   30 Mar 1998
//
//  Notes:
//
HRESULT
HrInstallSoftwareDeviceOnInterface (
    const GUID* pguidDeviceId,
    const GUID* pguidInterfaceId,
    PCWSTR      pszReferenceString,
    BOOL        fForceInstall,
    PCWSTR      pszInfFilename,
    HWND        hwndParent)
{
    Assert (pguidDeviceId);
    Assert (pguidInterfaceId);
    Assert (pszReferenceString && *pszReferenceString);

    // Open the software device enumerator.
    //
    HANDLE hSwenum;
    HRESULT hr = HrOpenSoftwareDeviceEnumerator (
                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                    &hSwenum);
    if (S_OK == hr)
    {
        Assert (INVALID_HANDLE_VALUE != hSwenum);

        // Allocate and build the buffer used as the IOCTL parameter.
        //
        const ULONG cbBuf = (ULONG)FIELD_OFFSET (SWENUM_INSTALL_INTERFACE, ReferenceString) +
                            CbOfSzAndTerm (pszReferenceString);
        SWENUM_INSTALL_INTERFACE* pBuf;

        hr = HrMalloc (cbBuf, (PVOID*)&pBuf);
        if (S_OK == hr)
        {
            ZeroMemory (pBuf, cbBuf);
            pBuf->DeviceId    = *pguidDeviceId;
            pBuf->InterfaceId = *pguidInterfaceId;
            lstrcpyW (pBuf->ReferenceString, pszReferenceString);

            // Create an event to be used for the overlapped IO we are about
            // to issue.
            //
            OVERLAPPED ovl;
            ZeroMemory (&ovl, sizeof(ovl));
            ovl.hEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
            if (ovl.hEvent)
            {
#ifdef ENABLETRACE
                WCHAR szDeviceId [c_cchGuidWithTerm];
                INT cch = StringFromGUID2 (pBuf->DeviceId, szDeviceId,
                            c_cchGuidWithTerm);
                Assert (c_cchGuidWithTerm == cch);

                WCHAR szInterfaceId [c_cchGuidWithTerm];
                cch = StringFromGUID2 (pBuf->InterfaceId, szInterfaceId,
                            c_cchGuidWithTerm);
                Assert (c_cchGuidWithTerm == cch);

                TraceTag (ttidNetcfgBase, "Installing software enumerated "
                    "device '%S' on interface '%S'",
                    szDeviceId, szInterfaceId);
#endif

                // Issue the install interface IOCTL.
                //
                DWORD cbReturned;
                BOOL fIoResult = DeviceIoControl (hSwenum,
                                    IOCTL_SWENUM_INSTALL_INTERFACE,
                                    pBuf, cbBuf, NULL, 0,
                                    &cbReturned, &ovl);
                if (!fIoResult)
                {
                    hr = HrFromLastWin32Error ();
                    if (HRESULT_FROM_WIN32 (ERROR_IO_PENDING) == hr)
                    {
                        // Wait for the IO to complete if it was returned as
                        // pending.
                        //
                        fIoResult = GetOverlappedResult (hSwenum, &ovl,
                                        &cbReturned, TRUE);
                        if (!fIoResult)
                        {
                            hr = HrFromLastWin32Error ();
                        }
                    }
                }

                CloseHandle (ovl.hEvent);
            }

            MemFree (pBuf);
        }

        CloseHandle (hSwenum);
    }

    // Force the device to be installed by enumerating it.
    //
    if ((S_OK == hr) && fForceInstall)
    {
        HANDLE hDevice;

        hr = HrFindDeviceOnInterface (
                pguidDeviceId,
                pguidInterfaceId,
                pszReferenceString,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                &hDevice);

        if (S_OK == hr)
        {
            CloseHandle (hDevice);
        }
        else if (S_FALSE == hr)
        {
            // We just installed this device, why wasn't it found?
            //
            hr = E_UNEXPECTED;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrInstallSoftwareDeviceOnInterface");
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrInstallFromInfSectionInFile
//
// Purpose:   Open the given INF file and call Setup API to install
//            from the specified section.
//
// Arguments:
//    hwndParent    [in]  handle of parent window
//    szInfName     [in]  name of INF
//    szSection     [in]  section name
//    hkeyRelative  [in]  handle of reg-key to use
//    fQuietInstall [in]  TRUE if we shouldn't show UI and use
//                        default values, FALSE if we can bother
//                        the user with questions and UI
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 23-December-97
//
// Notes:
//
HRESULT HrInstallFromInfSectionInFile (
    IN HWND    hwndParent,
    IN PCWSTR  pszInfName,
    IN PCWSTR  pszSection,
    IN HKEY    hkeyRelative,
    IN BOOL    fQuietInstall)
{
    AssertValidReadPtr(pszInfName);
    AssertValidReadPtr(pszSection);

    HRESULT hr;
    HINF    hinf;

    hr = HrSetupOpenInfFile(pszInfName, NULL,
                            INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL, &hinf);
    if (S_OK == hr)
    {
        hr = HrSetupInstallFromInfSection (hwndParent, hinf, pszSection,
                SPINST_REGISTRY, hkeyRelative, NULL, 0, NULL, NULL,
                NULL, NULL);
    }

    TraceError("HrInstallInfSectionInfFile", hr);
    return hr;
}

#if defined(REMOTE_BOOT)
//+--------------------------------------------------------------------------
//
//  Function:   HrIsRemoteBootAdapter
//
//  Purpose:    This determines whether the adapter is a remote boot adapter
//
//  Arguments:
//      hdi         [in]  See Device Installer Api for more info
//      pdeid       [in]  See Device Installer Api for more info
//
//  Returns:    HRESULT. S_OK if adapter is a remote boot adapter
//                       S_FALSE if adapter is not a remote boot adapter
//                       a Win32 converted error otherwise
//
//
//  Author:     billbe   31 Jan 1998
//
//  Notes:
//
HRESULT
HrIsRemoteBootAdapter(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    DWORD dwConfigFlags;

    // Get the current config flags
    HRESULT hr = HrSetupDiGetDeviceRegistryProperty(hdi, pdeid,
            SPDRP_CONFIGFLAGS, NULL, (BYTE*)&dwConfigFlags,
            sizeof(dwConfigFlags), NULL);

    if (SUCCEEDED(hr))
    {
        if (dwConfigFlags & CONFIGFLAG_NETBOOT_CARD)
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else if (HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr)
    {
        // The device had no config flags, so it isn't a remote boot adapter
        hr = S_FALSE;
    }


    TraceError("HrIsRemoteBootAdapter", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}
#endif // defined(REMOTE_BOOT)

VOID
SetupDiDestroyDeviceInfoListSafe(HDEVINFO hdi)
{
    if (IsValidHandle(hdi))
    {
        SetupDiDestroyDeviceInfoList(hdi);
    }
}

VOID
SetupCloseInfFileSafe(HINF hinf)
{
    if (IsValidHandle(hinf))
    {
        SetupCloseInfFile(hinf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncsvc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S V C . C P P
//
//  Contents:   Implementation of non-inline CService and CServiceManager
//              methods.
//
//  Notes:
//
//  Author:     mikemi      6 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncstring.h"
#include "ncsvc.h"
#include "ncmisc.h"
#include "ncperms.h"

struct CSCTX
{
    SC_HANDLE       hScm;
    const CSFLAGS*  pFlags;
    DWORD           dwErr;

    // This just allows us to save some stack space otherwise wasted by
    // recursion.
    //
    SERVICE_STATUS  status;
};

VOID
SvcControlServicesAndWait (
    CSCTX*          pCtx,
    UINT            cServices,
    const PCWSTR*   apszServices);


VOID
StopDependentServices (
    SC_HANDLE   hSvc,
    PCWSTR      pszService,
    CSCTX*      pCtx)
{
    // Try a first guess of 256 bytes for the buffer needed to hold the
    // dependent information.  If that fails, retry with the buffer size
    // returned from EnumDependentServices.
    //
    DWORD                   cbBuf   = 256;
    ENUM_SERVICE_STATUS*    aess    = NULL;
    DWORD                   cess    = 0;
    DWORD                   dwErr   = ERROR_SUCCESS;
    INT                     cLoop   = 0;
    const INT               cLoopMax = 2;
    do
    {
        // Allocate the needed space if we know it.
        //
        if (cbBuf)
        {
            MemFree (aess);
            aess = reinterpret_cast<ENUM_SERVICE_STATUS*>(MemAlloc (cbBuf));
            if (!aess)
            {
                dwErr = ERROR_OUTOFMEMORY;
                break;
            }
        }
        dwErr = ERROR_SUCCESS;
        if (!EnumDependentServices (hSvc, SERVICE_ACTIVE, aess, cbBuf,
                &cbBuf, &cess))
        {
            dwErr = GetLastError ();
        }
    }
    while ((ERROR_MORE_DATA == dwErr) && (++cLoop < cLoopMax));

    // If we have some services to stop, stop them and wait.
    //
    if ((ERROR_SUCCESS == dwErr) && cess)
    {
        // The array of ENUM_SERVICE_STATUS has the service names but not
        // in a form that can be passed directly to
        // SvcControlServicesAndWait, so we must transform the data into
        // an array of string pointers.
        //
        PCWSTR* apszServices = reinterpret_cast<PCWSTR*>(
                    PvAllocOnStack (cess * sizeof(PCWSTR)));
        for (UINT i = 0; i < cess; i++)
        {
            apszServices[i] = aess[i].lpServiceName;
        }

        Assert (SERVICE_CONTROL_STOP == pCtx->pFlags->dwControl);

        TraceTag (ttidSvcCtl, "Stopping dependents of %S...", pszService);

        SvcControlServicesAndWait (pCtx, cess, apszServices);
    }

    // Otherwise, if we've had an error, but there is no context error yet,
    // propagate our error to the context error for the caller.
    //
    else if ((ERROR_SUCCESS != dwErr) && (ERROR_SUCCESS == pCtx->dwErr))
    {
        pCtx->dwErr = dwErr;
    }

    MemFree (aess);
}

VOID
SvcControlServicesAndWait (
    CSCTX*          pCtx,
    UINT            cServices,
    const PCWSTR*   apszServices)
{
    BOOL  fr = TRUE;
    DWORD dwErr;

    // We only set this to TRUE if we successfuly open and control
    // at least one service in the first phase.
    //
    BOOL fWaitIfNeeded = FALSE;

    // Allocate a buffer (on the stack) to place the opened service
    // handles in and zero it.
    //
    size_t cb = cServices * sizeof(SC_HANDLE);

    SC_HANDLE* ahSvc = reinterpret_cast<SC_HANDLE*>
        (PvAllocOnStack (cb));

    ZeroMemory (ahSvc, cb);

    // For each service, open it and apply the requested control
    // (if requested).  If the control succeeds, add the handle to
    // our array for later use.
    //

    for (UINT i = 0; i < cServices; i++)
    {
        // Open the service.
        //
        SC_HANDLE hSvc = OpenService (pCtx->hScm,
                            apszServices[i],
                            SERVICE_QUERY_CONFIG |
                            SERVICE_QUERY_STATUS |
                            SERVICE_ENUMERATE_DEPENDENTS |
                            SERVICE_START | SERVICE_STOP |
                            SERVICE_USER_DEFINED_CONTROL);
        if (hSvc)
        {
            // If we're to ignore demand-start and disabled services,
            // check for it now and skip if needed.  Remember to close
            // the service handle because we're going to open the next if
            // we skip this one.
            //
            if (pCtx->pFlags->fIgnoreDisabledAndDemandStart)
            {
                BOOL fSkip = FALSE;

                LPQUERY_SERVICE_CONFIG pConfig;
                if (SUCCEEDED(HrQueryServiceConfigWithAlloc (hSvc, &pConfig)))
                {
                    if ((pConfig->dwStartType == SERVICE_DEMAND_START) ||
                        (pConfig->dwStartType == SERVICE_DISABLED))
                    {
                        fSkip = TRUE;

                        TraceTag (ttidSvcCtl, "Skipping %S because its start "
                            "type is %d.",
                            apszServices[i],
                            pConfig->dwStartType);
                    }

                    // Free our memory before we continue.
                    //
                    MemFree (pConfig);

                    if (fSkip)
                    {
                        CloseServiceHandle (hSvc);
                        continue;
                    }
                }
            }

            // Initialize fr and dwErr assuming that something goes wrong.
            // fr and dwErr should always be set to something in the following
            // if,else statement.
            //
            fr = FALSE;
            dwErr = ERROR_INVALID_DATA;

            // Start or Control the service if requested.  (Or do nothing
            // if we just want to wait.
            //
            if (pCtx->pFlags->fStart)
            {
                TraceTag (ttidSvcCtl, "Starting %S", apszServices[i]);

                fr = StartService (hSvc, 0, NULL);
                if (!fr)
                {
                    dwErr = GetLastError ();
                }
            }
            else if (pCtx->pFlags->dwControl)
            {
                // Stop dependent services if we're stopping the service.
                //
                if (SERVICE_CONTROL_STOP == pCtx->pFlags->dwControl)
                {
                    // We don't need to worry about the success or failure
                    // of this call here.  It simply recurses into this
                    // function so pCtx->dwErr will be set however we set
                    // it in this function on the next recursion.
                    //
                    StopDependentServices (hSvc, apszServices[i], pCtx);

                    //
                    //  Now handle any special cases
                    //
                    if (0 == _wcsicmp(L"Netbios", apszServices[i]))
                    {
                        TraceTag (ttidSvcCtl, "Running special-case code to stop NetBIOS");
                        ScStopNetbios();
                    }

                    TraceTag (ttidSvcCtl, "Stopping %S", apszServices[i]);
                }

                fr = ControlService (hSvc, pCtx->pFlags->dwControl,
                            &pCtx->status);
                if (!fr)
                {
                    dwErr = GetLastError ();
                }

                TraceTag(ttidSvcCtl,
                        "Just issued control (0x%x) to %S. ret=%u (dwErr=%u), status.dwCurrentState=0x%x",
                        pCtx->pFlags->dwControl,
                        apszServices[i],
                        fr,
                        (!fr) ? dwErr : ERROR_SUCCESS,
                        pCtx->status.dwCurrentState);

                if (!fr)
                {
                    if ((SERVICE_CONTROL_STOP == pCtx->pFlags->dwControl) &&
                        ((ERROR_INVALID_SERVICE_CONTROL == dwErr) ||
                         (ERROR_SERVICE_CANNOT_ACCEPT_CTRL == dwErr)))
                    {
                        if (SERVICE_STOP_PENDING == pCtx->status.dwCurrentState)
                        {
                            TraceTag(ttidSvcCtl,
                                    "Issued stop to service %S which is pending stop",
                                    apszServices[i]);
                            // This is an okay condition.  We want to wait on
                            // this service below.
                            //
                            fr = TRUE;
                            dwErr = ERROR_SUCCESS;
                        }
                    }
                }
            }

            if (fr)
            {
                // We have at least one handle, indicate we may
                // need to wait below and save the handle so the
                // the wait code will use it.
                //
                fWaitIfNeeded = TRUE;
                ahSvc[i] = hSvc;
            }
            else
            {
                Assert (!ahSvc[i]); // don't want to wait on this index
                Assert (ERROR_SUCCESS != dwErr); // obtained above

                if (SERVICE_CONTROL_STOP == pCtx->pFlags->dwControl)
                {
                    // We can ignore service not running errors.
                    //
                    // the first part of the OR is for the service case,
                    // the 2nd handles the driver and service cases respectively.
                    //
                    if ((ERROR_SERVICE_NOT_ACTIVE == dwErr) ||
                        (((ERROR_INVALID_SERVICE_CONTROL == dwErr) ||
                          (ERROR_SERVICE_CANNOT_ACCEPT_CTRL == dwErr)) &&
                         (SERVICE_STOPPED == pCtx->status.dwCurrentState)))
                    {
                        TraceTag(ttidSvcCtl,
                                "Issued stop to service %S which is already stopped",
                                apszServices[i]);
                        dwErr = ERROR_SUCCESS;
                    }
                }
                else if (pCtx->pFlags->fStart)
                {
                    // We can ignore service already running errors.
                    //
                    if (ERROR_SERVICE_ALREADY_RUNNING == dwErr)
                    {
                        TraceTag(ttidSvcCtl,
                                "Issued start to service %S which is already running",
                                apszServices[i]);
                        dwErr = ERROR_SUCCESS;
                    }
                }

                // If we still have an error, time to remember it and move on.
                //
                if (ERROR_SUCCESS != dwErr)
                {
                    // Keep going, but note that we have an error.
                    //
                    pCtx->dwErr = dwErr;

                    TraceHr (ttidError, FAL,
                        HRESULT_FROM_WIN32 (dwErr), FALSE,
                        "SvcControlServicesAndWait: %s (%S)",
                        (pCtx->pFlags->fStart) ?
                            "StartService" : "ControlService",
                        apszServices[i]);
                }

                CloseServiceHandle (hSvc);
            }
        }
#ifdef ENABLETRACE
        else
        {
            TraceHr (ttidError, FAL, HrFromLastWin32Error (), FALSE,
                "SvcControlServicesAndWait: OpenService (%S)",
                apszServices[i]);
        }
#endif
    }

    // For each service, wait for it to enter the requested state
    // (if requested).
    //
    if (fWaitIfNeeded &&
        pCtx->pFlags->dwMaxWaitMilliseconds && pCtx->pFlags->dwStateToWaitFor)
    {
        // We wait in increments of 100 milliseconds.  Therefore, the
        // total number of checks to perform is dwMaxWaitMilliseconds
        // divided by 100 with a minimum of one check.
        //
        const UINT cmsWait = 100;
        UINT cLoop = pCtx->pFlags->dwMaxWaitMilliseconds / cmsWait;
        if (0 == cLoop)
        {
            cLoop = 1;
        }

        // Wait the request number of times...
        // (Assume we timeout)
        //
        dwErr = ERROR_TIMEOUT;
        for (UINT nLoop = 0; nLoop < cLoop; nLoop++, Sleep (cmsWait))
        {
            // Querying the state of the service to see if its entered
            // the requested state.  We can quit the outer loop early
            // if all services have entered the requested state.
            //
            BOOL fAllDone = TRUE;
            for (i = 0; i < cServices; i++)
            {
                // Skip services that have already entered the state or
                // that we never opened.
                //
                if (!ahSvc[i])
                {
                    continue;
                }

                fr = QueryServiceStatus (ahSvc[i], &pCtx->status);
                if (fr)
                {
                    if (pCtx->status.dwCurrentState !=
                        pCtx->pFlags->dwStateToWaitFor)
                    {
                        // Not there yet.  We'll need to check this
                        // again and we now know we're definately not
                        // all done.
                        //
                        fAllDone = FALSE;
                    }
                    else
                    {
                        // No need to check this service anymore,
                        // its in the right state.
                        //
                        CloseServiceHandle (ahSvc[i]);
                        ahSvc[i] = NULL;
                    }
                }
#ifdef ENABLETRACE
                else
                {
                    TraceHr (ttidError, FAL, HrFromLastWin32Error (), FALSE,
                        "SvcControlServicesAndWait: QueryServiceStatus (%S)",
                        apszServices[i]);
                }
#endif
            }

            if (fAllDone)
            {
                dwErr = ERROR_SUCCESS;
                break;
            }
        }

        // If we had an error in the above wait (like a timeout), and
        // we haven't had any prior errors, remember this new one for the
        // caller.
        //
        if ((ERROR_SUCCESS != dwErr) && (ERROR_SUCCESS == pCtx->dwErr))
        {
            pCtx->dwErr = dwErr;
        }
    }

    // Close the remaining open service handles.
    //
    for (i = 0; i < cServices; i++)
    {
        if (ahSvc[i])
        {
            CloseServiceHandle (ahSvc[i]);

#ifdef ENABLETRACE
            if (fWaitIfNeeded &&
                pCtx->pFlags->dwMaxWaitMilliseconds &&
                pCtx->pFlags->dwStateToWaitFor)
            {
                TraceTag (ttidSvcCtl, "%S did not %s within %i milliseconds",
                    apszServices[i],
                    (SERVICE_RUNNING == pCtx->pFlags->dwStateToWaitFor)
                        ? "start" : "stop",
                    pCtx->pFlags->dwMaxWaitMilliseconds);
            }
#endif
        }
    }
}

HRESULT
HrQueryServiceConfigWithAlloc (
    SC_HANDLE               hService,
    LPQUERY_SERVICE_CONFIG* ppConfig)
{
    // Initial guess for the buffer size is the structure size plus
    // room for 5 strings of 32 characters each.  (since there are
    // 5 strings in the structure.)
    //
    static DWORD cbBufGuess = sizeof (QUERY_SERVICE_CONFIG) +
                              5 * (32 * sizeof(WCHAR));

    DWORD                   cbBuf    = cbBufGuess;
    LPQUERY_SERVICE_CONFIG  pConfig  = NULL;
    DWORD                   dwErr    = ERROR_SUCCESS;
    INT                     cLoop    = 0;
    const INT               cLoopMax = 2;

    do
    {
        // If we require more room, allocate the needed space.
        //
        MemFree (pConfig);
        pConfig = (LPQUERY_SERVICE_CONFIG)MemAlloc (cbBuf);
        if (!pConfig)
        {
            dwErr = ERROR_OUTOFMEMORY;
            break;
        }

        BOOL fr = QueryServiceConfig (hService, pConfig, cbBuf, &cbBuf);
        if (fr)
        {
            dwErr = ERROR_SUCCESS;

            // Update our guess for next time to be what QueryServiceConfig
            // says we needed.  But only do so if we needed more than our
            // guess.
            //
            if (cbBuf > cbBufGuess)
            {
                cbBufGuess = cbBuf;
            }
        }
        else
        {
            dwErr = GetLastError ();

#ifdef ENABLETRACE
            if (ERROR_INSUFFICIENT_BUFFER == dwErr)
            {
                TraceTag (ttidSvcCtl,
                    "Perf: Guessed buffer size incorrectly calling "
                    "QueryServiceConfig.\nNeeded %d bytes.  "
                    "(Guessed %d bytes.)",
                    cbBuf,
                    cbBufGuess);
            }
#endif
        }
    }
    while ((ERROR_INSUFFICIENT_BUFFER == dwErr) && (++cLoop < cLoopMax));

    AssertSz (cLoop < cLoopMax, "Why can we never allocate a buffer big "
                "enough for QueryServiceConfig when its telling us how big "
                "the buffer should be?");

    HRESULT hr = HRESULT_FROM_WIN32 (dwErr);
    if (S_OK == hr)
    {
        *ppConfig = pConfig;
    }
    else
    {
        MemFree (pConfig);
        *ppConfig = NULL;
    }

    TraceError ("HrQueryServiceConfigWithAlloc", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrChangeServiceStartType
//
//  Purpose:    Changes the start type of the given service to the given type.
//
//  Arguments:
//      pszServiceName [in]  Name of service to change.
//      dwStartType    [in]  New start type for service. See the Win32
//                           documentation on ChangeServiceConfig for the valid
//                           service start type values.
//
//  Returns:    S_OK if succeeded, HRESULT_FROM_WIN32 error code otherwise.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      Don't call this function too many times. It is fairly
//              inefficient.
//
HRESULT
HrChangeServiceStartType (
    IN PCWSTR pszServiceName,
    IN DWORD dwStartType)
{
    CServiceManager scm;
    CService        svc;

    HRESULT hr = scm.HrOpenService (&svc, pszServiceName, WITH_LOCK);
    if (S_OK == hr)
    {
        hr = svc.HrSetStartType(dwStartType);
    }

    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) == hr,
        "HrChangeServiceStartType");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrChangeServiceStartTypeOptional
//
//  Purpose:    Changes the start type of the given service to the given type.
//
//  Arguments:
//      pszServiceName [in]  Name of service to change.
//      dwStartType    [in]  New start type for service. See the Win32
//                           documentation on ChangeServiceConfig for the valid
//                           service start type values.
//
//  Returns:    S_OK if succeeded, NETCFG_E_SVC_* error otherwise.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      If the service does not exist, nothing is done.
//
HRESULT
HrChangeServiceStartTypeOptional (
    IN PCWSTR pszServiceName,
    IN DWORD dwStartType)
{
    HRESULT hr = HrChangeServiceStartType (pszServiceName, dwStartType);
    if (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) == hr)
    {
        hr = S_OK;
    }
    TraceError ("HrChangeServiceStartTypeOptional", hr);
    return hr;
}

HRESULT
HrSvcQueryStatus (
    IN PCWSTR pszService,
    OUT DWORD* pdwState)
{
    Assert (pszService);
    Assert (pdwState);

    *pdwState = 0;

    CServiceManager scm;
    CService        svc;

    HRESULT hr = scm.HrOpenService (&svc, pszService, NO_LOCK,
                        SC_MANAGER_CONNECT, SERVICE_QUERY_STATUS);
    if (S_OK == hr)
    {
        hr = svc.HrQueryState (pdwState);
    }

    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) == hr,
        "HrSvcQueryStatus");
    return hr;
}

VOID
CService::Close ()
{
    if (_schandle)
    {
        BOOL fr = ::CloseServiceHandle( _schandle );
        AssertSz(fr, "CloseServiceHandle failed!");

        _schandle = NULL;
    }
}

HRESULT
CService::HrControl (
    IN DWORD   dwControl)
{
    Assert (_schandle);

    HRESULT hr = S_OK;

    SERVICE_STATUS status;
    if (!::ControlService (_schandle, dwControl, &status))
    {
        hr = HrFromLastWin32Error ();
    }

    TraceError ("CService::HrControl", hr);
    return hr;
}

HRESULT
CService::HrRequestStop ()
{
    Assert (_schandle);

    HRESULT hr = S_OK;

    SERVICE_STATUS status;
    if (!::ControlService (_schandle, SERVICE_CONTROL_STOP, &status))
    {
        hr = HrFromLastWin32Error ();

        // Don't consider it an error if the service is not running.
        //

        if (HRESULT_FROM_WIN32 (ERROR_SERVICE_NOT_ACTIVE) == hr)
        {
            hr = S_OK;
        }

        // (driver case) ERROR_INVALID_SERVICE_CONTROL is returned if the service
        // is not running - which may mean pending_stop.
        // (non-driver case) ERROR_SERVICE_CANNOT_ACCEPT_CTRL is returned if the
        // service is either stop_pending or stopped.
        // ... so in either case we need to query for the state.
        //
        if (((HRESULT_FROM_WIN32 (ERROR_INVALID_SERVICE_CONTROL) == hr) ||
             (HRESULT_FROM_WIN32 (ERROR_SERVICE_CANNOT_ACCEPT_CTRL) == hr)) &&
            (SERVICE_STOPPED == status.dwCurrentState))
        {
            hr = S_OK;
        }
    }
    TraceError ("CService::HrRequestStop", hr);
    return hr;
}

HRESULT
CService::HrQueryState (
    OUT DWORD*  pdwState)
{
    Assert (pdwState);
    Assert (_schandle);

    SERVICE_STATUS sStatus;
    if (!::QueryServiceStatus( _schandle, &sStatus ))
    {
        *pdwState = 0;
        return ::HrFromLastWin32Error();
    }
    *pdwState = sStatus.dwCurrentState;
    return S_OK;
}

HRESULT
CService::HrQueryStartType (
    OUT DWORD*  pdwStartType)
{
    Assert (pdwStartType);

    *pdwStartType = 0;

    LPQUERY_SERVICE_CONFIG pConfig;
    HRESULT hr = HrQueryServiceConfig (&pConfig);
    if (S_OK == hr)
    {
        *pdwStartType = pConfig->dwStartType;

        MemFree (pConfig);
    }

    TraceError ("CService::HrQueryStartType", hr);
    return hr;
}

HRESULT
CService::HrSetServiceRestartRecoveryOption(
    IN SERVICE_FAILURE_ACTIONS *psfa
      )
{
    HRESULT     hr = S_OK;

    if (!ChangeServiceConfig2(_schandle,
                              SERVICE_CONFIG_FAILURE_ACTIONS,
                              (LPVOID)psfa))
    {
        hr = HrFromLastWin32Error();
    }

    TraceError("CService::HrSetServiceRestartRecoveryOption", hr);
    return hr;
}

CServiceManager::~CServiceManager ()
{
    if (_sclock)
    {
        Unlock();
    }
    if (_schandle)
    {
        Close();
    }
}

VOID
CServiceManager::Close ()
{
    Assert (_schandle);

    BOOL fr = ::CloseServiceHandle (_schandle);
    AssertSz (fr, "CloseServiceHandle failed!");

    _schandle = NULL;
}

HRESULT
CServiceManager::HrControlServicesAndWait (
    IN UINT cServices,
    IN const PCWSTR* apszServices,
    IN const CSFLAGS* pFlags)
{
    Assert (cServices);
    Assert (apszServices);
    Assert (pFlags);

    // Make sure we have something to do before wasting time.
    //
    Assert (   (pFlags->fStart || pFlags->dwControl)
            || (pFlags->dwMaxWaitMilliseconds && pFlags->dwStateToWaitFor));

    HRESULT hr = S_OK;

    if (!_schandle)
    {
        hr = HrOpen (NO_LOCK, SC_MANAGER_CONNECT);
    }

    if (S_OK == hr)
    {
        Assert (_schandle);

        // Setup the context structure and call the internal routine (which
        // may recurse which is why we use the context structure).
        //
        CSCTX ctx;
        ZeroMemory (&ctx, sizeof(ctx));
        ctx.hScm   = _schandle;
        ctx.pFlags = pFlags;
        SvcControlServicesAndWait (&ctx, cServices, apszServices);

        hr = HRESULT_FROM_WIN32 (ctx.dwErr);
    }

    TraceError ("CServiceManager::HrControlServicesAndWait", hr);
    return hr;
}

HRESULT
CServiceManager::HrStartServicesNoWait (
    IN UINT cServices,
    IN const PCWSTR* apszServices)
{
    CSFLAGS flags =
        { TRUE, 0, 0, SERVICE_RUNNING, FALSE };

    HRESULT hr = HrControlServicesAndWait (cServices, apszServices, &flags);

    TraceError ("CServiceManager::HrStartServicesNoWait", hr);
    return hr;
}

HRESULT
CServiceManager::HrStartServicesAndWait (
    IN UINT cServices,
    IN const PCWSTR* apszServices,
    IN DWORD dwWaitMilliseconds /*= 15000*/)
{
    CSFLAGS flags =
        { TRUE, 0, dwWaitMilliseconds, SERVICE_RUNNING, FALSE };

    HRESULT hr = HrControlServicesAndWait (cServices, apszServices, &flags);

    TraceError ("CServiceManager::HrStartServicesAndWait", hr);
    return hr;
}

HRESULT
CServiceManager::HrStopServicesNoWait (
    IN UINT cServices,
    IN const PCWSTR* apszServices)
{
    CSFLAGS flags =
        { FALSE, SERVICE_CONTROL_STOP, 0, SERVICE_STOPPED, FALSE };

    HRESULT hr = HrControlServicesAndWait (cServices, apszServices, &flags);

    TraceError ("CServiceManager::HrStopServicesNoWait", hr);
    return hr;
}

HRESULT
CServiceManager::HrStopServicesAndWait (
    IN UINT cServices,
    IN const PCWSTR* apszServices,
    IN DWORD dwWaitMilliseconds /*= 15000*/)
{
    CSFLAGS flags =
        { FALSE, SERVICE_CONTROL_STOP, dwWaitMilliseconds, SERVICE_STOPPED, FALSE };

    HRESULT hr = HrControlServicesAndWait (cServices, apszServices, &flags);

    TraceError ("CServiceManager::HrStopServicesAndWait", hr);
    return hr;
}

HRESULT
CServiceManager::HrCreateService (
    IN CService* pcsService,
    IN PCWSTR    pszServiceName,
    IN PCWSTR    pszDisplayName,
    IN DWORD     dwServiceType,
    IN DWORD     dwStartType,
    IN DWORD     dwErrorControl,
    IN PCWSTR    pszBinaryPathName,
    IN PCWSTR    pslzDependencies,
    IN PCWSTR    pszLoadOrderGroup,
    IN PDWORD    pdwTagId,
    IN DWORD     dwDesiredAccess,
    IN PCWSTR    pszServiceStartName,
    IN PCWSTR    pszPassword,
    IN PCWSTR    pszDescription)
{
    HRESULT hr = S_OK;

    // Open the service control manager if needed.
    //
    if (!_schandle)
    {
        hr = HrOpen ();
    }

    if (S_OK == hr)
    {
        // make sure the service is not in use
        //
        if (pcsService->_schandle)
        {
            pcsService->Close();
        }
        pcsService->_schandle = ::CreateService (_schandle,
                                    pszServiceName,
                                    pszDisplayName,
                                    dwDesiredAccess,
                                    dwServiceType,
                                    dwStartType,
                                    dwErrorControl,
                                    pszBinaryPathName,
                                    pszLoadOrderGroup,
                                    pdwTagId,
                                    pslzDependencies,
                                    pszServiceStartName,
                                    pszPassword );

        if (!pcsService->_schandle)
        {
            hr = HrFromLastWin32Error ();
        }
        else
        {
            // Set the description is one is supplied
            //
            if (pszDescription)
            {
                SERVICE_DESCRIPTION sd = {0};

                sd.lpDescription = (PWSTR)pszDescription;
                (VOID)ChangeServiceConfig2(pcsService->_schandle,
                                           SERVICE_CONFIG_DESCRIPTION, &sd);
            }
        }
    }
    TraceError ("CServiceManager::HrCreateService", hr);
    return hr;
}

HRESULT
CServiceManager::HrQueryLocked (
    OUT BOOL*   pfLocked)
{
    LPQUERY_SERVICE_LOCK_STATUS pqslStatus = NULL;
    DWORD   cbNeeded = sizeof( QUERY_SERVICE_LOCK_STATUS );
    DWORD   cbSize;
    BOOL    frt;

    Assert(_schandle != NULL );
    Assert(pfLocked != NULL);

    *pfLocked = FALSE;

    // loop, allocating the needed size
    do
    {
        pqslStatus = (LPQUERY_SERVICE_LOCK_STATUS) MemAlloc (cbNeeded);
        if (pqslStatus == NULL)
        {
            return E_OUTOFMEMORY;
        }
        cbSize = cbNeeded;

        frt = ::QueryServiceLockStatus( _schandle,
                pqslStatus,
                cbSize,
                &cbNeeded );
        *pfLocked = pqslStatus->fIsLocked;
        MemFree (pqslStatus);
        pqslStatus = NULL;
        if (!frt && (cbNeeded == cbSize))
        {
            // if an error, treat this as a lock
            return ::HrFromLastWin32Error();
        }

    } while (!frt && (cbNeeded != cbSize));

    return S_OK;
}

HRESULT
CServiceManager::HrLock ()
{
    INT        cRetries   = 30;
    const INT  c_msecWait = 1000;

    Assert (_schandle != NULL);
    Assert (_sclock == NULL);

    while (cRetries--)
    {
        _sclock = ::LockServiceDatabase( _schandle );
        if (_sclock)
        {
            return S_OK;
        }
        else
        {
            HRESULT hr = HrFromLastWin32Error();

            if ((HRESULT_FROM_WIN32(ERROR_SERVICE_DATABASE_LOCKED) != hr) ||
                (0 == cRetries))
            {
                return hr;
            }

            TraceTag(ttidSvcCtl, "SCM is locked, waiting for %d "
                     "seconds before retrying...", c_msecWait / 1000);

            // wait for a bit to see if the database unlocks in that
            // time.
            Sleep (c_msecWait);
        }
    }

    AssertSz (FALSE, "Lock me Amadeus! I'm not supposed to get here!");
    return S_OK;
}

HRESULT
CServiceManager::HrOpen (
    CSLOCK eLock,              // = NO_LOCK
    DWORD dwDesiredAccess,    // = SC_MANAGER_ALL_ACCESS
    PCWSTR pszMachineName,     // = NULL
    PCWSTR pszDatabaseName     // = NULL
    )
{
    HRESULT hr = S_OK;

    if (_schandle)
    {
        Close();
    }
    _schandle = ::OpenSCManager (pszMachineName, pszDatabaseName,
                    dwDesiredAccess );
    if (_schandle)
    {
        if (WITH_LOCK == eLock)
        {
            hr = HrLock ();
        }
    }
    else
    {
        hr = ::HrFromLastWin32Error();
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CServiceManager::HrOpen failed. eLock=%d dwDesiredAccess=0x%08x",
        eLock, dwDesiredAccess);
    return hr;
}

HRESULT
CServiceManager::HrOpenService (
    CService*   pcsService,
    PCWSTR      pszServiceName,
    CSLOCK      eLock,          // = NO_LOCK
    DWORD       dwScmAccess,    // = SC_MANAGER_ALL_ACCESS
    DWORD       dwSvcAccess     // = SERVICE_ALL_ACCESS
    )
{
    HRESULT hr = S_OK;

    // Open the service control manager if needed.
    //
    if (!_schandle)
    {
        hr = HrOpen (eLock, dwScmAccess);
    }

    if (S_OK == hr)
    {
        // make sure the service is not in use
        //
        if (pcsService->_schandle)
        {
            pcsService->Close();
        }

        pcsService->_schandle = ::OpenService (_schandle,
                                    pszServiceName,
                                    dwSvcAccess);
        if (!pcsService->_schandle)
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) == hr),
        "CServiceManager::HrOpenService failed opening '%S'", pszServiceName);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceManager::HrAddRemoveServiceDependency
//
//  Purpose:    Add/remove dependency to a service
//
//  Arguments:
//      pszService [in]     Name of service
//      pszDependency [in]  Dependency to add
//      enumFlag [in]       Indicates add or remove
//
//  Returns:    S_OK if success, Win32 HRESULT otherwise.
//
//  Author:     tongl   17 Jun 1997
//
//  Notes: this function is not for adding/removing group dependency
//
HRESULT
CServiceManager::HrAddRemoveServiceDependency (
    PCWSTR                  pszServiceName,
    PCWSTR                  pszDependency,
    DEPENDENCY_ADDREMOVE    enumFlag)
{
    HRESULT hr = S_OK;

    Assert(pszServiceName);
    Assert(pszDependency);
    Assert((enumFlag == DEPENDENCY_ADD) || (enumFlag == DEPENDENCY_REMOVE));

    // If either string is empty, do nothing
    if (*pszServiceName && *pszDependency)
    {
        hr = HrLock();
        if (S_OK == hr)
        {
            PCWSTR pszSrv = pszDependency;

            CService    svc;
            // Check if the dependency service exists
            hr = HrOpenService(&svc, pszDependency);

            if (S_OK == hr)
            {
                // Open the service we are changing dependency on
                pszSrv = pszServiceName;
                hr = HrOpenService(&svc, pszServiceName);
                if (S_OK == hr)
                {
                    LPQUERY_SERVICE_CONFIG pConfig;
                    hr = svc.HrQueryServiceConfig (&pConfig);
                    if (S_OK == hr)
                    {
                        BOOL fChanged = FALSE;

                        if (enumFlag == DEPENDENCY_ADD)
                        {
                            PWSTR pmszNewDependencies;

                            hr = HrAddSzToMultiSz(
                                    pszDependency,
                                    pConfig->lpDependencies,
                                    STRING_FLAG_DONT_MODIFY_IF_PRESENT |
                                    STRING_FLAG_ENSURE_AT_END, 0,
                                    &pmszNewDependencies,
                                    &fChanged);
                            if ((S_OK == hr) && fChanged)
                            {
                                Assert (pmszNewDependencies);

                                hr = svc.HrSetDependencies (pmszNewDependencies);
                                MemFree (pmszNewDependencies);
                            }
                        }
                        else if (enumFlag == DEPENDENCY_REMOVE)
                        {
                            RemoveSzFromMultiSz(
                                    pszDependency,
                                    pConfig->lpDependencies,
                                    STRING_FLAG_REMOVE_ALL,
                                    &fChanged);
                            if (fChanged)
                            {
                                hr = svc.HrSetDependencies (pConfig->lpDependencies);
                            }
                        }

                        MemFree (pConfig);
                    }
                }
            }

            if (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) == hr) // If either services do not exist
            {
                TraceTag(ttidSvcCtl, "CServiceManager::HrAddServiceDependency, Service %s does not exist.", pszSrv);
                hr = S_OK;
            }

            Unlock();
        }

    } // if szDependency is not empty string

    TraceError("CServiceManager::HrAddRemoveServiceDependency", hr);
    return hr;
}

VOID
CServiceManager::Unlock ()
{
    Assert (_schandle);
    Assert (_sclock);

    BOOL fr = ::UnlockServiceDatabase (_sclock);
    AssertSz (fr, "UnlockServiceDatabase failed!");

    _sclock = NULL;
}
//+---------------------------------------------------------------------------
//
//  Function:   AllocateAndInitializeAcl
//
//  Purpose:    Combine the common operation of allocation and initialization
//              of an ACL.  Similiar to AllocateAndInitializeSid.
//
//  Arguments:
//      cbAcl         [in]  size in bytes of ACL
//      dwAclRevision [in]  ACL_REVISION
//      ppAcl         [out] the returned ACL
//
//  Returns:    TRUE if successful, FALSE if not.
//
//  Author:     shaunco   4 Sep 1997
//
//  Notes:
//
BOOL
AllocateAndInitializeAcl (
    DWORD   cbAcl,
    DWORD   dwAclRevision,
    PACL*   ppAcl)
{
    Assert (ppAcl);
    *ppAcl = reinterpret_cast<PACL>(LocalAlloc (LPTR,
                static_cast<UINT>(cbAcl)));
    if (*ppAcl)
    {
        return InitializeAcl (*ppAcl, cbAcl, dwAclRevision);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncstrs.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S T R S . C P P
//
//  Contents:   Common strings for the various NetCfg projects.
//
//  Notes:
//
//  Author:     danielwe   16 Feb 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

// __declspec(selectany) tells the compiler that the string should be in
// its own COMDAT.  This allows the linker to throw out unused strings.
// If we didn't do this, the COMDAT for this module would reference the
// strings so they wouldn't be thrown out.
//
#define CONST_GLOBAL    extern const DECLSPEC_SELECTANY

CONST_GLOBAL WCHAR c_szRegKeyRefCounts[]        = L"RefCounts";
CONST_GLOBAL WCHAR c_szRegValueComponentId[]    = L"ComponentId";
CONST_GLOBAL WCHAR c_szBusType[]                = L"BusType";

// DLL names and aliases
//
CONST_GLOBAL WCHAR c_szNetCfgDll[]              = L"netcfgx.dll";
CONST_GLOBAL WCHAR c_szNetShellDll[]            = L"netshell.dll";
CONST_GLOBAL WCHAR c_szNetUpgradeDll[]          = L"netupgrd.dll";

// other file names
CONST_GLOBAL WCHAR c_szNetCfgHelpFile[]         = L"netcfg.hlp";

// Delimiters and other globals
CONST_GLOBAL WCHAR c_szEmpty[]                  = L"";
CONST_GLOBAL WCHAR c_szBackslash[]              = L"\\";
CONST_GLOBAL WCHAR c_szSpace[]                  = L" ";
CONST_GLOBAL WCHAR c_szDevice[]                 = L"\\Device\\";
CONST_GLOBAL WCHAR c_szYes[]                    = L"Yes";
CONST_GLOBAL WCHAR c_szNo[]                     = L"No";

// Service names
CONST_GLOBAL WCHAR c_szSvcBrowser[]             = L"Browser";
CONST_GLOBAL WCHAR c_szSvcDhcpRelayAgent[]      = L"RelayAgent";
CONST_GLOBAL WCHAR c_szSvcDhcpServer[]          = L"DHCPServer";
CONST_GLOBAL WCHAR c_szSvcDnscache[]            = L"Dnscache";
CONST_GLOBAL WCHAR c_szSvcLmHosts[]             = L"LmHosts";
CONST_GLOBAL WCHAR c_szSvcLmServer[]            = L"LanmanServer";
CONST_GLOBAL WCHAR c_szSvcMessenger[]           = L"Messenger";
CONST_GLOBAL WCHAR c_szSvcNTLMSsp[]             = L"NtLmSsp";
CONST_GLOBAL WCHAR c_szSvcNWCWorkstation[]      = L"NWCWorkstation";
CONST_GLOBAL WCHAR c_szSvcNwlnkIpx[]            = L"NwlnkIpx";
CONST_GLOBAL WCHAR c_szSvcNetBIOS[]             = L"NetBIOS";
CONST_GLOBAL WCHAR c_szSvcNetLogon[]            = L"NetLogon";
CONST_GLOBAL WCHAR c_szSvcRPCLocator[]          = L"Rpclocator";
CONST_GLOBAL WCHAR c_szSvcRasAuto[]             = L"RasAuto";
CONST_GLOBAL WCHAR c_szSvcRasMan[]              = L"RasMan";
CONST_GLOBAL WCHAR c_szSvcRdbss[]               = L"Rdbss";
CONST_GLOBAL WCHAR c_szSvcRdr[]                 = L"Rdr";
CONST_GLOBAL WCHAR c_szSvcRemoteAccess[]        = L"RemoteAccess";
CONST_GLOBAL WCHAR c_szSvcReplicator[]          = L"Replicator";
CONST_GLOBAL WCHAR c_szSvcRipForIp[]            = L"IpRip";
CONST_GLOBAL WCHAR c_szSvcRipForIpx[]           = L"NwlnkRip";
CONST_GLOBAL WCHAR c_szSvcRouter[]              = L"Router";
CONST_GLOBAL WCHAR c_szSvcRsvp[]                = L"Rsvp";
CONST_GLOBAL WCHAR c_szSvcSapAgent[]            = L"NwSapAgent";
CONST_GLOBAL WCHAR c_szSvcWinsClient[]          = L"NetBT";
CONST_GLOBAL WCHAR c_szSvcWorkstation[]         = L"LanmanWorkstation";

CONST_GLOBAL WCHAR c_szRegKeyCtlLsa[]           = L"System\\CurrentControlSet\\Control\\Lsa";
CONST_GLOBAL WCHAR c_szRegKeyCtlNPOrder[]       = L"System\\CurrentControlSet\\Control\\NetworkProvider\\Order";
CONST_GLOBAL WCHAR c_szRegKeyCtlNetProvider[]   = L"System\\CurrentControlSet\\Control\\NetworkProvider";
CONST_GLOBAL WCHAR c_szRegKeyServices[]         = L"System\\CurrentControlSet\\Services";
CONST_GLOBAL WCHAR c_szProviderOrder[]          = L"ProviderOrder";

CONST_GLOBAL WCHAR c_szRegValDependOnGroup[]    = L"DependOnGroup";
CONST_GLOBAL WCHAR c_szRegValDependOnService[]  = L"DependOnService";
CONST_GLOBAL WCHAR c_szRegValServiceName[]      = L"ServiceName";
CONST_GLOBAL WCHAR c_szRegValStart[]            = L"Start";

// Binding Interface Names
CONST_GLOBAL WCHAR c_szBiNdis4[]                = L"ndis4";
CONST_GLOBAL WCHAR c_szBiNdis5[]                = L"ndis5";
CONST_GLOBAL WCHAR c_szBiNdis5Ip[]              = L"ndis5_ip";
CONST_GLOBAL WCHAR c_szBiNdisAtm[]              = L"ndisatm";
CONST_GLOBAL WCHAR c_szBiNdisBda[]              = L"ndisbda";
CONST_GLOBAL WCHAR c_szBiNdisCoWan[]            = L"ndiscowan";
CONST_GLOBAL WCHAR c_szBiNdisWan[]              = L"ndiswan";
CONST_GLOBAL WCHAR c_szBiNdisWanAsync[]         = L"ndiswanasync";
CONST_GLOBAL WCHAR c_szBiNdisWanAtalk[]         = L"ndiswanatalk";
CONST_GLOBAL WCHAR c_szBiNdisWanBh[]            = L"ndiswanbh";
CONST_GLOBAL WCHAR c_szBiNdisWanIp[]            = L"ndiswanip";
CONST_GLOBAL WCHAR c_szBiNdisWanIpx[]           = L"ndiswanipx";
CONST_GLOBAL WCHAR c_szBiNdisWanNbf[]           = L"ndiswannbf";
CONST_GLOBAL WCHAR c_szBiNdis1394[]             = L"ndis1394";
CONST_GLOBAL WCHAR c_szBiLocalTalk[]            = L"LocalTalk";    // Yes this is a LOWER interface

// <Protocol>\Parameters\Adapters
CONST_GLOBAL WCHAR c_szParameters[]             = L"Parameters";
CONST_GLOBAL WCHAR c_szAdapters[]               = L"Adapters";

// Used by Netsetup and Component's who's answer file references AdapterSections
CONST_GLOBAL WCHAR c_szAdapterSections[]        = L"AdapterSections";
CONST_GLOBAL WCHAR c_szSpecificTo[]             = L"SpecificTo";

#ifdef DBG
//debugging related
CONST_GLOBAL CHAR  c_szDbgBadReadPtrMsg[]              = "Bad read pointer";
CONST_GLOBAL CHAR  c_szDbgBadWritePtrMsg[]             = "Bad write pointer";
#endif


// Net detect dll and functions
CONST_GLOBAL WCHAR c_szNetDetDll[]                      = L"netdet.dll";
CONST_GLOBAL CHAR  c_szaNetDetectRegister[]             = "NetDetectRegister";
CONST_GLOBAL CHAR  c_szaNetDetectDeregister[]           = "NetDetectDeregister";
CONST_GLOBAL CHAR  c_szaNetDetectFindAdapter[]          = "NetDetectFindAdapter";
CONST_GLOBAL CHAR  c_szaNetDetectFreeAdapterInfo[]      = "NetDetectFreeAdapterInfo";


// tcpras.h
CONST_GLOBAL WCHAR c_szNdisWan[]                        =  L"NdisWan";

// Component registry constants
CONST_GLOBAL WCHAR c_szRegKeyInterfacesFromInstance[]   = L"Ndi\\Interfaces";
CONST_GLOBAL WCHAR c_szRegValueLowerRange[]             = L"LowerRange";
CONST_GLOBAL WCHAR c_szRegValueUpperRange[]             = L"UpperRange";

// Device installer related strings
CONST_GLOBAL WCHAR c_szRegValueNetCfgInstanceId[]       = L"NetCfgInstanceID";
CONST_GLOBAL WCHAR c_szRegValuePnpInstanceId[]          = L"PnpInstanceID";

CONST_GLOBAL WCHAR c_szRegKeyComponentClasses[]         = L"SYSTEM\\CurrentControlSet\\Control\\Network";
CONST_GLOBAL WCHAR c_szRegValueInstallerAction[]        = L"InstallerAction";

// Optional component strings
CONST_GLOBAL WCHAR c_szOcMainSection[]                  = L"NetOptionalComponents";

// NWCWorkstation service subkey names
CONST_GLOBAL WCHAR c_szShares[]                         = L"Shares";
CONST_GLOBAL WCHAR c_szDrives[]                         = L"Drives";

CONST_GLOBAL WCHAR c_szRegKeyNt4Adapters[] = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
//#define NOGDI
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// This avoids duplicate definitions with Shell PIDL functions
// and MUST BE DEFINED!
#define AVOID_NET_CONFIG_DUPLICATES

#include <windows.h>
#include <objbase.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <infstr.h>
#include <setupapi.h>
#include <shellapi.h>
#include <wchar.h>

#include "stllist.h"
#include "stlvec.h"
using namespace std;

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C U I . C P P
//
//  Contents:   Common user interface routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include "ncerror.h"
#include "ncstring.h"
#include "ncui.h"
#include "ncperms.h"
#include "netconp.h"

//+---------------------------------------------------------------------------
//
//  Function:   EnableOrDisableDialogControls
//
//  Purpose:    Enable or disable a group of controls all at once.
//
//  Arguments:
//      hDlg    [in] Window handle of parent dialog.
//      ccid    [in] Count of elements in array pointed to by acid.
//      acid    [in] Array of control ids.
//      fEnable [in] TRUE to enable controls, FALSE to disable.
//
//  Returns:    nothing
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      Don't forget to declare your array as 'static const'.
//
NOTHROW
VOID
EnableOrDisableDialogControls (
    IN HWND        hDlg,
    IN INT         ccid,
    IN const INT*  acid,
    IN BOOL        fEnable)
{
    Assert (IsWindow (hDlg));
    Assert (FImplies (ccid, acid));

    while (ccid--)
    {
        EnableWindow (GetDlgItem (hDlg, *acid++), fEnable);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FMapRadioButtonToValue
//
//  Purpose:    Maps the current state of a set of radio buttons to a DWORD
//              value based on a mapping table.
//
//  Arguments:
//      hDlg     [in]  Window handle of parent dialog.
//      crbm     [in]  Count of elements in array pointed to by arbm.
//      arbm     [in]  Array of elements that map a radio button control id to
//                     its associated value.
//      pdwValue [out] The returned value.
//
//  Returns:    TRUE if a radio button was set and the value returned.
//              FALSE otherwise.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      Don't forget to declare your array as 'static const'.
//
NOTHROW
BOOL
FMapRadioButtonToValue (
    IN HWND                    hDlg,
    IN INT                     crbm,
    IN const RADIO_BUTTON_MAP* arbm,
    OUT DWORD*                  pdwValue)
{
    Assert (IsWindow (hDlg));
    Assert (FImplies (crbm, arbm));
    Assert (pdwValue);

    while (crbm--)
    {
        // If it is set, return the corresponding value.
        if (BST_CHECKED & IsDlgButtonChecked (hDlg, arbm->cid))
        {
            *pdwValue = arbm->dwValue;
            return TRUE;
        }

        arbm++;
    }
    *pdwValue = 0;
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FMapValueToRadioButton
//
//  Purpose:    Set the state of a set of radio buttons based on the value of
//              of a DWORD and a mapping table.
//
//  Arguments:
//      hDlg    [in] Window handle of parent dialog.
//      crbm    [in] Count of elements in array pointed to by arbm.
//      arbm    [in] Array of elements that map a radio button control id to
//                   its associated value.
//      dwValue [in] value which gets mapped to set the appropriate radio
//                   button.
//
//  Returns:    TRUE if dwValue was found in the map.  FALSE otherwise.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      Don't forget to declare your array as 'static const'.
//
NOTHROW
BOOL
FMapValueToRadioButton (
    IN HWND                    hDlg,
    IN INT                     crbm,
    IN const RADIO_BUTTON_MAP* arbm,
    IN DWORD                   dwValue,
    IN INT*                    pncid)
{
    Assert (IsWindow (hDlg));
    Assert (FImplies (crbm, arbm));

    while (crbm--)
    {
        if (dwValue == arbm->dwValue)
        {
            // Set the radio button.
            CheckDlgButton (hDlg, arbm->cid, BST_CHECKED);

            // Return the control id if requested.
            if (pncid)
            {
                *pncid = arbm->cid;
            }

            return TRUE;
        }

        arbm++;
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetIntegerFormat
//
//  Purpose:    Uses GetNumberFormat to format an integer number.
//
//  Arguments:
//      Locale            [in]  See Win32 API description of GetNumberFormat.
//      pszValue          [in]
//      pszFormattedValue [out]
//      cchFormattedValue [in]
//
//  Returns:    return value from GetNumberFormat
//
//  Author:     shaunco   4 May 1998
//
//  Notes:
//
INT
GetIntegerFormat (
    IN LCID   Locale,
    IN PCWSTR pszValue,
    OUT PWSTR pszFormattedValue,
    IN INT    cchFormattedValue)
{
    // Format the number for the user's locale and preferences.
    //
    WCHAR szGrouping [16];
    GetLocaleInfo (Locale, LOCALE_SGROUPING,
                   szGrouping, celems(szGrouping));

    WCHAR szDecimalSep [16];
    GetLocaleInfo (Locale, LOCALE_SDECIMAL,
                   szDecimalSep, celems(szDecimalSep));

    WCHAR szThousandSep [16];
    GetLocaleInfo (Locale, LOCALE_STHOUSAND,
                   szThousandSep, celems(szThousandSep));

    NUMBERFMT nf;
    ZeroMemory (&nf, sizeof(nf));
    nf.Grouping      = wcstoul (szGrouping, NULL, 10);
    nf.lpDecimalSep  = szDecimalSep;
    nf.lpThousandSep = szThousandSep;

    return GetNumberFormat (
                    Locale,
                    0,
                    pszValue,
                    &nf,
                    pszFormattedValue,
                    cchFormattedValue);
}

INT
Format32bitInteger (
    IN UINT32  unValue,
    IN BOOL    fSigned,
    OUT PWSTR  pszFormattedValue,
    IN INT     cchFormattedValue)
{
    // Convert the number to a string.
    //
    WCHAR szValue [33];

    *szValue = 0;

    if (fSigned)
    {
        _itow ((INT)unValue, szValue, 10);
    }
    else
    {
        _ultow (unValue, szValue, 10);
    }

    // Format the number according to user locale settings.
    //
    INT cch = GetIntegerFormat (
                LOCALE_USER_DEFAULT,
                szValue,
                pszFormattedValue,
                cchFormattedValue);
    if (!cch)
    {
        TraceHr(ttidError, FAL, HrFromLastWin32Error(), FALSE,
            "GetIntegerFormat failed in Format32bitInteger");

        lstrcpynW (pszFormattedValue, szValue, cchFormattedValue);
        cch = lstrlenW (pszFormattedValue);
    }
    return cch;
}

INT
Format64bitInteger (
    IN UINT64  ulValue,
    IN BOOL    fSigned,
    OUT PWSTR  pszFormattedValue,
    IN INT     cchFormattedValue)
{
    // Convert the number to a string.
    //
    WCHAR szValue [32];

    *szValue = 0;

    if (fSigned)
    {
        _i64tow ((INT64)ulValue, szValue, 10);
    }
    else
    {
        _ui64tow (ulValue, szValue, 10);
    }

    // Format the number according to user locale settings.
    //
    INT cch = GetIntegerFormat (
                LOCALE_USER_DEFAULT,
                szValue,
                pszFormattedValue,
                cchFormattedValue);
    if (!cch)
    {
        TraceHr(ttidError, FAL, HrFromLastWin32Error(), FALSE,
            "GetIntegerFormat failed in Format64bitInteger");

        lstrcpynW (pszFormattedValue, szValue, cchFormattedValue);
        cch = lstrlenW (pszFormattedValue);
    }
    return cch;
}


BOOL
SetDlgItemFormatted32bitInteger (
    IN HWND    hDlg,
    IN INT     nIdDlgItem,
    IN UINT32  unValue,
    IN BOOL    fSigned)
{
    // Format the number according to user locale settings.
    //
    WCHAR szFormattedValue[64];

    Format32bitInteger(
        unValue,
        fSigned,
        szFormattedValue,
        celems(szFormattedValue));

    // Display the number.
    //
    return SetDlgItemText (hDlg, nIdDlgItem, szFormattedValue);
}

BOOL
SetDlgItemFormatted64bitInteger (
    IN HWND    hDlg,
    IN INT     nIdDlgItem,
    IN UINT64  ulValue,
    IN BOOL    fSigned)
{
    // Format the number according to user locale settings.
    //
    WCHAR szFormattedValue[64];

    Format64bitInteger(
        ulValue,
        fSigned,
        szFormattedValue,
        celems(szFormattedValue));

    // Display the number.
    //
    return SetDlgItemText (hDlg, nIdDlgItem, szFormattedValue);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrNcQueryUserForRebootEx
//
//  Purpose:    Query the user to reboot.  If he/she chooses yes, a reboot
//              is initiated.
//
//  Arguments:
//      hwndParent  [in] Parent window handle.
//      pszCaption  [in] Caption text.
//      pszText     [in] Message text.
//      dwFlags     [in] Control flags (QUFR_PROMPT | QUFR_REBOOT)
//
//  Returns:    S_OK if a reboot was requested, S_FALSE if the user
//              didn't want to, or an error code otherwise.
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
HRESULT
HrNcQueryUserForRebootEx (
    IN HWND       hwndParent,
    IN PCWSTR     pszCaption,
    IN PCWSTR     pszText,
    IN DWORD      dwFlags)
{
    HRESULT hr   = S_FALSE;
    INT     nRet = IDYES;

    if (dwFlags & QUFR_PROMPT)
    {
        nRet = MessageBox (hwndParent, pszText, pszCaption,
                           MB_YESNO | MB_ICONEXCLAMATION);
    }

    if (nRet == IDYES)
    {
        if (dwFlags & QUFR_REBOOT)
        {
            TOKEN_PRIVILEGES* ptpOld;
            hr = HrEnableAllPrivileges (&ptpOld);
            if (S_OK == hr)
            {
                if (!ExitWindowsEx (EWX_REBOOT, 10))
                {
                    hr = HrFromLastWin32Error();
                }

                MemFree (ptpOld);
            }
        }
        else
        {
            hr = S_OK;
        }
    }

    TraceError("HrNcQueryUserForRebootEx", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrNcQueryUserForReboot
//
//  Purpose:    Query the user to reboot.  If he/she chooses yes, a reboot
//              is initiated.
//
//  Arguments:
//      hinst       [in] Module instance with string ids.
//      hwndParent  [in] Parent window handle.
//      unIdCaption [in] String id of caption text.
//      unIdText    [in] String id of message text.
//      dwFlags     [in] Control flags (QUFR_PROMPT | QUFR_REBOOT)
//
//  Returns:    S_OK if a reboot is initiated, S_FALSE if the user
//              didn't want to, or an error code otherwise.
//
//  Author:     shaunco   2 Jan 1998
//
//  Notes:
//
HRESULT
HrNcQueryUserForReboot (
    IN HINSTANCE   hinst,
    IN HWND        hwndParent,
    IN UINT        unIdCaption,
    IN UINT        unIdText,
    IN DWORD       dwFlags)
{
    PCWSTR pszCaption = SzLoadString (hinst, unIdCaption);
    PCWSTR pszText    = SzLoadString (hinst, unIdText);

    HRESULT hr = HrNcQueryUserForRebootEx (hwndParent, pszCaption,
                                           pszText, dwFlags);

    TraceError("HrNcQueryUserForReboot", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrShell_NotifyIcon
//
//  Purpose:    HRESULT returning wrapper for Shell_NotifyIcon.
//
//  Arguments:
//      dwMessage [in]
//      pData     [in]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   11 Nov 1998
//
//  Notes:
//
HRESULT
HrShell_NotifyIcon (
    IN DWORD dwMessage,
    IN PNOTIFYICONDATA pData)
{
    HRESULT hr              = E_FAIL; // First time through, this will succeed
    BOOL    fr              = FALSE;
    BOOL    fRetriedAlready = FALSE;
    BOOL    fAttemptRetry   = FALSE;
    INT     iRetries = 0;

    // Attempt the first time, and attempt again after an attempted correction
    //
    while ((hr == E_FAIL) || fAttemptRetry)
    {
        if (fAttemptRetry)
            fRetriedAlready = TRUE;

        fr = Shell_NotifyIcon(dwMessage, pData);
        if (!fr)
        {
            if (dwMessage == NIM_ADD && !fRetriedAlready)
            {
                NOTIFYICONDATA nidDelete;

                ZeroMemory (&nidDelete, sizeof(nidDelete));
                nidDelete.cbSize  = sizeof(NOTIFYICONDATA);
                nidDelete.hWnd    = pData->hWnd;
                nidDelete.uID     = pData->uID;

                Shell_NotifyIcon(NIM_DELETE, &nidDelete);

                fAttemptRetry = TRUE;
                hr = E_FAIL;
            }
            else
            {
                // We should not attempt [a|another] retry
                //
                fAttemptRetry = FALSE;
                hr = S_FALSE;
            }
        }
        else
        {
            fAttemptRetry = FALSE;
            hr = S_OK;
        }
    }

    // At this point, if hr == S_FALSE, it means that we tried to retry, and even that failed
    // We need to convert this to E_FAIL so we still return what we did before
    //
    if (S_FALSE == hr)
    {
        hr = E_FAIL;
    }

    // If we successfully swapped an icon, we should assert and figure out why that
    // went wrong.
    //
    if ((S_OK == hr) && fRetriedAlready)
    {
        TraceTag(ttidShellFolder, "We should debug this. We worked around a duplicate icon by removing "
            "the old one and putting the new one in place");
    }

    TraceError("HrShell_NotifyIcon", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   LresFromHr
//
//  Purpose:    Translates an HRESULT into a valid LRESULT to be returned by
//              a dialog handler function.
//
//  Arguments:
//      hr [in] HRESULT to be translated.
//
//  Returns:    LRESULT
//
//  Author:     danielwe   24 Mar 1997
//
//  Notes:
//
LRESULT
LresFromHr (
    IN HRESULT hr)
{
    AssertSz (((LRESULT)hr) != PSNRET_INVALID, "Don't pass PSNRET_INVALID to "
              "LresFromHr! Use equivalent NETCFG_E_* value instead!");
    AssertSz (((LRESULT)hr) != PSNRET_INVALID_NOCHANGEPAGE, "Don't pass "
              "PSNRET_INVALID_NOCHANGEPAGE to "
              "LresFromHr! Use equivalent NETCFG_E_* value instead!");

    if (NETCFG_E_PSNRET_INVALID == hr)
    {
        return PSNRET_INVALID;
    }

    if (NETCFG_E_PSNRET_INVALID_NCPAGE == hr)
    {
        return PSNRET_INVALID_NOCHANGEPAGE;
    }

    return (SUCCEEDED(hr)) ? PSNRET_NOERROR : (LRESULT)hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   NcMsgBox
//
//  Purpose:    Displays a message box using resource strings and replaceable
//              parameters.
//
//  Arguments:
//      hinst       [in] hinstance for resource strings
//      hwnd        [in] parent window handle
//      unIdCaption [in] resource id of caption string
//      unIdFormat  [in] resource id of text string (with %1, %2, etc.)
//      unStyle     [in] standard message box styles
//      ...         [in] replaceable parameters (optional)
//                          (these must be PCWSTRs as that is all
//                          FormatMessage handles.)
//
//  Returns:    the return value of MessageBox()
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      FormatMessage is used to do the parameter substitution.
//
INT
WINAPIV
NcMsgBox (
    IN HINSTANCE   hinst,
    IN HWND        hwnd,
    IN UINT        unIdCaption,
    IN UINT        unIdFormat,
    IN UINT        unStyle,
    IN ...)
{
    PCWSTR pszCaption = SzLoadString (hinst, unIdCaption);
    PCWSTR pszFormat  = SzLoadString (hinst, unIdFormat);

    PWSTR  pszText = NULL;
    va_list val;
    va_start (val, unStyle);
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                   pszFormat, 0, 0, (PWSTR)&pszText, 0, &val);
    va_end (val);

    INT nRet = MessageBox (hwnd, pszText, pszCaption, unStyle);
    LocalFree (pszText);

    return nRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   NcMsgBoxWithVarCaption
//
//  Purpose:    Same as NcMsgBox, but allows a string parameter to be used
//              for the caption.
//
//  Arguments:
//      hinst           [in] hinstance for resource strings
//      hwnd            [in] parent window handle
//      unIdCaption     [in] resource id of caption string
//      pszCaptionParam [in] string parameter to use for caption
//      unIdFormat      [in] resource id of text string (with %1, %2, etc.)
//      unStyle         [in] standard message box styles
//      ...             [in] replaceable parameters (optional)
//                              (these must be PCWSTRs as that is all
//                              FormatMessage handles.)
//
//  Returns:    the return value of MessageBox()
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:      FormatMessage is used to do the parameter substitution.
//
INT
WINAPIV
NcMsgBoxWithVarCaption (
    HINSTANCE   hinst,
    HWND        hwnd,
    UINT        unIdCaption,
    PCWSTR      pszCaptionParam,
    UINT        unIdFormat,
    UINT        unStyle,
    ...)
{
    PCWSTR pszCaption = SzLoadString (hinst, unIdCaption);
    PCWSTR pszFormat  = SzLoadString (hinst, unIdFormat);

    PWSTR  pszNewCaption = NULL;
    DwFormatStringWithLocalAlloc (pszCaption, &pszNewCaption, pszCaptionParam);

    PWSTR  pszText = NULL;
    va_list val;
    va_start (val, unStyle);
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                   pszFormat, 0, 0, (PWSTR)&pszText, 0, &val);
    va_end (val);

    INT nRet = MessageBox (hwnd, pszText, pszNewCaption, unStyle);
    LocalFree (pszText);
    LocalFree (pszNewCaption);

    return nRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   NcMsgBoxWithWin32ErrorText
//
//  Purpose:    Displays a message box using a Win32 error code, resource
//              strings and replaceable parameters.
//              The output text is a combination of the user's format
//              string (with parameter's replaced) and the Win32 error
//              text as returned from FormatMessage.  These two strings
//              are combined using the IDS_TEXT_WITH_WIN32_ERROR resource.
//
//  Arguments:
//      dwError     [in] Win32 error code
//      hinst       [in] Module instance where string resources live.
//      hwnd        [in] parent window handle
//      unIdCaption [in] resource id of caption string
//      unIdCombineFormat [in] resource id of format string to combine
//                              error text with unIdFormat text.
//      unIdFormat  [in] resource id of text string (with %1, %2, etc.)
//      unStyle     [in] standard message box styles
//      ...         [in] replaceable parameters (optional)
//                          (these must be PCWSTRs as that is all
//                          FormatMessage handles.)
//
//  Returns:    the return value of MessageBox()
//
//  Author:     shaunco   3 May 1997
//
//  Notes:      FormatMessage is used to do the parameter substitution.
//
NOTHROW
INT
WINAPIV
NcMsgBoxWithWin32ErrorText (
    IN DWORD       dwError,
    IN HINSTANCE   hinst,
    IN HWND        hwnd,
    IN UINT        unIdCaption,
    IN UINT        unIdCombineFormat,
    IN UINT        unIdFormat,
    IN UINT        unStyle,
    IN ...)
{
    // Get the user's text with parameter's replaced.
    //
    PCWSTR pszFormat = SzLoadString (hinst, unIdFormat);
    PWSTR  pszText;
    va_list val;
    va_start (val, unStyle);
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                   pszFormat, 0, 0, (PWSTR)&pszText, 0, &val);
    va_end(val);

    // Get the error text for the Win32 error.
    //
    PWSTR pszError;
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL, dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                   (PWSTR)&pszError, 0, NULL);

    // Combine the user's text with the error text using IDS_TEXT_WITH_WIN32_ERROR.
    //
    PCWSTR pszTextWithErrorFmt = SzLoadString (hinst, unIdCombineFormat);
    PWSTR  pszTextWithError;
    DwFormatStringWithLocalAlloc (pszTextWithErrorFmt, &pszTextWithError,
                                  pszText, pszError);

    PCWSTR pszCaption = SzLoadString (hinst, unIdCaption);
    INT nRet = MessageBox (hwnd, pszTextWithError, pszCaption, unStyle);

    LocalFree (pszTextWithError);
    LocalFree (pszError);
    LocalFree (pszText);

    return nRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   SendDlgItemsMessage
//
//  Purpose:    Send a group of dialog items the same message.
//
//  Arguments:
//      hDlg    [in] Window handle of parent dialog.
//      ccid    [in] Count of elements in array pointed to by acid.
//      acid    [in] Array of control ids.
//      unMsg   [in] Message to send
//      wParam  [in] First message parameter
//      lParam  [in] Second message parameter
//
//  Returns:    nothing
//
//  Author:     shaunco   11 Jun 1997
//
//  Notes:
//
VOID
SendDlgItemsMessage (
    IN HWND        hDlg,
    IN INT         ccid,
    IN const INT*  acid,
    IN UINT        unMsg,
    IN WPARAM      wParam,
    IN LPARAM      lParam)
{
    Assert (IsWindow (hDlg));
    Assert (FImplies (ccid, acid));

    while (ccid--)
    {
        Assert (IsWindow (GetDlgItem (hDlg, *acid)));

        SendDlgItemMessage (hDlg, *acid++, unMsg, wParam, lParam);
    }
}

//
// Function:    SetDefaultButton
//
// Purpose:     Set the new default pushbutton on a dialog
//
// Params:      hdlg  [in] - Dialog HWND
//              iddef [in] - Id of new default pushbutton
//
// Returns:     nothing
//
VOID
SetDefaultButton(
    IN HWND hdlg,
    IN INT iddef)
{
    HWND hwnd;
    DWORD dwData;

    Assert(hdlg);

    dwData = SendMessage (hdlg, DM_GETDEFID, 0, 0L);
    if ((HIWORD(dwData) == DC_HASDEFID) && LOWORD(dwData))
    {
        hwnd = GetDlgItem (hdlg, (INT)LOWORD(dwData));
        if ((LOWORD(dwData) != iddef) && (hwnd))
        {
            SendMessage (hwnd, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE);
        }
    }

    SendMessage (hdlg, DM_SETDEFID,(WPARAM)iddef, 0L);
    if (iddef)
    {
        hwnd = GetDlgItem (hdlg, iddef);
        Assert(hwnd);
        SendMessage (hwnd, BM_SETSTYLE, (WPARAM)BS_DEFPUSHBUTTON, TRUE);
    }
}

static const CONTEXTIDMAP c_adwContextIdMap[] =
{
    { IDOK,                   IDH_OK,     IDH_OK  },
    { IDCANCEL,               IDH_CANCEL, IDH_CANCEL },
    { 0,                      0,          0 },      // end marker
};

//+---------------------------------------------------------------------------
//
//  Function:   DwContextIdFromIdc
//
//  Purpose:    Converts the given control ID to a context help ID
//
//  Arguments:
//      idControl [in]  Control ID to convert
//
//  Returns:    Context help ID for that control (mapping comes from help
//              authors)
//
//  Author:     danielwe   27 May 1998
//
//  Notes:
//
DWORD DwContextIdFromIdc(
    PCCONTEXTIDMAP lpContextIdMap,
    BOOL bJpn,
    INT idControl)
{
    DWORD   idw;

    Assert(lpContextIdMap);

    for (idw = 0; lpContextIdMap[idw].idControl; idw++)
    {
        if (idControl == lpContextIdMap[idw].idControl)
        {
            if (!bJpn)
            {
                return lpContextIdMap[idw].dwContextId;
            }
            else
            {
                return lpContextIdMap[idw].dwContextIdJapan;
            }
        }
    }

    // Not found, just return 0
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnHelpGeneric
//
//  Purpose:    Handles help generically
//
//  Arguments:
//      hwnd   [in]     HWND of parent window
//      lParam [in]     lParam of the WM_HELP message
//
//  Returns:    Nothing
//
//  Author:     danielwe   27 May 1998
//              anbrad     18 May 1999 moved to common.  common control id's added.
//
//  Notes:
//
VOID OnHelpGeneric(
    HWND hwnd,
    LPHELPINFO lphi,
    PCCONTEXTIDMAP pContextMap,
    BOOL bJpn,
    PCWSTR pszHelpFile)
{
    static const TCHAR c_szWindowsHelpFile[] = TEXT("windows.hlp");

    Assert(lphi);

    if (lphi->iContextType == HELPINFO_WINDOW)
    {
        switch(lphi->iCtrlId)
        {
        case -1:        // IDC_STATIC
            break;
        case IDOK:
        case IDCANCEL:
        case IDABORT:
        case IDRETRY:
        case IDIGNORE:
        case IDYES:
        case IDNO:
        case IDCLOSE:
        case IDHELP:
            WinHelp(hwnd, c_szWindowsHelpFile, HELP_CONTEXTPOPUP,
                    DwContextIdFromIdc(c_adwContextIdMap, bJpn, lphi->iCtrlId));
            break;
        default:
            WinHelp(hwnd, pszHelpFile, HELP_CONTEXTPOPUP,
                    DwContextIdFromIdc(pContextMap, bJpn, lphi->iCtrlId));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\ncutil.cpp ===
// NCUtility.cpp: implementation of the CNCUtility class.
//
//////////////////////////////////////////////////////////////////////
#include <pch.h>
#pragma hdrstop
#include <tchar.h>
#include <regkysec.h>
#include <ncutil.h>
#include <winsock2.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CNCUtility::CNCUtility()
{
    
}

CNCUtility::~CNCUtility()
{
    
}

HRESULT CNCUtility::SidToString(PCSID pSid, tstring &strSid)
{
    HRESULT hr = S_OK;
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwSidRev=SID_REVISION;
    DWORD dwCounter;
    DWORD dwSidSize;
    LPTSTR strTextualSid = NULL;
    
    // Validate the binary SID.
    
    if(!IsValidSid(const_cast<PSID>(pSid)))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        return hr;
    }
    
    // Get the identifier authority value from the SID.
    
    psia = GetSidIdentifierAuthority(const_cast<PSID>(pSid));
    
    // Get the number of subauthorities in the SID.
    
    dwSubAuthorities = *GetSidSubAuthorityCount(const_cast<PSID>(pSid));
    
    // Compute the buffer length.
    // S-SID_REVISION- + IdentifierAuthority- + subauthorities- + NULL
    
    dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);
    
    strTextualSid = new TCHAR[dwSidSize];
    
    if (!strTextualSid)
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }
    
    // Add 'S' prefix and revision number to the string.
    
    dwSidSize=wsprintf(strTextualSid, TEXT("S-%lu-"), dwSidRev);
    
    // Add SID identifier authority to the string.
    
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        dwSidSize+=wsprintf(strTextualSid + lstrlen(strTextualSid),
            TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
            static_cast<USHORT>(psia->Value[0]),
            static_cast<USHORT>(psia->Value[1]),
            static_cast<USHORT>(psia->Value[2]),
            static_cast<USHORT>(psia->Value[3]),
            static_cast<USHORT>(psia->Value[4]),
            static_cast<USHORT>(psia->Value[5]));
    }
    else
    {
        dwSidSize+=wsprintf(strTextualSid + lstrlen(strTextualSid),
            TEXT("%lu"),
            (static_cast<ULONG>(psia->Value[5]))   +
            (static_cast<ULONG>(psia->Value[4]) <<  8)   +
            (static_cast<ULONG>(psia->Value[3]) << 16)   +
            (static_cast<ULONG>(psia->Value[2]) << 24)   );
    }
    
    // Add SID subauthorities to the string.
    //
    for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        dwSidSize+=wsprintf(strTextualSid + dwSidSize, TEXT("-%lu"),
            *GetSidSubAuthority(const_cast<PSID>(pSid), dwCounter) );
    }
    
    strSid = strTextualSid;
    
    delete[] strTextualSid;
    
    return hr;
}

HRESULT CNCUtility::StringToSid(const tstring strSid, PSID &pSid)
{
    HRESULT hr = S_OK;
    TCHAR seperators[] = _T("-");
    TCHAR *token;
    
    SID_IDENTIFIER_AUTHORITY sia;
    BYTE nSubAuthorityCount;
    DWORD SubAuthorities[8];
    BYTE count = 0;
    DWORD dwTemp;
    LPTSTR lpstrSid = new TCHAR[strSid.length()+1];
    
    ZeroMemory(sia.Value, sizeof (SID_IDENTIFIER_AUTHORITY));
    ZeroMemory(SubAuthorities, 8 * sizeof(DWORD));
    
    
    _tcscpy(lpstrSid, strSid.c_str());
    
    token = _tcstok(lpstrSid, seperators);
    
    if (_tcscmp(token, _T("S")) != 0)
    {
        return 0;
    }
    
    token = _tcstok(NULL, seperators); // Skip the revision
    token = _tcstok(NULL, seperators); // Start the real conversion
    
    while (token != NULL)
    {
        if (count == 0)
        {
            if (token[1] == 'x')
            {
                // > MAXINT
                unsigned int usTemp;
                TCHAR bytes[2];
                
                for (int iCount = 0; iCount < 6; iCount++)
                {
                    _tcsncpy(bytes,(token + iCount + 2),2 * sizeof(TCHAR));
                    usTemp = _ttoi(reinterpret_cast<LPCTSTR>(bytes));
                    sia.Value[iCount] = (unsigned char) usTemp;
                }
            }
            else
            {
                // <= MAXINT
                dwTemp = _ttol(reinterpret_cast<LPCTSTR>(token));
                dwTemp = htonl(dwTemp);
                memmove(sia.Value + 2, &dwTemp, sizeof(dwTemp));
                count++;
            }
        }
        else
        {
            SubAuthorities[count - 1] = _ttol(reinterpret_cast<LPCTSTR>(token));
            count++;
        }
        
        token = _tcstok(NULL, seperators); // get the next string
    }
    
    nSubAuthorityCount = count-1;
    
    if (!AllocateAndInitializeSid(&sia, 
        nSubAuthorityCount, 
        SubAuthorities[0],
        SubAuthorities[1],
        SubAuthorities[2], 
        SubAuthorities[3],
        SubAuthorities[4],
        SubAuthorities[5],
        SubAuthorities[6],
        SubAuthorities[7],
        &pSid))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    
    delete[] lpstrSid;
    
#ifdef DBG
    tstring strSidString;
    SidToString(pSid, strSidString);
    Assert(strSidString == strSid);
#endif
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\regkyexp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       R E G K Y S E C . H
//
//  Contents:   CRegKeySecurity class and related data types
//
//  Notes:
//
//  Author:     ckotze   8 July 2000
//
//---------------------------------------------------------------------------
#include <pch.h>
#pragma hdrstop
#include "regkysec.h"
#include "trnrgsec.h"
#include "regkyexp.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegKeyExplorer::CRegKeyExplorer()
{

}

CRegKeyExplorer::~CRegKeyExplorer()
{

}

//+---------------------------------------------------------------------------
//
//  Function:   GetRegKeyList
//
//  Purpose:    Get a list of all keys and subkeys that we are interested in.
//
//  Arguments:
//
//      rkeBuildFrom        - and array of REGKEYS that contain the relevant
//                            information on how to constuct the keys.
//
//      dwNumEntries        - The number of entries in the above Array.
//
//      listRegKeyEntries   - An output parameter containing a list of all
//                            the keys that need to have their security
//                            modified.
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   8 July 2000
//
//  Notes:
//
HRESULT CRegKeyExplorer::GetRegKeyList(const REGKEYS rkeBuildFrom[], DWORD dwNumEntries, LISTREGKEYDATA &listRegKeyEntries)
{
    REGKEYDATA rkeCurrentKey;

    for (DWORD i = 0; i < dwNumEntries; i++)
    {
        rkeCurrentKey.hkeyRoot = rkeBuildFrom[i].hkeyRoot;
        rkeCurrentKey.strKeyName = rkeBuildFrom[i].strRootKeyName;
        rkeCurrentKey.amMask = rkeBuildFrom[i].amMask;
        rkeCurrentKey.kamMask = rkeBuildFrom[i].kamMask;

        listRegKeyEntries.insert(listRegKeyEntries.end(), rkeCurrentKey);

        if (rkeBuildFrom[i].bEnumerateRelativeEntries)
        {
            EnumerateKeysAndAddToList(rkeBuildFrom[i], listRegKeyEntries);
        }
    }
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   EnumerateKeysAndAddToList
//
//  Purpose:    Enumerates all direct children and adds them and the required
//              permission to the list.
//
//  Arguments:  
//      rkeCurrent        - the current key.
//
//      listRegKeyEntries - Output parameter containing the list of keys to be
//                          changed
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   8 July 2000
//
//  Notes:
//
HRESULT CRegKeyExplorer::EnumerateKeysAndAddToList(REGKEYS rkeCurrent, LISTREGKEYDATA &listRegKeyEntries)
{
    HKEY hkeyCurrent;
    DWORD dwIndex = 0;
    LONG lErr = ERROR_SUCCESS;
    LPTSTR szSubkeyName;
    LPTSTR szSubKeyExpandedName;
    DWORD cbName = MAX_PATH + 1;
    REGKEYDATA rkeSubKey;

    if (ERROR_SUCCESS == (lErr = RegOpenKeyEx(rkeCurrent.hkeyRoot, rkeCurrent.strRootKeyName, 0, KEY_READ, &hkeyCurrent)))
    {
        szSubkeyName = new TCHAR[MAX_PATH + 1];

        if (!szSubkeyName)
        {
            return E_OUTOFMEMORY;
        }

        szSubKeyExpandedName = new TCHAR[MAX_PATH + 1];

        if (!szSubKeyExpandedName)
        {
            delete[] szSubkeyName;
            
            return E_OUTOFMEMORY;
        }

        do
        {
            ZeroMemory(szSubkeyName, (MAX_PATH + 1) * sizeof(TCHAR));
            ZeroMemory(szSubKeyExpandedName, (MAX_PATH + 1) * sizeof(TCHAR));

            lErr = RegEnumKey(hkeyCurrent, dwIndex++, szSubkeyName, cbName);

            if (ERROR_SUCCESS == lErr)
            {

                wsprintf(szSubKeyExpandedName, rkeCurrent.strRelativeKey, szSubkeyName);

                rkeSubKey.hkeyRoot = rkeCurrent.hkeyRelativeRoot;
                rkeSubKey.strKeyName = szSubKeyExpandedName;
                rkeSubKey.amMask = rkeCurrent.amChildMask;
                rkeSubKey.kamMask = rkeCurrent.kamChildMask;
                listRegKeyEntries.insert(listRegKeyEntries.end(), rkeSubKey);
            }
        }
        while (ERROR_SUCCESS == lErr);

        RegCloseKey(hkeyCurrent);

        delete[] szSubKeyExpandedName;
        delete[] szSubkeyName;

        if (ERROR_NO_MORE_ITEMS != lErr)
        {
            return HRESULT_FROM_WIN32(lErr);
        }
    }
    else
    {
        return HRESULT_FROM_WIN32(lErr);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\pidlutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P I D L . C P P
//
//  Contents:   PIDL utility routines. This stuff is mainly copied from the
//              existing Namespace extension samples and real code, since
//              everyone and their gramma uses this stuff.
//
//  Notes:
//
//  Author:     jeffspr   1 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "shlobj.h"
#include "shlobjp.h"

#include "pidlutil.h"

#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   ILNext
//
//  Purpose:    Return the next PIDL in the list
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST ILNext(LPCITEMIDLIST pidl)
{
    if (pidl)
    {
        pidl = (LPITEMIDLIST) ((BYTE *)pidl + pidl->mkid.cb);
    }

    return (LPITEMIDLIST)pidl;
}


//+---------------------------------------------------------------------------
//
//  Function:   ILIsEmpty
//
//  Purpose:    Is this PIDL empty
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
BOOL ILIsEmpty(LPCITEMIDLIST pidl)
{
   return (!pidl || !pidl->mkid.cb);

}
#endif // #if DBG

//+---------------------------------------------------------------------------
//
//  Function:   ILGetSizePriv
//
//  Purpose:    Return the size of a pidl.
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
UINT ILGetSizePriv(LPCITEMIDLIST pidl)
{
   UINT cbTotal = 0;

   if (pidl)
   {
        cbTotal += sizeof(pidl->mkid.cb);       // Null terminator
        while (pidl->mkid.cb)
        {
            cbTotal += pidl->mkid.cb;
            pidl = ILNext(pidl);
        }
    }

    return cbTotal;
}

//+---------------------------------------------------------------------------
//
//  Function:   ILCreate
//
//  Purpose:    Create a PIDL
//
//  Arguments:
//      cbSize []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST ILCreate(DWORD dwSize)
{
   LPITEMIDLIST pidl = (LPITEMIDLIST) SHAlloc(dwSize);

   return pidl;
}

VOID FreeIDL(LPITEMIDLIST pidl)
{
    Assert(pidl);

    SHFree(pidl);
}


//+---------------------------------------------------------------------------
//
//  Function:   ILIsSingleID
//
//  Purpose:    Returns TRUE if the idlist has just one ID in it.
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
BOOL ILIsSingleID(LPCITEMIDLIST pidl)
{
    if (pidl == NULL)
        return FALSE;

    return (pidl->mkid.cb == 0 || ILNext(pidl)->mkid.cb == 0);
}


//+---------------------------------------------------------------------------
//
//  Function:   ILGetCID
//
//  Purpose:    Returns the number of ID's in the list.
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
UINT ILGetCID(LPCITEMIDLIST pidl)
{
    UINT cid = 0;

    while (!ILIsEmpty(pidl))
    {
        ++ cid;
        pidl = ILNext(pidl);
    }

    return cid;
}


//+---------------------------------------------------------------------------
//
//  Function:   ILGetSizeCID
//
//  Purpose:    Get the length of the first cid items in a pidl.
//
//  Arguments:
//      pidl []
//      cid  []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
UINT ILGetSizeCID(LPCITEMIDLIST pidl, UINT cid)
{
    UINT cbTotal = 0;

    if (pidl)
    {
        cbTotal += sizeof(pidl->mkid.cb);       // Null terminator

        while (cid && !ILIsEmpty(pidl))
        {
            cbTotal += pidl->mkid.cb;
            pidl = ILNext(pidl);
            -- cid;
        }
    }

    return cbTotal;
}


//+---------------------------------------------------------------------------
//
//  Function:   CloneIDLFirstCID
//
//  Purpose:    Make a new list consisting of only the first cid items on
//              an existing list.
//
//  Arguments:
//      pidl []
//      cid  []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST CloneIDLFirstCID(LPCITEMIDLIST pidl, UINT cid)
{
    Assert((INT)cid >= 0);

    UINT            cb      = ILGetSizeCID(pidl, cid);
    LPITEMIDLIST    pidlRet = (LPITEMIDLIST) SHAlloc(cb);

    if (pidlRet)
    {
        // Notes: no need to zero-init.
        // Also, do not copy the NULL terminator.
        memcpy (pidlRet, pidl, cb - sizeof(pidl->mkid.cb));

        LPITEMIDLIST pidlTerm = pidlRet;

        // Cannot test for NULL terminator, we have not terminated
        // the list yet.
        //
        while (cid)
        {
            pidlTerm = ILNext(pidlTerm);
            -- cid;
        }

        pidlTerm->mkid.cb = 0;
    }

    return pidlRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   ILSkipCID
//
//  Purpose:    Skips the first cid items in a pidl.
//
//  Arguments:
//      pidl []
//      cid  []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST ILSkipCID(LPCITEMIDLIST pidl, UINT cid)
{
    Assert((INT)cid >= 0);

    while (cid && !ILIsEmpty(pidl))
    {
        pidl = ILNext(pidl);
        -- cid;
    }

    return (LPITEMIDLIST)pidl;
}

//+---------------------------------------------------------------------------
//
//  Function:   ILCombinePriv
//
//  Purpose:    Combine two PIDLs
//
//  Arguments:
//      pidl1 []
//      pidl2 []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST ILCombinePriv(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPITEMIDLIST    pidlNew     = NULL;
    // Let me pass in NULL pointers
    if (!pidl1)
    {
        if (!pidl2)
        {
            pidlNew = NULL;
        }
        else
        {
            pidlNew = CloneIDL(pidl2);
        }
    }
    else
    {
        if (!pidl2)
        {
            pidlNew = CloneIDL(pidl1);
        }
        else
        {
            UINT cb1 = ILGetSizePriv(pidl1) - sizeof(pidl1->mkid.cb);
            UINT cb2 = ILGetSizePriv(pidl2);

            pidlNew = ILCreate(cb1 + cb2);
            if (pidlNew)
            {
                memcpy(pidlNew, pidl1, cb1);
                memcpy((PWSTR)(((LPBYTE)pidlNew) + cb1), pidl2, cb2);
                Assert (ILGetSizePriv(pidlNew) == cb1+cb2);
            }
        }
    }

    return pidlNew;
}


#if 0
BOOL ILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    if (FSetupGlobalShellFolders())
    {
        LPSHELLFOLDER psfDesktop = (LPSHELLFOLDER) PvGlobGet (ipsfDesktop);
        if (psfDesktop)
        {
            VERIFYPTR(pidl1, FALSE);
            VERIFYPTR(pidl2, FALSE);

            return psfDesktop->CompareIDs(0, pidl1, pidl2) == ResultFromShort(0);
        }
    }
    return FALSE;
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:   CloneIDL
//
//  Purpose:    Clone an IDL (return a duplicate)
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST CloneIDL(LPCITEMIDLIST pidl)
{
    UINT            cb      = 0;
    LPITEMIDLIST    pidlRet = NULL;

    if (pidl)
    {
        cb = ILGetSizePriv(pidl);

        pidlRet = (LPITEMIDLIST) SHAlloc(cb);
        if (pidlRet)
        {
            memcpy(pidlRet, pidl, cb);
        }
    }

    return pidlRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   ILFindLastIDPriv
//
//  Purpose:    Find the last ID in an IDL
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST ILFindLastIDPriv(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlLast = pidl;
    LPCITEMIDLIST pidlNext = pidl;

    Assert(pidl);

    // Find the last one in the list
    //
    while (pidlNext->mkid.cb)
    {
        pidlLast = pidlNext;
        pidlNext = ILNext(pidlLast);
    }

    return (LPITEMIDLIST)pidlLast;
}

//+---------------------------------------------------------------------------
//
//  Function:   ILRemoveLastIDPriv
//
//  Purpose:    Remove the last ID from an IDL
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997
//
//  Notes:
//
BOOL ILRemoveLastIDPriv(LPITEMIDLIST pidl)
{
    BOOL    fRemoved = FALSE;

    Assert(pidl);

    if (pidl->mkid.cb)
    {
        LPITEMIDLIST pidlLast = (LPITEMIDLIST)ILFindLastIDPriv(pidl);

        Assert(pidlLast->mkid.cb);
        Assert(ILNext(pidlLast)->mkid.cb==0);

        // Remove the last one
        pidlLast->mkid.cb = 0; // null-terminator
        fRemoved = TRUE;
    }

    return fRemoved;
}

//+---------------------------------------------------------------------------
//
//  Function:   CloneRgIDL
//
//  Purpose:    Clone a pidl array
//
//  Arguments:
//      rgpidl              [in]    PIDL array to clone
//      cidl                [in]    Count of the pidl array
//      fUseCache           [in]    If TRUE, generate the returned IDL from the cache
//      fAllowNonCacheItems [in]    Use old version of pidl if cached version non available
//      pppidl              [out]   Return pointer for pidl array
//
//  Returns:
//
//  Author:     jeffspr   22 Oct 1997
//
//  Notes:
//
/*
HRESULT HrCloneRgIDL(
    LPCITEMIDLIST * rgpidl,
    ULONG           cidl,
    BOOL            fUseCache,
    BOOL            fAllowNonCacheItems,
    LPITEMIDLIST ** pppidl,
    ULONG *         pcidl)
{
    HRESULT         hr              = NOERROR;
    LPITEMIDLIST *  rgpidlReturn    = NULL;
    ULONG           irg             = 0;
    ULONG           cidlCopied      = 0;

    Assert(pppidl);
    Assert(pcidl);
    Assert(rgpidl);

    if (!rgpidl || !cidl)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
    else
    {
        // Alloc the return buffer
        //
        rgpidlReturn = (LPITEMIDLIST *) SHAlloc(cidl * sizeof(LPITEMIDLIST));
        if (!rgpidlReturn)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        else
        {
            // Clone all elements within the passed in PIDL array
            //
            for (irg = 0; irg < cidl; irg++)
            {
                if (rgpidl[irg])
                {
                    if (fUseCache)
                    {
                        PCONNLISTENTRY  pcle    = NULL;
                        PCONFOLDPIDL    pcfp    = (PCONFOLDPIDL) rgpidl[irg];

                        hr = g_ccl.HrFindConnectionByGuid(&(pcfp->guidId), &pcle);
                        if (hr == S_OK)
                        {
                            Assert(pcle);
                            Assert(pcle->pccfe);

                            // Copy to the return pidl array.
                            hr = HrConFoldEntryToPidl(pcle->pccfe, &(rgpidlReturn[cidlCopied++]));
                            if (FAILED(hr))
                                goto Exit;
                        }
                        else
                        {
                            TraceTag(ttidShellFolder, "HrCloneRgIDL: Connection find returned: 0x%08x", hr);

                            if (hr == S_FALSE)
                            {
                                if (fAllowNonCacheItems)
                                {
                                    TraceTag(ttidShellFolder, "HrCloneRgIDL: Connection not found in cache, "
                                             "using non-cache item");

                                    rgpidlReturn[cidlCopied++] = CloneIDL((LPITEMIDLIST)rgpidl[irg]);
                                    if (!rgpidlReturn[irg])
                                    {
                                        hr = E_OUTOFMEMORY;
                                        goto Exit;
                                    }
                                }
                                else
                                {
                                    TraceTag(ttidShellFolder, "HrCloneRgIDL: Connection not found in cache. "
                                             "Dropping item from array");
                                }
                            }
                            else
                            {
                                AssertSz(FALSE, "HrCloneRgIDL: Connection find HR_FAILED");
                            }
                        }
                    }
                    else
                    {
                        // Clone this element in the PIDL array
                        //
                                    rgpidlReturn[cidlCopied++] = CloneIDL ((LPITEMIDLIST) rgpidl[irg]);
                                    if (!rgpidlReturn[irg])
                                    {
                            hr = E_OUTOFMEMORY;
                            goto Exit;
                                    }
                    }
                }
                else
                {
                    // Make sure that we don't try to delete bogus data later.
                    //
                    rgpidlReturn[cidlCopied++] = NULL;

                    AssertSz(FALSE, "Bogus element in the rgpidl in HrCloneRgIDL");
                    hr = E_INVALIDARG;
                    goto Exit;
                }
            }
        }
    }

Exit:
    if (FAILED(hr))
    {
        // Free the already-allocated IDLISTs
        //
        ULONG irgT = 0;

        for (irgT = 0; irgT < irg; irgT++)
        {
            if (rgpidlReturn[irgT])
            {
                FreeIDL(rgpidlReturn[irgT]);
            }
        }

        SHFree(rgpidlReturn);
        *pppidl = NULL;
    }
    else
    {
        // Fill in the return var.
        //
        *pppidl = rgpidlReturn;
        *pcidl = cidlCopied;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrCloneRgIDL");
    return hr;

}       //  CloneRgIDL
*/


//+---------------------------------------------------------------------------
//
//  Function:   FreeRgIDL
//
//  Purpose:    Free a PIDL array
//
//  Arguments:
//      cidl  [in]  Size of PIDL array
//      apidl [in]  Pointer to the array itself.
//
//  Returns:
//
//  Author:     jeffspr   27 Oct 1997
//
//  Notes:
//
VOID FreeRgIDL(
    UINT            cidl,
    LPITEMIDLIST  * apidl)
{
    if (apidl)
    {
        for (UINT i = 0; i < cidl; i++)
        {
            FreeIDL(apidl[i]);
        }

        SHFree(apidl);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncdebug\benchmrk.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       B E N C H M R K . C P P
//
//  Contents:   Benchmarking class
//
//  Notes:
//
//  Author:     billbe   13 Oct 1997
//
//---------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "benchmrk.h"

CBenchmark::CBenchmark()
: m_i64Frequency(1000),
  m_sznDescription(NULL),
  m_i64TotalTime(0),
  m_fStarted(FALSE)
{
    LARGE_INTEGER li1;

    // Check if QueryPerformanceCounter is supported
    if (QueryPerformanceCounter(&li1))
    {
        // Now get # of ticks per second
        QueryPerformanceFrequency(reinterpret_cast<LARGE_INTEGER*>
                (&m_i64Frequency));

        m_fSupported = TRUE;
    }
    else
    {
        TraceTag(ttidBenchmark, "High performance counter is not supported.");
        m_fSupported = FALSE;
    }
}

CBenchmark::~CBenchmark()
{
    delete [] m_sznDescription;
}


void
CBenchmark::Start(PCSTR sznDescription)
{
    // If QueryPerformanceCounter is supported
    if (m_fSupported)
    {
        // delete the old description
        delete [] m_sznDescription;

        // replace with new one if specified
        if (sznDescription)
        {
            m_sznDescription = new CHAR[strlen(sznDescription) + 1];
            if (m_sznDescription)
            {
                strcpy(m_sznDescription, sznDescription);
            }
        }
        else
        {
            // no description specified clear the member variable
            m_sznDescription = NULL;
        }
        m_fStarted = TRUE;
        m_i64TotalTime = 0;

        // Record our start time
        QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>
                (&m_i64StartTime));
    }
}

void
CBenchmark::Stop()
{
    __int64 i64Stop;
    // Record our stop time
    QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&i64Stop));

    // If start was called prior to stop, then record the total time and
    // reset our m_fStarted flag
    //
    if (m_fStarted)
    {
        m_fStarted = FALSE;
        m_i64TotalTime = i64Stop - m_i64StartTime;
    }
    else
    {
        // invalidate previous benchmark since stop was called before start
        m_i64TotalTime = 0;
    }
}

PCSTR
CBenchmark::SznBenchmarkSeconds(unsigned short usPrecision)
{
    CHAR sznFmt[10];
    sprintf(sznFmt, "%%.%df", usPrecision);
    sprintf(m_sznSeconds, sznFmt, DblBenchmarkSeconds());
    return m_sznSeconds;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\regkysec.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       RegKeySecurity.cpp
//
//  Contents:   Provides code for changes to Regkey Security
//              
//
//  Notes:
//
//  Author:     ckotze   4 July 2000
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include <ncreg.h>
#include <regkysec.h>
#include <ncutil.h>
#include <ncdebug.h>

//+---------------------------------------------------------------------------
//
//  Function:   CRegKeySecurity constructor
//
//  Purpose:    
//
//  Arguments:
//
//  Returns:    
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
CRegKeySecurity::CRegKeySecurity() : m_psdRegKey(NULL), m_bDaclDefaulted(FALSE), m_hkeyCurrent(0), 
m_paclDacl(NULL), m_bHasDacl(FALSE), m_psidGroup(NULL), m_psidOwner(NULL), m_paclSacl(NULL), m_bHasSacl(FALSE)
{
    
}

//+---------------------------------------------------------------------------
//
//  Function:   CRegKeySecurity destructor
//
//  Purpose:    
//
//  Arguments:
//
//  Returns:    
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
CRegKeySecurity::~CRegKeySecurity()
{
    if (m_psdRegKey)
    {
        delete[] m_psdRegKey;
    }
    
    RegCloseKey();
    
    m_listAllAce.clear();
}

//+---------------------------------------------------------------------------
//
//  Function:   RegOpenKey
//
//  Purpose:    Opens the Registry Key with enough privileges to set the 
//              permission on the Key.
//
//  Arguments:  
//          hkeyRoot    - the root key from which to open the subkey
//
//          strKeyName  - the subkey to open.
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CRegKeySecurity::RegOpenKey(const HKEY hkeyRoot, LPCTSTR strKeyName)
{
    LONG lResult = 0;
    DWORD dwRightsRequired = KEY_ALL_ACCESS;

    if (m_hkeyCurrent)
    {
        RegCloseKey();
    }

    if ((lResult = HrRegOpenKeyEx(hkeyRoot, strKeyName, dwRightsRequired, &m_hkeyCurrent)) != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(lResult);
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetKeySecurity
//
//  Purpose:    Retrieves the Security Descriptor for the currently open 
//              Registry key.
//
//  Arguments:  None
//
//          
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CRegKeySecurity::GetKeySecurity()
{
    HRESULT hr = S_OK;
    DWORD cbSD = 1;  // try a size that won't be large enough
    LONG lResult;

    if (!m_hkeyCurrent)
    {
        TraceError("CRegKeySecurity::GetKeySecurity", E_UNEXPECTED);
        return E_UNEXPECTED;
    }

    // First call should get the correct size.

    if ((hr = HrRegGetKeySecurity(m_hkeyCurrent, OWNER_SECURITY_INFORMATION | 
        GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
        &m_psdRegKey, &cbSD)) != S_OK)
    {
        if (m_psdRegKey)
        {
            delete[] m_psdRegKey;
        }
        
        if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
        {

            m_psdRegKey = reinterpret_cast<PSECURITY_DESCRIPTOR>(new BYTE[cbSD]);

            hr = HrRegGetKeySecurity(m_hkeyCurrent, OWNER_SECURITY_INFORMATION | 
                GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                m_psdRegKey, &cbSD);
        }
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetKeySecurity
//
//  Purpose:    Updates the Security Descriptor of the currently open key.
//
//
//  Arguments:  None
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CRegKeySecurity::SetKeySecurity()
{
    HRESULT hr = S_OK;
    
    if ((hr = HrRegSetKeySecurity(m_hkeyCurrent, OWNER_SECURITY_INFORMATION 
        | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION, m_psdRegKey)) != S_OK)
    {
        TraceError("CRegKeySecurity::SetKeySecurity", hr);
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegCloseKey
//
//  Purpose:    Closes the currently open registry key.
//              
//
//  Arguments:  None
//
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CRegKeySecurity::RegCloseKey()
{
    HRESULT hr = S_OK;

    if (m_hkeyCurrent)
    {
        LONG err;

        err = ::RegCloseKey(m_hkeyCurrent);

        hr = HRESULT_FROM_WIN32(err);
    
        m_hkeyCurrent = 0;
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSecurityDescriptorDacl
//
//  Purpose:    Retrieve the Discretionary Access Control List from the SD
//              
//
//  Arguments:  
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CRegKeySecurity::GetSecurityDescriptorDacl()
{
    HRESULT hr = S_OK;
    
    if (!m_psdRegKey)
    {
        return E_UNEXPECTED;
    }
    
    if (!::GetSecurityDescriptorDacl(m_psdRegKey, 
        (LPBOOL)&m_bHasDacl, 
        (PACL *)&m_paclDacl, 
        (LPBOOL)&m_bDaclDefaulted))
    {
        DWORD dwErr;

        dwErr = GetLastError();

        hr = HRESULT_FROM_WIN32(dwErr);
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetSecurityDescriptorDacl
//
//  Purpose:    Update the Discretionary Access Control List in the SD
//              
//
//  Arguments:  
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CRegKeySecurity::SetSecurityDescriptorDacl(PACL paclDacl, DWORD dwNumEntries)
{
    HRESULT hr = E_FAIL;
    DWORD dwErr = 0;
    SECURITY_DESCRIPTOR psdSD = {0};
    
    SECURITY_DESCRIPTOR_CONTROL pSDCControl;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    PSID psidOwner = NULL;
    PSID psidGroup = NULL;
    DWORD dwSDSize = sizeof(psdSD);
    DWORD dwOwnerSIDSize = 0;
    DWORD dwGroupSIDSize = 0;
    DWORD cbDacl = 0;
    DWORD cbSacl = 0;
    DWORD dwRevision = 0;
    
    if (!paclDacl)
    {
        return E_INVALIDARG;
    }
    
    if (GetSecurityDescriptorControl(m_psdRegKey, &pSDCControl, &dwRevision))
    {
        if (SE_SELF_RELATIVE & pSDCControl)
        {
            if (!MakeAbsoluteSD(m_psdRegKey, &psdSD, &dwSDSize, pDacl, &cbDacl, pSacl, &cbSacl, psidOwner, &dwOwnerSIDSize, psidGroup, &dwGroupSIDSize))
            {
                pDacl = reinterpret_cast<PACL>(new BYTE[cbDacl]);

                if (!pDacl)
                {
                    return E_OUTOFMEMORY;
                }

                psidOwner = new BYTE[dwOwnerSIDSize];

                if (!psidOwner)
                {
                    delete[] pDacl;
                    
                    return E_OUTOFMEMORY;
                }

                psidGroup = new BYTE[dwGroupSIDSize];
                
                if (!psidGroup)
                {
                    delete[] pDacl;
                    delete[] psidOwner;
                    
                    return E_OUTOFMEMORY;
                }
                else if (MakeAbsoluteSD(m_psdRegKey, &psdSD, &dwSDSize, pDacl, &cbDacl, pSacl, &cbSacl, psidOwner, &dwOwnerSIDSize, psidGroup, &dwGroupSIDSize))
                {
                    if (!::SetSecurityDescriptorDacl(&psdSD, m_bHasDacl, paclDacl, m_bDaclDefaulted))
                    {
                        dwErr = GetLastError();
                    }
                    if (!MakeSelfRelativeSD(&psdSD, m_psdRegKey, &dwSDSize) && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                    {
                        if (m_psdRegKey)
                        {
                            delete[] m_psdRegKey;
                        }
                        
                        m_psdRegKey = reinterpret_cast<PSECURITY_DESCRIPTOR>(new BYTE[dwSDSize]);
                        
                        if (MakeSelfRelativeSD(&psdSD, m_psdRegKey, &dwSDSize))
                        {
                            hr = S_OK;
                            SetLastError(0);
                            m_paclDacl = NULL;
                        }
                    }
                }
                
                delete[] pDacl;
                delete[] psidOwner;
                delete[] psidGroup;
                
            }
        }
    }
    else
    {
        DWORD dwErr;

        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GrantRightsOnRegKey
//
//  Purpose:    Add the specified account to the ACL with the permissions
//              required and the inheritance information.
//
//  Arguments:  
//          psidUserOrGroup     - The sid (Security Identifier) of the user to 
//                                be added.
//          amPermissionMask    - The permissions to be granted.
//          
//          kamMask             - Applies to this key or child keys or both?
//                                
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CRegKeySecurity::GrantRightsOnRegKey(PCSID psidUserOrGroup, ACCESS_MASK amPermissionsMask, KEY_APPLY_MASK kamMask)
{
    HRESULT hr = E_FAIL;
    PACCESS_ALLOWED_ACE					paaAllowedAce = NULL;
    PACCESS_DENIED_ACE                  paaDeniedAce = NULL;
    BOOL                                bAceMatch = FALSE;
    BYTE                                cAceFlags = 0;
    DWORD                               cbAcl = 0;
    DWORD                               cbAce = 0;
    
    if (!IsValidSid(const_cast<PSID>(psidUserOrGroup)))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_SID);
    }
    
    hr = GetAccessControlEntriesFromAcl();
    
    if (FAILED(hr))
    {
        return hr;
    }
    
    cbAcl = sizeof(ACL);
    
    for (ACEITER i = m_listAllAce.begin(); i != m_listAllAce.end() ; i++)
    {
        CAccessControlEntry paEntry(*i);
        
        cbAcl += sizeof(ACCESS_ALLOWED_ACE) + 8 +
            paEntry.GetLengthSid()- sizeof(DWORD);
        
        // Assert(kamMask)
        
        switch (kamMask)
        {
        case KEY_CURRENT:
            {
                cAceFlags = 0;  // Do not allow this to be inherited by children.
                break;
            }
        case KEY_CHILDREN:
            {
                cAceFlags = CONTAINER_INHERIT_ACE;
                cAceFlags |= INHERIT_ONLY_ACE;
                break;
            }
        case KEY_ALL:
            {
                cAceFlags = CONTAINER_INHERIT_ACE;
                break;
            }
        default:
            return E_INVALIDARG;
        }
        
        if (paEntry.HasExactRights(amPermissionsMask) && paEntry.HasExactInheritFlags(cAceFlags) && paEntry.IsEqualSid(psidUserOrGroup))
        {
            bAceMatch = TRUE;
        }
    }
    
    if (!bAceMatch)
    {
        ACCESS_ALLOWED_ACE paEntry = {NULL};
        ACL_REVISION_INFORMATION AclRevisionInfo;
        PACL pNewDACL = NULL;
        CAccessControlEntry AccessControlEntry(ACCESS_ALLOWED_ACE_TYPE, amPermissionsMask, cAceFlags, psidUserOrGroup);
        
        // subtract ACE.SidStart from the size
        cbAce = sizeof (paEntry) - sizeof (DWORD);
        // add this ACE's SID length
        cbAce += 8 + GetLengthSid(const_cast<PSID>(psidUserOrGroup));
        // add the length of each ACE to the total ACL length
        cbAcl += cbAce;
        
        m_listAllAce.insert(m_listAllAce.end(), AccessControlEntry);
        
        AclRevisionInfo.AclRevision = ACL_REVISION;
        
        hr = BuildAndApplyACLFromList(cbAcl, AclRevisionInfo);
        
        if (SUCCEEDED(hr))
        {
            hr = SetKeySecurity();
        }
    }
    else
    {
        hr = S_FALSE;
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RevokeRightsOnRegKey
//
//  Purpose:    Remove the specified account to the ACL with the permissions
//              required and the inheritance information.
//
//  Arguments:  
//          psidUserOrGroup     - The sid (Security Identifier) of the user to 
//                                be added.
//          amPermissionMask    - The permissions to be granted.
//          
//          kamMask             - Applies to this key or child keys or both?
//                                
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:  This is designed to only remove the exact combination of user
//          rights and sid and key apply mask.  This is to stop us from
//          accidentally deleting a key that was put there for the user/group
//          by an administrator.
// 
HRESULT CRegKeySecurity::RevokeRightsOnRegKey(PCSID psidUserOrGroup, ACCESS_MASK amPermissionsMask, KEY_APPLY_MASK kamMask)
{
    HRESULT hr = S_OK;
    PACCESS_ALLOWED_ACE					paaAllowedAce = NULL;
    PACCESS_DENIED_ACE                  paaDeniedAce = NULL;
    BOOL                                bAceMatch = FALSE;
    BYTE                                cAceFlags = 0;
    DWORD                               cbAcl = 0;
    DWORD                               cbAce = 0;
    
    if (!IsValidSid(const_cast<PSID>(psidUserOrGroup)))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_SID);
    }
    
    hr = GetAccessControlEntriesFromAcl();
    
    if (FAILED(hr))
    {
        return hr;
    }
    
    cbAcl = sizeof(ACL);
    
    for (ACEITER i = m_listAllAce.begin(); i != m_listAllAce.end() ; i++)
    {
        CAccessControlEntry paEntry(*i);
        
        // Assert(kamMask)
        
        switch (kamMask)
        {
        case KEY_CURRENT:
            {
                cAceFlags = 0; // Do not allow this to be inherited by children.
                break;
            }
        case KEY_CHILDREN:
            {
                cAceFlags = CONTAINER_INHERIT_ACE;
                cAceFlags |= INHERIT_ONLY_ACE;
                break;
            }
        case KEY_ALL:
            {
                cAceFlags = CONTAINER_INHERIT_ACE;
                break;
            }
        default:
            return E_INVALIDARG;
        }
        
        if (paEntry.HasExactRights(amPermissionsMask) && paEntry.HasExactInheritFlags(cAceFlags) && paEntry.IsEqualSid(psidUserOrGroup))
        {
            ACEITER j = i;
            i = m_listAllAce.erase(j);
            bAceMatch = TRUE;
        }
        else
        {
            cbAcl += sizeof(ACCESS_ALLOWED_ACE) + 8 +
                paEntry.GetLengthSid()- sizeof(DWORD);
            
        }
    }
    
    if (bAceMatch)
    {
        ACCESS_ALLOWED_ACE paEntry = {NULL};
        ACL_REVISION_INFORMATION AclRevisionInfo;
        PACL pNewDACL = NULL;
        
        // subtract ACE.SidStart from the size
        cbAce = sizeof (paEntry) - sizeof (DWORD);
        // add this ACE's SID length
        cbAce += 8 + GetLengthSid(const_cast<PSID>(psidUserOrGroup));
        // add the length of each ACE to the total ACL length
        cbAcl += cbAce;
        
        AclRevisionInfo.AclRevision = ACL_REVISION;
        
        hr = BuildAndApplyACLFromList(cbAcl, AclRevisionInfo);
        
        if (SUCCEEDED(hr))
        {
            hr = SetKeySecurity();
        }
    }
    else
    {
        hr = S_FALSE;
    }
    
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetAccessControlEntriesFromAcl
//
//  Purpose:    Retrieves all the ACE's from the ACL and stores them in an 
//              STL list for easier manipulation.
//
//  Arguments:  
//
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CRegKeySecurity::GetAccessControlEntriesFromAcl()
{
    ACL_SIZE_INFORMATION				asiAclSize;
    ACL_REVISION_INFORMATION			ariAclRevision;
    DWORD								dwBufLength;
    DWORD								dwAcl;
    DWORD                               dwTotalEntries = 0;
    HRESULT                             hr = S_OK;
    PACCESS_ALLOWED_ACE					paaAllowedAce = NULL;
    PACCESS_DENIED_ACE                  paaDeniedAce = NULL;
    ACCESS_MASK                         amAccessAllowedMask = 0;
    ACCESS_MASK                         amAccessDeniedMask = 0;
    
    if (!m_paclDacl)
    {
        hr = GetSecurityDescriptorDacl();
        if (FAILED(hr))
        {
            return hr;
        }
    }
    
    if (!IsValidAcl(m_paclDacl))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_ACL);
    }
    
    dwBufLength = sizeof(asiAclSize);
    
    if (!GetAclInformation(m_paclDacl, 
        &asiAclSize, 
        dwBufLength, 
        AclSizeInformation))
    {
        return(FALSE);
    }
    
    dwBufLength = sizeof(ariAclRevision);
    
    if (!GetAclInformation(m_paclDacl, 
        &ariAclRevision, 
        dwBufLength, 
        AclRevisionInformation))
    {
        return(FALSE);
    }
    
    switch (ariAclRevision.AclRevision)
    { 
    case      ACL_REVISION1 :
        {
            break;
        }
    case      ACL_REVISION2 :
        {
            break;
        }
    default :
        {
            return(FALSE);
        }
    }
    
    if (asiAclSize.AceCount <= 0)
    {
        return E_INVALIDARG;
    }
    
    m_listAllAce.clear();
    
    for (dwAcl = 0;dwAcl < asiAclSize.AceCount; dwAcl++)
    {
        if (!GetAce(m_paclDacl, 
            dwAcl, 
            reinterpret_cast<LPVOID *>(&paaAllowedAce)))
        {
            return HRESULT_FROM_WIN32(ERROR_INVALID_ACL);
        }
        
        if (paaAllowedAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            CAccessControlEntry pEntry(*paaAllowedAce);
            
            m_listAllAce.insert(m_listAllAce.end(), pEntry);
        }
        else
        {
            CAccessControlEntry pEntry(*paaAllowedAce);
            
            m_listAllAce.insert(m_listAllAce.begin(), pEntry);
        }
    }
    
    return S_OK;
    
}


HRESULT CRegKeySecurity::BuildAndApplyACLFromList(DWORD cbAcl, ACL_REVISION_INFORMATION AclRevisionInfo)
{
    HRESULT hr = S_OK;
    DWORD cbAce = 0;
    PACL pNewDACL = NULL;
    
    pNewDACL = reinterpret_cast<PACL>(new BYTE[cbAcl]);
    
    if (!pNewDACL)
    {
        return E_OUTOFMEMORY;
    }
    
    ZeroMemory(pNewDACL, cbAcl);
    
    if (InitializeAcl(pNewDACL, cbAcl, AclRevisionInfo.AclRevision))
    {
        for (ACEITER i = m_listAllAce.begin(); i != m_listAllAce.end(); i++)
        {
            CAccessControlEntry Ace = *i;
            
            if (IsValidAcl(pNewDACL))
            {
                hr = Ace.AddToACL(&pNewDACL, AclRevisionInfo);
                
                if (FAILED(hr))
                {
                    break;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_ACL);
                break;
            }
        }
        
        if (SUCCEEDED(hr))
        {
            hr = SetSecurityDescriptorDacl(pNewDACL, m_listAllAce.size());
        }
        delete[] pNewDACL;
    }
    
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   CAccessControlEntry constructor
//
//  Purpose:    
//              
//
//  Arguments:  
//          
//
//          
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
CAccessControlEntry::CAccessControlEntry()
{
    
}

//+---------------------------------------------------------------------------
//
//  Function:   CAccessControlEntry copy constructor
//
//  Purpose:    To contruct a new CAccessControEntry based on the supplied 
//              Access Control Entry for storage in an STL list.
//
//  Arguments:  
//          aaAllowed   - An ACCESS_ALLOWED_ACE or ACCESS_DENIED_ACE
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:      Since STL doesn't know how to work with Sids we get the string 
//              representation of the sid and then store that inside the list.
//
CAccessControlEntry::CAccessControlEntry(const ACCESS_ALLOWED_ACE& aaAllowed)
{
    m_cAceType = aaAllowed.Header.AceType;
    m_amMask = aaAllowed.Mask;
    m_cAceFlags = aaAllowed.Header.AceFlags;
    
    CNCUtility::SidToString(&aaAllowed.SidStart, m_strSid);
    m_dwLengthSid = ::GetLengthSid(reinterpret_cast<PSID>(const_cast<LPDWORD>(&aaAllowed.SidStart)));
}

//+---------------------------------------------------------------------------
//
//  Function:   CAccessControlEntry copy constructor
//
//  Purpose:    To contruct a new CAccessControEntry based on the supplied 
//              Access Control Entry fields for storage in an STL list.
//
//
//  Arguments:  
//          AceType         - The type of ACE (allowed or denied or audit etc)
//
//          amMask          - Permissions Mask
//
//          AceFlags        - AceFlags
//
//          psidUserOrGroup - The User or Group we're interested in
//
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:      Since STL doesn't know how to work with Sids we get the string 
//              representation of the sid and then store that inside the list.
//
CAccessControlEntry::CAccessControlEntry(const BYTE AceType, const ACCESS_MASK amMask, const BYTE AceFlags, PCSID psidUserOrGroup)
{
    m_cAceType = AceType;
    m_amMask = amMask;
    m_cAceFlags = AceFlags;
    
    CNCUtility::SidToString(psidUserOrGroup, m_strSid);
    m_dwLengthSid = ::GetLengthSid(const_cast<PSID>(psidUserOrGroup));
}

//+---------------------------------------------------------------------------
//
//  Function:   CAccessControlEntry destructor
//
//  Purpose:    
//              
//
//  Arguments:  
//
//          
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
CAccessControlEntry::~CAccessControlEntry()
{
}

//+---------------------------------------------------------------------------
//
//  Function:   AddToACL
//
//  Purpose:    Adds this current AccessControlEntry to the specified ACL
//              
//
//  Arguments:  
//          pAcl            - Access Control List to Add to
//
//          AclRevisionInfo - Version of ACL
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CAccessControlEntry::AddToACL(PACL* pAcl, ACL_REVISION_INFORMATION AclRevisionInfo)
{
    HRESULT hr;
    PSID pSid = NULL;
    
    hr = CNCUtility::StringToSid(m_strSid, pSid);
    
    if (FAILED(hr))
    {
        return hr;
    }
    
    if (m_cAceType == ACCESS_ALLOWED_ACE_TYPE)
    {
        if (!::AddAccessAllowedAceEx(*pAcl, AclRevisionInfo.AclRevision, m_cAceFlags, m_amMask, pSid))
        {
            DWORD dwErr;

            dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErr);
        }
    }
    else
    {
        if (!::AddAccessDeniedAceEx(*pAcl, AclRevisionInfo.AclRevision, m_cAceFlags, m_amMask, pSid))
        {
            DWORD dwErr;

            dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErr);
        }
    }
    
    if (pSid)
    {
        FreeSid(pSid);
    }
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   HasExactRights
//
//  Purpose:    Checks to see if this ACE has the exact same rights that we 
//              are looking for
//              
//
//  Arguments:  
//          amRightsRequired    - The AccessMask in question
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
BOOL CAccessControlEntry::HasExactRights(ACCESS_MASK amRightsRequired) const
{
    return (amRightsRequired == m_amMask);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetLengthSid
//
//  Purpose:    returns the length of the sid in this AccessControlEntry
//
//  Arguments:  
//          
//
//          
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
DWORD CAccessControlEntry::GetLengthSid() const
{
    return m_dwLengthSid;
}

//+---------------------------------------------------------------------------
//
//  Function:   HasExactRights
//
//  Purpose:    Checks to see if this ACE has the exact same inherit flags 
//              that we are looking for
//              
//
//  Arguments:  
//          amRightsRequired    - The AccessMask in question
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
BOOL CAccessControlEntry::HasExactInheritFlags(BYTE AceFlags)
{
    return (m_cAceFlags == AceFlags);
}

//+---------------------------------------------------------------------------
//
//  Function:   IsEqualSid
//
//  Purpose:    Is this the same Sid as the one we're looking for?
//              
//
//  Arguments:  
//          psidUserOrGroup - Sid in question
//
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code 
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
BOOL CAccessControlEntry::IsEqualSid(PCSID psidUserOrGroup) const
{
    HRESULT hr;
    BOOL bEqualSid = FALSE;
    PSID pSid = NULL;
    
    hr = CNCUtility::StringToSid(m_strSid, pSid);
    
    if (SUCCEEDED(hr))
    {
        bEqualSid = ::EqualSid(pSid, const_cast<PSID>(psidUserOrGroup));
    }
    
    if (pSid)
    {
        FreeSid(pSid);
    }
    
    return bEqualSid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncbase\trnrgsec.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       T R N R G S E C . C P P
//
//  Contents:   Atomic application of security to registry keys
//              
//
//  Notes:
//
//  Author:     ckotze   10 July 2000
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include <ncreg.h>
#include <regkysec.h>
#include <trnrgsec.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTransactedRegistrySecurity::CTransactedRegistrySecurity()
{
    m_listTransaction.clear();
}

CTransactedRegistrySecurity::~CTransactedRegistrySecurity()
{

}

//+---------------------------------------------------------------------------
//
//  Function:   SetPermissionsForKeysFromList
//
//  Purpose:    Returns a HRESULT that is either S_OK or E_ABORT.  E_ABORT 
//              specifies that the transaction was cancelled and rolled back.
//
//  Arguments:
//       psidUserOrGroup - The Security Identifier for the user or group that 
//                         needs have it's security changed on certain keys.
//       listRegKeyApply - An stl list of REGKEYDATA for the different keys and 
//                         the different permissions to set on those keys.
//       bGrantRights    - Are we granting or revoke rights?
//
//  Returns:    S_OK if the permissions is set correctly, and error code otherwise
//
//  Author:     ckotze   10 July 2000
//
//  Notes:
//
HRESULT CTransactedRegistrySecurity::SetPermissionsForKeysFromList(PCSID psidUserOrGroup, LISTREGKEYDATA& listRegKeyApply, BOOL bGrantRights)
{
    HRESULT hr = E_FAIL;
    BOOL bAbort = FALSE;

    Assert(psidUserOrGroup != NULL);
    Assert(listRegKeyApply.size() > 0);

    for (REGKEYDATAITER i = listRegKeyApply.begin(); i != listRegKeyApply.end(); i++)
    {
        REGKEYDATA rkdInfo = *i;

        hr = ApplySecurityToKey(psidUserOrGroup, rkdInfo, bGrantRights);

        // We might return S_FALSE if we didn't change anything and we don't want to add it to the list

        if (S_OK == hr)
        {
            m_listTransaction.insert(m_listTransaction.end(), rkdInfo);
        }
        else if (FAILED(hr) && HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
        {
            bAbort = TRUE;
            break;
        }
    }

    if(bAbort)
    {
         for (REGKEYDATAITER i = m_listTransaction.end(); i != m_listTransaction.begin(); i++)
         {
            REGKEYDATA rkdInfo = *i;

            hr = ApplySecurityToKey(psidUserOrGroup, rkdInfo, !bGrantRights);
         }

         hr = E_ABORT;
    }
    else
    {
        hr = S_OK;
    }

    m_listTransaction.clear();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetPermissionsForKeysFromList
//
//  Purpose:    Returns a HRESULT that is either S_OK or E_ABORT.  E_ABORT 
//              specifies that the transaction was cancelled and rolled back.
//
//  Arguments:
//       psidUserOrGroup - The Security Identifier for the user or group that 
//                         needs have it's security changed on certain keys.
//       rkdInfo         - A REGKEYDATA structure for this key.
//                         
//       bGrantRights    - Are we granting or revoke rights?
//
//  Returns:    S_OK if the permissions is set correctly, and error code otherwise
//
//  Author:     ckotze   10 July 2000
//
//  Notes:
//
HRESULT CTransactedRegistrySecurity::ApplySecurityToKey(PCSID psidUserOrGroup, const REGKEYDATA rkdInfo, const BOOL bGrantRights)
{
    HRESULT hr = S_OK;

    hr = RegOpenKey(rkdInfo.hkeyRoot, rkdInfo.strKeyName.c_str());
    if (SUCCEEDED(hr))
    {

        hr = GetKeySecurity();
        if (SUCCEEDED(hr))
        {
            hr = GetSecurityDescriptorDacl();
            if (SUCCEEDED(hr))
            {
                if (bGrantRights)
                {
                    hr = GrantRightsOnRegKey(psidUserOrGroup, rkdInfo.amMask, rkdInfo.kamMask);
                }
                else
                {
                    hr = RevokeRightsOnRegKey(psidUserOrGroup, rkdInfo.amMask, rkdInfo.kamMask);
                }
            }
        }
        // we actually need the hr from the call above so we just assert here instead of returning the HRESULT
        Assert(SUCCEEDED(RegCloseKey()));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncdebug\diagcmn.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D I A G C M N . C P P
//
//  Contents:   Common functions for netcfg diagnostics
//
//  Notes:
//
//  Author:     danielwe   23 Mar 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "diag.h"
#include "ncstring.h"

//+---------------------------------------------------------------------------
//
//  Function:   SzFromCharacteristics
//
//  Purpose:    Converts a DWORD characteristics value into a string listing
//              the flags that are turned on.
//
//  Arguments:
//      dwChars   [in]  DWORD of netcfg characteristics (i.e. NCF_HIDDEN)
//      pstrChars [out] tstring of flags that are turned on, separated by a
//                      space.
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Mar 1999
//
//  Notes:
//
VOID SzFromCharacteristics(DWORD dwChars, tstring *pstrChars)
{
    INT     i;

    const PCWSTR chars[] =
    {
        L"NCF_VIRTUAL ",
        L"NCF_SOFTWARE_ENUMERATED ",
        L"NCF_PHYSICAL ",
        L"NCF_HIDDEN ",
        L"NCF_NO_SERVICE ",
        L"NCF_NOT_USER_REMOVABLE ",
        L"NCF_MULTIPORT_INSTANCED_ADAPTER ",
        L"NCF_HAS_UI ",
        L"NCF_MODEM ",
        L"NCF_FILTER_DEVICE ",
        L"NCF_FILTER ",
        L"NCF_DONTEXPOSELOWER ",
        L"NCF_HIDE_BINDING ",
        L"0x4000 ",
        L"0x8000 ",
        L"NCF_FORCE_SCM_NOTIFY ",
        L"NCF_FIXED_BINDING ",
    };

    for (i = 0; i < celems(chars); i++)
    {
        if (dwChars & (1 << i) )
        {
            pstrChars->append(chars[i]);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SzFromNetconStatus
//
//  Purpose:    Converts a NETCON_STATUS value into a string
//
//  Arguments:
//      Status [in]     Status value to convert
//
//  Returns:    The string
//
//  Author:     danielwe   23 Mar 1999
//
//  Notes:
//
PCWSTR SzFromNetconStatus(NETCON_STATUS Status)
{
    switch (Status)
    {
    case NCS_DISCONNECTED:
        return L"NCS_DISCONNECTED";

    case NCS_CONNECTING:
        return L"NCS_CONNECTING";

    case NCS_CONNECTED:
        return L"NCS_CONNECTED";

    case NCS_DISCONNECTING:
        return L"NCS_DISCONNECTING";

    case NCS_HARDWARE_NOT_PRESENT:
        return L"NCS_HARDWARE_NOT_PRESENT";

    case NCS_HARDWARE_DISABLED:
        return L"NCS_HARDWARE_DISABLED";

    case NCS_HARDWARE_MALFUNCTION:
        return L"NCS_HARDWARE_MALFUNCTION";
    }

    return L"Unknown";
}

//+---------------------------------------------------------------------------
//
//  Function:   SzFromCmProb
//
//  Purpose:    Converts a config manager (CM) problem value into a string
//
//  Arguments:
//      ulProb [in]     Problem value
//
//  Returns:    String version of value
//
//  Author:     danielwe   23 Mar 1999
//
//  Notes:
//
PCWSTR SzFromCmProb(ULONG ulProb)
{
    const PCWSTR a_szProbs[] =
    {
        L"<no problem>",
        L"CM_PROB_NOT_CONFIGURED",
        L"CM_PROB_DEVLOADER_FAILED",
        L"CM_PROB_OUT_OF_MEMORY",
        L"CM_PROB_ENTRY_IS_WRONG_TYPE",
        L"CM_PROB_LACKED_ARBITRATOR",
        L"CM_PROB_BOOT_CONFIG_CONFLICT",
        L"CM_PROB_FAILED_FILTER",
        L"CM_PROB_DEVLOADER_NOT_FOUND",
        L"CM_PROB_INVALID_DATA",
        L"CM_PROB_FAILED_START",
        L"CM_PROB_LIAR",
        L"CM_PROB_NORMAL_CONFLICT",
        L"CM_PROB_NOT_VERIFIED",
        L"CM_PROB_NEED_RESTART",
        L"CM_PROB_REENUMERATION",
        L"CM_PROB_PARTIAL_LOG_CONF",
        L"CM_PROB_UNKNOWN_RESOURCE",
        L"CM_PROB_REINSTALL",
        L"CM_PROB_REGISTRY",
        L"CM_PROB_VXDLDR",
        L"CM_PROB_WILL_BE_REMOVED",
        L"CM_PROB_DISABLED",
        L"CM_PROB_DEVLOADER_NOT_READY",
        L"CM_PROB_DEVICE_NOT_THERE",
        L"CM_PROB_MOVED",
        L"CM_PROB_TOO_EARLY",
        L"CM_PROB_NO_VALID_LOG_CONF",
        L"CM_PROB_FAILED_INSTALL",
        L"CM_PROB_HARDWARE_DISABLED",
        L"CM_PROB_CANT_SHARE_IRQ",
        L"CM_PROB_FAILED_ADD",
    };

    return a_szProbs[ulProb];
}

//+---------------------------------------------------------------------------
//
//  Function:   SzFromCmStatus
//
//  Purpose:    Converts a config manager (CM) status value into a string
//              containing all flags that are turned on.
//
//  Arguments:
//      ulStatus   [in]     CM status value
//      pstrStatus [out]    Returns string of flags that are on
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Mar 1999
//
//  Notes:
//
VOID SzFromCmStatus(ULONG ulStatus, tstring *pstrStatus)
{
    INT     i;

    const PCWSTR a_szStatus[] =
    {
        L"DN_ROOT_ENUMERATED ",
        L"DN_DRIVER_LOADED ",
        L"DN_ENUM_LOADED ",
        L"DN_STARTED ",
        L"DN_MANUAL ",
        L"DN_NEED_TO_ENUM ",
        L"DN_NOT_FIRST_TIME ",
        L"DN_HARDWARE_ENUM ",
        L"DN_LIAR/DN_NEED_RESTART ",
        L"DN_HAS_MARK ",
        L"DN_HAS_PROBLEM ",
        L"DN_FILTERED ",
        L"DN_MOVED ",
        L"DN_DISABLEABLE ",
        L"DN_REMOVABLE ",
        L"DN_PRIVATE_PROBLEM ",
        L"DN_MF_PARENT ",
        L"DN_MF_CHILD ",
        L"DN_WILL_BE_REMOVED ",
        L"DN_NOT_FIRST_TIMEE ",
        L"DN_STOP_FREE_RES ",
        L"DN_REBAL_CANDIDATE ",
        L"DN_BAD_PARTIAL ",
        L"DN_NT_ENUMERATOR ",
        L"DN_NT_DRIVER ",
        L"DN_NEEDS_LOCKING ",
        L"DN_ARM_WAKEUP ",
        L"DN_APM_ENUMERATOR ",
        L"DN_APM_DRIVER ",
        L"DN_SILENT_INSTALL ",
        L"DN_NO_SHOW_IN_DM ",
        L"DN_BOOT_LOG_PROB ",
    };

    for (i = 0; i < celems(a_szStatus); i++)
    {
        if (ulStatus & (1 << i) )
        {
            pstrStatus->append(a_szStatus[i]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncdebug\dbgflags.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D B G F L A G S . C P P
//
//  Contents:   DebugFlag list for the NetCfg Project
//
//  Notes:
//
//  Author:     jeffspr   27 May 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

// None of this should get compiled in unless we're in the debug version
// or we need to enable tracing code.
//
#if defined(DBG) || defined(ENABLETRACE)

#include "ncdebug.h"
#include "ncbase.h"

// This is the DebugFlag list that everyone should be modifying.
//
DEBUGFLAGELEMENT g_DebugFlags[] =
{
//      :-----------    DebugFlagId dfid
//      | :---------    CHAR []     szShortName
//      | | :-------    CHAR []     szDescription
//      | | |           DWORD       dwValue ------------------------------------------------------------:
//      | | |                                                                                           |
//      | | |                                                                                           |
//      | | :-------------------------------------------:                                               |
//      | :----------------------:                      |                                               |
//      |                        |                      |                                               |
//      v                        v                      v                                               v
//
    { dfidBreakOnAlloc,             "BreakOnAlloc",             "Break on Specified Alloc",             0 },
    { dfidBreakOnDoUnattend,        "BreakOnDoUnattend",        "Break during HrDoUnattend",            0 },
    { dfidBreakOnError,             "BreakOnError",             "Break on TraceError",                  0 },
    { dfidBreakOnHr,                "BreakOnHr",                "Break when hr is specific value",      0 },
    { dfidBreakOnHrIteration,       "BreakOnHrInteration",      "Break when hr is hit N times",         0 },
    { dfidBreakOnIteration,         "BreakOnIteration",         "Break on Nth call to TraceError",      0 },
    { dfidBreakOnNetInstall,        "BreakOnNetInstall",        "Break during HrNetClassInstaller",     0 },
    { dfidBreakOnNotifySinkRelease, "BreakOnNotifySinkRelease", "Break when the NotifySink is released",0 },
    { dfidBreakOnPrematureDllUnload,"BreakOnPrematureDllUnload","Break when DLL unloaded with open references",     0 },
    { dfidBreakOnWizard,            "BreakOnWizard",            "Break on Wizard",                      0 },
    { dfidBreakOnStartOfUpgrade,    "BreakOnStartOfUpgrade",    "Break at the beginning of InstallUpgradeWorkThread", 0 },
    { dfidBreakOnEndOfUpgrade,      "BreakOnEndOfUpgrade",      "Break after all calls to HrDoUnattend have been completed", 0 },
    { dfidCheckLegacyMenusAtRuntime,"CheckLegacyMenusAtRuntime","Assert legacy menus during runtime",   0 },
    { dfidCheckLegacyMenusOnStartup,"CheckLegacyMenusOnStartup","Assert all legacy menus on startup",   0 },
    { dfidDisableShellThreading,    "DisableShellThreading",    "Disable shell thread pool usage",      0 },
    { dfidDisableTray,              "DisableTray",              "Disable Tray",                         0 },
    { dfidDontCacheShellIcons,      "DontCacheShellIcons",      "Don't ever use shell icon caching",    0 },
    { dfidExtremeTracing,           "ExtremeTracing",           "Output all traces, even on success",   0 },
    { dfidNetShellBreakOnInit,      "NetShellBreakOnInit",      "Break on Initialization of NetShell",  0 },
    { dfidNoErrorText,              "NoErrorText",              "Don't show wimpy error strings.",      0 },
    { dfidShowIgnoredErrors,        "ShowIgnoredErrors",        "Displays errors that would otherwise be ignored", 0 },
    { dfidShowProcessAndThreadIds,  "ShowProcessAndThreadIds",  "Displays process and thread id",       0 },
    { dfidSkipLanEnum,              "SkipLanEnum",              "Skip LAN Enumeration",                 0 },
    { dfidTraceCallStackOnError,    "TraceCallStackOnError",    "Dump the call stack for all errors",   0 },
    { dfidTraceFileFunc,            "TraceFileFunc",            "Trace Function names & params for every call", 0 },
    { dfidTraceMultiLevel,          "TraceMultiLevel",          "Trace multiple levels",                0 },       
    { dfidTraceSource,              "TraceSource",              "Trace source information",             0 },
    { dfidTracingTimeStamps,        "TracingTimeStamps",        "Add time stamps to tracing output",    0 },
    { dfidTrackObjectLeaks,         "TrackObjectLeaks",         "Track object leaks",                   0 }
};

const INT g_nDebugFlagCount = celems(g_DebugFlags);


//+---------------------------------------------------------------------------
//
//  Function:   FIsDebugFlagSet
//
//  Purpose:    Return the state of a debug flag to the caller.
//
//  Arguments:
//      dfid [] Debug Flag ID
//
//  Returns:    TRUE if set, FALSE otherwise.
//
//  Author:     jeffspr   28 May 1997
//
//  Notes:
//
BOOL FIsDebugFlagSet( DEBUGFLAGID   dfid )
{
    return (g_DebugFlags[dfid].dwValue > 0);
}

DWORD   DwReturnDebugFlagValue( DEBUGFLAGID dfid )
{
    return (g_DebugFlags[dfid].dwValue);
}


#endif //! DBG || ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncdebug\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOGDI
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSERVICE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <windows.h>
#include <objbase.h>

#include <stdio.h>

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncdebug\diagctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       D I A G C T X . C P P
//
//  Contents:   Implements the optional diagnostic context used by
//              CNetConfig.
//
//  Notes:
//
//  Author:     shaunco   10 Feb 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "diagctx.h"


CDiagContext* g_pDiagCtx;


DWORD
CDiagContext::Flags () const
{
    return (this) ? m_dwFlags : 0;
}

VOID
CDiagContext::SetFlags (
    DWORD dwFlags /* DIAG_FLAGS */)
{
    Assert (this);

    m_dwFlags = dwFlags;

    if ((dwFlags & DF_SHOW_CONSOLE_OUTPUT) && !m_pCtx)
    {
        m_pCtx = (DIAG_CONTEXT*) MemAlloc (sizeof(DIAG_CONTEXT));
    }
}

VOID
CDiagContext::Printf (
    TRACETAGID ttid,
    PCSTR pszFormat,
    ...
    )
{
    va_list argList;
    DWORD cch;
    CHAR* pszPrintBuffer = NULL;
    INT cchPrintBuffer;

    Assert (pszFormat);

    if (this && (m_dwFlags & DF_SHOW_CONSOLE_OUTPUT) && m_pCtx)
    {
        pszPrintBuffer = m_pCtx->szPrintBuffer;
        cchPrintBuffer = sizeof(m_pCtx->szPrintBuffer);
    }
    else
    {
#ifdef ENABLETRACE
        if (!g_TraceTags[ttid].fOutputDebugString)
        {
            return;
        }

        static CHAR szPrintfBuffer [2048];

        pszPrintBuffer = szPrintfBuffer;
        cchPrintBuffer = sizeof(szPrintfBuffer);
#else
        return;
#endif
    }

    Assert (pszPrintBuffer);

    // Do the standard variable argument stuff
    va_start (argList, pszFormat);

    cch = _vsnprintf (pszPrintBuffer, cchPrintBuffer, pszFormat, argList);

    va_end(argList);

    TraceTag (ttid, pszPrintBuffer);

    if (this && (m_dwFlags & DF_SHOW_CONSOLE_OUTPUT))
    {
        HANDLE hStdOut;

        hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

        if (INVALID_HANDLE_VALUE != hStdOut)
        {
            DWORD cbWritten;

            if (WriteFile(hStdOut, pszPrintBuffer, cch * sizeof(CHAR), &cbWritten, NULL) == FALSE)
            {
                return;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncdebug\tracetag.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E T A G . C P P
//
//  Contents:   TraceTag list for the NetCfg Project
//
//  Notes:
//
//  Author:     jeffspr   9 Apr 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#ifdef ENABLETRACE

#include "tracetag.h"


// This is the TraceTag list that everyone should be modifying.
//
TraceTagElement g_TraceTags[] =
{
//      :-----------    TraceTagId  ttid
//      | :---------    CHAR []     szShortName
//      | | :-------    CHAR []     szDescription
//      | | |           BOOL        fOutputDebugString -----------------------------:
//      | | |           BOOL        fOutputToFile ----------------------------------|---:
//      | | |           BOOL        fVerboseOnly------------------------------------|---|---:
//      | | |                                                                       |   |   |
//      | | |                                                                       |   |   |
//      | | :-----------------------------------------:                             |   |   |
//      | :-------------------:                       |                             |   |   |
//      |                     |                       |                             |   |   |
//      v                     v                       v                             v   v   v
//
    { ttidDefault,          "Default",              "Default",                      0,  0,  0 },
    { ttidAdvCfg,           "AdvCfg",               "Advanced Config",              0,  0,  0 },
    { ttidAllocations,      "Allocations",          "All object allocations",       0,  0,  0 },
    { ttidAnswerFile,       "AFile",                "AnswerFile",                   0,  0,  0 },
    { ttidAtmArps,          "AtmArps",              "ATM ARP Server",               0,  0,  0 },
    { ttidAtmLane,          "AtmLane",              "ATM LAN Emulator",             0,  0,  0 },
    { ttidAtmUni,           "AtmUni",               "ATM UNI Call Manager",         0,  0,  0 },
    { ttidBeDiag,           "BeDiag",               "Binding Engine Diagnostics",   0,  0,  0 },
    { ttidBenchmark,        "Benchmarks",           "Benchmarks",                   0,  0,  0 },
    { ttidBrdgCfg,          "Bridge",               "MAC Bridge",                   0,  0,  0 },
    { ttidClassInst,        "ClassInstaller",       "Class Installer",              0,  0,  0 },
    { ttidConFoldEntry,     "ConFoldEntry",         "Connection Folder Entries",    0,  0,  0 },
    { ttidConman,           "Conman",               "Connection Manager",           0,  0,  0 },
    { ttidConnectionList,   "ConnectionList",       "Connection List",              0,  0,  0 },
    { ttidDHCPServer,       "DHCPServer",           "DHCP Server Config",           0,  0,  0 },
    { ttidDun,              "Win9xDunFile",         "Windows9x .dun file handling", 0,  0,  0 },
    { ttidEAPOL,            "EAPOL",                "EAPOL notifications",          0,  0,  0 },
    { ttidError,            "Errors",               "Errors",                       1,  0,  0 },
    { ttidEsLock,           "EsLocks",              "Exception safe locks",         0,  0,  0 },
    { ttidEvents,           "Events",               "Netman Event Handler",         0,  0,  0 },
    { ttidFilter,           "Filter",               "During filter processing",     0,  0,  0 },
    { ttidGPNLA,            "GPNLA",                "Group Policies for NLA",       0,  0,  0 },   // NLA = Network Location Awareness.
    { ttidGuiModeSetup,     "GuiModeSetup",         "Gui Mode Setup Wizard",        0,  0,  0 },
    { ttidIcons,            "Icons",                "Shell Icons",                  0,  0,  0 },
    { ttidInfExt,           "InfExtensions",        "INF Extension processing",     0,  0,  0 },
    { ttidInstallQueue,     "InstallQueue",         "Install Queue",                0,  0,  0 },
    { ttidISDNCfg,          "ISDNCfg",              "ISDN Wizard/PropSheets",       0,  0,  0 },
    { ttidLana,             "LanaMap",              "LANA map munging",             0,  0,  0 },
    { ttidLanCon,           "LanCon",               "LAN Connections",              0,  0,  0 },
    { ttidLanUi,            "LanUi",                "Lan property & wizard UI",     0,  0,  0 },
    { ttidMenus,            "Menus",                "Context menus",                0,  0,  0 },
    { ttidMSCliCfg,         "MSCliCfg",             "MS Client",                    0,  0,  0 },
    { ttidNcDiag,           "NcDiag",               "Net Config Diagnostics",       0,  0,  0 },
    { ttidNetAfx,           "NetAfx",               "NetAfx",                       0,  0,  0 },
    { ttidNetBios,          "NetBIOS",              "NetBIOS",                      0,  0,  0 },
    { ttidNetComm,          "NetComm",              "Common Property Pages",        0,  0,  0 },
    { ttidNetOc,            "NetOc",                "Network Optional Components",  0,  0,  0 },
    { ttidNetSetup,         "NetSetup",             "Netsetup",                     0,  0,  0 },
    { ttidNetUpgrade,       "NetUpgrd",             "NetUpgrd",                     0,  0,  0 },
    { ttidNetcfgBase,       "NetcfgBase",           "NetCfg Base Object",           0,  0,  0 },
    { ttidNetCfgBind,       "Bind",                 "NetCfg Bindings (VERBOSE)",    0,  0,  1 },
    { ttidNetCfgPnp,        "Pnp",                  "NetCfg PnP notifications",     0,  0,  0 },
    { ttidNotifySink,       "NotifySink",           "Notify Sink",                  0,  0,  0 },
    { ttidNWClientCfg,      "NWClientCfg",          "NetWare Client Config",        0,  0,  0 },
    { ttidNWClientCfgFn,    "NWClientCfgFn",        "NetWare Client Config Fn",     0,  0,  0 },
    { ttidRasCfg,           "RasCfg",               "RAS Configuration",            0,  0,  0 },
    { ttidSFNCfg,           "SFNCfg",               "Services for NetWare Cfg",     0,  0,  0 },
    { ttidSecTest,          "SecTest",              "Security INF Ext. Test",       0,  0,  0 },
    { ttidShellEnum,        "ShellEnum",            "Shell Folder Enumeration",     0,  0,  0 },
    { ttidShellFolder,      "ShellFolder",          "Shell Folder",                 0,  0,  0 },
    { ttidShellFolderIface, "ShellFolderIface",     "Shell Folder COM Interfaces",  0,  0,  1 },
    { ttidShellViewMsgs,    "ShellViewMsgs",        "Shell View Callback Messages", 0,  0,  1 },
    { ttidSrvrCfg,          "SrvrCfg",              "Server",                       0,  0,  0 },
    { ttidStatMon,          "StatMon",              "StatMon",                      0,  0,  0 },
    { ttidSvcCtl,           "ServiceControl",       "Service control activities",   0,  0,  0 },
    { ttidSystray,          "SysTray",              "Taskbar Notification Area",    0,  0,  0 },
    { ttidTcpip,            "Tcpip",                "Tcpip Config",                 0,  0,  0 },
    { ttidWanCon,           "WanCon",               "WAN Connections",              0,  0,  0 },
    { ttidWanOrder,         "WanOrder",             "WAN Adapter Ordering",         0,  0,  0 },
    { ttidWizard,           "Wizard",               "Connections Wizard",           0,  0,  0 },
    { ttidWlbs,             "WLBS",                 "WLBS Config",                  0,  0,  0 }, /* maiken 5.25.00 */
    { ttidWmi,              "WMI",                  "WDM extensions to WMI",        0,  0,  0 }, /* AlanWar */
};

const INT g_nTraceTagCount = celems(g_TraceTags);

#endif //! ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncdebug\ncdebug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D E B U G X . C P P
//
//  Contents:   Implementation of debug support routines.
//
//  Notes:
//
//  Author:     danielwe   16 Feb 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#ifdef DBG

#include "ncdebug.h"
#include "ncdefine.h"

static int  nAssertLevel = 0;
static PFNASSERTHOOK pfnAssertHook = DefAssertSzFn;

#define MAX_ASSERT_TEXT_SIZE 4096
//
// We can only do memory tracking if we've included crtdbg.h and
// _DEBUG is defined.
//
#if defined(_INC_CRTDBG) && defined(_DEBUG)
struct DBG_SHARED_MEM
{
    _CrtMemState    crtState;
    DWORD           cRef;
};

DBG_SHARED_MEM *    g_pMem = NULL;
HANDLE              g_hMap = NULL;

static const WCHAR  c_szSharedMem[] = L"DBG_NetCfgSharedMemory";

//+---------------------------------------------------------------------------
//
//  Function:   InitDbgState
//
//  Purpose:    Initializes the memory leak detection code.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   13 May 1997
//
//  Notes:
//
VOID InitDbgState()
{
    g_hMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
                             0, sizeof(DBG_SHARED_MEM), c_szSharedMem);
    if (g_hMap)
    {
        LPVOID  pvMem;
        BOOL    fExisted = (GetLastError() == ERROR_ALREADY_EXISTS);

        pvMem = MapViewOfFile(g_hMap, FILE_MAP_WRITE, 0, 0, 0);
        g_pMem = reinterpret_cast<DBG_SHARED_MEM *>(pvMem);

        if (!fExisted)
        {
            // First time creating the file mapping. Initialize things.

            g_pMem->cRef = 0;

            // start looking for leaks now
            _CrtMemCheckpoint(&g_pMem->crtState);
        }

        g_pMem->cRef++;
        TraceTag(ttidDefault, "DBGMEM: Init Refcount on shared mem is now %d",
                 g_pMem->cRef);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   UnInitDbgState
//
//  Purpose:    Uninitializes the memory leak detection code.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   13 May 1997
//
//  Notes:
//
VOID UnInitDbgState()
{
    if (g_pMem)
    {
        g_pMem->cRef--;
        TraceTag(ttidDefault, "DBGMEM: Uninit Refcount on shared mem is now %d",
                 g_pMem->cRef);

        if (!g_pMem->cRef)
        {
            // manually force dump of leaks when refcount goes to 0
            _CrtMemDumpAllObjectsSince(&g_pMem->crtState);
        }

        UnmapViewOfFile(reinterpret_cast<LPVOID>(g_pMem));
        CloseHandle(g_hMap);
    }
}
#endif


BOOL WINAPI FInAssert(VOID)
{
    return nAssertLevel > 0;
}

VOID WINAPIV AssertFmt(BOOL fExp, PCSTR pszaFile, int nLine, PCSTR pszaFmt, ...)
{
    CHAR rgch[MAX_ASSERT_TEXT_SIZE];

    if (!fExp)
    {
        va_list     valMarker;

        va_start(valMarker, pszaFmt);
        wvsprintfA(rgch, pszaFmt, valMarker);
        va_end(valMarker);

        AssertSzFn(rgch, pszaFile, nLine);
    }
}

VOID WINAPI AssertSzFn(PCSTR pszaMsg, PCSTR pszaFile, INT nLine)
{
    CHAR rgch[MAX_ASSERT_TEXT_SIZE];

    ++nAssertLevel;

    if (pszaFile)
    {
        if (pszaMsg)
        {
            wsprintfA(rgch, "Net Config Assert Failure:\r\n  File %s, line %d:\r\n %s\r\n",
                      pszaFile, nLine, pszaMsg);
        }
        else
        {
            wsprintfA(rgch, "Net Config Assert Failure:\r\n  File %s, line %d.\r\n",
                      pszaFile, nLine);
        }
    }
    else
    {
        if (pszaMsg)
        {
            wsprintfA(rgch, "Net Config Assert Failure:\r\n:\r\n %s\r\n",
                      pszaMsg);
        }
        else
        {
            wsprintfA(rgch, "Net Config Assert Failure\r\n");
        }
    }

    OutputDebugStringA(rgch);

    if (pfnAssertHook)
    {
        (*pfnAssertHook)(pszaMsg, pszaFile, nLine);
    }

    --nAssertLevel;
}

VOID WINAPI AssertSzFn(PCSTR pszaMsg, PCSTR pszaFile, INT nLine, PCSTR pszaFunc)
{
    CHAR rgch[MAX_ASSERT_TEXT_SIZE];

    ++nAssertLevel;

    if (pszaFile)
    {
        if (pszaMsg)
        {
            wsprintfA(rgch, "Net Config Assert Failure:\r\n  File %s, line %d, Func: %s:\r\n %s\r\n",
                      pszaFile, nLine, pszaFunc, pszaMsg );
        }
        else
        {
            wsprintfA(rgch, "Net Config Assert Failure:\r\n  File %s, line %d, Func: %s:.\r\n",
                      pszaFile, nLine, pszaFunc ) ;
        }
    }
    else
    {
        if (pszaMsg)
        {
            wsprintfA(rgch, "Net Config Assert Failure:\r\n:\r\n %s\r\n",
                      pszaMsg);
        }
        else
        {
            wsprintfA(rgch, "Net Config Assert Failure\r\n");
        }
    }

    OutputDebugStringA(rgch);

    if (pfnAssertHook)
    {
        (*pfnAssertHook)(pszaMsg, pszaFile, nLine);
    }

    --nAssertLevel;
}

VOID WINAPI AssertSzFnWithDbgPrompt(BOOL fPromptIgnore, PCSTR pszaMsg, PCSTR pszaFile, INT nLine, PCSTR pszaFunc)
{
    CHAR rgch[MAX_ASSERT_TEXT_SIZE];

    DWORD dwProcId = GetCurrentProcessId();
    if (fPromptIgnore)
    {
        wsprintfA(rgch, "%s.\r\nPlease attach a kernel mode debugger, or (if you have local access to symbols) a user mode debugger to process id %d (decimal) and hit IGNORE to debug the problem\r\nE.g. use ntsd -Gg -p %d, (or ntsd -d -Gg -p %d) and then hit IGNORE.", pszaMsg, dwProcId, dwProcId, dwProcId);
    }
    else
    {
        wsprintfA(rgch, "%s.\r\nPlease attach a user mode debugger to process id %d (decimal) and hit RETRY to debug the problem\r\nE.g. use ntsd -Gg -p %d, (or ntsd -d -Gg -p %d) and then hit RETRY.", pszaMsg, dwProcId, dwProcId, dwProcId);
    }
    AssertSzFn(rgch, pszaFile, nLine, pszaFunc);
};

VOID CALLBACK DefAssertSzFn(PCSTR pszaMsg, PCSTR pszaFile, INT nLine)
{
    CHAR    rgch[2048];
    INT     nID;
    int     cch;
    PSTR    pch;
    BOOL    fNYIWarning = FALSE;
    CHAR    szaNYI[]     = "NYI:";

    if (pszaFile)
    {
        wsprintfA(rgch, "File %s, line %d\r\n\r\n", pszaFile, nLine);
    }
    else
    {
        rgch[0] = 0;
    }

    if (pszaMsg)
    {
        // Check to see if this is an NYI alert. If so, then we'll want
        // to use a different MessageBox title
        if (strncmp(pszaMsg, szaNYI, strlen(szaNYI)) == 0)
        {
            fNYIWarning = TRUE;
        }

        lstrcatA(rgch, pszaMsg);
    }


    cch = lstrlenA(rgch);
    pch = &rgch[cch];

    if (cch < celems(rgch))
    {
        lstrcpynA(pch, "\n\nPress Abort to crash, Retry to debug, or Ignore to ignore."
                       "\nHold down Shift to copy the assert text to the "
                       "clipboard before the action is taken.", celems(rgch) - cch - 1);
    }

    MessageBeep(MB_ICONHAND);

    nID = MessageBoxA(NULL, rgch,
            fNYIWarning ? "Net Config -- Not Yet Implemented" : "Net Config Assert Failure",
            MB_ABORTRETRYIGNORE | MB_DEFBUTTON3 | MB_ICONHAND |
            MB_SETFOREGROUND | MB_TASKMODAL | MB_SERVICE_NOTIFICATION);

    if (nID == IDRETRY)
    {
        DebugBreak();
    }

    // if cancelling, force a hard exit w/ a GP-fault so that Dr. Watson
    // generates a nice stack trace log.
    if (nID == IDABORT)
    {
        *(BYTE *) 0 = 1;    // write to address 0 causes GP-fault
    }
}

VOID WINAPI SetAssertFn(PFNASSERTHOOK pfn)
{
    pfnAssertHook = pfn;
}

//+---------------------------------------------------------------------------
// To be called during DLL_PROCESS_DETACH for a DLL which implements COM
// objects or hands out references to objects which can be tracked.
// Call this function with the name of the DLL (so that it can be traced
// to the debugger) and the lock count of the DLL.  If the lock count is
// non-zero, it means the DLL is being unloaded prematurley.  When this
// condition is detected, a message is printed to the debugger and a
// DebugBreak will be invoked if the debug flag dfidBreakOnPrematureDllUnload
// is set.
//
// Assumptions:
//  Trace and debugging features have not been uninitialized.
//
//
VOID
DbgCheckPrematureDllUnload (
    PCSTR pszaDllName,
    UINT ModuleLockCount)
{
    if (0 != ModuleLockCount)
    {
        TraceTag(ttidNetcfgBase, "ModuleLockCount == %d.  "
            "%s is being unloaded with clients still holding references!",
            ModuleLockCount,
            pszaDllName);

        if (FIsDebugFlagSet(dfidBreakOnPrematureDllUnload))
        {
            DebugBreak ();
        }
    }
}

#endif //! DBG

//+---------------------------------------------------------------------------
//
//  Function:   InitializeDebugging
//
//  Purpose:    Called by every DLL or EXE to initialize the debugging
//              objects (Trace and DebugFlag tables)
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   23 Sep 1997
//
//  Notes:
//
NOTHROW void InitializeDebugging()
{
    // For debug builds or if we have retail tracing enabled we need to
    // include the tracing code.
    // Ignore the error return, since we don't return it here anyway.
    //
#ifdef ENABLETRACE
    (void) HrInitTracing();
#endif

#if defined(DBG) && defined(_INC_CRTDBG) && defined(_DEBUG)
    if (FIsDebugFlagSet (dfidDumpLeaks))
    {
        InitDbgState();
    }
#endif
}


//+---------------------------------------------------------------------------
//
//  Function:   UnInitializeDebugging
//
//  Purpose:    Uninitialize the debugging objects (Tracing and DbgFlags)
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   23 Sep 1997
//
//  Notes:
//
NOTHROW void UnInitializeDebugging()
{
    // For debug builds or if we have retail tracing enabled we will have
    // included the tracing code.  We now need to uninitialize it.
    // Ignore the error return, since we don't return it here anyway.
    //
#ifdef ENABLETRACE

    (void) HrUnInitTracing();

#endif

#if defined(DBG) && defined(_INC_CRTDBG) && defined(_DEBUG)
    if (FIsDebugFlagSet (dfidDumpLeaks))
    {
        UnInitDbgState();
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncdebug\trace.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E . C P P
//
//  Contents:   The actual tracing code (loading from ini, calling the
//              trace routines, etc.
//
//  Notes:
//
//  Author:     jeffspr   9 Apr 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#ifdef ENABLETRACE

#include <crtdbg.h>
#include "ncdebug.h"
#include "ncmisc.h"

#include "stldeque.h"

DWORD g_dwTlsTracing = 0;
LPCRITICAL_SECTION g_csTracing = NULL;

#define MAX_TRACE_LEN 4096

//---[ CTracing class ]-------------------------------------------------------
//
// Don't give this class a constructor or destructor.  We declare a global
// (static to this module) instance of this class and, by definition, static
// variables are automatically initialized to zero.
//
class CTracing 
{
public:
    CTracing();
    ~CTracing();
    // Initialize/Deinitialize this class
    //
private:
    HRESULT HrInit();
    HRESULT HrUnInit();

public:
    VOID Trace( TraceTagId    ttid,
                PCSTR         pszaTrace );

private:
    BOOL    m_fInitialized;                 // Has the object been initialized
    BOOL    m_fAttemptedLogFileOpen;        // Already attempted to open log
    BOOL    m_fDisableLogFile;              // Disable use of file logging?
    UINT    m_uiAllocOnWhichToBreak;        // For _CrtSetBreakAlloc
    HANDLE  m_hLogFile;                     // Handle for debug output file
    CHAR    m_szLogFilePath[MAX_PATH+1];    // File for debug output
    BOOL    m_fDebugFlagsLoaded;            // Have these been loaded yet.

    VOID    CorruptionCheck();              // Validate the tracetag structure

    HRESULT HrLoadOptionsFromIniFile();
    HRESULT HrLoadSectionsFromIniFile();
    HRESULT HrLoadDebugFlagsFromIniFile();
    HRESULT HrWriteDebugFlagsToIniFile();
    HRESULT HrOpenLogFile();

    HRESULT HrProcessTagSection(TraceTagElement *   ptte);
    HRESULT HrGetPrivateProfileString(  PCSTR   lpAppName,
                                        PCSTR   lpKeyName,
                                        PCSTR   lpDefault,
                                        PSTR    lpReturnedString,
                                        DWORD   nSize,
                                        PCSTR   lpFileName,
                                        DWORD * pcchReturn );
    HRESULT FIniFileInit(); // Returns S_OK if the file exist
};


//---[ Static Variables ]-----------------------------------------------------

#pragma warning(disable:4073) // warning about the following init_seg statement
#pragma init_seg(lib)
static CTracing g_Tracing;                      // Our global tracing object

//---[ Constants ]------------------------------------------------------------

static const WCHAR  c_szDebugIniFileName[]  = L"netcfg.ini"; // .INI file
             CHAR   c_szDebugIniFileNameA[MAX_PATH];       // .INI file
static const CHAR   c_szTraceLogFileNameA[] = "nctrace.log";      // .LOG file

// constants for the INI file labels
static const CHAR   c_szaOptions[]          = "Options";
static const CHAR   c_szaLogFilePath[]      = "LogFilePath";
static const CHAR   c_szaDisableLogFile[]   = "DisableLogFile";

const INT   c_iDefaultDisableLogFile    = 0;

static CHAR   c_szLowMemory[]         = "<low on memory>";

//+---------------------------------------------------------------------------
//
//  Function:   HrInitTracing
//
//  Purpose:    Initialize the Tracing object and other random data.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   9 Apr 1997
//
//  Notes:
//
HRESULT HrInitTracing()
{
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrUnInitTracing
//
//  Purpose:    Uninitialize the tracing object.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or a valid Win32 HRESULT
//
//  Author:     jeffspr   14 Apr 1997
//
//  Notes:
//
HRESULT HrUnInitTracing()
{
    return S_OK;
}

const DWORD TI_HRESULT      = 0x00000001;
const DWORD TI_WIN32        = 0x00000002;
const DWORD TI_IGNORABLE    = 0x00000004;

//+---------------------------------------------------------------------------
//
//  Function:   TraceInternal
//
//  Purpose:    The one and only place that a string to be traced is formed
//              and traced.
//
//  Arguments:
//
//  Returns:    nothing.
//
//  Author:     shaunco   13 Mar 1998
//
//  Notes:      Restructured from lots of other code that was added to this
//              module over the past year.
//
VOID
TraceInternal (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    DWORD       dwFlags,
    PCSTR       pszaCallerText,
    DWORD       dwErrorCode,
    BOOL        bTraceStackOnError)
{
    // If this tracetag is turned off, don't do anything.
    //
    if (!g_TraceTags[ttid].fOutputDebugString &&
        !g_TraceTags[ttid].fOutputToFile)
    {
        return;
    }

    BOOL fError     = dwFlags & (TI_HRESULT | TI_WIN32);
    BOOL fIgnorable = dwFlags & TI_IGNORABLE;

    HRESULT hr           = (dwFlags & TI_HRESULT) ? dwErrorCode : S_OK;
    DWORD   dwWin32Error = (dwFlags & TI_WIN32)   ? dwErrorCode : ERROR_SUCCESS;

    // Ignore if told and we're not set to trace ignored errors or warnings.
    //
    if (fError && fIgnorable &&
        !FIsDebugFlagSet (dfidShowIgnoredErrors) &&
        !FIsDebugFlagSet (dfidExtremeTracing))
    {
        return;
    }

    // Don't do anything if we're tracing for an error and we don't have one,
    // unless the "Extreme Tracing" flag is on, in which case we trace
    // everything in the world (for debugger use only, really)
    // This is the path taken by TraceError ("...", S_OK) or
    // TraceLastWin32Error when there is no last Win32 error.
    //
    if (fError && !dwErrorCode && !FIsDebugFlagSet(dfidExtremeTracing))
    {
        return;
    }

    CHAR szaBuf [MAX_TRACE_LEN * 2];
    PSTR pcha = szaBuf;

    // Form the prefix, process id and thread id.
    //
    static const CHAR c_szaFmtPrefix [] = "NETCFG";
    lstrcpyA (pcha, c_szaFmtPrefix);
    pcha += lstrlenA (c_szaFmtPrefix);

    // Add process and thread ids if the debug flags indicate to do so.
    //
    if (FIsDebugFlagSet (dfidShowProcessAndThreadIds))
    {
        static const CHAR c_szaFmtPidAndTid [] = " %03x.%03x";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtPidAndTid,
                    GetCurrentProcessId (),
                    GetCurrentThreadId ());
    }

    // Add a time stamp if the debug flags indicate to do so.
    //
    if (FIsDebugFlagSet (dfidTracingTimeStamps))
    {
        static const CHAR c_szaFmtTime [] = " [%02dh%02d:%02d.%03d]";

        SYSTEMTIME stLocal;
        GetLocalTime (&stLocal);
        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtTime,
                    stLocal.wHour,
                    stLocal.wMinute,
                    stLocal.wSecond,
                    stLocal.wMilliseconds);
    }

    // Add a severity indicator if this trace is for an error or warning.
    //
    if (fError || (ttidError == ttid))
    {
        static const CHAR c_szaSevIgnored [] = " Ignored:";
        static const CHAR c_szaSevError   [] = " *ERROR*:";
        static const CHAR c_szaSevWarning [] = " Warning:";

        PCSTR pszaSev = NULL;

        if (fError && SUCCEEDED(hr) && !dwWin32Error && !fIgnorable)
        {
            pszaSev = c_szaSevWarning;
        }
        else
        {
            if (fIgnorable && FIsDebugFlagSet (dfidShowIgnoredErrors))
            {
                pszaSev = c_szaSevIgnored;
            }
            else
            {
                pszaSev = c_szaSevError;
            }
        }
        Assert (pszaSev);

        lstrcatA (pcha, pszaSev);
        pcha += lstrlenA (pszaSev);
    }

    // Add the tracetag short name.  Don't do this for ttidError if
    // we already have the severity indicator from above.
    //
    if (ttid && (ttid < g_nTraceTagCount) && (ttid != ttidError))
    {
        if (FIsDebugFlagSet(dfidTraceMultiLevel))
        {
            static const CHAR c_szaFmtTraceTag [] = " (%-16s)";
            pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtTraceTag,
                        g_TraceTags[ttid].szShortName);
        }
        else
        {
            static const CHAR c_szaFmtTraceTag [] = " (%s)";
            pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtTraceTag,
                        g_TraceTags[ttid].szShortName);
        }
    
        *pcha = ' ';
        pcha++;
        
        if (FIsDebugFlagSet(dfidTraceMultiLevel))
        {
            // Add the indentation text.

            DWORD dwNumSpaces = CTracingIndent::getspaces();
            Assert(dwNumSpaces >= 2);
            
            pcha += _snprintf(pcha, MAX_TRACE_LEN, "%1x", dwNumSpaces - 2);
            
            memset(pcha, '-', dwNumSpaces-1 );
            pcha += dwNumSpaces-1;
        }
    }
    else
    {
        *pcha = ' ';
        pcha++;
    }

    // Add the caller's text.
    //
    if (pszaCallerText)
    {
        static const CHAR c_szaFmtCallerText [] = "%s";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtCallerText,
                    pszaCallerText);

        Assert (pcha > szaBuf);
        if ('\n' == *(pcha-1))
        {
            pcha--;
            *pcha = 0;
        }
    }

    // Add descriptive error text if this is an error and we can get some.
    //
    if (FAILED(hr) || dwWin32Error)
    {
        BOOL fFacilityWin32 = (FACILITY_WIN32 == HRESULT_FACILITY(hr));

        // dwError will be the error code we pass to FormatMessage.  It may
        // come from hr or dwWin32Error.  Give preference to hr.
        //
        DWORD dwError = 0;

        if (fFacilityWin32)
        {
            dwError = HRESULT_CODE(hr);
        }
        else if (FAILED(hr))
        {
            dwError = hr;
        }
        else
        {
            dwError = dwWin32Error;
        }
        Assert (dwError);

        if (!FIsDebugFlagSet (dfidNoErrorText))
        {
            PSTR pszaErrorText = NULL;
            FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL, dwError,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                           (PSTR)&pszaErrorText, 0, NULL);

            if (pszaErrorText)
            {
                // Strip off newline characters.
                //
                PSTR pchText = pszaErrorText;
                while (*pchText && (*pchText != '\r') && (*pchText != '\n'))
                {
                    pchText++;
                }
                *pchText = 0;

                // Add the error text.
                //
                static const CHAR c_szaFmtErrorText [] = " [%s]";

                pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtErrorText,
                            pszaErrorText);

                LocalFree (pszaErrorText);
            }
        }

        // Add the Win32 error code.
        //
        if (fFacilityWin32 || dwWin32Error)
        {
            static const CHAR c_szaFmtWin32Error [] = " Win32=%d,0x%08X";

            pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtWin32Error,
                        dwError, dwError);
        }
    }

    // Add the HRESULT.
    //
    if (S_OK != hr)
    {
        static const CHAR c_szaFmtHresult [] = " hr=0x%08X";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtHresult,
                    hr);
    }

    // Add the file and line.
    //
    if (pszaFile)
    {
        static const CHAR c_szaFmtFileAndLine [] = " File:%s,%d";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtFileAndLine,
                    pszaFile, nLine);
    }

    // Add the newline.
    //
    lstrcatA (pcha, "\n");

    g_Tracing.Trace (ttid, szaBuf);

    // Now that the message is on the debugger, break if we have an error
    // and the debug flag to break on error is set.
    //
    if ((FAILED(hr) || dwWin32Error || (ttidError == ttid)) &&
        !fIgnorable && FIsDebugFlagSet(dfidBreakOnError))
    {
        DebugBreak();
    }

    if ( (bTraceStackOnError) && FIsDebugFlagSet(dfidTraceCallStackOnError) && (ttid == ttidError) )
    {
        CTracingIndent::TraceStackFn(ttidError);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceInternal
//
//  Purpose:    The one and only place that a string to be traced is formed
//              and traced.
//
//  Arguments:
//
//  Returns:    nothing.
//
//  Author:     shaunco   13 Mar 1998
//
//  Notes:      Restructured from lots of other code that was added to this
//              module over the past year.
//
VOID
TraceInternal (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    PCSTR       pszaFunc,
    DWORD       dwFlags,
    PCSTR       pszaCallerText,
    DWORD       dwErrorCode,
    BOOL        bTraceStackOnError)
{
    // If this tracetag is turned off, don't do anything.
    //
    if (!g_TraceTags[ttid].fOutputDebugString &&
        !g_TraceTags[ttid].fOutputToFile)
    {
        return;
    }

    BOOL fError     = dwFlags & (TI_HRESULT | TI_WIN32);
    BOOL fIgnorable = dwFlags & TI_IGNORABLE;

    HRESULT hr           = (dwFlags & TI_HRESULT) ? dwErrorCode : S_OK;
    DWORD   dwWin32Error = (dwFlags & TI_WIN32)   ? dwErrorCode : ERROR_SUCCESS;

    // Ignore if told and we're not set to trace ignored errors or warnings.
    //
    if (fError && fIgnorable &&
        !FIsDebugFlagSet (dfidShowIgnoredErrors) &&
        !FIsDebugFlagSet (dfidExtremeTracing))
    {
        return;
    }

    // Don't do anything if we're tracing for an error and we don't have one,
    // unless the "Extreme Tracing" flag is on, in which case we trace
    // everything in the world (for debugger use only, really)
    // This is the path taken by TraceError ("...", S_OK) or
    // TraceLastWin32Error when there is no last Win32 error.
    //
    if (fError && !dwErrorCode && !FIsDebugFlagSet(dfidExtremeTracing))
    {
        return;
    }

    CHAR szaBuf [MAX_TRACE_LEN * 2];
    PSTR pcha = szaBuf;

    // Form the prefix, process id and thread id.
    //
    static const CHAR c_szaFmtPrefix [] = "NETCFG";
    lstrcpyA (pcha, c_szaFmtPrefix);
    pcha += lstrlenA (c_szaFmtPrefix);

    // Add process and thread ids if the debug flags indicate to do so.
    //
    if (FIsDebugFlagSet (dfidShowProcessAndThreadIds))
    {
        static const CHAR c_szaFmtPidAndTid [] = " %03d.%03d";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtPidAndTid,
                    GetCurrentProcessId (),
                    GetCurrentThreadId ());
    }

    // Add a time stamp if the debug flags indicate to do so.
    //
    if (FIsDebugFlagSet (dfidTracingTimeStamps))
    {
        static const CHAR c_szaFmtTime [] = " [%02d:%02d:%02d.%03d]";

        SYSTEMTIME stLocal;
        GetLocalTime (&stLocal);
        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtTime,
                    stLocal.wHour,
                    stLocal.wMinute,
                    stLocal.wSecond,
                    stLocal.wMilliseconds);
    }

    // Add a severity indicator if this trace is for an error or warning.
    //
    if (fError || (ttidError == ttid))
    {
        static const CHAR c_szaSevIgnored [] = " Ignored:";
        static const CHAR c_szaSevError   [] = " *ERROR*:";
        static const CHAR c_szaSevWarning [] = " Warning:";

        PCSTR pszaSev = NULL;

        if (fError && SUCCEEDED(hr) && !dwWin32Error && !fIgnorable)
        {
            pszaSev = c_szaSevWarning;
        }
        else
        {
            if (fIgnorable && FIsDebugFlagSet (dfidShowIgnoredErrors))
            {
                pszaSev = c_szaSevIgnored;
            }
            else
            {
                pszaSev = c_szaSevError;
            }
        }
        Assert (pszaSev);

        lstrcatA (pcha, pszaSev);
        pcha += lstrlenA (pszaSev);
    }

    // Add the tracetag short name.  Don't do this for ttidError if
    // we already have the severity indicator from above.
    //
    if (ttid && (ttid < g_nTraceTagCount) && (ttid != ttidError))
    {
        static const CHAR c_szaFmtTraceTag [] = " (%s)";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtTraceTag,
                    g_TraceTags[ttid].szShortName);
    }

    // Add the caller's text.
    //
    if (pszaCallerText)
    {
        static const CHAR c_szaFmtCallerText [] = " %s";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtCallerText,
                    pszaCallerText);

        Assert (pcha > szaBuf);
        if ('\n' == *(pcha-1))
        {
            pcha--;
            *pcha = 0;
        }
    }

    // Add descriptive error text if this is an error and we can get some.
    //
    if (FAILED(hr) || dwWin32Error)
    {
        BOOL fFacilityWin32 = (FACILITY_WIN32 == HRESULT_FACILITY(hr));

        // dwError will be the error code we pass to FormatMessage.  It may
        // come from hr or dwWin32Error.  Give preference to hr.
        //
        DWORD dwError = 0;

        if (fFacilityWin32)
        {
            dwError = HRESULT_CODE(hr);
        }
        else if (FAILED(hr))
        {
            dwError = hr;
        }
        else
        {
            dwError = dwWin32Error;
        }
        Assert (dwError);

        if (!FIsDebugFlagSet (dfidNoErrorText))
        {
            PSTR pszaErrorText = NULL;
            FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL, dwError,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                           (PSTR)&pszaErrorText, 0, NULL);

            if (pszaErrorText)
            {
                // Strip off newline characters.
                //
                PSTR pchText = pszaErrorText;
                while (*pchText && (*pchText != '\r') && (*pchText != '\n'))
                {
                    pchText++;
                }
                *pchText = 0;

                // Add the error text.
                //
                static const CHAR c_szaFmtErrorText [] = " [%s]";

                pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtErrorText,
                            pszaErrorText);

                LocalFree (pszaErrorText);
            }
        }

        // Add the Win32 error code.
        //
        if (fFacilityWin32 || dwWin32Error)
        {
            static const CHAR c_szaFmtWin32Error [] = " Win32=%d,0x%08X";

            pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtWin32Error,
                        dwError, dwError);
        }
    }

    // Add the HRESULT.
    //
    if (S_OK != hr)
    {
        static const CHAR c_szaFmtHresult [] = " hr=0x%08X";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtHresult,
                    hr);
    }

    // Add the file and line.
    //
    if (pszaFile)
    {
        static const CHAR c_szaFmtFileAndLine [] = " File:%s,%d";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtFileAndLine,
                    pszaFile, nLine);
    }

    // Add the function name
    //
    if (pszaFunc)
    {
        static const CHAR c_szaFmtFunc[] = ":";

        pcha += _snprintf (pcha, MAX_TRACE_LEN, c_szaFmtFunc, pszaFunc);
    }
    
    // Add the newline.
    //
    lstrcatA (pcha, "\n");

    g_Tracing.Trace (ttid, szaBuf);

    // Now that the message is on the debugger, break if we have an error
    // and the debug flag to break on error is set.
    //
    if ((FAILED(hr) || dwWin32Error || (ttidError == ttid)) &&
        !fIgnorable && FIsDebugFlagSet(dfidBreakOnError))
    {
        DebugBreak();
    }

    if ( (bTraceStackOnError) && FIsDebugFlagSet(dfidTraceCallStackOnError) && (ttid == ttidError) )
    {
        CTracingIndent::TraceStackFn(ttidError);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceErrorFn
//
//  Purpose:    Output debug trace of an HRESULT, allowing an additional
//              caller-defined error string.
//
//  Arguments:
//      sz          []  Caller-defined additional error text
//      hr          []  The error HRESULT.
//
//  Returns:
//
//  Author:     jeffspr   14 Apr 1997
//
//  Notes:
//
VOID
WINAPI
TraceErrorFn (
    PCSTR   pszaFile,
    INT     nLine,
    PCSTR   psza,
    HRESULT hr)
{   
    DWORD dwFlags = TI_HRESULT;
    if (S_FALSE == hr)
    {
        dwFlags |= TI_IGNORABLE;
    }

    TraceInternal (ttidError, pszaFile, nLine, dwFlags, psza, hr, TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceErrorOptionalFn
//
//  Purpose:    Implements TraceErrorOptional macro
//
//  Arguments:
//      pszaFile [in]     __FILE__ value
//      nLine    [in]     __LINE__ value
//      psza     [in]     String to trace.
//      hr       [in]     HRESULT value to trace.
//      fOpt     [in]     TRUE if error should be treated as optional, FALSE if
//                        ERROR is not optional and should be reported thru
//                        TraceError().
//
//  Returns:    Nothing.
//
//  Author:     danielwe   12 May 1997
//
//  Notes:
//
VOID
WINAPI
TraceErrorOptionalFn (
    PCSTR   pszaFile,
    INT     nLine,
    PCSTR   psza,
    HRESULT hr,
    BOOL    fIgnorable)
{
    DWORD dwFlags = TI_HRESULT;
    if (fIgnorable)
    {
        dwFlags |= TI_IGNORABLE;
    }

    TraceInternal (ttidError, pszaFile, nLine, dwFlags, psza, hr, TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   TraceErrorSkipFn
//
//  Purpose:    Implements TraceErrorOptional macro
//
//  Arguments:
//      pszaFile [in]     __FILE__ value
//      nLine    [in]     __LINE__ value
//      psza     [in]     String to trace.
//      hr       [in]     HRESULT value to trace.
//      c        [in]     count of pass-through Hresults.  if hr is any of these
//                        the error is treated as optional.
//      ...      [in]     list of hresults.
//
//  Returns:    Nothing.
//
//  Author:     sumitc      08 Jan 1998
//
//  Notes:
//
VOID WINAPI
TraceErrorSkipFn (
    PCSTR   pszaFile,
    INT     nLine,
    PCSTR   psza,
    HRESULT hr,
    UINT    c, ...)
{
    va_list valMarker;
    BOOL fIgnorable = FALSE;

    va_start(valMarker, c);
    for (UINT i = 0; i < c; ++i)
    {
        fIgnorable = (va_arg(valMarker, HRESULT) == hr);
        if (fIgnorable)
        {
            break;
        }
    }
    va_end(valMarker);

    DWORD dwFlags = TI_HRESULT;
    if (fIgnorable)
    {
        dwFlags |= TI_IGNORABLE;
    }
    TraceInternal (ttidError, pszaFile, nLine, dwFlags, psza, hr, TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceLastWin32ErrorFn
//
//  Purpose:    Trace the last Win32 error, which we get with GetLastError().
//              Not a whole lot to it.
//
//  Arguments:
//      sz []   Additional error text.
//
//  Returns:
//
//  Author:     jeffspr   14 Apr 1997
//
//  Notes:
//
VOID
WINAPIV
TraceLastWin32ErrorFn (
    PCSTR  pszaFile,
    INT    nLine,
    PCSTR  psza)
{
    TraceInternal (ttidError, pszaFile, nLine, TI_WIN32, psza, GetLastError(), TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceHrFn
//
//  Purpose:    Generic replacement for the TraceErrorOptional, TraceError,
//              and a couple other random functions.
//
//  Arguments:
//      ttid       [] TraceTag to use for the debug output
//      pszaFile   [] Source file to log
//      nLine      [] Line number to log
//      hr         [] Error to log
//      fIgnorable [] Ignore this error? (The optional bit)
//      pszaFmt    [] Format of the vargs
//
//  Returns:
//
//  Author:     jeffspr   10 Oct 1997
//
//  Notes:
//
VOID
WINAPIV
TraceHrFn (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    HRESULT     hr,
    BOOL        fIgnorable,
    PCSTR       pszaFmt,
    ...)
{
    // If this tracetag is turned off, don't do anything.
    //
    if (!g_TraceTags[ttid].fOutputDebugString &&
        !g_TraceTags[ttid].fOutputToFile)
    {
        return;
    }

    CHAR szaBuf [MAX_TRACE_LEN];

    // Build the string from the varg list
    //
    va_list valMarker;
    va_start (valMarker, pszaFmt);
    vsprintf (szaBuf, pszaFmt, valMarker);
    va_end (valMarker);

    DWORD dwFlags = TI_HRESULT;
    if (fIgnorable)
    {
        dwFlags |= TI_IGNORABLE;
    }
    TraceInternal (ttid, pszaFile, nLine, dwFlags, szaBuf, hr, TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceHrFn
//
//  Purpose:    Generic replacement for the TraceErrorOptional, TraceError,
//              and a couple other random functions.
//
//  Arguments:
//      ttid       [] TraceTag to use for the debug output
//      pszaFile   [] Source file to log
//      nLine      [] Line number to log
//      hr         [] Error to log
//      fIgnorable [] Ignore this error? (The optional bit)
//      pszaFmt    [] Format of the vargs
//
//  Returns:
//
//  Author:     jeffspr   10 Oct 1997
//
//  Notes:
//
VOID
WINAPIV
TraceHrFn (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    PCSTR       pszaFunc,
    HRESULT     hr,
    BOOL        fIgnorable,
    PCSTR       pszaFmt,
    ...)
{
    // If this tracetag is turned off, don't do anything.
    //
    if (!g_TraceTags[ttid].fOutputDebugString &&
        !g_TraceTags[ttid].fOutputToFile)
    {
        return;
    }

    CHAR szaBuf [MAX_TRACE_LEN];

    // Build the string from the varg list
    //
    va_list valMarker;
    va_start (valMarker, pszaFmt);
    _vsnprintf (szaBuf, MAX_TRACE_LEN, pszaFmt, valMarker);
    va_end (valMarker);

    DWORD dwFlags = TI_HRESULT;
    if (fIgnorable)
    {
        dwFlags |= TI_IGNORABLE;
    }
    TraceInternal (ttid, pszaFile, nLine, pszaFunc, dwFlags, szaBuf, hr, TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   TraceTagFn
//
//  Purpose:    Output a debug trace to one or more trace targets (ODS,
//              File, COM port, etc.). This function determines the targets
//              and performs the actual trace.
//
//  Arguments:
//      ttid    []  TraceTag to use for the debug output
//      pszaFmt []  Format of the vargs.
//
//  Returns:
//
//  Author:     jeffspr   14 Apr 1997
//
//  Notes:
//
VOID
WINAPIV
TraceTagFn (
    TRACETAGID  ttid,
    PCSTR       pszaFmt,
    ...)
{
    // If this tracetag is turned off, don't do anything.
    //
    if (!g_TraceTags[ttid].fOutputDebugString &&
        !g_TraceTags[ttid].fOutputToFile)
    {
        return;
    }

    CHAR szaBuf [MAX_TRACE_LEN];

    // Build the string from the varg list
    //
    va_list valMarker;
    va_start (valMarker, pszaFmt);
    _vsnprintf (szaBuf, MAX_TRACE_LEN, pszaFmt, valMarker);
    va_end (valMarker);

    TraceInternal (ttid, NULL, 0, 0, szaBuf, 0, TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::CTracing
//
//  Purpose:    Constructor for CTracing. Initialize all vars.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   23 Jan 1999
//
//  Notes:
//
CTracing::CTracing()
{
    m_fInitialized          = FALSE;    // Has the object been initialized
    m_fAttemptedLogFileOpen = FALSE;    // Already attempted to open log
    m_fDisableLogFile       = FALSE;    // Disable use of file logging?
    m_uiAllocOnWhichToBreak = 0;        // For _CrtSetBreakAlloc
    m_hLogFile              = NULL;     // Handle for debug output file
    m_szLogFilePath[0]      = '\0';     // File for debug output
    m_fDebugFlagsLoaded     = FALSE;    // Have these been loaded yet.

    g_dwTlsTracing          = NULL;
    HrInit();
}

CTracing::~CTracing()
{
    HrUnInit();
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrInit
//
//  Purpose:    Initialize the CTracing object.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   9 Apr 1997
//
//  Notes:      This should get called from some standard exe initialization
//              point. And make sure to call HrDeinit when you're done, eh?
//
HRESULT CTracing::HrInit()
{
    HRESULT hr  = S_OK;

    AssertSz(!m_fInitialized,
            "CTracing::HrInit -- Let's not go overboard. Already initialized");

    g_csTracing = new CRITICAL_SECTION;
    Assert(g_csTracing);
    InitializeCriticalSection(g_csTracing);

    g_dwTlsTracing = TlsAlloc();
    AssertSz(g_dwTlsTracing, "g_dwTlsTracing could not aquire a TLS slot");

    hr = FIniFileInit();
    if (FAILED(hr))
    {
        goto Exit;
    }

    // Temporarily set this so the called functions don't believe that we're
    // uninitialized. At Exit, if we fail, we'll set it back so no-one tries
    // to call these functions when uninitialized.
    //
    m_fInitialized = TRUE;

    // Check for corruptions in the tracing structure. This can't fail, but
    // it will send up asserts all over the place if something is amiss.
    //
    CorruptionCheck();

    // Load the "options" section from the ini file
    //
    hr = HrLoadOptionsFromIniFile();
    if (FAILED(hr))
    {
        goto Exit;
    }

    // Load the DebugFlags section from the ini file.
    //
    hr = HrLoadDebugFlagsFromIniFile();
    if (FAILED(hr))
    {
        goto Exit;
    }

    // Load the tracetag sections from the ini file.
    // Make sure this is called after HrLoadDebugFlagsFromIniFile(),
    // as those options will affect the tracetag sections (we also
    // assert on this)
    //
    hr = HrLoadSectionsFromIniFile();
    if (FAILED(hr))
    {
        goto Exit;
    }

    // If certain tracetags are on, we want others to be off because some
    // encompase the functionality of others.
    //
    if (g_TraceTags[ttidBeDiag].fOutputDebugString)
    {
        g_TraceTags[ttidNetCfgPnp].fOutputDebugString = FALSE;
    }


#ifdef ENABLELEAKDETECTION
    if (FIsDebugFlagSet(dfidTrackObjectLeaks))
    {
        g_pObjectLeakTrack = new CObjectLeakTrack;
        Assert(g_pObjectLeakTrack);
    }
#endif

Exit:
    if (FAILED(hr))
    {
        m_fInitialized = FALSE;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrUnInit
//
//  Purpose:    Uninitialize the Tracing object
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   12 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrUnInit()
{
    HRESULT hr  = S_OK;

#ifdef ENABLELEAKDETECTION
    if (FIsDebugFlagSet(dfidTrackObjectLeaks))
    {
        BOOL fAsserted = g_pObjectLeakTrack->AssertIfObjectsStillAllocated(NULL);
        delete g_pObjectLeakTrack;
        if (fAsserted)
        {
            AssertSz(FALSE, "Spew is completed - press RETRY to look at spew and map ReturnAddr values to symbols");
        }
    }
#endif
    
    if (g_dwTlsTracing)
    {
        TlsFree(g_dwTlsTracing);
        g_dwTlsTracing = 0;
    }

    if (g_csTracing)
    {
        {
            __try
            {
                EnterCriticalSection(g_csTracing);
            }
            __finally
            {
                LeaveCriticalSection(g_csTracing);
            }
        }
        
        DeleteCriticalSection(g_csTracing);
        delete g_csTracing;
        g_csTracing = NULL;
    }
    
    // Don't assert on m_fInitialized here, because we allow this to
    // be called even if initialization failed.
    //
    if (m_fInitialized)
    {
        hr = HrWriteDebugFlagsToIniFile();
        if (FAILED(hr))
        {
            // continue on, but I want to know why this is failing.
            AssertSz(FALSE, "Whoa, why can't we write the debug flags?");
        }

        // Close the log file, if there's one open
        //
        if (m_hLogFile)
        {
            CloseHandle(m_hLogFile);
            m_hLogFile = NULL;
        }

        // Mark us as being uninitialized.
        //
        m_fInitialized = FALSE;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrGetPrivateProfileString
//
//  Purpose:
//
//  Arguments:
//      lpAppName        [] points to section name
//      lpKeyName        [] points to key name
//      lpDefault        [] points to default string
//      lpReturnedString [] points to destination buffer
//      nSize            [] size of destination buffer
//      lpFileName       [] points to initialization filename
//      pcchReturn          return buffer for the old Win32 API return code
//
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   12 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrGetPrivateProfileString(    PCSTR  lpAppName,
                                                PCSTR  lpKeyName,
                                                PCSTR  lpDefault,
                                                PSTR   lpReturnedString,
                                                DWORD  nSize,
                                                PCSTR  lpFileName,
                                                DWORD* pcchReturn
)
{
    HRESULT hr              = S_OK;

    Assert(m_fInitialized);

    // Assert on the known conditions required for this API call
    //
    Assert(lpDefault);
    Assert(lpFileName);

    // Call the Win32 API
    //
    DWORD dwGPPSResult = GetPrivateProfileStringA(
            lpAppName,
            lpKeyName,
            lpDefault,
            lpReturnedString,
            nSize,
            lpFileName);

    // Check to see if we've gotten a string-size error
    if (lpAppName && lpKeyName)
    {
        // If we get back (nSize - 1), then our string buffer wasn't
        // large enough
        //
        if (dwGPPSResult == (nSize - 1))
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }
    }
    else
    {
        // Since either of the app name or key name are NULL, then
        // we're supposed to be receiving a doubly-NULL terminated
        // list of strings. If we're at (nSize - 2), that means
        // our buffer was too small.
        //
        if (dwGPPSResult == (nSize - 2))
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;
        }
    }

Exit:
    *pcchReturn = dwGPPSResult;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrLoadOptionsFromIniFile
//
//  Purpose:    Load the options section from the ini file, and set our
//              state accordingly
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   10 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrLoadOptionsFromIniFile()
{
    HRESULT hr                          = S_OK;
    DWORD   cchReturnBufferSize         = 0;
    WCHAR   szLogFilePath[MAX_PATH+1]   = { 0 };
    DWORD   dwTempPathLength            = 0;

    // Get the explicit log file path, if any. If it doesn't exist, then
    // use the default path, which is the temp file path plus the default
    // trace file name
    //

    // Get the location of the "temporary files" path
    dwTempPathLength = GetTempPath(MAX_PATH, szLogFilePath);
    if ((dwTempPathLength == 0) ||
        (dwTempPathLength > MAX_PATH))
    {
        TraceLastWin32Error("GetTempPath failure");

        hr = HrFromLastWin32Error();
        goto Exit;
    }

    // Tack the log file name onto the end.
    //
    _snprintf(m_szLogFilePath, MAX_TRACE_LEN, "%s%s", szLogFilePath, c_szTraceLogFileNameA);

    // This will overwrite the log file path if one exists in the INI file
    //
    hr = HrGetPrivateProfileString(
            c_szaOptions,           // "Options"
            c_szaLogFilePath,       // "LogFilePath
            m_szLogFilePath,        // Default string, already filled
            m_szLogFilePath,        // Return string (same string)
            MAX_PATH+1,
            c_szDebugIniFileNameA,
            &cchReturnBufferSize);
    if (FAILED(hr))
    {
        // This should not cause problems with recursive failure, since
        // Traces will work regardless of the state of trace initialization.
        //
        TraceError(
                "GetPrivateProfileString failed on Options::LogFilePath", hr);
        goto Exit;
    }

    // Get the "disable log file option". No return code here.
    m_fDisableLogFile = GetPrivateProfileIntA(
            c_szaOptions,               // "Options"
            c_szaDisableLogFile,        // "DisableLogFile"
            c_iDefaultDisableLogFile,
            c_szDebugIniFileNameA);
    if (FAILED(hr))
    {
        TraceError(
                "GetPrivateProfileInt failed on Options::DisableLogFile", hr);
        goto Exit;
    }

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrLoadSectionsFromIniFile
//
//  Purpose:    Load the individual tracetag sections from the ini file, and
//              set our array elements accordingly, defaulting if necessary.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   10 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrLoadSectionsFromIniFile()
{
    HRESULT hr = S_OK;

    // Make sure that we've loaded the debug flags first, as they can
    // affect each tracetag section
    //
    Assert(m_fDebugFlagsLoaded);

    // Loop through the array and load the data.
    //
    for (INT nLoop = 0; nLoop < g_nTraceTagCount; nLoop++ )
    {
        // Process the individual lines from the section
        hr = HrProcessTagSection(&(g_TraceTags[nLoop]));
        if (FAILED(hr))
        {
            break;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrLoadDebugFlagsFromIniFile
//
//  Purpose:    Load the individual debugflag values from the ini file, and
//              set our array elements accordingly, defaulting if necessary.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 HRESULT
//
//  Author:     jeffspr   10 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrLoadDebugFlagsFromIniFile()
{
    HRESULT hr                  = S_OK;
    INT     nLoop;

    // Loop through the array and load the data.
    //
    for (nLoop = 0; nLoop < g_nDebugFlagCount; nLoop++)
    {
        switch(nLoop)
        {
            case dfidBreakOnAlloc:
                // Get the "break on alloc" alloc count.
                //
                m_uiAllocOnWhichToBreak = GetPrivateProfileIntA(
                    "DebugFlags",
                    g_DebugFlags[nLoop].szShortName,
                    FALSE,
                    c_szDebugIniFileNameA);
                g_DebugFlags[nLoop].dwValue = (m_uiAllocOnWhichToBreak > 0);

                // If there was a value set, set the break..
                //
                if (m_uiAllocOnWhichToBreak != 0)
                    _CrtSetBreakAlloc(m_uiAllocOnWhichToBreak);

                break;

            default:
                // Get the enabled file param
                //
                g_DebugFlags[nLoop].dwValue = GetPrivateProfileIntA(
                        "DebugFlags",
                        g_DebugFlags[nLoop].szShortName,
                        FALSE,
                        c_szDebugIniFileNameA);
                break;
        }
    }

    if (SUCCEEDED(hr))
    {
        m_fDebugFlagsLoaded = TRUE;
    }

    return hr;
}

HRESULT CTracing::FIniFileInit()
{
    HRESULT hr = E_FAIL;
    WCHAR   szWindowsPath[MAX_PATH+1]  = L"";
    WCHAR   szPath[MAX_PATH+1]  = L"";
    UINT    uiCharsReturned     = 0;
    HANDLE  hFile               = INVALID_HANDLE_VALUE;

    uiCharsReturned = GetWindowsDirectory(szWindowsPath, MAX_PATH);
    if ((uiCharsReturned == 0) || (uiCharsReturned > MAX_PATH))
    {
        AssertSz(FALSE, "GetWindowsDirectory failed in CTracing::FIniFileInit");

        hr = E_UNEXPECTED;
        goto Exit;
    }

    wcscpy (szPath, szWindowsPath);
    wcscat (szPath, L"\\");
    wcscat (szPath, c_szDebugIniFileName);

    hFile = CreateFile(
            szPath,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        DWORD dwLastError = GetLastError();

        if (dwLastError != ERROR_FILE_NOT_FOUND)
        {
            AssertSz(FALSE, "FIniFileInit failed for some reason other than FILE_NOT_FOUND");
            hr = HRESULT_FROM_WIN32(dwLastError);
            goto Exit;
        }
    }
    else
    {
        hr = S_OK;
        wcstombs(c_szDebugIniFileNameA, szPath, MAX_PATH);
        goto Exit;
    }
    
    _wsplitpath(szWindowsPath, szPath, NULL, NULL, NULL);
    wcscat (szPath, L"\\");
    wcscat (szPath, c_szDebugIniFileName);

    hFile = CreateFile(
            szPath,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        DWORD dwLastError = GetLastError();

        hr = HRESULT_FROM_WIN32(dwLastError);
        if (dwLastError != ERROR_FILE_NOT_FOUND)
        {
            AssertSz(FALSE, "FIniFileInit failed for some reason other than FILE_NOT_FOUND");
        }
    }
    else
    {
        wcstombs(c_szDebugIniFileNameA, szPath, MAX_PATH);
        hr = S_OK;
    }
    
Exit:
    if (hFile)
    {
        CloseHandle(hFile);
        hFile = NULL;
    }

    return hr;
}

HRESULT CTracing::HrWriteDebugFlagsToIniFile()
{
    HRESULT hr = S_OK;

    // First, check to see if the file exists. If it doesn't, then we don't want
    // to write the entries.
    //
    if (FIniFileInit())
    {
        // Loop through the array and write the data.
        //
        for (INT nLoop = 0; nLoop < g_nDebugFlagCount; nLoop++)
        {
            CHAR   szInt[16];      // Sure, it's arbitrary, but it's also OK.

            switch(nLoop)
            {
                // BreakOnAlloc is special case -- no associated flag entry
                //
                case dfidBreakOnAlloc:
                    _snprintf(szInt, MAX_TRACE_LEN, "%d", m_uiAllocOnWhichToBreak);
                    break;

                // These store a DWORD in its standard form
                //
                case dfidBreakOnHr:
                case dfidBreakOnHrIteration:
                case dfidBreakOnIteration:
                    _snprintf( szInt, MAX_TRACE_LEN, "%d", g_DebugFlags[nLoop].dwValue);
                    break;

                // default are treated as boolean, and stored that way
                //
                default:
                    // !! means it will always be 1 or 0.
                    _snprintf( szInt, MAX_TRACE_LEN, "%d", (!!g_DebugFlags[nLoop].dwValue));
                    break;
            }

            // Write the param to the ini file
            WritePrivateProfileStringA(
                    "DebugFlags",
                    g_DebugFlags[nLoop].szShortName,
                    szInt,
                    c_szDebugIniFileNameA);
        }
    }

    // For now, this is always S_OK, since there's nothing above that can
    // fail.
    //
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTracing::HrProcessTagSection
//
//  Purpose:    Grab the parameters from the ini file. If they're not
//              available, then use the settings in default. Note - this
//              will always work because ttidDefault will always be the first
//              element. If a [default] section wasn't present, then it will
//              be using the settings that were in the struct initialization,
//              which is also fine.
//
//  Arguments:
//      ptte []     TraceTag element to load
//
//  Returns:
//
//  Author:     jeffspr   15 Apr 1997
//
//  Notes:
//
HRESULT CTracing::HrProcessTagSection(  TraceTagElement *   ptte )
{
    HRESULT hr                      = S_OK;

    AssertSz(m_fInitialized,
            "CTracing::HrProcessTagSection. Class not initialized");

    AssertSz(ptte, "CTracing::HrProcessTagSection -- invalid ptte");

    // Get the output to file param
    //
    ptte->fOutputToFile = GetPrivateProfileIntA(
            ptte->szShortName,
            "OutputToFile",
            ptte->fVerboseOnly ?
                FALSE : g_TraceTags[ttidDefault].fOutputToFile,
            c_szDebugIniFileNameA);

    // Get the OutputDebugString param. Require that the error tag
    // always has at least output debug string on.
    //
    if (ptte->ttid == ttidError)
    {
        ptte->fOutputDebugString = TRUE;
    }
    else
    {
        // Load the OutputToDebug
        ptte->fOutputDebugString = GetPrivateProfileIntA(
                ptte->szShortName,
                "OutputToDebug",
                ptte->fVerboseOnly ?
                    FALSE : g_TraceTags[ttidDefault].fOutputDebugString,
                c_szDebugIniFileNameA);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::CorruptionCheck
//
//  Purpose:    Validate the tracetag array. Check to see that the
//              shortnames are valid, that the descriptions are valid,
//              and that the tracetag elements are not out of order.
//              Also verify that the correct number of tracetag elements
//              exist.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   15 Apr 1997
//
//  Notes:
//      (shaunco) 16 Jul 1997: This is #if'defd out until JVert
//      gives us a fix for the alpha compiler.  It blows up compiling this
//      function in retail.
//
//      (jeffspr) Tough noogies for JVert - I need this code. Hopefully
//      this has been fixed by now.
//
VOID CTracing::CorruptionCheck()
{
    INT nLoop = 0;

    // Validate the tracetag structure
    //
    for (nLoop = 0; nLoop < g_nTraceTagCount; nLoop++)
    {
        // Verify that we're not out of order or missing ttids
        //
        AssertSz(g_TraceTags[nLoop].ttid == nLoop,
                "Invalid ttid in the tracetag structure. Out of order. " \
                "CTracing::CorruptionCheck");
        AssertSz(g_TraceTags[nLoop].ttid < g_nTraceTagCount,
                "Invalid ttid (out of range) in CTracing::CorruptionCheck");

        // Validate the shortname (verify not NULL or empty strings)
        //
        AssertSz(g_TraceTags[nLoop].szShortName,
                "Invalid tracetag short name (NULL) in CTracing::CorruptionCheck");
        AssertSz(g_TraceTags[nLoop].szShortName[0] != 0,
                "Invalid tracetagshort name (empty) in CTracing::CorruptionCheck");

        // Validate the descriptions (verify not NULL or empty strings)
        //
        AssertSz(g_TraceTags[nLoop].szDescription,
                "Invalid tracetagdescription in CTracing::CorruptionCheck");
        AssertSz(g_TraceTags[nLoop].szDescription[0] != 0,
                "Invalid tracetagdescription (empty) in CTracing::CorruptionCheck");
    }

    // Validate the debug flags structure
    //
    for (nLoop = 0; nLoop < g_nDebugFlagCount; nLoop++)
    {
        // Verify that we're not out of order or missing dfids
        //
        AssertSz(g_DebugFlags[nLoop].dfid == nLoop,
                "Invalid dfid in the debugflag structure. Out of order. " \
                "CTracing::CorruptionCheck");
        AssertSz(g_DebugFlags[nLoop].dfid < g_nDebugFlagCount,
                "Invalid dfid (out of range) in CTracing::CorruptionCheck");

        // Validate the shortname (verify not NULL or empty strings)
        //
        AssertSz(g_DebugFlags[nLoop].szShortName,
                "Invalid debug flag short name (NULL) in CTracing::CorruptionCheck");
        AssertSz(g_DebugFlags[nLoop].szShortName[0] != 0,
                "Invalid debug flag short name (empty) in CTracing::CorruptionCheck");

        // Validate the descriptions (verify not NULL or empty strings)
        //
        AssertSz(g_DebugFlags[nLoop].szDescription,
                "Invalid debug flag description in CTracing::CorruptionCheck");
        AssertSz(g_DebugFlags[nLoop].szDescription[0] != 0,
                "Invalid debug flag description (empty) in CTracing::CorruptionCheck");
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTracing::Trace
//
//  Purpose:    The actual trace call that takes care of doing the output
//              to each trace target (file, OutputDebugString, etc.)
//
//  Arguments:
//      ttid      []     The tracetag to use for output
//      pszaTrace []     The trace string itself.
//
//  Returns:
//
//  Author:     jeffspr   12 Apr 1997
//
//  Notes:
//
VOID CTracing::Trace( TraceTagId    ttid,
                      PCSTR         pszaTrace )
{
    // HrInit should have called a corruption checker for the entire trace
    // block, but we'll check again just to make sure.
    //
    AssertSz(g_nTraceTagCount > ttid, "ttid out of range in CTracing::Trace");
    AssertSz(g_TraceTags[ttid].ttid == ttid,
            "TraceTag structure is corrupt in CTracing::Trace");

    // If they want debug string output
    //
    if (g_TraceTags[ttid].fOutputDebugString)
    {
        // Then output the string
        //
        OutputDebugStringA(pszaTrace);
    }

    // If they want file output
    if (g_TraceTags[ttid].fOutputToFile)
    {
        if (!m_hLogFile)
        {
            // Assuming that we haven't already tried to open the file
            // and failed, open it.
            if (!m_fAttemptedLogFileOpen)
            {
                HRESULT hr = HrOpenLogFile();
                if (FAILED(hr))
                {
                    AssertSz(FALSE, "Failed to open log file for tracing. No, "
                             "this isn't a coding error, but hey, figured that "
                             "you'd want to know...");
                }
            }
        }

        // If we were already open, or the open has now succeeded, do the
        // trace
        //
        if (m_hLogFile)
        {
            Assert(pszaTrace);

            // Since pszTrace is guaranteed to be a single-byte trace, we
            // don't need to do the WCHAR multiply on the length, just
            // a char multiply.
            //
            DWORD   dwBytesToWrite  = lstrlenA(pszaTrace) * sizeof(CHAR);
            DWORD   dwBytesWritten  = 0;
            BOOL    fWriteResult    = FALSE;

            fWriteResult = WriteFile(
                    m_hLogFile,         // handle to file to write to
                    pszaTrace,           // pointer to data to write to file
                    dwBytesToWrite,     // size of trace
                    &dwBytesWritten,    // Bytes actually written.
                    NULL );             // No overlapped

            if (!fWriteResult || (dwBytesToWrite != dwBytesWritten))
            {
                AssertSz(FALSE, "CTracing failure: Can't write to log file."
                         " Can't trace or we'll be recursing on this failure.");
            }
        }
    }
}

HRESULT CTracing::HrOpenLogFile()
{
    HRESULT hr  = S_OK;

    AssertSz(m_fInitialized,
            "CTracing not initialized in HrOpenLogFile()");
    AssertSz(!m_hLogFile,
            "File already open before call to HrOpenLogFile()");

    // Mark us as having attempted to open the file, so we don't call this
    // function everytime we log, if we can't open it.
    //
    m_fAttemptedLogFileOpen = TRUE;

    // $$TODO (jeffspr) - Allow flags in the Options section of the ini
    // file specify the create flags and attributes, which would allow
    // us to control the overwriting of log files and/or the write-through
    // properties.
    //

    // Actually open the file, creating if necessary.
    //
    m_hLogFile = CreateFileA(
            m_szLogFilePath,        // Pointer to name of file
            GENERIC_WRITE,          // access (read-write) mode
            FILE_SHARE_READ,        // share mode (allow read access)
            NULL,                   // pointer to security attributes
            CREATE_ALWAYS,          // how to create
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
            NULL);
    if (INVALID_HANDLE_VALUE == m_hLogFile)
    {
        m_hLogFile = NULL;

        hr = HrFromLastWin32Error();
        goto Exit;
    }

Exit:
    return hr;
}

using namespace std;
typedef deque<CTracingFuncCall> TRACING_FUNCTIONSTACK;

CTracingFuncCall::CTracingFuncCall(const CTracingFuncCall& TracingFuncCall)
{
    Assert(g_csTracing);

    m_szFunctionName = new CHAR[strlen(TracingFuncCall.m_szFunctionName)+1];
    if (m_szFunctionName)
    {
        strcpy(m_szFunctionName, TracingFuncCall.m_szFunctionName);
    }
    else
    {
        m_szFunctionName = c_szLowMemory;
    }
    
    m_szFunctionDName = new CHAR[strlen(TracingFuncCall.m_szFunctionDName)+1];
    if (m_szFunctionDName)
    {
        strcpy(m_szFunctionDName, TracingFuncCall.m_szFunctionDName);
    }
    else
    {
        m_szFunctionDName = c_szLowMemory;
    }
    
    m_szFile = new CHAR[strlen(TracingFuncCall.m_szFile)+1];
    if (m_szFile)
    {
        strcpy(m_szFile, TracingFuncCall.m_szFile);
    }
    else
    {
        m_szFile = c_szLowMemory;
    }
    
    m_dwLine = TracingFuncCall.m_dwLine;
    m_dwFramePointer = TracingFuncCall.m_dwFramePointer;
    m_dwThreadId = TracingFuncCall.m_dwThreadId;
    m_ReturnAddress = TracingFuncCall.m_ReturnAddress;
    
#if defined(_X86_) || defined(_AMD64_)
    m_arguments[0] = TracingFuncCall.m_arguments[0];
    m_arguments[1] = TracingFuncCall.m_arguments[1];
    m_arguments[2] = TracingFuncCall.m_arguments[2];
#elif defined (_IA64_) 
    m_arguments[0] = TracingFuncCall.m_arguments[0];
    m_arguments[1] = TracingFuncCall.m_arguments[1];
    m_arguments[2] = TracingFuncCall.m_arguments[2];
#else 
    // add other processors here
#endif
}

#if defined (_X86_) || defined (_AMD64_)
CTracingFuncCall::CTracingFuncCall(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, DWORD_PTR dwpReturnAddress, const DWORD_PTR dwFramePointer)
#elif defined (_IA64_) 
CTracingFuncCall::CTracingFuncCall(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, DWORD_PTR dwpReturnAddress, const __int64 Args1, const __int64 Args2, const __int64 Args3)
#else
CTracingFuncCall::CTracingFuncCall(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine)
#endif
{
    Assert(g_csTracing);

    m_szFunctionName = new CHAR[strlen(szFunctionName)+1];
    if (m_szFunctionName)
    {
        strcpy(m_szFunctionName, szFunctionName);
    }
    else
    {
        m_szFunctionName = c_szLowMemory;
    }

    m_szFunctionDName = new CHAR[strlen(szFunctionDName)+1];
    if (m_szFunctionDName)
    {
        strcpy(m_szFunctionDName, szFunctionDName);
    }
    else
    {
        m_szFunctionDName = c_szLowMemory;
    }

    m_szFile = new CHAR[strlen(szFile)+1];
    if (m_szFile)
    {
        strcpy(m_szFile, szFile);
    }
    else
    {
        m_szFile = c_szLowMemory;
    }

    m_dwLine = dwLine;
    m_ReturnAddress = dwpReturnAddress;
    
#if defined (_X86_) || defined (_AMD64_)
    m_dwFramePointer = dwFramePointer;
    
    if (dwFramePointer)
    {
        PDWORD_PTR pdwEbp = reinterpret_cast<PDWORD_PTR>(dwFramePointer);
        pdwEbp++; // advance pass BaseEBP
        pdwEbp++; // advance pass ReturnIP
    
        m_arguments[0] = *pdwEbp; pdwEbp++;
        m_arguments[1] = *pdwEbp; pdwEbp++;
        m_arguments[2] = *pdwEbp;
    }
    else
    {
        m_arguments[0] = 0;
        m_arguments[1] = 0;
        m_arguments[2] = 0;
    }
#elif defined (_IA64_) 
    m_dwFramePointer = 0;

    m_arguments[0] = Args1;
    m_arguments[1] = Args2;
    m_arguments[2] = Args3;
#else
    m_dwFramePointer = 0;
#endif

    m_dwThreadId = GetCurrentThreadId();
}

CTracingFuncCall::~CTracingFuncCall()
{
    Assert(g_csTracing);
    
    if (c_szLowMemory != m_szFile)
    {
        delete[] m_szFile;
    }

    if (c_szLowMemory != m_szFunctionDName)
    {
        delete[] m_szFunctionDName;
    }

    if (c_szLowMemory != m_szFunctionName)
    {
        delete[] m_szFunctionName;
    }
}

CTracingThreadInfo::CTracingThreadInfo()
{
    Assert(g_csTracing);

    m_dwLevel = 1;
    m_dwThreadId = GetCurrentThreadId();
    m_pfnStack = new TRACING_FUNCTIONSTACK;
}

CTracingThreadInfo::~CTracingThreadInfo()
{
    Assert(g_csTracing);

    TRACING_FUNCTIONSTACK *pfnStack = reinterpret_cast<TRACING_FUNCTIONSTACK *>(m_pfnStack);
    delete pfnStack;
}

CTracingThreadInfo* CTracingIndent::GetThreadInfo()
{
    CTracingThreadInfo *pThreadInfo = NULL;

    AssertSz(g_dwTlsTracing, "Tracing not initialized... Did RawDllMain run?");
    AssertSz(g_csTracing, "Tracing not initialized... Did RawDllMain run?");

    pThreadInfo = reinterpret_cast<CTracingThreadInfo *>(TlsGetValue(g_dwTlsTracing));
    if (!pThreadInfo)
    {
        pThreadInfo = new CTracingThreadInfo;
        TlsSetValue(g_dwTlsTracing, pThreadInfo);

        Assert(pThreadInfo == reinterpret_cast<CTracingThreadInfo *>(TlsGetValue(g_dwTlsTracing)));
    }

    Assert(pThreadInfo);
    return pThreadInfo;
}

CTracingIndent::CTracingIndent()
{
    bFirstTrace = TRUE;
    m_szFunctionDName = NULL;
    m_dwFramePointer  = NULL;
}

#if defined (_X86_) || defined (_AMD64_)
void CTracingIndent::AddTrace(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, LPCVOID pReturnAddress, const DWORD_PTR dwFramePointer)
#elif defined (_IA64_) 
void CTracingIndent::AddTrace(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, LPCVOID pReturnAddress, const __int64 Args1, const __int64 Args2, const __int64 Args3)
#else
void CTracingIndent::AddTrace(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine)
#endif
{
    Assert(szFunctionName);
    Assert(szFunctionDName);
    Assert(szFile);

    if (!bFirstTrace)
    {
#if defined (_X86_)  || defined (_AMD64_)
        RemoveTrace(szFunctionDName, dwFramePointer);
#elif defined (_IA64_) 
        RemoveTrace(szFunctionDName, 0);
#else 
        RemoveTrace(szFunctionDName, 0);
#endif
    }
    else
    {
        bFirstTrace = FALSE;
    }
    
    volatile CTracingThreadInfo *pThreadInfo = GetThreadInfo();
    TRACING_FUNCTIONSTACK &fnStack = *reinterpret_cast<TRACING_FUNCTIONSTACK *>(pThreadInfo->m_pfnStack);

    Assert(g_csTracing);
    
    __try
    {
        EnterCriticalSection(g_csTracing);

#if defined (_X86_)  || defined (_AMD64_)
        CTracingFuncCall fnCall(szFunctionName, szFunctionDName, szFile, dwLine, reinterpret_cast<DWORD_PTR>(pReturnAddress), dwFramePointer);
#elif defined (_IA64_) 
        CTracingFuncCall fnCall(szFunctionName, szFunctionDName, szFile, dwLine, reinterpret_cast<DWORD_PTR>(pReturnAddress), Args1, Args2, Args3);
#else
        CTracingFuncCall fnCall(szFunctionName, szFunctionDName, szFile, dwLine);
#endif

        if (fnStack.size() == 0)
        {
            pThreadInfo->m_dwLevel++;
        }
        else
        {
            const CTracingFuncCall& fnTopOfStack = fnStack.front();
            if ( (fnCall.m_dwFramePointer != fnTopOfStack.m_dwFramePointer) || 
                 strcmp(fnCall.m_szFunctionDName, fnTopOfStack.m_szFunctionDName))
            {
                pThreadInfo->m_dwLevel++;
            }
        }
    
        m_szFunctionDName = new CHAR[strlen(fnCall.m_szFunctionDName)+1];
        if (m_szFunctionDName)
        {
            strcpy(m_szFunctionDName, fnCall.m_szFunctionDName);
        }
        else
        {
            m_szFunctionDName = c_szLowMemory;
        }

        m_dwFramePointer  = fnCall.m_dwFramePointer;
    
        fnStack.push_front(fnCall);
    }
    __finally
    {
        LeaveCriticalSection(g_csTracing);
    }
}

CTracingIndent::~CTracingIndent()
{
    AssertSz(g_csTracing, "Tracing not initialized");

    RemoveTrace(m_szFunctionDName, m_dwFramePointer);
}

void CTracingIndent::RemoveTrace(LPCSTR szFunctionDName, const DWORD dwFramePointer)
{
    __try
    {
        EnterCriticalSection(g_csTracing);

        volatile CTracingThreadInfo *pThreadInfo = GetThreadInfo();
        TRACING_FUNCTIONSTACK &fnStack = *reinterpret_cast<TRACING_FUNCTIONSTACK *>(pThreadInfo->m_pfnStack);

        Assert(szFunctionDName);
        Assert(m_szFunctionDName);
        Assert(g_csTracing);
    
        if  ( 
                (fnStack.size() == 0) 
                ||
                ( 
                    (   
                        strcmp(m_szFunctionDName, szFunctionDName) 
                        || 
                        strcmp(m_szFunctionDName, fnStack.front().m_szFunctionDName)
                    ) 
                    &&
                    ( 
                        (c_szLowMemory != m_szFunctionDName)  
                        &&
                        (c_szLowMemory != fnStack.front().m_szFunctionDName) 
                        && 
                        (c_szLowMemory != szFunctionDName) 
                    ) 
                ) 
                ||
                (m_dwFramePointer  != fnStack.front().m_dwFramePointer)  
                ||
                (dwFramePointer    != m_dwFramePointer) 
            )
        {
            // Make sure to leave the critical section during the assert, so that it does not cause a deadlock.
            LeaveCriticalSection(g_csTracing);

            // This will trace the stack:
            if (IsDebuggerPresent())
            {
                TraceTagFn(ttidError, "Tracing self-inconsistent - either a stack over/underwrite occurred or an exception was thrown in faulting stack:");
                TraceStackFn(ttidError);
            }
            else
            {
                AssertSz(FALSE,     "Tracing self-inconsistent - either a stack over/underwrite occurred or an exception was thrown.\r\nPlease attach a debugger and hit Ignore on this assert to spew info to the debugger (it will assert again).");
                TraceTagFn(ttidError, "Tracing self-inconsistent - either a stack over/underwrite occurred or an exception was thrown in faulting stack:");
                TraceStackFn(ttidError);
            }
            TraceTagFn(ttidError, "1) For complete stack info, .frame down to CTracingIndent__RemoveTrace, dv and find dwFramePointer (2nd parameter to CTracingIndent__RemoveTrace)");
            TraceTagFn(ttidError, "   Then do a kb=(value of dwFramePointer)");
            TraceTagFn(ttidError, "2) For even more complete stack info, .frame down to CTracingIndent__RemoveTrace, dv and then dt -r on fnStack");
            TraceTagFn(ttidError, "   Then find the _Next, where m_szFunctionName == 'CTracingIndent::RemoveTrace'");
            TraceTagFn(ttidError, "   If it exists, find the value of m_dwFramePointer under _Next");
            TraceTagFn(ttidError, "   Then do a kb=(value of m_dwFramePointer)");

            DebugBreak();

            // Try to recover.
            if (fnStack.size() > 0)
            {
                fnStack.pop_front();
            }

            EnterCriticalSection(g_csTracing);
        }
        else
        {
            DWORD dwOldFramePointer = fnStack.front().m_dwFramePointer;
            fnStack.pop_front();
    
            if ( (fnStack.size() == 0) || 
                (dwOldFramePointer != fnStack.front().m_dwFramePointer) || 
                strcmp(m_szFunctionDName, fnStack.front().m_szFunctionDName) )
            {
                pThreadInfo->m_dwLevel--;
                Assert(pThreadInfo->m_dwLevel);
            }
        }

        if (c_szLowMemory != m_szFunctionDName)
        {
            delete [] m_szFunctionDName;
        }
    }
    __finally
    {
        LeaveCriticalSection(g_csTracing);
    }
}

DWORD CTracingIndent::getspaces()
{
    volatile CTracingThreadInfo *pThreadInfo = GetThreadInfo();
    return pThreadInfo->m_dwLevel;
}

void CTracingIndent::TraceStackFn(TRACETAGID TraceTagId)
{
    if (!g_TraceTags[TraceTagId].fOutputDebugString &&
        !g_TraceTags[TraceTagId].fOutputToFile)
    {
        return;
    }

    volatile CTracingThreadInfo *pThreadInfo = GetThreadInfo();
    TRACING_FUNCTIONSTACK &fnStack = *reinterpret_cast<TRACING_FUNCTIONSTACK *>(pThreadInfo->m_pfnStack);
    Assert(g_csTracing);
    
    __try
    {
        EnterCriticalSection(g_csTracing);

        if (fnStack.size() == 0)
        {
            return;
        }
    
    #if defined (_X86_) || defined (_AMD64_)
        TraceInternal(TraceTagId, NULL, 0, 0, "ChildEBP RetAddr  Args to Child (reconstructed - ChildEBP is invalid now)", 0, FALSE);
    #elif defined (_IA64_) 
        TraceInternal(TraceTagId, NULL, 0, 0, "RetAddr          Args to Child (reconstructed - ChildEBP is invalid now)", 0, FALSE);
    #else
        TraceInternal(TraceTagId, NULL, 0, 0, "Function stack", 0, FALSE);
    #endif
    
        for (TRACING_FUNCTIONSTACK::const_iterator i = fnStack.begin(); i != fnStack.end(); i++)
        {
            CHAR szBuffer[MAX_TRACE_LEN];
    #if defined (_X86_) || defined (_AMD64_)
            _snprintf(szBuffer, MAX_TRACE_LEN, "%08x %08x %08x %08x %08x %s [%s @ %d]", i->m_dwFramePointer, i->m_ReturnAddress, i->m_arguments[0], i->m_arguments[1], i->m_arguments[2], i->m_szFunctionName, i->m_szFile, i->m_dwLine);
    #elif defined (_IA64_) 
            _snprintf(szBuffer, MAX_TRACE_LEN, "%016I64x %016I64x 0x%016I64x 0x%016I64x %s [%s @ %d]", i->m_ReturnAddress, i->m_arguments[0], i->m_arguments[1], i->m_arguments[2], i->m_szFunctionName, i->m_szFile, i->m_dwLine);
    #else
            _snprintf(szBuffer, MAX_TRACE_LEN, "%s", i->m_szFunctionName);
    #endif
            TraceInternal (TraceTagId, NULL, 0, 0, szBuffer, 0, FALSE);
        }
    }
    __finally
    {
        LeaveCriticalSection(g_csTracing);
    }
}

void CTracingIndent::TraceStackFn(IN OUT LPSTR szString, IN OUT LPDWORD pdwSize)
{
    volatile CTracingThreadInfo *pThreadInfo = GetThreadInfo();
    TRACING_FUNCTIONSTACK &fnStack = *reinterpret_cast<TRACING_FUNCTIONSTACK *>(pThreadInfo->m_pfnStack);
    Assert(g_csTracing);
    
    __try
    {
        EnterCriticalSection(g_csTracing);
        ZeroMemory(szString, *pdwSize);

        if (fnStack.size() == 0)
        {
            return;
        }

        Assert(*pdwSize > MAX_TRACE_LEN);
        LPSTR pszString = szString;

    #if defined (_X86_) || defined (_AMD64_)
        pszString += _snprintf(pszString, MAX_TRACE_LEN, " ChildEBP RetAddr  Args to Child (reconstructed - ChildEBP is invalid now)\r\n");
    #elif defined (_IA64_) 
        pszString += _snprintf(pszString, MAX_TRACE_LEN, " RetAddr          Args to Child (reconstructed - ChildEBP is invalid now)\r\n");
    #else
        pszString += _snprintf(pszString, MAX_TRACE_LEN, " Function stack\r\n");
    #endif
    
        DWORD dwSizeIn = *pdwSize;

        for (TRACING_FUNCTIONSTACK::const_iterator i = fnStack.begin(); i != fnStack.end(); i++)
        {
            CHAR szBuffer[1024];
    #if defined (_X86_) || defined (_AMD64_)
            _snprintf(szBuffer, MAX_TRACE_LEN, " %08x %08x %08x %08x %08x %s [%s @ %d]", i->m_dwFramePointer, i->m_ReturnAddress, i->m_arguments[0], i->m_arguments[1], i->m_arguments[2], i->m_szFunctionName, i->m_szFile, i->m_dwLine);
    #elif defined (_IA64_) 
            _snprintf(szBuffer, MAX_TRACE_LEN, " %016I64x %016I64x 0x%016I64x 0x%016I64x %s [%s @ %d]", i->m_ReturnAddress, i->m_arguments[0], i->m_arguments[1], i->m_arguments[2], i->m_szFunctionName, i->m_szFile, i->m_dwLine);
    #else
            _snprintf(szBuffer, MAX_TRACE_LEN, " %s", i->m_szFunctionName);
    #endif
            pszString += _snprintf(pszString, MAX_TRACE_LEN, "%s\r\n", szBuffer);
            if (pszString > (szString + (*pdwSize - celems(szBuffer))) ) // Can't use strlen since I need to know the length of the
                                                                         // next element - not this one. Hence just take the maximum size.
            {
                pszString += _snprintf(pszString, MAX_TRACE_LEN, "...", szBuffer);
                *pdwSize = dwSizeIn * 2; // Tell the caller to allocate more memory and call us back if they want more info.
                break;
            }
        }

        if (*pdwSize < dwSizeIn)
        {
            *pdwSize = pszString - szString;
        }
    }
    __finally
    {
        LeaveCriticalSection(g_csTracing);
    }
}

VOID
WINAPIV
TraceFileFuncFn (TRACETAGID  ttid)
{
    if (FIsDebugFlagSet (dfidTraceFileFunc))
    {
        CHAR szBuffer[MAX_TRACE_LEN];

        volatile CTracingThreadInfo *pThreadInfo = CTracingIndent::GetThreadInfo();
        TRACING_FUNCTIONSTACK &fnStack = *reinterpret_cast<TRACING_FUNCTIONSTACK *>(pThreadInfo->m_pfnStack);   
        
        Assert(g_csTracing);
        __try 
        {
            EnterCriticalSection(g_csTracing);

            const CTracingFuncCall& fnCall = fnStack.front();

            if (fnStack.size() != 0)
            {
                if (FIsDebugFlagSet (dfidTraceSource))
                {
    #if defined (_X86_) || defined (_AMD64_)
                    _snprintf(szBuffer, MAX_TRACE_LEN, "%s [0x%08x 0x%08x 0x%08x] %s:%d", fnCall.m_szFunctionName, fnCall.m_arguments[0], fnCall.m_arguments[1], fnCall.m_arguments[2], fnCall.m_szFile, fnCall.m_dwLine);
    #elif defined (_IA64_) 
                    _snprintf(szBuffer, MAX_TRACE_LEN, "%s [0x%016I64x 0x%016I64x 0x%016I64x] %s:%d", fnCall.m_szFunctionName, fnCall.m_arguments[0], fnCall.m_arguments[1], fnCall.m_arguments[2], fnCall.m_szFile, fnCall.m_dwLine);
    #else
                    _snprintf(szBuffer, MAX_TRACE_LEN, "%s %s:%d", fnCall.m_szFunctionName, fnCall.m_szFile, fnCall.m_dwLine);
    #endif
                }
                else
                {
    #if defined (_X86_) || defined (_AMD64_)
                    _snprintf(szBuffer, MAX_TRACE_LEN, "%s [0x%08x 0x%08x 0x%08x]", fnCall.m_szFunctionName, fnCall.m_arguments[0], fnCall.m_arguments[1], fnCall.m_arguments[2]);
    #elif defined (_IA64_) 
                    _snprintf(szBuffer, MAX_TRACE_LEN, "%s [0x%016I64x 0x%016I64x 0x%016I64x]", fnCall.m_szFunctionName, fnCall.m_arguments[0], fnCall.m_arguments[1], fnCall.m_arguments[2]);
    #else
                    _snprintf(szBuffer, MAX_TRACE_LEN, "%s", fnCall.m_szFunctionName);
    #endif

                }

                TraceTagFn(ttid, szBuffer);
            }
            else
            {
                AssertSz(FALSE, "Trace failure");
            }
        }
        __finally
        {
            LeaveCriticalSection(g_csTracing);
        }
    }
}

LPCSTR DBG_EMNAMES[] =
{
    "INVALID_EVENTMGR",
    "EVENTMGR_CONMAN",
    "EVENTMGR_EAPOLMAN"
};

LPCSTR DBG_CMENAMES[] =
{
    "INVALID_TYPE",
    "CONNECTION_ADDED",
    "CONNECTION_BANDWIDTH_CHANGE",
    "CONNECTION_DELETED",
    "CONNECTION_MODIFIED",
    "CONNECTION_RENAMED",
    "CONNECTION_STATUS_CHANGE",
    "REFRESH_ALL",
    "CONNECTION_ADDRESS_CHANGE"
};

LPCSTR DBG_NCMNAMES[] =
{
    "NCM_NONE",
    "NCM_DIRECT",
    "NCM_ISDN",
    "NCM_LAN",
    "NCM_PHONE",
    "NCM_TUNNEL",
    "NCM_PPPOE",
    "NCM_BRIDGE",
    "NCM_SHAREDACCESSHOST_LAN",
    "NCM_SHAREDACCESSHOST_RAS"
};

LPCSTR DBG_NCSMNAMES[] =
{
    "NCSM_NONE",
    "NCSM_LAN",
    "NCSM_WIRELESS",
    "NCSM_ATM",
    "NCSM_ELAN",
    "NCSM_1394",
    "NCSM_DIRECT",
    "NCSM_IRDA",
    "NCSM_CM",
};

LPCSTR DBG_NCSNAMES[] =
{
    "NCS_DISCONNECTED",
    "NCS_CONNECTING",
    "NCS_CONNECTED",
    "NCS_DISCONNECTING",
    "NCS_HARDWARE_NOT_PRESENT",
    "NCS_HARDWARE_DISABLED",
    "NCS_HARDWARE_MALFUNCTION",
    "NCS_MEDIA_DISCONNECTED",
    "NCS_AUTHENTICATING",
    "NCS_AUTHENTICATION_SUCCEEDED",
    "NCS_AUTHENTICATION_FAILED",
    "NCS_INVALID_ADDRESS",
    "NCS_CREDENTIALS_REQUIRED"
};

// Shorten these to fit more in.
LPCSTR DBG_NCCSFLAGS[] =
{
    "_NONE",
    "_ALL_USERS",
    "_ALLOW_DUPLICATION",
    "_ALLOW_REMOVAL",
    "_ALLOW_RENAME",
    "_SHOW_ICON",
    "_INCOMING_ONLY",
    "_OUTGOING_ONLY",
    "_BRANDED",
    "_SHARED",
    "_BRIDGED",
    "_FIREWALLED",
    "_DEFAULT"
};

LPCSTR DbgEvents(DWORD Event)
{
    if (Event < celems(DBG_CMENAMES))
    {
        return DBG_CMENAMES[Event];
    }
    else
    {
        return "UNKNOWN Event: Update DBG_CMENAMES table.";
    }
}

LPCSTR DbgEventManager(DWORD EventManager)
{
    if (EventManager < celems(DBG_EMNAMES))
    {
        return DBG_EMNAMES[EventManager];
    }
    else
    {
        return "UNKNOWN Event: Update DBG_EMNAMES table.";
    }
}

LPCSTR DbgNcm(DWORD ncm)
{
    if (ncm < celems(DBG_NCMNAMES))
    {
        return DBG_NCMNAMES[ncm];
    }
    else
    {
        return "UNKNOWN NCM: Update DBG_NCMNAMES table.";
    }
}

LPCSTR DbgNcsm(DWORD ncsm)
{
    if (ncsm < celems(DBG_NCSMNAMES))
    {
        return DBG_NCSMNAMES[ncsm];
    }
    else
    {
        return "UNKNOWN NCM: Update DBG_NCSMNAMES table.";
    }
}

LPCSTR DbgNcs(DWORD ncs)
{
    if (ncs < celems(DBG_NCSNAMES))
    {
        return DBG_NCSNAMES[ncs];
    }
    else
    {
        return "UNKNOWN NCS: Update DBG_NCSNAMES table.";
    }
}

LPCSTR DbgNccf(DWORD nccf)
{
    static CHAR szName[MAX_PATH];

    if (nccf >= (1 << celems(DBG_NCCSFLAGS)) )
    {
        return "UNKNOWN NCCF: Update DBG_NCCSFLAGS table.";
    }

    if (0 == nccf)
    {
        strcpy(szName, DBG_NCCSFLAGS[0]);
    }
    else
    {
        szName[0] = '\0';
        LPSTR szTemp = szName;
        BOOL bFirst = TRUE;
        for (DWORD x = 0; x < celems(DBG_NCCSFLAGS); x++)
        {
            if (nccf & (1 << x))
            {
                if (!bFirst)
                {
                    szTemp += _snprintf(szTemp, MAX_TRACE_LEN, "+");
                }
                else
                {
                    szTemp += _snprintf(szTemp, MAX_TRACE_LEN, "NCCF:");
                }
                bFirst = FALSE;
                szTemp += _snprintf(szTemp, MAX_TRACE_LEN, "%s", DBG_NCCSFLAGS[x+1]);
            }
        }
    }

    return szName;
}

#ifdef ENABLELEAKDETECTION

CObjectLeakTrack *g_pObjectLeakTrack = NULL;

// First LPSTR is classname
// Second LPSTR is stack trace
typedef pair<LPSTR, LPSTR> MAPOBJLEAKPAIR;
typedef map<LPCVOID, MAPOBJLEAKPAIR> MAPOBJLEAK;

//+---------------------------------------------------------------------------
//
//  Member:     CObjectLeakTrack::CObjectLeakTrack
//
//  Purpose:    Constructor
//
//  Arguments:
//
//  Returns:
//
//  Author:     deonb  7 July 2001
//
//  Notes:      We are allocating our g_mapObjLeak here
//
CObjectLeakTrack::CObjectLeakTrack()
{
    Assert(FIsDebugFlagSet(dfidTrackObjectLeaks));
    g_mapObjLeak = new MAPOBJLEAK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectLeakTrack::CObjectLeakTrack
//
//  Purpose:    Destructor
//
//  Arguments:
//
//  Returns:    none
//
//  Author:     deonb  7 July 2001
//
//  Notes:      We are deleting our g_mapObjLeak here. We have to typecast it
//              first since the data types exported by trace.h to the world is
//              LPVOID, to minimize dependencies in order to include tracing.
//
CObjectLeakTrack::~CObjectLeakTrack()
{
    Assert(FIsDebugFlagSet(dfidTrackObjectLeaks));
    delete reinterpret_cast<MAPOBJLEAK *>(g_mapObjLeak);
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectLeakTrack::Insert
//
//  Purpose:    Insert an object instance in the list
//
//  Arguments:  [in] pThis                    - This pointer of the object instance. This must
//                                              be the same as the this pointer of the ::Remove
//              [in] szdbgClassName           - The classname of the object
//              [in own] pszConstructionStack - The stacktrace of the object constructor.
//                                              (or any other information that is useful to describe
//                                               the origin of the object).
//                                              This must be allocated with the global new operator
//                                              since we will take ownership and free this
//  Returns:    none
//
//  Author:     deonb  7 July 2001
//
//  Notes:      
//
void CObjectLeakTrack::Insert(IN LPCVOID pThis, IN LPCSTR szdbgClassName, IN TAKEOWNERSHIP LPSTR pszConstructionStack)
{
    Assert(FIsDebugFlagSet(dfidTrackObjectLeaks));
    if (g_mapObjLeak)
    {
        MAPOBJLEAK &rmapObjLeak = *reinterpret_cast<MAPOBJLEAK *>(g_mapObjLeak);

        LPSTR szdbgClassNameCopy = NULL;
        if (szdbgClassName)
        {
            // We have to take a copy of the classname here. This is a bit cointerintuitive, but typeid(T).name() actually calls 
            // into _UnDName to undecorate the name, and this points to an inner static - not directly to a location in 
            // our binary containing the class name.
            szdbgClassNameCopy = new CHAR[strlen(szdbgClassName) + 1];
            if (szdbgClassNameCopy)
            {
                strcpy(szdbgClassNameCopy, szdbgClassName);
            }
        }

        rmapObjLeak[pThis] = MAPOBJLEAKPAIR(szdbgClassNameCopy, pszConstructionStack);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectLeakTrack::Remove
//
//  Purpose:    Remove an object instance from the list
//
//  Arguments:  [in] pThis                    - This pointer of the object instance. This must
//                                              be the same as the this pointer of the ::Insert
//
//  Returns:
//
//  Author:     deonb  7 July 2001
//
//  Notes:      
//
void CObjectLeakTrack::Remove(IN LPCVOID pThis)
{
    Assert(FIsDebugFlagSet(dfidTrackObjectLeaks));
    if (g_mapObjLeak)
    {
        MAPOBJLEAK &rmapObjLeak = *reinterpret_cast<MAPOBJLEAK *>(g_mapObjLeak);

        MAPOBJLEAK::iterator iter = rmapObjLeak.find(pThis);
        if (iter != rmapObjLeak.end())
        {
            delete [] iter->second.first;  // The class name
            iter->second.first = NULL;

            delete [] iter->second.second; // The stack trace
            iter->second.second = NULL;

            rmapObjLeak.erase(iter);
        }
    }
}

void RemoveKnownleakFn(LPCVOID pThis)
{
    if (FIsDebugFlagSet(dfidTrackObjectLeaks) && g_pObjectLeakTrack)
    {
        __try
        {
            EnterCriticalSection(g_csTracing);
            TraceTag(ttidAllocations, "An object at '0x%08x' was marked as a known leak", pThis);
        
            g_pObjectLeakTrack->Remove(pThis);
        }
        __finally
        {
            LeaveCriticalSection(g_csTracing);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectLeakTrack::AssertIfObjectsStillAllocated
//
//  Purpose:    Assert if the the list of allocated objects in the process is not NULL.
//              and call DumpAllocatedObjects to dump out this list.
//
//  Arguments:  [in] szClassName.   The classname of the objects to assert that there are nothing of.
//                                  This classname can be obtained by calling typeid(CLASS).name() 
//                                  on your class. (E.g. typeid(CConnectionManager).name() )
//
//                                  Can also be NULL to ensure that there are NO objects allocated
//  Returns:    none
//
//  Author:     deonb  7 July 2001
//
//  Notes:      Don't call this from outside tracing - rather call AssertNoAllocatedInstances
//              which is safe to call in CHK and FRE.
BOOL CObjectLeakTrack::AssertIfObjectsStillAllocated(IN LPCSTR szClassName)
{
    if (!FIsDebugFlagSet(dfidTrackObjectLeaks))
    {
        return FALSE;
    }

    if (g_mapObjLeak)
    {
        __try
        {
            EnterCriticalSection(g_csTracing);

            MAPOBJLEAK &rmapObjLeak = *reinterpret_cast<MAPOBJLEAK *>(g_mapObjLeak);
            BOOL fFoundObjectOfType = FALSE;

            for (MAPOBJLEAK::const_iterator iter = rmapObjLeak.begin(); iter != rmapObjLeak.end(); iter++)
            {
               if (szClassName)
               {
                   if (0 == strcmp(iter->second.first, szClassName) )
                   {
                       fFoundObjectOfType = TRUE;
                       break;
                   }
               }
               else
               {
                   fFoundObjectOfType = TRUE;
                   break;
               }
            }

            if (fFoundObjectOfType)
            {
                AssertSz(FALSE, "An object leak has been detected. Please attach a user or kernel mode debugger and hit IGNORE to dump the offending stacks");
                DumpAllocatedObjects(ttidError, szClassName);
                return TRUE;
            }
        }
        __finally
        {
            LeaveCriticalSection(g_csTracing);
        }
    }
    return FALSE;
}   


//+---------------------------------------------------------------------------
//
//  Member:     CObjectLeakTrack::DumpAllocatedObjects
//
//  Purpose:    Dump the list of the objects and their construction stacks
//              for the objects that were allocated but not deleted yet. Dumps
//              to the debugger.
//
//  Arguments:  [in] TraceTagId.    The TraceTag to trace it to.
//              [in] szClassName.   The classname of the objects to dump out.
//                                  This classname can be obtained by calling typeid(CLASS).name() 
//                                  on your class. (E.g. typeid(CConnectionManager).name() )
//              
//                                  Can also be NULL to dump out objects of ALL types.
//
//  Returns:    none
//
//  Author:     deonb  7 July 2001
//
//  Notes:      Don't call this from outside - rather call TraceAllocatedObjects 
//              which is safe to call in CHK and FRE.
//
void CObjectLeakTrack::DumpAllocatedObjects(IN TRACETAGID TraceTagId, IN LPCSTR szClassName)
{
    if (!FIsDebugFlagSet(dfidTrackObjectLeaks))
    {
        return;
    }

    if (g_mapObjLeak)
    {
        __try 
        {
            EnterCriticalSection(g_csTracing);

            MAPOBJLEAK &rmapObjLeak = *reinterpret_cast<MAPOBJLEAK *>(g_mapObjLeak);

            for (MAPOBJLEAK::const_iterator iter = rmapObjLeak.begin(); iter != rmapObjLeak.end(); iter++)
            {
               BOOL fMustSpew = TRUE;
               if (szClassName)
               {
                   if (0 != strcmp(iter->second.first, szClassName) )
                   {
                       fMustSpew = FALSE;
                   }
               }

               if (fMustSpew)
               {
                    TraceTag(TraceTagId, "The object of type '%s' allocated at 0x%08x has not been freed:", 
                                iter->second.first, iter->first);

                    if (*iter->second.second)
                    {
                        TraceTag (TraceTagId, "Callstack below:\r\n%s", iter->second.second);
                    }
                    else
                    {
                        TraceTag(TraceTagId, "    <call stack information not available. See comments inside trace.h on how to increase call stack information>.");
                    }
               }
            }
        }
        __finally
        {
            LeaveCriticalSection(g_csTracing);
        }
    }
}   

#endif // ENABLELEAKDETECTION
#endif // ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncdebug\unit\main.cpp ===
#include <pch.h>
#pragma hdrstop

//---[ prototypes ]------------------------------------------------------------

void TestAssert();
void TestSideAssert();
void TestAssertSz();
void TestSideAssertSz();

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Purpose:    Entrypoint for the unit test. Calls all of the sub-tests
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   3 Sep 1997
//
//  Notes:
//
void _cdecl main()
{
    printf("\n\nUnit test for (netcfg)\\common\\debug ");

#ifdef _DBG
    printf("[debug build]\n\n");
#else
    printf("[release build]\n\n");
#endif

    TestAssert();
    TestAssertSz();
    TestSideAssert();
    TestSideAssertSz();
}

void TestAssert()
{
    Assert(TRUE);   // This should succeed
    Assert(FALSE);  // This should fail
}

void TestAssertSz()
{
    AssertSz(TRUE, "This should not have asserted");
    AssertSz(FALSE, "This assert is expected on debug builds");
}

void TestSideAssert()
{
    BOOL fTest  = FALSE;

    printf("Pre-call value of fTest : %d\n", fTest);

    SideAssert(fTest = TRUE);       // This should not fire

    printf("Post-call-#1 value of fTest: %d (should be TRUE)\n", fTest);

    SideAssert(fTest = FALSE);      // This should assert on Debug

    printf("Post-call-#2 value of fTest: %d (should be FALSE, Asserted in DEBUG builds)\n", fTest);
}

void TestSideAssertSz()
{
    BOOL fTest  = FALSE;

    printf("Pre-call value of fTest : %d\n", fTest);

    SideAssertSz(fTest = TRUE, "This assert should not have fired");       // This should not fire

    printf("Post-call-#1 value of fTest: %d (should be TRUE)\n", fTest);

    SideAssertSz(fTest = FALSE, "This assert should have fired in DEBUG mode only");      // This should assert on Debug

    printf("Post-call-#2 value of fTest: %d (should be FALSE, Asserted in DEBUG builds)\n", fTest);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\nclan\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOGDI
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSERVICE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <setupapi.h>

#include <stdio.h>
#include <wchar.h>

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\nclan\lancmn.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L A N C M N . C P P
//
//  Contents:   Implementation of LAN Connection related functions common
//              to the shell and netman.
//
//  Notes:
//
//  Author:     danielwe   7 Oct 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include <winsock2.h>
#include <mswsock.h>
#include <iphlpapi.h>
#include "lancmn.h"
#include "ncnetcfg.h"
#include "ncnetcon.h"
#include "ncreg.h"
#include "ncstring.h"
#include "netconp.h"
#include "ndispnp.h"
#include "naming.h"
extern const DECLSPEC_SELECTANY WCHAR c_szConnName[]                 = L"Name";
extern const DECLSPEC_SELECTANY WCHAR c_szRegKeyConFmt[]             = L"System\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\%s\\Connection";
extern const DECLSPEC_SELECTANY WCHAR c_szRegKeyIrdaFmt[]            = L"System\\CurrentControlSet\\Control\\Network\\{6BDD1FC5-810F-11D0-BEC7-08002BE2092F}\\%s\\Connection";
extern const DECLSPEC_SELECTANY WCHAR c_szRegKeyHwConFmt[]           = L"System\\CurrentControlSet\\Control\\Network\\Connections\\%s";
extern const DECLSPEC_SELECTANY WCHAR c_szRegValuePnpInstanceId[]    = L"PnpInstanceID";
extern const DECLSPEC_SELECTANY WCHAR c_szRegKeyNetworkAdapters[]    = L"System\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002bE10318}";
extern const DECLSPEC_SELECTANY WCHAR c_szRegValueNetCfgInstanceId[] = L"NetCfgInstanceId";
extern const DECLSPEC_SELECTANY WCHAR c_szRegValueMediaSubType[]     = L"MediaSubType";

//
// Helper functions
//

//+---------------------------------------------------------------------------
//
//  Function:   HrOpenConnectionKey
//
//  Purpose:    Opens the "Connection" subkey under the gievn connection
//              GUID.
//
//  Arguments:
//      pguid    [in]       GUID of net card in use by the connection
//      pszGuid  [in]       String version of GUID of net card in use by
//                          the connection
//      sam      [in]       SAM desired
//      occFlags [in]       Flags determining how to open the key
//      pszPnpId [in]       The Pnp id of the net card in use by the
//                          connection. This is used if the key is created.
//      phkey    [out]      Returns hkey of connection subkey
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise.
//
//  Author:     danielwe   7 Oct 1997
//
//  Notes:  Only pguid or pszGuid should be specified, not both.  Specifying
//          both will result in an E_INVALIDARG error
//
//
HRESULT
HrOpenConnectionKey (
    IN const GUID* pguid,
    IN PCWSTR pszGuid,
    IN REGSAM sam,
    IN OCC_FLAGS occFlags,
    IN PCWSTR pszPnpId,
    OUT HKEY *phkey)
{
    HRESULT     hr = S_OK;
    WCHAR       szRegPath[256];
    WCHAR       szGuid[c_cchGuidWithTerm];

    Assert(phkey);
    Assert(pguid || (pszGuid && *pszGuid));
    Assert(!(pguid && pszGuid));
    Assert (FImplies (OCCF_CREATE_IF_NOT_EXIST == occFlags, pszPnpId && *pszPnpId));

    *phkey = NULL;

    if (pguid)
    {
        StringFromGUID2(*pguid, szGuid, c_cchGuidWithTerm);
        pszGuid = szGuid;
    }

    wsprintfW(szRegPath, c_szRegKeyConFmt, pszGuid);

    if (occFlags & OCCF_CREATE_IF_NOT_EXIST)
    {
        DWORD   dwDisp;

        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, szRegPath, 0,
                              sam, NULL, phkey, &dwDisp);

        
        if ((S_OK == hr))
        {
            DWORD dwMediaSubType;
            // Store the pnp instance id as our back pointer to the pnp tree.
            //
            hr = HrRegSetSz (*phkey, c_szRegValuePnpInstanceId, pszPnpId);

            TraceError("HrRegSetSz in HrOpenConnectionKey failed.", hr);
            
            HRESULT hrT = HrRegQueryDword(*phkey, c_szRegValueMediaSubType, &dwMediaSubType);
            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrT)
            {   
                CIntelliName inName(NULL, NULL);
                NETCON_MEDIATYPE ncMediaType = NCM_NONE;
                NETCON_SUBMEDIATYPE ncMediaSubType = NCSM_NONE;
                hrT = inName.HrGetPseudoMediaTypes(*pguid, &ncMediaType, &ncMediaSubType);
                if (SUCCEEDED(hrT))
                {
                    hrT = HrRegSetDword(*phkey, c_szRegValueMediaSubType, ncMediaSubType);
                }
            }
            TraceError("Could not set media subtype for adapter", hrT);
        }
    }
    else if (occFlags & OCCF_DELETE_IF_EXIST)
    {
        if (wcslen(szGuid) > 0)
        {
            wcscpy(szRegPath, c_szRegKeyNetworkAdapters);
            wcscat(szRegPath, L"\\");
            wcscat(szRegPath, szGuid);
            hr = HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, szRegPath);
        }
    }
    else
    {
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath, sam, phkey);
    }

    TraceErrorOptional("HrOpenConnectionKey", hr,
                       HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOpenHwConnectionKey
//
//  Purpose:    Opens the per-hardware profile registry key for this connection
//
//  Arguments:
//      refGuid  [in]       GUID of net card in use by the connection
//      sam      [in]       SAM desired
//      occFlags [in]       Flags determining how to open the key
//      phkey    [out]      Returns hkey of connection subkey
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise.
//
//  Author:     danielwe   9 Oct 1997
//
//  Notes:
//
HRESULT
HrOpenHwConnectionKey(
    REFGUID refGuid,
    REGSAM sam,
    OCC_FLAGS occFlags,
    HKEY *phkey)
{
    HRESULT     hr = S_OK;
    WCHAR       szRegPath[256];
    WCHAR       szGuid[c_cchGuidWithTerm];

    Assert(phkey);

    *phkey = NULL;

    StringFromGUID2(refGuid, szGuid, c_cchGuidWithTerm);
    wsprintfW(szRegPath, c_szRegKeyHwConFmt, szGuid);

    if (occFlags & OCCF_CREATE_IF_NOT_EXIST)
    {
        DWORD   dwDisp;

        hr = HrRegCreateKeyEx(HKEY_CURRENT_CONFIG, szRegPath, 0,
                              sam, NULL, phkey, &dwDisp);
    }
    else
    {
        hr = HrRegOpenKeyEx(HKEY_CURRENT_CONFIG, szRegPath, sam, phkey);
    }

    TraceError("HrOpenHwConnectionKey", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsConnectionNameUnique
//
//  Purpose:    Returns whether or not the given connection name is unique.
//
//  Arguments:
//      guidExclude  [in,ref]   Device GUID of Connection to exclude from
//                              consideration (can be {0})
//      pszName      [in] Name to verify for uniqueness
//
//  Returns:    S_OK if name is unique, S_FALSE if it is a duplicate, or OLE
//              or Win32 error otherwise
//
//  Author:     danielwe   14 Nov 1997
//
//  Notes:
//
HRESULT
HrIsConnectionNameUnique(
    REFGUID guidExclude,
    PCWSTR  pszName)
{
    Assert(pszName);

    BOOL    fDupe = FALSE;

    // Iterate all LAN connections
    //
    INetConnectionManager * pconMan;
    HRESULT hr = HrCreateInstance(CLSID_LanConnectionManager, 
                    CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD, &pconMan);

    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");

    if (SUCCEEDED(hr))
    {
        CIterNetCon         ncIter(pconMan, NCME_DEFAULT);
        INetConnection *    pconn;
        while (SUCCEEDED(hr) && !fDupe &&
               (S_OK == (ncIter.HrNext(&pconn))))
        {
            // Exclude if GUID passed in matches this connection's GUID.
            //
            if (!FPconnEqualGuid(pconn, guidExclude))
            {
                NETCON_PROPERTIES* pProps;
                hr = pconn->GetProperties(&pProps);
                if (SUCCEEDED(hr))
                {
                    AssertSz(pProps->pszwName, "NULL pszwName!");

                    if (!lstrcmpiW(pProps->pszwName, pszName))
                    {
                        // Names match.. This is a dupe.
                        fDupe = TRUE;
                    }

                    FreeNetconProperties(pProps);
                }
            }

            ReleaseObj(pconn);
        }
        ReleaseObj(pconMan);
    }

    if (SUCCEEDED(hr))
    {
        hr = fDupe ? S_FALSE : S_OK;
    }

    TraceErrorOptional("HrIsConnectionNameUnique", hr, (S_FALSE == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLanConnectionNameFromGuidOrPath
//
//  Purpose:    Retrieves the display-name of a LAN connection given its GUID.
//
//  Arguments:
//      guid        [in]       GUID of net card in question
//      pszPath     [in]       Bind path that contains the GUID of the net
//                             card in question
//      pszName    [out]      receives the retrieved name
//      pcchMax     [inout]    indicates the capacity of 'pszName' on input,
//                             contains the required capacity on output.
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise.
//
//  Author:     aboladeg    30 May 1998
//
//  Notes:  Only pguid or pszGuidPath should be specified, not both.
//          Specifying both will result in an E_INVALIDARG error
//
EXTERN_C
HRESULT
WINAPI
HrLanConnectionNameFromGuidOrPath(
    const GUID* pguid,
    PCWSTR pszPath,
    PWSTR pszName,
    LPDWORD pcchMax)
{
    HRESULT hr = S_OK;

    Assert(pcchMax);

    // If neither a guid nor a path was specified then return an error.
    //
    if (!pguid && (!pszPath || !*pszPath))
    {
        hr = E_INVALIDARG;
    }
    // If both pguid and a path were specified then return an error.
    //
    else if (pguid && (pszPath && *pszPath))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        WCHAR szGuid [c_cchGuidWithTerm];
        PCWSTR pszGuid = NULL;

        // If we don't have pguid, it means we are to parset if from
        // pszPath.
        //
        if (!pguid)
        {
            Assert(pszPath && *pszPath);

            // Search for the beginning brace of the supposed GUID and
            // copy the remaining characters into szGuid.
            // If no guid is found, return file not found since
            // there will be no connection name found.
            //
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            for (const WCHAR* pch = pszPath; *pch; pch++)
            {
                if (*pch == L'{')
                {
                    wcsncpy (szGuid, pch, celems(szGuid)-1);
                    szGuid[celems(szGuid)-1] = 0;
                    pszGuid = szGuid;
                    hr = S_OK;
                    break;
                }
            }
        }

        if (S_OK == hr)
        {
            HKEY hkey;

            hr = HrOpenConnectionKey(pguid, pszGuid, KEY_READ,
                    OCCF_NONE, NULL, &hkey);
            if (S_OK == hr)
            {
                DWORD dwType;

                *pcchMax *= sizeof(WCHAR);
                hr = HrRegQueryValueEx(hkey, c_szConnName, &dwType,
                                (LPBYTE)pszName, pcchMax);
                *pcchMax /= sizeof(WCHAR);

                RegCloseKey(hkey);
            }
        }
    }

    TraceError("HrLanConnectionNameFromGuid",
            (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ? S_OK : hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrPnccFromGuid
//
//  Purpose:    Given a GUID of an adapter, returns the INetCfgComponent
//              that corresponds to it.
//
//  Arguments:
//      pnc     [in]        INetCfg to work with
//      refGuid [in]        GUID of adapter to look for
//      ppncc   [out]       Returns INetCfgComponent already AddRef'd
//
//  Returns:    S_OK if found, S_FALSE if not (out param will be NULL), or
//              OLE or Win32 error otherwise
//
//  Author:     danielwe   6 Nov 1997
//
//  Notes:      Caller should ReleaseObj the returned pointer
//
HRESULT HrPnccFromGuid(INetCfg *pnc, const GUID &refGuid,
                       INetCfgComponent **ppncc)
{
    HRESULT     hr = S_OK;

    Assert(pnc);

    if (!ppncc)
    {
        hr = E_POINTER;
    }
    else
    {
        *ppncc = NULL;

        BOOL                    fFound = FALSE;
        CIterNetCfgComponent    nccIter(pnc, &GUID_DEVCLASS_NET);
        INetCfgComponent *      pncc;

        while (!fFound && SUCCEEDED(hr) &&
               S_OK == (hr = nccIter.HrNext(&pncc)))
        {
            GUID    guidTest;

            hr = pncc->GetInstanceGuid(&guidTest);
            if (S_OK == hr)
            {
                if (guidTest == refGuid)
                {
                    // Found our adapter
                    fFound = TRUE;

                    // Give another reference so it's not released down below
                    AddRefObj(pncc);
                    *ppncc = pncc;
                    Assert (S_OK == hr);
                }
            }

            ReleaseObj(pncc);
        }

        if (SUCCEEDED(hr) && !fFound)
        {
            hr = S_FALSE;
        }
    }

    TraceErrorOptional("HrPnccFromGuid", hr, (S_FALSE == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsConnection
//
//  Purpose:    Determines whether the given component has an associated
//              LAN connection.
//
//  Arguments:
//      pncc [in]   Component to test
//
//  Returns:    S_OK if it does, S_FALSE if not, otherwise a Win32 error code
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
HRESULT HrIsConnection(INetCfgComponent *pncc)
{
    HRESULT     hr = S_FALSE;
    GUID        guid;

    Assert(pncc);

    // Get the component instance GUID
    //
    hr = pncc->GetInstanceGuid(&guid);
    if (SUCCEEDED(hr))
    {
        HKEY    hkey;

        // Check for the existence of the connection sub-key
        hr = HrOpenConnectionKey(&guid, NULL, KEY_READ,
                OCCF_NONE, NULL, &hkey);
        if (SUCCEEDED(hr))
        {
            RegCloseKey(hkey);
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            // Key not there, return FALSE
            hr = S_FALSE;
        }
    }

    TraceErrorOptional("HrIsConnection", hr, (S_FALSE == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetDeviceGuid
//
//  Purpose:    Given a LAN connection object, returns the device GUID
//              associated with it.
//
//  Arguments:
//      pconn [in]      LAN connection object
//      pguid [out]     Returns device GUID
//
//  Returns:    S_OK if success, OLE or Win32 error if failed
//
//  Author:     danielwe   23 Dec 1997
//
//  Notes:
//
HRESULT HrGetDeviceGuid(INetConnection *pconn, GUID *pguid)
{
    HRESULT             hr = S_OK;
    INetLanConnection * plan = NULL;

    Assert(pguid);

    hr = HrQIAndSetProxyBlanket(pconn, &plan);

    if (SUCCEEDED(hr))
    {
        hr = plan->GetDeviceGuid(pguid);

        ReleaseObj(plan);
    }

    TraceError("HrGetDeviceGuid", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FPconnEqualGuid
//
//  Purpose:    Determines if the given connection's device GUID matches the
//              guid passed in.
//
//  Arguments:
//      pconn [in]      Connection object to examine (must be a LAN connection)
//      guid  [in,ref]  Guid to compare with
//
//  Returns:    TRUE if connection's device guid matches passed in guid, FALSE
//              if not.
//
//  Author:     danielwe   23 Dec 1997
//
//  Notes:
//
BOOL FPconnEqualGuid(INetConnection *pconn, REFGUID guid)
{
    HRESULT     hr = S_OK;
    GUID        guidDev;
    BOOL        fRet = FALSE;

    hr = HrGetDeviceGuid(pconn, &guidDev);
    if (SUCCEEDED(hr))
    {
        fRet = (guidDev == guid);
    }

    TraceError("FPconnEqualGuid", hr);
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrPnpInstanceIdFromGuid
//
//  Purpose:    Given a GUID of a network device, returns its PnP Instance ID
//
//  Arguments:
//      pguid       [in]    NetCfg instance GUID of device
//      pszInstance [out]   PnP instance ID (string)
//
//  Returns:    S_OK if success, Win32 error code otherwise
//
//  Author:     danielwe   30 Oct 1998
//
//  Notes:
//
HRESULT
HrPnpInstanceIdFromGuid(
    const GUID* pguid,
    PWSTR pszInstance,
    UINT cchInstance)
{
    HRESULT     hr = S_OK;
    WCHAR       szRegPath[MAX_PATH];
    HKEY        hkey;
    DWORD       cb;
    WCHAR       szGuid[c_cchGuidWithTerm];

    StringFromGUID2(*pguid, szGuid, c_cchGuidWithTerm);

    wsprintfW(szRegPath, c_szRegKeyConFmt, szGuid);

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath, KEY_READ, &hkey);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        wsprintfW(szRegPath, c_szRegKeyIrdaFmt, szGuid);
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath, KEY_READ, &hkey);
    }

    if (S_OK == hr)
    {
        cb = cchInstance * sizeof(WCHAR);

        hr = HrRegQuerySzBuffer(hkey, c_szRegValuePnpInstanceId,
                                pszInstance, &cb);
        RegCloseKey(hkey);
    }
#ifdef ENABLETRACE
    if (FAILED(hr))
    {
        TraceHr (ttidError, FAL, hr, IsEqualGUID(*pguid, GUID_NULL), "HrPnpInstanceIdFromGuid "
                 "failed getting id for %S", szGuid);
    }
#endif

    TraceHr (ttidError, FAL, hr,
            HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr,
            "HrPnpInstanceIdFromGuid");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetPnpDeviceStatus
//
//  Purpose:    Given a network device GUID, returns its status
//
//  Arguments:
//      pguid   [in]    NetCfg instance GUID of network device
//      pStatus [out]   Status of device
//
//  Returns:    S_OK if success, Win32 error code otherwise
//
//  Author:     danielwe   30 Oct 1998
//
//  Notes:
//
EXTERN_C
HRESULT
WINAPI
HrGetPnpDeviceStatus(
    const GUID* pguid,
    NETCON_STATUS *pStatus)
{
    HRESULT     hr = S_OK;

    if (!pStatus || !pguid)
    {
        hr = E_POINTER;
        goto err;
    }

    WCHAR   szInstance[MAX_PATH];

    hr = HrPnpInstanceIdFromGuid(pguid, szInstance, celems(szInstance));
    if (SUCCEEDED(hr))
    {
        DEVINST     devinst;
        CONFIGRET   cr;

        cr = CM_Locate_DevNode(&devinst, szInstance,
                               CM_LOCATE_DEVNODE_NORMAL);
        if (CR_SUCCESS == cr)
        {
            hr = HrGetDevInstStatus(devinst, pguid, pStatus);
        }
        else if (CR_NO_SUCH_DEVNODE == cr)
        {
            // If the devnode doesn't exist, the hardware is not physically
            // present
            //
            *pStatus = NCS_HARDWARE_NOT_PRESENT;
        }
    }

err:
    TraceError("HrGetPnpDeviceStatus", hr);
    return hr;
}

extern const WCHAR c_szDevice[];

//+---------------------------------------------------------------------------
//
//  Function:   HrQueryLanMediaState
//
//  Purpose:    Determines as best as can be basically whether the cable is
//              plugged in to the network card.
//
//  Arguments:
//      pguid     [in]  GUID of device to tes
//      pfEnabled [out] Returns TRUE if media is connected, FALSE if not
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   13 Nov 1998
//
//  Notes:
//
EXTERN_C
HRESULT
WINAPI
HrQueryLanMediaState(
    const GUID* pguid,
    BOOL* pfEnabled)
{
    HRESULT         hr = S_OK;

    if (!pfEnabled)
    {
        hr = E_POINTER;
    }
    else
    {
        UINT            uiRet = 0;
        NIC_STATISTICS  nsNewLanStats = {0};
        tstring         strDevice;
        UNICODE_STRING  ustrDevice;
        WCHAR           szGuid[c_cchGuidWithTerm];

        // Initialize to TRUE
        //
        *pfEnabled = TRUE;

        StringFromGUID2(*pguid, szGuid, c_cchGuidWithTerm);

        strDevice = c_szDevice;
        strDevice.append(szGuid);

        RtlInitUnicodeString(&ustrDevice, strDevice.c_str());

        nsNewLanStats.Size = sizeof(NIC_STATISTICS);
        uiRet = NdisQueryStatistics(&ustrDevice, &nsNewLanStats);
        if (uiRet)
        {
            *pfEnabled = (nsNewLanStats.MediaState == MEDIA_STATE_CONNECTED);
        }
        else
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceHr (ttidError, FAL, hr,
            HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr,
            "HrQueryLanMediaState");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsMediaPresent
//
//  Purpose:    Determines as best as can be basically whether the cable is
//              plugged in to the network card.
//
//  Arguments:
//      pGuid [in]    GUID of device to test
//
//  Returns:    TRUE if media is connected, FALSE otherwise
//
//  Author:     danielwe   30 Oct 1998
//
//  Notes:
//
BOOL
FIsMediaPresent(
    const GUID *pguid)
{
    BOOL    fEnabled;

    if (SUCCEEDED(HrQueryLanMediaState(pguid, &fEnabled)))
    {
        return fEnabled;
    }

    // Assume media is connected on failure
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetDevInstStatus
//
//  Purpose:    Determines status of the given Pnp device instance
//
//  Arguments:
//      devinst [in]    PnP device instance
//      pGuid   [in]    GUID of said device
//      pStatus [out]   Status of device
//
//  Returns:    S_OK if success, Win32 error code otherwise
//
//  Author:     danielwe   30 Oct 1998
//
//  Notes:
//
HRESULT
HrGetDevInstStatus(
    DEVINST devinst,
    const GUID* pguid,
    NETCON_STATUS* pStatus)
{
    HRESULT     hr = S_OK;
    ULONG       ulStatus;
    ULONG       ulProblem;
    CONFIGRET   cfgRet;

    if (!pguid)
    {
        return E_INVALIDARG;
    }

    if (!pStatus)
    {
        return E_POINTER;
    }

    cfgRet = CM_Get_DevNode_Status_Ex(&ulStatus, &ulProblem,
                                      devinst, 0, NULL);

    if (CR_SUCCESS == cfgRet)
    {
        TraceTag(ttidLanCon, "CM_Get_DevNode_Status_Ex: ulProblem "
                 "= 0x%08X, ulStatus = 0x%08X.",
                 ulProblem, ulStatus);

        switch (ulProblem)
        {
        case 0:
            // No problem, we're connected
            *pStatus = NCS_CONNECTED;
            break;

        case CM_PROB_DEVICE_NOT_THERE:
        case CM_PROB_MOVED:
            // Device not present
            *pStatus = NCS_HARDWARE_NOT_PRESENT;
             break;

        case CM_PROB_HARDWARE_DISABLED:
            // Device was disabled via Device Manager
            *pStatus = NCS_HARDWARE_DISABLED;
            break;

        case CM_PROB_DISABLED:
            // Device was disconnected
            *pStatus = NCS_DISCONNECTED;
            break;

        default:
            // All other problems
            *pStatus = NCS_HARDWARE_MALFUNCTION;
            break;
        }

        if (*pStatus == NCS_CONNECTED)
        {
            // Check DeviceState and MediaState from NdisQueryStatistics
            UINT            uiRet = 0;
            NIC_STATISTICS  nsNewLanStats = {0};
            tstring         strDevice;
            UNICODE_STRING  ustrDevice;
            WCHAR           szGuid[c_cchGuidWithTerm];

            StringFromGUID2(*pguid, szGuid, c_cchGuidWithTerm);

            strDevice = c_szDevice;
            strDevice.append(szGuid);

            RtlInitUnicodeString(&ustrDevice, strDevice.c_str());

            nsNewLanStats.Size = sizeof(NIC_STATISTICS);
            uiRet = NdisQueryStatistics(&ustrDevice, &nsNewLanStats);

            if (uiRet)
            {
                // Check MediaState
                if (nsNewLanStats.MediaState == MEDIA_STATE_DISCONNECTED)
                {
                    TraceTag(ttidLanCon, "NdisQueryStatistics reports MediaState of "
                                         "device %S is disconnected.", szGuid);

                    *pStatus = NCS_MEDIA_DISCONNECTED;
                }
                else 
                {
                    HRESULT hrTmp;

                    BOOL fValidAddress = TRUE;

                    hrTmp = HrGetAddressStatusForAdapter(pguid, &fValidAddress);
                    if (SUCCEEDED(hrTmp))
                    {
                        if (!fValidAddress)
                        {
                            *pStatus = NCS_INVALID_ADDRESS;

                            INetCfg *pNetCfg  = NULL;
                            BOOL     fInitCom = TRUE;

                            HRESULT hrT = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_MULTITHREADED);
                            if (RPC_E_CHANGED_MODE == hrT)
                            {
                                hrT      = S_OK;
                                fInitCom = FALSE;
                            }

                            if (SUCCEEDED(hrT))
                            {
                                HRESULT hrT = HrCreateAndInitializeINetCfg(NULL, &pNetCfg, FALSE, 0,  NULL,  NULL);
                                if (SUCCEEDED(hrT))
                                {
                                    INetCfgComponent *pNetCfgComponent = NULL;
                                    hrT = HrPnccFromGuid(pNetCfg, *pguid, &pNetCfgComponent);
                                    if (SUCCEEDED(hrT))
                                    {
                                        DWORD dwCharacteristics = 0;
                                        pNetCfgComponent->GetCharacteristics(&dwCharacteristics);

                                        if (NCF_VIRTUAL & dwCharacteristics)
                                        {
                                            *pStatus = NCS_CONNECTED;

                                            TraceTag(ttidLanCon, "NCS_INVALID_ADDRESS status ignored for NCF_VIRTUAL device: %S", szGuid);
                                        }

                                        pNetCfgComponent->Release();
                                    }

                                    HrUninitializeAndReleaseINetCfg(FALSE, pNetCfg, FALSE);
                                }
                                
                                if (fInitCom)
                                {
                                    CoUninitialize();
                                }
                            }
                            TraceError("Error retrieving adapter Characteristics", hrT);
                        }
                    }
                    
                }
            }
            else
            {
                // $REVIEW(tongl 11/25/98): This is added to display proper state
                // for ATM ELAN virtual miniports (Raid #253972, 256355).
                //
                // If we get here for a physical adapter, this means NdisQueryStatistics
                // returned different device state from CM_Get_DevNode_Status_Ex, we may
                // have a problem.

                hr = HrFromLastWin32Error();

                if ((HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) &&
                    (nsNewLanStats.DeviceState == DEVICE_STATE_DISCONNECTED))
                {
                    Assert(nsNewLanStats.MediaState == MEDIA_STATE_UNKNOWN);

                    TraceTag(ttidLanCon, "NdisQueryStatistics reports DeviceState of "
                                         "device %S is disconnected.", szGuid);

                    *pStatus = NCS_DISCONNECTED;
                    hr = S_OK;
                }
                else if (HRESULT_FROM_WIN32(ERROR_NOT_READY) == hr)
                {
                    // This error means that the device went into power
                    // management induced sleep and so we should report this
                    // case as media disconnected, not connection disconnected
                    TraceTag(ttidLanCon, "NdisQueryStatistics reports device"
                             " %S is asleep. Returning status of media "
                             "disconnected.", szGuid);

                    *pStatus = NCS_MEDIA_DISCONNECTED;
                    hr = S_OK;
                }
                else if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr)
                {
                    TraceTag(ttidLanCon, "NdisQueryStatistics reports device %S is still connecting.",
                                          szGuid);

                    *pStatus = NCS_CONNECTING;
                    hr = S_OK;
                }
                else
                {
                    // Treat as disconected, if we return failure the folder will
                    // not display this connection at all.
                    TraceHr (ttidLanCon, FAL, hr, FALSE, "NdisQueryStatistics reports error on device %S",
                             szGuid);

                    *pStatus = NCS_DISCONNECTED;
                    hr = S_OK;
                }
            }
        }
    }

    TraceError("HrGetDevInstStatus", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetRegInstanceKeyForAdapter
//
//  Purpose:    Get the path to the PnP Instance key for a given adapter.
//
//  Arguments:
//              IN LPGUID pguidId           -  Guid for the Adapter
//              OUT LPWSTR lpszRegInstance  -  String containing regpath to the
//                                             the adapter's instance key.
//  Returns:    HRESULT indicating success or failure
//
//  Author:     ckotze   11 Jan 2001
//
//  Notes:      
//              
//  
//              
//
HRESULT HrGetRegInstanceKeyForAdapter(IN LPGUID pguidId, OUT LPWSTR lpszRegInstance)
{
    HRESULT hr = E_FAIL;
    HKEY hkeyNetworkAdapters;
    WCHAR szSubKey[MAX_PATH];
    DWORD cchSubKey = MAX_PATH;
    
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyNetworkAdapters, KEY_READ, &hkeyNetworkAdapters);
    if (SUCCEEDED(hr))
    {
        DWORD dwIndex = 0;

        wcscpy(lpszRegInstance, c_szRegKeyNetworkAdapters);
        wcscat(lpszRegInstance, L"\\");

        while (hr = HrRegEnumKey(hkeyNetworkAdapters, dwIndex++, szSubKey, cchSubKey) == S_OK)
        {
            HKEY hkeySubKey;

            hr = HrRegOpenKeyEx(hkeyNetworkAdapters, szSubKey, KEY_READ, &hkeySubKey);
            if (SUCCEEDED(hr))
            {
                WCHAR szValue[MAX_PATH];
                WCHAR szGuid[MAX_PATH];
                DWORD dwType = REG_SZ;
                DWORD cchData = MAX_PATH;

                StringFromGUID2(*pguidId, szGuid, MAX_PATH);

                HrRegQueryValueEx(hkeySubKey, c_szRegValueNetCfgInstanceId, &dwType, reinterpret_cast<LPBYTE>(szValue), &cchData);

                if (wcscmp(szValue, szGuid) == 0)
                {
                    wcscat(lpszRegInstance, szSubKey);
                    RegCloseKey(hkeySubKey);
                    hr = S_OK;
                    break;
                }
            }
            RegCloseKey(hkeySubKey);
        }
        RegCloseKey(hkeyNetworkAdapters);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HasValidAddress
//
//  Purpose:    Verifies that the given adapter has a valid address
//
//  Arguments:
//              IN PIP_ADAPTER_INFO pAdapterInfo  - Adapter Info structure
//                                                  containing addresses
//
//  Returns:    True if Valid address, False otherwise
//
//  Author:     ckotze   11 Jan 2001
//
//  Notes:      
//              
//  
//              
BOOL HasValidAddress(IN PIP_ADAPTER_INFO pAdapterInfo)
{
    PIP_ADDR_STRING pAddrString;
	unsigned int addr;

    TraceFileFunc(ttidConman);

    for(pAddrString = &pAdapterInfo->IpAddressList; pAddrString != NULL; pAddrString = pAddrString->Next) 
    {
        TraceTag(ttidConman, "IP Address: %s", pAddrString->IpAddress.String);

        addr = inet_addr(pAddrString->IpAddress.String);
        if(!addr)
        {
            return FALSE;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetAddressStatusForAdapter
//
//  Purpose:    Verifies that the given adapter has a valid address
//
//  Arguments:
//              IN LPCGUID pguidAdapter     - Guid for the adapter
//              OUT BOOL* pbValidAddress    - BOOL indicating if it has
//                                            has Valid Address 
//
//  Returns:    True if Valid address, False otherwise
//
//  Author:     ckotze   11 Jan 2001
//
//  Notes:      
//              
//  
//              
HRESULT HrGetAddressStatusForAdapter(IN LPCGUID pguidAdapter, OUT BOOL* pbValidAddress)
{   
    HRESULT hr = E_FAIL;
    GUID guidId = GUID_NULL;
    PIP_ADAPTER_INFO pAdapterInfo = NULL;
    PIP_ADAPTER_INFO pAdapters = NULL;
    ULONG ulSize = 0;
    PIP_ADAPTER_INFO p = NULL;
    WCHAR lpszInstanceId[50];
    WCHAR szAdapterGUID[MAX_PATH];
    WCHAR szAdapterID[MAX_PATH];

    if (!pguidAdapter)
    {
        return E_INVALIDARG;
    }
    if (!pbValidAddress)
    {
        return E_POINTER;
    }

    ZeroMemory(szAdapterGUID, sizeof(WCHAR)*MAX_PATH);
    ZeroMemory(szAdapterID, sizeof(WCHAR)*MAX_PATH);

    StringFromGUID2(*pguidAdapter, szAdapterGUID, MAX_PATH);

    if (ERROR_SUCCESS == GetAdaptersInfo(NULL, &ulSize))
    {
        pAdapters = reinterpret_cast<PIP_ADAPTER_INFO>(new BYTE[ulSize]);
    
        if (pAdapters)
        {
            if(ERROR_SUCCESS == GetAdaptersInfo(pAdapters, &ulSize))
            {
                for (p = pAdapters; p != NULL; p = p->Next)
                {
                    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, p->AdapterName, strlen(p->AdapterName), szAdapterID, MAX_PATH);
                    if (wcscmp(szAdapterGUID, szAdapterID) == 0)
                    {
                        TraceTag(ttidConman, "Found Adapter: %s", p->AdapterName);
                        pAdapterInfo = p;

                        *pbValidAddress = HasValidAddress(pAdapterInfo);

                        hr = S_OK;

                        TraceTag(ttidConman, "Valid Address: %s", (*pbValidAddress) ? "Yes" : "No");
                        TraceTag(ttidConman, "DHCP: %s", (pAdapterInfo->DhcpEnabled) ? "Yes" : "No");
                    }                
                }
            }
            delete[] reinterpret_cast<BYTE*>(pAdapters);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT HrGetPseudoMediaTypeFromConnection(IN REFGUID guidConn, OUT NETCON_SUBMEDIATYPE *pncsm)
{
    HRESULT hr = S_OK;
    HKEY hkeyConnection;

    hr = HrOpenConnectionKey(&guidConn, NULL, KEY_READ, OCCF_NONE, NULL, &hkeyConnection);

    if (SUCCEEDED(hr))
    {
        DWORD dwMediaSubType;

        hr = HrRegQueryDword(hkeyConnection, c_szRegValueMediaSubType, &dwMediaSubType);
        if (SUCCEEDED(hr))
        {
            *pncsm = static_cast<NETCON_SUBMEDIATYPE>(dwMediaSubType);
        }
        else
        {
            *pncsm = NCSM_LAN;
        }
        RegCloseKey(hkeyConnection);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncnetcfg\kkenet.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       K K E N E T . C P P
//
//  Contents:   Ethernet address function
//
//  Notes:
//
//  Author:     kumarp
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "kkutils.h"
#include "ndispnp.h"
#include "ntddndis.h"        // This defines the IOCTL constants.

extern const WCHAR c_szDevice[];

HRESULT HrGetNetCardAddr(IN PCWSTR pszDriver, OUT ULONGLONG* pqwNetCardAddr)
{
    AssertValidReadPtr(pszDriver);
    AssertValidWritePtr(pqwNetCardAddr);

    DefineFunctionName("HrGetNetCardAddr");

    HRESULT hr = S_OK;

    // Form the device name in form "\Device\{GUID}"
    tstring strDeviceName = c_szDevice;
    strDeviceName.append(pszDriver);

    UNICODE_STRING ustrDevice;
    ::RtlInitUnicodeString(&ustrDevice, strDeviceName.c_str());

    UINT uiRet;
    UCHAR MacAddr[6];
    UCHAR PMacAddr[6];
    UCHAR VendorId[3];
    ULONGLONG qw = 0;

    uiRet = NdisQueryHwAddress(&ustrDevice, MacAddr, PMacAddr, VendorId);

    if (uiRet)
    {
        for (int i=0; i<=4; i++)
        {
            qw |= MacAddr[i];
            qw <<= 8;
        }
        qw |= MacAddr[i];
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    *pqwNetCardAddr = qw;

    TraceError(__FUNCNAME__, hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetNetCardAddrOld
//
// Purpose:   Get mac address of a netcard without using NdisQueryHwAddress
//
// Arguments:
//    pszDriver      [in]  name (on NT3.51/4) or guid (on NT5) of driver
//    pqwNetCardAddr [out] pointer to result
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 11-February-99
//
// Notes:
//
#define DEVICE_PREFIX   L"\\\\.\\"

HRESULT HrGetNetCardAddrOld(IN PCWSTR pszDriver, OUT ULONGLONG* pqwNetCardAddr)
{
    DefineFunctionName("HrGetNetCardAddrOld");

    AssertValidReadPtr(pszDriver);

    *pqwNetCardAddr = 0;

    WCHAR       LinkName[512];
    WCHAR       DeviceName[80];
    WCHAR       szMACFileName[80];
    WCHAR       OidData[4096];
    BOOL        fCreatedDevice = FALSE;
    DWORD       ReturnedCount;
    HANDLE      hMAC;
    HRESULT     hr = S_OK;

    NDIS_OID OidCode[] =
    {
        OID_802_3_PERMANENT_ADDRESS,  // Ethernet
        OID_802_5_PERMANENT_ADDRESS,  // TokenRing
        OID_FDDI_LONG_PERMANENT_ADDR, // FDDI
    };

    //
    // Check to see if the DOS name for the MAC driver already exists.
    // Its not created automatically in version 3.1 but may be later.
    //

    TraceTag (ttidDefault, "Attempting to get address of %S", pszDriver);
    if (QueryDosDevice(pszDriver, LinkName, sizeof(LinkName)) == 0)
    {
        if (ERROR_FILE_NOT_FOUND == GetLastError())
        {
            wcscpy(DeviceName, L"\\Device\\");
            wcscat(DeviceName, pszDriver);

            //
            // It doesn't exist so create it.
            //
            if (DefineDosDevice( DDD_RAW_TARGET_PATH, pszDriver, DeviceName))
            {
                fCreatedDevice = TRUE;
            }
            else
            {
                TraceLastWin32Error("DefineDosDevice returned an error creating the device");
                hr = HrFromLastWin32Error();
            }
        }
        else
        {
            TraceLastWin32Error("QueryDosDevice returned an error");
            hr = HrFromLastWin32Error();
        }
    }

    if (S_OK == hr)
    {
        //
        // Construct a device name to pass to CreateFile
        //
        wcscpy(szMACFileName, DEVICE_PREFIX);
        wcscat(szMACFileName, pszDriver);

        hMAC = CreateFile(
                    szMACFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    INVALID_HANDLE_VALUE
                    );

        if (hMAC != INVALID_HANDLE_VALUE)
        {
            DWORD count = 0;
            DWORD ReturnedCount = 0;
            //
            // We successfully opened the driver, format the IOCTL to pass the
            // driver.
            //

            while ((0 == ReturnedCount) && (count < celems (OidCode)))
            {
                if (DeviceIoControl(
                        hMAC,
                        IOCTL_NDIS_QUERY_GLOBAL_STATS,
                        &OidCode[count],
                        sizeof(OidCode[count]),
                        OidData,
                        sizeof(OidData),
                        &ReturnedCount,
                        NULL
                        ))
                {
                    TraceTag (ttidDefault, "OID %lX succeeded", OidCode[count]);
                    if (ReturnedCount == 6)
                    {
                        *pqwNetCardAddr = (ULONGLONG) 0;
                        WORD wAddrLen=6;
                        for (int i=0; i<wAddrLen; i++)
                        {
                            *(((BYTE*) pqwNetCardAddr)+i) = *(((BYTE*) OidData)+(wAddrLen-i-1));
                        }
                        hr = S_OK;
                    }
                    else
                    {
                        TraceLastWin32Error("DeviceIoControl returned an invalid count");
                        hr = HrFromLastWin32Error();
                    }
                }
                else
                {
                    hr = HrFromLastWin32Error();
                }
                count++;
            }
        }
        else
        {
            TraceLastWin32Error("CreateFile returned an error");
            hr = HrFromLastWin32Error();
        }
    }


    if (fCreatedDevice)
    {
        //
        // The MAC driver wasn't visible in the Win32 name space so we created
        // a link.  Now we have to delete it.
        //
        if (!DefineDosDevice(
                DDD_RAW_TARGET_PATH | DDD_REMOVE_DEFINITION |
                    DDD_EXACT_MATCH_ON_REMOVE,
                pszDriver,
                DeviceName)
                )
        {
            TraceLastWin32Error("DefineDosDevice returned an error removing the device");
        }
    }

    TraceFunctionError(hr);
    return hr;
}

#ifdef DBG

void PrintNetCardAddr(IN PCWSTR pszDriver)
{
    ULONGLONG qwNetCardAddr=0;
    HRESULT hr = HrGetNetCardAddr(pszDriver, &qwNetCardAddr);
    wprintf(L"Netcard address for %s: 0x%012.12I64x", pszDriver, qwNetCardAddr);
    TraceError("dafile.main", hr);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncnetcfg\kkcwinf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C W I N F . C P P
//
//  Contents:   Definition of class CWInfFile and other related classes
//
//  Notes:
//
//  Author:     kumarp    12 April 97
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "kkcwinf.h"
#include "kkutils.h"
#include <stdio.h>

#define TC_COMMENT_CHAR L';'
const WCHAR c_szCommentPrefix[] = L"; ";


extern const WCHAR c_szYes[];
extern const WCHAR c_szNo[];

void EraseAndDeleteAll(IN WifLinePtrList* ppl)
{
    WifLinePtrListIter i=ppl->begin();
    while (i != ppl->end())
    {
        delete *i++;
    }

    ppl->erase(ppl->begin(), ppl->end());
}
inline void EraseAll(IN WifLinePtrList* ppl)
{
    ppl->erase(ppl->begin(), ppl->end());
}

inline WifLinePtrListIter GetIterAtBack(IN const WifLinePtrList* ppl)
{
    WifLinePtrListIter pliRet = ppl->end();
    pliRet--;
    return pliRet;
}

inline WifLinePtrListIter AddAtEndOfPtrList(IN WifLinePtrList& pl, IN PCWInfLine pwifLine)
{
    return pl.insert(pl.end(), pwifLine);
}

// ======================================================================
// Class CWInfFile
// ======================================================================

// ----------------------------------------------------------------------
// CWInfFile public functions
// ----------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::CWInfFile
//
//  Purpose:    constructor
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      We keep the read-context and write-context separate. This allows us
//      to simultaneously read and write from the file

CWInfFile::CWInfFile()
{
    m_fp          = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::~CWInfFile
//
//  Purpose:    destructor
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//
CWInfFile::~CWInfFile()
{
    EraseAndDeleteAll(m_plLines);
    EraseAll(m_plSections);

    CWInfKey::UnInit();

    delete m_plLines;
    delete m_plSections;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::Init
//
//  Purpose:    initialization of alloc'd member variables
//
//  Arguments:  none
//
//  Author:     davea    17 Feb 2000
//
//
BOOL CWInfFile::Init()
{
    m_plLines       = new WifLinePtrList(); // lines in this file
    m_plSections    = new WifLinePtrList(); // lines that represent sections
                                      // this allows us to quickly locate a section
	if ((m_plLines != NULL) &&
		(m_plSections != NULL))
	{
		m_ReadContext.posSection = m_plSections->end();
		m_ReadContext.posLine    = m_plLines->end();
		m_WriteContext.posSection = m_plSections->end();
		m_WriteContext.posLine    = m_plLines->end();
	}
	else
	{
		return(FALSE);
	}

    CWInfKey::Init();
	return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::Open
//
//  Purpose:    Opens an INF file
//
//  Arguments:
//      pszFileName  [in]   name of the file to open
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      This does not keep the physical file handle open. We just open the file
//      read the contents and close it. After this, one can freely read from or
//      write to the file. This is done to the memory image of the file. To write
//      this file back, one must call Close() or SaveAs() member functions
BOOL CWInfFile::Open(IN PCWSTR pszFileName)
{
    DefineFunctionName("CWInfFile::Open");

    BOOL status = FALSE;

    m_strFileName = pszFileName;
    FILE *fp = _wfopen(pszFileName, L"r");
    if (fp)
    {
        status = Open(fp);
        fclose(fp);
    }
    else
    {
        TraceTag(ttidError, "%s: could not open file: %S",
                 __FUNCNAME__, pszFileName);
    }

    return status;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::Open
//
//  Purpose:    Opens an INF file
//
//  Arguments:
//      fp  [in]   FILE* of the file to read from
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      This does not physically close the file handle
BOOL CWInfFile::Open(IN FILE *fp)
{
    PWSTR pszLineRoot = (PWSTR) MemAlloc ((MAX_INF_STRING_LENGTH + 1) *
            sizeof (WCHAR));

    if (!pszLineRoot)
    {
        return FALSE;
    }

    PWSTR pszNewLinePos;
    while (!feof(fp))
    {
        PWSTR pszLine = pszLineRoot;

        *pszLine = 0;
        if (fgetws(pszLine, MAX_INF_STRING_LENGTH, fp))
        {
            // Trim leading spaces
            //
            while (iswspace(*pszLine))
            {
                pszLine++;
            }

            if (pszNewLinePos = wcschr(pszLine, L'\n'))
            {
                *pszNewLinePos = 0;
            }
            if (!wcslen(pszLine))
            {
                continue;
            }
            ParseLine(pszLine);
        }
    }

    MemFree (pszLineRoot);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::ParseLine
//
//  Purpose:    Parse the given line and update internal structures
//
//  Arguments:
//      pszLine  [in]   line text to parse
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      Parse the line and add a CWInfKey / CWInfSection / CWInfComment
//      as appropriate in the current write context
//      The logic:
//        add CWInfComment if line begins with ';'
//        add CWInfKey     if line is of the form key=value
//        add CWInfSection if line begins with '[' and has ']' at the end
//        ignore anything else i.e. dont add anything

void CWInfFile::ParseLine(IN PCWSTR pszLine)
{
    tstring strTemp;
    PWSTR  pszTemp, pszTemp2;

    if (!CurrentWriteSection() && (pszLine[0] != L'['))
    {
        return;
    }

    if (pszLine[0] == TC_COMMENT_CHAR)
    {
        //it is a comment
        AddComment(pszLine + 1);
    }
    else if (pszLine[0] == L'[')
    {
        //it is a section
        pszTemp = wcschr(pszLine, L']');
        if (!pszTemp)
        {
            return;
        }
        tstring strSectionName(pszLine+1, pszTemp-pszLine-1);
        AddSection(strSectionName.c_str());
    }
    else if ((pszTemp = wcschr(pszLine, L'=')) != NULL)
    {
        if (pszLine == pszTemp)
        {
            return;
        }

        //it is a key
        pszTemp2 = pszTemp;     // pszTemp2 points at '='
        pszTemp2--;
        while (iswspace(*pszTemp2) && (pszTemp2 != pszLine))
        {
            pszTemp2--;
        }

        pszTemp++;              // skip '='
        while (*pszTemp && iswspace(*pszTemp))
        {
            pszTemp++;
        }

        if ((*pszTemp == L'"') && !wcschr(pszTemp, L','))
        {
            pszTemp++;
            DWORD dwLen = wcslen(pszTemp);
            if (pszTemp[dwLen-1] == L'"')
            {
                pszTemp[dwLen-1] = 0;
            }
        }

        tstring strKeyName(pszLine, pszTemp2-pszLine+1);
        tstring strKeyValue(pszTemp);
        AddKey(strKeyName.c_str(), strKeyValue.c_str());
    }
    else
    {
        // we cannot interpret the line, just add it
        AddRawLine(pszLine);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::Create
//
//  Purpose:    Create a blank INF file in memory
//
//  Arguments:
//      pszFileName  [in]   name of the file to create
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      This does not write anything to disk
BOOL CWInfFile::Create(IN PCWSTR pszFileName)
{
    m_strFileName = pszFileName;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::Create
//
//  Purpose:    Create a blank INF file in memory
//
//  Arguments:
//      fp  [in]   FILE* of the file to create
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      This does not write anything to disk
BOOL CWInfFile::Create(IN FILE *fp)
{
    m_fp = fp;

    return fp != NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::Close
//
//  Purpose:    Close the file, flushing data to disk.
//
//  Arguments:  none
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      This just calls CWInfFile::flush() which will actually write the file back
BOOL CWInfFile::Close()
{
    return Flush();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::Flush
//
//  Purpose:    Close the file, flushing data to disk.
//
//  Arguments:  none
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      This just calls CWInfFile::flush() which will actually write the file back
BOOL CWInfFile::Flush()
{
    WifLinePtrListIter pos;
    CWInfLine *line;
    tstring line_text;
    BOOL fStatus = TRUE;

    //if a filename was specified then open it for writing
    //
    if (!m_strFileName.empty())
    {
        m_fp = _wfopen(m_strFileName.c_str(), L"w");
    }

    if (!m_fp)
        return FALSE;

    // get text of each line and dump it to the file
    for( pos = m_plLines->begin(); pos != m_plLines->end(); )
    {
        line = (CWInfLine *) *pos++;
        line->GetText(line_text);
        if (line->Type() == INF_SECTION)
            fwprintf(m_fp, L"\n");

        fwprintf(m_fp, L"%s", line_text.c_str());
        fwprintf(m_fp, L"\n");
    }

    if (!m_strFileName.empty())
    {
        fStatus = fclose(m_fp) == 0;
        m_fp = NULL;
    }

    return fStatus;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::FlushEx
//
//  Purpose:    Close the file, flushing data to disk.
//
//  Arguments:  none
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     frankli    4 May 2000
//
//  Notes:
//      This is used by SysPrep to enclose value of a key with quotes except 
//      for multi-sz value.
BOOL CWInfFile::FlushEx()
{
    WifLinePtrListIter pos;
    CWInfLine *line;
    tstring line_text;
    BOOL fStatus = TRUE;

    //if a filename was specified then open it for writing
    //
    if (!m_strFileName.empty())
    {
        m_fp = _wfopen(m_strFileName.c_str(), L"w");
    }

    if (!m_fp)
        return FALSE;

    // get text of each line and dump it to the file
    for( pos = m_plLines->begin(); pos != m_plLines->end(); )
    {
        line = (CWInfLine *) *pos++;
        line->GetTextEx(line_text);
        if (line->Type() == INF_SECTION)
            fwprintf(m_fp, L"\n");

        fwprintf(m_fp, L"%s", line_text.c_str());
        fwprintf(m_fp, L"\n");
    }

    if (!m_strFileName.empty())
    {
        fStatus = fclose(m_fp) == 0;
        m_fp = NULL;
    }

    return fStatus;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::SaveAs
//
//  Purpose:    Save current image to the given file
//
//  Arguments:
//      pszFileName  [in]   name of the file to save as
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      This is not same as Close()!, Close() will still write to
//      the original file.
BOOL CWInfFile::SaveAs(IN PCWSTR pszFileName)
{
    BOOL fStatus;

    tstring strTemp = m_strFileName;
    m_strFileName = pszFileName;
    fStatus = Flush();
    m_strFileName = strTemp;

    return fStatus;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::SaveAsEx
//
//  Purpose:    Save current image to the given file
//
//  Arguments:
//      pszFileName  [in]   name of the file to save as
//
//  Returns:    TRUE if suceeded, FALSE otherwise.
//
//  Author:     frankli    4 May 2000
//
//  Notes:
//      This is not same as Close()!, Close() will still write to
//      the original file. Save SysPrep prepared data, 
//      value of a key will be enclosed with quotes except for multi-sz
//      value.
BOOL CWInfFile::SaveAsEx(IN PCWSTR pszFileName)
{
    BOOL fStatus;

    tstring strTemp = m_strFileName;
    m_strFileName = pszFileName;
    fStatus = FlushEx();
    m_strFileName = strTemp;

    return fStatus;
}


// ---------------------------------------------------------------------------
// Functions for reading
// ---------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::SetCurrentReadSection
//
//  Purpose:    Set read-context so that subsequent reads
//              will be from this section
//
//  Arguments:
//      pwisSection  [in]   Section to set context to
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfFile::SetCurrentReadSection(IN PCWInfSection pwisSection)
{
    if ((CurrentReadSection() != pwisSection) && pwisSection)
    {
        m_ReadContext.posSection = pwisSection->m_posSection;
        m_ReadContext.posLine = pwisSection->m_posLine;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::FindSection
//
//  Purpose:    Find the given section in current file
//
//
//  Arguments:
//      pszSectionName  [in]   Section to find
//      wsmMode         [in]   Search mode
//                             (search from beginning-of-file / current-position)
//  Returns:    Pointer to section if found, NULL otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      Sets the current read-context to the section found
//
PCWInfSection CWInfFile::FindSection(IN PCWSTR pszSectionName,
                                     IN WInfSearchMode wsmMode)
{
    PCWInfSection pwisRet=NULL, pwisTemp;
    WifLinePtrListIter pos, old_pos;
    if (wsmMode == ISM_FromBeginning)
    {
        pos = m_plSections->begin();
    }
    else
    {
        pos = m_ReadContext.posSection;
        if (pos == m_plSections->end())
            pos = m_plSections->begin();
    }

    while (pos != m_plSections->end())
    {
        old_pos = pos;
        pwisTemp = (PCWInfSection) *pos++;
        if (!lstrcmpiW(pwisTemp->m_Name.c_str(), pszSectionName))
        {
            pwisRet = pwisTemp;
            SetCurrentReadSection(pwisRet);
            /*
            //            m_ReadContext.posSection = old_pos;
            m_ReadContext.posSection = pwisRet->m_posSection;
            m_ReadContext.posLine    = pwisRet->m_posLine;
            */
            break;
        }
    }

    return pwisRet;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::FindKey
//
//  Purpose:    Find a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      wsmMode         [in]   Search mode
//                             (search from beginning-of-section / current-position)
//  Returns:    Pointer to the key if found, NULL otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
PCWInfKey CWInfFile::FindKey(IN PCWSTR pszKeyName, IN WInfSearchMode wsmMode)
{
    WifLinePtrListIter pos, old_pos;
    PCWInfKey pwikRet=NULL;
    PCWInfLine pwilTemp;

    PCWInfSection pwisCurrentReadSection = CurrentReadSection();
    ReturnNULLIf(!pwisCurrentReadSection);

    if (wsmMode == ISM_FromCurrentPosition)
    {
        pos = m_ReadContext.posLine;
    }
    else
    {
        pos = pwisCurrentReadSection->m_posLine;
    }

    pos++;  // start from next line

    while(pos != m_plLines->end())
    {
        old_pos = pos;
        pwilTemp = (PCWInfLine) *pos++;
        if (pwilTemp->Type() != INF_KEY)
        {
            if (pwilTemp->Type() == INF_SECTION)
            {
                break;
            }
            else
            {
                continue;
            }
        }
        if (!lstrcmpiW(((PCWInfKey) pwilTemp)->m_Name.c_str(), pszKeyName))
        {
            pwikRet = (PCWInfKey) pwilTemp;
            m_ReadContext.posLine = old_pos;
            break;
        }
    }

    ReturnNULLIf(!pwikRet);

    return pwikRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::FirstKey
//
//  Purpose:    Return the first  key in the current section
//
//
//  Arguments:  none
//
//  Returns:    Pointer to the key if found, NULL otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     Sets read-context to this key
//
PCWInfKey CWInfFile::FirstKey()
{
    WifLinePtrListIter pos, old_pos;
    PCWInfKey pwikRet=NULL;
    PCWInfLine pwilTemp;

    PCWInfSection pwisCurrentReadSection = CurrentReadSection();

    if (!pwisCurrentReadSection)
    {
        return NULL;
    }

    pos = pwisCurrentReadSection->m_posLine;

    pos++;  // start from next line

    while(pos != m_plLines->end())
    {
        old_pos = pos;
        pwilTemp = (PCWInfLine) *pos++;
        if (pwilTemp->Type() != INF_KEY)
        {
            if (pwilTemp->Type() == INF_SECTION)
            {
                break;
            }
            else
            {
                continue;
            }
        }
        pwikRet = (PCWInfKey) pwilTemp;
        m_ReadContext.posLine = old_pos;
        break;
    }

    return pwikRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::NextKey
//
//  Purpose:    Return the next key in the current section
//
//
//  Arguments:  none
//
//  Returns:    Pointer to the key if found, NULL otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     Sets read-context to this key
//
PCWInfKey CWInfFile::NextKey()
{
    WifLinePtrListIter pos, old_pos;
    PCWInfKey pwikRet=NULL;
    PCWInfLine pwilTemp;

    PCWInfSection pwisCurrentReadSection = CurrentReadSection();

    if (!pwisCurrentReadSection)
    {
        return NULL;
    }

    pos = m_ReadContext.posLine;

    pos++;  // start from next line

    while(pos != m_plLines->end())
    {
        old_pos = pos;
        pwilTemp = (PCWInfLine) *pos++;
        if (pwilTemp->Type() != INF_KEY)
        {
            if (pwilTemp->Type() == INF_SECTION)
            {
                break;
            }
            else
            {
                continue;
            }
        }
        pwikRet = (PCWInfKey) pwilTemp;
        m_ReadContext.posLine = old_pos;
        break;
    }

    return pwikRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetStringListValue
//
//  Purpose:    Return the value of the given key as a string-list
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pslList         [out]  List value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     If the value is a comma-delimited list, converts it to a TStringList
//     otherwise returns a TStringList with a single element
//
BOOL CWInfFile::GetStringListValue(IN PCWSTR pszKeyName, OUT TStringList &pslList)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
        return FALSE;

    return key->GetStringListValue(pslList);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetStringArrayValue
//
//  Purpose:    Return the value of the given key as a string-Array
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      saStrings       [out]  Array value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12-November-97
//
//  Notes:
//     If the value is a comma-delimited list, converts it to a TStringArray
//     otherwise returns a TStringArray with a single element
//
BOOL CWInfFile::GetStringArrayValue(IN PCWSTR pszKeyName, OUT TStringArray &saStrings)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);

    if (key)
    {
        return key->GetStringArrayValue(saStrings);
    }
    else
    {
        return FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetStringValue
//
//  Purpose:    Return the value of the given key as a string
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      strValue        [out]  string value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfFile::GetStringValue(IN PCWSTR pszKeyName, OUT tstring &strValue)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
        return FALSE;

    return key->GetStringValue(strValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetIntValue
//
//  Purpose:    Return the value of the given key as an int
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pdwValue        [out]  int value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfFile::GetIntValue(IN PCWSTR pszKeyName, OUT DWORD *pdwValue)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
        return FALSE;

    return key->GetIntValue(pdwValue);
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetQwordValue
//
//  Purpose:    Return the value of the given key as a QWORD
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pqwValue        [out]  int value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfFile::GetQwordValue(IN PCWSTR pszKeyName, OUT QWORD *pqwValue)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
        return FALSE;

    return key->GetQwordValue(pqwValue);
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetBoolValue
//
//  Purpose:    Return the value of the given key as a BOOL
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pfValue         [out]  BOOL value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     converts:
//       "True"  / "Yes" / 1 to TRUE
//       "False" / "No"  / 0 to FALSE
//
BOOL CWInfFile::GetBoolValue(IN PCWSTR pszKeyName, OUT BOOL *pfValue)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
        return FALSE;

    return key->GetBoolValue(pfValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetStringValue
//
//  Purpose:    Return the value of the given key as a string
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pszDefault      [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
PCWSTR CWInfFile::GetStringValue(IN PCWSTR pszKeyName, IN PCWSTR pszDefault)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
    {
        return pszDefault;
    }

    return key->GetStringValue(pszDefault);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetIntValue
//
//  Purpose:    Return the value of the given key as an int
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      dwDefault       [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
DWORD CWInfFile::GetIntValue(IN PCWSTR pszKeyName, IN DWORD dwDefault)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
    {
        return dwDefault;
    }

    return key->GetIntValue(dwDefault);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetQwordValue
//
//  Purpose:    Return the value of the given key as a QWORD
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      qwDefault       [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
QWORD CWInfFile::GetQwordValue(IN PCWSTR pszKeyName, IN QWORD qwDefault)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
    {
        return qwDefault;
    }

    return key->GetQwordValue(qwDefault);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GetBoolValue
//
//  Purpose:    Return the value of the given key as a BOOL
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      fDefault        [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfFile::GetBoolValue(IN PCWSTR pszKeyName, IN BOOL fDefault)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
    {
        return fDefault;
    }

    return key->GetBoolValue(fDefault);
}


// ---------------------------------------------------------------------------
// Functions for writing
// ---------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddSection
//
//  Purpose:    Adds the given section to the current file
//
//
//  Arguments:
//      pszSectionName  [in]   Section to add
//
//  Returns:    Pointer to section added, NULL in case of error
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      Sets the current write-context to the section added
//
PCWInfSection CWInfFile::AddSection(IN PCWSTR pszSectionName)
{
    WifLinePtrListIter tpos, section_pos, line_pos;
    CWInfSection *current_section;

    if ((current_section = CurrentWriteSection()) != NULL)
        GotoEndOfSection(current_section);

    CWInfSection *section = new CWInfSection(pszSectionName, this);
    if (m_plSections->empty())
    {
        m_plSections->push_back(section);
        section_pos = GetIterAtBack(m_plSections);

        line_pos = m_plLines->end();
    }
    else
    {
        section_pos = m_WriteContext.posSection;
        section_pos++;
        section_pos = m_plSections->insert(section_pos, section);
    }

    if (line_pos == m_plLines->end())
    {
        line_pos = AddAtEndOfPtrList(*m_plLines, section);
    }
    else
    {
        line_pos = m_WriteContext.posLine;
        line_pos++;
        line_pos = m_plLines->insert(line_pos, section);
        //        line_pos = AddAtEndOfPtrList(*m_plLines, section);
    }

    m_WriteContext.posSection = section_pos;
    m_WriteContext.posLine    = line_pos;

    section->m_posLine    = line_pos;
    section->m_posSection = section_pos;

    return section;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddSectionIfNotPresent
//
//  Purpose:    Adds the given section to the current file if it is not
//              present. if present, returns pointer to the section
//
//
//  Arguments:
//      pszSectionName  [in]   Section to add/find
//
//  Returns:    Pointer to section added/found, NULL in case of error
//
//  Author:     kumarp    kumarp    11-September-97 (06:09:06 pm)
//
//  Notes:
//      Sets the current write-context to the section added
//
PCWInfSection CWInfFile::AddSectionIfNotPresent(IN PCWSTR szSectionName)
{
    CWInfSection* pwis;

    pwis = FindSection(szSectionName);
    if (!pwis)
    {
        pwis = AddSection(szSectionName);
    }

    return pwis;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GotoEndOfSection
//
//  Purpose:    Sets write context to the end of a given section
//              (so that more keys can be added to the end)
//
//
//  Arguments:
//      pwisSection  [in]   the given Section
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      Sets the current write-context to the end of pwisSection
//
void CWInfFile::GotoEndOfSection(PCWInfSection pwisSection)
{
    // line corresponding to the end of current section is the line
    // prior to the next section
    WifLinePtrListIter posEndOfSection, posNextSection;

    posNextSection = pwisSection->m_posSection;
    posNextSection++;

    if (posNextSection == m_plSections->end())
    {
        posEndOfSection = GetIterAtBack(m_plLines);
    }
    else
    {
        PCWInfSection pwisNextSection;

        pwisNextSection = (PCWInfSection) *posNextSection;
        posEndOfSection = pwisNextSection->m_posLine;
        --posEndOfSection;
    }

    m_WriteContext.posSection = pwisSection->m_posSection;
    m_WriteContext.posLine    = posEndOfSection;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::GotoEnd
//
//  Purpose:    Sets write context to the end of the file
//
//
//  Arguments:
//      pwisSection  [in]   the given Section
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfFile::GotoEnd()
{
    m_WriteContext.posSection = GetIterAtBack(m_plSections);
    m_WriteContext.posLine    = GetIterAtBack(m_plLines);
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddKey
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      pszValue        [in]   value to assign
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfFile::AddKey(IN PCWSTR pszKeyName, IN PCWSTR pszValue)
{
    AddKey(pszKeyName)->SetValue(pszValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddKey
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//
//  Returns:    pointer to the key just added, NULL in case of error
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      No value is assigned
//
PCWInfKey CWInfFile::AddKey(IN PCWSTR pszKeyName)
{
    CWInfKey *key;
    key = new CWInfKey(pszKeyName);
    AddLine(key);
    return key;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddKey
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      dwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfFile::AddKey(IN PCWSTR pszKeyName, IN DWORD dwValue)
{
    AddKey(pszKeyName)->SetValue(dwValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddQwordKey
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      qwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfFile::AddQwordKey(IN PCWSTR pszKeyName, IN QWORD qwValue)
{
    AddKey(pszKeyName)->SetValue(qwValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddHexKey
//
//  Purpose:    Adds a key in the current section, stores value in hex.
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      dwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfFile::AddHexKey(IN PCWSTR pszKeyName, IN DWORD dwValue)
{
    AddKey(pszKeyName)->SetHexValue(dwValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddBoolKey
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      fValue          [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     TRUE  is stored as "Yes"
//     FALSE is stored as "No"
//
void CWInfFile::AddBoolKey(IN PCWSTR pszKeyName, IN BOOL Value)
{
    AddKey(pszKeyName)->SetBoolValue(Value);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddKeyV
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      pszFormat       [in]   format string (printf style)
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfFile::AddKeyV(IN PCWSTR pszKeyName, IN PCWSTR Format, IN ...)
{
    va_list arglist;

    va_start (arglist, Format);
    AddKey(pszKeyName)->SetValues(Format, arglist);
    va_end(arglist);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddKey
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      pszFormat       [in]   format string (printf style)
//      arglist         [in]   argument list
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfFile::AddKey(IN PCWSTR pszKeyName, IN PCWSTR Format, IN va_list arglist)
{
    AddKey(pszKeyName)->SetValues(Format, arglist);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddKey
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      slValues        [in]   values in the form of a string list
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     The string-list is converted to a comma-delimited list before
//     the value is assigned to the key
//
void CWInfFile::AddKey(IN PCWSTR pszKeyName, IN const TStringList &slValues)
{
    AddKey(pszKeyName)->SetValue(slValues);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddComment
//
//  Purpose:    Adds a comment in the current section
//
//
//  Arguments:
//      pszComment      [in]   text of the comment
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     A "; " is prefixed to pszComment before it is inserted into the section.
//
void CWInfFile::AddComment(IN PCWSTR pszComment)
{
    CWInfComment *Comment;
    Comment = new CWInfComment(pszComment);
    AddLine(Comment);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddRawLine
//
//  Purpose:    Adds a raw line in the current section
//
//
//  Arguments:
//      szText      [in]   text to add
//
//  Returns:    none
//
//  Author:     danielwe    11 Jun 1997
//
void CWInfFile::AddRawLine(IN PCWSTR szText)
{
    CWInfRaw *pwir;
    pwir = new CWInfRaw(szText);
    AddLine(pwir);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddRawLines
//
//  Purpose:    Adds a raw line in the current section
//
//
//  Arguments:
//      szText      [in]   text to add
//
//  Returns:    none
//
//  Author:     danielwe    11 Jun 1997
//
void CWInfFile::AddRawLines(IN PCWSTR* pszLines, IN DWORD cLines)
{
    AssertValidReadPtr(pszLines);
    AssertSz(cLines, "CWInfFile::AddRawLines: dont add 0 lines");

    CWInfRaw *pwir;
    for (DWORD i=0; i<cLines; i++)
    {
        AssertSz(pszLines[i], "CWInfRaw::AddRawLines: One of the lines is bad");

        pwir = new CWInfRaw(pszLines[i]);
        AddLine(pwir);
    }
}

// ----------------------------------------------------------------------
// CWInfFile protected functions
// ----------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::CurrentWriteSection
//
//  Purpose:    Get a pointer to the section selected for writing
//
//
//  Arguments:  none
//
//  Returns:    pointer to the section if exists, NULL if file has no sections
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
PCWInfSection CWInfFile::CurrentWriteSection() const
{
    WifLinePtrListIter pos = m_WriteContext.posSection;

    if (pos == m_plSections->end())
    {
        return NULL;
    }
    else
    {
        return (PCWInfSection) *pos;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::CurrentReadSection
//
//  Purpose:    Get a pointer to the section selected for reading
//
//
//  Arguments:  none
//
//  Returns:    pointer to the section if exists, NULL if file has no sections
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
PCWInfSection CWInfFile::CurrentReadSection() const
{
    PCWInfSection pwisCurrent;

    WifLinePtrListIter pos = m_ReadContext.posSection;

    if (pos == m_plSections->end())
    {
        return NULL;
    }
    else
    {
        pwisCurrent = (PCWInfSection) *pos;
        return pwisCurrent;
    }
}


//+---------------------------------------------------------------------------
//
// Function:  CWInfFile::RemoveSection
//
// Purpose:   Remove a section and its contents
//
// Arguments:
//    szSectionName [in]  name of Section to remove
//
// Returns:   None
//
// Author:    kumarp 09-December-98
//
// Notes:
//
void CWInfFile::RemoveSection(IN PCWSTR szSectionName)
{
    CWInfSection* pwis;

    if (pwis = FindSection(szSectionName))
    {
        m_plSections->erase(pwis->m_posSection);
        WifLinePtrListIter pos = pwis->m_posLine;
        WifLinePtrListIter posTemp;

        do
        {
            posTemp = pos;
            pos++;
            m_plLines->erase(posTemp);
        }
        while (pos != m_plLines->end() &&
               ((CWInfLine*) *pos)->Type() != INF_SECTION);
    }
}

//+---------------------------------------------------------------------------
//
// Function:  CWInfFile::RemoveSections
//
// Purpose:   Remove the specified sections
//
// Arguments:
//    slSections [in]  list of sections to remove
//
// Returns:   None
//
// Author:    kumarp 09-December-98
//
// Notes:
//
void CWInfFile::RemoveSections(IN TStringList& slSections)
{
    PCWSTR szSectionName;
    TStringListIter pos;

    pos = slSections.begin();
    while (pos != slSections.end())
    {
        szSectionName = (*pos)->c_str();
        pos++;
        RemoveSection(szSectionName);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfFile::AddLine
//
//  Purpose:    Add a CWInfLine in the current section, adjust write context.
//
//  Arguments:
//      ilLine      [in]   pointer to a CWInfLine
//
//  Returns:    TRUE on success, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfFile::AddLine(IN const PCWInfLine ilLine)
{
    CWInfSection *section = CurrentWriteSection();
    if (!section)
        return FALSE;

    WifLinePtrListIter pos;
    pos = m_WriteContext.posLine;
    pos++;
    pos = m_plLines->insert(pos, ilLine);
    m_WriteContext.posLine = pos;

    return TRUE;
}

// ======================================================================
// Class CWInfSection
// ======================================================================

// ----------------------------------------------------------------------
// CWInfSection public functions
// ----------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetText
//
//  Purpose:    Get text representation of this section.
//
//  Arguments:
//      text      [in]   string that receives the text
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfSection::GetText(OUT tstring &text) const
{
    text = L"[" + m_Name + L"]";
}

// used by SysPrep
void CWInfSection::GetTextEx(OUT tstring &text) const
{
    text = L"[" + m_Name + L"]";
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::FindKey
//
//  Purpose:    Find a key in this section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      wsmMode         [in]   Search mode
//                             (search from beginning-of-section / current-position)
//  Returns:    Pointer to the key if found, NULL otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
PCWInfKey CWInfSection::FindKey(IN PCWSTR pszKeyName,
                                IN WInfSearchMode wsmMode)
{
    m_Parent->SetCurrentReadSection(this);
    return m_Parent->FindKey(pszKeyName, wsmMode);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::FirstKey
//
//  Purpose:    Return the first  key in this section
//
//
//  Arguments:  none
//
//  Returns:    Pointer to the key if found, NULL otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     Sets read-context to this key
//
PCWInfKey CWInfSection::FirstKey()
{
    m_Parent->SetCurrentReadSection(this);
    return m_Parent->FirstKey();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::NextKey
//
//  Purpose:    Return the next key in this section
//
//
//  Arguments:  none
//
//  Returns:    Pointer to the key if found, NULL otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     Sets read-context to this key
//
PCWInfKey CWInfSection::NextKey()
{
    m_Parent->SetCurrentReadSection(this);
    return m_Parent->NextKey();
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetStringArrayValue
//
//  Purpose:    Return the value of the given key as a string-Array
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      saStrings       [out]  Array value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12-November-97
//
//  Notes:
//     If the value is a comma-delimited list, converts it to a TStringArray
//     otherwise returns a TStringArray with a single element
//
BOOL CWInfSection::GetStringArrayValue(IN PCWSTR pszKeyName, OUT TStringArray &saStrings)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);

    if (key)
    {
        return key->GetStringArrayValue(saStrings);
    }
    else
    {
        return FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetStringListValue
//
//  Purpose:    Return the value of the given key as a string-list
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pslList         [out]  List value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     If the value is a comma-delimited list, converts it to a TStringList
//     otherwise returns a TStringList with a single element
//
BOOL CWInfSection::GetStringListValue(IN PCWSTR pszKeyName, OUT TStringList &pslList)
{
    CWInfKey* key;
    key = FindKey(pszKeyName, ISM_FromBeginning);
    if (!key)
        return FALSE;

    return key->GetStringListValue(pslList);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetStringValue
//
//  Purpose:    Return the value of the given key as a string
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      strValue        [out]  string value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfSection::GetStringValue(IN PCWSTR pszKeyName, OUT tstring &strValue)
{
    CWInfKey* key;
    key = FindKey(pszKeyName, ISM_FromBeginning);
    if (!key)
        return FALSE;

    return key->GetStringValue(strValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetIntValue
//
//  Purpose:    Return the value of the given key as an integer
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pdwValue        [out]  int value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfSection::GetIntValue(IN PCWSTR pszKeyName, OUT DWORD *pdwValue)
{
    CWInfKey* key;
    key = FindKey(pszKeyName, ISM_FromBeginning);
    if (!key)
        return FALSE;

    return key->GetIntValue(pdwValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetQwordValue
//
//  Purpose:    Return the value of the given key as a QWORD
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pqwValue        [out]  int value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfSection::GetQwordValue(IN PCWSTR pszKeyName, OUT QWORD *pqwValue)
{
    CWInfKey* key;
    key = FindKey(pszKeyName, ISM_FromBeginning);
    if (!key)
        return FALSE;

    return key->GetQwordValue(pqwValue);
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetBoolValue
//
//  Purpose:    Return the value of the given key as a BOOL
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pfValue         [out]  BOOL value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     converts:
//       "True"  / "Yes" / 1 to TRUE
//       "False" / "No"  / 0 to FALSE
//
BOOL CWInfSection::GetBoolValue(IN PCWSTR pszKeyName, OUT BOOL *pfValue)
{
    CWInfKey* key;
    key = FindKey(pszKeyName, ISM_FromBeginning);
    if (!key)
        return FALSE;

    return key->GetBoolValue(pfValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetStringValue
//
//  Purpose:    Return the value of the given key as a string
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      pszDefault      [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
PCWSTR CWInfSection::GetStringValue(IN PCWSTR pszKeyName, IN PCWSTR pszDefault)
{
    CWInfKey* key;
    key = FindKey(pszKeyName, ISM_FromBeginning);
    if (!key)
    {
        return pszDefault;
    }

    return key->GetStringValue(pszDefault);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetIntValue
//
//  Purpose:    Return the value of the given key as an int
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      dwDefault       [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
DWORD CWInfSection::GetIntValue(IN PCWSTR pszKeyName, IN DWORD dwDefault)
{
    CWInfKey* key;
    key = FindKey(pszKeyName, ISM_FromBeginning);
    if (!key)
    {
        return dwDefault;
    }

    return key->GetIntValue(dwDefault);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetQwordValue
//
//  Purpose:    Return the value of the given key as a QWORD
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      qwDefault       [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
QWORD CWInfSection::GetQwordValue(IN PCWSTR pszKeyName, IN QWORD qwDefault)
{
    CWInfKey* key;
    key = FindKey(pszKeyName);
    if (!key)
    {
        return qwDefault;
    }

    return key->GetQwordValue(qwDefault);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GetBoolValue
//
//  Purpose:    Return the value of the given key as a BOOL
//
//
//  Arguments:
//      pszKeyName      [in]   Key to find
//      fDefault        [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfSection::GetBoolValue(IN PCWSTR pszKeyName, IN BOOL fDefault)
{
    CWInfKey* key;
    key = FindKey(pszKeyName, ISM_FromBeginning);
    if (!key)
    {
        return fDefault;
    }

    return key->GetBoolValue(fDefault);
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::GotoEnd
//
//  Purpose:    Sets write context to the end of this section
//              (so that more keys can be added to the end)
//
//  Arguments:  none
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      Sets this write-context to the end of pwisSection
//
void CWInfSection::GotoEnd()
{
    m_Parent->GotoEndOfSection(this);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddKey
//
//  Purpose:    Adds a key in this section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//
//  Returns:    pointer to the key just added, NULL in case of error
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//      No value is assigned
//
PCWInfKey CWInfSection::AddKey(IN PCWSTR pszKeyName)
{
    GotoEnd();
    return m_Parent->AddKey(pszKeyName);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddKey
//
//  Purpose:    Adds a key in this section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      pszValue        [in]   value to assign
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfSection::AddKey(IN PCWSTR pszKeyName, IN PCWSTR pszValue)
{
    GotoEnd();
    m_Parent->AddKey(pszKeyName, pszValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddKey
//
//  Purpose:    Adds a key in this section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      dwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfSection::AddKey(IN PCWSTR pszKeyName, IN DWORD Value)
{
    GotoEnd();
    m_Parent->AddKey(pszKeyName, Value);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddQwordKey
//
//  Purpose:    Adds a key in the current section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      qwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfSection::AddQwordKey(IN PCWSTR pszKeyName, IN QWORD qwValue)
{
    AddKey(pszKeyName)->SetQwordValue(qwValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddHexKey
//
//  Purpose:    Adds a key in this section, stores value in hex.
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      dwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfSection::AddHexKey(IN PCWSTR pszKeyName, IN DWORD Value)
{
    GotoEnd();
    m_Parent->AddHexKey(pszKeyName, Value);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddKey
//
//  Purpose:    Adds a key in this section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      slValues        [in]   values in the form of a string list
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     The string-list is converted to a comma-delimited list before
//     the value is assigned to the key
//
void CWInfSection::AddKey(IN PCWSTR pszKeyName, IN const TStringList &slValues)
{
    GotoEnd();
    m_Parent->AddKey(pszKeyName, slValues);
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddBoolKey
//
//  Purpose:    Adds a key in this section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      fValue          [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     TRUE  is stored as "Yes"
//     FALSE is stored as "No"
//
void CWInfSection::AddBoolKey(IN PCWSTR pszKeyName, IN BOOL Value)
{
    GotoEnd();
    m_Parent->AddBoolKey(pszKeyName, Value);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddKeyV
//
//  Purpose:    Adds a key in this section
//
//
//  Arguments:
//      pszKeyName      [in]   Key to add
//      pszFormat       [in]   format string (printf style)
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfSection::AddKeyV(IN PCWSTR pszKeyName, IN PCWSTR Format, IN ...)
{
    GotoEnd();
    va_list arglist;

    va_start (arglist, Format);
    m_Parent->AddKey(pszKeyName, Format, arglist);
    va_end(arglist);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddComment
//
//  Purpose:    Adds a comment in this section
//
//
//  Arguments:
//      pszComment      [in]   text of the comment
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     A "; " is prefixed to pszComment before it is inserted into the section.
//
void CWInfSection::AddComment(IN PCWSTR pszComment)
{
    GotoEnd();
    m_Parent->AddComment(pszComment);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::AddComment
//
//  Purpose:    Adds a comment in this section
//
//
//  Arguments:
//      szLine  [in]   raw line to be inserted
//
//  Returns:    none
//
//  Author:     danielwe    11 Jun 1997
//
void CWInfSection::AddRawLine(IN PCWSTR szLine)
{
    GotoEnd();
    m_Parent->AddRawLine(szLine);
}

// ----------------------------------------------------------------------
// CWInfSection protected functions
// ----------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::CWInfSection
//
//  Purpose:    constructor
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
CWInfSection::CWInfSection(IN PCWSTR SectionName, IN PCWInfFile parent)
    : CWInfLine(INF_SECTION)
{
    m_Name = SectionName;
    m_posLine = 0;
    m_Parent = parent;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfSection::~CWInfSection
//
//  Purpose:    destructor
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//
CWInfSection::~CWInfSection()
{
}


// ======================================================================
// Class CWInfKey
// ======================================================================

// ----------------------------------------------------------------------
// CWInfKey public functions
// ----------------------------------------------------------------------

WCHAR *CWInfKey::m_Buffer;

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::CWInfFile
//
//  Purpose:    constructor
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
CWInfKey::CWInfKey(IN PCWSTR pszKeyName)
    : CWInfLine(INF_KEY)
{
    m_Value = c_szEmpty;
    m_Name = pszKeyName;
    m_fIsAListAndAlreadyProcessed = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::~CWInfFile
//
//  Purpose:    destructor
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//
CWInfKey::~CWInfKey()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::Init
//
//  Purpose:    allocate internal shared buffer
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//
void CWInfKey::Init()
{
    if (NULL == m_Buffer)
    {
        m_Buffer = new WCHAR[MAX_INF_STRING_LENGTH];
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::UnInit
//
//  Purpose:    deallocate internal shared buffer
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//
void CWInfKey::UnInit()
{
    if (NULL != m_Buffer)
    {
        delete [] m_Buffer;
        m_Buffer = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetText
//
//  Purpose:    Get text representation in the format key=value.
//
//  Arguments:
//      text      [in]   string that receives the text
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfKey::GetText(tstring &text) const
{
    // Text mode setup does not like certain special characters in the
    // value of a key. if the value has one of these characters then
    // we need to enclose the entire value in quotes
    //
    static const WCHAR szSpecialChars[] = L" %=][";
    tstring strTemp = m_Value; 
    tstring strTempName = m_Name;

    if (!m_fIsAListAndAlreadyProcessed)
    {
        if (m_Value.empty() ||
            (L'\"' != *(m_Value.c_str()) &&
             wcscspn(m_Value.c_str(), szSpecialChars) < m_Value.size()))
        {
            strTemp = L"\"" + m_Value + L"\"";
        }
    }

    if (m_Name.empty() ||
        (L'\"' != *(m_Name.c_str()) &&
         wcscspn(m_Name.c_str(), szSpecialChars) < m_Name.size()))
    {
        strTempName = L"\"" + m_Name + L"\"";
    }

    text = strTempName + L"=" + strTemp;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetTextEx
//
//  Purpose:    Get text representation in the format key=value for multi-sz value
//              Otherwiese, get text representation in the format key="value"
//
//  Arguments:
//      text      [in]   string that receives the text
//
//  Returns:    none
//
//  Author:     frankli    4 May 2000
//
//  Notes: value will be enclosed in quotes except for multi-sz value 
//
void CWInfKey::GetTextEx(tstring &text) const
{
    // we need to enclose the entire value in quotes except for multi-sz value.
    // For example,
    // tcpip adapter specific
    // NameServer registry value is of type REG_SZ and it is a string of
    // comma-delimited dns server name. We need to enclosed it in quotes,
    // otherwise, it will be interpreted as multi-sz value
    
    // Text mode setup does not like certain special characters in the
    // value of a key. if the value has one of these characters then
    // we need to enclose the entire value in quotes
    //
    static const WCHAR szSpecialChars[] = L" %=][";
    tstring strTemp = m_Value;
    tstring strTempName = m_Name;

    if (!m_fIsAListAndAlreadyProcessed)
    {   // we don't do this for multi-sz value
        strTemp = L"\"" + m_Value + L"\"";
    }

    // leave the processing of the key as in CWInfKey::GetText
    if (m_Name.empty() ||
        (L'\"' != *(m_Name.c_str()) &&
         wcscspn(m_Name.c_str(), szSpecialChars) < m_Name.size()))
    {
        strTempName = L"\"" + m_Name + L"\"";
    }

    text = strTempName + L"=" + strTemp;
}


// --------- Read values --------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetStringArrayValue
//
//  Purpose:    Return the value of the given key as a string-Array
//
//
//  Arguments:
//      saStrings         [out]  Array value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     If the value is a comma-delimited list, converts it to a TStringArray
//     otherwise returns a TStringArray with a single element
//
BOOL CWInfKey::GetStringArrayValue(TStringArray &saStrings) const
{
    ConvertCommaDelimitedListToStringArray(m_Value, saStrings);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetStringListValue
//
//  Purpose:    Return the value of the given key as a string-list
//
//
//  Arguments:
//      pslList         [out]  List value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     If the value is a comma-delimited list, converts it to a TStringList
//     otherwise returns a TStringList with a single element
//
BOOL CWInfKey::GetStringListValue(TStringList &pslList) const
{
    ConvertCommaDelimitedListToStringList(m_Value, pslList);

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetStringValue
//
//  Purpose:    Return the value of the given key as a string
//
//
//  Arguments:
//      strValue        [out]  string value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfKey::GetStringValue(OUT tstring& strValue) const
{
    strValue = m_Value;
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetIntValue
//
//  Purpose:    Return the value of the given key as an in
//
//
//  Arguments:
//      pdwValue        [out]  int value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfKey::GetIntValue(OUT DWORD *pdwValue) const
{
    if ((swscanf(m_Value.c_str(), L"0x%x", pdwValue) == 1) ||
        (swscanf(m_Value.c_str(), L"%d", pdwValue) == 1))
    {
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetQwordValue
//
//  Purpose:    Return the value of the given key as a QWORD
//
//
//  Arguments:
//      pqwValue        [out]  int value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfKey::GetQwordValue(OUT QWORD *pqwValue) const
{
    if ((swscanf(m_Value.c_str(), L"0x%I64x", pqwValue) == 1) ||
        (swscanf(m_Value.c_str(), L"%I64d", pqwValue) == 1))
    {
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetBoolValue
//
//  Purpose:    Return the value of the given key as a BOOL
//
//
//  Arguments:
//      pfValue         [out]  BOOL value to return
//
//  Returns:    TRUE if key found and value in correct format, FALSE otherwise
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     converts:
//       "True"  / "Yes" / 1 to TRUE
//       "False" / "No"  / 0 to FALSE
//
BOOL CWInfKey::GetBoolValue(OUT BOOL *pfValue) const
{
    return IsBoolString(m_Value.c_str(), pfValue);
}


//+---------------------------------------------------------------------------
//these functions return the default value if value not found
//or if it is in a wrong format
//+---------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetStringValue
//
//  Purpose:    Return the value of the given key as a string
//
//
//  Arguments:
//      pszDefault      [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
PCWSTR CWInfKey::GetStringValue(IN PCWSTR pszDefault) const
{
    if (m_Value.empty())
    {
        return pszDefault;
    }
    else
    {
        return m_Value.c_str();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetIntValue
//
//  Purpose:    Return the value of the given key as an int
//
//
//  Arguments:
//      dwDefault       [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
DWORD CWInfKey::GetIntValue(IN DWORD dwDefault) const
{
    DWORD dwValue;
    if ((swscanf(m_Value.c_str(), L"0x%lx", &dwValue) == 1) ||
        (swscanf(m_Value.c_str(), L"%ld", &dwValue) == 1))
    {
        return dwValue;
    }
    else
    {
        return dwDefault;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetQwordValue
//
//  Purpose:    Return the value of the given key as an int
//
//
//  Arguments:
//      qwDefault       [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
QWORD CWInfKey::GetQwordValue(IN QWORD qwDefault) const
{
    QWORD qwValue;
    if ((swscanf(m_Value.c_str(), L"0x%I64x", &qwValue) == 1) ||
        (swscanf(m_Value.c_str(), L"%I64x", &qwValue) == 1) ||
        (swscanf(m_Value.c_str(), L"%I64d", &qwValue) == 1))
    {
        return qwValue;
    }
    else
    {
        return qwDefault;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::GetBoolValue
//
//  Purpose:    Return the value of the given key as a BOOL
//
//
//  Arguments:
//      fDefault        [in]   default value
//
//  Returns:    value if key found and value in correct format,
//              otherwise returns the default-value
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
BOOL CWInfKey::GetBoolValue(IN BOOL bDefault) const
{
    BOOL bValue;

    if (IsBoolString(m_Value.c_str(), &bValue))
    {
        return bValue;
    }
    else
    {
        return bDefault;
    }
}

// --------- Write values --------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::SetValues
//
//  Purpose:    Sets the value of this key to the value passed
//
//
//  Arguments:
//      pszFormat       [in]   format string (printf style)
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfKey::SetValues(IN PCWSTR Format, IN ...)
{
    va_list arglist;
    va_start (arglist, Format);
    SetValues(Format, arglist);
    va_end(arglist);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::SetValue
//
//  Purpose:    Sets the value of this key to the value passed
//
//
//  Arguments:
//      pszFormat       [in]   format string (printf style)
//      arglist         [in]   argument list
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfKey::SetValues(IN PCWSTR Format, va_list arglist)
{
    // we need m_Buffer because tstring does not provide
    // tstring::Format( PCWSTR lpszFormat, va_list );

    vswprintf(m_Buffer, Format, arglist);
    m_Value = m_Buffer;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::SetValue
//
//  Purpose:    Sets the value of this key to the value passed
//
//
//  Arguments:
//      pszValue        [in]   value to assign
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfKey::SetValue(IN PCWSTR Value)
{
    m_Value = Value;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::SetValue
//
//  Purpose:    Sets the value of this key to the value passed
//
//
//  Arguments:
//      dwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfKey::SetValue(IN DWORD Value)
{
    FormatTString(m_Value, L"%d", Value);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::SetQwordValue
//
//  Purpose:    Sets the value of this key to the value passed
//
//
//  Arguments:
//      qwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfKey::SetQwordValue(IN QWORD Value)
{
    FormatTString(m_Value, L"0x%I64x", Value);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::SetHexValue
//
//  Purpose:    Sets the value of this key to the value passed, stores value in hex.
//
//
//  Arguments:
//      dwValue         [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfKey::SetHexValue(IN DWORD Value)
{
    FormatTString(m_Value, L"0x%0lx", Value);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::SetValue
//
//  Purpose:    Sets the value of this key to the value passed
//
//
//  Arguments:
//      slValues        [in]   values in the form of a string list
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     The string-list is converted to a comma-delimited list before
//     the value is assigned to the key
//
void CWInfKey::SetValue(IN const TStringList &slValues)
{
    tstring strFlatList;
    ConvertStringListToCommaList(slValues, strFlatList);
    SetValue(strFlatList.c_str());
    m_fIsAListAndAlreadyProcessed = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfKey::SetBoolValue
//
//  Purpose:    Sets the value of this key to the value passed
//
//
//  Arguments:
//      fValue          [in]   value
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//     TRUE  is stored as "Yes"
//     FALSE is stored as "No"
//
void CWInfKey::SetBoolValue(IN BOOL Value)
{
    m_Value = Value ? c_szYes : c_szNo;
}

// ======================================================================
// Class CWInfComment
// ======================================================================

// ----------------------------------------------------------------------
// CWInfComment public functions
// ----------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Member:     CWInfComment::CWInfComment
//
//  Purpose:    constructor
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
CWInfComment::CWInfComment(IN PCWSTR pszComment)
    : CWInfLine(INF_COMMENT)
{
    m_strCommentText = tstring(c_szCommentPrefix) + pszComment;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfComment::~CWInfComment
//
//  Purpose:    destructor
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//
CWInfComment::~CWInfComment()
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CWInfComment::GetText
//
//  Purpose:    Get text representation of this comment
//
//  Arguments:
//      text      [in]   string that receives the text
//
//  Returns:    none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
void CWInfComment::GetText(tstring &text) const
{
    text = m_strCommentText;
}

// used by SysPrep
void CWInfComment::GetTextEx(tstring &text) const
{
    text = m_strCommentText;
}

// ======================================================================
// Class CWInfRaw
// ======================================================================

// ----------------------------------------------------------------------
// CWInfRaw public functions
// ----------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Member:     CWInfRaw::CWInfRaw
//
//  Purpose:    constructor
//
//  Arguments:  none
//
//  Author:     danielwe    11 Jun 1997
//
//  Notes:
//
CWInfRaw::CWInfRaw(IN PCWSTR szText)
    : CWInfLine(INF_RAW)
{
    m_strText = szText;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfRaw::~CWInfRaw
//
//  Purpose:    destructor
//
//  Arguments:  none
//
//  Author:     danielwe    11 Jun 1997
//
//
CWInfRaw::~CWInfRaw()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CWInfRaw::GetText
//
//  Purpose:    Get text representation of this raw string
//
//  Arguments:
//      text      [in]   string that receives the text
//
//  Returns:    none
//
//  Author:     danielwe    11 Jun 1997
//
//  Notes:
//
void CWInfRaw::GetText(tstring &text) const
{
    text = m_strText;
}

// used by SysPrep
void CWInfRaw::GetTextEx(tstring &text) const
{
    text = m_strText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncnetcfg\ncnetcfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C N E T C F G . C P P
//
//  Contents:   Common routines for dealing with INetCfg interfaces.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "netcfgx.h"
#include "netcfgn.h"
#include "netcfgp.h"
#include "ncdebug.h"
#include "ncbase.h"
#include "ncmisc.h"
#include "ncnetcfg.h"
#include "ncreg.h"
#include "ncvalid.h"

extern const WCHAR c_szRegKeyAnswerFileMap[];
extern const WCHAR c_szInfId_MS_AppleTalk[];
extern const WCHAR c_szInfId_MS_AtmArps[];
extern const WCHAR c_szInfId_MS_AtmElan[];
extern const WCHAR c_szInfId_MS_AtmLane[];
extern const WCHAR c_szInfId_MS_AtmUni[];
extern const WCHAR c_szInfId_MS_DHCPServer[];
extern const WCHAR c_szInfId_MS_FPNW[];
extern const WCHAR c_szInfId_MS_GPC[];
extern const WCHAR c_szInfId_MS_IrDA[];
extern const WCHAR c_szInfId_MS_IrdaMiniport[];
extern const WCHAR c_szInfId_MS_IrModemMiniport[];
extern const WCHAR c_szInfId_MS_Isotpsys[];
extern const WCHAR c_szInfId_MS_L2TP[];
extern const WCHAR c_szInfId_MS_L2tpMiniport[];
extern const WCHAR c_szInfId_MS_MSClient[];
extern const WCHAR c_szInfId_MS_NdisWan[];
extern const WCHAR c_szInfId_MS_NdisWanAtalk[];
extern const WCHAR c_szInfId_MS_NdisWanBh[];
extern const WCHAR c_szInfId_MS_NdisWanIp[];
extern const WCHAR c_szInfId_MS_NdisWanIpx[];
extern const WCHAR c_szInfId_MS_NdisWanNbfIn[];
extern const WCHAR c_szInfId_MS_NdisWanNbfOut[];
extern const WCHAR c_szInfId_MS_NetBIOS[];
extern const WCHAR c_szInfId_MS_NetBT[];
extern const WCHAR c_szInfId_MS_NetBT_SMB[];
extern const WCHAR c_szInfId_MS_NetMon[];
extern const WCHAR c_szInfId_MS_NWClient[];
extern const WCHAR c_szInfId_MS_NWIPX[];
extern const WCHAR c_szInfId_MS_NWNB[];
extern const WCHAR c_szInfId_MS_NwSapAgent[];
extern const WCHAR c_szInfId_MS_NWSPX[];
extern const WCHAR c_szInfId_MS_PPPOE[];
extern const WCHAR c_szInfId_MS_PppoeMiniport[];
extern const WCHAR c_szInfId_MS_PPTP[];
extern const WCHAR c_szInfId_MS_PptpMiniport[];
extern const WCHAR c_szInfId_MS_PSched[];
extern const WCHAR c_szInfId_MS_PSchedMP[];
extern const WCHAR c_szInfId_MS_PSchedPC[];
extern const WCHAR c_szInfId_MS_PtiMiniport[];
extern const WCHAR c_szInfId_MS_RasCli[];
extern const WCHAR c_szInfId_MS_RasMan[];
extern const WCHAR c_szInfId_MS_RasSrv[];
extern const WCHAR c_szInfId_MS_RawWan[];
extern const WCHAR c_szInfId_MS_RSVP[];
extern const WCHAR c_szInfId_MS_Server[];
extern const WCHAR c_szInfId_MS_Steelhead[];
extern const WCHAR c_szInfId_MS_Streams[];
extern const WCHAR c_szInfId_MS_TCPIP[];


#pragma BEGIN_CONST_SECTION

// Warning: This must stay sorted on component id!
// Hint: With VSlick, use 'sort_on_selection AI' to resort this.
//
extern const __declspec(selectany) COMPONENT_INFO  c_mapComponents [] =
{
    { c_szInfId_MS_AppleTalk,       &GUID_DEVCLASS_NETTRANS,    L"netatlk.inf" },
    { c_szInfId_MS_AtmArps,         &GUID_DEVCLASS_NETTRANS,    L"netaarps.inf"},
    { c_szInfId_MS_AtmElan,         &GUID_DEVCLASS_NET,         L"netlanem.inf"},
    { c_szInfId_MS_AtmLane,         &GUID_DEVCLASS_NETTRANS,    L"netlanep.inf"},
    { c_szInfId_MS_AtmUni,          &GUID_DEVCLASS_NETTRANS,    L"netauni.inf"},
    { c_szInfId_MS_DHCPServer,      &GUID_DEVCLASS_NETSERVICE,  L"netdhcps.inf" },
    { c_szInfId_MS_FPNW,            &GUID_DEVCLASS_NETSERVICE,  L"netsfn.inf" },
    { c_szInfId_MS_GPC,             &GUID_DEVCLASS_NET,         L"netgpc.inf" },
    { c_szInfId_MS_IrDA,            &GUID_DEVCLASS_NETTRANS,    L"netirda.inf" },
    { c_szInfId_MS_IrdaMiniport,    &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_IrModemMiniport, &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_Isotpsys,        &GUID_DEVCLASS_NETTRANS,    L"nettp4.inf" },
    { c_szInfId_MS_L2TP,            &GUID_DEVCLASS_NETTRANS,    L"netrast.inf" },
    { c_szInfId_MS_L2tpMiniport,    &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_MSClient,        &GUID_DEVCLASS_NETCLIENT,   L"netmscli.inf" },
    { c_szInfId_MS_NdisWan,         &GUID_DEVCLASS_NETTRANS,    L"netrast.inf" },
    { c_szInfId_MS_NdisWanAtalk,    &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_NdisWanBh,       &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_NdisWanIp,       &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_NdisWanIpx,      &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_NdisWanNbfIn,    &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_NdisWanNbfOut,   &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_NetBIOS,         &GUID_DEVCLASS_NETSERVICE,  L"netnb.inf" },
    { c_szInfId_MS_NetBT,           &GUID_DEVCLASS_NETTRANS,    L"nettcpip.inf" },
    { c_szInfId_MS_NetBT_SMB,       &GUID_DEVCLASS_NETTRANS,    L"nettcpip.inf" },
    { c_szInfId_MS_NetMon,          &GUID_DEVCLASS_NETTRANS,    L"netnm.inf" },
    { c_szInfId_MS_NWClient,        &GUID_DEVCLASS_NETCLIENT,   L"netnwcli.inf" },
    { c_szInfId_MS_NWIPX,           &GUID_DEVCLASS_NETTRANS,    L"netnwlnk.inf" },
    { c_szInfId_MS_NWNB,            &GUID_DEVCLASS_NETTRANS,    L"netnwlnk.inf" },
    { c_szInfId_MS_NwSapAgent,      &GUID_DEVCLASS_NETSERVICE,  L"netsap.inf" },
    { c_szInfId_MS_NWSPX,           &GUID_DEVCLASS_NETTRANS,    L"netnwlnk.inf" },
    { c_szInfId_MS_PPPOE,           &GUID_DEVCLASS_NETTRANS,    L"netrast.inf" },
    { c_szInfId_MS_PppoeMiniport,   &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_PPTP,            &GUID_DEVCLASS_NETTRANS,    L"netrast.inf" },
    { c_szInfId_MS_PptpMiniport,    &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_PSched,          &GUID_DEVCLASS_NETSERVICE,  L"netpschd.inf" },
    { c_szInfId_MS_PSchedMP,        &GUID_DEVCLASS_NET,         L"netpsa.inf" },
    { c_szInfId_MS_PSchedPC,        &GUID_DEVCLASS_NETSERVICE,  L"netpschd.inf" },
    { c_szInfId_MS_PtiMiniport,     &GUID_DEVCLASS_NET,         L"netrasa.inf" },
    { c_szInfId_MS_RasCli,          &GUID_DEVCLASS_NETSERVICE,  L"netrass.inf" },
    { c_szInfId_MS_RasMan,          &GUID_DEVCLASS_NETSERVICE,  L"netrass.inf" },
    { c_szInfId_MS_RasSrv,          &GUID_DEVCLASS_NETSERVICE,  L"netrass.inf" },
    { c_szInfId_MS_RawWan,          &GUID_DEVCLASS_NETTRANS,    L"netrwan.inf" },
    { c_szInfId_MS_RSVP,            &GUID_DEVCLASS_NETSERVICE,  L"netrsvp.inf"},
    { c_szInfId_MS_Server,          &GUID_DEVCLASS_NETSERVICE,  L"netserv.inf" },
    { c_szInfId_MS_Steelhead,       &GUID_DEVCLASS_NETSERVICE,  L"netrass.inf" },
    { c_szInfId_MS_Streams,         &GUID_DEVCLASS_NETTRANS,    L"netstrm.inf" },
    { c_szInfId_MS_TCPIP,           &GUID_DEVCLASS_NETTRANS,    L"nettcpip.inf" },
    { L"ms_wanarp",                 &GUID_DEVCLASS_NET,         L"netrast.inf" },
};

#pragma END_CONST_SECTION


//+---------------------------------------------------------------------------
//
//  Function:   NCompareComponentIds
//
//  Purpose:    Compare function for bsearch.
//
//  Arguments:
//      ppszComp1 [in] pointer to pointer to a component id
//      ppszComp2 [in] pointer to pointer to a component id
//
//  Returns:    < 0 if pvComp1 is less than pvComp2
//                0 if they are equal
//              > 0 if pvComp1 is greater than pvComp2
//
//  Author:     shaunco   27 Jul 1997
//
//  Notes:
//
int __cdecl
NCompareComponentIds (
    IN  const PCWSTR* ppszComp1,
    IN  const PCWSTR* ppszComp2)
{
    return lstrcmpiW (*ppszComp1, *ppszComp2);
}

//+---------------------------------------------------------------------------
//
//  Function:   PComponentInfoFromComponentId
//
//  Purpose:    Return the COMPONENT_INFO record within c_mapComponents
//              having the specified component id.
//
//  Arguments:
//      pszComponentId [in] The requested component id.
//
//  Returns:    NULL if not found.
//
//  Author:     shaunco   27 Jul 1997
//
//  Notes:
//
inline
const COMPONENT_INFO*
PComponentInfoFromComponentId (
    PCWSTR pszComponentId)
{
    // For debug builds, check that c_mapComponents is sorted properley.
    // If it isn't, bsearch (called below) won't work.  Only perform this
    // check once because the map doesn't change.
    //
#ifdef DBG
    static BOOL fCheckedSorted = FALSE;

    if (!fCheckedSorted)
    {
        fCheckedSorted = TRUE;

        for (UINT i = 1; i < celems (c_mapComponents); i++)
        {
            PCWSTR pszComp1 = c_mapComponents [i-1].pszComponentId;
            PCWSTR pszComp2 = c_mapComponents [i]  .pszComponentId;
            if (NCompareComponentIds (&pszComp1, &pszComp2) >= 0)
            {
                AssertFmt (FALSE, FAL,
                           "'%S' in c_mapComponents is out of order!  "
                           "Component installation may fail in bizarre ways!",
                           pszComp2);
            }
        }
    }
#endif

    typedef int (__cdecl *PFNCOMPARE)(const void *, const void *);

    PFNCOMPARE pfn = reinterpret_cast<PFNCOMPARE>(NCompareComponentIds);

    return static_cast<const COMPONENT_INFO*>
                (bsearch (&pszComponentId,
                          &c_mapComponents->pszComponentId,
                          celems (c_mapComponents),
                          sizeof (c_mapComponents[0]),
                          pfn));
}

//+---------------------------------------------------------------------------
//
//  Function:   FClassGuidFromComponentId
//
//  Purpose:    Given a component id, returns the class guid associated with
//              it.
//
//  Arguments:
//      pszComponentId  [in]  Component id to look up.
//      pguidClass      [out] Class guid to be returned.
//
//  Returns:    TRUE if component was found, FALSE if not.
//
//  Author:     danielwe   17 Jun 1997
//
//  Notes:
//
BOOL
FClassGuidFromComponentId (
    PCWSTR          pszComponentId,
    const GUID**    ppguidClass)
{
    Assert(ppguidClass);

    // Initialize output parameter.
    //
    *ppguidClass = NULL;

    const COMPONENT_INFO* pComponentInfo =
            PComponentInfoFromComponentId (pszComponentId);
    if (pComponentInfo)
    {
        *ppguidClass = pComponentInfo->pguidClass;
        return TRUE;
    }
    TraceTag (ttidNetcfgBase,
              "Found no match for %S in FClassGuidFromComponentId.",
              pszComponentId);
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FInfFileFromComponentId
//
//  Purpose:    Given a component ID, returns the INF file name it lives in.
//
//  Arguments:
//      pszComponentId [in]  Component id to look up.
//      pszInfFile     [out] INF file name to be returned.
//                           (must be _MAX_PATH long).
//
//  Returns:    TRUE if component was found, FALSE if not.
//
//  Author:     shaunco   27 Jul 1997
//
//  Notes:
//
BOOL
FInfFileFromComponentId (
    PCWSTR  pszComponentId,
    PWSTR   pszInfFile)
{
    Assert(pszComponentId);
    Assert(pszInfFile);

    // Initialize output parameter.
    //
    *pszInfFile = 0;

    const COMPONENT_INFO* pComponentInfo =
            PComponentInfoFromComponentId (pszComponentId);
    if (pComponentInfo)
    {
        wcsncpy (pszInfFile, pComponentInfo->pszInfFile, _MAX_PATH);
        pszInfFile [_MAX_PATH - 1] = 0;
        return TRUE;
    }
    TraceTag (ttidNetcfgBase,
              "Found no match for %S in FInfFileFromComponentId.",
              pszComponentId);
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   FGetInstanceGuidOfComponentFromAnswerFileMap
//
//  Purpose:    Maps a component instance in the answer file to
//              its instance guid.
//
//  Arguments:
//      pszComponentId   [in]       Name of component to get guid of.
//      pguid            [out]      Returns instance GUID of that component.
//
//  Returns:    TRUE if successful, FALSE if the component was not located.
//
BOOL
FGetInstanceGuidOfComponentFromAnswerFileMap (
    IN  PCWSTR  pszComponentId,
    OUT GUID*   pguid)
{

    HRESULT hr;
    BOOL fFound = FALSE;

    // Component not found as already installed. Need to examine the
    // AnswerFileMap in the registry.
    //
    HKEY hkey;
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyAnswerFileMap,
                        KEY_QUERY_VALUE, &hkey);
    if (S_OK == hr)
    {
        WCHAR szGuid [c_cchGuidWithTerm];
        DWORD cbData = sizeof (szGuid);
        hr = HrRegQuerySzBuffer(hkey, pszComponentId, szGuid, &cbData);
        if (S_OK == hr)
        {
            hr = IIDFromString(szGuid, pguid);
            fFound = (S_OK == hr);
        }

        RegCloseKey(hkey);
    }

#ifdef ENABLETRACE
    if (FAILED(hr))
    {
        TraceTag(ttidNetcfgBase, "FGetInstanceGuidOfComponentInAnswerFile: "
                "could not locate instance GUID of %S", pszComponentId);
    }
#endif

    return fFound;
}

//+---------------------------------------------------------------------------
//
//  Function:   FGetInstanceGuidOfComponentInAnswerFile
//
//  Purpose:    Maps a component instance in the answer file to
//              its instance guid.
//
//  Arguments:
//      pszComponentId   [in]       Name of component to get guid of.
//      pnc              [in]       INetCfg interface
//      pguid            [out]      Returns instance GUID of that component.
//
//  Returns:    TRUE if successful, FALSE if the component was not located.
//
BOOL
FGetInstanceGuidOfComponentInAnswerFile(
    IN  PCWSTR      pszComponentId,
    IN  INetCfg*    pnc,
    OUT LPGUID      pguid)
{
    static char __FUNCNAME__[] = "FGetInstanceGuidOfComponentInAnswerFile";

    Assert (pszComponentId);
    AssertValidReadPtr(pnc);
    AssertValidWritePtr(pguid);

    // Search for the component.
    //
    INetCfgComponent* pncc;
    HRESULT hr = pnc->FindComponent (pszComponentId, &pncc);
    if (S_OK == hr)
    {
        hr = pncc->GetInstanceGuid (pguid);
        ReleaseObj(pncc);
    }
    else
    {
        // Component not found as already installed. Need to examine the
        // AnswerFileMap in the registry.
        //
        HKEY hkey;
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyAnswerFileMap,
                            KEY_QUERY_VALUE, &hkey);
        if (S_OK == hr)
        {
            WCHAR szGuid [c_cchGuidWithTerm];
            DWORD cbData = sizeof (szGuid);
            hr = HrRegQuerySzBuffer(hkey, pszComponentId, szGuid, &cbData);
            if (S_OK == hr)
            {
                hr = IIDFromString(szGuid, pguid);
            }

            RegCloseKey(hkey);
        }

#ifdef ENABLETRACE
        if (FAILED(hr))
        {
            TraceTag(ttidNetcfgBase, "%s: could not locate instance GUID of %S",
                     __FUNCNAME__, pszComponentId);
        }
#endif
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), __FUNCNAME__);
    return (SUCCEEDED(hr)) ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsBindingName
//
//  Purpose:    Returns TRUE if a binding interface is of the specified name.
//
//  Arguments:
//      pszName  [in] Name of the binding interface to check for.
//      dwFlags  [in] FIBN_ flags
//      pncbi    [in] Binding interface pointer.
//
//  Returns:    TRUE if the binding interface is of the specified name.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:
//
BOOL
FIsBindingName (
    PCWSTR                      pszName,
    DWORD                       dwFlags,
    INetCfgBindingInterface*    pncbi)
{
    Assert (pszName);
    Assert (pncbi);

    BOOL fRet = FALSE;
    PWSTR pszInterfaceName;
    if (SUCCEEDED(pncbi->GetName (&pszInterfaceName)))
    {
        INT c_cchPrefix = (FIBN_PREFIX & dwFlags) ? lstrlenW (pszName) : -1;

        fRet = (2 == CompareStringW (LOCALE_SYSTEM_DEFAULT, 0,
                                     pszName, c_cchPrefix,
                                     pszInterfaceName, c_cchPrefix));

        CoTaskMemFree (pszInterfaceName);
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsComponentId
//
//  Purpose:    Returns TRUE if a component is of the specified id.
//
//  Arguments:
//      pszComponentId  [in] Component Id to check for.
//      pncc            [in] Component interface pointer.
//
//  Returns:    TRUE if component is of the specified id.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:
//
BOOL
FIsComponentId (
    PCWSTR              pszComponentId,
    INetCfgComponent*   pncc)
{
    Assert (pszComponentId);
    Assert (pncc);

    BOOL fRet = FALSE;
    PWSTR pszId;
    if (SUCCEEDED(pncc->GetId (&pszId)))
    {
        if (FEqualComponentId (pszComponentId, pszId))
            fRet = TRUE;

        CoTaskMemFree (pszId);
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrAddOrRemoveAdapter
//
//  Purpose:
//
//  Arguments:
//      pnc             [in] pointer to an INetCfg object.
//      pszComponentId  [in] component INF id.
//      dwFlags         [in]
//
//          ARA_ADD       :  Add the component
//          ARA_REMOVE    :  Remove the component.  Cannot be specified
//                           with ARA_ADD.
//      pOboToken       [in] If specified, refcount the adapter.  This is the
//                           on behalf of token adding or removing the specified
//                           component.  This allows per-component reference
//                           counts of another.
//      cInstances      [in] this specifies how many instances (or references)
//                           to add or remove.
//      ppncc           [out] (optional). The newly added component.  Can only
//                            be specified when adding one component.
//
//  Returns:    S_OK or an error
//
//  Author:     shaunco   28 Mar 1997
//
//  Notes:
//
HRESULT
HrAddOrRemoveAdapter (
    INetCfg*            pnc,
    PCWSTR              pszComponentId,
    DWORD               dwFlags,
    OBO_TOKEN*          pOboToken,
    UINT                cInstances,
    INetCfgComponent**  ppncc)
{
    Assert (pnc);
    Assert (pszComponentId);
    Assert (dwFlags);
    Assert (cInstances);

#ifdef DBG
    AssertSz ((dwFlags & ARA_ADD) || (dwFlags & ARA_REMOVE),
              "Need to add or remove.  Can't do neither.");

    if (dwFlags & ARA_ADD)
    {
        AssertSz (!(dwFlags & ARA_REMOVE), "Can't remove AND add.");
    }
    if (dwFlags & ARA_REMOVE)
    {
        AssertSz (!(dwFlags & ARA_ADD), "Can't add AND remove.");
    }
    AssertSz (FImplies(1 != cInstances, NULL == ppncc),
              "Can't return ppncc when cInstances is greater than one.");
    AssertSz (FImplies(ppncc, 1 == cInstances),
              "Can only add one instance when returning ppncc.");
    AssertSz (FImplies(ppncc, dwFlags & ARA_ADD),
              "Can't return ppncc when removing.");
#endif

    // Get the component class object for adapters.
    INetCfgClass* pncclass;
    HRESULT hr = pnc->QueryNetCfgClass (&GUID_DEVCLASS_NET, IID_INetCfgClass,
                    reinterpret_cast<void**>(&pncclass));
    if (S_OK == hr)
    {
        INetCfgClassSetup* pncclasssetup;
        hr = pncclass->QueryInterface (IID_INetCfgClassSetup,
                reinterpret_cast<void**>(&pncclasssetup));
        if (S_OK == hr)
        {
            if (dwFlags & ARA_ADD)
            {
                // Install the component the specified number of times.
                //
                while (SUCCEEDED(hr) && cInstances--)
                {
                    hr = pncclasssetup->Install(pszComponentId, pOboToken,
                                                0, 0, NULL, NULL, ppncc );
                }
            }
            else
            {
                // Remove the component the specified number of times.
                //
                AssertSz(S_OK == hr, "hr should be S_OK here to make sure the "
                                     "loop is given a chance.");
                while (SUCCEEDED(hr) && cInstances)
                {
                    // Find and remove the component.
                    //
                    INetCfgComponent* pncc;
                    hr = pncclass->FindComponent (pszComponentId, &pncc);
                    if (S_OK == hr)
                    {
                        hr = pncclasssetup->DeInstall (pncc,
                                pOboToken, NULL);

                        cInstances--;

                        ReleaseObj (pncc);
                    }
                    else if (S_FALSE == hr)
                    {
                        // If it wasn't found, get out.
                        break;
                    }
                }
                AssertSz (FImplies(SUCCEEDED(hr), (0 == cInstances)),
                          "cInstances should be zero.  This assert means "
                          "that we were asked to remove more instances than "
                          "were installed.");
            }

            // Normalize the HRESULT.
            // Possible values of hr at this point are S_FALSE,
            // NETCFG_S_REBOOT, and NETCFG_S_STILL_REFERENCED.
            //
            if (SUCCEEDED(hr))
            {
                hr = S_OK;
            }

            ReleaseObj( pncclasssetup );
        }
        ReleaseObj (pncclass);
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrAddOrRemoveAdapter");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindAndRemoveAllInstancesOfAdapter
//
//  Purpose:    Remove all instances of the adapter with the specified
//              component id.
//
//  Arguments:
//      pnc             [in] INetCfg pointer.
//      pszComponentId  [in] Component id to search for and remove.
//
//  Returns:    S_OK or an error code
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
HRESULT
HrFindAndRemoveAllInstancesOfAdapter (
    INetCfg*    pnc,
    PCWSTR      pszComponentId)
{
    Assert (pnc);
    Assert (pszComponentId);

    PCWSTR apszComponentId [1];
    apszComponentId[0] = pszComponentId;

    HRESULT hr = HrFindAndRemoveAllInstancesOfAdapters (pnc,
                    1, apszComponentId);

    TraceHr (ttidError, FAL, hr, FALSE,
        "HrFindAndRemoveAllInstancesOfAdapter");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindAndRemoveAllInstancesOfAdapters
//
//  Purpose:    Remove all instances of the adapters with the specified
//              component ids.
//
//  Arguments:
//      pnc              [in] INetCfg pointer.
//      cComponents      [in] Count of component ids in the array.
//      apszComponentId  [in] Array of compoennt ids to search for and
//                             remove.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
HRESULT
HrFindAndRemoveAllInstancesOfAdapters (
    INetCfg*        pnc,
    ULONG           cComponents,
    const PCWSTR*   apszComponentId)
{
    Assert (pnc);
    Assert (cComponents);
    Assert (apszComponentId);

    // Get the class object for adapters.
    INetCfgClass* pncclass;
    INetCfgClassSetup* pncclasssetup;

    HRESULT hr = pnc->QueryNetCfgClass (&GUID_DEVCLASS_NET,
                        IID_INetCfgClass,
                        reinterpret_cast<void**>(&pncclass));
    if (S_OK == hr)
    {
        hr = pncclass->QueryInterface (IID_INetCfgClassSetup,
                reinterpret_cast<void**>(&pncclasssetup));
        if (S_OK == hr)
        {
            for (ULONG i = 0; (i < cComponents) && SUCCEEDED(hr); i++)
            {
                // Find and remove all instances of the component.
                INetCfgComponent* pncc;

                while ((SUCCEEDED(hr)) &&
                       (S_OK == (hr = pncclass->FindComponent (
                                        apszComponentId[i], &pncc))))
                {
                    hr = pncclasssetup->DeInstall (pncc, NULL, NULL);
                    ReleaseObj (pncc);
                }

                // Normalize the HRESULT.
                //
                if (SUCCEEDED(hr))
                {
                    hr = S_OK;
                }
            }
            ReleaseObj (pncclasssetup);
        }
        ReleaseObj (pncclass);
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "HrFindAndRemoveAllInstancesOfAdapters");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindAndRemoveComponent
//
//  Purpose:    Find and remove the component with the specified id.
//
//  Arguments:
//      pnc             [in] INetCfg pointer.
//      pguidClass      [in] Class GUID of the component.
//      pszComponentId  [in] Component id to search for and remove.
//      pOboToken       [in] (Optional) If specified, remove on behalf of.
//
//  Returns:    S_OK, NETCFG_S_STILL_REFERENCED, or an error code.
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
HRESULT
HrFindAndRemoveComponent (
    INetCfg*    pnc,
    const GUID* pguidClass,
    PCWSTR      pszComponentId,
    OBO_TOKEN*  pOboToken)
{
    Assert (pnc);
    Assert (pguidClass);
    Assert (pszComponentId);
    AssertSz (GUID_DEVCLASS_NET != *pguidClass,
                "Don't use this to remove adapters.");

    // Get the component class object.
    //
    INetCfgClass* pncclass;
    HRESULT hr = pnc->QueryNetCfgClass (pguidClass, IID_INetCfgClass,
                    reinterpret_cast<void**>(&pncclass));
    if (SUCCEEDED(hr))
    {
        // Find the component to remove.
        //
        INetCfgComponent* pnccRemove;
        hr = pncclass->FindComponent (pszComponentId, &pnccRemove);
        if (S_OK == hr)
        {
            INetCfgClassSetup* pncclasssetup;
            hr = pncclass->QueryInterface (IID_INetCfgClassSetup,
                        reinterpret_cast<void**>(&pncclasssetup));
            if (SUCCEEDED(hr))
            {
                hr = pncclasssetup->DeInstall (pnccRemove, pOboToken, NULL);

                ReleaseObj (pncclasssetup);
            }

            ReleaseObj (pnccRemove);
        }
        else if (S_FALSE == hr)
        {
            hr = S_OK;
        }

        ReleaseObj (pncclass);
    }
    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrFindAndRemoveComponent");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindAndRemoveComponents
//
//  Purpose:    Find and remove the components with the specified ids.
//
//  Arguments:
//      pnc              [in] INetCfg pointer.
//      cComponents      [in] Count of components in the array.
//      apguidClass      [in] Array of class GUIDs corresponding to the
//                            array of component ids.
//      apszComponentId  [in] Array of component ids to search for and
//                            remove.
//      pOboToken        [in] (Optional) If specified, remove on behalf of.
//
//  Returns:    S_OK, NETCFG_S_STILL_REFERENCED, or an error code.
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
HRESULT
HrFindAndRemoveComponents (
    INetCfg*        pnc,
    ULONG           cComponents,
    const GUID**    apguidClass,
    const PCWSTR*   apszComponentId,
    OBO_TOKEN*      pOboToken)
{
    Assert (pnc);
    Assert (cComponents);
    Assert (apguidClass);
    Assert (apszComponentId);

    HRESULT hr = S_OK;
    for (ULONG i = 0; (i < cComponents) && SUCCEEDED(hr); i++)
    {
        hr = HrFindAndRemoveComponent (pnc, apguidClass[i],
                    apszComponentId[i], pOboToken);
    }
    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrFindAndRemoveComponents");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindAndRemoveComponentsOboComponent
//
//  Purpose:    Remove multiple components on behalf of one component.
//
//  Arguments:
//      pnc         [in]    pointer to an INetCfg object.
//      cComponents [in]    count of class guid pointers and component id
//                          pointers.
//      apguidClass [in]    array of class guid pointers.
//      apszId      [in]    array of component id pointers.
//      pnccObo     [in]    the component requesting the remove. (i.e. the
//                          "on behalf of" component.)
//
//  Returns:    S_OK, NETCFG_S_STILL_REFERENCED, or an error code.
//
//  Author:     shaunco   13 Apr 1997
//
//  Notes:
//
HRESULT
HrFindAndRemoveComponentsOboComponent (
    INetCfg*            pnc,
    ULONG               cComponents,
    const GUID**        apguidClass,
    const PCWSTR*       apszComponentId,
    INetCfgComponent*   pnccObo)
{
    Assert (pnc);
    Assert (cComponents);
    Assert (apguidClass);
    Assert (apszComponentId);
    Assert (pnccObo);

    // Make an "on behalf of" token for the requesting component.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_COMPONENT;
    OboToken.pncc = pnccObo;

    HRESULT hr = HrFindAndRemoveComponents (pnc, cComponents,
                    apguidClass, apszComponentId, &OboToken);

    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrFindAndRemoveComponentsOboComponent");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindAndRemoveComponentsOboUser
//
//  Purpose:    Remove multiple components on behalf of one component.
//
//  Arguments:
//      pnc         [in]    pointer to an INetCfg object.
//      cComponents [in]    count of class guid pointers and component id
//                          pointers.
//      apguidClass [in]    array of class guid pointers.
//      apszId      [in]    array of component id pointers.
//
//  Returns:    S_OK, NETCFG_S_STILL_REFERENCED, or an error code.
//
//  Author:     shaunco   13 Apr 1997
//
//  Notes:
//
HRESULT
HrFindAndRemoveComponentsOboUser (
    INetCfg*            pnc,
    ULONG               cComponents,
    const GUID**        apguidClass,
    const PCWSTR*       apszComponentId)
{
    Assert (pnc);
    Assert (cComponents);
    Assert (apguidClass);
    Assert (apszComponentId);

    // Make an "on behalf of" token for the user.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    HRESULT hr = HrFindAndRemoveComponents (pnc, cComponents,
                    apguidClass, apszComponentId, &OboToken);

    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrFindAndRemoveComponentsOboUser");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindComponents
//
//  Purpose:    Find multiple INetCfgComponents with one call.  This makes
//              the error handling associated with multiple calls to
//              QueryNetCfgClass and Find much easier.
//
//  Arguments:
//      pnc             [in] pointer to INetCfg object
//      cComponents     [in] count of class guid pointers, component id
//                           pointers, and INetCfgComponent output pointers.
//      apguidClass     [in] array of class guid pointers.
//      apszComponentId [in] array of component id pointers.
//      apncc           [out] array of returned INetCfgComponet pointers.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   22 Mar 1997
//
//  Notes:      cComponents is the count of pointers in all three arrays.
//              S_OK will still be returned even if no components were
//              found!  This is by design.
//
HRESULT
HrFindComponents (
    INetCfg*            pnc,
    ULONG               cComponents,
    const GUID**        apguidClass,
    const PCWSTR*       apszComponentId,
    INetCfgComponent**  apncc)
{
    Assert (pnc);
    Assert (cComponents);
    Assert (apguidClass);
    Assert (apszComponentId);
    Assert (apncc);

    // Initialize the output parameters.
    //
    ZeroMemory (apncc, cComponents * sizeof(*apncc));

    // Find all of the components requested.
    // Variable initialization is important here.
    HRESULT hr = S_OK;
    ULONG i;
    for (i = 0; (i < cComponents) && SUCCEEDED(hr); i++)
    {
        // Get the class object for this component.
        INetCfgClass* pncclass;
        hr = pnc->QueryNetCfgClass (apguidClass[i], IID_INetCfgClass,
                    reinterpret_cast<void**>(&pncclass));
        if (SUCCEEDED(hr))
        {
            // Find the component.
            hr = pncclass->FindComponent (apszComponentId[i], &apncc[i]);

            AssertSz (SUCCEEDED(hr), "pncclass->Find failed.");

            ReleaseObj (pncclass);
        }
    }

    // On any error, release what we found and set the output to NULL.
    if (FAILED(hr))
    {
        for (i = 0; i < cComponents; i++)
        {
            ReleaseObj (apncc[i]);
            apncc[i] = NULL;
        }
    }
    // Otherwise, normalize the HRESULT.  (i.e. don't return S_FALSE)
    else
    {
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrFindComponents");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetBindingInterfaceComponents
//
//  Purpose:    Get both upper and lower components involved in a
//              binding interface.
//
//  Arguments:
//      pncbi      [in]     binding interface.
//      ppnccUpper [out]    output upper component.
//      ppnccLower [out]    output lower compoenet.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   18 Apr 1997
//
//  Notes:
//
HRESULT
HrGetBindingInterfaceComponents (
    INetCfgBindingInterface*    pncbi,
    INetCfgComponent**          ppnccUpper,
    INetCfgComponent**          ppnccLower)
{
    Assert (pncbi);
    Assert (ppnccUpper);
    Assert (ppnccLower);

    // Initialize the output parameters.
    *ppnccUpper = NULL;
    *ppnccLower = NULL;

    INetCfgComponent* pnccUpper;
    HRESULT hr = pncbi->GetUpperComponent (&pnccUpper);
    if (SUCCEEDED(hr))
    {
        INetCfgComponent* pnccLower;
        hr = pncbi->GetLowerComponent (&pnccLower);
        if (SUCCEEDED(hr))
        {
            *ppnccUpper = pnccUpper;
            *ppnccLower = pnccLower;
        }
        else
        {
            // Rather than AddRef this in the above SUCCEEDED block followed
            // by the normal unconditional Release, just Release here in
            // the case of failure to get the lower component.
            ReleaseObj (pnccUpper);
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrGetBindingInterfaceComponents");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponent
//
//  Purpose:    Install the component with a specified id.
//
//  Arguments:
//      pnc             [in] INetCfg pointer.
//      pnip            [in] (Optional) If specified, perform the installation
//                           using the answer file.
//      pguidClass      [in] Class guid of the component to install.
//      pszComponentId  [in] Component id to install.
//      pOboToken       [in] (Optional) If specified, perform the installation
//                           on behalf of this token.
//      ppncc           [out] (Optional) Returned component that was
//                            installed.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
HRESULT
HrInstallComponent (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    const GUID*                     pguidClass,
    PCWSTR                          pszComponentId,
    OBO_TOKEN*                      pOboToken,
    INetCfgComponent**              ppncc)
{
    Assert (pnc);
    Assert (pszComponentId);

    // Initialize output parameter.
    //
    if (ppncc)
    {
        *ppncc = NULL;
    }

    // Get the class setup object.
    //
    INetCfgClassSetup* pncclasssetup;
    HRESULT hr = pnc->QueryNetCfgClass (pguidClass, IID_INetCfgClassSetup,
                    reinterpret_cast<void**>(&pncclasssetup));
    if (SUCCEEDED(hr))
    {
        if (pnip)
        {
            hr = pncclasssetup->Install (
                    pszComponentId,
                    pOboToken,
                    pnip->dwSetupFlags,
                    pnip->dwUpgradeFromBuildNo,
                    pnip->pszAnswerFile,
                    pnip->pszAnswerSection,
                    ppncc);
        }
        else
        {
            hr = pncclasssetup->Install (pszComponentId,
                    pOboToken, 0, 0, NULL, NULL, ppncc);
        }

        ReleaseObj (pncclasssetup);
    }
    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "HrInstallComponent (%S)", pszComponentId);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponents
//
//  Purpose:    Install the components with the specified ids.
//
//  Arguments:
//      pnc              [in] INetCfg pointer.
//      pnip             [in] (Optional) If specified, perform the installation
//                            using the answer file.
//      cComponents      [in] Count of components in the arrays.
//      apguidClass      [in] Array of class guids for the specified components.
//      apszComponentId  [in] Array of component ids to install.
//      pOboToken        [in] (Optional) If specified, perform the installation
//                            on behalf of this token.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
HRESULT
HrInstallComponents (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    ULONG                           cComponents,
    const GUID**                    apguidClass,
    const PCWSTR*                   apszComponentId,
    OBO_TOKEN*                      pOboToken)
{
    Assert (pnc);
    Assert (cComponents);
    Assert (apguidClass);
    Assert (apszComponentId);

    HRESULT hr = S_OK;
    for (ULONG i = 0; (i < cComponents) && SUCCEEDED(hr); i++)
    {
        hr = HrInstallComponent (pnc, pnip,
                apguidClass[i], apszComponentId[i], pOboToken, NULL);
    }
    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "HrInstallComponents");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponentsOboComponent
//
//  Purpose:    Install multiple components on behalf of one component.
//
//  Arguments:
//      pnc              [in] pointer to an INetCfg object.
//      pnip             [in] (Optional) pointer to network install parameters.
//                            If non-NULL, a network install is performed,
//                            otherwise a normal install is performed.
//      cComponents      [in] count of class guid pointers and component id
//                            pointers.
//      apguidClass      [in] array of class guid pointers.
//      apszComponentId  [in] array of component id pointers.
//      pnccObo     [in]      the component requesting the install. (i.e. the
//                            "on behalf of" component.)
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   13 Apr 1997
//
//  Notes:
//
HRESULT
HrInstallComponentsOboComponent (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    ULONG                           cComponents,
    const GUID**                    apguidClass,
    const PCWSTR*                   apszComponentId,
    INetCfgComponent*               pnccObo)
{
    Assert (pnccObo);

    // Make an "on behalf of" token for the requesting component.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_COMPONENT;
    OboToken.pncc = pnccObo;

    HRESULT hr = HrInstallComponents (pnc, pnip, cComponents, apguidClass,
                    apszComponentId, &OboToken);

    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "HrInstallComponentsOboComponent");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponentsOboUser
//
//  Purpose:    Install multiple components on behalf of the user.
//
//  Arguments:
//      pnc              [in] INetCfg pointer.
//      pnip             [in] (Optional) If specified, perform the installation
//                            using the answer file.
//      cComponents      [in] Count of components in the arrays.
//      apguidClass      [in] Array of class guids for the specified components.
//      apszComponentId  [in] Array of component ids to install.
//
//  Returns:
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
HRESULT
HrInstallComponentsOboUser (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    ULONG                           cComponents,
    const GUID**                    apguidClass,
    const PCWSTR*                   apszComponentId)
{
    // Make an "on behalf of" token for the user.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    HRESULT hr = HrInstallComponents (pnc, pnip, cComponents, apguidClass,
                    apszComponentId, &OboToken);

    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "HrInstallComponentsOboUser");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponentOboComponent
//
//  Purpose:    Installs a component on behalf of another.  If the component
//              is already installed, it reference count is incremented on
//              behalf of the component doing the install.  When one
//              component calls this function to install another, it is
//              saying that it has a depencency on the component being
//              installed.  This dependency will prevent even the user from
//              removing the component.
//
//  Arguments:
//      pnc           [in]  pointer to an INetCfg object.
//      pnip          [in]  (Optional) pointer to network install parameters.
//                          If non-NULL, a network install is performed,
//                          otherwise a normal install is performed.
//      rguid         [in]  class GUID of the component being installed.
//      pszComponentId [in]  component INF id of the component being installed.
//      pnccObo       [in]  the component requesting the install. (i.e. the
//                          "on behalf of" component.)
//      ppncc         [out] (Optional) set on return to the previously
//                          installed component or the one that was installed.
//
//  Returns:    S_OK or an error.
//
//  Author:     shaunco   7 Apr 1997
//
//  Notes:
//
HRESULT
HrInstallComponentOboComponent (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    const GUID&                     rguid,
    PCWSTR                          pszComponentId,
    INetCfgComponent*               pnccObo,
    INetCfgComponent**              ppncc)
{
    Assert (pnc);
    Assert (pszComponentId);
    Assert (pnccObo);

    // Initialize output parameter.
    //
    if (ppncc)
    {
        *ppncc = NULL;
    }

    // Make an "on behalf of" token for the requesting component.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_COMPONENT;
    OboToken.pncc = pnccObo;

    HRESULT hr = HrInstallComponent (pnc, pnip, &rguid, pszComponentId,
                    &OboToken, ppncc);

    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "HrInstallComponentOboComponent");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponentOboSoftware
//
//  Purpose:    Installs a component on behalf of a piece of software.
//              If the component is already installed, it's reference count
//              is incremented on behalf of the indicated software piece.
//              This is useful for a component to call
//              when it is installing another component as a convienience for
//              the user.  The user can then remove the component with no
//              ill-effects for the component that called this function.
//
//  Arguments:
//      pnc              [in] pointer to an INetCfg object.
//      pnip             [in] (Optional) pointer to network install parameters.
//                            If non-NULL, a network install is performed,
//                            otherwise a normal install is performed.
//      rguid            [in] class GUID of the component being installed.
//      pszComponentId   [in] component INF id of the component being installed.
//      pszManufacturer  [in] Manufacturer name of software.
//      pszProduct       [in] Product name of software.
//      pszDisplayName   [in] Full display name of software.
//      ppncc            [out] (Optional) set on return to the previously
//                            installed component or the one that was installed.
//
//  Returns:
//
//  Author:     danielwe   5 May 1997
//
//  Notes:
//
HRESULT
HrInstallComponentOboSoftware (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    const GUID&                     rguid,
    PCWSTR                          pszComponentId,
    PCWSTR                          pszManufacturer,
    PCWSTR                          pszProduct,
    PCWSTR                          pszDisplayName,
    INetCfgComponent**              ppncc)
{
    Assert (pnc);
    Assert (pszComponentId);
    Assert (pszManufacturer);
    Assert (pszDisplayName);
    Assert (pszProduct);
    AssertSz (GUID_DEVCLASS_NET != rguid, "Don't use this to install adapters.");

    // Initialize output parameter.
    //
    if (ppncc)
    {
        *ppncc = NULL;
    }

    // Make an "on behalf of" token for the software.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_SOFTWARE;
    OboToken.pszwManufacturer = pszManufacturer;
    OboToken.pszwProduct      = pszProduct;
    OboToken.pszwDisplayName  = pszDisplayName;

    HRESULT hr = HrInstallComponent (pnc, pnip, &rguid, pszComponentId,
                    &OboToken, ppncc);

    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "HrInstallComponentOboSoftware");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponentOboUser
//
//  Purpose:    Installs a component on behalf of the user.  If the component
//              is already installed, it reference count is incremented on
//              behalf of the user.  This is useful for a component to call
//              when it is installing another component as a convienience for
//              the user.  The user can then remove the component with no
//              ill-effects for the component that called this function.
//
//  Arguments:
//      pnc           [in]  pointer to an INetCfg object.
//      pnip          [in]  (Optional) pointer to network install parameters.
//                          If non-NULL, a network install is performed,
//                          otherwise a normal install is performed.
//      rguid         [in]  class GUID of the component being installed.
//      pszComponentId [in]  component INF id of the component being installed.
//      ppncc         [out] (Optional) set on return to the previously
//                          installed component or the one that was installed.
//
//  Returns:    S_OK or an error.
//
//  Author:     shaunco   7 Apr 1997
//
//  Notes:
//
HRESULT
HrInstallComponentOboUser (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    const GUID&                     rguid,
    PCWSTR                          pszComponentId,
    INetCfgComponent**              ppncc)
{
    Assert (pnc);
    Assert (&rguid);
    Assert (pszComponentId);
    AssertSz (GUID_DEVCLASS_NET != rguid, "Don't use this to install adapters.");

    // Initialize output parameter.
    //
    if (ppncc)
    {
        *ppncc = NULL;
    }

    // Make an "on behalf of" token for the user.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    HRESULT hr = HrInstallComponent (pnc, pnip, &rguid, pszComponentId,
                    &OboToken, ppncc);

    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "HrInstallComponentOboUser");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallRasIfNeeded
//
//  Purpose:    Install RAS services on behalf of the user.  No need to
//              check first as we install on behalf of the user which is
//              implicilty checked.
//
//  Arguments:
//      pnc [in] INetCfg pointer to use
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   30 Aug 1997
//
//  Notes:
//      (shaunco) 10 Sep 1997: Don't install RAS Server for Beta1.
//      DHCP addresses get eaten up too quickly.  For Beta2, it will be
//      installed but disabled.
//
//      (shaunco) 20 Dec 1997: We used to install RAS Server only on NTS.
//      We now install it always but its set to not start automatically.
//
HRESULT
HrInstallRasIfNeeded (
    INetCfg*    pnc)
{
    Assert (pnc);

    static const GUID* c_apguidInstalledComponentClasses [] =
    {
        &GUID_DEVCLASS_NETSERVICE,  // RasCli
        &GUID_DEVCLASS_NETSERVICE,  // RasSrv
    };

    static const PCWSTR c_apszInstalledComponentIds [] =
    {
        c_szInfId_MS_RasCli,
        c_szInfId_MS_RasSrv,
    };

    HRESULT hr = HrInstallComponentsOboUser (pnc, NULL,
                        celems (c_apguidInstalledComponentClasses),
                        c_apguidInstalledComponentClasses,
                        c_apszInstalledComponentIds);

    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "HrInstallRasIfNeeded");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrQueryNotifyObject
//
//  Purpose:    Helper function to call QueryNotifyObject given an
//              INetCfgComponent.  (Saves the intermediate QI.)
//
//  Arguments:
//      pncc      [in]  INetCfgComponent to call QueryNotifyObject on.
//      riid      [in]  Requested interface identifier.
//      ppvObject [out] Address of pointer to return the requested interface.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   2 Sep 1998
//
//  Notes:
//
HRESULT
HrQueryNotifyObject (
    INetCfgComponent*   pncc,
    REFIID              riid,
    VOID**              ppvObject)
{
    Assert (pncc);
    Assert (ppvObject);

    // Initialize the output parameter.
    //
    *ppvObject = NULL;

    // First, QI for the component private interface.
    //
    INetCfgComponentPrivate* pPrivate;
    HRESULT hr = pncc->QueryInterface(
                            IID_INetCfgComponentPrivate,
                            reinterpret_cast<VOID**>(&pPrivate));

    if (SUCCEEDED(hr))
    {
        // Now query the notify object for the requested interface.
        //
        hr = pPrivate->QueryNotifyObject (riid, ppvObject);

        ReleaseObj (pPrivate);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrQueryNotifyObject");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveComponent
//
//  Purpose:    Remove the specified component.
//
//  Arguments:
//      pnc          [in] INetCfg pointer.
//      pnccToRemove [in] Component to remove.
//      pOboToken    [in] (Optional) If specified, remove the component
//                        on behalf of this token.
//      pmszRefs     [out] (Optional) Returns Multi-Sz of components that
//                         still reference this one. NOTE: This will be NULL
//                         if the return value is not
//                         NETCFG_S_STILL_REFERENCED
//
//  Returns:    S_OK, NETCFG_S_STILL_REFERENCED, or an error code.
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
HRESULT
HrRemoveComponent (
    INetCfg*            pnc,
    INetCfgComponent*   pnccToRemove,
    OBO_TOKEN*          pOboToken,
    PWSTR *             pmszRefs)
{
    Assert (pnc);
    Assert (pnccToRemove);

    // Get the class setup interface for this component.
    //
    GUID guidClass;
    HRESULT hr = pnccToRemove->GetClassGuid (&guidClass);
    if (SUCCEEDED(hr))
    {
        // Use the class setup interface to remove the component.
        //
        INetCfgClassSetup* pSetup;
        hr = pnc->QueryNetCfgClass (&guidClass,
                            IID_INetCfgClassSetup,
                            reinterpret_cast<void**>(&pSetup));
        if (SUCCEEDED(hr))
        {
            hr = pSetup->DeInstall (pnccToRemove, pOboToken, pmszRefs);
            ReleaseObj (pSetup);
        }
    }
    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrRemoveComponent");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveComponentOboComponent
//
//  Purpose:    Removes a component previously installed by another.
//              Effectively balances a call to HrInstallComponentOboComponent().
//              The reference count of the component is decremented and,
//              if it is zero, the component is removed from the system.
//
//  Arguments:
//      pnc             [in]  pointer to an INetCfg object.
//      rguidClass      [in]  class GUID of the component being removed.
//      pszComponentId  [in]  component INF id of the component being removed.
//      pnccObo         [in]  the component requesting the removal.
//
//  Returns:    S_OK, NETCFG_S_STILL_REFERENCED or an error.
//
//  Author:     shaunco   7 Apr 1997
//
//  Notes:
//
HRESULT
HrRemoveComponentOboComponent (
    INetCfg*            pnc,
    const GUID&         rguidClass,
    PCWSTR              pszComponentId,
    INetCfgComponent*   pnccObo)
{
    // Make an "on behalf of" token for the requesting component.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_COMPONENT;
    OboToken.pncc = pnccObo;

    HRESULT hr = HrFindAndRemoveComponent (pnc, &rguidClass, pszComponentId,
                    &OboToken);

    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrRemoveComponentOboComponent");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveComponentOboSoftware
//
//  Purpose:    Removes a component previously installed by some software
//              entity. Effectively balances a call to
//              HrAddComponentOboSoftware(). The reference count of the
//              component is decremented and, if it is zero, the component
//              is removed from the system.
//
//  Arguments:
//      pnc              [in] pointer to an INetCfg object.
//      rguidClass       [in] class GUID of the component being removed.
//      pszComponentId   [in] component INF id of the component being removed.
//      pszManufacturer  [in] Manufacturer name of software.
//      pszProduct       [in] Product name of software.
//      pszDisplayName   [in] Full display name of software.
//      pnccObo          [in] the component requesting the removal.
//
//  Returns:    S_OK, NETCFG_S_STILL_REFERENCED or an error.
//
//  Author:     jeffspr     13 Jun 1997
//
//  Notes:
//
HRESULT
HrRemoveComponentOboSoftware (
    INetCfg*    pnc,
    const GUID& rguidClass,
    PCWSTR     pszComponentId,
    PCWSTR     pszManufacturer,
    PCWSTR     pszProduct,
    PCWSTR     pszDisplayName)
{
    // Make an "on behalf of" token for the software.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_SOFTWARE;
    OboToken.pszwManufacturer = pszManufacturer;
    OboToken.pszwProduct      = pszProduct;
    OboToken.pszwDisplayName  = pszDisplayName;

    HRESULT hr = HrFindAndRemoveComponent (pnc, &rguidClass, pszComponentId,
                    &OboToken);

    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrRemoveComponentOboSoftware");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveComponentOboUser
//
//  Purpose:    Removes a component previously installed by the user.
//              Effectively balances a call to HrAddComponentOboUser().
//              The reference count of the component is decremented and,
//              if it is zero, the component is removed from the system.
//
//  Arguments:
//      pnc             [in]  pointer to an INetCfg object.
//      rguidClass      [in]  class GUID of the component being removed.
//      pszComponentId  [in]  component INF id of the component being removed.
//
//  Returns:    S_OK, NETCFG_S_STILL_REFERENCED or an error.
//
//  Author:     shaunco   7 Apr 1997
//
//  Notes:
//
HRESULT
HrRemoveComponentOboUser (
    INetCfg*        pnc,
    const GUID&     rguidClass,
    PCWSTR          pszComponentId)
{
    // Make an "on behalf of" token for the user.
    //
    OBO_TOKEN OboToken;
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    HRESULT hr = HrFindAndRemoveComponent (pnc, &rguidClass, pszComponentId,
                    &OboToken);

    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "HrRemoveComponentOboUser");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetLastComponentAndInterface
//
//  Purpose:    This function enumerates a binding path, returns the last
//              component on the path and optionally return the last binding
//              interface name in this path.
//
//  Arguments:
//      pncbp               [in]    The INetCfgBindingPath *
//      ppncc               [out]   The INetCfgComponent * of the last component on the path
//      ppszInterfaceName   [out]   The interface name of the last binding interface of the path
//
//  Returns:    S_OK, or an error.
//
//  Author:     tongl   5 Dec 1997
//
//  Notes:
//
HRESULT
HrGetLastComponentAndInterface (
    INetCfgBindingPath* pncbp,
    INetCfgComponent** ppncc,
    PWSTR* ppszInterfaceName)
{
    Assert(pncbp);

    // Initialize output parameters.
    //
    *ppncc = NULL;
    if (ppszInterfaceName)
    {
        *ppszInterfaceName = NULL;
    }

    // Enumerate binding interfaces and keep track of
    // the last interface.
    //
    HRESULT hr = S_OK;
    CIterNetCfgBindingInterface ncbiIter(pncbp);
    INetCfgBindingInterface* pncbi;
    INetCfgBindingInterface* pncbiLast = NULL;

    while(SUCCEEDED(hr) && (hr = ncbiIter.HrNext(&pncbi)) == S_OK)
    {
        ReleaseObj (pncbiLast);
        pncbiLast = pncbi;
    }

    if (S_FALSE == hr) // we got to the end of the loop
    {
        hr = S_OK;

        Assert (pncbiLast);

        INetCfgComponent* pnccLowerComponent;
        hr = pncbiLast->GetLowerComponent(&pnccLowerComponent);
        if (S_OK == hr)
        {
            // Get the name of the interface if requested.
            //
            if (ppszInterfaceName)
            {
                hr = pncbiLast->GetName(ppszInterfaceName);
            }

            // If we've succeded everything, (including the optional
            // return of the interface name above) then assign and addref
            // the output interface.
            //
            if (S_OK == hr)
            {
                AddRefObj (pnccLowerComponent);
                *ppncc = pnccLowerComponent;
            }

            // Important to release our use of this interface in case
            // we failed and didn't assign it as an output parameter.
            //
            ReleaseObj (pnccLowerComponent);
        }
    }

    // Don't forget to release the binding interface itself.
    //
    ReleaseObj (pncbiLast);

    TraceHr (ttidError, FAL, hr, FALSE, "HrGetLastComponentAndInterface");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncnetcfg\kkstl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       K K S T L . C P P
//
//  Contents:
//
//  Notes:
//
//  Author:     kumarp
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "kkstl.h"

void FormatTString(IN OUT tstring& str, IN PCWSTR pszFormat, va_list arglist)
{
    const c_dwMaxFormatBufferLen = 511;
    //since there is no way to determine the size of the string
    //after applying the format, we must assume some arbitrary size
    static WCHAR pszTemp[c_dwMaxFormatBufferLen+1];
    _vsnwprintf(pszTemp, c_dwMaxFormatBufferLen, pszFormat, arglist);

    str = pszTemp;
}

void FormatTString(IN OUT tstring& str, IN PCWSTR pszFormat, ...)
{
    va_list arglist;

    va_start (arglist, pszFormat);
    FormatTString(str, pszFormat, arglist);
    va_end(arglist);
}


BOOL FIsInStringList(IN const TStringList& sl, IN tstring& str,
                     OUT TStringListIter* pos)
{
    return FIsInStringList(sl, str.c_str(), pos);
}

BOOL FIsInStringList(IN const TStringList& sl, IN PCWSTR psz,
                     OUT TStringListIter* pos)
{
    TStringListIter i=sl.begin();
    while (i != sl.end())
    {
        if (!_wcsicmp((*i)->c_str(), psz))
        {
            if (pos != NULL)
                *pos = i;
            return TRUE;
        }
        ++i;
    }

    return FALSE;
}

tstring* GetNthItem(IN TStringList& sl, IN DWORD dwIndex)
{
    TStringListIter sli=sl.begin();
    DWORD i;
    for (i=0; i<dwIndex; ++i, ++sli)
        ;
    return *sli;
}


void EraseAndDeleteAll(IN TPtrList& ppl)
{
    EraseAndDeleteAll(&ppl);
}

void EraseAndDeleteAll(IN TPtrList* ppl)
{
    TPtrListIter i=ppl->begin();
    while (i != ppl->end())
    {
        delete *i++;
    }

    ppl->erase(ppl->begin(), ppl->end());
}


void EraseAndDeleteAll(IN TStringList& ppl)
{
    EraseAndDeleteAll(&ppl);
}

void EraseAndDeleteAll(IN TStringList* ppl)
{
    TStringListIter i=ppl->begin();
    while (i != ppl->end())
    {
        delete *i++;
    }

    ppl->erase(ppl->begin(), ppl->end());
}


void GetDataFromByteArray(IN const TByteArray& ba, OUT BYTE*& pb)
{
    DWORD dwSize = ba.size();

    if (dwSize == 0)
    {
        pb = NULL;
        return;
    }

    if (pb == NULL)
    {
        pb = new BYTE[dwSize];
    }

    if(pb) {
        for (DWORD i=0; i < dwSize; i++)
        {
            pb[i] = ba[i];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncnetcfg\ncpnp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C P N P . C P P
//
//  Contents:   Common code for PnP.
//
//  Notes:
//
//  Author:     shaunco   10 Oct 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncbase.h"
#include "ncdebug.h"
#include "ncpnp.h"
#include "ncstring.h"
#include "ncsvc.h"

extern const WCHAR c_szDevice[];


//+---------------------------------------------------------------------------
// Function:    HrSendServicePnpEvent
//
// Purpose:     Send to the service one of the net pnp control codes
//
// Parameters:
//          pszService - the service name to send the notification to
//          dwControl - the control code to send
//
// Returns:     HRESULT  S_OK on success, HrFromLastWin32Error otherwise
//
// Notes:   the following control codes are only allowed
//          SERVICE_CONTROL_PARAMCHANGE
//  Informs the service that service-specific parameters that it reads
//  when it starts have changed, and requests it to re-read its startup
//  parameters from whatever location they are stored in. The hService
//  handle must have SERVICE_CHANGE_PARAM access.
//
//          SERVICE_CONTROL_NETBINDADD
// Informs a network service that a new component has been added to the
// set of components that it should bind to, and requests it to re-read
// its binding information and bind to the new component. The hService
// handle must have SERVICE_CHANGE_PARAM access.
//
//          SERVICE_CONTROL_NETBINDREMOVE
// Informs a network service that a component has been removed from the
// set of components that it should bind to, and requests it to re-read
// its binding information and unbind from the removed component. The
// hService handle must have SERVICE_CHANGE_PARAM access.
//
//          SERVICE_CONTROL_NETBINDENABLE
// Informs a network service that one of its previously disabled bindings
// has been enabled, and requests it to re-read its binding information and
// add the new binding. The hService handle must have SERVICE_CHANGE_PARAM access.
//
//          SERVICE_CONTROL_NETBINDDISABLE
// Informs a network service that one of its bindings has been disabled, and
// requests it to re-read its binding information and unbind the disabled
// binding. The hService handle must have SERVICE_CHANGE_PARAM access.
// (Note: There is nothing network-specific about the Win32 service APIs today.
// This would be the first network-specific thing appearing in the docs.
// I think that's OK.)
//
HRESULT
HrSendServicePnpEvent (
    PCWSTR      pszService,
    DWORD       dwControl )
{
    Assert( pszService && 0 < lstrlen( pszService ) );
    Assert( (dwControl == SERVICE_CONTROL_PARAMCHANGE) ||
            (dwControl == SERVICE_CONTROL_NETBINDADD) ||
            (dwControl == SERVICE_CONTROL_NETBINDREMOVE) ||
            (dwControl == SERVICE_CONTROL_NETBINDENABLE) ||
            (dwControl == SERVICE_CONTROL_NETBINDDISABLE) );

    CServiceManager scm;
    CService service;
    HRESULT hr = scm.HrOpenService(&service, pszService, NO_LOCK, STANDARD_RIGHTS_READ | STANDARD_RIGHTS_WRITE | SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_QUERY_LOCK_STATUS,  STANDARD_RIGHTS_READ | STANDARD_RIGHTS_WRITE | SERVICE_QUERY_CONFIG | SERVICE_CHANGE_CONFIG | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_INTERROGATE | SERVICE_PAUSE_CONTINUE | SERVICE_USER_DEFINED_CONTROL);
    if (S_OK == hr)
    {
        TraceTag(ttidNetCfgPnp,
                "HrSendServicePnpEvent( service- %S, control- %d )",
                pszService,
                dwControl );

        hr = service.HrControl( dwControl );
    }

    TraceError( "HrSendServicePnpEvent", hr );
    return  hr;
}

//+---------------------------------------------------------------------------
// Function:    SetUnicodeString
//
// Purpose:     given a UNICODE_STRING initialize it to the given WSTR
//
// Parameters:
//      pustr - the UNICODE_STRING to initialize
//      psz - the WSTR to use to initialize the UNICODE_STRING
//
// Notes:  This differs from the RtlInitUnicodeString in that the
//      MaximumLength value contains the terminating null
//
void
SetUnicodeString (
    OUT UNICODE_STRING* pustr,
    IN PCWSTR psz )
{
    Assert(pustr);
    Assert(psz);

    pustr->Buffer = const_cast<PWSTR>(psz);
    pustr->Length = wcslen(psz) * sizeof(WCHAR);
    pustr->MaximumLength = pustr->Length + sizeof(WCHAR);
}

//+---------------------------------------------------------------------------
// Function:    SetUnicodeMultiString
//
// Purpose:     given a UNICODE_STRING initialize it to the given WSTR
//              multi string buffer
//
// Parameters:
//      pustr - the UNICODE_STRING to initialize
//      pmsz - the multi sz WSTR to use to initialize the UNICODE_STRING
//
void
SetUnicodeMultiString (
    OUT UNICODE_STRING* pustr,
    IN PCWSTR pmsz )
{
    AssertSz( pustr != NULL, "Invalid Argument" );
    AssertSz( pmsz != NULL, "Invalid Argument" );

    pustr->Buffer = const_cast<PWSTR>(pmsz);

    ULONG cb = CchOfMultiSzAndTermSafe(pustr->Buffer) * sizeof(WCHAR);
    Assert (cb <= USHRT_MAX);
    pustr->Length = (USHORT)cb;

    pustr->MaximumLength = pustr->Length;
}

//+---------------------------------------------------------------------------
// Function:    HrSendNdisHandlePnpEvent
//
// Purpose:     Send to Ndis a HandlePnpEvent notification
//
// Parameters:
//      uiLayer - either NDIS or TDI
//      uiOperation - either BIND, RECONFIGURE, or UNBIND
//      pszUpper - a WIDE string containing the upper component name
//      pszLower - a WIDE string containing the lower component name
//            This is one of the Export names from that component
//            The values NULL and c_szEmpty are both supported
//      pmszBindList - a WIDE string containing the NULL terminiated list of strings
//            representing the bindlist, vaid only for reconfigure
//            The values NULL and c_szEmpty are both supported
//      pvData - Pointer to ndis component notification data. Content
//            determined by each component.
//      dwSizeData - Count of bytes in pvData
//
// Returns:     HRESULT  S_OK on success, HrFromLastWin32Error otherwise
//
// Notes:  Do not use this routine directly, see...
//                  HrSendNdisPnpBindOrderChange,
//                  HrSendNdisPnpReconfig
//
HRESULT
HrSendNdisHandlePnpEvent (
    UINT        uiLayer,
    UINT        uiOperation,
    PCWSTR      pszUpper,
    PCWSTR      pszLower,
    PCWSTR      pmszBindList,
    PVOID       pvData,
    DWORD       dwSizeData)
{
    UNICODE_STRING    umstrBindList;
    UNICODE_STRING    ustrLower;
    UNICODE_STRING    ustrUpper;
    UINT nRet;
    HRESULT hr = S_OK;

    Assert(NULL != pszUpper);
    Assert((NDIS == uiLayer)||(TDI == uiLayer));
    Assert( (BIND == uiOperation) || (RECONFIGURE == uiOperation) ||
            (UNBIND == uiOperation) || (UNLOAD == uiOperation) ||
            (REMOVE_DEVICE == uiOperation));
    AssertSz( FImplies( ((NULL != pmszBindList) && (0 != lstrlenW( pmszBindList ))),
            (RECONFIGURE == uiOperation) &&
            (TDI == uiLayer) &&
            (0 == lstrlenW( pszLower ))),
            "bind order change requires a bind list, no lower, only for TDI, "
            "and with Reconfig for the operation" );

    // optional strings must be sent as empty strings
    //
    if (NULL == pszLower)
    {
        pszLower = c_szEmpty;
    }
    if (NULL == pmszBindList)
    {
        pmszBindList = c_szEmpty;
    }

    // build UNICDOE_STRINGs
    SetUnicodeMultiString( &umstrBindList, pmszBindList );
    SetUnicodeString( &ustrUpper, pszUpper );
    SetUnicodeString( &ustrLower, pszLower );

    TraceTag(ttidNetCfgPnp,
                "HrSendNdisHandlePnpEvent( layer- %d, op- %d, upper- %S, lower- %S, &bindlist- %08lx, &data- %08lx, sizedata- %d )",
                uiLayer,
                uiOperation,
                pszUpper,
                pszLower,
                pmszBindList,
                pvData,
                dwSizeData );

    // Now submit the notification
    nRet = NdisHandlePnPEvent( uiLayer,
            uiOperation,
            &ustrLower,
            &ustrUpper,
            &umstrBindList,
            (PVOID)pvData,
            dwSizeData );
    if (!nRet)
    {
        hr = HrFromLastWin32Error();

        // If the transport is not started, ERROR_FILE_NOT_FOUND is expected
        // when the NDIS layer is notified.  If the components of the TDI
        // layer aren't started, we get ERROR_GEN_FAILURE.  We need to map
        // these to one consistent error

        if ((HRESULT_FROM_WIN32(ERROR_GEN_FAILURE) == hr) && (TDI == uiLayer))
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
    }

    TraceError( "HrSendNdisHandlePnpEvent",
            HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr ? S_OK : hr );
    return hr;
}

//+---------------------------------------------------------------------------
// Function:    HrSendNdisPnpReconfig
//
// Purpose:     Send to Ndis a HandlePnpEvent reconfig notification
//
// Parameters:  uiLayer - either NDIS or TDI
//              pszUpper - a WIDE string containing the upper component name
//                         (typically a protocol)
//              pszLower - a WIDE string containing the lower component name
//                         (typically an adapter bindname) The values NULL and
//                         c_szEmpty are both supported
//              pvData - Pointer to ndis component notification data. Content
//                       determined by each component.
//              dwSizeData - Count of bytes in pvData
//
// Returns:     HRESULT  S_OK on success, HrFromLastWin32Error otherwise
//
HRESULT
HrSendNdisPnpReconfig (
    UINT        uiLayer,
    PCWSTR      pszUpper,
    PCWSTR      pszLower,
    PVOID       pvData,
    DWORD       dwSizeData)
{
    Assert(NULL != pszUpper);
    Assert((NDIS == uiLayer) || (TDI == uiLayer));

    HRESULT hr;
    tstring strLower;

    // If a lower component is specified, prefix with "\Device\" else
    // strLower's default of an empty string will be used.
    if (pszLower && *pszLower)
    {
        strLower = c_szDevice;
        strLower += pszLower;
    }

    hr = HrSendNdisHandlePnpEvent(
                uiLayer,
                RECONFIGURE,
                pszUpper,
                strLower.c_str(),
                c_szEmpty,
                pvData,
                dwSizeData);

    TraceError("HrSendNdisPnpReconfig",
              (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ? S_OK : hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncnetcfg\ncnetcfg2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C N E T C F G . C P P
//
//  Contents:   Common routines for dealing with INetCfg interfaces.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncbase.h"
#include "ncdebug.h"
#include "ncnetcfg.h"
#include "netcfgx.h"


//+---------------------------------------------------------------------------
//
//  Function:   HrCreateAndInitializeINetCfg
//
//  Purpose:    Cocreate and initialize the root INetCfg object.  This will
//              optionally initialize COM for the caller too.
//
//  Arguments:
//      pfInitCom       [in,out]   TRUE to call CoInitialize before creating.
//                                 returns TRUE if COM was successfully
//                                 initialized FALSE if not.  If NULL, means
//                                 don't initialize COM.
//      ppnc            [out]  The returned INetCfg object.
//      fGetWriteLock   [in]   TRUE if a writable INetCfg is needed
//      cmsTimeout      [in]   See INetCfg::AcquireWriteLock
//      pszClientDesc   [in]   See INetCfg::AcquireWriteLock
//      ppszClientDesc  [out]  See INetCfg::AcquireWriteLock
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:
//
HRESULT
HrCreateAndInitializeINetCfg (
    BOOL*       pfInitCom,
    INetCfg**   ppnc,
    BOOL        fGetWriteLock,
    DWORD       cmsTimeout,
    PCWSTR      pszClientDesc,
    PWSTR*      ppszClientDesc)
{
    Assert (ppnc);

    // Initialize the output parameters.
    *ppnc = NULL;

    if (ppszClientDesc)
    {
        *ppszClientDesc = NULL;
    }

    // Initialize COM if the caller requested.
    HRESULT hr = S_OK;
    if (pfInitCom && *pfInitCom)
    {
        hr = CoInitializeEx( NULL,
                COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
            *pfInitCom = FALSE;
        }
    }
    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;

        hr = CoCreateInstance(
                CLSID_CNetCfg,
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                IID_INetCfg,
                reinterpret_cast<void**>(&pnc));

        if (SUCCEEDED(hr))
        {
            INetCfgLock * pnclock = NULL;
            if (fGetWriteLock)
            {
                // Get the locking interface
                hr = pnc->QueryInterface(IID_INetCfgLock,
                                         reinterpret_cast<LPVOID *>(&pnclock));
                if (SUCCEEDED(hr))
                {
                    // Attempt to lock the INetCfg for read/write
                    hr = pnclock->AcquireWriteLock(cmsTimeout, pszClientDesc,
                                               ppszClientDesc);
                    if (S_FALSE == hr)
                    {
                        // Couldn't acquire the lock
                        hr = NETCFG_E_NO_WRITE_LOCK;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Initialize the INetCfg object.
                //
                hr = pnc->Initialize (NULL);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    AddRefObj (pnc);
                }
                else
                {
                    if (pnclock)
                    {
                        pnclock->ReleaseWriteLock();
                    }
                }
                // Transfer reference to caller.
            }
            ReleaseObj(pnclock);

            ReleaseObj(pnc);
        }

        // If we failed anything above, and we've initialized COM,
        // be sure an uninitialize it.
        //
        if (FAILED(hr) && pfInitCom && *pfInitCom)
        {
            CoUninitialize ();
        }
    }
    TraceError("HrCreateAndInitializeINetCfg", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndReleaseINetCfg
//
//  Purpose:    Unintialize and release an INetCfg object.  This will
//              optionally uninitialize COM for the caller too.
//
//  Arguments:
//      fUninitCom [in] TRUE to uninitialize COM after the INetCfg is
//                      uninitialized and released.
//      pnc        [in] The INetCfg object.
//      fHasLock   [in] TRUE if the INetCfg was locked for write and
//                          must be unlocked.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:      The return value is the value returned from
//              INetCfg::Uninitialize.  Even if this fails, the INetCfg
//              is still released.  Therefore, the return value is for
//              informational purposes only.  You can't touch the INetCfg
//              object after this call returns.
//
HRESULT
HrUninitializeAndReleaseINetCfg (
    BOOL        fUninitCom,
    INetCfg*    pnc,
    BOOL        fHasLock)
{
    Assert (pnc);
    HRESULT hr = S_OK;

    if (fHasLock)
    {
        hr = HrUninitializeAndUnlockINetCfg(pnc);
    }
    else
    {
        hr = pnc->Uninitialize ();
    }

    ReleaseObj (pnc);

    if (fUninitCom)
    {
        CoUninitialize ();
    }
    TraceError("HrUninitializeAndReleaseINetCfg", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndUnlockINetCfg
//
//  Purpose:    Uninitializes and unlocks the INetCfg object
//
//  Arguments:
//      pnc [in]    INetCfg to uninitialize and unlock
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   13 Nov 1997
//
//  Notes:
//
HRESULT
HrUninitializeAndUnlockINetCfg (
    INetCfg*    pnc)
{
    HRESULT     hr = S_OK;

    hr = pnc->Uninitialize();
    if (SUCCEEDED(hr))
    {
        INetCfgLock *   pnclock;

        // Get the locking interface
        hr = pnc->QueryInterface(IID_INetCfgLock,
                                 reinterpret_cast<LPVOID *>(&pnclock));
        if (SUCCEEDED(hr))
        {
            // Attempt to lock the INetCfg for read/write
            hr = pnclock->ReleaseWriteLock();

            ReleaseObj(pnclock);
        }
    }

    TraceError("HrUninitializeAndUnlockINetCfg", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsLanCapableAdapter
//
//  Purpose:    Returns whether the given component (adapter) is capable of
//              being associated with a LAN connection
//
//  Arguments:
//      pncc [in]   Component to test
//
//  Returns:    S_OK if it is capable, S_FALSE if not, OLE or Win32 error code
//              otherwise
//
//  Author:     danielwe   13 Nov 1997
//
//  Notes:
//
HRESULT
HrIsLanCapableAdapter (
    INetCfgComponent*   pncc)
{
    Assert(pncc);

    INetCfgComponentBindings*  pnccb;
    HRESULT hr = pncc->QueryInterface(IID_INetCfgComponentBindings,
                              reinterpret_cast<LPVOID *>(&pnccb));
    if (S_OK == hr)
    {
        // Does it have ndis4?...
        extern const WCHAR c_szBiNdis4[];
        hr = pnccb->SupportsBindingInterface(NCF_UPPER, c_szBiNdis4);
        if (S_FALSE == hr)
        {
            // ... no.. how about ndisatm?
            extern const WCHAR c_szBiNdisAtm[];
            hr = pnccb->SupportsBindingInterface(NCF_UPPER, c_szBiNdisAtm);
            if (S_FALSE == hr)
            {
                // .. let's try ndis5 then
                extern const WCHAR c_szBiNdis5[];
                hr = pnccb->SupportsBindingInterface(NCF_UPPER, c_szBiNdis5);
                if (S_FALSE == hr)
                {
                    // .. let's try ndis5_ip then
                    extern const WCHAR c_szBiNdis5Ip[];
                    hr = pnccb->SupportsBindingInterface(NCF_UPPER, c_szBiNdis5Ip);
                    if (S_FALSE == hr)
                    {
                        // .. let's try LocalTalk then (this is an adapters lower interface)
                        extern const WCHAR c_szBiLocalTalk[];
                        hr = pnccb->SupportsBindingInterface(NCF_LOWER, c_szBiLocalTalk);

                        // ... no.. how about ndis1394?
                        if (S_FALSE == hr)
                        {
                            extern const WCHAR c_szBiNdis1394[];
                            hr = pnccb->SupportsBindingInterface(NCF_UPPER,
                                                             c_szBiNdis1394);
                        }
                    }
                }
            }
        }

        ReleaseObj(pnccb);
    }

    TraceError("HrIsLanCapableAdapter", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsLanCapableProtocol
//
//  Purpose:    Returns whether the given component (protocol) is capable of
//              being associated with a LAN connection
//
//  Arguments:
//      pncc [in]   Component to test
//
//  Returns:    S_OK if it is capable, S_FALSE if not, OLE or Win32 error code
//              otherwise
//
//  Author:     danielwe   13 Nov 1997
//
//  Notes:
//
HRESULT
HrIsLanCapableProtocol (
    INetCfgComponent*   pncc)
{
    Assert(pncc);

    INetCfgComponentBindings*  pnccb;
    HRESULT hr = pncc->QueryInterface(IID_INetCfgComponentBindings,
                              reinterpret_cast<LPVOID *>(&pnccb));
    if (S_OK == hr)
    {
        // Does it have ndis4?...
        extern const WCHAR c_szBiNdis4[];
        hr = pnccb->SupportsBindingInterface(NCF_LOWER, c_szBiNdis4);
        if (S_FALSE == hr)
        {
            // ... no.. how about ndisatm?
            extern const WCHAR c_szBiNdisAtm[];
            hr = pnccb->SupportsBindingInterface(NCF_LOWER, c_szBiNdisAtm);
            if (S_FALSE == hr)
            {
                // .. let's try ndis5 then
                extern const WCHAR c_szBiNdis5[];
                hr = pnccb->SupportsBindingInterface(NCF_LOWER, c_szBiNdis5);
                if (S_FALSE == hr)
                {
                    // .. let's try ndis5_ip then
                    extern const WCHAR c_szBiNdis5Ip[];
                    hr = pnccb->SupportsBindingInterface(NCF_LOWER, c_szBiNdis5Ip);
                }
            }
        }

        ReleaseObj(pnccb);
    }

    // Raid 147474 : NDISUIO: No warning when you uninstall all the protocols.
    // mbend 7/20/2000
    //
    // Don't consider a hidden protocol a valid Lanui protocol.
    if(S_OK == hr)
    {
        DWORD dwChar = 0;
        hr = pncc->GetCharacteristics(&dwChar);
        if(SUCCEEDED(hr))
        {
            if(NCF_HIDDEN & dwChar)
            {
                hr = S_FALSE;
            }
        }
    }

    TraceError("HrIsLanCapableAdapter", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncnetcfg\kkreg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       K K R E G . C P P
//
//  Contents:   Windows NT Registry Access Class
//
//  Notes:
//
//  Author:     kumarp    14 April 97 (09:22:00 pm)
//
//  Notes:
//    kumarp   1/16/97   most of the code in this file was originally in
//                       net\ui\rhino\common\classes\common.h
//                       extracted only that portion related to CRegKey & related classes
//    kumarp   3/27/97   the original code used MFC. converted the entire code
//                       to make it use STL
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "kkreg.h"
#include "kkstl.h"
#include "kkutils.h"
#include "nceh.h"
#include "ncreg.h"

HRESULT HrGetRegErrorForTrace(LONG err)
{
    HRESULT hr = ((err == ERROR_FILE_NOT_FOUND) ||
                  (err == ERROR_NO_MORE_ITEMS))
        ? S_OK : HRESULT_FROM_WIN32(err);

    return hr;
}

#define TraceRegFunctionError(e)  TraceFunctionError(HrGetRegErrorForTrace(e))

//+---------------------------------------------------------------------------
//
//  Member:     CORegKey::CORegKey
//
//  Purpose:    constructor for an existing key
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
CORegKey::CORegKey (HKEY hKeyBase,
                    PCWSTR pchSubKey,
                    REGSAM regSam,
                    PCWSTR pchServerName )
    : m_hKey( NULL ),
      m_dwDisposition( 0 ),
      m_fInherit(FALSE)
{
    DefineFunctionName("CORegKey::CORegKey(HKEY hKeyBase, PCWSTR pchSubKey, )");

    HKEY hkBase = NULL ;
    LONG err = 0 ;

    if ( pchServerName )
    {
        // This is a remote connection.
        if ( err = ::RegConnectRegistry( (PWSTR) pchServerName,
                                         hKeyBase, & hkBase ) )
        {
            TraceLastWin32Error("RegConnectRegistry failed");
            hkBase = NULL ;
        }
    }
    else
    {
        hkBase = hKeyBase ;
    }

    if ( err == 0 )
    {
        if ( pchSubKey )
        {
            err = ::RegOpenKeyEx( hkBase, pchSubKey, 0, regSam, & m_hKey ) ;
            /*
            if (err)
            {
                TraceLastWin32Error("RegOpenKeyEx failed");
            }
            */
        }
        else
        {
            m_hKey = hkBase ;
            hkBase = NULL ;
            m_fInherit = TRUE;
        }

        if ( hkBase && hkBase != hKeyBase )
        {
            ::RegCloseKey( hkBase ) ;
        }
    }

    if ( err )
    {
        // ReportError( err ) ;
        m_hKey = NULL ;
    }

    TraceRegFunctionError(err);
}

//+---------------------------------------------------------------------------
//
//  Member:     CORegKey::CORegKey
//
//  Purpose:    constructor for creating a new key
//
//  Arguments:  none
//
//  Author:     kumarp    12 April 97 (05:53:03 pm)
//
//  Notes:
//
CORegKey::CORegKey (PCWSTR pchSubKey,
                    HKEY hKeyBase,
                    DWORD dwOptions,
                    REGSAM regSam,
                    LPSECURITY_ATTRIBUTES pSecAttr,
                    PCWSTR pchServerName)
    : m_hKey( NULL ),
      m_dwDisposition( 0 ),
      m_fInherit(FALSE)
{
    DefineFunctionName("CORegKey::CORegKey(PCWSTR pchSubKey, HKEY hKeyBase, )");

    HKEY hkBase = NULL ;
    LONG err = 0;

    if ( pchServerName )
    {
        // This is a remote connection.
        if ( err = ::RegConnectRegistry( (PWSTR) pchServerName,
                                         hKeyBase, & hkBase ) )
        {
            hkBase = NULL ;
            TraceLastWin32Error("RegConnectRegistry failed");
        }

        hkBase = NULL ;

    }
    else
    {
        hkBase = hKeyBase ;
    }

    if (err == 0)
    {

        PCWSTR szEmpty = L"" ;

        err = ::RegCreateKeyEx( hkBase, pchSubKey,
                                0, (PWSTR) szEmpty,
                                dwOptions, regSam,  pSecAttr,
                                & m_hKey,
                                & m_dwDisposition ) ;

    }
    if ( err )
    {
        TraceLastWin32Error("RegCreateKeyEx failed");
        m_hKey = NULL ;
    }

    TraceRegFunctionError(err);
}


CORegKey::~CORegKey ()
{
    if ( m_hKey && !m_fInherit)
    {
        ::RegCloseKey( m_hKey ) ;
    }
}


    //  Prepare to read a value by finding the value's size.
LONG CORegKey::PrepareValue (PCWSTR pchValueName,
                             DWORD * pdwType,
                             DWORD * pcbSize,
                             BYTE ** ppbData )
{
    DefineFunctionName("CORegKey::PrepareValue");

    LONG err = 0 ;

    BYTE chDummy[2] ;
    DWORD cbData = 0 ;

    do
    {
        //  Set the resulting buffer size to 0.
        *pcbSize = 0 ;
        *ppbData = NULL ;

        err = ::RegQueryValueExW( *this,
                      (PWSTR) pchValueName,
                      0, pdwType,
                      chDummy, & cbData ) ;

        //  The only error we should get here is ERROR_MORE_DATA, but
        //  we may get no error if the value has no data.
        if ( err == 0 )
        {
            cbData = sizeof (LONG) ;  //  Just a fudgy number
        }
        else
            if ( err != ERROR_MORE_DATA )
                break ;

        //  Allocate a buffer large enough for the data.

        *ppbData = new BYTE [ (*pcbSize = cbData) + sizeof (LONG) ] ;

        if ( *ppbData == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        //  Now that have a buffer, re-fetch the value.

        err = ::RegQueryValueExW( *this,
                         (PWSTR) pchValueName,
                     0, pdwType,
                     *ppbData, pcbSize ) ;

    } while ( FALSE ) ;

    if ( err )
    {
        delete [] *ppbData ;
    }

    TraceRegFunctionError(err);

    return err ;
}

    //  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
    //  if data exists but not in correct form to deliver into result object.

LONG CORegKey::QueryValue ( PCWSTR pchValueName, tstring& strResult )
{
    DefineFunctionName("CORegKey::QueryValue(tstring& strResult)");

    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    //  strResult.remove();
    strResult = c_szEmpty;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;

        if (( dwType != REG_SZ ) && (dwType != REG_EXPAND_SZ))
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Guarantee that the data looks like a string
        pabData[cbData] = 0 ;

        NC_TRY
        {
            strResult = (PWSTR) pabData ;
        }
        NC_CATCH_ALL
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
    }
    while ( FALSE ) ;

    delete [] pabData ;

    TraceRegFunctionError(err);

    return err ;
}

LONG CORegKey::QueryValue ( PCWSTR pchValueName, TStringList& strList )
{
    DefineFunctionName("CORegKey::QueryValue(TStringList& strList)");

    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;
    PWSTR pbTemp, pbTempLimit ;

    EraseAndDeleteAll(&strList);
    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;

        if ( dwType != REG_MULTI_SZ )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Guarantee that the trailing data looks like a string
        pabData[cbData] = 0 ;
        pbTemp = (PWSTR) pabData ;
    //kumarp: changed the following because it gives wrong results for UNICODE
    //        pbTempLimit = & pbTemp[cbData] ;
        pbTempLimit = & pbTemp[(cbData / sizeof(WCHAR))-1] ;

        //  Catch exceptions trying to build the list
        NC_TRY
        {

            for ( ; pbTemp < pbTempLimit ; )
            {
                // Raid 237766
                if (pbTemp && wcslen(pbTemp))
                {
                    strList.insert(strList.end(), new tstring(pbTemp) ) ;
                }
                pbTemp += wcslen( pbTemp ) + 1 ;
            }
        }
        NC_CATCH_ALL
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }

    }
    while ( FALSE ) ;

    delete [] pabData ;

    TraceRegFunctionError(err);

    return err ;
}

LONG CORegKey::QueryValue ( PCWSTR pchValueName, DWORD& dwResult )
{
    DefineFunctionName("CORegKey::QueryValue(DWORD& dwResult)");

    LONG err = 0;

    DWORD dwData;

    if (m_hKey && (S_OK == HrRegQueryDword(m_hKey, pchValueName, &dwData)))
    {
        dwResult = dwData;
    }
    else
    {
        err = ERROR_FILE_NOT_FOUND;
        dwResult = -1;
    }

    TraceRegFunctionError(err);

    return err ;
}

LONG CORegKey::QueryValue ( PCWSTR pchValueName, TByteArray& abResult )
{
    DefineFunctionName("CORegKey::QueryValue(TByteArray& abResult)");

    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;

        if ( dwType != REG_BINARY )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //  Catch exceptions trying to grow the result array
        NC_TRY
        {
            abResult.reserve( cbData ) ;
        }
        NC_CATCH_ALL
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }


        if ( err )
            break ;

        //  Move the data to the result array.
        for ( DWORD i = 0 ; i < cbData ; i++ )
        {
            //            abResult[i] = pabData[i] ;
            abResult.push_back(pabData[i]) ;
        }
    }
    while ( FALSE ) ;

    delete [] pabData ;

    TraceRegFunctionError(err);

    return err ;
}

LONG CORegKey::QueryValue ( PCWSTR pchValueName, void* pvResult, DWORD cbSize )
{
    DefineFunctionName("CORegKey::QueryValue(void* pvResult, DWORD cbSize)");

    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
            break ;

        if ( dwType != REG_BINARY )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        if ( cbSize < cbData )
        {
            err = ERROR_MORE_DATA;
            break;
        }

        ::memcpy(pvResult, pabData, cbData);
    }
    while ( FALSE ) ;

    delete [] pabData ;

    TraceRegFunctionError(err);

    return err ;
}


//  Overloaded value setting members.
LONG CORegKey::SetValue ( PCWSTR pchValueName, tstring& strResult )
{
    DefineFunctionName("CORegKey::SetValue(tstring& strResult)");

    LONG err = 0;

    err = ::RegSetValueEx( *this,
                           pchValueName,
                           0,
                           REG_SZ,
                           (const BYTE *) strResult.c_str(),
                           CbOfSzAndTerm (strResult.c_str())) ;

    TraceRegFunctionError(err);

    return err ;
}

//  Overloaded value setting members.
LONG CORegKey::SetValue ( PCWSTR pchValueName, tstring& strResult ,
                           BOOL fRegExpand)
{
    LONG err = 0;
    DWORD dwType = fRegExpand ? REG_EXPAND_SZ : REG_SZ;

    err = ::RegSetValueEx( *this,
                    pchValueName,
                    0,
                    dwType,
                    (const BYTE *) strResult.c_str(),
                    CbOfSzAndTerm (strResult.c_str()));

    return err ;
}

LONG CORegKey::SetValue ( PCWSTR pchValueName, TStringList& strList )
{
    DefineFunctionName("CORegKey::SetValue(TStringList& strList)");


    LONG err = 0;

    DWORD cbSize ;
    BYTE * pbData = NULL ;

    err = FlattenValue( strList, & cbSize, & pbData ) ;

    if ( err == 0 )
    {
        err = ::RegSetValueEx( *this,
                       pchValueName,
                       0,
                       REG_MULTI_SZ,
                       pbData,
                       cbSize ) ;
    }

    delete pbData ;

    TraceRegFunctionError(err);

    return err ;
}

LONG CORegKey::SetValue ( PCWSTR pchValueName, DWORD& dwResult )
{
    DefineFunctionName("CORegKey::SetValue(DWORD& dwResult)");

    LONG err = 0;

    err = ::RegSetValueEx( *this,
                    pchValueName,
                    0,
                    REG_DWORD,
                    (const BYTE *) & dwResult,
                    sizeof dwResult ) ;

    TraceRegFunctionError(err);

    return err ;
}

LONG CORegKey::SetValue ( PCWSTR pchValueName, TByteArray& abResult )
{
    DefineFunctionName("CORegKey::SetValue(TByteArray& abResult)");


    LONG err = 0;

    DWORD cbSize ;
    BYTE * pbData = NULL ;

    err = FlattenValue( abResult, & cbSize, & pbData ) ;

    if ( err == 0 )
    {
        err = ::RegSetValueEx( *this,
                       pchValueName,
                       0,
                       REG_BINARY,
                       pbData,
                       cbSize ) ;
    }

    delete pbData ;

    TraceRegFunctionError(err);

    return err ;
}

LONG CORegKey::SetValue ( PCWSTR pchValueName, void* pvResult, DWORD cbSize )
{
    DefineFunctionName("CORegKey::SetValue(void* pvResult, DWORD cbSize)");


    LONG err = 0;

    err = ::RegSetValueEx( *this,
                       pchValueName,
                       0,
                       REG_BINARY,
                       (const BYTE *)pvResult,
                       cbSize ) ;

    TraceRegFunctionError(err);

    return err ;
}


LONG CORegKey::DeleteValue ( PCWSTR pchValueName )
{
    DefineFunctionName("CORegKey::DeleteValue");

    LONG err = ::RegDeleteValue(m_hKey, pchValueName);

    TraceRegFunctionError(err);

    return err;
}


LONG CORegKey::FlattenValue (TStringList & strList,
                             DWORD * pcbSize,
                             BYTE ** ppbData )
{
    Assert(pcbSize);
    Assert(ppbData);
    DefineFunctionName("CORegKey::FlattenValue(TStringList)");


    LONG err = ERROR_NOT_ENOUGH_MEMORY ;

    TStringListIter pos ;
    tstring* pstr ;
    int cbTotal = 0 ;

    *ppbData = NULL;

    //  Walk the list accumulating sizes
    for ( pos = strList.begin() ;
          pos != strList.end() && (pstr = (tstring *) *pos++); )
    {
        cbTotal += CbOfSzAndTerm (pstr->c_str());
    }

    //  Allocate and fill a temporary buffer
    if (*pcbSize = cbTotal)
    {
        BYTE * pbData = new BYTE[ *pcbSize ] ;
        if(pbData) 
        {
            //  Populate the buffer with the strings.
            for ( pos = strList.begin() ;
                pos != strList.end() && (pstr = (tstring *) *pos++); )
            {
                int cb = CbOfSzAndTerm (pstr->c_str());
                ::memcpy( pbData, pstr->c_str(), cb ) ;
                pbData += cb ;
            }
            err = NOERROR;
            *ppbData = pbData;
        }
    }

    TraceRegFunctionError(err);

    return err ;
}

LONG CORegKey::FlattenValue (TByteArray & abData,
                             DWORD * pcbSize,
                             BYTE ** ppbData )
{
    Assert(pcbSize);
    Assert(ppbData);

    DefineFunctionName("CORegKey::FlattenValue(TByteArray)");

    LONG err = ERROR_NOT_ENOUGH_MEMORY ;

    DWORD i ;

    *ppbData = NULL;

    //  Allocate and fill a temporary buffer
    if (*pcbSize = abData.size())
    {
        *ppbData = new BYTE[*pcbSize] ;

        if(*ppbData) 
        {
            for ( i = 0 ; i < *pcbSize ; i++ )
            {
                (*ppbData)[i] = abData[i] ;
            }
        }

        err = NOERROR;
    }

    TraceRegFunctionError(err);

    return err ;
}


LONG CORegKey::QueryKeyInfo ( CORegKEY_KEY_INFO * pRegKeyInfo )
{
    DefineFunctionName("CORegKey::QueryKeyInfo");

    LONG err = 0 ;

    pRegKeyInfo->dwClassNameSize = sizeof pRegKeyInfo->chBuff - 1 ;

    err = ::RegQueryInfoKeyW( *this,
                     pRegKeyInfo->chBuff,
                     & pRegKeyInfo->dwClassNameSize,
                     NULL,
                     & pRegKeyInfo->dwNumSubKeys,
                     & pRegKeyInfo->dwMaxSubKey,
                     & pRegKeyInfo->dwMaxClass,
                     & pRegKeyInfo->dwMaxValues,
                     & pRegKeyInfo->dwMaxValueName,
                     & pRegKeyInfo->dwMaxValueData,
                     & pRegKeyInfo->dwSecDesc,
                     & pRegKeyInfo->ftKey ) ;

    TraceRegFunctionError(err);

    return err ;
}

CORegKeyIter::CORegKeyIter ( CORegKey & regKey )
    : m_rk_iter( regKey ),
      m_p_buffer( NULL ),
      m_cb_buffer( 0 )
{
    DefineFunctionName("CORegKeyIter::CORegKeyIter");

    LONG err = 0 ;

    CORegKey::CORegKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if ( err == 0 )
    {
        NC_TRY
        {
            m_cb_buffer = regKeyInfo.dwMaxSubKey + sizeof (DWORD) ;
            m_p_buffer = new WCHAR [ m_cb_buffer ] ;
        }
        NC_CATCH_ALL
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }

    }

    TraceRegFunctionError(err);
}

CORegKeyIter::~CORegKeyIter ()
{
    delete [] m_p_buffer ;
}


LONG CORegKeyIter::Next ( tstring * pstrName )
{
    DefineFunctionName("CORegKeyIter::Next");

    LONG err = 0;

    FILETIME ftDummy ;
    DWORD dwNameSize = m_cb_buffer ;

    err = ::RegEnumKeyEx( m_rk_iter,
                  m_dw_index,
              m_p_buffer,
                  & dwNameSize,
                  NULL,
                  NULL,
                  NULL,
                  & ftDummy ) ;
    if ( err == 0 )
    {
        m_dw_index++ ;

        NC_TRY
        {
            *pstrName = m_p_buffer ;
        }
        NC_CATCH_ALL
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }

    }

    TraceRegFunctionError(err);

    return err ;
}


CORegValueIter::CORegValueIter ( CORegKey & regKey )
    : m_rk_iter( regKey ),
    m_p_buffer( NULL ),
    m_cb_buffer( 0 )
{
    DefineFunctionName("CORegValueIter::CORegValueIter");

    LONG err = 0 ;

    CORegKey::CORegKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if ( err == 0 )
    {
        NC_TRY
        {
            m_cb_buffer = regKeyInfo.dwMaxValueName + sizeof (DWORD) ;
            m_p_buffer = new WCHAR [ m_cb_buffer ] ;
        }
        NC_CATCH_ALL
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }

    }

    TraceRegFunctionError(err);
}

CORegValueIter::~CORegValueIter ()
{
    delete [] m_p_buffer ;
}

LONG CORegValueIter::Next ( tstring * pstrName, DWORD * pdwType )
{
    DefineFunctionName("CORegValueIter::Next");

    LONG err = 0 ;

    DWORD dwNameLength = m_cb_buffer ;

    err = ::RegEnumValue( m_rk_iter,
                  m_dw_index,
                  m_p_buffer,
                  & dwNameLength,
                  NULL,
                  pdwType,
                  NULL,
                  NULL ) ;

    if ( err == 0 )
    {
        m_dw_index++ ;

        NC_TRY
        {
            *pstrName = m_p_buffer ;
        }
        NC_CATCH_ALL
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
    }

    TraceRegFunctionError(err);
    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncnetcfg\kkutils.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       K K U T I L S . C P P
//
//  Contents:   Misc. helper functions
//
//  Notes:
//
//  Author:     kumarp   14 Jan 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "kkutils.h"
#include "ncreg.h"

extern const WCHAR c_szRegKeyServices[];

// ----------------------------------------------------------------------
//
// Function:  AddOnlyOnceToStringList
//
// Purpose:   Add the specified string to the list if it is not present
//            in that list
//
// Arguments:
//    psl       [in]  list of strings
//    pszString [in]  string to add
//
// Returns:   None
//
// Author:    kumarp 23-December-97
//
// Notes:
//
void AddOnlyOnceToStringList(IN TStringList* psl, IN PCWSTR pszString)
{
    AssertValidReadPtr(psl);
    AssertValidReadPtr(pszString);

    if (!FIsInStringList(*psl, pszString))
    {
        AddAtEndOfStringList(*psl, pszString);
    }
}

// ----------------------------------------------------------------------
//
// Function:  ConvertDelimitedListToStringList
//
// Purpose:   Convert a delimited list to a TStringList
//
// Arguments:
//    strDelimitedList [in]  delimited list
//    chDelimiter      [in]  delimiter
//    slList           [out] list of string items
//
// Returns:   None
//
// Author:    kumarp 23-December-97
//
// Notes:
//
void ConvertDelimitedListToStringList(IN const tstring& strDelimitedList,
                                      IN WCHAR chDelimiter,
                                      OUT TStringList &slList)
{
    PCWSTR pszDelimitedList = strDelimitedList.c_str();
    DWORD i=0, dwStart;

    // should this be EraseAndDeleteAll() ??
    //EraseAll(&slList);
	EraseAndDeleteAll(&slList);
    tstring strTemp;
    DWORD dwNumChars;

    // the two spaces are intentional
    static WCHAR szCharsToSkip[] = L"  \t";
    szCharsToSkip[0] = chDelimiter;

    while (pszDelimitedList[i])
    {
        dwStart = i;
        while (pszDelimitedList[i] &&
               !wcschr(szCharsToSkip, pszDelimitedList[i]))
        {
            ++i;
        }

        // if each item is enclosed in quotes. strip the quotes
        dwNumChars = i - dwStart;
        if (pszDelimitedList[dwStart] == '"')
        {
            dwStart++;
            dwNumChars -= 2;
        }

        strTemp = strDelimitedList.substr(dwStart, dwNumChars);
        slList.insert(slList.end(), new tstring(strTemp));

        // skip spaces and delimiter
        //
        while (pszDelimitedList[i] &&
               wcschr(szCharsToSkip, pszDelimitedList[i]))
        {
            ++i;
        }
    }
}


// ----------------------------------------------------------------------
//
// Function:  ConvertCommaDelimitedListToStringList
//
// Purpose:   Convert a comma delimited list to a TStringList
//
// Arguments:
//    strDelimitedList [in]  comma delimited list
//    slList           [out] list of string items
//
// Returns:   None
//
// Author:    kumarp 23-December-97
//
// Notes:
//
void ConvertCommaDelimitedListToStringList(IN const tstring& strDelimitedList, OUT TStringList &slList)
{
    ConvertDelimitedListToStringList(strDelimitedList, (WCHAR) ',', slList);
}

// ----------------------------------------------------------------------
//
// Function:  ConvertSpaceDelimitedListToStringList
//
// Purpose:   Convert a space delimited list to a TStringList
//
// Arguments:
//    strDelimitedList [in]  Space delimited list
//    slList           [out] list of string items
//
// Returns:   None
//
// Author:    kumarp 23-December-97
//
// Notes:
//
void ConvertSpaceDelimitedListToStringList(IN const tstring& strDelimitedList,
                                           OUT TStringList &slList)
{
    ConvertDelimitedListToStringList(strDelimitedList, ' ', slList);
}

void ConvertStringListToCommaList(IN const TStringList &slList, OUT tstring &strList)
{
    ConvertStringListToDelimitedList(slList, strList, ',');
}

void ConvertStringListToDelimitedList(IN const TStringList &slList,
                      OUT tstring &strList, IN WCHAR chDelimiter)
{
    TStringListIter pos = slList.begin();
    tstring strTemp;
    WORD i=0;
    static const WCHAR szSpecialChars[] = L" %=";

    while (pos != slList.end())
    {
        strTemp = **pos++;

        //
        //  put quotes around any strings that have chars that setupapi doesn't like.
        //
        if (strTemp.empty() ||
            (L'\"' != *(strTemp.c_str()) &&
             wcscspn(strTemp.c_str(), szSpecialChars) < strTemp.size()))
        {
            strTemp = '"' + strTemp + '"';
        }

        if (i)
        {
            strList = strList + chDelimiter + strTemp;
        }
        else
        {
            strList = strTemp;
        }
        ++i;
    }
}


// ----------------------------------------------------------------------
//
// Function:  IsBoolString
//
// Purpose:   Parse a string to decide if it represents a boolean value
//
// Arguments:
//    pszStr  [in]  string
//    pbValue [out] pointer to BOOL value parsed
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 12-February-98
//
// Notes:
//
BOOL IsBoolString(IN PCWSTR pszStr, OUT BOOL *pbValue)
{
    if ((!_wcsicmp(pszStr, L"yes")) ||
    (!_wcsicmp(pszStr, L"true")) ||
    (!_wcsicmp(pszStr, L"1")))
    {
        *pbValue = TRUE;
        return TRUE;
    }
    else if ((!_wcsicmp(pszStr, L"no")) ||
         (!_wcsicmp(pszStr, L"false")) ||
         (!_wcsicmp(pszStr, L"0")))
    {
        *pbValue = FALSE;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

// ----------------------------------------------------------------------
//
// Function:  FIsInStringArray
//
// Purpose:   Find out if a string exists in an array
//
// Arguments:
//    ppszStrings     [in]  array of strings
//    cNumStrings     [in]  num strings in array
//    pszStringToFind [in]  string to find
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 12-February-98
//
// Notes:
//
BOOL FIsInStringArray(
    IN const PCWSTR* ppszStrings,
    IN DWORD cNumStrings,
    IN PCWSTR pszStringToFind,
    OUT UINT* puIndex)
{
    for (DWORD isz = 0; isz < cNumStrings; isz++)
    {
        if (!lstrcmpiW(ppszStrings[isz], pszStringToFind))
        {
            if (puIndex)
            {
                *puIndex = isz;
            }

            return TRUE;
        }
    }
    return FALSE;
}

// ----------------------------------------------------------------------
//
// Function:  HrRegOpenServiceKey
//
// Purpose:   Open reg key for the given service
//
// Arguments:
//    szServiceName [in]  name of service
//    samDesired    [in]  SAM required
//    phKey         [out] pointer to handle of reg key
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 12-February-98
//
// Notes:
//
HRESULT HrRegOpenServiceKey(
    IN PCWSTR pszServiceName,
    IN REGSAM samDesired,
    OUT HKEY* phKey)
{
    DefineFunctionName("HrRegOpenServiceKey");

    AssertValidReadPtr(pszServiceName);
    AssertValidWritePtr(phKey);

    *phKey = NULL;

    HRESULT hr;
    tstring strService;

    strService = c_szRegKeyServices;
    strService += L"\\";
    strService += pszServiceName;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, strService.c_str(),
                        samDesired, phKey);

    TraceErrorOptional(__FUNCNAME__, hr,
                       (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr));

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrRegOpenServiceSubKey
//
// Purpose:   Open sub key of a service key
//
// Arguments:
//    pszServiceName [in]  name of service
//    pszSubKey      [in]  name of sub key
//    samDesired    [in]  SAM required
//    phKey         [out] pointer to handle of key opened
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 12-February-98
//
// Notes:
//
HRESULT HrRegOpenServiceSubKey(
    IN PCWSTR pszServiceName,
    IN PCWSTR pszSubKey,
    IN REGSAM samDesired,
    OUT HKEY* phKey)
{
    AssertValidReadPtr(pszServiceName);
    AssertValidReadPtr(pszSubKey);
    AssertValidWritePtr(phKey);

    DefineFunctionName("HrRegOpenServiceSubKey");

    HRESULT hr = S_OK;

    tstring strKey;
    strKey = pszServiceName;
    strKey += L"\\";
    strKey += pszSubKey;

    hr = HrRegOpenServiceKey(strKey.c_str(), samDesired, phKey);

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  FIsServiceKeyPresent
//
// Purpose:   Check if a service reg key is present
//
// Arguments:
//    pszServiceName [in]  name of service
//
// Returns:   TRUE on success, FALSE otherwise
//
// Author:    kumarp 12-February-98
//
// Notes:
//
BOOL FIsServiceKeyPresent(IN PCWSTR pszServiceName)
{
    BOOL fResult = FALSE;

    HKEY hkeyService;
    HRESULT hr;

    hr = HrRegOpenServiceKey(pszServiceName, KEY_READ, &hkeyService);
    if (S_OK == hr)
    {
        // we just wanted to see if service is installed
        RegCloseKey(hkeyService);
        fResult = TRUE;
    }

    return fResult;
}

// ----------------------------------------------------------------------
//
// Function:  EraseAndDeleteAll
//
// Purpose:   Erase each element and then delete string array
//
// Arguments:
//    sa [in]  pointer to array of strings
//
// Returns:   None
//
// Author:    kumarp 12-February-98
//
// Notes:
//
void EraseAndDeleteAll(IN TStringArray* sa)
{
    for (size_t i=0; i < sa->size(); i++)
    {
        delete (*sa)[i];
    }
    sa->erase(sa->begin(), sa->end());
}


// ----------------------------------------------------------------------
//
// Function:  AppendToPath
//
// Purpose:   Append a subpath/filename to a path
//
// Arguments:
//    pstrPath [in]  path
//    szItem   [in]  item to append
//
// Returns:   None
//
// Author:    kumarp 12-February-98
//
// Notes:
//
void AppendToPath(IN OUT tstring* pstrPath, IN PCWSTR szItem)
{
    if (pstrPath->c_str()[pstrPath->size()-1] != L'\\')
    {
        *pstrPath += L'\\';
    }

    *pstrPath += szItem;
}

// ----------------------------------------------------------------------
//
// Function:  ConvertDelimitedListToStringArray
//
// Purpose:   Convert a delimited list to an array
//
// Arguments:
//    strDelimitedList [in]  delimited list (e.g. "a,b,c")
//    chDelimiter      [in]  delimiter char
//    saStrings        [out] array of strings
//
// Returns:   None
//
// Author:    kumarp 12-February-98
//
// Notes:
//
void ConvertDelimitedListToStringArray(
    IN const tstring& strDelimitedList,
    IN WCHAR chDelimiter,
    OUT TStringArray &saStrings)
{
    PCWSTR pszDelimitedList = strDelimitedList.c_str();
    DWORD i=0, dwStart;

    EraseAndDeleteAll(&saStrings);

    tstring strTemp;
    DWORD dwNumChars;
    while (pszDelimitedList[i])
    {
        dwStart = i;
        while (pszDelimitedList[i] && (pszDelimitedList[i] != chDelimiter))
        {
            ++i;
        }

        // if each item is enclosed in quotes. strip the quotes
        dwNumChars = i - dwStart;
        if (pszDelimitedList[dwStart] == L'"')
        {
            dwStart++;
            dwNumChars -= 2;
        }

        strTemp = strDelimitedList.substr(dwStart, dwNumChars);
        saStrings.push_back(new tstring(strTemp));
        if (pszDelimitedList[i])
        {
            ++i;
        }
    }
}

// ----------------------------------------------------------------------
//
// Function:  ConvertCommaDelimitedListToStringList
//
// Purpose:   Convert a comma delimited list to an array
//
// Arguments:
//    strDelimitedList [in]  delimited list (e.g. "a,b,c")
//    saStrings        [out] array of strings
//
// Returns:   None
//
// Author:    kumarp 12-February-98
//
// Notes:
//
void ConvertCommaDelimitedListToStringArray(
    IN const tstring& strDelimitedList,
    OUT TStringArray &saStrings)
{
    ConvertDelimitedListToStringArray(strDelimitedList, L',', saStrings);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncnetcfg\notifval.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       N O T I F V A L . C P P
//
//  Contents:   Validation routines for the INetCfgNotify interfaces.
//
//  Notes:
//
//  Author:     shaunco   14 Apr 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "netcfgn.h"
#include "notifval.h"



//+---------------------------------------------------------------------------
// INetCfgNotify
//

BOOL FBadArgs_INetCfgNotify_Initialize (INetCfgComponent* a, INetCfg* b, BOOL c)
{
    return FBadInPtr(a) || FBadInPtr(b);
}

BOOL FBadArgs_INetCfgNotify_ReadAnswerFile (PCWSTR c, PCWSTR d)
{
    return FBadInPtr(c) || FBadInPtr(d);
}

BOOL FBadArgs_INetCfgNotify_Validate (HWND a)
{
    return a && !IsWindow(a);
}


//+---------------------------------------------------------------------------
// INetCfgProperties
//

BOOL FBadArgs_INetCfgProperties_MergePropPages (DWORD* a, LPBYTE* b, UINT* c, HWND hwnd, PCWSTR *psz)
{
    BOOL fRet = FALSE;

    if (!FBadOutPtr (b))
    {
        *b = NULL;
    }
    else
    {
        fRet = TRUE;
    }

    if (!FBadOutPtr (c))
    {
        *c = 0;
    }
    else
    {
        fRet = TRUE;
    }

    if (psz)
    {
        if (!FBadOutPtr(psz))
        {
            *psz = NULL;
        }
        else
        {
            fRet = TRUE;
        }
    }

    return fRet || FBadInPtr (a) || FBadOutPtr (a) || (hwnd && !IsWindow(hwnd));
}

BOOL FBadArgs_INetCfgProperties_ValidateProperties(HWND a)
{
    return a && !IsWindow(a);
}


//+---------------------------------------------------------------------------
// INetCfgSystemNotify
//

BOOL FBadArgs_INetCfgSystemNotify_GetSupportedNotifications (DWORD* a)
{
    BOOL fRet = FALSE;

    if (!FBadOutPtr(a))
    {
        *a = 0;
    }
    else
    {
        fRet = TRUE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncnetcfg\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOGDI
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <devguid.h>
#include <setupapi.h>
#include <tchar.h>

#include "stllist.h"
#include "stlvec.h"
using namespace std;

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncnetcon\ncconv.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C C O N V . H
//
//  Contents:   Common routines for dealing with the connections interfaces.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   20 Aug 1998
//
//----------------------------------------------------------------------------

#include <atlbase.h>
#include "netconp.h"

class CPropertiesEx
{
public:
    CPropertiesEx(NETCON_PROPERTIES_EX* pPropsEx)
    {
        m_pPropsEx = pPropsEx;
    };

    ~CPropertiesEx() {};

    HRESULT GetField(IN int nField, OUT VARIANT& varElement);
    HRESULT SetField(IN int nField, IN const VARIANT& varElement);

protected:
    NETCON_PROPERTIES_EX* m_pPropsEx;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncnetcon\ncconv.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C C O N V . C P P
//
//  Contents:   Common routines for dealing with the connections interfaces.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   20 Aug 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncnetcon.h"
#include "ncconv.h"

HRESULT SysCopyBString(BSTR *bstrDestination, const BSTR bstrSource)
{
    HRESULT hr = S_OK;
    if (bstrSource)
    {
        *bstrDestination = SysAllocStringByteLen(reinterpret_cast<LPCSTR>(bstrSource), SysStringByteLen(bstrSource));
        if (!*bstrDestination)
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        *bstrDestination = SysAllocString(NULL);
    }
    return hr;
}

HRESULT CPropertiesEx::GetField(IN int nField, OUT VARIANT& varElement)
{
    HRESULT hr = S_OK;

    WCHAR szGuid[MAX_GUID_STRING_LEN];
    
    switch (nField)
    {
    case NCP_DWSIZE:
        varElement.vt = VT_I4;
        varElement.ulVal = m_pPropsEx->dwSize;
        break;
    case NCP_GUIDID:
        if (StringFromGUID2(m_pPropsEx->guidId, szGuid, MAX_GUID_STRING_LEN))
        {
            varElement.vt = VT_BSTR;
            varElement.bstrVal = SysAllocString(szGuid);
            if (!varElement.bstrVal)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_BSTRNAME:
        varElement.vt = VT_BSTR;
        hr = SysCopyBString(&varElement.bstrVal, m_pPropsEx->bstrName);
        break;
    case NCP_BSTRDEVICENAME:
        varElement.vt = VT_BSTR;
        hr = SysCopyBString(&varElement.bstrVal, m_pPropsEx->bstrDeviceName);
        break;
    case NCP_NCSTATUS:
        varElement.vt = VT_I4;
        varElement.ulVal = m_pPropsEx->ncStatus;
        break;
    case NCP_MEDIATYPE:
        varElement.vt = VT_I4;
        varElement.ulVal = m_pPropsEx->ncMediaType;
        break;
    case NCP_SUBMEDIATYPE:
        varElement.vt = VT_I4;
        varElement.ulVal = m_pPropsEx->ncSubMediaType;        
        break;
    case NCP_DWCHARACTER:
        varElement.vt = VT_I4;
        varElement.ulVal = m_pPropsEx->dwCharacter;        
        break;
    case NCP_CLSIDTHISOBJECT:
        if (StringFromGUID2(m_pPropsEx->clsidThisObject, szGuid, MAX_GUID_STRING_LEN))
        {
            varElement.vt = VT_BSTR;
            varElement.bstrVal = SysAllocString(szGuid);
            if (!varElement.bstrVal)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_CLSIDUIOBJECT:
        if (StringFromGUID2(m_pPropsEx->clsidUiObject, szGuid, MAX_GUID_STRING_LEN))
        {
            varElement.vt = VT_BSTR;
            varElement.bstrVal = SysAllocString(szGuid);
            if (!varElement.bstrVal)
            {
                hr = E_OUTOFMEMORY;
            }
        }        
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_BSTRPHONEORHOSTADDRESS:
        varElement.vt = VT_BSTR;
        hr = SysCopyBString(&varElement.bstrVal, m_pPropsEx->bstrPhoneOrHostAddress);
        break;
    case NCP_BSTRPERSISTDATA:
        varElement.vt = VT_BSTR;
        hr = SysCopyBString(&varElement.bstrVal, m_pPropsEx->bstrPersistData);
        break;
    default:
        AssertSz(FALSE, "Field is not in list, have you updated the list?");
    }

    AssertSz(SUCCEEDED(hr), "Could not GetField");
    TraceHr (ttidError, FAL, hr, FALSE, "GetField");

    return hr;
}

HRESULT CPropertiesEx::SetField(IN int nField, IN const VARIANT& varElement)
{
    HRESULT hr = S_OK;
    
    switch (nField) 
    {
    case NCP_DWSIZE:
        if (VT_I4 == varElement.vt)
        {
            m_pPropsEx->dwSize = varElement.ulVal;
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_GUIDID:
        if (VT_BSTR == varElement.vt)
        {
            hr = CLSIDFromString(varElement.bstrVal, &m_pPropsEx->guidId);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_BSTRNAME:
        if (VT_BSTR == varElement.vt)
        {
            hr = SysCopyBString(&m_pPropsEx->bstrName, varElement.bstrVal);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_BSTRDEVICENAME:
        if (VT_BSTR == varElement.vt)
        {
            hr = SysCopyBString(&m_pPropsEx->bstrDeviceName, varElement.bstrVal);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_NCSTATUS:
        if (VT_I4 == varElement.vt)
        {
            m_pPropsEx->ncStatus = static_cast<NETCON_STATUS>(varElement.ulVal);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_MEDIATYPE:
        if (VT_I4 == varElement.vt)
        {
            m_pPropsEx->ncMediaType = static_cast<NETCON_MEDIATYPE>(varElement.ulVal);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_SUBMEDIATYPE:
        if (VT_I4 == varElement.vt)
        {
            m_pPropsEx->ncSubMediaType = static_cast<NETCON_SUBMEDIATYPE>(varElement.ulVal);
        }
        else
        {
            hr = E_INVALIDARG;
        }

        break;
    case NCP_DWCHARACTER:
        if (VT_I4 == varElement.vt)
        {
            m_pPropsEx->dwCharacter = varElement.ulVal;
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_CLSIDTHISOBJECT:
        if (VT_BSTR == varElement.vt)
        {
            hr = CLSIDFromString(varElement.bstrVal, &m_pPropsEx->clsidThisObject);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_CLSIDUIOBJECT:
        if (VT_BSTR == varElement.vt)
        {
            hr = CLSIDFromString(varElement.bstrVal, &m_pPropsEx->clsidUiObject);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_BSTRPHONEORHOSTADDRESS:
        if (VT_BSTR == varElement.vt)
        {
            hr = SysCopyBString(&m_pPropsEx->bstrPhoneOrHostAddress, varElement.bstrVal);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
    case NCP_BSTRPERSISTDATA:
        if (VT_BSTR == varElement.vt)
        {
            hr = SysCopyBString(&m_pPropsEx->bstrPersistData, varElement.bstrVal);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        break;
 
    default:
        AssertSz(FALSE, "Field is not in list, have you updated the list?");
    }
    
    TraceHr (ttidError, FAL, hr, FALSE, "SetField");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncnetcfg\netinfid.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N E T I N F I D . H
//
//  Contents:   Network Component IDs
//
//  Notes:
//
//  Author:     kumarp  13 Mar 1997
//
//----------------------------------------------------------------------------

#pragma hdrstop
#include "netcfgx.h"

// __declspec(selectany) tells the compiler that the string should be in
// its own COMDAT.  This allows the linker to throw out unused strings.
// If we didn't do this, the COMDAT for this module would reference the
// strings so they wouldn't be thrown out.
//
#define CONST_GLOBAL    extern const DECLSPEC_SELECTANY

//+---------------------------------------------------------------------------
// Network Adapters: GUID_DEVCLASS_NET

CONST_GLOBAL WCHAR c_szInfId_MS_AtmElan[]       = L"ms_atmelan";
CONST_GLOBAL WCHAR c_szInfId_MS_IrdaMiniport[]  = L"ms_irdaminiport";
CONST_GLOBAL WCHAR c_szInfId_MS_IrModemMiniport[] = L"ms_irmodemminiport";
CONST_GLOBAL WCHAR c_szInfId_MS_L2tpMiniport[]  = L"ms_l2tpminiport";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanAtalk[]  = L"ms_ndiswanatalk";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanBh[]     = L"ms_ndiswanbh";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanIp[]     = L"ms_ndiswanip";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanIpx[]    = L"ms_ndiswanipx";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanNbfIn[]  = L"ms_ndiswannbfin";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWanNbfOut[] = L"ms_ndiswannbfout";
CONST_GLOBAL WCHAR c_szInfId_MS_PppoeMiniport[] = L"ms_pppoeminiport";
CONST_GLOBAL WCHAR c_szInfId_MS_PptpMiniport[]  = L"ms_pptpminiport";
CONST_GLOBAL WCHAR c_szInfId_MS_PSchedMP[]      = L"ms_pschedmp";
CONST_GLOBAL WCHAR c_szInfId_MS_PtiMiniport[]   = L"ms_ptiminiport";


//+---------------------------------------------------------------------------
// Network Protocols: GUID_DEVCLASS_NETTRANS

CONST_GLOBAL WCHAR c_szInfId_MS_AppleTalk[]     = L"ms_appletalk";
CONST_GLOBAL WCHAR c_szInfId_MS_AtmArps[]       = L"ms_atmarps";
CONST_GLOBAL WCHAR c_szInfId_MS_AtmLane[]       = L"ms_atmlane";
CONST_GLOBAL WCHAR c_szInfId_MS_AtmUni[]        = L"ms_atmuni";
CONST_GLOBAL WCHAR c_szInfId_MS_IrDA[]          = L"ms_irda";
CONST_GLOBAL WCHAR c_szInfId_MS_Isotpsys[]      = L"ms_isotpsys";
CONST_GLOBAL WCHAR c_szInfId_MS_L2TP[]          = L"ms_l2tp";
CONST_GLOBAL WCHAR c_szInfId_MS_NdisWan[]       = L"ms_ndiswan";
CONST_GLOBAL WCHAR c_szInfId_MS_NetBEUI[]       = L"ms_netbeui";
CONST_GLOBAL WCHAR c_szInfId_MS_NetBT[]         = L"ms_netbt";
CONST_GLOBAL WCHAR c_szInfId_MS_NetBT_SMB[]     = L"ms_netbt_smb";
CONST_GLOBAL WCHAR c_szInfId_MS_NetMon[]        = L"ms_netmon";
CONST_GLOBAL WCHAR c_szInfId_MS_NWIPX[]         = L"ms_nwipx";
CONST_GLOBAL WCHAR c_szInfId_MS_NWNB[]          = L"ms_nwnb";
CONST_GLOBAL WCHAR c_szInfId_MS_NWSPX[]         = L"ms_nwspx";
CONST_GLOBAL WCHAR c_szInfId_MS_PPPOE[]         = L"ms_pppoe";
CONST_GLOBAL WCHAR c_szInfId_MS_PPTP[]          = L"ms_pptp";
CONST_GLOBAL WCHAR c_szInfId_MS_PSchedPC[]      = L"ms_pschedpc";
CONST_GLOBAL WCHAR c_szInfId_MS_RawWan[]        = L"ms_rawwan";
CONST_GLOBAL WCHAR c_szInfId_MS_Streams[]       = L"ms_streams";
CONST_GLOBAL WCHAR c_szInfId_MS_TCPIP[]         = L"ms_tcpip";
CONST_GLOBAL WCHAR c_szInfId_MS_NDISUIO[]       = L"ms_ndisuio";

//+---------------------------------------------------------------------------
// Network Services: GUID_DEVCLASS_NETSERVICE

CONST_GLOBAL WCHAR c_szInfId_MS_ALG[]           = L"ms_alg";
CONST_GLOBAL WCHAR c_szInfId_MS_DHCPServer[]    = L"ms_dhcpserver";
CONST_GLOBAL WCHAR c_szInfId_MS_FPNW[]          = L"ms_fpnw";
CONST_GLOBAL WCHAR c_szInfId_MS_GPC[]           = L"ms_gpc";
CONST_GLOBAL WCHAR c_szInfId_MS_NetBIOS[]       = L"ms_netbios";
CONST_GLOBAL WCHAR c_szInfId_MS_NwSapAgent[]    = L"ms_nwsapagent";
CONST_GLOBAL WCHAR c_szInfId_MS_PSched[]        = L"ms_psched";
CONST_GLOBAL WCHAR c_szInfId_MS_RasCli[]        = L"ms_rascli";
CONST_GLOBAL WCHAR c_szInfId_MS_RasMan[]        = L"ms_rasman";
CONST_GLOBAL WCHAR c_szInfId_MS_RasSrv[]        = L"ms_rassrv";
CONST_GLOBAL WCHAR c_szInfId_MS_RSVP[]          = L"ms_rsvp";
CONST_GLOBAL WCHAR c_szInfId_MS_Server[]        = L"ms_server";
CONST_GLOBAL WCHAR c_szInfId_MS_Steelhead[]     = L"ms_steelhead";
CONST_GLOBAL WCHAR c_szInfId_MS_WLBS[]          = L"ms_wlbs";
CONST_GLOBAL WCHAR c_szInfId_MS_WZCSVC[]        = L"ms_wzcsvc";

//+---------------------------------------------------------------------------
// Network Clients: GUID_DEVCLASS_NETCLIENT

CONST_GLOBAL WCHAR c_szInfId_MS_MSClient[]      = L"ms_msclient";
CONST_GLOBAL WCHAR c_szInfId_MS_NWClient[]      = L"ms_nwclient";
CONST_GLOBAL WCHAR c_szInfId_MS_WebClient[]     = L"ms_webclient";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncnetcon\ncnetcon.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C N E T C O N . C P P
//
//  Contents:   Common routines for dealing with the connections interfaces.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   20 Aug 1998
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include <atlbase.h>
#include "nccom.h"
#include "ncnetcon.h"
#include "netconp.h"
#include "ncras.h"
#include "ncreg.h"
#include "ncconv.h"

//+---------------------------------------------------------------------------
//
//  Function:   FreeNetconProperties
//
//  Purpose:    Free the memory associated with the output parameter of
//              INetConnection->GetProperties.  This is a helper function
//              used by clients of INetConnection.
//
//  Arguments:
//      pProps  [in] The properties to free.
//
//  Returns:    nothing.
//
//  Author:     shaunco   1 Feb 1998
//
//  Notes:
//
VOID
FreeNetconProperties (
    IN NETCON_PROPERTIES* pProps)
{
    if (pProps)
    {
        CoTaskMemFree (pProps->pszwName);
        CoTaskMemFree (pProps->pszwDeviceName);
        CoTaskMemFree (pProps);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetConnectionPersistData
//
//  Purpose:    Get the persistent form of a connection.  This can be used
//              to later get back to the INetConnection interface with a call
//              to HrGetConnectionFromPersistData.
//
//  Arguments:
//      pConn   [in]  Connection to get persist data from.
//      ppbData [out] Address of where to return pointer to data.
//      pcbSize [out] Address of where to return the size of the data.
//      pclsid  [out] Address of where to return the CLSID of the connection.
//
//  Returns:    S_OK or an error code
//
//  Author:     shaunco   20 Aug 1998
//
//  Notes:      Free *ppbData with MemFree.
//
HRESULT
HrGetConnectionPersistData (
    IN INetConnection* pConn,
    OUT BYTE** ppbData,
    OUT ULONG* pcbSize,
    OUT CLSID* pclsid OPTIONAL)
{
    Assert (pConn);
    Assert (ppbData);
    Assert (pcbSize);
    // pclsid is optional.

    // Initialize the output parameters.
    //
    *ppbData = NULL;
    *pcbSize = 0;
    if (pclsid)
    {
        *pclsid = GUID_NULL;
    }

    // Get the IPersistNetConnection interfaces.
    //
    IPersistNetConnection* pPersist;

    HRESULT hr = HrQIAndSetProxyBlanket(pConn, &pPersist);

    if (SUCCEEDED(hr))
    {
        // Return the CLSID if requested.
        //
        if (pclsid)
        {
            hr = pPersist->GetClassID (pclsid);
            TraceHr(ttidError, FAL, hr, FALSE, "pPersist->GetClassID");
        }

        if (SUCCEEDED(hr))
        {
            // Get the size required, allocated a buffer, and get the data.
            //

            BYTE* pbData;
            ULONG cbData;

            hr = pPersist->GetSizeMax (&cbData);

            TraceHr(ttidError, FAL, hr, FALSE, "pPersist->GetSizeMax");

            if (SUCCEEDED(hr))
            {
                hr = E_OUTOFMEMORY;
                pbData = (BYTE*)MemAlloc (cbData);
                if (pbData)
                {
                    hr = pPersist->Save (pbData, cbData);

                    TraceHr(ttidError, FAL, hr, FALSE, "pPersist->Save");

                    if (SUCCEEDED(hr))
                    {
                        *ppbData = pbData;
                        *pcbSize = cbData;
                    }
                    else
                    {
                        MemFree (pbData);
                    }
                }
            }
        }

        ReleaseObj (pPersist);
    }

    TraceError("HrGetConnectionPersistData", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetConnectionFromPersistData
//
//  Purpose:    Get an INetConnection interface given the persistent form of
//              the connection.
//
//  Arguments:
//      clsid  [in]  CLSID to CoCreateInstance with.
//      pbData [in]  Pointer to connection's persist data.
//      cbData [in]  Size of the data in bytes.
//      ppConn [out] Address of where to return the pointer to the
//                   INetConnection interface.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   2 Nov 1998
//
//  Notes:
//
HRESULT
HrGetConnectionFromPersistData (
    IN const CLSID& clsid,
    IN const BYTE* pbData,
    IN ULONG cbData,
    IN REFIID riid,
    OUT VOID** ppv)
{
    Assert (pbData);
    Assert (cbData);
    Assert (ppv);

    HRESULT hr;

    // Initialize the output parameter.
    //
    *ppv = NULL;

    // Create a connection object and get an IPersistNetConnection
    // interface pointer on it.
    //
    IPersistNetConnection* pPersist;
    hr = HrCreateInstance(
        clsid,
        CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        &pPersist);

    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");

    if (SUCCEEDED(hr))
    {
        // Initialize the connection object using the persist data.
        //
        hr = pPersist->Load (pbData, cbData);

        TraceHr(ttidError, FAL, hr, FALSE,
            "pPersist->Load: pbData=0x%p, cbData=%u",
            pbData, cbData);

        if (SUCCEEDED(hr))
        {
            // Return an INetConnection interface pointer.
            //
            hr = pPersist->QueryInterface(riid, ppv);

            TraceHr(ttidError, FAL, hr, FALSE, "pPersist->QueryInterface");

            if (SUCCEEDED(hr))
            {
                NcSetProxyBlanket (reinterpret_cast<IUnknown *>(*ppv));
            }
        }
        ReleaseObj (pPersist);
    }

    TraceError("HrGetConnectionFromPersistData", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsValidConnectionName
//
//  Purpose:    Determines if the given connection name is valid.
//
//  Arguments:
//      pszName [in]     Connection name to test
//
//  Returns:    TRUE if name is valid, FALSE if not
//
//  Author:     danielwe   14 Sep 1998
//
//  Notes:
//
BOOL
FIsValidConnectionName (
    IN PCWSTR pszName)
{
    static const WCHAR c_szInvalidChars[] = L"\\/:*?\"<>|\t";

    const WCHAR*  pchName;

    if (lstrlen(pszName) > RASAPIP_MAX_ENTRY_NAME)
    {
        return FALSE;
    }

    DWORD dwNonSpaceChars = 0;
    for (pchName = pszName; pchName && *pchName; pchName++)
    {
        if (wcschr(c_szInvalidChars, *pchName))
        {
            return FALSE;
        }

        if (*pchName != L' ')
        {
            dwNonSpaceChars++;
        }
    }

    if (!dwNonSpaceChars)
    {
        return FALSE;
    }

    return TRUE;
}


#define REGKEY_NETWORK_CONNECTIONS \
    L"System\\CurrentControlSet\\Control\\Network\\Connections"

#define REGVAL_ATLEASTONELANSHOWICON \
    L"AtLeastOneLanShowIcon"

VOID
SetOrQueryAtLeastOneLanWithShowIcon (
    IN BOOL fSet,
    IN BOOL fSetValue,
    OUT BOOL* pfQueriedValue)
{
    HRESULT hr;
    HKEY hkey;
    REGSAM samDesired;
    DWORD dwValue;

    samDesired = (fSet) ? KEY_WRITE : KEY_READ;

    hr = HrRegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            REGKEY_NETWORK_CONNECTIONS,
            samDesired,
            &hkey);

    if (S_OK == hr)
    {
        if (fSet)
        {
            dwValue = (fSetValue) ? 1: 0;

            hr = HrRegSetDword (
                    hkey,
                    REGVAL_ATLEASTONELANSHOWICON,
                    dwValue);
        }
        else
        {
            Assert (pfQueriedValue);

            hr = HrRegQueryDword (
                    hkey,
                    REGVAL_ATLEASTONELANSHOWICON,
                    &dwValue);

            *pfQueriedValue = !!dwValue;
        }

        RegCloseKey (hkey);
    }
}

BOOL
FAnyReasonToEnumerateConnectionsForShowIconInfo (
    VOID)
{
    // If any active RAS connections exist, might as well return TRUE
    // because they will probably have the "showicon" bit turned on.
    //
    if (FExistActiveRasConnections ())
    {
        return TRUE;
    }

    BOOL fRet = FALSE;

    // If the LAN connection manager has previously noted that at least
    // one LAN connection has the showicon bit set, return TRUE.
    //
    SetOrQueryAtLeastOneLanWithShowIcon (
        FALSE,  // query the value
        FALSE,
        &fRet);

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSafeArrayFromNetConPropertiesEx
//
//  Purpose:    Create a safe array that can be marshaled across processes.
//
//
//
//  Arguments:
//      pPropsEx        [in]  Properties to use to build the safe array.
//      ppsaProperties  [out] Safe array in which to store data.
//
//  Returns:    HRESULT
//
//  Author:     ckotze 19 Mar 2001
//
//  Notes:      Caller must free array and contents.
//
//
HRESULT
HrSafeArrayFromNetConPropertiesEx (
    IN      NETCON_PROPERTIES_EX* pPropsEx,
    OUT     SAFEARRAY** ppsaProperties)
{
    HRESULT hr = S_OK;
    SAFEARRAYBOUND rgsaBound[1] = {0};

    if (!pPropsEx)
    {
        return E_INVALIDARG;
    }
    if (!ppsaProperties)
    {
        return E_POINTER;
    }

    rgsaBound[0].cElements = NCP_ELEMENTS;
    rgsaBound[0].lLbound = 0;

    *ppsaProperties = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);
    if (*ppsaProperties)
    {
        CPropertiesEx peProps(pPropsEx);

        for (LONG i = NCP_DWSIZE; i <= NCP_MAX; i++)
        {
            CComVariant varField;
            hr = peProps.GetField(i, varField);
            if (SUCCEEDED(hr))
            {
                hr = SafeArrayPutElement(*ppsaProperties, &i, reinterpret_cast<void*>(&varField));
            }

            if (FAILED(hr))
            {
                break;
            }

        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrSafeArrayFromNetConPropertiesEx");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrNetConPropertiesExFromSafeArray
//
//  Purpose:    Rebuilds a NETCON_PROPERTIES_EX* structure from the safearray.
//
//
//
//  Arguments:
//      psaProperties  [in]  The safe array containing the data
//      ppPropsEx      [out] Structure containing the properties
//
//  Returns:    HRESULT - S_OK if valid, else an error.
//
//  Author:     ckotze   19 Mar 2001
//
//  Notes:      Caller must free ppPropsEx using HrFreeNetConProperties2
//
HRESULT HrNetConPropertiesExFromSafeArray(
    IN      SAFEARRAY* psaProperties,
    OUT     NETCON_PROPERTIES_EX** ppPropsEx)
{
    HRESULT hr = S_OK;
    LONG lLBound;
    LONG lUBound;

    if (!psaProperties)
    {
        return E_INVALIDARG;
    }

    *ppPropsEx = reinterpret_cast<NETCON_PROPERTIES_EX*>(CoTaskMemAlloc(sizeof(NETCON_PROPERTIES_EX)));

    if (*ppPropsEx)
    {
        hr = SafeArrayGetLBound(psaProperties, 1, &lLBound);
        if (SUCCEEDED(hr))
        {
            hr = SafeArrayGetUBound(psaProperties, 1, &lUBound);
            if (SUCCEEDED(hr))
            {
                CPropertiesEx PropEx(*ppPropsEx);

                for (LONG i = lLBound; i <= lUBound; i++)
                {
                    CComVariant varField;
                    hr = SafeArrayGetElement(psaProperties, &i, reinterpret_cast<LPVOID>(&varField));
                    if (SUCCEEDED(hr))
                    {
                        hr = PropEx.SetField(i, varField);
                    }

                    if (FAILED(hr))
                    {
                        break;
                    }
                }
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrNetConPropertiesExFromSafeArray");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFreeNetConProperties2
//
//  Purpose:    Free all strings in the structure and then free the structure.
//
//
//
//  Arguments:
//      pPropsEx  [in] The properties to free.
//
//  Returns:    HRESULT - S_OK if success else an error
//
//  Author:     ckotze   19 Mar 2001
//
//  Notes:
//
HRESULT HrFreeNetConProperties2(NETCON_PROPERTIES_EX* pPropsEx)
{
    HRESULT hr = S_OK;

    Assert(pPropsEx);

    if (pPropsEx)
    {
        if (pPropsEx->bstrName)
        {
            SysFreeString(pPropsEx->bstrName);
        }

        if (pPropsEx->bstrDeviceName)
        {
            SysFreeString(pPropsEx->bstrDeviceName);
        }

        if (pPropsEx->bstrPhoneOrHostAddress)
        {
            SysFreeString(pPropsEx->bstrPhoneOrHostAddress);
        }
        if (pPropsEx->bstrPersistData)
        {
            SysFreeString(pPropsEx->bstrPersistData);
        }

        CoTaskMemFree(pPropsEx);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncoc\ncoc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C O C . C P P
//
//  Contents:   Common functions related to optional components
//
//  Notes:
//
//  Author:     danielwe   18 Dec 1997
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncinf.h"
#include "ncmisc.h"
#include "ncsetup.h"
#include "ncstring.h"
#include "ncsnmp.h"
#include "ncoc.h"
#include "ncsvc.h"
#include <winspool.h>  // Print monitor routines
#include "ncmisc.h"

// SNMP Agent extension
static const WCHAR  c_szSNMPSuffix[]    = L"SNMPAgent";
static const WCHAR  c_szSNMPAddLabel[]  = L"AddAgent";
static const WCHAR  c_szSNMPDelLabel[]  = L"DelAgent";

static const WCHAR  c_szServiceName[]   = L"ServiceName";
static const WCHAR  c_szAgentName[]     = L"AgentName";
static const WCHAR  c_szAgentPath[]     = L"AgentPath";

// Print extension
static const WCHAR  c_szPrintSuffix[]   = L"PrintMonitor";
static const WCHAR  c_szPrintAddLabel[] = L"AddMonitor";
static const WCHAR  c_szPrintDelLabel[] = L"DelMonitor";

static const WCHAR  c_szPrintMonitorName[]  = L"PrintMonitorName";
static const WCHAR  c_szPrintMonitorDLL[]   = L"PrintMonitorDLL";
static const WCHAR  c_szPrintProcName[]     = L"PrintProcName";
static const WCHAR  c_szPrintProcDLL[]      = L"PrintProcDLL";

static const WCHAR  c_szExternalAppCmdLine[]       = L"CommandLine";
static const WCHAR  c_szExternalAppCmdShow[]       = L"WindowStyle";
static const WCHAR  c_szExternalAppDirectory[]     = L"Directory";

//+---------------------------------------------------------------------------
//
//  Function:   HrProcessSNMPAddSection
//
//  Purpose:    Parses the AddSNMPAgent section for parameters then adds the
//              component as an SNMP agent.
//
//  Arguments:
//      hinfFile  [in]  handle to INF file
//      szSection [in]  section on which to operate
//
//  Returns:    S_OK if success, setup API HRESULT otherwise.
//
//  Author:     danielwe   28 Apr 1997
//
//  Notes:
//
HRESULT HrProcessSNMPAddSection(HINF hinfFile, PCWSTR szSection)
{
    HRESULT     hr = S_OK;
    tstring     strServiceName;
    tstring     strAgentName;
    tstring     strAgentPath;

    hr = HrSetupGetFirstString(hinfFile, szSection, c_szServiceName,
                               &strServiceName);
    if (S_OK == hr)
    {
        hr = HrSetupGetFirstString(hinfFile, szSection, c_szAgentName,
                                   &strAgentName);
        if (S_OK == hr)
        {
            hr = HrSetupGetFirstString(hinfFile, szSection, c_szAgentPath,
                                       &strAgentPath);
            if (S_OK == hr)
            {
                TraceTag(ttidInfExt, "Adding SNMP agent %S...",
                         strAgentName.c_str());
                hr = HrAddSNMPAgent(strServiceName.c_str(),
                                    strAgentName.c_str(),
                                    strAgentPath.c_str());
            }
        }
    }

    TraceHr (ttidError, FAL, hr, (SPAPI_E_LINE_NOT_FOUND == hr),
        "HrProcessSNMPAddSection");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrProcessSNMPRemoveSection
//
//  Purpose:    Handles removal of an SNMP agent.
//
//  Arguments:
//      hinfFile  [in]  handle to INF file
//      szSection [in]  section on which to operate
//
//  Returns:    S_OK if success, setup API HRESULT otherwise
//
//  Author:     danielwe   28 Apr 1997
//
//  Notes:
//
HRESULT HrProcessSNMPRemoveSection(HINF hinfFile, PCWSTR szSection)
{
    HRESULT     hr = S_OK;
    tstring     strAgentName;

    hr = HrSetupGetFirstString(hinfFile, szSection, c_szAgentName,
                               &strAgentName);
    if (S_OK == hr)
    {
        hr = HrRemoveSNMPAgent(strAgentName.c_str());
    }

    TraceHr (ttidError, FAL, hr, (SPAPI_E_LINE_NOT_FOUND == hr),
        "HrProcessSNMPRemoveSection");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrProcessPrintAddSection
//
//  Purpose:    Parses the AddPrintMonitor section for parameters then adds the
//              monitor.
//
//  Arguments:
//      hinfFile  [in]  handle to INF file
//      szSection [in]  section on which to operate
//
//  Returns:    S_OK if success, setup API HRESULT otherwise.
//
//  Author:     CWill   May 5 1997
//
//  Notes:
//
HRESULT HrProcessPrintAddSection(HINF hinfFile, PCWSTR szSection)
{
    HRESULT     hr = S_OK;
    tstring     strPrintMonitorName;
    tstring     strPrintMonitorDLL;

    hr = HrSetupGetFirstString(hinfFile, szSection, c_szPrintMonitorName,
            &strPrintMonitorName);
    if (S_OK == hr)
    {
        hr = HrSetupGetFirstString(hinfFile, szSection, c_szPrintMonitorDLL,
                &strPrintMonitorDLL);
        if (S_OK == hr)
        {
            hr = HrAddPrintMonitor(
                    strPrintMonitorName.c_str(),
                    strPrintMonitorDLL.c_str());
            if (S_OK == hr)
            {
                tstring     strPrintProcName;
                tstring     strPrintProcDLL;

                hr = HrSetupGetFirstString(hinfFile, szSection,
                                           c_szPrintProcName,
                                           &strPrintProcName);
                if (S_OK == hr)
                {
                    hr = HrSetupGetFirstString(hinfFile, szSection,
                                               c_szPrintProcDLL,
                                               &strPrintProcDLL);
                    if (S_OK == hr)
                    {
                        hr = HrAddPrintProc(strPrintProcDLL.c_str(),
                                            strPrintProcName.c_str());
                    }
                }
                else
                {
                    if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
                    {
                        // Print proc's are optional.
                        hr = S_OK;
                    }
                }
            }
        }
    }

    TraceHr (ttidError, FAL, hr, (SPAPI_E_LINE_NOT_FOUND == hr),
        "HrProcessPrintAddSection");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrProcessPrintRemoveSection
//
//  Purpose:    Handles removal of a print monitor.
//
//  Arguments:
//      hinfFile  [in]  handle to INF file
//      szSection [in]  section on which to operate
//
//  Returns:    S_OK if success, setup API HRESULT otherwise
//
//  Author:     CWill   May 5 1997
//
//  Notes:
//
HRESULT HrProcessPrintRemoveSection(HINF hinfFile, PCWSTR szSection)
{
    HRESULT     hr = S_OK;
    tstring     strPrintMonitorName;

    hr = HrSetupGetFirstString(hinfFile, szSection, c_szPrintMonitorName,
            &strPrintMonitorName);
    if (S_OK == hr)
    {
        hr = HrRemovePrintMonitor(strPrintMonitorName.c_str());
        if (S_OK == hr)
        {
            tstring     strPrintProcName;

            hr = HrSetupGetFirstString(hinfFile, szSection, c_szPrintProcName,
                                       &strPrintProcName);
            if (S_OK == hr)
            {
                hr = HrRemovePrintProc(strPrintProcName.c_str());
            }
            else
            {
                if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
                {
                    // Print proc's are optional.
                    hr = S_OK;
                }
            }
        }
        else if (HRESULT_FROM_WIN32(ERROR_BUSY) == hr)
        {
            // Consume the device busy error.  NT4 and NT 3.51 had
            // the same limitation
            hr = S_OK;
        }
    }

    TraceHr (ttidError, FAL, hr, (SPAPI_E_LINE_NOT_FOUND == hr),
        "HrProcessPrintRemoveSection");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrAddPrintProc
//
//  Purpose:    Adds a new print procedure.
//
//  Arguments:
//      szDLLName [in]  File name of DLL in which proc resides.
//      szProc    [in]  Name of procedure to add.
//
//  Returns:    S_OK if success, Win32 HRESULT otherwise.
//
//  Author:     danielwe   6 May 1997
//
//  Notes:
//
HRESULT HrAddPrintProc(PCWSTR szDLLName, PCWSTR szProc)
{
    HRESULT     hr = S_OK;

    if (!AddPrintProcessor(NULL, NULL, const_cast<PWSTR>(szDLLName),
                           const_cast<PWSTR>(szProc)))
    {
        hr = HrFromLastWin32Error();
        if (hr == HRESULT_FROM_WIN32(ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED))
        {
            // Don't complain if processor is already installed.
            hr = S_OK;
        }
    }

    TraceError("HrAddPrintProc", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemovePrintProc
//
//  Purpose:    Removes a print procedure.
//
//  Arguments:
//      szProc    [in]  Name of procedure to remove.
//
//  Returns:    S_OK if success, Win32 HRESULT otherwise.
//
//  Author:     danielwe   6 May 1997
//
//  Notes:
//
HRESULT HrRemovePrintProc(PCWSTR szProc)
{
    HRESULT     hr = S_OK;

    if (!DeletePrintProcessor(NULL, NULL, const_cast<PWSTR>(szProc)))
    {
        hr = HrFromLastWin32Error();
        if (hr == HRESULT_FROM_WIN32(ERROR_UNKNOWN_PRINTPROCESSOR))
        {
            // Don't complain if print processor doesn't exist.
            hr = S_OK;
        }
    }

    TraceError("HrFromLastWin32Error", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrAddPrintMonitor
//
//  Purpose:    Adds a print monitor
//
//  Arguments:
//      szPrintMonitorName  [in]    The name of the print monitor being added
//      szPrintMonitorDLL [in]      The DLL associated with the monitor
//
//  Returns:    S_OK if success, WIN32 HRESULT otherwise
//
//  Author:     CWill   May 5 1997
//
//  Notes:
//
HRESULT HrAddPrintMonitor(PCWSTR szPrintMonitorName,
                          PCWSTR szPrintMonitorDLL)
{
    HRESULT     hr = S_OK;

    MONITOR_INFO_2  moninfoTemp =
    {
        const_cast<WCHAR*>(szPrintMonitorName),
        NULL,
        const_cast<WCHAR*>(szPrintMonitorDLL)
    };

    //$ REVIEW (danielwe) 23 Mar 1998: Need Spooler team to add support to
    // PrintMonitor APIs to start Spooler if needed. Bug #149775

retry:
    // According to MSDN, first param is NULL, second is 2
    // third is the monitor
    TraceTag(ttidInfExt, "Adding print monitor...");
    if (!AddMonitor(NULL, 2, (BYTE*)&moninfoTemp))
    {
        hr = HrFromLastWin32Error();
        if (hr == HRESULT_FROM_WIN32(ERROR_PRINT_MONITOR_ALREADY_INSTALLED))
        {
            // Don't complain if it's already there.
            hr = S_OK;
        }
        else if (hr == HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE))
        {
            // Spooler service isn't started. We need to start it
            TraceTag(ttidInfExt, "Spooler service wasn't started. Starting"
                     " it now...");
            hr = HrEnableAndStartSpooler();
            if (S_OK == hr)
            {
                TraceTag(ttidInfExt, "Spooler service started successfully. "
                         "Retrying...");
                goto retry;
            }
        }
    }

    TraceTag(ttidInfExt, "Done adding print monitor...");

    TraceError("HrAddPrintMonitor", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemovePrintMonitor
//
//  Purpose:    Removes a print monitor
//
//  Arguments:
//      szPrintMonitorName  [in]    The name of the print monitor being removed
//
//  Returns:    S_OK if success, WIN32 HRESULT otherwise
//
//  Author:     CWill   May 5 1997
//
//  Notes:
//
HRESULT HrRemovePrintMonitor(PCWSTR szPrintMonitorName)
{
    HRESULT     hr = S_OK;

    //$ REVIEW (danielwe) 23 Mar 1998: Need Spooler team to add support to
    // PrintMonitor APIs to start Spooler if needed. Bug #149775

retry:
    // According to MSDN, first param is NULL, second is NULL,
    // third is the monitor
    TraceTag(ttidInfExt, "Removing print monitor...");
    if (!DeleteMonitor(NULL, NULL, const_cast<WCHAR*>(szPrintMonitorName)))
    {
        hr = HrFromLastWin32Error();
        if (hr == HRESULT_FROM_WIN32(ERROR_UNKNOWN_PRINT_MONITOR))
        {
            // Don't complain if monitor is unknown.
            hr = S_OK;
        }
        else if (hr == HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE))
        {
            // Spooler service isn't started. We need to start it
            TraceTag(ttidInfExt, "Spooler service wasn't started. Starting"
                     " it now...");
            hr = HrEnableAndStartSpooler();
            if (S_OK == hr)
            {
                TraceTag(ttidInfExt, "Spooler service started successfully. "
                         "Retrying...");
                goto retry;
            }
        }
    }

    TraceTag(ttidInfExt, "Done removing print monitor...");

    TraceError("HrRemovePrintMonitor", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrProcessAllINFExtensions
//
//  Purpose:    Handles support for all optional component extensions to the
//              INF file format.
//
//  Arguments:
//      hinfFile         [in]   handle to INF to process
//      szInstallSection [in]   Install section to process
//
//  Returns:    S_OK if success, setup API HRESULT otherwise
//
//  Author:     jeffspr   14 May 1997
//
//  Notes:
//
HRESULT HrProcessAllINFExtensions(HINF hinfFile, PCWSTR szInstallSection)
{
    HRESULT     hr = S_OK;

    //
    // Handle SNMP Agent extension
    //
    hr = HrProcessInfExtension(hinfFile, szInstallSection, c_szSNMPSuffix,
                               c_szSNMPAddLabel, c_szSNMPDelLabel,
                               HrProcessSNMPAddSection,
                               HrProcessSNMPRemoveSection);
    if (FAILED(hr) && hr != HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
        goto err;

    //
    // Handle Print monitor/procedure extension
    //
    hr = HrProcessInfExtension(hinfFile, szInstallSection, c_szPrintSuffix,
                               c_szPrintAddLabel, c_szPrintDelLabel,
                               HrProcessPrintAddSection,
                               HrProcessPrintRemoveSection);

    if (FAILED(hr) && hr != HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
        goto err;

    hr = S_OK;

err:
    TraceError("HrProcessAllINFExtensions", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncnetcon\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOGDI
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSERVICE
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <windows.h>
#include <objbase.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <setupapi.h>

#include <stdio.h>
#include <wchar.h>

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncoc\ncsnmp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S N M P . C P P
//
//  Contents:   Functions for adding a service as an SNMP agent.
//
//  Notes:
//
//  Author:     danielwe   8 Apr 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncsnmp.h"
#include "ncreg.h"

extern const WCHAR  c_szBackslash[];
extern const WCHAR  c_szEmpty[];
extern const WCHAR  c_szRegKeyServices[];

static const WCHAR  c_szSNMP[]          = L"SNMP";
static const WCHAR  c_szSNMPParams[]    = L"SNMP\\Parameters";
static const WCHAR  c_szSoftwareKey[]   = L"SOFTWARE\\Microsoft";
static const WCHAR  c_szAgentsKey[]     = L"SNMP\\Parameters\\ExtensionAgents";
static const WCHAR  c_szAgentsKeyAbs[]  = L"System\\CurrentControlSet\\Services\\SNMP\\Parameters\\ExtensionAgents";
static const WCHAR  c_szParamsKeyAbs[]  = L"System\\CurrentControlSet\\Services\\SNMP\\Parameters";
static const WCHAR  c_szCurrentVersion[]= L"CurrentVersion";
static const WCHAR  c_szPathName[]      = L"Pathname";

struct SNMP_REG_DATA
{
    PCWSTR     pszAgentPath;
    PCWSTR     pszExtAgentValueName;
    PCWSTR     pszEmpty;
};

//+---------------------------------------------------------------------------
//
//  Function:   HrGetNextAgentNumber
//
//  Purpose:    Obtains the next agent number to use as a value name.
//
//  Arguments:
//      pszAgentName [in]      Name of agent being added
//      pdwNumber    [out]     New agent number to use.
//
//  Returns:    S_OK if successful, S_FALSE if agent already exists, or
//              WIN32 error code otherwise.
//
//  Author:     danielwe   8 Apr 1997
//
//  Notes:
//
HRESULT HrGetNextAgentNumber(PCWSTR pszAgentName, DWORD *pdwNumber)
{
    HRESULT         hr = S_OK;
    HKEY            hkeyEnum;
    DWORD           dwIndex = 0;

    Assert(pdwNumber);

    *pdwNumber = 0;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szAgentsKeyAbs, KEY_READ,
                        &hkeyEnum);
    if (S_OK == hr)
    {
        // Enumerate all values.
        do
        {
            WCHAR   szValueName [_MAX_PATH];
            DWORD   cchValueName = celems (szValueName);
            DWORD   dwType;

            hr = HrRegEnumValue(hkeyEnum, dwIndex,
                                szValueName, &cchValueName,
                                &dwType, NULL, 0);
            if (S_OK == hr)
            {
                // Verify the type. If it's not correct, though,
                // we'll ignore the key. No sense failing the entire install
                // (RAID 370702)
                //
                if (REG_SZ == dwType)
                {
                    tstring     strAgent;

                    hr = HrRegQueryString(hkeyEnum, szValueName, &strAgent);
                    if (S_OK == hr)
                    {
                        if (strAgent.find(pszAgentName, 0) != tstring::npos)
                        {
                            hr = S_FALSE;
                        }
                    }
                }
                else
                {
                    // No sense failing the install, but it's still wrong, so
                    // assert
                    //
                    AssertSz(REG_SZ == dwType,
                             "HrGetNextAgentNumber: Expected a type of REG_SZ.");
                }
            }
            else if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hr)
            {
                hr = S_OK;
                break;
            }

            dwIndex++;
        }
        while (hr == S_OK);

        RegCloseKey(hkeyEnum);
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        // danielwe: 403774 - If key doesn't exist, SNMP isn't installed so
        // we should not continue.
        hr = S_FALSE;
    }

    if (S_OK == hr)
    {
        *pdwNumber = dwIndex + 1;
    }

    TraceError("HrGetNextAgentNumber", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrAddSNMPAgent
//
//  Purpose:    Adds a service as an SNMP agent.
//
//  Arguments:
//      pszServiceName [in]  Name of service to add (i.e. "WINS")
//      pszAgentName   [in]  Name of the agent to add (i.e. "WINSMibAgent")
//      pszAgentPath   [in]  Path to where the agent DLL lives.
//                           (i.e. "%SystemRoot%\System32\winsmib.dll")
//
//  Returns:    S_OK if successful, WIN32 error code otherwise.
//
//  Author:     danielwe   8 Apr 1997
//
//  Notes:
//
HRESULT HrAddSNMPAgent(PCWSTR pszServiceName, PCWSTR pszAgentName,
                       PCWSTR pszAgentPath)
{
    HRESULT         hr = S_OK;
    HKEY            hkeySNMP;
    HKEY            hkeyService;
    HKEY            hkeyServices;
    DWORD           dwNum;

    SNMP_REG_DATA   srd = {pszAgentPath, const_cast<PCWSTR>(c_szEmpty),
                           const_cast<PCWSTR>(c_szEmpty)};

    tstring         strKeyAgentName;
    tstring         strKeyAgentNameCurVer;
    tstring         strKeyAgentNameParams;

    // Open HKEY_LOCAL_MACHINE\System\CCS\Services key
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyServices,
                        KEY_READ_WRITE, &hkeyServices);
    if (SUCCEEDED(hr))
    {
        // Open Services\SNMP key
        hr = HrRegOpenKeyEx(hkeyServices, c_szSNMP, KEY_READ_WRITE,
                            &hkeySNMP);
        if (SUCCEEDED(hr))
        {
            hr = HrGetNextAgentNumber(pszAgentName, &dwNum);
            if (S_OK == hr)
            {
                // Open the Services\szService key
                hr = HrRegOpenKeyEx(hkeyServices, pszServiceName,
                                    KEY_READ_WRITE, &hkeyService);
                if (SUCCEEDED(hr))
                {
                    // Create key name: "SOFTWARE\Microsoft\<AgentName>
                    strKeyAgentName = c_szSoftwareKey;
                    strKeyAgentName.append(c_szBackslash);
                    strKeyAgentName.append(pszAgentName);

                    // Create key name: "SNMP\Parameters\\<AgentName>
                    strKeyAgentNameParams = c_szSNMPParams;
                    strKeyAgentNameParams.append(c_szBackslash);
                    strKeyAgentNameParams.append(pszAgentName);

                    // Create key name: "SOFTWARE\Microsoft\<AgentName>\CurrentVersion
                    // Start with "SOFTWARE\Microsoft\<AgentName> and append a
                    // backslash and then the constant "CurrentVersion"
                    strKeyAgentNameCurVer = strKeyAgentName;
                    strKeyAgentNameCurVer.append(c_szBackslash);
                    strKeyAgentNameCurVer.append(c_szCurrentVersion);

                    static const WCHAR c_szFmt[] = L"%lu";
                    WCHAR   szAgentNumber[64];

                    wsprintfW(szAgentNumber, c_szFmt, dwNum);
                    srd.pszExtAgentValueName = strKeyAgentNameCurVer.c_str();

                    REGBATCH rbSNMPData[] =
                    {
                        {                   // Software\Microsoft\AgentName
                            HKEY_LOCAL_MACHINE,
                            strKeyAgentName.c_str(),
                            c_szEmpty,
                            REG_CREATE,     // Only create the key
                            offsetof(SNMP_REG_DATA, pszEmpty),
                            NULL
                        },
                        {                   // Software\Microsoft\AgentName\CurrentVersion
                            HKEY_LOCAL_MACHINE,
                            strKeyAgentNameCurVer.c_str(),
                            c_szPathName,
                            REG_EXPAND_SZ,
                            offsetof(SNMP_REG_DATA, pszAgentPath),
                            NULL
                        },
                        {                   // SNMP\Parameters\ExtensionAgents
                            HKLM_SVCS,
                            c_szAgentsKey,
                            szAgentNumber,
                            REG_SZ,
                            offsetof(SNMP_REG_DATA, pszExtAgentValueName),
                            NULL
                        },
                    };

                    hr = HrRegWriteValues(celems(rbSNMPData),
                                          reinterpret_cast<const REGBATCH *>
                                          (&rbSNMPData),
                                          reinterpret_cast<const BYTE *>(&srd),
                                          0, KEY_READ_WRITE);

                    RegCloseKey(hkeyService);
                }
                else
                {
                    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                    {
                        // Ok if Service key does not exist. Means it is not
                        // installed so we do nothing and return S_OK;
                        hr = S_OK;
                    }
                }

            }

            RegCloseKey(hkeySNMP);
        }
        else
        {
            if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                // Ok if SNMP key does not exist. Means it is not installed
                // so we do nothing and return S_OK;
                hr = S_OK;
            }
        }

        RegCloseKey(hkeyServices);
    }

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    TraceError("HrAddSNMPAgent", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveSNMPAgent
//
//  Purpose:    Removes a component as an SNMP agent
//
//  Arguments:
//      pszAgentName [in]    Name of agent to remove (i.e. WINSMibAgent)
//
//  Returns:    S_OK for success, WIN32 error otherwise
//
//  Author:     danielwe   28 Apr 1997
//
//  Notes:      Note that *ALL* entries related to this agent are removed, not
//              just the first one.
//
HRESULT HrRemoveSNMPAgent(PCWSTR pszAgentName)
{
    HRESULT     hr = S_OK;
    tstring     strKeyAgentName;
    tstring     strKeyAgentNameParams;

    // Create key name: "SOFTWARE\Microsoft\<AgentName>
    strKeyAgentName = c_szSoftwareKey;
    strKeyAgentName.append(c_szBackslash);
    strKeyAgentName.append(pszAgentName);

    // Delete entire registry tree under SOFTWARE\Microsoft\<agent name>
    hr = HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, strKeyAgentName.c_str());
    if (SUCCEEDED(hr))
    {
        // Delete key:
        // "SYSTEM\CurrentControlSet\Services\SNMP\Parameters\\<AgentName>
        strKeyAgentNameParams = c_szParamsKeyAbs;
        strKeyAgentNameParams.append(c_szBackslash);
        strKeyAgentNameParams.append(pszAgentName);

        hr = HrRegDeleteKey(HKEY_LOCAL_MACHINE, strKeyAgentNameParams.c_str());
        if (SUCCEEDED(hr))
        {
            HKEY    hkeyEnum;

            hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szAgentsKeyAbs,
                                KEY_READ_WRITE_DELETE, &hkeyEnum);
            if (SUCCEEDED(hr))
            {
                DWORD   dwIndex = 0;

                // Enumerate all values.
                do
                {
                    WCHAR   szValueName [_MAX_PATH];
                    DWORD   cchValueName = celems (szValueName);
                    DWORD   dwType;
                    WCHAR   szValueData[_MAX_PATH];
                    DWORD   cchValueData = celems (szValueData);

                    hr = HrRegEnumValue(hkeyEnum, dwIndex,
                                        szValueName, &cchValueName,
                                        &dwType,
                                        reinterpret_cast<LPBYTE>(szValueData),
                                        &cchValueData);
                    if (SUCCEEDED(hr))
                    {
                        // It's type should be REG_SZ
                        AssertSz(REG_SZ == dwType,
                                 "HrGetNextAgentNumber: Expected a type of "
                                 "REG_SZ.");
                        if (FIsSubstr(pszAgentName, szValueData))
                        {
                            // Delete value if the agent name is found in the
                            // data. Don't break though, because there may be
                            // duplicates for some reason so this will delete
                            // those as well.
                            hr = HrRegDeleteValue(hkeyEnum, szValueName);
                        }
                    }
                    else if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hr)
                    {
                        hr = S_OK;
                        break;
                    }

                    dwIndex++;
                }
                while (SUCCEEDED(hr));

                RegCloseKey(hkeyEnum);
            }
        }
    }

    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        // Ignore any errors about registry keys or values missing. We don't
        // want them there anyway so if they're not, who cares!?!?
        hr = S_OK;
    }

    TraceError("HrRemoveSNMPAgent", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncoc\ncsnmp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S N M P . H
//
//  Contents:   Functions for adding a service as an SNMP agent.
//
//  Notes:
//
//  Author:     danielwe   8 Apr 1997
//
//----------------------------------------------------------------------------

#ifndef _NCSNMP_H
#define _NCSNMP_H
#pragma once

HRESULT HrGetNextAgentNumber(PCWSTR pszAgentName, DWORD *pdwNumber);
HRESULT HrAddSNMPAgent(PCWSTR pszServiceName, PCWSTR pszAgentName,
                       PCWSTR pszAgentPath);
HRESULT HrRemoveSNMPAgent(PCWSTR pszAgentName);

#endif //! _NCSNMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncoc\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <windows.h>
#include <objbase.h>

#include <setupapi.h>
#include <stdio.h>
#include <tchar.h>

#include "stllist.h"
#include "stlvec.h"
using namespace std;

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncras\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOGDI
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSERVICE
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <windows.h>
#include <objbase.h>

#include <stdio.h>
#include <wchar.h>

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\nctraceui\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSERVICE
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <windows.h>
#include <objbase.h>

#include <commctrl.h>
#include <shellapi.h>

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\nctraceui\resource.h ===
#define IDD_TRACETAGS                   60000
#define IDD_DBGFLAGS                    60001

// TraceTags page
//
#define IDC_TRACETAGS                   61000
#define IDC_CB_TT_VERBOSE               61001
#define IDC_B_TT_ENABLE                 61002
#define IDC_B_TT_DISABLE                61003
#define IDC_B_TT_ENABLE_ALL             61004
#define IDC_B_TT_DISABLE_ALL            61005
#define IDC_E_TT_LOGFILE_PATH           61006
#define IDC_TT_BROWSE                   61007

// DebugFlags page
//
#define IDC_DBGFLAGS                    61100
#define IDC_B_DF_ENABLE                 61101
#define IDC_B_DF_DISABLE                61102


// Bitmap defines
//
#define IDB_TRACE_CHECKSTATE            62001

#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\nctraceui\flagspage.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T A G S P A G E . C P P
//
//  Contents:   TraceTags propsheet page handlers
//
//  Notes:
//
//  Author:     jeffspr   24 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#ifdef ENABLETRACE

#include <crtdbg.h>
#include "ncdebug.h"
#include <ncui.h>
#include "traceui.h"


//---[ Globals ]--------------------------------------------------------------

#if 0
typedef struct _LV_COLUMN {
    UINT mask;
    int fmt;
    int cx;
    PWSTR pszText;
    int cchTextMax;
    int iSubItem;
} LV_COLUMN;
#endif

//      | :---------    CHAR []     szShortName
//      | | :-------    CHAR []     szDescription
//      | | |           BOOL        fOutputDebugString -----------------------------:
//      | | |           BOOL        fOutputToFile ----------------------------------|---:
//      | | |           BOOL        fVerboseOnly------------------------------------|---|---:

#define LVCF_NORMAL (LVCF_FMT | LVCF_TEXT | LVCF_WIDTH)

static LV_COLUMN    g_lvcTags[] =
{
    {LVCF_NORMAL,   LVCFMT_LEFT,    30, L"Name",           0,  0},
    {LVCF_NORMAL,   LVCFMT_LEFT,    60, L"Description",    0,  0},
    {LVCF_NORMAL,   LVCFMT_LEFT,    30, L"Debug Logging",  0,  0},
    {LVCF_NORMAL,   LVCFMT_LEFT,    30, L"File Logging",   0,  0}
};

const DWORD g_dwTagColumnCount = celems(g_lvcTags);

static const UINT SELS_UNCHECKED     = 0x1;
static const UINT SELS_CHECKED       = 0x2;


CDbgFlagPage::CDbgFlagPage()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::~CDbgFlagPage
//
//  Purpose:    Destroys the CDbgFlagPage object
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   25 Feb 1998
//
//  Notes:
//
CDbgFlagPage::~CDbgFlagPage()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnInitDialog
//
//  Purpose:    Handles the WM_INITDIALOG message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& bHandled)
{
    HRESULT             hr = S_OK;

    m_hwndLV = GetDlgItem(IDC_TRACETAGS);

    hr = HrInitTraceListView(m_hwndLV, &m_hilCheckIcons);

    for(DWORD dwLoop = 0; dwLoop < g_dwTagColumnCount; dwLoop++)
    {
        ListView_InsertColumn(m_hwndLV,dwLoop+1,&(g_lvcTags[dwLoop]));
    }

    LV_ITEM lvi = {0};

    lvi.mask = LVIF_TEXT | LVIF_IMAGE |
               LVIF_STATE | LVIF_PARAM;

    INT nIndex =0;

#if 0
    // Get the component's class image list index
    if (pcild)
    {
        hr = HrSetupDiGetClassImageIndex(pcild, &guidClass, &nIndex);
        TraceError("HrSetupDiGetClassImageIndex failed.", hr);

        lvi.iImage = nIndex;

        hr = S_OK;
    }

    lvi.iItem = *pnPos;
#endif
    lvi.iItem = 0;
#if 0
    NET_ITEM_DATA * pnid = new NET_ITEM_DATA;
    pnid->szwName = SzDupSz(pszwName);
    pnid->szwDesc = SzDupSz(pszwDesc);
    pnid->dwFlags = dwFlags;
    AddRefObj(pnid->pncc = pncc);

    pnid->pCompObj = new CComponentObj(pncc);
    hr = pnid->pCompObj->HrInit(plistBindingPaths);

    if FAILED(hr)
    {
        TraceError("HrInsertComponent: failed to initialize a component object", hr);
        hr = S_OK;
    }

    lvi.lParam = reinterpret_cast<LPARAM>(pnid);
    lvi.pszText = pnid->szwName;
#endif
    lvi.lParam = 0;
    lvi.pszText = L"Hey, Jude";

    // We will refresh the state of the whole list in the end
    UINT iChkIndex = SELS_CHECKED;
    lvi.state = INDEXTOSTATEIMAGEMASK( iChkIndex );

    INT ret;
    ret = ListView_InsertItem(m_hwndLV, &lvi);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnHelp
//
//  Purpose:    Handles the WM_HELP message.
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     danielwe   25 Feb 1998
//
//  Notes:
//
LRESULT CDbgFlagPage::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,
                            BOOL& bHandled)
{
    OnTraceHelpGeneric(m_hWnd, lParam);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnDestroy
//
//  Purpose:    Called when the dialog page is destroyed
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   2 Feb 1998
//
//  Notes:
//
LRESULT CDbgFlagPage::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam,
                               BOOL& bHandled)
{
    UninitTraceListView(m_hwndLV);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnSetCursor
//
//  Purpose:    Called in response to the WM_SETCURSOR message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   2 Jan 1998
//
//  Notes:
//
LRESULT CDbgFlagPage::OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                 BOOL& bHandled)
{
    if (m_hPrevCurs)
    {
        if (LOWORD(lParam) == HTCLIENT)
        {
            SetCursor(LoadCursor(NULL, IDC_WAIT));
        }

        return TRUE;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnAdd
//
//  Purpose:    Handles the clicking of the Add button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                           BOOL& bHandled)
{
    HRESULT     hr = S_OK;

#if 0
    hr = HrLvAdd(m_hwndLV, m_hWnd, m_pnc, m_pnccAdapter, &m_listBindingPaths);
    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        // Change the Cancel Button to CLOSE (because we committed changes)
        //
        ::PostMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
    }

    if (NETCFG_S_REBOOT == hr)
    {
        RequestReboot();

        // The reboot request has been handled
        hr = S_OK;
    }

    TraceError("CDbgFlagPage::OnAdd", hr);
#endif
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnRemove
//
//  Purpose:    Handles the clicking of the Remove button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                              BOOL& bHandled)
{
    HRESULT     hr = S_OK;
#if 0
    hr = HrLvRemove(m_hwndLV, m_hWnd, m_pnc, m_pnccAdapter,
                    &m_listBindingPaths);

    // if list is empty, reset the buttons
    if (0 == ListView_GetItemCount(m_hwndLV))
    {
        // Reset the buttons and the description text based on the changed selection
        LvSetButtons(m_handles);
    }

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        // Change the Cancel Button to CLOSE (because we committed changes)
        //
        ::PostMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
    }

    if (NETCFG_S_REBOOT == hr)
    {
        RequestReboot();

        // The reboot request has been handled
        hr = S_OK;
    }

    TraceError("CDbgFlagPage::OnRemove", hr);
#endif
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnProperties
//
//  Purpose:    Handles the clicking of the Properties button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                  BOOL& bHandled)
{
    HRESULT     hr = S_OK;
#if 0
    hr = HrLvProperties(m_hwndLV, m_hWnd, m_pnc, m_punk,
                        m_pnccAdapter, &m_listBindingPaths);

    TraceError("CDbgFlagPage::OnProperties", hr);
#endif
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnApply
//
//  Purpose:    Called when the Networking page is applied
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr = S_OK;

#if 0
    if (m_fReentrancyCheck)
    {
        TraceTag(ttidLanUi, "CDbgFlagPage::OnApply is being re-entered! "
                 "I'm outta here!");

        // Don't allow the automatic EndDialog() to work just yet
        SetWindowLong(DWLP_MSGRESULT, PSNRET_INVALID);
        return TRUE;
    }

    m_hPrevCurs = SetCursor(LoadCursor(NULL, IDC_WAIT));

    hr = m_pnc->Validate();
    if (hr == S_OK)
    {
        BOOL    fReboot = FALSE;

        // Note: This function becomes reentrant because INetCfg::Apply()
        // has a message pump in it which causes the PSN_APPLY message to
        // be processed twice. This will happen ONLY if the user double-clicks
        // the OK button.
        m_fReentrancyCheck = TRUE;

        TraceTag(ttidLanUi, "Calling INetCfg::Apply()");
        hr = m_pnc->Apply();
        if (NETCFG_S_REBOOT == hr)
        {
            fReboot = TRUE;
        }

        if (SUCCEEDED(hr))
        {
            TraceTag(ttidLanUi, "INetCfg::Apply() succeeded");
            hr = m_pnc->Uninitialize();
        }

        if (SUCCEEDED(hr))
        {
            if (m_fRebootAlreadyRequested || fReboot)
            {
                DWORD dwFlags = QUFR_REBOOT;
                if (!m_fRebootAlreadyRequested)
                    dwFlags |= QUFR_PROMPT;

                (VOID) HrNcQueryUserForReboot(_Module.GetResourceInstance(),
                                              m_hWnd, IDS_LAN_CAPTION,
                                              IDS_REBOOT_REQUIRED,
                                              dwFlags);
            }
        }
    }

    // Apply "general" properties
    //
    if (SUCCEEDED(hr))
    {
        LANCON_INFO linfo = {0};

        linfo.fShowIcon = IsDlgButtonChecked(IDC_CHK_ShowIcon);

        // Set new value of show icon property
        hr = m_plan->SetInfo(LCIF_ICON, &linfo);
    }

    // Normalize result
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    if (m_hPrevCurs)
    {
        SetCursor(m_hPrevCurs);
        m_hPrevCurs = NULL;
    }

    // Reset this just in case
    m_fReentrancyCheck = FALSE;

    TraceError("CDbgFlagPage::OnApply", hr);
#endif
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnCancel
//
//  Purpose:    Called when the Networking page is cancelled.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   3 Jan 1998
//
//  Notes:
//
LRESULT CDbgFlagPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr = S_OK;
#if 0
    AssertSz(m_pnc, "I need a NetCfg object!");

    hr = m_pnc->Uninitialize();

    TraceError("CDbgFlagPage::OnCancel", hr);
#endif
    return LresFromHr(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnDeleteItem
//
//  Purpose:    Called when the LVN_DELETEITEM message is received
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   3 Nov 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);
#if 0
    LvDeleteItem(m_hwndLV, pnmlv->iItem);
#endif
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnClick
//
//  Purpose:    Called in response to the NM_CLICK message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
#if 0
    OnListClick(m_hwndLV, m_hWnd, m_pnc, m_punk,
                        m_pnccAdapter, &m_listBindingPaths, FALSE);
#endif
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnDbClick
//
//  Purpose:    Called in response to the NM_DBLCLK message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
#if 0
    OnListClick(m_hwndLV, m_hWnd, m_pnc, m_punk,
                m_pnccAdapter, &m_listBindingPaths, TRUE);
#endif
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnKeyDown
//
//  Purpose:    Called in response to the LVN_KEYDOWN message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    LV_KEYDOWN* plvkd = (LV_KEYDOWN*)pnmh;
#if 0
    OnListKeyDown(m_hwndLV, &m_listBindingPaths, plvkd->wVKey);
#endif
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDbgFlagPage::OnItemChanged
//
//  Purpose:    Called when the LVN_ITEMCHANGED message is received
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   10 Nov 1997
//
//  Notes:
//
LRESULT CDbgFlagPage::OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);
#if 0
    HANDLES         handles;

    Assert(pnmlv);

    // Reset the buttons and the description text based on the changed selection
    LvSetButtons(m_handles);
#endif
    return 0;
}

#endif // ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\ncras\ncras.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R A S . C P P
//
//  Contents:   Common code for RAS connections.
//
//  Notes:
//
//  Author:     shaunco   20 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncnetcon.h"
#include "ncras.h"
#include "ncstring.h"
#include <raserror.h>
#include "mprapi.h"
//+---------------------------------------------------------------------------
//
//  Function:   RciFree
//
//  Purpose:    Frees the memory associated with a RASCON_INFO strucutre.
//
//  Arguments:
//      pRasConInfo [in]    Pointer to RASCON_INFO structure to free.
//
//  Returns:    nothing
//
//  Author:     shaunco   21 Sep 1997
//
//  Notes:      CoTaskMemAlloc/CoTaskMemFree are used as the allocator/
//              deallocator because this structure is marshalled by COM.
//
VOID
RciFree (
    RASCON_INFO* pRasConInfo)
{
    Assert (pRasConInfo);

    CoTaskMemFree (pRasConInfo->pszwPbkFile);
    CoTaskMemFree (pRasConInfo->pszwEntryName);

    ZeroMemory (pRasConInfo, sizeof (*pRasConInfo));
}

//+---------------------------------------------------------------------------
//
//  Function:   FExistActiveRasConnections
//
//  Purpose:    Returns TRUE if there is at least one active RAS connection.
//              Both incoming and outgoing connections are checked.
//
//  Arguments:
//      (none)
//
//  Returns:    TRUE if at least one incoming or outgoing RAS connection
//              in progress.  FALSE if not.
//
//  Author:     shaunco   8 Jul 1998
//
//  Notes:
//
BOOL
FExistActiveRasConnections ()
{
    BOOL              fExist         = FALSE;
    RASCONN           RasConn;
    DWORD             dwErr;
    DWORD             cbBuf;
    DWORD             cConnections;

    ZeroMemory (&RasConn, sizeof(RasConn));
    RasConn.dwSize = sizeof(RasConn);
    cbBuf = sizeof(RasConn);
    cConnections = 0;
    dwErr = RasEnumConnections (&RasConn, &cbBuf, &cConnections);
    if ((ERROR_SUCCESS == dwErr) || (ERROR_BUFFER_TOO_SMALL == dwErr))
    {
        fExist = (cbBuf > 0) || (cConnections > 0);
    }

    // If no outgoing connections active, check on incoming ones.
    //
    if (!fExist)
    {
        MPR_SERVER_HANDLE hMprServer;
        LPBYTE            lpbBuf         = NULL;
        DWORD             dwEntriesRead  = 0;
        DWORD             dwTotalEntries = 0;

        ZeroMemory (&hMprServer, sizeof(hMprServer));
        //get a handle to the local router ie. name = NULL
        dwErr = MprAdminServerConnect( NULL, &hMprServer );
        if (ERROR_SUCCESS == dwErr)
        {
            //retrieve a pointer to buffer containing all
            //incoming connections (ie dwPrefMaxLen = -1) and
            //the their count ( ie. dwTotalEntries ) 
            dwErr = MprAdminConnectionEnum( hMprServer,
                                            0,
                                            &lpbBuf,
                                            (DWORD)-1,
                                            &dwEntriesRead,
                                            &dwTotalEntries,
                                            NULL );
            if (ERROR_SUCCESS == dwErr)
            {
                fExist = (dwTotalEntries > 0);
            }
            // close the handle to the router
            MprAdminServerDisconnect( hMprServer );
        }
    }

    return fExist;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRciGetRasConnectionInfo
//
//  Purpose:    QI an INetConnection pointer for INetRasConnection and make
//              a call to GetRasConnectionInfo on it.
//
//  Arguments:
//      pCon        [in]    The connection to QI and call.
//      pRasConInfo [out]   The returned information.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   15 Nov 1997
//
//  Notes:
//
HRESULT
HrRciGetRasConnectionInfo (
    INetConnection* pCon,
    RASCON_INFO*    pRasConInfo)
{
    INetRasConnection* pRasCon;
    HRESULT hr = HrQIAndSetProxyBlanket(pCon, &pRasCon);
    if (S_OK == hr)
    {
        // Make the call to get the info and release the interface.
        //
        hr = pRasCon->GetRasConnectionInfo (pRasConInfo);

        ReleaseObj (pRasCon);
    }
    TraceError ("HrRciGetRasConnectionInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasEnumAllActiveConnections
//
//  Purpose:    Enumerate and return all active RAS connections.
//
//  Arguments:
//      paRasConn [out] Pointer to returned allocation of RASCONN structures.
//      pcRasConn [out] Pointer to count of RASCONN structures returned.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   23 Sep 1997
//
//  Notes:      The returned buffer must be freed using free.
//
HRESULT
HrRasEnumAllActiveConnections (
    RASCONN**   paRasConn,
    DWORD*      pcRasConn)
{
    // Allocate room for two active connections initially.  We'll update
    // this guess after we successfully allocate and find out how much was
    // really needed.  Saving it across calls will keep us from allocating
    // too much or too little.
    //
    static DWORD cbBufGuess = 2 * sizeof (RASCONN);

    DWORD   cbBuf = cbBufGuess;
    BOOL    fRetry = TRUE;

    // Initialize the output parameters.
    //
    *paRasConn = NULL;
    *pcRasConn = NULL;

    // Allocate cbBuf bytes.
    //
allocate:
    HRESULT hr = E_OUTOFMEMORY;
    RASCONN* aRasConn = reinterpret_cast<RASCONN*>(MemAlloc (cbBuf));
    if (aRasConn)
    {
        aRasConn->dwSize = sizeof (RASCONN);

        DWORD cRasConn;
        DWORD dwErr = RasEnumConnections (aRasConn, &cbBuf, &cRasConn);
        hr = HRESULT_FROM_WIN32 (dwErr);

        if (SUCCEEDED(hr))
        {
            // Update our guess for next time to be one more than we got back
            // this time.
            //
            cbBufGuess = cbBuf + sizeof (RASCONN);

            if (cRasConn)
            {
                *paRasConn = aRasConn;
                *pcRasConn = cRasConn;
            }
            else
            {
                MemFree (aRasConn);
            }
        }
        else
        {
            MemFree (aRasConn);

            if (ERROR_BUFFER_TOO_SMALL == dwErr)
            {
                TraceTag (ttidWanCon, "Perf: Guessed buffer size incorrectly "
                    "calling RasEnumConnections.\n"
                    "   Guessed %d, needed %d.", cbBufGuess, cbBuf);

                // In case RAS makes more calls by the time we get back
                // to enumerate with the bigger buffer, add room for a few
                // more.
                //
                cbBuf += 2 * sizeof (RASCONN);

                // Protect from an infinte loop by only retrying once.
                //
                if (fRetry)
                {
                    fRetry = FALSE;
                    goto allocate;
                }
            }
        }
    }

    TraceError ("HrRasEnumAllActiveConnections", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasEnumAllActiveServerConnections
//
//  Purpose:    Enumerate and return all active RAS server connections.
//
//  Arguments:
//      paRasSrvConn [out]  Pointer to returned allocation of RASSRVCONN
//                          structures.
//      pcRasSrvConn [out]  Pointer to count of RASSRVCONN structures
//                          returned.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   12 Nov 1997
//
//  Notes:      The returned buffer must be freed using free.
//
HRESULT
HrRasEnumAllActiveServerConnections (
    RASSRVCONN**    paRasSrvConn,
    DWORD*          pcRasSrvConn)
{
    // Allocate room for two active connections initially.  We'll update
    // this guess after we successfully allocate and find out how much was
    // really needed.  Saving it across calls will keep us from allocating
    // too much or too little.
    //
    static DWORD cbBufGuess = 2 * sizeof (RASSRVCONN);

    DWORD   cbBuf = cbBufGuess;
    BOOL    fRetry = TRUE;

    // Initialize the output parameters.
    //
    *paRasSrvConn = NULL;
    *pcRasSrvConn = NULL;

    // Allocate cbBuf bytes.
    //
allocate:
    HRESULT hr = E_OUTOFMEMORY;
    RASSRVCONN* aRasSrvConn = reinterpret_cast<RASSRVCONN*>(MemAlloc (cbBuf));
    if (aRasSrvConn)
    {
        aRasSrvConn->dwSize = sizeof (RASSRVCONN);

        DWORD cRasSrvConn;
        DWORD dwErr = RasSrvEnumConnections (aRasSrvConn, &cbBuf, &cRasSrvConn);
        hr = HRESULT_FROM_WIN32 (dwErr);

        if (SUCCEEDED(hr))
        {
            // Update our guess for next time to be one more than we got back
            // this time.
            //
            cbBufGuess = cbBuf + sizeof (RASSRVCONN);

            if (cRasSrvConn)
            {
                *paRasSrvConn = aRasSrvConn;
                *pcRasSrvConn = cRasSrvConn;
            }
            else
            {
                MemFree (aRasSrvConn);
            }
        }
        else
        {
            MemFree (aRasSrvConn);

            if (ERROR_BUFFER_TOO_SMALL == dwErr)
            {
                TraceTag (ttidWanCon, "Perf: Guessed buffer size incorrectly "
                    "calling RasSrvEnumConnections.\n"
                    "   Guessed %d, needed %d.", cbBufGuess, cbBuf);

                // In case RAS makes more calls by the time we get back
                // to enumerate with the bigger buffer, add room for a few
                // more.
                //
                cbBuf += 2 * sizeof (RASSRVCONN);

                // Protect from an infinte loop by only retrying once.
                //
                if (fRetry)
                {
                    fRetry = FALSE;
                    goto allocate;
                }
            }
        }
    }

    TraceError ("HrRasEnumAllActiveServerConnections", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasEnumAllEntriesWithDetails
//
//  Purpose:    Enumerate and return all RAS entries in a phone book.
//
//  Arguments:
//      pszPhonebook      [in]  Phonebook file to use.
//      paRasEntryDetails [out] Pointer to returned allocation of
//                              RASENUMENTRYDETAILS structures.
//      pcRasEntryDetails [out] Pointer to count of RASENUMENTRYDETAILS
//                              structures returned.
//
//  Returns:    S_OK, S_FALSE if no entries, or an error code.
//
//  Author:     shaunco   2 Oct 1997
//
//  Notes:      The returned buffer must be freed using free.
//
HRESULT
HrRasEnumAllEntriesWithDetails (
    PCWSTR                  pszPhonebook,
    RASENUMENTRYDETAILS**   paRasEntryDetails,
    DWORD*                  pcRasEntryDetails)
{
    // Allocate room for five entry names initially.  We'll update
    // this guess after we successfully allocate and find out how much was
    // really needed.  Saving it across calls will keep us from allocating
    // too much or too little.
    //
    static DWORD cbBufGuess = 5 * sizeof (RASENUMENTRYDETAILS);

    DWORD   cbBuf = cbBufGuess;
    BOOL    fRetry = TRUE;

    // Initialize the output parameters.
    //
    *paRasEntryDetails = NULL;
    *pcRasEntryDetails = 0;

    // Allocate cbBuf bytes.
    //
allocate:
    HRESULT hr = E_OUTOFMEMORY;
    RASENUMENTRYDETAILS* aRasEntryDetails =
        reinterpret_cast<RASENUMENTRYDETAILS*>(MemAlloc (cbBuf));
    if (aRasEntryDetails)
    {
        ZeroMemory(aRasEntryDetails, cbBuf);
        aRasEntryDetails->dwSize = sizeof (RASENUMENTRYDETAILS);

        DWORD cRasEntryDetails;
        DWORD dwErr = DwEnumEntryDetails (
                        pszPhonebook,
                        aRasEntryDetails,
                        &cbBuf, &cRasEntryDetails);
        hr = HRESULT_FROM_WIN32 (dwErr);

        if (SUCCEEDED(hr))
        {
            // Update our guess for next time to be one more than we got back
            // this time.
            //
            cbBufGuess = cbBuf + sizeof (RASENUMENTRYDETAILS);

            if (cRasEntryDetails)
            {
                *paRasEntryDetails = aRasEntryDetails;
                *pcRasEntryDetails = cRasEntryDetails;
            }
            else
            {
                MemFree (aRasEntryDetails);
                hr = S_FALSE;
            }
        }
        else
        {
            MemFree (aRasEntryDetails);

            if (ERROR_BUFFER_TOO_SMALL == dwErr)
            {
                TraceTag (ttidWanCon, "Perf: Guessed buffer size incorrectly "
                    "calling DwEnumEntryDetails.\n"
                    "   Guessed %d, needed %d.", cbBufGuess, cbBuf);

                // Protect from an infinte loop by only retrying once.
                //
                if (fRetry)
                {
                    fRetry = FALSE;
                    goto allocate;
                }
            }
        }
    }

    TraceError ("HrRasEnumAllEntriesWithDetails", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFindRasConnFromGuidId
//
//  Purpose:    Searches for the active RAS connection that corresponds to
//              the phone book entry given by a GUID.
//
//  Arguments:
//      pguid       [in]    Pointer to the GUID which identifies the entry.
//      phRasConn   [out]   The returned handle to the RAS connection if it
//                          was found.  NULL otherwise.
//      pRasConn    [out]   Optional pointer to returned RASCONN structure
//                          if found.
//
//  Returns:    S_OK if found, S_FALSE if not, or an error code.
//
//  Author:     shaunco   29 Sep 1997
//
//  Notes:
//
HRESULT
HrFindRasConnFromGuidId (
    IN const GUID* pguid,
    OUT HRASCONN* phRasConn,
    OUT RASCONN* pRasConn OPTIONAL)
{
    Assert (pguid);
    Assert (phRasConn);

    HRESULT hr;
    RASCONN* aRasConn;
    DWORD cRasConn;

    // Initialize the output parameter.
    //
    *phRasConn = NULL;

    hr = HrRasEnumAllActiveConnections (&aRasConn, &cRasConn);

    if (S_OK == hr)
    {
        hr = S_FALSE;

        for (DWORD i = 0; i < cRasConn; i++)
        {
            if (*pguid == aRasConn[i].guidEntry)
            {
                *phRasConn = aRasConn[i].hrasconn;

                if (pRasConn)
                {
                    CopyMemory (pRasConn, &aRasConn[i], sizeof(RASCONN));
                }

                hr = S_OK;
                break;
            }
        }

        MemFree (aRasConn);
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr, "HrFindRasConnFromGuidId");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasGetEntryProperties
//
//  Purpose:    Wrapper around RasGetEntryProperties that returns an HRESULT
//              and allocates the necessary memory automatically.
//
//  Arguments:
//      pszPhonebook  [in]
//      pszEntry      [in]
//      ppRasEntry    [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   6 Oct 1997
//
//  Notes:      The output parameters should be freed using free.
//
HRESULT
HrRasGetEntryProperties (
    PCWSTR          pszPhonebook,
    PCWSTR          pszEntry,
    RASENTRY**      ppRasEntry,
    DWORD*          pcbRasEntry)
{
    // Init the output parameter if provided.
    //
    if (pcbRasEntry)
    {
        *pcbRasEntry = 0;
    }

    // Allocate room for RASENTRY structure plus 256 bytes initially.
    // We'll update this guess after we successfully allocate and find out
    // how much was really needed.  Saving it across calls will keep us
    // from allocating too much or too little.
    //
    static DWORD cbBufGuess = sizeof (RASENTRY) + 256;

    DWORD   cbBuf = cbBufGuess;
    BOOL    fRetry = TRUE;

    // Initialize the output parameters.
    //
    *ppRasEntry = NULL;
    if (pcbRasEntry)
    {
        *pcbRasEntry = 0;
    }

    // Allocate cbBuf bytes.
    //
allocate:
    HRESULT hr = E_OUTOFMEMORY;
    RASENTRY* pRasEntry = reinterpret_cast<RASENTRY*>(MemAlloc (cbBuf));
    if (pRasEntry)
    {
        pRasEntry->dwSize = sizeof (RASENTRY);

        DWORD dwErr = RasGetEntryProperties (pszPhonebook, pszEntry,
                        pRasEntry, &cbBuf, NULL, NULL);
        hr = HRESULT_FROM_WIN32 (dwErr);

        if (SUCCEEDED(hr))
        {
            // Update our guess for next time to be a bit more than we
            // got back this time.
            //
            cbBufGuess = cbBuf + 256;

            *ppRasEntry = pRasEntry;
            if (pcbRasEntry)
            {
                *pcbRasEntry = cbBuf;
            }
        }
        else
        {
            MemFree (pRasEntry);

            if (ERROR_BUFFER_TOO_SMALL == dwErr)
            {
                TraceTag (ttidWanCon, "Perf: Guessed buffer size incorrectly "
                    "calling RasGetEntryProperties.\n"
                    "   Guessed %d, needed %d.", cbBufGuess, cbBuf);

                // Protect from an infinte loop by only retrying once.
                //
                if (fRetry)
                {
                    fRetry = FALSE;
                    goto allocate;
                }
            }
        }
    }

    TraceError ("HrRasGetEntryProperties", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasGetSubEntryProperties
//
//  Purpose:    Wrapper around RasGetSubEntryProperties that returns an HRESULT
//              and allocates the necessary memory automatically.
//
//  Arguments:
//      pszPhonebook  [in]
//      pszEntry      [in]
//      dwSubEntry    [in]
//      ppRasSubEntry [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     CWill   02/10/98
//
//  Notes:      The output parameters should be freed using free.
//
HRESULT
HrRasGetSubEntryProperties (
    PCWSTR          pszPhonebook,
    PCWSTR          pszEntry,
    DWORD           dwSubEntry,
    RASSUBENTRY**   ppRasSubEntry)
{
    // Allocate room for RASSUBENTRY structure plus 256 bytes initially.
    // We'll update this guess after we successfully allocate and find out
    // how much was really needed.  Saving it across calls will keep us
    // from allocating too much or too little.
    //
    static DWORD cbBufGuess = sizeof (RASSUBENTRY) + 256;

    DWORD   cbBuf = cbBufGuess;
    BOOL    fRetry = TRUE;

    // Initialize the output parameters.
    //
    *ppRasSubEntry = NULL;

    // Allocate cbBuf bytes.
    //
allocate:
    HRESULT hr = E_OUTOFMEMORY;
    RASSUBENTRY* pRasSubEntry = reinterpret_cast<RASSUBENTRY*>(MemAlloc (cbBuf));
    if (pRasSubEntry)
    {
        pRasSubEntry->dwSize = sizeof (RASSUBENTRY);

        DWORD dwErr = RasGetSubEntryProperties (pszPhonebook, pszEntry,
                    dwSubEntry, pRasSubEntry, &cbBuf, NULL, NULL);
        hr = HRESULT_FROM_WIN32 (dwErr);

        if (SUCCEEDED(hr))
        {
            // Update our guess for next time to be a bit more than we
            // got back this time.
            //
            cbBufGuess = cbBuf + 256;

            *ppRasSubEntry = pRasSubEntry;
        }
        else
        {
            MemFree (pRasSubEntry);

            if (ERROR_BUFFER_TOO_SMALL == dwErr)
            {
                TraceTag (ttidWanCon, "Perf: Guessed buffer size incorrectly "
                    "calling RasGetSubEntryProperties.\n"
                    "   Guessed %d, needed %d.", cbBufGuess, cbBuf);

                // Protect from an infinte loop by only retrying once.
                //
                if (fRetry)
                {
                    fRetry = FALSE;
                    goto allocate;
                }
            }
        }
    }

    TraceError ("HrRasGetSubEntryProperties", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasGetNetconStatusFromRasConnectStatus
//
//  Purpose:    Returns a NETCON_STATUS value given a handle to a RAS
//              connection by calling RasGetConnectStatus and mapping.
//
//  Arguments:
//      hRasConn [in]  Handle to the RAS connection.  (See Win32 RAS APIs.)
//      pStatus  [out] Pointer to where the NETCON_STATUS is returned.
//
//  Returns:    S_OK or an error code in the FACILITY_WIN32 facility.
//
//  Author:     shaunco   6 May 1998
//
//  Notes:
//
HRESULT
HrRasGetNetconStatusFromRasConnectStatus (
    HRASCONN        hRasConn,
    NETCON_STATUS*  pStatus)
{
    Assert (pStatus);

    // Initialize the output parameter.
    //
    *pStatus = NCS_DISCONNECTED;

    // Get its status and map it to our status.
    //
    RASCONNSTATUS RasConnStatus;
    ZeroMemory (&RasConnStatus, sizeof(RasConnStatus));
    RasConnStatus.dwSize = sizeof(RASCONNSTATUS);

    DWORD dwErr = RasGetConnectStatus (hRasConn, &RasConnStatus);

    HRESULT hr = HRESULT_FROM_WIN32 (dwErr);
    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE) == hr),
        "RasGetConnectStatus");

    if (S_OK == hr)
    {
        if (RasConnStatus.rasconnstate & RASCS_DONE)
        {
            if (RASCS_Disconnected != RasConnStatus.rasconnstate)
            {
                *pStatus = NCS_CONNECTED;
            }
        }
        else
        {
            *pStatus = NCS_CONNECTING;
        }
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE) == hr),
        "HrRasGetNetconStatusFromRasConnectStatus");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasHangupUntilDisconnected
//
//  Purpose:    Call RasHangup until the connection is disconnected.
//              Ras reference-counts RasDial/RasHangup, so this is called
//              when the connection needs to be dropped no matter what.
//              (For example, the behavior of disconnect from the shell
//              is to drop the connection regardless of who dialed it.)
//
//  Arguments:
//      hRasConn [in] The connection to disconnect.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   29 May 1999
//
HRESULT
HrRasHangupUntilDisconnected (
    IN HRASCONN hRasConn)
{
    HRESULT hr = E_UNEXPECTED;

    BOOL fDisconnectAgain;
    do
    {
        fDisconnectAgain = FALSE;

        // Hang up.
        //
        DWORD dwErr = RasHangUp (hRasConn);
        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceError ("RasHangUp", hr);

        if (SUCCEEDED(hr))
        {
            // Since the connection may be ref-counted, see if
            // it's still connected and, if it is, go back and
            // disconnect again.
            //
            HRESULT hrT;
            NETCON_STATUS Status;

            hrT = HrRasGetNetconStatusFromRasConnectStatus (
                    hRasConn,
                    &Status);

            if ((S_OK == hrT) && (NCS_CONNECTED == Status))
            {
                fDisconnectAgain = TRUE;

                TraceTag (ttidWanCon, "need to disconnect again...");
            }
        }
    } while (fDisconnectAgain);

    TraceHr (ttidError, FAL, hr, FALSE, "HrRasHangupUntilDisconnected");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasNetConToSharedConnection
//
//  Purpose:    Converts an 'INetConnection' to the format expected
//              by the RAS sharing API routines.
//
//  Arguments:
//      pCon          [in]
//      prcs          [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     AboladeG    05/14/98
//
//  Notes:
//
HRESULT
HrNetConToSharedConnection (
    INetConnection* pCon,
    LPRASSHARECONN  prsc)
{
    HRESULT hr;
    NETCON_PROPERTIES* pProps;
    hr = pCon->GetProperties(&pProps);
    if (SUCCEEDED(hr))
    {
        if (pProps->MediaType == NCM_LAN)
        {
            RasGuidToSharedConnection(&pProps->guidId, prsc);
        }
        else
        {
            INetRasConnection* pnrc;
            hr = HrQIAndSetProxyBlanket(pCon, &pnrc);
            if (SUCCEEDED(hr))
            {
                RASCON_INFO rci;
                hr = pnrc->GetRasConnectionInfo (&rci);
                if (SUCCEEDED(hr))
                {
                    RasEntryToSharedConnection (
                        rci.pszwPbkFile, rci.pszwEntryName, prsc );
                    RciFree (&rci);
                }
                ReleaseObj (pnrc);
            }
        }
        FreeNetconProperties(pProps);
    }
    TraceError ("HrRasNetConToSharedConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasIsSharedConnection
//
//  Purpose:    Wrapper around RasIsSharedConnection that returns an HRESULT.
//
//  Arguments:
//      prsc          [in]
//      pfShared      [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     AboladeG    05/04/98
//
//  Notes:
//
HRESULT
HrRasIsSharedConnection (
    LPRASSHARECONN  prsc,
    BOOL*           pfShared)
{
    *pfShared = FALSE;
    DWORD dwErr = RasIsSharedConnection (prsc, pfShared);
    HRESULT hr = HRESULT_FROM_WIN32 (dwErr);
    TraceError ("HrRasIsSharedConnection", hr);
    return hr;
}

#if 0

//+---------------------------------------------------------------------------
//
//  Function:   HrRasQueryLanConnTable
//
//  Purpose:    Wrapper around RasQueryLanConnTable that returns an HRESULT.
//
//  Arguments:
//      prsc          [in]
//      ppLanTable    [out,optional]
//      pdwLanCount   [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     AboladeG    05/14/98
//
//  Notes:
//
HRESULT
HrRasQueryLanConnTable (
    LPRASSHARECONN      prsc,
    NETCON_PROPERTIES** ppLanTable,
    LPDWORD             pdwLanCount)
{
    DWORD dwErr = RasQueryLanConnTable (prsc, (LPVOID*)ppLanTable, pdwLanCount);
    HRESULT hr = HRESULT_FROM_WIN32 (dwErr);
    TraceError ("HrRasQueryLanConnTable", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasShareConnection
//
//  Purpose:    Wrapper around RasShareConnection that returns an HRESULT.
//
//  Arguments:
//      prsc            [in]
//      pPrivateLanGuid [in,optional]
//
//  Returns:    S_OK or an error code.
//
//  Author:     AboladeG    05/14/98
//
//  Notes:
//
HRESULT
HrRasShareConnection (
    LPRASSHARECONN      prsc,
    GUID*               pPrivateLanGuid)
{
    DWORD dwErr = RasShareConnection (prsc, pPrivateLanGuid);
    HRESULT hr = HRESULT_FROM_WIN32 (dwErr);
    TraceError ("HrRasShareConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRasUnshareConnection
//
//  Purpose:    Wrapper around HrRasUnshareConnection that returns an HRESULT.
//
//  Arguments:
//      pfWasShared   [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     AboladeG    05/14/98
//
//  Notes:
//
HRESULT
HrRasUnshareConnection (
    PBOOL       pfWasShared)
{
    HRESULT hr;
    DWORD dwErr = RasUnshareConnection (pfWasShared);
    hr = HRESULT_FROM_WIN32 (dwErr);
    TraceError ("HrRasUnshareConnection", hr);
    return hr;
}

#endif

//+---------------------------------------------------------------------------
//
//  Function:   NcRasMsgBoxWithErrorText
//
//  Purpose:    Displays a message box using a RAS or Win32 error code,
//              resource strings and replaceable parameters.
//              The output text is a combination of the user's format
//              string (with parameter's replaced) and the Win32 error
//              text as returned from FormatMessage.  These two strings
//              are combined using the IDS_TEXT_WITH_WIN32_ERROR resource.
//
//  Arguments:
//      dwError     [in] RAS/Win32 error code
//      hinst       [in] Module instance where string resources live.
//      hwnd        [in] parent window handle
//      unIdCaption [in] resource id of caption string
//      unIdCombineFormat [in] resource id of format string to combine
//                              error text with unIdFormat text.
//      unIdFormat  [in] resource id of text string (with %1, %2, etc.)
//      unStyle     [in] standard message box styles
//      ...         [in] replaceable parameters (optional)
//                          (these must be PCWSTRs as that is all
//                          FormatMessage handles.)
//
//  Returns:    the return value of MessageBox()
//
//  Author:     aboladeg  15 May 1997
//
//  Notes:      FormatMessage is used to do the parameter substitution.
//
//  Revision:   based on NcMsgBoxWithWin32ErrorText by shaunco.
//
NOTHROW
int
WINAPIV
NcRasMsgBoxWithErrorText (
    DWORD       dwError,
    HINSTANCE   hinst,
    HWND        hwnd,
    UINT        unIdCaption,
    UINT        unIdCombineFormat,
    UINT        unIdFormat,
    UINT        unStyle,
    ...)
{
    // Get the user's text with parameter's replaced.
    //
    PCWSTR pszFormat = SzLoadString (hinst, unIdFormat);
    PWSTR  pszText;
    va_list val;
    va_start (val, unStyle);
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                   pszFormat, 0, 0, (PWSTR)&pszText, 0, &val);
    va_end(val);

    // Get the error text for the Win32 error.
    //
    PWSTR pszError = NULL;
    if (dwError < RASBASE || dwError > RASBASEEND)
    {
        FormatMessage (
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
            (PWSTR)&pszError, 0, NULL);
    }
    else
    {
        pszError = (PWSTR)LocalAlloc (0, (256 + 1) * sizeof(WCHAR));
        if (pszError)
        {
            RasGetErrorString(dwError, pszError, 256);
        }
    }

    // Combine the user's text with the error text using IDS_TEXT_WITH_WIN32_ERROR.
    //
    PCWSTR pszTextWithErrorFmt = SzLoadString (hinst, unIdCombineFormat);
    PWSTR  pszTextWithError;
    DwFormatStringWithLocalAlloc (pszTextWithErrorFmt, &pszTextWithError,
                                  pszText, pszError);

    PCWSTR pszCaption = SzLoadString (hinst, unIdCaption);
    int nRet = MessageBox(hwnd, pszTextWithError, pszCaption, unStyle);

    LocalFree (pszTextWithError);
    LocalFree (pszError);
    LocalFree (pszText);

    return nRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   RasSrvTypeFromRasDeviceType
//
//  Purpose:    Converts from RASDEVICETYPE into an accepted incoming type
//
//  Arguments:
//      rdt [in] the RasDeviceType
//
//  Returns:    RASSRVUI_Xxx type
//
//  Author:     ckotze      19 Apr 2001
//
//  Notes:
//
DWORD RasSrvTypeFromRasDeviceType(RASDEVICETYPE rdt)
{
    DWORD dwType = RASSRVUI_MODEM;
    
    TraceTag (ttidWanCon, "rdt:0x%08x,  dwType:0x%08x",
        rdt,
        dwType);
    
    switch (LOWORD(rdt))
    {
    case RDT_PPPoE:
        dwType = RASSRVUI_MODEM;
        break;
        
    case RDT_Modem:
    case RDT_X25:
        dwType = RASSRVUI_MODEM;
        break;
        
    case RDT_Isdn:
        dwType = RASSRVUI_MODEM;
        break;
        
    case RDT_Serial:
    case RDT_FrameRelay:
    case RDT_Atm:
    case RDT_Sonet:
    case RDT_Sw56:
        dwType = RASSRVUI_MODEM;
        break;
        
    case RDT_Tunnel_Pptp:
    case RDT_Tunnel_L2tp:
        dwType = RASSRVUI_VPN;
        break;
        
    case RDT_Irda:
    case RDT_Parallel:
        dwType = RASSRVUI_DCC;
        break;
        
    case RDT_Other:
    default:
        dwType = RASSRVUI_MODEM;
    }
    
    if (rdt & RDT_Tunnel)
    {
        dwType = RASSRVUI_VPN;
    }
    else if (rdt & (RDT_Direct | RDT_Null_Modem))
    {
        dwType = RASSRVUI_DCC;
    }
    return dwType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\nctraceui\traceui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E U I . C P P
//
//  Contents:   Trace configuration UI property sheet code
//
//  Notes:
//
//  Author:     jeffspr   1 Sept 1998
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#ifdef ENABLETRACE

#include "ncdebug.h"
#include "ncui.h"
#include "traceui.h"

//---[ Constants ]------------------------------------------------------------

const WCHAR  c_szTraceUICaption[]    = L"Tracing Configuration";    // Propsheet caption


HRESULT HrOpenTracingUI(HWND hwndOwner)
{
    HRESULT             hr          = S_OK;
    int                 nRet        = 0;
    CPropSheetPage *    ppspTrace   = new CTraceTagPage;
    CPropSheetPage *    ppspFlags   = new CDbgFlagPage;
    HPROPSHEETPAGE      hpsp[2]     = {0};
    PROPSHEETHEADER     psh;

    if (!ppspTrace || !ppspFlags)
    {
        hr = E_FAIL;
        goto Exit;
    }

    hpsp[0] = ppspTrace->CreatePage(IDD_TRACETAGS, 0);
    hpsp[1] = ppspTrace->CreatePage(IDD_DBGFLAGS, 0);

    ZeroMemory (&psh, sizeof(psh));
    psh.dwSize      = sizeof( PROPSHEETHEADER );
    psh.dwFlags     = PSH_NOAPPLYNOW;
    psh.hwndParent  = hwndOwner;
    psh.hInstance   = _Module.GetResourceInstance();
    psh.pszCaption  = c_szTraceUICaption;
    psh.nPages      = 2;
    psh.phpage      = hpsp;

    nRet = PropertySheet(&psh);

Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnTraceHelpGeneric
//
//  Purpose:    Generic help handler function.
//
//  Arguments:
//      hwnd   [in]     Parent window
//      lParam [in]     lParam passed to WM_HELP handler
//
//  Returns:    Nothing
//
//  Author:     danielwe   25 Feb 1998
//
//  Notes:
//
VOID OnTraceHelpGeneric(HWND hwnd, LPARAM lParam)
{
    LPHELPINFO  lphi;

    lphi = reinterpret_cast<LPHELPINFO>(lParam);

    Assert(lphi);

    if (lphi->iContextType == HELPINFO_WINDOW)
    {
#if 0   // NYI
        WinHelp(hwnd, c_szNetCfgHelpFile, HELP_CONTEXTPOPUP,
                lphi->iCtrlId);
#endif
    }
}

//+---------------------------------------------------------------------------
//
//  Function Name:  HrInitTraceListView
//
//  Purpose:    Initialize the list view.
//              Iterate through all installed clients, services and protocols,
//              insert into the list view with the correct binding state with
//              the adapter used in this connection.
//
//  Arguments:
//      hwndList[in]:    Handle of the list view
//      pnc[in]:         The writable INetcfg pointer
//      pnccAdapter[in]: The INetcfgComponent pointer to the adapter used in this connection
//
//  Returns:    HRESULT, Error code.
//
//  Notes:
//

HRESULT HrInitTraceListView(HWND hwndList, HIMAGELIST *philStateIcons)
{
    HRESULT                     hr  = S_OK;
    RECT                        rc;
    LV_COLUMN                   lvc = {0};

    Assert(hwndList);

    // Set the shared image lists bit so the caller can destroy the class
    // image lists itself
    //
    DWORD dwStyle = GetWindowLong(hwndList, GWL_STYLE);
    SetWindowLong(hwndList, GWL_STYLE, (dwStyle | LVS_SHAREIMAGELISTS));

    // Create state image lists
    *philStateIcons = ImageList_LoadBitmap(
                                    _Module.GetResourceInstance(),
                                    MAKEINTRESOURCE(IDB_TRACE_CHECKSTATE),
                                    16,
                                    0,
                                    PALETTEINDEX(6));
    ListView_SetImageList(hwndList, *philStateIcons, LVSIL_STATE);

    GetClientRect(hwndList, &rc);
    lvc.mask = LVCF_FMT; // | LVCF_WIDTH
    lvc.fmt = LVCFMT_LEFT;
//     lvc.cx = rc.right;

    ListView_InsertColumn(hwndList, 0, &lvc);

    if (SUCCEEDED(hr))
    {
        // Selete the first item
        ListView_SetItemState(hwndList, 0, LVIS_SELECTED, LVIS_SELECTED);
    }

    TraceError("HrInitTraceListView", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   UninitTraceListView
//
//  Purpose:    Uninitializes the common component list view
//
//  Arguments:
//      hwndList [in]   HWND of listview
//
//  Returns:    Nothing
//
//  Author:     danielwe   2 Feb 1998
//
//  Notes:
//
VOID UninitTraceListView(HWND hwndList)
{
    Assert(hwndList);

    // delete existing items in the list view
    ListView_DeleteAllItems( hwndList );
}

#endif  // ENABLE_TRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\nctraceui\traceui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E U I . H
//
//  Contents:   Tracing Property sheet UI
//
//  Notes:
//
//  Author:     jeffspr   31 Aug 1998
//
//----------------------------------------------------------------------------

#pragma once
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>

#include "ncatl.h"
#include "ncatlps.h"
#include "resource.h"
#include <nctraceui.h>

//---[ Classes and structs ]--------------------------------------------------

#if 0
struct ADVANCED_ITEM_DATA
{
    PWSTR              szwName;
    INetCfgComponent *  pncc;
};
#endif

//
// CTraceUIDlg
//

class CTraceUIDlg :
    public CDialogImpl<CTraceUIDlg>
{
    BEGIN_MSG_MAP(CTraceUIDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    END_MSG_MAP()

//    enum { IDD = IDD_LAN_CONNECT};

    CTraceUIDlg() {};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled);
};

//
// Trace UI TraceTag Page
//
class CTraceTagPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CTraceTagPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)

        // Listview handlers
        NOTIFY_CODE_HANDLER(NM_CLICK, OnClick)
        NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDbClick)
        NOTIFY_CODE_HANDLER(LVN_KEYDOWN, OnKeyDown)
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChanged)
        NOTIFY_CODE_HANDLER(LVN_DELETEITEM, OnDeleteItem)
    END_MSG_MAP()

    enum {IDD = IDD_TRACETAGS};

    CTraceTagPage();
    ~CTraceTagPage();

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam,
                      LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                     BOOL& bHandled);
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                         BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // listview handlers
    LRESULT OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

private:
    HIMAGELIST              m_hil;
    HWND                    m_hwndLV;
    BOOL                    m_fLocked;
    HIMAGELIST              m_hilCheckIcons;
    HCURSOR                 m_hPrevCurs;
};

//
// Trace UI TraceTag Page
//
class CDbgFlagPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CDbgFlagPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)

        // Listview handlers
        NOTIFY_CODE_HANDLER(NM_CLICK, OnClick)
        NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDbClick)
        NOTIFY_CODE_HANDLER(LVN_KEYDOWN, OnKeyDown)
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChanged)
        NOTIFY_CODE_HANDLER(LVN_DELETEITEM, OnDeleteItem)
    END_MSG_MAP()

    enum {IDD = IDD_TRACETAGS};

    CDbgFlagPage();
    ~CDbgFlagPage();

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam,
                      LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                     BOOL& bHandled);
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                         BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // listview handlers
    LRESULT OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

private:
    HIMAGELIST              m_hil;
    HWND                    m_hwndLV;
    BOOL                    m_fLocked;
    HIMAGELIST              m_hilCheckIcons;
    HCURSOR                 m_hPrevCurs;
};



//
// Global functions
//

VOID    OnTraceHelpGeneric(HWND hwnd, LPARAM lParam);
HRESULT HrInitTraceListView(HWND hwndList, HIMAGELIST *philStateIcons);
VOID    UninitTraceListView(HWND hwndList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\dbgext\exts.cpp ===
/*-----------------------------------------------------------------------------
   Copyright (c) 2000  Microsoft Corporation

Module:
  ncext.c

------------------------------------------------------------------------------*/

#define ENABLETRACE
#define NCDBGEXT

#define IMPORT_NCDBG_FRIENDS \
    friend HRESULT HrDumpConnectionListFromAddress(ULONG64 address); \
    friend HRESULT HrDumpNode(LPVOID pvHead, LPVOID pvDbgHead, LPVOID pvNil, DWORD dwLevel);

#include "ncext.h"

// #define VERBOSE

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
#include "tracetag.h"
#include "naming.h"
#include "foldinc.h"
#include "connlist.h"

#ifdef VERBOSE
#define dprintfVerbose dprintf
#else
#define dprintfVerbose __noop
#endif

HRESULT HrGetAddressOfSymbol(LPCSTR szSymbol, PULONG64 pAddress)
{
    HRESULT hr = E_FAIL;

    if (pAddress)
    {
        *pAddress = 0;
    }

    if (!szSymbol || !*szSymbol || !pAddress)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pAddress = GetExpression(szSymbol);
        if (!*pAddress)
        {
            dprintf("\nCould not find symbol: %s. Is your symbols correct?\n", szSymbol);
        }
        else
        {
            dprintfVerbose("%s: %I64lx\n", szSymbol, *pAddress);
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT HrGetAddressOfSymbol(LPCSTR szModule, LPCSTR szSymbol, PULONG64 pAddress)
{
    HRESULT hr = E_FAIL;

    if (pAddress)
    {
        *pAddress = 0;
    }

    if (!szModule || !*szModule || !szSymbol || !*szSymbol || !pAddress)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pAddress = 0;

        CHAR szModulueSymbol[MAX_PATH];
        wsprintf(szModulueSymbol, "%s!%s", szModule, szSymbol);
        dprintfVerbose("%s: ", szModulueSymbol);

        hr = HrGetAddressOfSymbol(szModulueSymbol, pAddress);
    }

    return hr;
}

HRESULT HrReadMemoryFromUlong(ULONG64 Address, DWORD dwSize, OUT LPVOID pBuffer)
{
    HRESULT hr = S_OK;
    DWORD cb;

    dprintfVerbose("from %I64lx, size=%x\n", Address, dwSize);
    if (ReadMemory(Address, pBuffer, dwSize, &cb) && cb == dwSize)
    {
        hr = S_OK;
    }
    else
    {
        dprintf("Could not read content of memory at %I64lx. Content might be paged out.\n", Address);
        hr = E_FAIL;
    }
    return hr;
}

HRESULT HrWriteMemoryFromUlong(ULONG64 Address, DWORD dwSize, OUT LPCVOID pBuffer)
{
    HRESULT hr = S_OK;
    DWORD cb;

    dprintfVerbose("to %I64lx, size=%x\n", Address, dwSize);
    if (WriteMemory(Address, pBuffer, dwSize, &cb) && cb == dwSize)
    {
        hr = S_OK;
    }
    else
    {
        dprintf("Could not write content of memory to %I64lx. Address might be paged out.\n", Address);
        hr = E_FAIL;
    }
    return hr;
}

HRESULT HrReadMemory(LPVOID pAddress, DWORD dwSize, OUT LPVOID pBuffer)
{
    return HrReadMemoryFromUlong((ULONG64)(ULONG_PTR)pAddress, dwSize, pBuffer);
}

HRESULT HrWriteMemory(LPVOID pAddress, DWORD dwSize, OUT LPCVOID pBuffer)
{
    return HrWriteMemoryFromUlong((ULONG64)(ULONG_PTR)pAddress, dwSize, pBuffer);
}

HRESULT HrGetTraceTagsForModule(LPCSTR szModuleName, LPDWORD pdwCount, TRACETAGELEMENT** ppTRACETAGELEMENT)
{
    HRESULT hr = E_FAIL;

    if (szModuleName && *szModuleName)
    {
        ULONG64 g_TraceTagCountAddress = 0;
        ULONG64 g_TraceTagsAddress     = 0;
        hr = HrGetAddressOfSymbol(szModuleName, "g_nTraceTagCount", &g_TraceTagCountAddress);
        if (SUCCEEDED(hr))
        {
            INT nTraceTagCount = 0;
            hr = HrReadMemoryFromUlong(g_TraceTagCountAddress, sizeof(nTraceTagCount), &nTraceTagCount);
            if (SUCCEEDED(hr))
            {
                *pdwCount = nTraceTagCount;
                dprintfVerbose("Number of tags: %d\n", nTraceTagCount);
    
                hr = HrGetAddressOfSymbol(szModuleName, "g_TraceTags", &g_TraceTagsAddress);
                if (SUCCEEDED(hr))
                {
                    if (nTraceTagCount)
                    {
                        DWORD dwSize = nTraceTagCount * sizeof(TRACETAGELEMENT);
                
                        *ppTRACETAGELEMENT = reinterpret_cast<TRACETAGELEMENT*>(LocalAlloc(0, dwSize));
                        if (*ppTRACETAGELEMENT)
                        {
                            dprintfVerbose("Reading %d bytes\n", dwSize);

                            hr = HrReadMemoryFromUlong(g_TraceTagsAddress, dwSize, *ppTRACETAGELEMENT);
                        }
                        else
                        {
                            dprintf("Out of memory allocating %d trace elements\n", nTraceTagCount);
                        }
                    }
                    else
                    {
                        dprintf("Internal error\n");
                    }
                }
            }
            else
            {
                dprintf("*ERROR* Could not read content of %s!g_nTraceTagCount. Value might be paged out.\n", szModuleName);
            }
        }
    }

    return hr;
}

HRESULT HrPutTraceTagsForModule(LPCSTR szModuleName, DWORD dwCount, const TRACETAGELEMENT* pTRACETAGELEMENT)
{
    HRESULT hr = E_FAIL;

    if (szModuleName && *szModuleName)
    {
        CHAR szTraceExport[MAX_PATH];
        wsprintf(szTraceExport, "%s!g_TraceTags", szModuleName);
        dprintfVerbose("%s: ", szTraceExport);

        ULONG64 pnTraceAddress = GetExpression(szTraceExport);
        if (!pnTraceAddress)
        {
            dprintf("\n### Could not find g_TraceTags export on module %s. Is %s loaded, and is your symbols correct? ###\n", szModuleName, szModuleName);
        }
        dprintfVerbose("%I64lx\n", pnTraceAddress);

        CHAR szTraceCount[MAX_PATH];
        wsprintf(szTraceCount, "%s!g_nTraceTagCount", szModuleName);
        dprintfVerbose("%s: ", szTraceCount);
        ULONG64 pnTraceTagCount = GetExpression(szTraceCount);
        if (!pnTraceTagCount)
        {
            dprintf("\n### Could not find g_nTraceTagCount export on module %s. Is %s loaded, and is your symbols correct? ###\n", szModuleName, szModuleName);
        }
        dprintfVerbose("%I64lx\n", pnTraceTagCount);

        if (pnTraceAddress & pnTraceTagCount)
        {
            INT nTraceTagCount = 0;
            DWORD cb;
            hr = HrReadMemoryFromUlong(pnTraceTagCount, sizeof(nTraceTagCount), &nTraceTagCount);
            if (SUCCEEDED(hr))
            {
                dwCount = nTraceTagCount;
                if (dwCount != nTraceTagCount)
                {
                    dprintf("Internal Error\n");
                }
                else
                {
                    dprintfVerbose("Number of tags: %d\n", nTraceTagCount);
        
                    if (nTraceTagCount)
                    {
                        DWORD dwSize = nTraceTagCount * sizeof(TRACETAGELEMENT);
                    
                        dprintfVerbose("Writing %d bytes\n", dwSize);
                        hr = HrWriteMemoryFromUlong(pnTraceAddress, dwSize, pTRACETAGELEMENT);
                    }
                    else
                    {
                        dprintf("Internal error\n");
                    }
                 }
            }
            else
            {
                dprintf("*ERROR* Could not read content of %s!g_nTraceTagCount. Value might be paged out.\n", szModuleName);
            }
        }
    }

    return hr;
}

//
// Extension to read and dump dwords from target
//
DECLARE_API( tracelist )
{
    ULONG cb;
    ULONG64 Address;
    ULONG   Buffer[4];

    if (!lstrcmpi(args, "all"))
    {
        for (int x = 0; x < g_nTraceTagCount; x++)
        {
            dprintf("%-20s - %s\r\n", g_TraceTags[x].szShortName, g_TraceTags[x].szDescription);
        }
    }
    else
    {
        if (args && *args)
        {
            DWORD dwCount; 
            TRACETAGELEMENT *pTRACETAGELEMENT;
            HRESULT hr = HrGetTraceTagsForModule(args, &dwCount, &pTRACETAGELEMENT);
            if (SUCCEEDED(hr))
            {
                for (DWORD x = 0; x < dwCount; x++)
                {
                    if (pTRACETAGELEMENT[x].fOutputDebugString)
                    {
                        dprintf("  %s\n", pTRACETAGELEMENT[x].szShortName);
                    }
                }

                LocalFree(pTRACETAGELEMENT);
            }
        }
        else
        {
            dprintf("Usage: !tracelist all - dump all tracetags\n");
            dprintf("       !tracelist <module> - dump tracetags enable for module <module>\n");
        }
    }
}

HRESULT HrEnableDisableTraceTag(LPCSTR argstring, BOOL fEnable)
{
    HRESULT hr = E_FAIL;

    BOOL fShowUsage = FALSE;
    DWORD dwArgLen = lstrlen(argstring);

    if (dwArgLen)
    {
        LPSTR szString = new TCHAR[dwArgLen+1];
        if (!szString)
        {
            dprintf("Out of memory\n");
        }
        else
        {
            LPSTR Args[2];
            DWORD dwCurrentArg = 0;
            lstrcpy(szString, argstring);
            Args[0] = szString;
        
            for (DWORD x = 0; (x < dwArgLen) && (dwCurrentArg < celems(Args)); x++)
            {
                if (szString[x] == ' ')
                {
                    dwCurrentArg++;

                    szString[x] = '\0';
                    Args[dwCurrentArg] = szString + x + 1;
                }
            }

            dprintfVerbose("Number of arguments: %d\n", dwCurrentArg + 1);

            if (dwCurrentArg != 1) 
            {
                hr = E_INVALIDARG;
            }
            else
            {
                dprintfVerbose("Arguments: %s, %s\n", Args[0], Args[1]);
                if (argstring && *argstring)
                {
                    DWORD dwCount; 
                    TRACETAGELEMENT *pTRACETAGELEMENT;
                    HRESULT hr = HrGetTraceTagsForModule(Args[0], &dwCount, &pTRACETAGELEMENT);
                    if (SUCCEEDED(hr))
                    {
                        BOOL fFound = FALSE;
                        for (DWORD x = 0; x < dwCount; x++)
                        {
                            if (!lstrcmpi(Args[1], pTRACETAGELEMENT[x].szShortName))
                            {
                                fFound = TRUE;

                                if (pTRACETAGELEMENT[x].fOutputDebugString == fEnable)
                                {
                                    dprintf("  [%s] is already %s\n", pTRACETAGELEMENT[x].szShortName, fEnable ? "enabled" : "disabled");
                                    hr = S_FALSE;
                                }
                                else
                                {
                                    pTRACETAGELEMENT[x].fOutputDebugString = fEnable;
                                    if (SUCCEEDED(HrPutTraceTagsForModule(Args[0], dwCount, pTRACETAGELEMENT)))
                                    {
                                        dprintf("  [%s] is now %s on module %s\n", pTRACETAGELEMENT[x].szShortName, fEnable ? "enabled" : "disabled", Args[0]);
                                        hr = S_OK;
                                    }
                                    break;
                                }
                            }
                        }

                        if (!fFound)
                        {
                            dprintf("ERROR: No such TraceTag ID found in module %s\n", Args[0]);
                        }

                        LocalFree(pTRACETAGELEMENT);
                    }
                }
                else
                {
                }
            }
        }

        delete [] szString;
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//
// Extension to edit a dword on target
//  
//    !edit <address> <value>
//
DECLARE_API( traceadd )
{
    ULONG cb;
    ULONG64 Address;
    ULONG   Value;

    HRESULT hr = HrEnableDisableTraceTag(args, TRUE);

    if (E_INVALIDARG == hr)
    {
        dprintf("Usage: traceadd <module> \"tracetag\" - Starts tracing for a specific tracetag\n");
    }
}


//
// Extension to dump stacktrace
//
DECLARE_API ( tracedel )
{
    EXTSTACKTRACE64 stk[20];
    ULONG frames, i;
    CHAR Buffer[256];
    ULONG64 displacement;

    HRESULT hr = HrEnableDisableTraceTag(args, FALSE);

    if (E_INVALIDARG == hr)
    {
        dprintf("Usage: tracedel <module> \"tracetag\" - Stops tracing for a specific tracetag\n");
    }
}

typedef map<ConnListCore::key_type, ConnListCore::referent_type> ConnListCoreMap;

class ConnList_Map : public ConnListCoreMap
{
public:
    class ConnList_Tree : public ConnListCoreMap::_Imp
    {
    public:
        _Nodeptr GetHead() { return _Head; }
        _Nodepref _Left(_Nodeptr _P)
        {
            return ((_Nodepref)(*_P)._Left);
        }
        _Nodepref _Right(_Nodeptr _P)
        {
            return ((_Nodepref)(*_P)._Right);
        }

        LPVOID _GetHeadPtr() { return _Head; }
        LPVOID _LeftPtr(LPVOID _P)
        {
            return ((* (_Nodeptr)_P)._Left);
        }
        LPVOID _RightPtr(LPVOID _P)
        {
            return ((* (_Nodeptr)_P)._Right);
        }
        LPVOID _ParentPtr(LPVOID _P)
        {
            return ((* (_Nodeptr)_P)._Parent);
        }
        LPVOID GetNil()
        {
            return _Nil;
        }
        DWORD _GetNodeSize() { return sizeof(_Node); }
    };

public:
    ConnList_Tree *GetTree() { return reinterpret_cast<ConnList_Tree *>(&_Tr); }

    LPVOID _GetHeadPtr() { return GetTree()->_GetHeadPtr(); }
    LPVOID _LeftPtr(LPVOID p)  { return GetTree()->_LeftPtr(p); }
    LPVOID _RightPtr(LPVOID p) { return GetTree()->_RightPtr(p); }
    LPVOID _ParentPtr(LPVOID p) { return GetTree()->_ParentPtr(p); }
    LPVOID GetNil() { return GetTree()->GetNil(); }
    DWORD _GetNodeSize() { return GetTree()->_GetNodeSize(); }
    typedef ConnList_Tree::_Node _NodeType;
};

typedef ConnList_Map::_NodeType NodeType;

LPCSTR DBG_EMNAMES[] =
{
    "INVALID_EVENTMGR",
    "EVENTMGR_CONMAN",
    "EVENTMGR_EAPOLMAN"
};

LPCSTR DBG_CMENAMES[] =
{
    "INVALID_TYPE",
    "CONNECTION_ADDED",
    "CONNECTION_BANDWIDTH_CHANGE",
    "CONNECTION_DELETED",
    "CONNECTION_MODIFIED",
    "CONNECTION_RENAMED",
    "CONNECTION_STATUS_CHANGE",
    "REFRESH_ALL",
    "CONNECTION_ADDRESS_CHANGE"
};

LPCSTR DBG_NCMNAMES[] =
{
    "NCM_NONE",
    "NCM_DIRECT",
    "NCM_ISDN",
    "NCM_LAN",
    "NCM_PHONE",
    "NCM_TUNNEL",
    "NCM_PPPOE",
    "NCM_BRIDGE",
    "NCM_SHAREDACCESSHOST_LAN",
    "NCM_SHAREDACCESSHOST_RAS"
};

LPCSTR DBG_NCSMNAMES[] =
{
    "NCSM_NONE",
    "NCSM_LAN",
    "NCSM_WIRELESS",
    "NCSM_ATM",
    "NCSM_ELAN",
    "NCSM_1394",
    "NCSM_DIRECT",
    "NCSM_IRDA",
    "NCSM_CM",
};

LPCSTR DBG_NCSNAMES[] =
{
    "NCS_DISCONNECTED",
    "NCS_CONNECTING",
    "NCS_CONNECTED",
    "NCS_DISCONNECTING",
    "NCS_HARDWARE_NOT_PRESENT",
    "NCS_HARDWARE_DISABLED",
    "NCS_HARDWARE_MALFUNCTION",
    "NCS_MEDIA_DISCONNECTED",
    "NCS_AUTHENTICATING",
    "NCS_AUTHENTICATION_SUCCEEDED",
    "NCS_AUTHENTICATION_FAILED",
    "NCS_INVALID_ADDRESS",
    "NCS_CREDENTIALS_REQUIRED"
};

// Shorten these to fit more in.
LPCSTR DBG_NCCSFLAGS[] =
{
    "_NONE",
    "_ALL_USERS",
    "_ALLOW_DUPLICATION",
    "_ALLOW_REMOVAL",
    "_ALLOW_RENAME",
    "_SHOW_ICON",
    "_INCOMING_ONLY",
    "_OUTGOING_ONLY",
    "_BRANDED",
    "_SHARED",
    "_BRIDGED",
    "_FIREWALLED",
    "_DEFAULT"
};

LPCSTR DbgEvents(DWORD Event)
{
    if (Event < celems(DBG_CMENAMES))
    {
        return DBG_CMENAMES[Event];
    }
    else
    {
        return "UNKNOWN Event: Update DBG_CMENAMES table.";
    }
}

LPCSTR DbgEventManager(DWORD EventManager)
{
    if (EventManager < celems(DBG_EMNAMES))
    {
        return DBG_EMNAMES[EventManager];
    }
    else
    {
        return "UNKNOWN Event: Update DBG_EMNAMES table.";
    }
}

LPCSTR DbgNcm(DWORD ncm)
{
    if (ncm < celems(DBG_NCMNAMES))
    {
        return DBG_NCMNAMES[ncm];
    }
    else
    {
        return "UNKNOWN NCM: Update DBG_NCMNAMES table.";
    }
}

LPCSTR DbgNcsm(DWORD ncsm)
{
    if (ncsm < celems(DBG_NCSMNAMES))
    {
        return DBG_NCSMNAMES[ncsm];
    }
    else
    {
        return "UNKNOWN NCM: Update DBG_NCSMNAMES table.";
    }
}

LPCSTR DbgNcs(DWORD ncs)
{
    if (ncs < celems(DBG_NCSNAMES))
    {
        return DBG_NCSNAMES[ncs];
    }
    else
    {
        return "UNKNOWN NCS: Update DBG_NCSNAMES table.";
    }
}

LPCSTR DbgNccf(DWORD nccf)
{
    static CHAR szName[MAX_PATH];

    if (nccf >= (1 << celems(DBG_NCCSFLAGS)) )
    {
        return "UNKNOWN NCCF: Update DBG_NCCSFLAGS table.";
    }

    if (0 == nccf)
    {
        strcpy(szName, DBG_NCCSFLAGS[0]);
    }
    else
    {
        szName[0] = '\0';
        LPSTR szTemp = szName;
        BOOL bFirst = TRUE;
        for (DWORD x = 0; x < celems(DBG_NCCSFLAGS); x++)
        {
            if (nccf & (1 << x))
            {
                if (!bFirst)
                {
                    szTemp += sprintf(szTemp, "+");
                }
                else
                {
                    szTemp += sprintf(szTemp, "NCCF:");
                }
                bFirst = FALSE;
                szTemp += sprintf(szTemp, "%s", DBG_NCCSFLAGS[x+1]);
            }
        }
    }

    return szName;
}

HRESULT HrDumpNode(LPVOID pvHead, LPVOID pvDbgHead, LPVOID pvNil, DWORD dwLevel)
{
    NodeType *pHead = reinterpret_cast<NodeType *>(pvHead);
    dprintfVerbose("%d: [0x%I64lx], NIL = [0x%I64lx]\n", dwLevel, pvDbgHead, pvNil);
        
    if (pvDbgHead == pvNil)
    {
        return S_FALSE;
    }

    if ( (!pHead->_Left) && (!pHead->_Right) ) // aparently with the STL version we are using, this identifies an end node.
    {
        return S_FALSE; 
    }

    HRESULT hr;
    ConnListEntry &cle = pHead->_Value.second;
    CConFoldEntry &cfe = cle.ccfe;

    WCHAR szNameEntry[MAX_PATH];
    dprintfVerbose("%d: Reading szNameEntry", dwLevel);
    hr = HrReadMemory(cfe.m_pszName, celems(szNameEntry), szNameEntry);
    if (SUCCEEDED(hr))
    {
        if (*szNameEntry)
        {
            LPWSTR szGUID;
            StringFromCLSID(cfe.m_guidId, &szGUID);

            dprintf(" * %S [%s:%s:%s:%s]\n", szNameEntry,
                    DbgNcs(cfe.m_ncs), DbgNccf(cfe.m_dwCharacteristics), DbgNcm(cfe.m_ncm), DbgNcsm(cfe.m_ncsm) );
            dprintf("       guidId      : %S\n", szGUID);
            CoTaskMemFree(szGUID);

            StringFromCLSID(cfe.m_clsid, &szGUID);
            dprintf("       clsId       : %S\n", szGUID);
            CoTaskMemFree(szGUID);

            hr = HrReadMemory(cfe.m_pszDeviceName , celems(szNameEntry), szNameEntry);
            if (SUCCEEDED(hr))
            {
                dprintf("       Device Name : %S\n", szNameEntry);
            }

            hr = HrReadMemory(cfe.m_pszPhoneOrHostAddress, celems(szNameEntry), szNameEntry);
            if (SUCCEEDED(hr))
            {
                dprintf("       Phone #     : %S\n", szNameEntry);
            }
            
            switch (cfe.m_wizWizard)
            {
                case WIZARD_NOT_WIZARD:
                    break;
                case WIZARD_HNW:
                    dprintf("       WIZARD_HNW\n");
                    break;
                case WIZARD_MNC:
                    dprintf("       WIZARD_MNC\n");
                    break;
            }
        }
    }

    dprintfVerbose("%d: left is : 0x%I64lx\n", dwLevel, pHead->_Left);
    dprintfVerbose("%d: right is: 0x%I64lx\n", dwLevel, pHead->_Right);
    if (0 != pHead->_Left) 
    {
        NodeType *pNodeLeft = reinterpret_cast<NodeType *>(new BYTE[sizeof(NodeType)]);
        ZeroMemory(pNodeLeft, sizeof(NodeType));
        dprintfVerbose("%d: Reading left child node ", dwLevel);
        hr = HrReadMemory(pHead->_Left, sizeof(NodeType), pNodeLeft);
        if (SUCCEEDED(hr))
        {
            hr = ::HrDumpNode(pNodeLeft, pHead->_Left, pvNil, dwLevel+1);
        }
        delete [] reinterpret_cast<LPBYTE>(pNodeLeft);
    }

    if (0 != pHead->_Right) 
    {
        NodeType *pNodeRight = reinterpret_cast<NodeType *>(new BYTE[sizeof(NodeType)]);
        ZeroMemory(pNodeRight, sizeof(NodeType));
        dprintfVerbose("%d: Reading right child node ", dwLevel);
        hr = HrReadMemory(pHead->_Right, sizeof(NodeType), pNodeRight);
        if (SUCCEEDED(hr))
        {
            hr = ::HrDumpNode(pNodeRight, pHead->_Right, pvNil, dwLevel+1);
        }
        delete [] reinterpret_cast<LPBYTE>(pNodeRight);
    }
    
    return S_OK;
}

HRESULT HrDumpConnectionListFromAddress(ULONG64 address)
{
    HRESULT hr = E_FAIL;

    CConnectionList *pConnectionList = reinterpret_cast<CConnectionList *>(new BYTE[sizeof(CConnectionList)]);
    ZeroMemory(pConnectionList, sizeof(CConnectionList));

    dprintfVerbose("Reading pConnectionList (g_ccl) ");
    hr = HrReadMemoryFromUlong(address, sizeof(CConnectionList), pConnectionList);
    if (SUCCEEDED(hr))
    {
        ConnList_Map *pConnListCore = reinterpret_cast<ConnList_Map *>(new BYTE[sizeof(ConnList_Map)]);
        ZeroMemory(pConnListCore, sizeof(ConnList_Map));

        dprintfVerbose("Reading pConnListCore (g_ccl.m_pcclc) ");
        hr = HrReadMemory(pConnectionList->m_pcclc, sizeof(ConnList_Map), pConnListCore);
        if (SUCCEEDED(hr))
        {
            dprintf("%d entries found:\n", pConnListCore->size());

            NodeType *pConnListHead = reinterpret_cast<NodeType *>(new BYTE[sizeof(NodeType)]);
            ZeroMemory(pConnListHead, sizeof(NodeType));

            dprintfVerbose("Reading pConnListHead (g_ccl.m_pcclc.[_Tr]._Head) ");
            hr = HrReadMemory(pConnListCore->_GetHeadPtr(), sizeof(NodeType), pConnListHead);
            if (SUCCEEDED(hr))
            {
//                hr = ::HrDumpNode(pConnListHead, 0);

                NodeType *pConnListRoot = reinterpret_cast<NodeType *>(new BYTE[sizeof(NodeType)]);
                ZeroMemory(pConnListRoot, sizeof(NodeType));
                dprintfVerbose("Reading pConnListRoot (g_ccl.m_pcclc.[_Tr]._Head._Parent) ");
                hr = HrReadMemory(pConnListHead->_Parent, sizeof(NodeType), pConnListRoot);
                if (SUCCEEDED(hr))
                {
                    hr = ::HrDumpNode(pConnListRoot, pConnListHead->_Parent, pConnListCore->GetNil(), 0);
                }
                delete [] reinterpret_cast<LPBYTE>(pConnListRoot);
            }
            delete [] reinterpret_cast<LPBYTE>(pConnListHead);
        }
        delete reinterpret_cast<LPBYTE>(pConnListCore);
    }
    delete reinterpret_cast<LPBYTE>(pConnectionList);

    if (FAILED(hr))
    {
        dprintf("Could not dump connection list\n");
    }
    return hr;
}

//
// Extension to dump stacktrace
//
DECLARE_API ( connlist )
{
    EXTSTACKTRACE64 stk[20];
    ULONG frames, i;
    CHAR Buffer[256];
    ULONG64 displacement;

    HRESULT hr = E_FAIL;;
    ULONG64 g_cclAddress;
    if (*args)
    {
        hr = HrGetAddressOfSymbol(args, &g_cclAddress);
    }
    else
    {
        hr = HrGetAddressOfSymbol("netshell!g_ccl", &g_cclAddress);
    }

    if (SUCCEEDED(hr))
    {
        hr = ::HrDumpConnectionListFromAddress(g_cclAddress);
    }

    if (E_INVALIDARG == hr)
    {
        dprintf("Usage:\n"
            "   connlist                         - Dumps out the connection\n"
            "   connlist <address>               - Dumps out the connection list from address\n");
    }
}


/*
  A built-in help for the extension dll
*/

DECLARE_API ( help ) 
{
    dprintf("Help for NetConfig ncext.dll\n"
            "   tracelist <module>               - List all the currently traces enabled for module <module>\n"
            "   tracelist all                    - List currently available traces\n"
            "   traceadd <module> \"tracetag\"     - Starts tracing for a specific tracetag\n"
            "   tracedel <module> \"tracetag\"     - Stops tracing for a specific tracetag\n"
            "   connlist                         - Dumps out the connection\n"
            "   connlist <address>               - Dumps out the connection list from address\n"
            "   help                             - Shows this help\n"
            );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\common\nctraceui\tagspage.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T A G S P A G E . C P P
//
//  Contents:   TraceTags propsheet page handlers
//
//  Notes:
//
//  Author:     jeffspr   24 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#ifdef ENABLETRACE

#include <crtdbg.h>
#include "ncdebug.h"
#include <ncui.h>
#include "traceui.h"



//---[ Globals ]--------------------------------------------------------------

#if 0
typedef struct _LV_COLUMN {
    UINT mask;
    int fmt;
    int cx;
    PWSTR pszText;
    int cchTextMax;
    int iSubItem;
} LV_COLUMN;
#endif

//      | :---------    CHAR []     szShortName
//      | | :-------    CHAR []     szDescription
//      | | |           BOOL        fOutputDebugString -----------------------------:
//      | | |           BOOL        fOutputToFile ----------------------------------|---:
//      | | |           BOOL        fVerboseOnly------------------------------------|---|---:

#define LVCF_NORMAL (LVCF_FMT | LVCF_TEXT | LVCF_WIDTH)

static LV_COLUMN    g_lvcTags[] =
{
    {LVCF_NORMAL,   LVCFMT_LEFT,    90,     L"Name",           0,  0},
    {LVCF_NORMAL,   LVCFMT_LEFT,    180,    L"Description",    0,  0},
    {LVCF_NORMAL,   LVCFMT_LEFT,    70,     L"Debug Logging",  0,  0},
    {LVCF_NORMAL,   LVCFMT_LEFT,    70,     L"File Logging",   0,  0}
};

const DWORD g_dwTagColumnCount = celems(g_lvcTags);

static const UINT SELS_UNCHECKED     = 0x1;
static const UINT SELS_CHECKED       = 0x2;


CTraceTagPage::CTraceTagPage()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::~CTraceTagPage
//
//  Purpose:    Destroys the CTraceTagPage object
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   25 Feb 1998
//
//  Notes:
//
CTraceTagPage::~CTraceTagPage()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnInitDialog
//
//  Purpose:    Handles the WM_INITDIALOG message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& bHandled)
{
    HRESULT             hr = S_OK;

    m_hwndLV = GetDlgItem(IDC_TRACETAGS);

    for(DWORD dwLoop = 0; dwLoop < g_dwTagColumnCount; dwLoop++)
    {
        ListView_InsertColumn(m_hwndLV,dwLoop+1,&(g_lvcTags[dwLoop]));
    }

    LV_ITEM lvi = {0};

    lvi.mask = LVIF_TEXT | LVIF_PARAM;

    for(INT iLoop = 0; iLoop < g_nTraceTagCount; iLoop++)
    {
        WCHAR szShortName[c_iMaxTraceTagShortName+1];

        lvi.iItem = iLoop;
        lvi.lParam = reinterpret_cast<LPARAM>(&g_TraceTags[iLoop]);

        MultiByteToWideChar(CP_ACP, 0, g_TraceTags[iLoop].szShortName,
                -1, szShortName, c_iMaxTraceTagShortName+1);
        lvi.pszText = szShortName;

        // We will refresh the state of the whole list in the end

        INT ret = ListView_InsertItem(m_hwndLV, &lvi);
        if(ret != -1)
        {
            WCHAR szColumnText[c_iMaxTraceTagDescription+1];

            for(INT iColumn = 1; iColumn < g_dwTagColumnCount; iColumn++)
            {
                switch(iColumn)
                {
                    // Description
                    //
                    case 1:
                        MultiByteToWideChar(CP_ACP, 0, g_TraceTags[iLoop].szDescription,
                            -1, szColumnText, c_iMaxTraceTagDescription+1);
                        break;

                    // Debug logging
                    //
                    case 2:
                        lstrcpyW(szColumnText, L"Enabled");
                        break;

                    // File logging
                    //
                    case 3:
                        lstrcpyW(szColumnText, L"Disabled");
                        break;

                    default:
                        AssertSz(FALSE, "Bad column in OnInitDialog switch");
                        break;
                }

                ListView_SetItemText(m_hwndLV, iLoop, iColumn,
                        szColumnText);
            }
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnHelp
//
//  Purpose:    Handles the WM_HELP message.
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     danielwe   25 Feb 1998
//
//  Notes:
//
LRESULT CTraceTagPage::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,
                            BOOL& bHandled)
{
    OnTraceHelpGeneric(m_hWnd, lParam);

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnDestroy
//
//  Purpose:    Called when the dialog page is destroyed
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   2 Feb 1998
//
//  Notes:
//
LRESULT CTraceTagPage::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam,
                               BOOL& bHandled)
{
    UninitTraceListView(m_hwndLV);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnSetCursor
//
//  Purpose:    Called in response to the WM_SETCURSOR message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   2 Jan 1998
//
//  Notes:
//
LRESULT CTraceTagPage::OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                 BOOL& bHandled)
{
    if (m_hPrevCurs)
    {
        if (LOWORD(lParam) == HTCLIENT)
        {
            SetCursor(LoadCursor(NULL, IDC_WAIT));
        }

        return TRUE;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnAdd
//
//  Purpose:    Handles the clicking of the Add button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                           BOOL& bHandled)
{
    HRESULT     hr = S_OK;

#if 0
    hr = HrLvAdd(m_hwndLV, m_hWnd, m_pnc, m_pnccAdapter, &m_listBindingPaths);
    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        // Change the Cancel Button to CLOSE (because we committed changes)
        //
        ::PostMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
    }

    if (NETCFG_S_REBOOT == hr)
    {
        RequestReboot();

        // The reboot request has been handled
        hr = S_OK;
    }

    TraceError("CTraceTagPage::OnAdd", hr);
#endif
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnRemove
//
//  Purpose:    Handles the clicking of the Remove button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                              BOOL& bHandled)
{
    HRESULT     hr = S_OK;
#if 0
    hr = HrLvRemove(m_hwndLV, m_hWnd, m_pnc, m_pnccAdapter,
                    &m_listBindingPaths);

    // if list is empty, reset the buttons
    if (0 == ListView_GetItemCount(m_hwndLV))
    {
        // Reset the buttons and the description text based on the changed selection
        LvSetButtons(m_handles);
    }

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        // Change the Cancel Button to CLOSE (because we committed changes)
        //
        ::PostMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
    }

    if (NETCFG_S_REBOOT == hr)
    {
        RequestReboot();

        // The reboot request has been handled
        hr = S_OK;
    }

    TraceError("CTraceTagPage::OnRemove", hr);
#endif
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnProperties
//
//  Purpose:    Handles the clicking of the Properties button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                  BOOL& bHandled)
{
    HRESULT     hr = S_OK;
#if 0
    hr = HrLvProperties(m_hwndLV, m_hWnd, m_pnc, m_punk,
                        m_pnccAdapter, &m_listBindingPaths);

    TraceError("CTraceTagPage::OnProperties", hr);
#endif
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnApply
//
//  Purpose:    Called when the Networking page is applied
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr = S_OK;

#if 0
    if (m_fReentrancyCheck)
    {
        TraceTag(ttidLanUi, "CTraceTagPage::OnApply is being re-entered! "
                 "I'm outta here!");

        // Don't allow the automatic EndDialog() to work just yet
        SetWindowLong(DWLP_MSGRESULT, PSNRET_INVALID);
        return TRUE;
    }

    m_hPrevCurs = SetCursor(LoadCursor(NULL, IDC_WAIT));

    hr = m_pnc->Validate();
    if (hr == S_OK)
    {
        BOOL    fReboot = FALSE;

        // Note: This function becomes reentrant because INetCfg::Apply()
        // has a message pump in it which causes the PSN_APPLY message to
        // be processed twice. This will happen ONLY if the user double-clicks
        // the OK button.
        m_fReentrancyCheck = TRUE;

        TraceTag(ttidLanUi, "Calling INetCfg::Apply()");
        hr = m_pnc->Apply();
        if (NETCFG_S_REBOOT == hr)
        {
            fReboot = TRUE;
        }

        if (SUCCEEDED(hr))
        {
            TraceTag(ttidLanUi, "INetCfg::Apply() succeeded");
            hr = m_pnc->Uninitialize();
        }

        if (SUCCEEDED(hr))
        {
            if (m_fRebootAlreadyRequested || fReboot)
            {
                DWORD dwFlags = QUFR_REBOOT;
                if (!m_fRebootAlreadyRequested)
                    dwFlags |= QUFR_PROMPT;

                (VOID) HrNcQueryUserForReboot(_Module.GetResourceInstance(),
                                              m_hWnd, IDS_LAN_CAPTION,
                                              IDS_REBOOT_REQUIRED,
                                              dwFlags);
            }
        }
    }

    // Apply "general" properties
    //
    if (SUCCEEDED(hr))
    {
        LANCON_INFO linfo = {0};

        linfo.fShowIcon = IsDlgButtonChecked(IDC_CHK_ShowIcon);

        // Set new value of show icon property
        hr = m_plan->SetInfo(LCIF_ICON, &linfo);
    }

    // Normalize result
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    if (m_hPrevCurs)
    {
        SetCursor(m_hPrevCurs);
        m_hPrevCurs = NULL;
    }

    // Reset this just in case
    m_fReentrancyCheck = FALSE;

    TraceError("CTraceTagPage::OnApply", hr);
#endif
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnCancel
//
//  Purpose:    Called when the Networking page is cancelled.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   3 Jan 1998
//
//  Notes:
//
LRESULT CTraceTagPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr = S_OK;
#if 0
    AssertSz(m_pnc, "I need a NetCfg object!");

    hr = m_pnc->Uninitialize();

    TraceError("CTraceTagPage::OnCancel", hr);
#endif
    return LresFromHr(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnDeleteItem
//
//  Purpose:    Called when the LVN_DELETEITEM message is received
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   3 Nov 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);
#if 0
    LvDeleteItem(m_hwndLV, pnmlv->iItem);
#endif
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnClick
//
//  Purpose:    Called in response to the NM_CLICK message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
#if 0
    OnListClick(m_hwndLV, m_hWnd, m_pnc, m_punk,
                        m_pnccAdapter, &m_listBindingPaths, FALSE);
#endif
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnDbClick
//
//  Purpose:    Called in response to the NM_DBLCLK message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
#if 0
    OnListClick(m_hwndLV, m_hWnd, m_pnc, m_punk,
                m_pnccAdapter, &m_listBindingPaths, TRUE);
#endif
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnKeyDown
//
//  Purpose:    Called in response to the LVN_KEYDOWN message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    LV_KEYDOWN* plvkd = (LV_KEYDOWN*)pnmh;
#if 0
    OnListKeyDown(m_hwndLV, &m_listBindingPaths, plvkd->wVKey);
#endif
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTraceTagPage::OnItemChanged
//
//  Purpose:    Called when the LVN_ITEMCHANGED message is received
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   10 Nov 1997
//
//  Notes:
//
LRESULT CTraceTagPage::OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);
#if 0
    HANDLES         handles;

    Assert(pnmlv);

    // Reset the buttons and the description text based on the changed selection
    LvSetButtons(m_handles);
#endif
    return 0;
}

#endif // ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\dbgext\ncext.h ===
/*++
   Copyright (c) 2000  Microsoft Corporation

Module:

    Simple.h
    
    
    Common header file for extensions

--*/

#if (__cplusplus)
#include <pch.h>
#else
#include <windows.h>
#endif
#include <dbghelp.h>

#define KDEXT_64BIT
#include <wdbgexts.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\dbgext\ncext.c ===
/*++

 Copyright (c) 2000  Microsoft Corporation

Module Name:

    ncext.c

--*/

#include "ncext.h"

#include <ntverp.h>
#include <dbghelp.h>

//
// globals
//
EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG SavedMajorVersion;
ULONG SavedMinorVersion;

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

//
// Routine called by debugger after load
//
VOID
CheckVersion(
    VOID
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\dbgext\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOIME
#define NOMCX
#define NOMDI
#define NOMETAFILE
#define NOSOUND
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>

#include <commdlg.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <infstr.h>
#include <regstr.h>
#include <setupapi.h>
#include <shellapi.h>
#include <shlobj.h>     // must come before shlguid.h
#include <shlguid.h>
#include <stdio.h>
#include <wchar.h>
#include <hnetcfg.h>
#include <iphlpapi.h>

// Fusion support
#include "shfusion.h"

#include "stlalgor.h"
#include "stllist.h"
#include "stlmap.h"
#include "stlset.h"
#include "stlvec.h"
using namespace std;

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
#include "ncexcept.h"
#include "naming.h"

// This avoids duplicate definitions with Shell PIDL functions
// and MUST BE DEFINED!
#define AVOID_NET_CONFIG_DUPLICATES
#define DONT_WANT_SHELLDEBUG 1
#define NO_SHIDLIST 1
#define USE_SHLWAPI_IDLIST

#include <commctrl.h>
#include <shlobjp.h>

#include <rasuip.h>
#include <rasdlg.h>

#include <comctrlp.h>
#include <shpriv.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shlobjp.h>
#include <shlapip.h>

#define LoadIconSize(hInstance, lpszName, dwSize) \
    reinterpret_cast<HICON>(LoadImage(hInstance, lpszName, IMAGE_ICON, dwSize, dwSize, LR_DEFAULTCOLOR))

#define LoadIconSmall(hInstance, lpszName) \
    LoadIconSize(hInstance, lpszName, 16)

#define LoadIconNormal(hInstance, lpszName) \
    LoadIconSize(hInstance, lpszName, 32)

#define LoadIconTile(hInstance, lpszName) \
    LoadIconSize(hInstance, lpszName, 48)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\benchmrk.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       B E N C H M R K . H
//
//  Contents:   Benchmark class.
//
//  Notes:
//
//  Author:     billbe   13 Oct 1997
//
//---------------------------------------------------------------------------


#pragma once

const CHAR c_sznEmpty[] = {'\0'};

class CBenchmark
{
public:
    CBenchmark();
    ~CBenchmark();
    void Start(PCSTR sznDescription);
    void Stop();
    double DblBenchmarkSeconds()
    {
        return m_i64TotalTime / static_cast<double>(m_i64Frequency);
    }
    PCSTR SznDescription(){return m_sznDescription ? m_sznDescription : c_sznEmpty;}
    PCSTR SznBenchmarkSeconds(unsigned short usPrecision);
private:
    __int64 m_i64Frequency;
    PSTR m_sznDescription;
    __int64 m_i64StartTime;
    __int64 m_i64TotalTime;
    BOOL m_fStarted;
    BOOL m_fSupported;
    CHAR m_sznSeconds[50];

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\dbgflags.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D B G F L A G S . H
//
//  Contents:   Debug Flag definitions for the Netcfg project
//
//  Notes:
//
//  Author:     jeffspr   27 May 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _DBGFLAGS_H_
#define _DBGFLAGS_H_

// None of this should get compiled in unless we're in the debug version
// or we need to enable tracing code.
//

//+---------------------------------------------------------------------------
//
// DBG (checked) or ENABLETRACE build
//
#if defined(DBG) || defined(ENABLETRACE)


// DebugFlagIds are the identifiers for debug flags, and are used in calls
// to FIsDebugFlagSet()
//
// Hungarian == dfid
//
enum DebugFlagId
{
    dfidBreakOnAlloc = 0,
    dfidBreakOnDoUnattend,
    dfidBreakOnError,
    dfidBreakOnHr,
    dfidBreakOnHrIteration,
    dfidBreakOnIteration,
    dfidBreakOnNetInstall,
    dfidBreakOnNotifySinkRelease,
    dfidBreakOnPrematureDllUnload,
    dfidBreakOnWizard,
    dfidBreakOnStartOfUpgrade,
    dfidBreakOnEndOfUpgrade,
    dfidCheckLegacyMenusAtRuntime,
    dfidCheckLegacyMenusOnStartup,
    dfidDisableShellThreading,
    dfidDisableTray,
    dfidDontCacheShellIcons,
    dfidExtremeTracing,
    dfidNetShellBreakOnInit,
    dfidNoErrorText,
    dfidShowIgnoredErrors,
    dfidShowProcessAndThreadIds,
    dfidSkipLanEnum,
    dfidTraceCallStackOnError,
    dfidTraceFileFunc,
    dfidTraceMultiLevel,
    dfidTraceSource,
    dfidTracingTimeStamps,
    dfidTrackObjectLeaks
};

// Just for kicks
//
typedef enum DebugFlagId    DEBUGFLAGID;

// Maximum sizes for the trace tag elements.
const int c_iMaxDebugFlagShortName      = 32;
const int c_iMaxDebugFlagDescription    = 128;

// For each element in the debug flag list
//
struct DebugFlagElement
{
    DEBUGFLAGID dfid;
    CHAR        szShortName[c_iMaxDebugFlagShortName+1];
    CHAR        szDescription[c_iMaxDebugFlagDescription+1];
    DWORD       dwValue;
};

typedef struct DebugFlagElement DEBUGFLAGELEMENT;

//---[ Externs ]--------------------------------------------------------------

extern DEBUGFLAGELEMENT g_DebugFlags[];
extern const INT        g_nDebugFlagCount;

BOOL    FIsDebugFlagSet( DEBUGFLAGID    dfid );
DWORD   DwReturnDebugFlagValue( DEBUGFLAGID dfid );

//+---------------------------------------------------------------------------
//
// !DBG (retail) and !ENABLETRACE build
//
#else

#define FIsDebugFlagSet(dfid)           0
#define DwReturnDebugFlagValue(dfid)    0

#endif //! DBG || ENABLETRACE

#endif  // _DBGFLAGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\diag.h ===
#pragma once
#include "diagctx.h"
#include "ncstring.h"
#include "netcon.h"

// The enum constants CMD_SHOW_LANA_DIAG, CMD_SHOW_LANA_PATHS,
// CMD_SET_LANA_NUMBER, and CMD_REWRITE_LANA_INFO are used by lanacfg.exe
// which is published outside Microsoft.
// To keep lanacfg.exe working with new versions of netcfgx.dll, we need
// to make sure these constants do not change. These are sent to a different
// entry point than the previous COMMANDs so overlap is not a problem.
//

enum COMMAND
{
    CMD_SHOW_LANA_DIAG = 17,
    CMD_SHOW_LANA_PATHS = 19,
    CMD_SET_LANA_NUMBER = 20,
    CMD_REWRITE_LANA_INFO = 21,
    CMD_INVALID = 0,
    CMD_SHOW_BINDINGS,
    CMD_SHOW_COMPONENTS,
    CMD_SHOW_STACK_TABLE,
    CMD_SHOW_LAN_ADAPTER_PNPIDS,
    CMD_ADD_COMPONENT,
    CMD_REMOVE_COMPONENT,
    CMD_UPDATE_COMPONENT,
    CMD_REMOVE_REFS,
    CMD_ENABLE_BINDING,
    CMD_DISABLE_BINDING,
    CMD_MOVE_BINDING,
    CMD_WRITE_BINDINGS,
    CMD_SET_WANORDER,
    CMD_FULL_DIAGNOSTIC,
    CMD_CLEANUP,
    CMD_ADD_REMOVE_STRESS,
    CMD_SHOW_LAN_CONNECTIONS,
    CMD_SHOW_LAN_DETAILS,
    CMD_LAN_CHANGE_STATE,
    CMD_SHOW_ALL_DEVICES,
};

//+---------------------------------------------------------------------------
// Parameters for SZ_CMD_SHOW_BINDINGS
//
enum SHOW_BINDINGS_PARAM
{
    SHOW_INVALID = 0,
    SHOW_BELOW,
    SHOW_INVOLVING,
    SHOW_UPPER,
    SHOW_DISABLED,
};

enum COMPONENT_SPECIFIER_TYPE
{
    CST_INVALID = 0,
    CST_ALL,
    CST_BY_NAME,
};

struct COMPONENT_SPECIFIER
{
    COMPONENT_SPECIFIER_TYPE    Type;
    PCWSTR                      pszInfOrPnpId;
};


struct DIAG_OPTIONS
{
    CDiagContext*   pDiagCtx;

    COMMAND         Command;

    // Valid for CMD_ADD_COMPONENT
    GUID            ClassGuid;
    PCWSTR          pszInfId;

    // Valid for SZ_CMD_SHOW_BINDINGS
    //
    SHOW_BINDINGS_PARAM     ShowBindParam;
    COMPONENT_SPECIFIER     CompSpecifier;

    // Valid for SZ_CMD_ENABLE_BINDING and SZ_CMD_DISABLE_BINDING
    //
    PCWSTR          pszBindPath;

    // Valid for SZ_CMD_MOVE_BINDING
    //
    PCWSTR          pszOtherBindPath;
    BOOL            fMoveBefore;

    // Valid for SZ_CMD_SET_WANORDER
    //
    BOOL            fWanAdaptersFirst;

    // Valid for SZ_CMD_FULL_DIAGNOSTIC
    //
    BOOL            fLeakCheck;

    // Need this reserved in order to keep the lanacfg.exe tool working.
    // Otherwise the offsets for OldLanaNumber and NewLanaNumber will
    // be wrong since we published an earlier version of the tool compiled
    // with this BOOL in the structure definition.
    //
    BOOL            fReserved;

    // Valid for SZ_SET_LANA_NUMBER
    //
    BYTE            OldLanaNumber;
    BYTE            NewLanaNumber;

    // Used by CMD_SHOW_LAN_DETAILS
    PCWSTR          szLanConnection;

    // Used by CMD_LAN_CHANGE_STATE & CMD_SHOW_LAN_DETAILS
    BOOL            fConnect;
};

VOID
SzFromCharacteristics (
    DWORD dwChars,
    tstring *pstrChars);

PCWSTR
SzFromNetconStatus (
    NETCON_STATUS Status);

PCWSTR
SzFromCmProb (
    ULONG ulProb);

VOID
SzFromCmStatus (
    ULONG ulStatus, tstring *pstrStatus);

EXTERN_C
VOID
WINAPI
NetCfgDiagFromCommandArgs (
    IN DIAG_OPTIONS *pOptions);

EXTERN_C
VOID
WINAPI
LanaCfgFromCommandArgs (
    IN DIAG_OPTIONS *pOptions);

EXTERN_C
VOID
WINAPI
NetManDiagFromCommandArgs (
    IN DIAG_OPTIONS *pOptions);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\gpbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       G P B A S E . H
//
//  Contents:   Abstract Base Class for Handling NLA Changes that affect
//              Group Policies
//  Notes:
//
//  Author:     ckotze   20 Feb 2001
//
//----------------------------------------------------------------------------
#pragma once

class CGroupPolicyBase
{
public:
    CGroupPolicyBase(){};
    ~CGroupPolicyBase(){};

    virtual BOOL IsSameNetworkAsGroupPolicies() = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\afilestr.h ===
/* ----------------------------------------------------------------------

Copyright (c) 1996-1997 Microsoft Corporation


Module Name:

    afilestr.h

Abstract:

    Strings for accessing the AnswerFile

Author:

    Kumar Pandit (kumarp)

Revision History:
    Last modified: Time-stamp: <kumarp    04-February-99 (06:12:41 pm)>

    17-Mar-1997 : Kumar Pandit (kumarp)  : Created

 ---------------------------------------------------------------------- */
#pragma once
#ifndef _AFILESTR_H_
#define _AFILESTR_H_

// ----------------------------------------------------------------------
// General

extern const WCHAR c_szAfNone[];
extern const WCHAR c_szAfUnknown[];
extern const WCHAR c_szAfListDelimiter[];

extern const WCHAR c_szAfDisplay[];
extern const WCHAR c_szAfAllowChanges[];
extern const WCHAR c_szAfOnlyOnError[];

extern const WCHAR c_szAfParams[];

extern const WCHAR c_szAfSectionIdentification[];
extern const WCHAR c_szAfSectionNetAdapters[];
extern const WCHAR c_szAfSectionNetProtocols[];
extern const WCHAR c_szAfSectionNetServices[];
extern const WCHAR c_szAfSectionNetClients[];
extern const WCHAR c_szAfSectionNetBindings[];

extern const WCHAR c_szAfSectionWinsock[];
extern const WCHAR c_szAfKeyWinsockOrder[];

extern const WCHAR c_szAfAdapterSections[];
extern const WCHAR c_szAfSpecificTo[];
extern const WCHAR c_szAfCleanup[];

extern const WCHAR c_szAfInfid[];
extern const WCHAR c_szAfInfidReal[];
extern const WCHAR c_szAfInstance[];

extern const WCHAR c_szAfInstallDefaultComponents[];

// ----------------------------------------------------------------------
// ZAW related
//
extern const WCHAR c_szAfNetComponentsToRemove[];

// ----------------------------------------------------------------------
// Network upgrade related
//
extern const WCHAR c_szAfSectionNetworking[];
extern const WCHAR c_szAfUpgradeFromProduct[];
extern const WCHAR c_szAfBuildNumber[];

extern const WCHAR c_szAfProcessPageSections[];

extern const WCHAR c_szAfNtServer[];
extern const WCHAR c_szAfNtSbServer[];
extern const WCHAR c_szAfNtWorkstation[];
extern const WCHAR c_szAfWin95[];
extern const WCHAR c_szAfDisableServices[];

extern const WCHAR c_szAfSectionToRun[];

extern const WCHAR c_szRegKeyAnswerFileMap[];

extern const WCHAR c_szAfPreUpgradeRouter[];
extern const WCHAR c_szAfNwSapAgentParams[];
extern const WCHAR c_szAfIpRipParameters[];
extern const WCHAR c_szAfDhcpRelayAgentParameters[];
extern const WCHAR c_szAfRadiusParameters[];

extern const WCHAR c_szAfMiscUpgradeData[];
extern const WCHAR c_szAfSapAgentUpgrade[];

extern const WCHAR c_szAfServiceStartTypes[];
extern const WCHAR c_szAfTapiSrvRunInSeparateInstance[];

// ----------------------------------------------------------------------
// OEM upgrade related
//
extern const WCHAR c_szAfOemSection[];
extern const WCHAR c_szAfOemDir[];
extern const WCHAR c_szAfOemDllToLoad[];
extern const WCHAR c_szAfOemInf[];
extern const WCHAR c_szAfSkipInstall[];

// ----------------------------------------------------------------------
// Net card related

// ----------------------------------------------------------------------
// The definition of INTERFACE_TYPE has been picked up from ntioapi.h
// if we try to include ntioapi.h, it leads to inclusion of tons of other
// irrelevant files.

#ifndef _NTIOAPI_
typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;
#endif

// ----------------------------------------------------------------------

//Hardware Bus-Types

extern const WCHAR c_szAfInfIdWildCard[];

extern const WCHAR c_szAfNetCardAddr[];
extern const WCHAR c_szAfBusType[];

extern const WCHAR c_szAfBusInternal[];
extern const WCHAR c_szAfBusIsa[];
extern const WCHAR c_szAfBusEisa[];
extern const WCHAR c_szAfBusMicrochannel[];
extern const WCHAR c_szAfBusTurbochannel[];
extern const WCHAR c_szAfBusPci[];
extern const WCHAR c_szAfBusVme[];
extern const WCHAR c_szAfBusNu[];
extern const WCHAR c_szAfBusPcmcia[];
extern const WCHAR c_szAfBusC[];
extern const WCHAR c_szAfBusMpi[];
extern const WCHAR c_szAfBusMpsa[];
extern const WCHAR c_szAfBusProcessorinternal[];
extern const WCHAR c_szAfBusInternalpower[];
extern const WCHAR c_szAfBusPnpisa[];

//Net card parameters
extern const WCHAR c_szAfAdditionalParams[];
extern const WCHAR c_szAfPseudoAdapter[];
extern const WCHAR c_szAfDetect[];
extern const WCHAR c_szAfIoAddr[];
extern const WCHAR c_szAfIrq[];
extern const WCHAR c_szAfDma[];
extern const WCHAR c_szAfMem[];
extern const WCHAR c_szAfTransceiverType[];
extern const WCHAR c_szAfSlotNumber[];
extern const WCHAR c_szAfConnectionName[];

//Transceiver Types
extern const WCHAR c_szAfThicknet[];
extern const WCHAR c_szAfThinnet[];
extern const WCHAR c_szAfTp[];
extern const WCHAR c_szAfAuto[];

enum NetTransceiverType
{
    NTT_UKNOWN, NTT_THICKNET, NTT_THINNET, NTT_TP, NTT_AUTO
};

// Netcard upgrade specific
extern const WCHAR c_szAfPreUpgradeInstance[];

// ----------------------------------------------------------------------
// Identification Page related

extern const WCHAR c_szAfComputerName[];
extern const WCHAR c_szAfJoinWorkgroup[];
extern const WCHAR c_szAfJoinDomain[];

extern const WCHAR c_szAfDomainAdmin[];
extern const WCHAR c_szAfDomainAdminPassword[];


// ----------------------------------------------------------------------
// Protocols related

//TCPIP
extern const WCHAR c_szAfEnableSecurity[];
extern const WCHAR c_szAfEnableICMPRedirect[];
extern const WCHAR c_szAfDeadGWDetectDefault[];
extern const WCHAR c_szAfDontAddDefaultGatewayDefault[];

extern const WCHAR c_szAfIpAllowedProtocols[];
extern const WCHAR c_szAfTcpAllowedPorts[];
extern const WCHAR c_szAfUdpAllowedPorts[];

extern const WCHAR c_szDatabasePath[];
extern const WCHAR c_szAfForwardBroadcasts[];
extern const WCHAR c_szAfPPTPTcpMaxDataRetransmissions[];
extern const WCHAR c_szAfUseZeroBroadcast[];
extern const WCHAR c_szAfArpAlwaysSourceRoute[];
extern const WCHAR c_szAfArpCacheLife[];
extern const WCHAR c_szAfArpTRSingleRoute[];
extern const WCHAR c_szAfArpUseEtherSNAP[];
extern const WCHAR c_szAfDefaultTOS[];
extern const WCHAR c_szDefaultTTL[];
extern const WCHAR c_szEnableDeadGWDetect[];
extern const WCHAR c_szEnablePMTUBHDetect[];
extern const WCHAR c_szEnablePMTUDiscovery[];
extern const WCHAR c_szForwardBufferMemory[];
extern const WCHAR c_szHostname[];
extern const WCHAR c_szIGMPLevel[];
extern const WCHAR c_szKeepAliveInterval[];
extern const WCHAR c_szKeepAliveTime[];
extern const WCHAR c_szMaxForwardBufferMemory[];
extern const WCHAR c_szMaxForwardPending[];
extern const WCHAR c_szMaxNumForwardPackets[];
extern const WCHAR c_szMaxUserPort[];
extern const WCHAR c_szMTU[];
extern const WCHAR c_szNumForwardPackets[];
extern const WCHAR c_szTcpMaxConnectRetransmissions[];
extern const WCHAR c_szTcpMaxDataRetransmissions[];
extern const WCHAR c_szTcpNumConnections[];
extern const WCHAR c_szTcpTimedWaitDelay[];
extern const WCHAR c_szTcpUseRFC1122UrgentPointer[];
extern const WCHAR c_szDefaultGateway[];
extern const WCHAR c_szDomain[];
extern const WCHAR c_szEnableSecurityFilters[];
extern const WCHAR c_szNameServer[];
extern const WCHAR c_szMaxHashTableSize[];
extern const WCHAR c_szEnableAddrMaskReply[];
extern const WCHAR c_szPersistentRoutes[];
extern const WCHAR c_szArpCacheMinReferencedLife[];
extern const WCHAR c_szArpRetryCount[];
extern const WCHAR c_szTcpMaxConnectresponseRetransmissions[];
extern const WCHAR c_szTcpMaxDupAcks[];
extern const WCHAR c_szSynAttackProtect[];
extern const WCHAR c_szTCPMaxPortsExhausted[];
extern const WCHAR c_szTCPMaxHalfOpen[];
extern const WCHAR c_szTCPMaxHalfOpenRetried[];
extern const WCHAR c_szDontAddDefaultGateway[];
extern const WCHAR c_szPPTPFiltering[];
extern const WCHAR c_szDhcpClassId[];
extern const WCHAR c_szAfUseDomainNameDevolution[];
extern const WCHAR c_szSyncDomainWithMembership[];
extern const WCHAR c_szAfDisableDynamicUpdate[];
extern const WCHAR c_szAfEnableAdapterDomainNameRegistration[];

//NetBt
extern const WCHAR c_szBcastNameQueryCount[];
extern const WCHAR c_szBcastQueryTimeout[];
extern const WCHAR c_szCacheTimeout[];
extern const WCHAR c_szNameServerPort[];
extern const WCHAR c_szNameSrvQueryCount[];
extern const WCHAR c_szNameSrvQueryTimeout[];
extern const WCHAR c_szSessionKeepAlive[];
extern const WCHAR c_szSizeSmallMediumLarge[];
extern const WCHAR c_szBroadcastAddress[];
extern const WCHAR c_szEnableProxyRegCheck[];
extern const WCHAR c_szInitialRefreshTimeout[];
extern const WCHAR c_szLmhostsTimeout[];
extern const WCHAR c_szMaxDgramBuffering[];
extern const WCHAR c_szNodeType[];
extern const WCHAR c_szRandomAdapter[];
extern const WCHAR c_szRefreshOpCode[];
extern const WCHAR c_szSingleResponse[];
extern const WCHAR c_szWinsDownTimeout[];
extern const WCHAR c_szEnableProxy[];

//DNS
extern const WCHAR c_szAfDns[];
extern const WCHAR c_szAfDnsHostname[];
extern const WCHAR c_szAfDnsDomain[];
extern const WCHAR c_szAfDnsServerSearchOrder[];
extern const WCHAR c_szAfDnsSuffixSearchOrder[];

//DHCP
extern const WCHAR c_szAfDhcp[];
extern const WCHAR c_szAfIpaddress[];
extern const WCHAR c_szAfSubnetmask[];
extern const WCHAR c_szAfDefaultGateway[];
extern const WCHAR c_szAfBindToDhcpServer[];

//WINS
extern const WCHAR c_szAfWins[];
extern const WCHAR c_szAfWinsServerList[];
//extern const WCHAR c_szAfWinsPrimary[];
//extern const WCHAR c_szAfWinsSecondary[];
extern const WCHAR c_szAfScopeid[];
extern const WCHAR c_szAfEnableLmhosts[];
extern const WCHAR c_szAfImportLmhostsFile[];
extern const WCHAR c_szAfNetBIOSOptions[];

//IPX
extern const WCHAR c_szAfInternalNetworkNumber[];
extern const WCHAR c_szAfFrameType[];

// ----------------------------------------------------------------------
// Services

//MS_NetClient
extern const WCHAR c_szAfMsNetClient[];
extern const WCHAR c_szAfComputerBrowser[];
extern const WCHAR c_szAfBrowseDomains[];
extern const WCHAR c_szAfDefaultProvider[];
extern const WCHAR c_szAfNameServiceAddr[];
extern const WCHAR c_szAfNameServiceProtocol[];

//LanmanServer
extern const WCHAR c_szAfBrowserParameters[];
extern const WCHAR c_szAfNetLogonParameters[];

extern const WCHAR c_szAfLmServerShares[];
extern const WCHAR c_szAfLmServerParameters[];
extern const WCHAR c_szAfLmServerAutotunedParameters[];

extern const WCHAR c_szAfLmServerOptimization[];
extern const WCHAR c_szAfBroadcastToClients[];

extern const WCHAR c_szAfMinmemoryused[];
extern const WCHAR c_szAfBalance[];
extern const WCHAR c_szAfMaxthroughputforfilesharing[];
extern const WCHAR c_szAfMaxthrouputfornetworkapps[];

//TCP/IP
extern const WCHAR c_szAfIpAllowedProtocols[];
extern const WCHAR c_szAfTcpAllowedPorts[];
extern const WCHAR c_szAfUdpAllowedPorts[];

//RAS
extern const WCHAR c_szAfParamsSection[];

extern const WCHAR c_szAfPortSections[];
extern const WCHAR c_szAfPortname[];
extern const WCHAR c_szAfPortUsage[];
extern const WCHAR c_szAfPortUsageClient[];
extern const WCHAR c_szAfPortUsageServer[];
extern const WCHAR c_szAfPortUsageRouter[];

extern const WCHAR c_szAfSetDialinUsage[];

extern const WCHAR c_szAfForceEncryptedPassword[];
extern const WCHAR c_szAfForceEncryptedData[];
extern const WCHAR c_szAfMultilink[];
extern const WCHAR c_szAfRouterType[];

extern const WCHAR c_szAfDialinProtocols[];

extern const WCHAR c_szAfDialIn[];
extern const WCHAR c_szAfDialOut[];
extern const WCHAR c_szAfDialInOut[];

extern const WCHAR c_szAfNetbeui[];
extern const WCHAR c_szAfTcpip[];
extern const WCHAR c_szAfIpx[];

extern const WCHAR c_szAfNetbeuiClientAccess[];
extern const WCHAR c_szAfTcpipClientAccess[];
extern const WCHAR c_szAfIpxClientAccess[];
extern const WCHAR c_szAfNetwork[];
extern const WCHAR c_szAfThisComputer[];

extern const WCHAR c_szAfUseDhcp[];
extern const WCHAR c_szAfIpAddressStart[];
extern const WCHAR c_szAfIpAddressEnd[];
extern const WCHAR c_szAfExcludeAddress[];

extern const WCHAR c_szAfClientCanReqIpaddr[];
extern const WCHAR c_szAfAutoNetworkNumbers[];
extern const WCHAR c_szAfNetNumberFrom[];
extern const WCHAR c_szAfSameNetworkNumber[];
extern const WCHAR c_szAfClientReqNodeNumber[];
extern const WCHAR c_szAfWanNetPoolSize[];
extern const WCHAR c_szAfSecureVPN[];

//PPTP
extern const WCHAR c_szAfPptpEndpoints[];

//Bindings
extern const WCHAR c_szAfDisable[];
extern const WCHAR c_szAfEnable[];
extern const WCHAR c_szAfPromote[];
extern const WCHAR c_szAfDemote[];

extern const WCHAR c_szAfDhcpServerParameters[];
extern const WCHAR c_szAfDhcpServerConfiguration[];

extern const WCHAR c_szAfNWCWorkstationParameters[];
extern const WCHAR c_szAfNWCWorkstationShares[];
extern const WCHAR c_szAfNWCWorkstationDrives[];

#endif // _AFILESTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\diagctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       D I A G C T X . H
//
//  Contents:   Implements the optional diagnostic context used by
//              CNetConfig.
//
//  Notes:
//
//  Author:     shaunco   10 Feb 1999
//
//----------------------------------------------------------------------------

#pragma once

#include <tracetag.h>

enum DIAG_FLAGS
{
    DF_SHOW_CONSOLE_OUTPUT      = 0x00000001,
    DF_DONT_START_SERVICES      = 0x00000002,
    DF_DONT_DO_PNP_BINDS        = 0x00000004,
    DF_SUPRESS_E_NEED_REBOOT    = 0x00000010,
    DF_REPAIR_REGISTRY_BINDINGS = 0x00000020,
};

// This structure is allocated dynamically by CDiagContext.  Place anything
// big in this structure (as opposed to CDiagContext) so that the size of
// CNetConfig is not directly increased.
//
struct DIAG_CONTEXT
{
    CHAR szPrintBuffer [4096];
};

class CDiagContext
{
private:
    DWORD           m_dwFlags;  // DIAG_FLAGS
    DIAG_CONTEXT*   m_pCtx;
    FILE*           m_pLogFile; // optional, and not owned by this class.
    PVOID           m_pvScratchBuffer;
    DWORD           m_cbScratchBuffer;

public:
    CDiagContext ()
    {
        m_dwFlags = 0;
        m_pCtx = NULL;
        m_pLogFile = NULL;
        m_pvScratchBuffer = NULL;
        m_cbScratchBuffer = 0;
    }

    ~CDiagContext ()
    {
        MemFree (m_pCtx);
        MemFree (m_pvScratchBuffer);
        // Do not close m_pLogFile.  It is not owned by this class.
    }

    VOID
    SetFlags (
        DWORD dwFlags /* DIAG_FLAGS */);

    VOID
    SetLogFile (
        FILE* pLogFile OPTIONAL)
    {
        m_pLogFile = pLogFile;
    }

    DWORD
    Flags () const;

    FILE *
    LogFile () const
    {
        return m_pLogFile;
    }

    PVOID
    GetScratchBuffer (
        OUT PDWORD pcbSize) const
    {
        *pcbSize = m_cbScratchBuffer;
        return m_pvScratchBuffer;
    }

    PVOID
    GrowScratchBuffer (
        IN OUT PDWORD pcbNewSize)
    {
        MemFree(m_pvScratchBuffer);
        m_pvScratchBuffer = MemAlloc (*pcbNewSize);
        m_cbScratchBuffer = (m_pvScratchBuffer) ? *pcbNewSize : 0;
        *pcbNewSize = m_cbScratchBuffer;
        return m_pvScratchBuffer;
    }

    VOID
    Printf (
        TRACETAGID ttid,
        PCSTR pszFormat,
        ...);
};

extern CDiagContext* g_pDiagCtx;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ipafval.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I P A F V A L . H 
//
//  Contents:   Value/Type pairs of IP-specific AnswerFile strings
//
//  Notes:      
//
//  Author:     Ning Sun (nsun)   17 May 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "ncreg.h"
#include "afilestr.h"

typedef struct 
{
    PCWSTR pszValueName;
    DWORD  dwType;
} ValueTypePair;

//For unconfigurable parameters upgrading
extern const DECLSPEC_SELECTANY ValueTypePair rgVtpNetBt[] = 
{
    {c_szBcastNameQueryCount, REG_DWORD},       // in the inf
    {c_szBcastQueryTimeout, REG_DWORD},         // in the inf
    {c_szBroadcastAddress, REG_DWORD},
    {c_szCacheTimeout, REG_DWORD},              // in the inf
    {c_szEnableProxy, REG_BOOL},
    {c_szEnableProxyRegCheck, REG_BOOL},
    {c_szInitialRefreshTimeout, REG_DWORD},
    {c_szLmhostsTimeout, REG_DWORD},
    {c_szMaxDgramBuffering, REG_DWORD},
    {c_szNameServerPort, REG_DWORD},            // in the inf
    {c_szNameSrvQueryCount, REG_DWORD},         // in the inf
    {c_szNameSrvQueryTimeout, REG_DWORD},       // in the inf
    {c_szNodeType, REG_DWORD},
    {c_szRandomAdapter, REG_BOOL},
    {c_szRefreshOpCode, REG_DWORD},
    {c_szAfScopeid, REG_SZ},
    {c_szSessionKeepAlive, REG_DWORD},          // in the inf
    {c_szSingleResponse, REG_BOOL},
    {c_szSizeSmallMediumLarge, REG_DWORD},      // in the inf
    {c_szWinsDownTimeout, REG_DWORD}
};

extern const DECLSPEC_SELECTANY ValueTypePair rgVtpIp[] = 
{
    {c_szAfArpAlwaysSourceRoute, REG_BOOL},
    {c_szAfArpCacheLife, REG_DWORD},
    {c_szArpCacheMinReferencedLife, REG_DWORD},
    {c_szArpRetryCount, REG_DWORD},
    {c_szAfArpTRSingleRoute, REG_BOOL},
    {c_szAfArpUseEtherSNAP, REG_BOOL},
    {c_szAfDefaultTOS, REG_DWORD},
    {c_szEnableAddrMaskReply, REG_BOOL},
    {c_szEnableDeadGWDetect, REG_BOOL},
    {c_szEnablePMTUBHDetect, REG_BOOL},
    {c_szEnablePMTUDiscovery, REG_BOOL},
    {c_szAfForwardBroadcasts, REG_BOOL},            // in the inf
    {c_szForwardBufferMemory, REG_DWORD},
    {c_szIGMPLevel, REG_DWORD},
    {c_szKeepAliveInterval, REG_DWORD},
    {c_szKeepAliveTime, REG_DWORD},
    {c_szMaxForwardBufferMemory, REG_DWORD},
    {c_szMaxHashTableSize, REG_DWORD},
    {c_szMaxNumForwardPackets, REG_DWORD},
    {c_szMaxUserPort, REG_DWORD},
    {c_szNumForwardPackets, REG_DWORD},
    {c_szPersistentRoutes, REG_FILE},
    {c_szAfPPTPTcpMaxDataRetransmissions, REG_DWORD},
    {c_szSynAttackProtect, REG_BOOL},
    {c_szSyncDomainWithMembership, REG_DWORD},
    {c_szTcpMaxConnectRetransmissions, REG_DWORD},
    {c_szTcpMaxDataRetransmissions, REG_DWORD},
    {c_szTcpMaxDupAcks, REG_DWORD},
    {c_szTCPMaxHalfOpen, REG_DWORD},
    {c_szTCPMaxHalfOpenRetried, REG_DWORD},
    {c_szTCPMaxPortsExhausted, REG_DWORD},
    {c_szTcpNumConnections, REG_DWORD},
    {c_szTcpTimedWaitDelay, REG_DWORD},
    {c_szTcpUseRFC1122UrgentPointer, REG_BOOL}
};

extern const DECLSPEC_SELECTANY ValueTypePair rgVtpIpAdapter[] = 
{
    {c_szMTU, REG_DWORD},
    {c_szAfUseZeroBroadcast, REG_BOOL},
    {c_szMaxForwardPending, REG_DWORD},
    {c_szDontAddDefaultGateway, REG_BOOL},
    {c_szPPTPFiltering, REG_BOOL},
    {c_szAfBindToDhcpServer, REG_BOOL},

    //Bug286037 new unconfigurable param in Windows2000, but we want to support
    //the unattended install for this parameter
    {c_szDhcpClassId, REG_SZ}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\kkenet.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       K K E N E T . H
//
//  Contents:
//
//  Notes:
//
//  Author:     kumarp
//
//----------------------------------------------------------------------------

#pragma once

HRESULT HrGetNetCardAddr(IN PCWSTR pszDriver, OUT ULONGLONG* pqwNetCardAddr);
HRESULT HrGetNetCardAddrOld(IN PCWSTR pszDriver, OUT ULONGLONG* pqwNetCardAddr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\kkcwinf.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C W I N F . H
//
//  Contents:   Declaration of class CWInfFile and other related classes
//
//  Notes:
//
//  Author:     kumarp 04/12/97 17:17:27
//
//----------------------------------------------------------------------------
#pragma once
#include "kkstl.h"

//----------------------------------------------------------------------------
// forward declarations and useful typedefs
//----------------------------------------------------------------------------
typedef unsigned __int64 QWORD;

class CWInfContext;
typedef CWInfContext &RCWInfContext;

class CWInfFile;
typedef CWInfFile *PCWInfFile, &RCWInfFile;

class CWInfSection;
typedef CWInfSection *PCWInfSection, &RCWInfSection;

class CWInfKey;
typedef CWInfKey *PCWInfKey, &RCWInfKey;

class CWInfLine;
typedef CWInfLine *PCWInfLine, &RCWInfLine;

// access mode for CWInfFile
enum WInfAccessMode { IAM_Read, IAM_Write };

// search mode for CWInfFile
enum WInfSearchMode { ISM_FromCurrentPosition, ISM_FromBeginning };

typedef list<PCWInfLine> WifLinePtrList;
typedef WifLinePtrList::iterator WifLinePtrListIter;

// ----------------------------------------------------------------------
// Class CWInfContext
//
// Inheritance:
//   none
//
// Purpose:
//   Stores context within a CWInfFile during reading or writing
//
// Hungarian: wix
// ----------------------------------------------------------------------

class CWInfContext
{
    friend class CWInfFile;

public:
    CWInfContext() { posSection = 0; posLine = 0; }

private:
    WifLinePtrListIter posSection;
    WifLinePtrListIter posLine;
};


// ----------------------------------------------------------------------
// Class CWInfContext
//
// Inheritance:
//   none
//
// Purpose:
//   Allows simultaneous reading from and writing to an INF/INI style file
//
// Hungarian: wif
// ----------------------------------------------------------------------

class CWInfFile
{
public:
    CWInfFile();
    ~CWInfFile();

            BOOL Init();
	virtual BOOL Create(IN PCWSTR pszFileName);
    virtual BOOL Create(IN FILE *fp);
    virtual BOOL Open(IN PCWSTR pszFileName);
    virtual BOOL Open(IN FILE *fp);
    virtual BOOL Close();
    virtual BOOL SaveAs(IN PCWSTR pszFileName);
    virtual BOOL SaveAsEx(IN PCWSTR pszFileName); // used by SysPrep
    virtual BOOL Flush();
    virtual BOOL FlushEx(); // used by SysPrep
    virtual PCWSTR FileName() const { return m_strFileName.c_str(); }

    virtual const CWInfContext CurrentReadContext() const { return m_ReadContext; }
    virtual void  SetReadContext(IN RCWInfContext cwic)
                                                          { m_ReadContext = cwic; }

    virtual const CWInfContext CurrentWriteContext() const { return m_WriteContext; }
    virtual void  SetWriteContext(IN RCWInfContext cwic)
                                                          { m_WriteContext = cwic; }

    //Functions for reading
    virtual PCWInfSection FindSection(IN PCWSTR pszSectionName,
                                      IN WInfSearchMode wsmMode=ISM_FromBeginning);
    virtual void SetCurrentReadSection(IN PCWInfSection pwisSection);
    virtual PCWInfSection CurrentReadSection() const;

    virtual PCWInfKey FindKey(IN PCWSTR pszKeyName,
                              IN WInfSearchMode wsmMode=ISM_FromCurrentPosition);
    virtual PCWInfKey FirstKey();
    virtual PCWInfKey NextKey();

    //these functions return the FALSE if value not found
    //or if it is in a wrong format
    virtual BOOL    GetStringArrayValue(IN PCWSTR pszKeyName, OUT TStringArray &saStrings);
    virtual BOOL    GetStringListValue(IN PCWSTR pszKeyName, OUT TStringList &slList);
    virtual BOOL    GetStringValue(IN PCWSTR pszKeyName, OUT tstring &strValue);
    virtual BOOL    GetIntValue(IN PCWSTR pszKeyName, OUT DWORD *pdwValue);
    virtual BOOL    GetQwordValue(IN PCWSTR pszKeyName, OUT QWORD *pqwValue);
    virtual BOOL    GetBoolValue(IN PCWSTR pszKeyName, OUT BOOL *pfValue);

    //these functions return the default value if value not found
    //or if it is in a wrong format
    virtual PCWSTR GetStringValue(IN PCWSTR pszKeyName, IN PCWSTR pszDefault);
    virtual DWORD   GetIntValue(IN PCWSTR pszKeyName, IN DWORD dwDefault);
    virtual QWORD   GetQwordValue(IN PCWSTR pszKeyName, IN QWORD qwDefault);
    virtual BOOL    GetBoolValue(IN PCWSTR pszKeyName, IN BOOL fDefault);


    //Functions for writing
    virtual void  GotoEnd();

    virtual PCWInfSection AddSectionIfNotPresent(IN PCWSTR pszSectionName);
    virtual PCWInfSection AddSection(IN PCWSTR pszSectionName);
    virtual void  GotoEndOfSection(PCWInfSection section);
    virtual PCWInfSection CurrentWriteSection() const;
            void RemoveSection(IN PCWSTR szSectionName);
            void RemoveSections(IN TStringList& slSections);

    virtual PCWInfKey AddKey(IN PCWSTR pszKeyName);
    virtual void AddKey(IN PCWSTR pszKeyName, IN PCWSTR Value);
    virtual void AddKey(IN PCWSTR pszKeyName, IN DWORD Value);
    virtual void AddQwordKey(IN PCWSTR pszKeyName, IN QWORD qwValue);
    virtual void AddHexKey(IN PCWSTR pszKeyName, IN DWORD Value);
    virtual void AddBoolKey(IN PCWSTR pszKeyName, IN BOOL Value);
    virtual void AddKeyV(IN PCWSTR pszKeyName, IN PCWSTR Format, IN ...);
    virtual void AddKey(IN PCWSTR pszKeyName, IN PCWSTR Format, IN va_list arglist);
    virtual void AddKey(IN PCWSTR pszKeyName, IN const TStringList &slValues);

    virtual void AddComment(IN PCWSTR pszComment);
    virtual void AddRawLine(IN PCWSTR szText);
    virtual void AddRawLines(IN PCWSTR* pszLines, IN DWORD cLines);


protected:
    WifLinePtrList *m_plSections, *m_plLines;
    CWInfContext m_WriteContext, m_ReadContext;

    BOOL AddLine(IN const PCWInfLine ilLine);
    virtual void ParseLine(IN PCWSTR pszLine);

private:
    tstring m_strFileName;
    FILE*   m_fp;
};

// ----------------------------------------------------------------------
// Type of a line in a CWInfFile
//
// Hungarian: ilt
// ----------------------------------------------------------------------
enum InfLineTypeEnum { INF_UNKNOWN, INF_SECTION, INF_KEY, INF_COMMENT, INF_BLANK, INF_RAW };
typedef enum InfLineTypeEnum InfLineType;

// ----------------------------------------------------------------------
// Class CWInfLine
//
// Inheritance:
//   none
//
// Purpose:
//   Represents a line in a CWInfFile
//
// Hungarian: wil
// ----------------------------------------------------------------------

class CWInfLine
{
public:
    CWInfLine(InfLineType type) { m_Type = type; }

    virtual void GetText(tstring &text) const = 0;
    virtual void GetTextEx(tstring &text) const = 0; // used by SysPrep

    InfLineType Type() const { return m_Type; }

    virtual ~CWInfLine(){};

protected:
    InfLineType m_Type;
};

// ----------------------------------------------------------------------
// Class CWInfSection
//
// Inheritance:
//   CWInfLine
//
// Purpose:
//   Represents a section in a CWInfFile
//
// Hungarian: wis
// ----------------------------------------------------------------------

class CWInfSection : public CWInfLine
{
    friend class CWInfFile;

public:
    virtual void GetText(tstring &text) const;
    virtual void GetTextEx(tstring &text) const; // used by SysPrep
    virtual PCWSTR Name() const { return m_Name.c_str(); }

    //Functions for reading
    virtual PCWInfKey FindKey(IN PCWSTR pszKeyName,
                  IN WInfSearchMode wsmMode=ISM_FromCurrentPosition);
    virtual PCWInfKey FirstKey();
    virtual PCWInfKey NextKey();


    //these functions return the FALSE if value not found
    //or if it is in a wrong format
    virtual BOOL    GetStringArrayValue(IN PCWSTR pszKeyName, OUT TStringArray &saStrings);
    virtual BOOL    GetStringListValue(IN PCWSTR pszKeyName, OUT TStringList &slList);
    virtual BOOL    GetStringValue(IN PCWSTR pszKeyName, OUT tstring &strValue);
    virtual BOOL    GetIntValue(IN PCWSTR pszKeyName, OUT DWORD *pdwValue);
    virtual BOOL    GetQwordValue(IN PCWSTR pszKeyName, OUT QWORD *pqwValue);
    virtual BOOL    GetBoolValue(IN PCWSTR pszKeyName, OUT BOOL *pfValue);

    //these functions return the default value if value not found
    //or if it is in a wrong format
    virtual PCWSTR GetStringValue(IN PCWSTR pszKeyName, IN PCWSTR pszDefault);
    virtual DWORD   GetIntValue(IN PCWSTR pszKeyName, IN DWORD dwDefault);
    virtual QWORD   GetQwordValue(IN PCWSTR pszKeyName, IN QWORD qwDefault);
    virtual BOOL    GetBoolValue(IN PCWSTR pszKeyName, IN BOOL fDefault);

    //Functions for writing
    virtual void GotoEnd();

    virtual PCWInfKey AddKey(IN PCWSTR pszKeyName);
    virtual void AddKey(IN PCWSTR pszKeyName, IN PCWSTR Value);
    virtual void AddKey(IN PCWSTR pszKeyName, IN DWORD Value);
    virtual void AddQwordKey(IN PCWSTR pszKeyName, IN QWORD qwValue);
    virtual void AddHexKey(IN PCWSTR pszKeyName, IN DWORD Value);
    virtual void AddBoolKey(IN PCWSTR pszKeyName, IN BOOL Value);
    virtual void AddKeyV(IN PCWSTR pszKeyName, IN PCWSTR Format, IN ...);
    virtual void AddKey(IN PCWSTR pszKeyName, IN const TStringList &slValues);

    virtual void AddComment(IN PCWSTR pszComment);
    virtual void AddRawLine(IN PCWSTR szLine);

protected:
    tstring m_Name;
    WifLinePtrListIter m_posLine, m_posSection;
    CWInfFile *m_Parent;

    CWInfSection(IN PCWSTR pszSectionName, IN PCWInfFile parent);
   ~CWInfSection();

};

// ----------------------------------------------------------------------
// Class CWInfKey
//
// Inheritance:
//   CWInfLine
//
// Purpose:
//   Represents a key=value line in a CWInfFile
//
// Hungarian: wik
// ----------------------------------------------------------------------

class CWInfKey : public CWInfLine
{
    friend class CWInfFile;

public:
    CWInfKey(IN PCWSTR pszKeyName);
    ~CWInfKey();
    static void Init();
    static void UnInit();

    virtual void GetText(tstring &text) const;
    virtual void GetTextEx(tstring &text) const; // used by SysPrep

    PCWSTR Name() const { return m_Name.c_str(); }

    //Read values

    //these functions return the FALSE if value not found
    //or if it is in a wrong format
    virtual BOOL    GetStringArrayValue(OUT TStringArray &saStrings) const;
    virtual BOOL    GetStringListValue(OUT TStringList& slList) const;
    virtual BOOL    GetStringValue(OUT tstring& strValue) const;
    virtual BOOL    GetIntValue(OUT DWORD *pdwValue) const;
    virtual BOOL    GetQwordValue(OUT QWORD *pqwValue) const;
    virtual BOOL    GetBoolValue(OUT BOOL *pfValue) const;

    //these functions return the default value if value not found
    //or if it is in a wrong format
    virtual PCWSTR GetStringValue(IN PCWSTR pszDefault) const;
    virtual DWORD   GetIntValue(IN DWORD dwDefault) const;
    virtual QWORD   GetQwordValue(IN QWORD qwDefault) const;
    virtual BOOL    GetBoolValue(IN BOOL fDefault) const;

    //Write values
    virtual void SetValues(IN PCWSTR Format, va_list arglist);
    virtual void SetValues(IN PCWSTR Format, IN ...);
    virtual void SetValue(IN PCWSTR Value);
    virtual void SetValue(IN DWORD Value);
    virtual void SetQwordValue(IN QWORD Value);
    virtual void SetHexValue(IN DWORD Value);
    virtual void SetBoolValue(IN BOOL Value);
    virtual void SetValue(IN const TStringList &slValues);

protected:
    static WCHAR *m_Buffer;

private:
    tstring m_Name, m_Value;
    BOOL    m_fIsAListAndAlreadyProcessed;  // the value is a MULTI_SZ, will be
                                            // written out as a comma-separated
                                            // list, and has already been checked
                                            // to see if it has special chars and
                                            // needs to be surrounded by quotes.
};


// ----------------------------------------------------------------------
// Class CWInfComment
//
// Inheritance:
//   CWInfComment
//
// Purpose:
//   Represents a comment line in a CWInfFile
//
// Hungarian: wic
// ----------------------------------------------------------------------

class CWInfComment : public CWInfLine
{
public:
    CWInfComment(IN PCWSTR pszComment);
    ~CWInfComment();

    virtual void GetText(tstring &text) const;
    virtual void GetTextEx(tstring &text) const; // used by SysPrep

protected:

private:
    tstring m_strCommentText;
};

// ----------------------------------------------------------------------
// Class CWInfRaw
//
// Inheritance:
//   CWInfRaw
//
// Purpose:
//   Represents a raw line in a CWInfFile
//
// Hungarian: wir
// ----------------------------------------------------------------------

class CWInfRaw : public CWInfLine
{
public:
    CWInfRaw(IN PCWSTR szText);
    ~CWInfRaw();

    virtual void GetText(tstring &text) const;
    virtual void GetTextEx(tstring &text) const; // used by SysPrep
protected:

private:
    tstring m_strText;
};


// ----------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\kkreg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R E G I S T R Y . H
//
//  Contents:   Windows NT Registry Access Class
//
//  Notes:
//
//  Author:     kumarp    14 April 97 (09:22:00 pm)
//
//  Notes:
//    kumarp   1/16/97   most of the code in this file was originally in
//                       net\ui\rhino\common\classes\common.h
//                       extracted only that portion related to CRegKey & related classes
//    kumarp   3/27/97   the original code used MFC. converted the entire code
//                       to make it use STL
//----------------------------------------------------------------------------

#pragma once
#include "kkstl.h"
#include "ncreg.h"
//----------------------------------------------------------------------------
//  Forward declarations
//----------------------------------------------------------------------------

class CORegKey ;
class CORegValueIter ;
class CORegKeyIter ;

typedef CORegKey *PCORegKey;
//
//  Maximum size of a Registry class name
//
#define CORegKEY_MAX_CLASS_NAME MAX_PATH


// ----------------------------------------------------------------------
// Class CORegKey
//
// Inheritance:
//   none
//
// Purpose:
//   Provides a wrapper for NT registry access functions
//
// Hungarian: rk
// ----------------------------------------------------------------------

class CORegKey
{
protected:
    HKEY m_hKey ;
    DWORD m_dwDisposition ;
    BOOL m_fInherit;

    //  Prepare to read a value by finding the value's size.
    LONG PrepareValue (PCWSTR pchValueName, DWORD * pdwType,
                       DWORD * pcbSize, BYTE ** ppbData);

    //  Convert a TStringList to the REG_MULTI_SZ format
    static LONG FlattenValue (TStringList & strList, DWORD * pcbSize,
                              BYTE ** ppbData);

    //  Convert a TByteArray to a REG_BINARY block
    static LONG FlattenValue (TByteArray & abData, DWORD * pcbSize,
                              BYTE ** ppbData);

public:
    //
    //  Key information return structure
    //
    typedef struct
    {
        WCHAR chBuff [CORegKEY_MAX_CLASS_NAME] ;
        DWORD dwClassNameSize,
              dwNumSubKeys,
              dwMaxSubKey,
              dwMaxClass,
              dwMaxValues,
              dwMaxValueName,
              dwMaxValueData,
              dwSecDesc ;
        FILETIME ftKey ;
    } CORegKEY_KEY_INFO ;

    //
    //  Standard constructor for an existing key
    //
    CORegKey (HKEY hKeyBase, PCWSTR pchSubKey = NULL,
              REGSAM regSam = KEY_READ_WRITE_DELETE, PCWSTR pchServerName = NULL);

    //
    //  Constructor creating a new key.
    //
    CORegKey (PCWSTR pchSubKey, HKEY hKeyBase, DWORD dwOptions = 0,
              REGSAM regSam = KEY_READ_WRITE_DELETE, LPSECURITY_ATTRIBUTES pSecAttr = NULL,
              PCWSTR pchServerName = NULL);

    ~ CORegKey () ;

    //
    //  Allow a CORegKey to be used anywhere an HKEY is required.
    //
    operator HKEY ()    { return m_hKey; }

    //
    //  Also provide a function to get HKEY
    //
    HKEY HKey()         { return m_hKey; }

    //
    //  Fill a key information structure
    //
    LONG QueryKeyInfo ( CORegKEY_KEY_INFO * pRegKeyInfo ) ;

    //
    //  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
    //  if data exists but not in correct form to deliver into result object.
    //
    LONG QueryValue ( PCWSTR pchValueName, tstring & strResult ) ;
    LONG QueryValue ( PCWSTR pchValueName, TStringList & strList ) ;
    LONG QueryValue ( PCWSTR pchValueName, DWORD & dwResult ) ;
    LONG QueryValue ( PCWSTR pchValueName, TByteArray & abResult ) ;
    LONG QueryValue ( PCWSTR pchValueName, void * pvResult, DWORD cbSize );

    //  Overloaded value setting members.
    LONG SetValue ( PCWSTR pchValueName, tstring & strResult ) ;
    LONG SetValue ( PCWSTR pchValueName, tstring & strResult , BOOL fRegExpand) ;
    LONG SetValue ( PCWSTR pchValueName, TStringList & strList ) ;
    LONG SetValue ( PCWSTR pchValueName, DWORD & dwResult ) ;
    LONG SetValue ( PCWSTR pchValueName, TByteArray & abResult ) ;
    LONG SetValue ( PCWSTR pchValueName, void * pvResult, DWORD cbSize );

    LONG DeleteValue ( PCWSTR pchValueName );
};

// ----------------------------------------------------------------------
// Class CORegValueIter
//
// Inheritance:
//   none
//
// Purpose:
//  Iterate the values of a key, return the name and type of each
//
// Hungarian: rki
// ----------------------------------------------------------------------

class CORegValueIter
{
protected:
    CORegKey& m_rk_iter ;
    DWORD     m_dw_index ;
    PWSTR    m_p_buffer ;
    DWORD     m_cb_buffer ;

public:
    CORegValueIter ( CORegKey & regKey ) ;
    ~ CORegValueIter () ;

    //
    // Get the name (and optional last write time) of the next key.
    //
    LONG Next ( tstring * pstrName, DWORD * pdwType ) ;

    //
    // Reset the iterator
    //
    void Reset ()    { m_dw_index = 0 ; }
};

// ----------------------------------------------------------------------
// Class CORegKeyIter
//
// Inheritance:
//   none
//
// Purpose:
//  Iterate the sub-key names of a key.
//
// Hungarian: rki
// ----------------------------------------------------------------------

class CORegKeyIter
{
protected:
    CORegKey & m_rk_iter ;
    DWORD m_dw_index ;
    PWSTR m_p_buffer ;
    DWORD m_cb_buffer ;

public:
    CORegKeyIter (CORegKey & regKey) ;
    ~CORegKeyIter () ;

    LONG Next ( tstring * pstrName );

    // Reset the iterator
    void Reset ()    { m_dw_index = 0 ; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\kklog.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       K K L O G . H
//
//  Contents:   Error logging for NetCfg components
//
//  Notes:
//
//  Author:     kumarp    14 April 97 (09:22:00 pm)
//
//  Notes:
//----------------------------------------------------------------------------


enum ENetCfgComponentType;

// ----------------------------------------------------------------------
// Class CLog
//
// Inheritance:
//   none
//
// Purpose:
//   Provides a way to log errors/warnings to
//     - NT EventLog
//     - NT SetupLog (setuperr.log / setupact.log)
//
//   This class hides much of complexity of the EventLog API. In addition
//   the user of this class does not have to first check whether a EventSource
//   has been created in the registry. This class will create one if not found.
//   Also, it is not necessary to call (De)RegisterEventSource for each report.
//
//   Messages are logged to SetupLog only during system install/upgrade
//   Message are always logged to the EventLog
//
//   This class provides function interface that is closer to EventLog API
//   than to the SetupLog API. The EventLog parameter values are mapped to
//   corresponding SetupLog parameters using some helper functions.
//   See nclog.cpp for details.
//
//   The members of this class do not return an error, because this itself is the
//   error reporting mechanism. However, the class has several Trace* functions.
//
// Hungarian: cl
// ----------------------------------------------------------------------

class CLog
{
public:
    CLog(ENetCfgComponentType nccType);
    ~CLog();

    void Initialize(IN ENetCfgComponentType nccType);
    void SetCategory(IN ENetCfgComponentType nccType) { m_nccType = nccType; }

    //Event Reporting functions
    void ReportEvent(IN WORD wType, IN DWORD dwEventID,
                     IN WORD wNumStrings=0, IN PCWSTR* ppszStrings=NULL,
                     IN DWORD dwBinaryDataNumBytes=0,
                     IN PVOID pvBinaryData=NULL) const;

    void ReportEvent(IN WORD wType, IN DWORD dwEventID,
                     IN WORD wNumStrings, ...) const;

    void ReportEvent(IN WORD wType, IN DWORD dwEventID,
                     IN WORD wNumStrings, va_list arglist) const;

    void ReportError(DWORD dwEventID);
    void ReportWarning(DWORD dwEventID);

private:
    static BOOL          m_fNetSetupMode; // TRUE only during NT install/upgrade
                                          // this must be set by some external logic
    static PCWSTR       m_pszEventSource;// EventLog source name
    BOOL                 m_fInitialized;  // TRUE only if correctly initialized
    ENetCfgComponentType m_nccType;       // Component category
};

inline void CLog::ReportError(DWORD dwEventID)
{
    ReportEvent(EVENTLOG_ERROR_TYPE, dwEventID);
}

inline void CLog::ReportWarning(DWORD dwEventID)
{
    ReportEvent(EVENTLOG_WARNING_TYPE, dwEventID);
}

// ----------------------------------------------------------------------
// The wType parameter of ReportEvent can take any on of the following values
//
//   - EVENTLOG_SUCCESS
//   - EVENTLOG_ERROR_TYPE
//   - EVENTLOG_WARNING_TYPE
//   - EVENTLOG_INFORMATION_TYPE
//   - EVENTLOG_AUDIT_SUCCESS
//   - EVENTLOG_AUDIT_FAILURE

// ----------------------------------------------------------------------
// Components categories. This decides which event-message-file to use
// ----------------------------------------------------------------------
enum ENetCfgComponentType
{
    nccUnknown = 0,
    nccError,
    nccNetcfgBase,
    nccNWClientCfg,
    nccRasCli,
    nccRasSrv,
    nccRasRtr,
    nccRasNdisWan,
    nccRasPptp,
    nccNCPA,
    nccCompInst,
    nccMSCliCfg,
    nccSrvrCfg,
    nccNetUpgrade,
    nccNetSetup,
    nccDAFile,
    nccTcpip,
    nccAtmArps,
    nccAtmUni,
    nccLast
};


// ----------------------------------------------------------------------
// These functions should normally be used by components that require
// event reporting for different sub-components using different categories.
//
// For those components that report events only for a single component,
// should probably create a global instance of CLog only once
// and report thru that instance.
// ----------------------------------------------------------------------

void NcReportEvent(IN ENetCfgComponentType nccType,
                   IN WORD  wType, IN DWORD dwEventID,
                   IN WORD  wNumStrings, IN PCWSTR* ppszStrings,
                   IN DWORD dwBinaryDataNumBytes,
                   IN PVOID pvBinaryData);

void NcReportEvent(IN ENetCfgComponentType nccType,
                   IN WORD  wType, IN DWORD dwEventID,
                   IN WORD  wNumStrings, ...);

// ----------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\nameres.h ===
//+---------------------------------------------------------------------------
// Default names
#define IDS_DEFAULT_START                    1800
#define IDS_DEFAULT_VPNName                  IDS_DEFAULT_START + 1
#define IDS_DEFAULT_VPNName_Type             IDS_DEFAULT_START + 2
#define IDS_DEFAULT_PHONEName                IDS_DEFAULT_START + 3
#define IDS_DEFAULT_PHONEName_Type           IDS_DEFAULT_START + 4
#define IDS_DEFAULT_ISDNName                 IDS_DEFAULT_START + 5
#define IDS_DEFAULT_ISDNName_Type            IDS_DEFAULT_START + 6
#define IDS_DEFAULT_PPPOEName                IDS_DEFAULT_START + 7
#define IDS_DEFAULT_PPPOEName_Type           IDS_DEFAULT_START + 8
#define IDS_DEFAULT_IncomingName             IDS_DEFAULT_START + 9
#define IDS_DEFAULT_IncomingName_Type        IDS_DEFAULT_START + 10
#define IDS_DEFAULT_LANName                  IDS_DEFAULT_START + 11
#define IDS_DEFAULT_LANName_Type             IDS_DEFAULT_START + 12
#define IDS_DEFAULT_WirelessName             IDS_DEFAULT_START + 13
#define IDS_DEFAULT_WirelessName_Type        IDS_DEFAULT_START + 14
#define IDS_DEFAULT_BRIDGEName               IDS_DEFAULT_START + 15
#define IDS_DEFAULT_BRIDGEName_Type          IDS_DEFAULT_START + 16
#define IDS_DEFAULT_SAHLANName               IDS_DEFAULT_START + 17
#define IDS_DEFAULT_SAHLANName_Type          IDS_DEFAULT_START + 18
#define IDS_DEFAULT_SAHRASName               IDS_DEFAULT_START + 19
#define IDS_DEFAULT_SAHRASName_Type          IDS_DEFAULT_START + 20
#define IDS_DEFAULT_ATMName                  IDS_DEFAULT_START + 21
#define IDS_DEFAULT_ATMName_Type             IDS_DEFAULT_START + 22
#define IDS_DEFAULT_ELANName                 IDS_DEFAULT_START + 23
#define IDS_DEFAULT_ELANName_Type            IDS_DEFAULT_START + 24
#define IDS_DEFAULT_1394Name                 IDS_DEFAULT_START + 25
#define IDS_DEFAULT_1394Name_Type            IDS_DEFAULT_START + 26
#define IDS_TO_THE_INTERNET                  IDS_DEFAULT_START + 27
#define IDS_ON_THE_HOMENET                   IDS_DEFAULT_START + 28
#define IDS_DEFAULT_DIRECTName               IDS_DEFAULT_START + 29
#define IDS_DEFAULT_DIRECTName_Type          IDS_DEFAULT_START + 30

#define IDS_RESERVED_INCOMING                IDS_DEFAULT_IncomingName
#define IDS_RESERVED_NCW                     IDS_DEFAULT_START + 31
#define IDS_RESERVED_HNW                     IDS_DEFAULT_START + 32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\lancmn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L A N C M N . H
//
//  Contents:   Declarations of LAN Connection related functions common
//              to the shell and netman.
//
//  Notes:
//
//  Author:     danielwe   7 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "netcfgx.h"
#include "netcon.h"
#include "netconp.h"
#include "iptypes.h"

EXTERN_C const CLSID CLSID_LanConnectionManager;

enum OCC_FLAGS
{
    OCCF_NONE                   = 0x0000,
    OCCF_CREATE_IF_NOT_EXIST    = 0x0001,
    OCCF_DELETE_IF_EXIST        = 0x0002,
};

HRESULT HrOpenConnectionKey(const GUID* pguid, PCWSTR pszGuid, REGSAM sam,
                            OCC_FLAGS occFlags, PCWSTR pszPnpId, HKEY *phkey);

HRESULT HrOpenHwConnectionKey(REFGUID guid, REGSAM sam, OCC_FLAGS occFlags,
                              HKEY *phkey);
HRESULT HrIsConnectionNameUnique(REFGUID guidExclude,
                                 PCWSTR szwName);
HRESULT HrPnccFromGuid(INetCfg *pnc, const GUID &refGuid,
                       INetCfgComponent **ppncc);

HRESULT HrIsConnection(INetCfgComponent *pncc);
HRESULT HrGetDeviceGuid(INetConnection *pconn, GUID *pguid);
BOOL FPconnEqualGuid(INetConnection *pconn, REFGUID guid);

HRESULT HrGetPseudoMediaTypeFromConnection(IN REFGUID guidConn, OUT NETCON_SUBMEDIATYPE *pncsm);

inline
BOOL
FIsDeviceFunctioning(ULONG ulProblem)
{
    // ulProblem is returned by calling CM_Get_DevNode_Status_Ex
    // or INetCfgComponent->GetDeviceStatus
    //
    // "Functioning" means the device is enabled and started with
    // no problem codes, or it is disabled and stopped with no
    // problem codes.

    return (ulProblem == 0) || (ulProblem == CM_PROB_DISABLED);
};

EXTERN_C HRESULT WINAPI HrPnpInstanceIdFromGuid(const GUID* pguid,
                                                PWSTR szwInstance,
                                                UINT cchInstance);

EXTERN_C HRESULT WINAPI HrGetPnpDeviceStatus(const GUID* pguid,
                                             NETCON_STATUS *pStatus);
EXTERN_C HRESULT WINAPI HrQueryLanMediaState(const GUID* pguid,
                                             BOOL* pfEnabled);

BOOL FIsMediaPresent(const GUID *pguid);
HRESULT HrGetDevInstStatus(DEVINST devinst, const GUID *pguid,
                           NETCON_STATUS *pStatus);

HRESULT HrGetRegInstanceKeyForAdapter(IN LPGUID pguidId, 
                                      OUT LPWSTR lpszRegInstance);
BOOL HasValidAddress(IN PIP_ADAPTER_INFO pAdapterInfo);
HRESULT HrGetAddressStatusForAdapter(IN LPCGUID pguidAdapter, 
                                     OUT BOOL* pbValidAddress);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\kkutils.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       K K U T I L S . H
//
//  Contents:   Misc. helper functions
//
//  Notes:
//
//  Author:     kumarp   14 Jan 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "kkstl.h"

#ifndef NCAPI
#define NCAPI          extern "C" HRESULT __declspec(dllexport)
#endif

#ifdef ENABLETRACE
#define DefineFunctionName(name) static char __FUNCNAME__[] = name
#else
#define DefineFunctionName(name) (void) 0
#define __FUNCNAME__    ""
#endif

#define DeleteIfNotNull(p)  \
    delete p; \
    p = NULL;

#define ReturnHrIfFailedSz(hr,msg)  if (FAILED(hr)) \
                                    { \
                                       TraceError(msg, hr); \
                                       return hr; \
                                    }
#define ReturnHrIfFailed(hr)        if (FAILED(hr)) \
                                    { \
                                       TraceError(__FUNCNAME__, hr); \
                                       return hr; \
                                    }
#define ReturnErrorIf(condition,hr) if (condition) \
                                    { \
                                       TraceError(__FUNCNAME__, hr); \
                                       return hr; \
                                    }
#define ReturnError(hr)             if (1) { TraceFunctionError(hr); return hr; }
#define DoErrorCleanupAndReturnError(status_var,error_code) \
                                    { \
                                       status_var = error_code; \
                                       goto error_cleanup; \
                                    }
#define DoErrorCleanupAndReturnErrorIf(condition,status_var,error_code) \
                                    if (condition) \
                                    { \
                                       status_var = error_code; \
                                       goto error_cleanup; \
                                    }

#define TraceFunctionEntry(ttid)    TraceTag(ttid, "---------> entering %s", __FUNCNAME__)
#define TraceFunctionError(hr)      TraceError(__FUNCNAME__, hr)
#define TraceLastWin32ErrorInCurrentFunction() TraceLastWin32Error(__FUNCNAME__)
#define TraceWin32FunctionError(e)  TraceFunctionError(HRESULT_FROM_WIN32(e))

#define ReturnNULLIf(condition)     if (condition) return NULL
#define BreakIf(condition)          if (condition) break
#define ContinueIf(condition)       if (condition) continue
//#define ReturnFalseIfFailed(hr)     if ((hr) != S_OK) return FALSE
#define DoErrorCleanupIf(condition) if (condition) goto error_cleanup
#define AppendErrorAndReturnFalseIf(condition,e) if (condition) { AppendError(e); return FALSE;}

#define BenignAssert()              AssertSz(FALSE,"Benign Assert (this is not a bug): Click Ignore to continue...")

#define CR L"\n"

void AddOnlyOnceToStringList(IN TStringList* psl, IN PCWSTR pszString);
void ConvertDelimitedListToStringList(IN const tstring& strDelimitedList,
                      IN WCHAR chDelimiter,
                      OUT TStringList &slList);
void ConvertCommaDelimitedListToStringList(IN const tstring& strDelimitedList,
                                           OUT TStringList &slList);
void ConvertSpaceDelimitedListToStringList(IN const tstring& strDelimitedList,
                                           OUT TStringList &slList);


void ConvertStringListToCommaList(IN const TStringList &slList,
                                  OUT tstring &strList);
void ConvertStringListToDelimitedList(IN const TStringList &slList,
                                      OUT tstring &strList, IN WCHAR chDelimiter);

BOOL IsBoolString(IN PCWSTR pszStr, OUT BOOL *pbValue);

BOOL UpgradingFromNT(IN DWORD dwUpgradeFlag);

BOOL FIsInStringArray(
    IN const PCWSTR* ppszStrings,
    IN DWORD cNumStrings,
    IN PCWSTR pszStringToFind,
    OUT UINT* puIndex=NULL);

HRESULT HrRegOpenServiceKey(IN PCWSTR pszServiceName,
                            REGSAM samDesired,
                            OUT HKEY* phKey);
HRESULT HrRegOpenServiceSubKey(IN PCWSTR pszServiceName,
                               IN PCWSTR pszSubKey,
                               REGSAM samDesired,
                               OUT HKEY* phKey);
BOOL FIsServiceKeyPresent(IN PCWSTR pszServiceName);

void AppendToPath(IN OUT tstring* pstrPath, IN PCWSTR pszItem);
void EraseAndDeleteAll(IN TStringArray* sa);
void ConvertDelimitedListToStringArray(IN const tstring& strDelimitedList,
                                       IN WCHAR chDelimiter,
                                       OUT TStringArray &saStrings);
void ConvertCommaDelimitedListToStringArray(IN const tstring& strDelimitedList,
                                            OUT TStringArray &saStrings);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\kkstl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       K K S T L . H
//
//  Contents:
//
//  Notes:
//
//  Author:     kumarp
//
//----------------------------------------------------------------------------

#pragma once
#include "ncstring.h"

typedef list<PVOID> TPtrList;
typedef TPtrList::iterator TPtrListIter;

typedef list<tstring*> TStringList;
typedef TStringList::iterator TStringListIter;

typedef vector<BYTE> TByteArray;

typedef vector<tstring*> TStringArray;

// ----------------------------------------------------------------------

void FormatTString(IN OUT tstring& str, IN PCWSTR pszFormat, ...);

inline void AddAtEndOfStringList(IN TStringList& sl,
                                            IN PCWSTR pszString)
{
    sl.push_back(new tstring(pszString));
}

inline void AddAtEndOfStringList(IN TStringList& sl,
                                            IN const tstring* pstr)
{
    sl.push_back(new tstring(*pstr));
}

inline void AddAtEndOfStringList(IN TStringList& sl,
                                            IN const tstring& pstr)
{
    sl.push_back(new tstring(pstr));
}

inline void AddAtBeginningOfStringList(IN TStringList& sl,
                                                  IN const tstring& pstr)
{
    sl.push_front(new tstring(pstr));
}


BOOL FIsInStringList(IN const TStringList& sl, IN tstring& str,
                     OUT TStringListIter* pos=NULL);
BOOL FIsInStringList(IN const TStringList& sl, IN PCWSTR psz,
                     OUT TStringListIter* pos=NULL);

tstring* GetNthItem(IN TStringList& sl, IN DWORD dwIndex);

// ----------------------------------------------------------------------

inline TPtrListIter AddAtEndOfPtrList(IN TPtrList& pl, IN PVOID pv)
{
    return pl.insert(pl.end(), pv);
}


inline TPtrListIter GetIterAtBack(IN const TPtrList* ppl)
{
    TPtrListIter pliRet = ppl->end();
    pliRet--;
    return pliRet;
}

inline void EraseAll(IN TPtrList* ppl)
{
    ppl->erase(ppl->begin(), ppl->end());
}

void EraseAndDeleteAll(IN TPtrList* ppl);
void EraseAndDeleteAll(IN TPtrList& ppl);

inline void EraseAll(IN TStringList* ppl)
{
    ppl->erase(ppl->begin(), ppl->end());
}

void EraseAndDeleteAll(IN TStringList* ppl);
void EraseAndDeleteAll(IN TStringList& ppl);

// ----------------------------------------------------------------------

void GetDataFromByteArray(IN const TByteArray& ba, OUT BYTE*& pb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\naming.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       N A M I N G . H
//
//  Contents:   Generates Connection Names Automatically
//
//  Notes:
//
//  Author:     deonb    27 Feb 2001
//
//----------------------------------------------------------------------------

#pragma once

#include "nameres.h"
#include "netconp.h"

using namespace std;

class CIntelliName;
typedef BOOL FNDuplicateNameCheck(IN CIntelliName *pIntelliName, IN LPCTSTR szName, NETCON_MEDIATYPE *pncm, NETCON_SUBMEDIATYPE *pncms);

class CIntelliName
{
    FNDuplicateNameCheck* m_pFNDuplicateNameCheck;
    HINSTANCE m_hInstance;

private:
    BOOL NameExists(IN LPCWSTR szName, IN OUT NETCON_MEDIATYPE *pncm, IN NETCON_SUBMEDIATYPE *pncms);
    HRESULT GenerateNameRenameOnConflict(IN REFGUID guid, IN NETCON_MEDIATYPE ncm, IN DWORD dwCharacteristics, IN LPCWSTR szHintName, IN LPCWSTR szHintType, OUT LPWSTR * szName);
    HRESULT GenerateNameFromResource(IN REFGUID guid, IN NETCON_MEDIATYPE ncm, IN DWORD dwCharacteristics, IN LPCWSTR szHint, IN UINT uiNameID, IN UINT uiTypeId, OUT LPWSTR *szName);
    BOOL IsReservedName(LPCWSTR szName);

public:
    HRESULT HrGetPseudoMediaTypes(IN REFGUID guid, OUT NETCON_MEDIATYPE *pncm, OUT NETCON_SUBMEDIATYPE *pncms);

    // Pass NULL for no Duplicate Check
    CIntelliName(HINSTANCE hInstance, FNDuplicateNameCheck *pFNDuplicateNameCheck);

    // Must LocalFree szName for these:
    HRESULT GenerateName(IN REFGUID guid, IN NETCON_MEDIATYPE ncm, IN DWORD dwCharacteristics, IN LPCWSTR szHint, OUT LPWSTR * szName);
    HRESULT GenerateInternetName(IN REFGUID guid, IN NETCON_MEDIATYPE ncm, IN DWORD dwCharacteristics, OUT LPWSTR * szName);
    HRESULT GenerateHomeNetName(IN REFGUID guid, IN NETCON_MEDIATYPE ncm, IN DWORD dwCharacteristics, OUT LPWSTR * szName);

};

BOOL IsMediaWireless(NETCON_MEDIATYPE ncm, const GUID &gdDevice);
BOOL IsMedia1394(NETCON_MEDIATYPE ncm, const GUID &gdDevice);

#ifndef _NTDDNDIS_
typedef ULONG NDIS_OID, *PNDIS_OID;
#endif
HRESULT HrQueryDeviceOIDByName(IN     LPCWSTR         szDeviceName,
                               IN     DWORD           dwIoControlCode,
                               IN     ULONG           Oid,
                               IN OUT LPDWORD         pnSize,
                               OUT    LPVOID          pbValue);

HRESULT HrQueryNDISAdapterOID(IN     REFGUID         guidId,
                              IN     NDIS_OID        Oid,
                              IN OUT LPDWORD         pnSize,
                              OUT    LPVOID          pbValue);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncatlps.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C A T L P S . H
//
//  Contents:   Class definition for ATL-like property sheet page object.
//
//  Notes:
//
//  Author:     danielwe   28 Feb 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCATLPS_H_
#define _NCATLPS_H_

#include <prsht.h>

class CPropSheetPage : public CWindow, public CMessageMap
{
public:
    virtual ~CPropSheetPage();

    VOID SetChangedFlag() const
    {
        ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);
    }
    VOID SetUnchangedFlag() const
    {
        ::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0);
    }

    virtual UINT UCreatePageCallbackHandler()
    {
        return TRUE;
    }

    virtual VOID DestroyPageCallbackHandler() {}


    HPROPSHEETPAGE  CreatePage(UINT unId, DWORD dwFlags,
                               PCWSTR pszHeaderTitle = NULL,
                               PCWSTR pszHeaderSubTitle = NULL,
                               PCWSTR pszTitle = NULL,
                               OPTIONAL HINSTANCE hInstance = NULL);

    static LRESULT CALLBACK DialogProc(HWND hWnd, UINT uMsg,
                                       WPARAM wParam, LPARAM lParam);

    static UINT CALLBACK PropSheetPageProc(HWND hWnd, UINT uMsg,
                                           LPPROPSHEETPAGE ppsp);
};

#endif // _NCATLPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncatlui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C A T L U I . H
//
//  Contents:   UI common code relying on ATL.
//
//  Notes:
//
//  Author:     shaunco   13 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCATLUI_H_
#define _NCATLUI_H_


NOTHROW
int
WINAPIV
NcMsgBox (
        HWND    hwnd,
        UINT    unIdCaption,
        UINT    unIdFormat,
        UINT    unStyle,
        ...);


#endif // _NCATLUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncatl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C A T L . H
//
//  Contents:   Common code for use with ATL.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   22 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCATL_H_
#define _NCATL_H_

#include "ncstring.h"

//
// This file should be included *after* your standard ATL include sequence.
//
//      #include <atlbase.h>
//      extern CComModule _Module;
//      #include <atlcom.h>
//      #include "ncatl.h"      <------
//
// We cannot directly include that sequence here because _Module may be
// derived from CComModule as opposed to an instance of it.
//

class CExceptionSafeComObjectLock
{
public:
    CExceptionSafeComObjectLock (CComObjectRootEx <CComObjectThreadModel>* pObj)
    {
        AssertH (pObj);
        m_pObj = pObj;
        TraceTag (ttidEsLock,
            "Entered critical section object of COM object 0x%08x",
            &m_pObj);
        pObj->Lock ();
    }

    ~CExceptionSafeComObjectLock ()
    {
        TraceTag (ttidEsLock,
            "Leaving critical section object of COM object 0x%08x",
            &m_pObj);

        m_pObj->Unlock ();
    }

protected:
    CComObjectRootEx <CComObjectThreadModel>* m_pObj;
};


//+---------------------------------------------------------------------------
//
//  Function:   HrCopyIUnknownArrayWhileLocked
//
//  Purpose:    Allocate and copy an array of IUnknown pointers from an ATL
//              CComDynamicUnkArray while holding the object which controls
//              the CComDynamicUnkArray locked.  This is needed by objects
//              which dispatch calls on a connection point's advise sink
//              to prevent the CComDynamicUnkArray from being modified (via
//              calls to Advise/Unadvise on other threads) while they are
//              dispatching.  An atomic copy is made so the dispatcher can
//              then make the lengthy callbacks without the need to hold
//              the owner object locked.
//
//  Arguments:
//      pObj  [in]  Pointer to object which has Lock/Unlock methods.
//      pVec  [in]  ATL array of IUnknown's to copy.
//      pcUnk [out] Address of returned count of IUnknown pointerss
//                  in *paUnk.
//      paUnk [out] Address of allocated pointer to the array of IUnknown
//                  pointers.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Author:     shaunco   3 Dec 1998
//
//  Notes:      The returned count and array may be NULL when no IUnknowns
//              existed in the input array.  S_OK will be returned for this
//              case too, so be sure to check *pcUnk and *paUnk too.
//
inline
HRESULT
HrCopyIUnknownArrayWhileLocked (
    IN  CComObjectRootEx <CComObjectThreadModel>* pObj,
    IN  CComDynamicUnkArray* pVec,
    OUT ULONG* pcpUnk,
    OUT IUnknown*** papUnk)
{
    HRESULT hr = S_OK;
    IUnknown** ppUnkSrc;
    IUnknown** ppUnkDst;

    // Initialize the output parameters.
    //
    *pcpUnk = 0;
    *papUnk = NULL;

    pObj->Lock();

    // First, count the number of IUnknown's we need to copy.
    //
    ULONG cpUnk = 0;
    for (ppUnkSrc = pVec->begin(); ppUnkSrc < pVec->end(); ppUnkSrc++)
    {
        if (ppUnkSrc && *ppUnkSrc)
        {
            cpUnk++;
        }
    }

    // Allocate space and copy the IUnknown's.  (Be sure to AddRef them.)
    //
    if (cpUnk)
    {
        hr = E_OUTOFMEMORY;
        ppUnkDst = (IUnknown**)MemAlloc (cpUnk * sizeof(IUnknown*));
        if (ppUnkDst)
        {
            hr = S_OK;

            *pcpUnk = cpUnk;
            *papUnk = ppUnkDst;

            for (ppUnkSrc = pVec->begin(); ppUnkSrc < pVec->end(); ppUnkSrc++)
            {
                if (ppUnkSrc && *ppUnkSrc)
                {
                    *ppUnkDst = *ppUnkSrc;
                    AddRefObj(*ppUnkDst);
                    ppUnkDst++;
                    cpUnk--;
                }
            }

            // We should have copied what we counted.
            //
            AssertH(0 == cpUnk);
        }
    }

    pObj->Unlock();

    TraceHr (ttidError, FAL, hr, FALSE, "HrCopyIUnknownArrayWhileLocked");
    return hr;
}


#define DECLARE_CLASSFACTORY_DEFERRED_SINGLETON(obj) DECLARE_CLASSFACTORY_EX(CComClassFactoryDeferredSingleton<obj>)

//+---------------------------------------------------------------------------
// Deferred Singleton Class Factory
//
template <class T>
class CComClassFactoryDeferredSingleton : public CComClassFactory
{
public:
    CComClassFactoryDeferredSingleton () : m_pObj(NULL) {}
    ~CComClassFactoryDeferredSingleton() { delete m_pObj; }

    // IClassFactory
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
    {
        HRESULT hr = E_POINTER;
        if (ppvObj != NULL)
        {
            // can't ask for anything other than IUnknown when aggregating
            //
            AssertH(!pUnkOuter || InlineIsEqualUnknown(riid));
            if (pUnkOuter && !InlineIsEqualUnknown(riid))
            {
                hr = CLASS_E_NOAGGREGATION;
            }
            else
            {
                // Need to protect m_pObj from being created more than once
                // by multiple threads calling this method simultaneously.
                // (I've seen this happen on multi-proc machines.)
                //
                Lock ();

                if (m_pObj)
                {
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    m_pObj = new CComObjectGlobal<T>;
                    if (m_pObj)
                    {
                        hr = m_pObj->m_hResFinalConstruct;
                    }
                }

                Unlock ();

                if (SUCCEEDED(hr))
                {
                    hr = m_pObj->QueryInterface(riid, ppvObj);
                }
            }
        }
        return hr;
    }
    CComObjectGlobal<T>* m_pObj;
};

// We have our own version of AtlModuleRegisterServer coded here
// because the former brings in oleaut32.dll so it can register
// type libraries.  We don't care to have a type library registered
// so we can avoid the whole the mess associated with oleaut32.dll.
//
inline
HRESULT
NcAtlModuleRegisterServer(
    _ATL_MODULE* pM
    )
{
    AssertH (pM);
    AssertH(pM->m_hInst);
    AssertH(pM->m_pObjMap);

    HRESULT hr = S_OK;

    for (_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
         pEntry->pclsid;
         pEntry++)
    {
        if (pEntry->pfnGetObjectDescription() != NULL)
        {
            continue;
        }

        hr = pEntry->pfnUpdateRegistry(TRUE);
        if (FAILED(hr))
        {
            break;
        }
    }

    TraceError ("NcAtlModuleRegisterServer", hr);
    return hr;
}

#ifdef __ATLCOM_H__
//+---------------------------------------------------------------------------
//
//  Function:   SzLoadIds
//
//  Purpose:    Loads the given string ID from the resource file.
//
//  Arguments:
//      unId [in]   ID of string resource to load.
//
//  Returns:    Read-only version of resource string.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      1) You must be compiling with ATL support to use this function.
//              2) The returned string CANNOT be modified.
//              3) You must compile your RC file with the -N option for this
//                 to work properly.
//
inline
PCWSTR
SzLoadIds (
        UINT    unId)
{
    return SzLoadString (_Module.GetResourceInstance(), unId);
}
#endif  //!__ATLCOM_H__

#endif // _NCATL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\nccfgmgr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       N C C F G M G R.H
//
//  Contents:   Common code useful when using the Configuration Manager APIs.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   6 May 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCCFGMGR_H_
#define _NCCFGMGR_H_

#include "ncdefine.h"   // for NOTHROW

NOTHROW
HRESULT
HrFromConfigManagerError (
    CONFIGRET   cr,
    HRESULT     hrDefault);

#endif // _NCCFGMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncdefine.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       N C D E F I N E . H
//
//  Contents:   Very generic defines for netcfg. Don't throw non-generic crap
//              in here! No iterators for NetCfgBindingPaths, etc. etc.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     jeffspr   20 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCDEFINE_H_
#define _NCDEFINE_H_

#define BEGIN_CONST_SECTION     data_seg(".rdata")
#define END_CONST_SECTION       data_seg()

#define celems(_x)          (sizeof(_x) / sizeof(_x[0]))

#ifdef NOTHROW
#undef NOTHROW
#endif
#define NOTHROW __declspec(nothrow)

// Defines for C source files including us.
//
#ifndef __cplusplus
#ifndef inline
#define inline  __inline
#endif
#endif


// Generic flags used when inserting elements into collections.
//
enum INS_FLAGS
{
    INS_ASSERT_IF_DUP   = 0x00000100,
    INS_IGNORE_IF_DUP   = 0x00000200,
    INS_APPEND          = 0x00000400,
    INS_INSERT          = 0x00000800,
    INS_SORTED          = 0x00001000,
    INS_NON_SORTED      = 0x00002000,
};


#endif // _NCDEFINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C B A S E . H
//
//  Contents:   Basic common code.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   20 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCBASE_H_
#define _NCBASE_H_

#include "ncdefine.h"   // for NOTHROW

#define STACK_SIZE_DEFAULT  0
#define STACK_SIZE_TINY     256
#define STACK_SIZE_SMALL    65536
#define STACK_SIZE_COMPACT  262144
#define STACK_SIZE_LARGE    1048576
#define STACK_SIZE_HUGE     5242880

NOTHROW
ULONG
AddRefObj (
    IUnknown* punk);

NOTHROW
ULONG
ReleaseObj (
    IUnknown* punk);


NOTHROW
DWORD
DwWin32ErrorFromHr (
    HRESULT hr);


inline
BOOL
FDwordWithinRange (
    DWORD   dwLower,
    DWORD   dw,
    DWORD   dwUpper)
{
    return ((dw >= dwLower) && (dw <= dwUpper));
}


NOTHROW
HRESULT
HrFromLastWin32Error ();


HRESULT
HrGetProcAddress (
    HMODULE     hModule,
    PCSTR       pszaFunction,
    FARPROC*    ppfn);

HRESULT
HrLoadLibAndGetProcs (
    PCWSTR          pszLibPath,
    UINT            cFunctions,
    const PCSTR*    apszaFunctionNames,
    HMODULE*        phmod,
    FARPROC*        apfn);

inline
HRESULT
HrLoadLibAndGetProc (
    PCWSTR      pszLibPath,
    PCSTR       pszaFunctionName,
    HMODULE*    phmod,
    FARPROC*    ppfn)
{
    return HrLoadLibAndGetProcs (pszLibPath, 1, &pszaFunctionName, phmod, ppfn);
}

HRESULT
__cdecl
HrGetProcAddressesV(
    HMODULE hModule, ...);

HRESULT
__cdecl
HrLoadLibAndGetProcsV(
    PCWSTR      pszLibPath,
    HMODULE*    phModule,
    ...);

HRESULT
HrCreateEventWithWorldAccess(PCWSTR pszName, BOOL fManualReset,
        BOOL fInitialState, BOOL* pfAlreadyExists, HANDLE* phEvent);

HRESULT
HrCreateMutexWithWorldAccess(PCWSTR pszName, BOOL fInitialOwner,
        BOOL* pfAlreadyExists, HANDLE* phMutex);

HRESULT
HrCreateInstanceBase (REFCLSID rclsid, DWORD dwClsContext, REFIID riid, LPVOID * ppv);

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateInstance
//
//  Purpose:    Creates a COM object and sets default proxy settings.
//
//  Arguments:
//      rclsid          [in]  See documentation for CoCreateInstance.
//      dwClsContext    [in]  ""
//      ppInter         [out] Typed interface pointer using templates.
//
//  Returns:    S_OK on success. An error code otherwise.
//
//  Author:     mbend   1 Mar 2000
//
template <class Inter>
inline HRESULT
HrCreateInstance (
    REFCLSID rclsid,
    DWORD dwClsContext,
    Inter ** ppInter)
{
    return HrCreateInstanceBase(rclsid, dwClsContext, __uuidof(Inter), reinterpret_cast<void**>(ppInter));
}

HRESULT
HrQIAndSetProxyBlanketBase(IUnknown * pUnk, REFIID riid, void ** ppv);

//+---------------------------------------------------------------------------
//
//  Function:   HrQIAndSetProxyBlanket
//
//  Purpose:    Performs QueryInterface and sets default proxy settings.
//
//  Arguments:
//      pUnk            [in]  Interface pointer to perform QueryInterface on.
//      ppInter         [out] Typed interface pointer using templates.
//
//  Returns:    S_OK on success. An error code otherwise.
//
//  Author:     mbend   1 Mar 2000
//
template <class Inter>
inline HRESULT
HrQIAndSetProxyBlanket (
    IUnknown * pUnk,
    Inter ** ppInter)
{
    return HrQIAndSetProxyBlanketBase(pUnk, __uuidof(Inter), reinterpret_cast<void**>(ppInter));
}


#endif // _NCBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\nccom.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C C O M . H
//
//  Contents:   Common routines for dealing with COM.
//
//  Notes:
//
//  Author:     shaunco   25 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCCOM_H_
#define _NCCOM_H_

#include "ncdefine.h"   // for NOTHROW
#include "ncstlstr.h"

HRESULT
HrCoTaskMemAlloc (
    ULONG   cb,
    VOID**  ppv);

HRESULT
HrCoTaskMemAllocAndDupSzLen (
    IN PCWSTR pszwSrc,
    IN ULONG cchSrc,
    OUT PWSTR* ppszwDst);

HRESULT
HrCoTaskMemAllocAndDupSz (
    IN PCWSTR pszwSrc,
    OUT PWSTR* ppszwDst);

VOID
NcSetProxyBlanket (
    IN IUnknown* pUnk);

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseIUnknownArray
//
//  Purpose:    Releases an array of IUnknown pointers.
//
//  Arguments:
//      cpunk [in]  count of pointers to release
//      apunk [in]  array of pointers to release
//
//  Returns:    Nothing
//
//  Author:     shaunco   23 Mar 1997
//
//  Notes:      Any of the pointers in the array can be NULL.
//
inline
NOTHROW
VOID
ReleaseIUnknownArray (
    ULONG       cpunk,
    IUnknown**  apunk)
{
    AssertH (apunk);

    while (cpunk--)
    {
        ReleaseObj (*apunk);
        apunk++;
    }
}

//------------------------------------------------------------------------
// CIEnumIter - template iterator for IEnumIUnknown
//
//  Tenum is of type IEnumXXX (the enumeration interface)
//  Telt is of type XXX (the type of the element being enumerated)
//
//  HrNext(Telt* pelt) retreives next interface pointer and returns S_OK
//  if it is non-null.  S_FALSE is returned if *pelt is null (at end of list).
//  An error code will be returned for other failures (and *pelt will be
//  null of course.)
//
template <class Tenum, class Telt>
class CIEnumIter
{
public:
    NOTHROW CIEnumIter (Tenum* penum);
    NOTHROW ~CIEnumIter () { ReleaseRemainingBatch (); }

    NOTHROW HRESULT HrNext(Telt* pelt);
    NOTHROW VOID    SetEnumerator(Tenum* penum)
                { AssertSzH(!m_penum, "Enumerator already set.");
                  m_penum = penum;
                  AssertSzH(m_penum, "Can't use a null enumerator."); }

protected:
    NOTHROW VOID ReleaseRemainingBatch ();

    Tenum*  m_penum;        // pointer to the enumerator.  not addref'd.
    Telt*   m_aelt;         // array of enumerated types.
    Telt*   m_peltNext;     // pointer to next type to be returned.
    ULONG   m_celtFetched;  // number of elements fetched.
    HRESULT m_hrLast;       // last error
};


//------------------------------------------------------------------------
// CIEnumIter - template iterator for IEnumXXX
//
template <class Tenum, class Telt>
inline CIEnumIter<Tenum, Telt>::CIEnumIter(Tenum* penum)
{
    m_penum         = penum;
    m_aelt          = NULL;
    m_peltNext      = NULL;
    m_celtFetched   = NULL;
    m_hrLast        = S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIEnumIter<Tenum, Telt>::HrNext
//
//  Purpose:    Returns the next item in the enumeration.
//
//  Arguments:
//      pelt [out]  Pointer to the returned elemnt.  Null if not available.
//
//  Returns:    S_OK if *pelt is valid.  S_FALSE if it is NULL.  Error
//              otherwise.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:
//
template <class Tenum, class Telt>
inline NOTHROW HRESULT CIEnumIter<Tenum, Telt>::HrNext(Telt* pelt)
{
    AssertH(pelt);

    const ULONG c_celtBatch = 256;

    // If we failed for any reason before, return that failure.
    //
    if (FAILED(m_hrLast))
    {
        *pelt = NULL;
        goto error;
    }

    AssertSzH(m_penum, "m_penum is null.  Did you forget to call SetEnumerator()?");
    AssertSzH(c_celtBatch, "c_celtBatch can't be zero.");

    // If we already have the next interface pointer, and we're
    // not at the end of the batch, return it and advance.
    // This if should be caught most of the time.
    //
    if (m_peltNext && (m_peltNext < m_aelt + m_celtFetched))
    {
        *pelt = *m_peltNext;
        m_peltNext++;
    }

    // Otherwise, if we don't have the next interface pointer (first time),
    // or we're at the end of the batch, get the next batch and return
    // the first pointer in it.
    // This if should be caught the first time through.
    //
    else if (!m_peltNext || (m_celtFetched == c_celtBatch))
    {
        // Indicate that m_peltNext is invalid.
        //
        m_peltNext = NULL;

        // Free the old block of pointers
        MemFree(m_aelt);

        // Allocate the next block of pointers
        m_aelt = reinterpret_cast<Telt *>(MemAlloc(c_celtBatch * sizeof(Telt *)));
        if (!m_aelt)
        {
            *pelt = NULL;
            m_hrLast = E_OUTOFMEMORY;
            goto error;
        }

        AssertH (m_aelt);

        // Get the next batch.
        //
        m_hrLast = m_penum->Next(c_celtBatch, m_aelt, &m_celtFetched);

        // Make sure the implementor of Next is obeying the rules.
        AssertH (FImplies((S_OK == m_hrLast), (m_celtFetched == c_celtBatch)));
        AssertH (FImplies((SUCCEEDED(m_hrLast) && (0 == m_celtFetched)), (NULL == *m_aelt)));

        // If we were successful, set the next pointer and return
        // S_OK if we returned a valid pointer or S_FALSE if we
        // returned NULL.
        //
        if (SUCCEEDED(m_hrLast))
        {
            m_peltNext = m_aelt + 1;
            if (m_celtFetched)
            {
                *pelt = *m_aelt;
                m_hrLast = S_OK;
            }
            else
            {
                *pelt = NULL;
                m_hrLast = S_FALSE;
            }
        }
        else
        {
            *pelt = NULL;
        }
    }

    // Otherwise we've completely iterated the last batch and there are
    // no more batches.
    //
    else
    {
        AssertH(m_peltNext >= m_aelt + m_celtFetched);
        AssertH(m_celtFetched != c_celtBatch);

        *pelt = NULL;
        m_hrLast = S_FALSE;
    }

error:
    AssertH(FIff(S_OK == m_hrLast, NULL != *pelt));
    AssertH(FImplies(S_FALSE == m_hrLast, NULL == *pelt));

    TraceError("CIEnumIter<Tenum, Telt>::HrNext(Telt* pelt)",
               (S_FALSE == m_hrLast) ? S_OK : m_hrLast);
    return m_hrLast;
}

template <class Tenum, class Telt>
inline NOTHROW VOID CIEnumIter<Tenum, Telt>::ReleaseRemainingBatch ()
{
    // This needs to be run if the user doesn't completely iterate the
    // batch.  Finish releasing the interface pointers and free the batch.
    //
    if (m_peltNext && m_aelt)
    {
        while (m_peltNext < m_aelt + m_celtFetched)
        {
            ReleaseObj (*m_peltNext);
            m_peltNext++;
        }

        MemFree (m_aelt);
    }

    // If this method is ever called from anywhere other than just
    // the destructor, uncomment the following lines.
    // m_peltNext = NULL;
    // m_aelt = NULL;
}


#endif // _NCCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncdebug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C D E B U G . H
//
//  Contents:   Debug routines.
//
//  Notes:
//
//  Author:     danielwe   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCDEBUG_H_
#define _NCDEBUG_H_

#include "dbgflags.h"       // For debugflags id definitions
#include "trace.h"

NOTHROW void InitializeDebugging ();
NOTHROW void UnInitializeDebugging ();


//
//  Useful macros to use with Asserts.
//  Eg,     Assert(FImplies(sz, !*sz));
//          Assert(FIff(sz, cch));
//
#define FImplies(a,b)       (!(a) || (b))
#define FIff(a,b)           (!(a) == !(b))


//
//  "Normal" assertion checking.  Provided for compatibility with
//  imported code.
//
//      Assert(a)       Displays a message indicating the file and line number
//                      of this Assert() if a == 0.
//      AssertSz(a,b)   As Assert(); also displays the message b (which should
//                      be a string literal.)
//      SideAssert(a)   As Assert(); the expression a is evaluated even if
//                      asserts are disabled.
//
#undef AssertSz
#undef Assert


//+---------------------------------------------------------------------------
//
// DBG (checked) build
//
#ifdef DBG

VOID
DbgCheckPrematureDllUnload (
    PCSTR pszaDllName,
    UINT ModuleLockCount);

typedef VOID     (CALLBACK * PFNASSERTHOOK)(PCSTR, PCSTR, int);
VOID    WINAPI   SetAssertFn             (PFNASSERTHOOK);
BOOL    WINAPI   FInAssert               (VOID);
VOID    WINAPI   AssertSzFn              (PCSTR pszaMsg, PCSTR pszaFile, int nLine);
VOID    WINAPI   AssertSzFn              (PCSTR pszaMsg, PCSTR pszaFile, int nLine, PCSTR pszaFunc);
VOID    WINAPI   AssertSzFnWithDbgPrompt (BOOL fPromptIgnore, PCSTR pszaMsg, PCSTR pszaFile, int nLine, PCSTR pszaFunc);
VOID    CALLBACK DefAssertSzFn           (PCSTR pszaMsg, PCSTR pszaFile, int nLine);

#define Assert(a)       AssertSz(a, "Assert(" #a ")\r\n")
#define AssertSz(a,b)   if (!(a)) AssertSzFn(b, __FILE__, __LINE__);
#define AssertSzWithDbgPromptIgnore(a,b) if (!(a)) AssertSzFnWithDbgPrompt(TRUE, b, __FILE__, __LINE__, __FUNCTION__);
#define AssertSzWithDbgPromptRetry(a,b) if (!(a)) AssertSzFnWithDbgPrompt(FALSE, b, __FILE__, __LINE__, __FUNCTION__);

//#define Assert(exp)       if (!(exp)) RtlAssert(#exp, __FILE__, __LINE__, NULL)
//#define AssertSz(exp,msg) if (!(exp)) RtlAssert(#exp, __FILE__, __LINE__, msg)

#define AssertH         Assert
#define AssertSzH       AssertSz

void WINAPIV AssertFmt(BOOL fExp, PCSTR pszaFile, int nLine, PCSTR pszaFmt, ...);

#define AssertValidReadPtrSz(p,msg)     AssertSz(!IsBadReadPtr(p, sizeof(*p)),  msg)
#define AssertValidWritePtrSz(p,msg)    AssertSz(!IsBadWritePtr(p, sizeof(*p)), msg)
#define AssertValidReadPtr(p)           AssertValidReadPtrSz(p,"Bad read pointer:" #p)
#define AssertValidWritePtr(p)          AssertValidWritePtrSz(p,"Bad write pointer:" #p)

#define SideAssert(a)                   Assert(a)
#define SideAssertH(a)                  AssertH(a)
#define SideAssertSz(a,b)               AssertSz(a,b)
#define SideAssertSzH(a,b)              AssertSzH(a,b)
#define NYI(a)                          AssertSz(FALSE, "NYI: " a)
#define NYIH(a)                         AssertSzH(FALSE, "NYI: " a)


//+---------------------------------------------------------------------------
//
// !DBG (retail) build
//
#else

#define DbgCheckPrematureDllUnload(a,b) NOP_FUNCTION

#define AssertH(a)
#define AssertSzH(a,b)
#define Assert(a)
#define AssertSz(a,b)
#define AssertSzWithDbgPrompt(a,b)
#define AssertFmt                       NOP_FUNCTION
#define AssertValidReadPtrSz(p,msg)     NOP_FUNCTION
#define AssertValidWritePtrSz(p,msg)    NOP_FUNCTION
#define AssertValidReadPtr(p)           NOP_FUNCTION
#define AssertValidWritePtr(p)          NOP_FUNCTION

#define SideAssert(a)                   (a)
#define SideAssertH(a)                  (a)
#define SideAssertSz(a,b)               (a)
#define SideAssertSzH(a,b)              (a)
#define NYI(a)                          NOP_FUNCTION

#endif  // DBG


#endif // _NCDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\nceh.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C E H . H
//
//  Contents:   Exception handling stuff.
//
//  Notes:
//
//  Author:     shaunco   27 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCEH_H_
#define _NCEH_H_


// NC_TRY and NC_CATCH_ALL are #defined to allow easy replacement.  This
// is handy when evaulating SEH (__try, __except) vs. C++ EH (try, catch).
//
#define NC_TRY          __try
#define NC_CATCH_ALL    __except(EXCEPTION_EXECUTE_HANDLER)
#define NC_FINALLY      __finally


// For DEBUG builds, don't catch anything.  This allows the debugger to locate
// the exact source of the exception.

/*
#ifdef DBG
*/

#define COM_PROTECT_TRY

#define COM_PROTECT_CATCH   ;

/*
#else // DBG

#define COM_PROTECT_TRY     __try

#define COM_PROTECT_CATCH   \
    __except (EXCEPTION_EXECUTE_HANDLER ) \
    { \
        hr = E_UNEXPECTED; \
    }

#endif // DBG
*/

#endif // _NCEH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncexcept.h ===
#ifndef DBG
#define NETCFG_TRY try {
#define NETCFG_CATCH(hr) ; }  \
    catch (bad_alloc a) \
    { \
        hr = E_OUTOFMEMORY; \
    } \
    catch (HRESULT hrCaught) \
    { \
        hr = hrCaught; \
    } \
    catch (...) \
    { \
        hr = E_FAIL; \
    }
    
#define NETCFG_CATCH_NOHR ; } \
    catch (bad_alloc a) \
    { \
    } \
    catch (HRESULT hrCaught) \
    { \
    }
    
#define NETCFG_CATCH_AND_RETHROW ; }  \
    catch (...) \
    { \
        throw; \
    }

#else // #ifndef DBG

#define NETCFG_TRY {
#define NETCFG_CATCH(hr) ; }
#define NETCFG_CATCH_NOHR ; }
#define NETCFG_CATCH_AND_RETHROW ; }

/*
#define NETCFG_CATCH(hr) ; }  \
    catch (bad_alloc a) \
    { \
        hr = E_OUTOFMEMORY; \
        TraceException(hr, "bad_alloc"); \
        AssertSzWithDbgPromptIgnore(FALSE, "A bad_alloc exception occurred"); \
        throw; \
    } \
    catch (HRESULT hrCaught) \
    { \
        TraceException(hr, "HRESULT"); \
        hr = hrCaught; \
        CHAR szTemp[MAX_PATH]; \
        sprintf(szTemp, "An HRESULT exception occurred (0x%08x)", hr); \
        AssertSzWithDbgPromptIgnore(FALSE, szTemp); \
        throw; \
    } \
    catch (...) \
    { \
        TraceException(E_FAIL, "HRESULT"); \
        hr = E_FAIL; \
        AssertSzWithDbgPromptIgnore(FALSE, "A general exception occurred."); \
        throw; \
    }
    
#define NETCFG_CATCH_NOHR ; } \
    catch (bad_alloc a) \
    { \
        TraceException(E_OUTOFMEMORY, "bad_alloc"); \
        AssertSzWithDbgPromptIgnore(FALSE, "A bad_alloc exception occurred"); \
        throw; \
    } \
    catch (HRESULT hrCaught) \
    { \
        TraceException(hrCaught, "HRESULT"); \
        CHAR szTemp[MAX_PATH]; \
        sprintf(szTemp, "An HRESULT exception occurred (0x%08x)", hrCaught); \
        AssertSzWithDbgPromptIgnore(FALSE, szTemp); \
        throw; \
    }
    
#define NETCFG_CATCH_AND_RETHROW  }  \
    catch (bad_alloc a) \
    { \
        TraceException(E_OUTOFMEMORY, "bad_alloc"); \
        AssertSzWithDbgPromptIgnore(FALSE, "A bad_alloc exception occurred"); \
        throw; \
    } \
    catch (HRESULT hrCaught) \
    { \
        TraceException(hrCaught, "HRESULT"); \
        CHAR szTemp[MAX_PATH]; \
        sprintf(szTemp, "An HRESULT exception occurred (0x%08x)", hrCaught); \
        AssertSzWithDbgPromptIgnore(FALSE, szTemp); \
        throw; \
    } \
    catch (...) \
    { \
        TraceException(E_FAIL, "Unknown"); \
        AssertSzWithDbgPromptIgnore(FALSE, "A bad_alloc exception occurred"); \
        throw; \
    }
*/

#endif // ifndef DBG

class NC_SEH_Exception 
{
private:
    unsigned int m_uSECode;
public:
    NC_SEH_Exception(unsigned int uSECode) : m_uSECode(uSECode) {}
    NC_SEH_Exception() {}
    ~NC_SEH_Exception() {}
    unsigned int getSeHNumber() { return m_uSECode; }
};

void __cdecl nc_trans_func( unsigned int uSECode, EXCEPTION_POINTERS* pExp );
void EnableCPPExceptionHandling();
void DisableCPPExceptionHandling();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncipaddr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C I P A D D R . H
//
//  Contents:
//
//  Notes:
//
//  Author:     shaunco   11 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCIPADDR_H_
#define _NCIPADDR_H_

VOID
IpHostAddrToPsz(
    IN  DWORD   dwAddr,
    OUT PWSTR   pszBuffer);

DWORD
IpPszToHostAddr(
    IN  PCWSTR pszAddr);


#endif // _NCIPADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncinf.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C I N F . H
//
//  Contents:   ???
//
//  Notes:
//
//  Author:     ???
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCINF_H_
#define _NCINF_H_

typedef HRESULT (CALLBACK *PFNADDCALLBACK)      (HINF hinf, PCWSTR pszSection);
typedef HRESULT (CALLBACK *PFNREMOVECALLBACK)   (HINF hinf, PCWSTR pszSection);
typedef HRESULT (CALLBACK *PFNHRENTRYPOINT)     (PCWSTR, LPGUID);

HRESULT
HrProcessInfExtension (
    HINF                hinfInstallFile,
    PCWSTR              pszSectionName,
    PCWSTR              pszSuffix,
    PCWSTR              pszAddLabel,
    PCWSTR              pszRemoveLabel,
    PFNADDCALLBACK      pfnHrAdd,
    PFNREMOVECALLBACK   pfnHrRemove);

#endif //_NCINF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncmem.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C M E M . H
//
//  Contents:   Common memory management routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCMEM_H_
#define _NCMEM_H_

#include <malloc.h>

VOID*
MemAlloc (
    size_t cb);

VOID*
MemAllocRaiseException (
    size_t  cb);

VOID
MemFree (
    VOID* pv);


// A simple wrapper around malloc that returns E_OUTOFMEMORY if the
// allocation fails.  Avoids having to explicitly do this at each
// call site of malloc.
//
HRESULT
HrMalloc (
    size_t  cb,
    PVOID*  ppv);


// This CANNOT be an inline function.  If it is ever not inlined,
// the memory allocated will be destroyed.  (We're dealing with the stack
// here.)
//
#define PvAllocOnStack(_st)  _alloca(_st)


// Define a structure so that we can overload operator new with a
// signature specific to our purpose.
//
struct raiseexception_t {};
extern const raiseexception_t raiseexception;

VOID*
__cdecl
operator new (
    size_t cb,
    const raiseexception_t&
    );


// Define a structure so that we can overload operator new with a
// signature specific to our purpose.
//
struct extrabytes_t {};
extern const extrabytes_t extrabytes;

VOID*
__cdecl
operator new (
    size_t cb,
    const extrabytes_t&,
    size_t cbExtra);



#ifdef USE_HEAP_ALLOC

inline
void *  Nccalloc(size_t n, size_t s)
{
    return HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, (n * s));
}

inline
void Ncfree(void * p)
{
    HeapFree (GetProcessHeap(), 0, p);
}

inline
void * Ncmalloc(size_t n)
{
    return HeapAlloc (GetProcessHeap(), 0, n);
}

inline
void * Ncrealloc(void * p, size_t n)
{
    return (NULL == p)
        ? HeapAlloc (GetProcessHeap(), 0, n)
        : HeapReAlloc (GetProcessHeap(), 0, p, n);
}

#define calloc  Nccalloc
#define free    Ncfree
#define malloc  Ncmalloc
#define realloc Ncrealloc

#endif // USE_HEAP_ALLOC

#endif // _NCMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncerror.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C E R R O R . H
//
//  Contents:   NetCfg specific error codes.
//
//  Notes:
//
//  Author:     danielwe   25 Feb 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCERROR_H_
#define _NCERROR_H_

#include <winerror.h>

//
// Error codes are arbitrarily numbered starting at A000.
//

const HRESULT NETSETUP_E_ANS_FILE_ERROR         = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA002);
const HRESULT NETSETUP_E_NO_ANSWERFILE          = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA003);
const HRESULT NETSETUP_E_NO_EXACT_MATCH         = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA004);
const HRESULT NETSETUP_E_AMBIGUOUS_MATCH        = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA005);

//
// error codes (A020 - A040) reserved for netcfg.dll
//

const HRESULT NETCFG_E_PSNRET_INVALID       = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA041);
const HRESULT NETCFG_E_PSNRET_INVALID_NCPAGE= MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA042);

//
// Primarily join domain error codes but a few have crept into general use.
//
// Specifically: NETCFG_E_NAME_IN_USE and NETCFG_E_NOT_JOINED
//

const HRESULT NETCFG_E_ALREADY_JOINED       = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA050);
const HRESULT NETCFG_E_NAME_IN_USE          = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA051);
const HRESULT NETCFG_E_NOT_JOINED           = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA052);
const HRESULT NETCFG_E_MACHINE_IS_DC        = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA053);
const HRESULT NETCFG_E_NOT_A_SERVER         = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA054);
const HRESULT NETCFG_E_INVALID_ROLE         = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA055);
const HRESULT NETCFG_E_INVALID_DOMAIN       = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA056);

#endif // _NCERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncmsz.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C M S Z . H
//
//  Contents:   Common multi-sz routines.
//
//  Notes:      Split out from ncstring.h and included by ncstring.h
//
//  Author:     shaunco   7 Jun 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCMSZ_H_
#define _NCMSZ_H_

ULONG
CchOfMultiSzSafe (
    IN PCWSTR pmsz);

ULONG
CchOfMultiSzAndTermSafe (
    IN PCWSTR pmsz);

inline ULONG
CbOfMultiSzAndTermSafe (
    IN PCWSTR pmsz)
{
    return CchOfMultiSzAndTermSafe (pmsz) * sizeof(WCHAR);
}


BOOL
FGetSzPositionInMultiSzSafe (
    IN PCWSTR psz,
    IN PCWSTR pmsz,
    OUT DWORD* pdwIndex,
    OUT BOOL *pfDuplicatePresent,
    OUT DWORD* pcStrings);

BOOL
FIsSzInMultiSzSafe (
    IN PCWSTR psz,
    IN PCWSTR pmsz);

// flags for HrAddSzToMultiSz and RemoveSzFromMultiSz
const   DWORD   STRING_FLAG_ALLOW_DUPLICATES       =   0x00000001;
const   DWORD   STRING_FLAG_ENSURE_AT_FRONT        =   0x00000002;
const   DWORD   STRING_FLAG_ENSURE_AT_END          =   0x00000004;
const   DWORD   STRING_FLAG_ENSURE_AT_INDEX        =   0x00000008;
const   DWORD   STRING_FLAG_DONT_MODIFY_IF_PRESENT =   0x00000010;
const   DWORD   STRING_FLAG_REMOVE_SINGLE          =   0x00000020;
const   DWORD   STRING_FLAG_REMOVE_ALL             =   0x00000040;

HRESULT
HrAddSzToMultiSz (
    IN PCWSTR pszAddString,
    IN PCWSTR pmszIn,
    IN DWORD dwFlags,
    IN DWORD dwStringIndex,
    OUT PWSTR* ppmszOut,
    OUT BOOL* pfChanged);


HRESULT
HrCreateArrayOfStringPointersIntoMultiSz (
    IN PCWSTR     pmszSrc,
    OUT UINT*       pcStrings,
    OUT PCWSTR**   papsz);

VOID
RemoveSzFromMultiSz (
    IN PCWSTR psz,
    IN OUT PWSTR  pmsz,
    IN DWORD   dwFlags,
    OUT BOOL*   pfRemoved);

VOID
SzListToMultiSz (
    IN PCWSTR psz,
    OUT DWORD*  pcb,
    OUT PWSTR* ppszOut);


#endif // _NCMSZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncnbios.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       N C N B I O S . H
//
//  Contents:   NetBios Binding object definitions
//
//  Notes:
//
//  Author:     danielwe   14 Jul 1998
//
//----------------------------------------------------------------------------

#pragma once

//
// Structure of LANA MAP
//
// The Lana map is a simple structure that looks like this in memory:
//
//    Entry #0    Entry #1   .....   Entry #n
// |-----------|-----------| ..... |-----------|
// | 0x01 0x00 | 0x00 0x01 | ..... | 0x01 0x03 |
// |-----------|-----------| ..... |-----------|
//   EP0   LN0   EP1   LN1           EPn  LNn
//
// EP is "ExportPref" - means that when someone asks for the list of
// all Lana numbers, entries with a 0 here will not be returned.
//
// LN is the "Lana number" - see the IBM NetBIOS spec for details.
// Basically, this describes a single, unique network route which
// uses NetBIOS.
//
// Using the above example, Entry #0 has a lana number of 0 and WILL
// be returned during enumeration. Entry #1 has a lana number of 1
// and WILL NOT be returned.
//

struct LANA_ENTRY
{
    BYTE        bIsExported;
    BYTE        bLanaNum;
};

struct LANA_MAP
{
    DWORD           clmMap;         // number of entries in map
    LANA_ENTRY *    aleMap;         // array for each entry
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncmisc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C M I S C . H
//
//  Contents:   Miscellaneious common code.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   10 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCMISC_H_
#define _NCMISC_H_

#include "ncdebug.h"    // for AssertH
#include "ncdefine.h"   // for NOTHROW


const WORD wWinNT351BuildNumber = 1057;
const WORD wWinNT4BuildNumber   = 1381;

#define WM_SELECTED_ALL        WM_USER+200

//+---------------------------------------------------------------------------
// CExceptionSafeLock takes advantage of automatic constructor/destructor
// action guaranteed by the compiler (if stack unwinding is turned on)
// to always ensure that a critical section is left if it has ever been
// entered.  The constructor of this class enters the critical section
// and destructor leaves it.  The critical section must have been initialized
// before this class can be used.
//
class CExceptionSafeLock
{
public:
    CExceptionSafeLock (CRITICAL_SECTION* pCritSec)
    {
        AssertH (pCritSec);

        m_pCritSec = pCritSec;
        EnterCriticalSection (pCritSec);

        //TraceTag (ttidEsLock, "Entered critical section 0x%08x", pCritSec);
    }

    ~CExceptionSafeLock ()
    {
        AssertH (m_pCritSec);

        //TraceTag (ttidEsLock, "Leaving critical section 0x%08x", &m_pCritSec);

        LeaveCriticalSection (m_pCritSec);
    }

protected:
    CRITICAL_SECTION* m_pCritSec;
};


BOOL
FInSystemSetup ();

#if defined(REMOTE_BOOT)
HRESULT HrIsRemoteBootMachine();
#endif

enum PRODUCT_FLAVOR
{
    PF_WORKSTATION  = 1,
    PF_SERVER       = 2,
};

NOTHROW
VOID
GetProductFlavor (
    const VOID*     pvReserved,
    PRODUCT_FLAVOR* ppf);

HRESULT
HrIsNetworkingInstalled ();

enum REGISTER_FUNCTION
{
    RF_REGISTER,
    RF_UNREGISTER,
};
HRESULT
HrRegisterOrUnregisterComObject (
        PCWSTR              pszDllPath,
        REGISTER_FUNCTION   rf);

inline
HRESULT
HrRegisterComObject (
        PCWSTR     pszDllPath)
{
    HRESULT hr = HrRegisterOrUnregisterComObject (pszDllPath, RF_REGISTER);
    TraceError("HrRegisterComObject", hr);
    return hr;
}

inline
HRESULT
HrUnregisterComObject (
        PCWSTR     pszDllPath)
{
    HRESULT hr = HrRegisterOrUnregisterComObject (pszDllPath, RF_UNREGISTER);
    TraceError("HrUnregisterComObject", hr);
    return hr;
}

DWORD
ScStopNetbios();

HRESULT HrEnableAndStartSpooler();
HRESULT HrCreateDirectoryTree(PWSTR pszPath, LPSECURITY_ATTRIBUTES psa);
HRESULT HrDeleteFileSpecification(PCWSTR pszFileSpec,
                                  PCWSTR pszDirectoryPath);
HRESULT HrDeleteDirectory(IN PCWSTR pszDir,
                          IN BOOL fContinueOnError);

VOID LowerCaseComputerName(PWSTR szName);

#endif // _NCMISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncoc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C O C . H
//
//  Contents:   Optional component common library
//
//  Notes:
//
//  Author:     danielwe   18 Dec 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCOC_H
#define _NCOC_H

HRESULT HrProcessSNMPAddSection(HINF hinfFile, PCWSTR szSection);
HRESULT HrProcessSNMPRemoveSection(HINF hinfFile, PCWSTR szSection);
HRESULT HrProcessRegisterSection(HINF hinfFile, PCWSTR szSection);
HRESULT HrProcessUnregisterSection(HINF hinfFile, PCWSTR szSection);
HRESULT HrProcessAllINFExtensions(HINF hinfFile, PCWSTR szInstallSection);
HRESULT HrProcessAddShortcutSection(HINF hinfFile, PCWSTR szSection);
HRESULT HrProcessDelShortcutSection(HINF hinfFile, PCWSTR szSection);
HRESULT HrProcessPrintAddSection(HINF hinfFile, PCWSTR szSection);
HRESULT HrProcessPrintRemoveSection(HINF hinfFile, PCWSTR szSection);
HRESULT HrAddPrintMonitor(PCWSTR szPrintMonitorName,
                          PCWSTR szPrintMonitorDLL);
HRESULT HrRemovePrintMonitor(PCWSTR szPrintMonitorName);
HRESULT HrAddPrintProc(PCWSTR szDLLName, PCWSTR szProc);
HRESULT HrRemovePrintProc(PCWSTR szProc);

#endif //!_NCOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncnetcfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:
//
//  Contents:   Common routines for dealing with INetCfg interfaces.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCNETCFG_H_
#define _NCNETCFG_H_

#include "ncbase.h"
#include "nccom.h"
#include "ncstring.h"
#include "netcfgp.h"
#include "netcfgx.h"


BOOL
FClassGuidFromComponentId (
    PCWSTR          pszComponentId,
    const GUID**    ppguidClass);

BOOL
FInfFileFromComponentId (
    PCWSTR    pszComponentId,
    PWSTR     pszInfFile);

//+---------------------------------------------------------------------------
//
//  Function:   FEqualComponentId
//
//  Purpose:    Compares 2 components IDs to see if they are equal.
//
//  Arguments:
//      pszComp1 [in]    Name of first component ID.
//      pszComp2 [in]    Name of second compoennt ID.
//
//  Returns:    TRUE if component IDs are equal, FALSE if not.
//
//  Author:     danielwe   9 Apr 1997
//
//  Notes:      Current comparison is case-INSENSITIVE
//
inline
FEqualComponentId (
    PCWSTR pszComp1,
    PCWSTR pszComp2)
{
    return !lstrcmpiW(pszComp1, pszComp2);
}

BOOL
FGetInstanceGuidOfComponentFromAnswerFileMap (
    IN  PCWSTR  pszComponentId,
    OUT GUID*   pguid);

BOOL
FGetInstanceGuidOfComponentInAnswerFile (
    PCWSTR      pszComponentId,
    INetCfg*    pnc,
    LPGUID      pguid);

enum FIBN_FLAGS
{
    FIBN_NORMAL = 0x00000000,
    FIBN_PREFIX = 0x00000001
};
BOOL
FIsBindingName (
    PCWSTR                      pszName,
    DWORD                       dwFlags,
    INetCfgBindingInterface*    pncbi);


BOOL
FIsComponentId (
    PCWSTR              pszComponentId,
    INetCfgComponent*   pncc);


struct NETWORK_INSTALL_PARAMS
{
    DWORD   dwSetupFlags;
    DWORD   dwUpgradeFromBuildNo;
    PCWSTR  pszAnswerFile;
    PCWSTR  pszAnswerSection;
};


struct FILTER_INSTALL_PARAMS
{
    void *      pnccAdapter;
    void *      pnccFilter;
    tstring *   pstrInterface;
};

enum ARA_FLAGS
{
    ARA_ADD             = 0x01,
    ARA_REMOVE          = 0x02,
};
HRESULT
HrAddOrRemoveAdapter (
    INetCfg*            pnc,
    PCWSTR              pszComponentId,
    DWORD               dwFlags,
    OBO_TOKEN*          pOboToken,
    UINT                cInstances,
    INetCfgComponent**  ppncc);


HRESULT
HrCreateAndInitializeINetCfg (
    BOOL*       pfInitCom,
    INetCfg**   ppnc,
    BOOL        fGetWriteLock,
    DWORD       cmsTimeout,
    PCWSTR     pszwClientDesc,
    PWSTR*     ppszwClientDesc);

HRESULT
HrFindAndRemoveAllInstancesOfAdapter (
    INetCfg*    pnc,
    PCWSTR     pszwComponentId);

HRESULT
HrFindAndRemoveAllInstancesOfAdapters (
    INetCfg*        pnc,
    ULONG           cComponents,
    const PCWSTR*  apszwComponentId);

HRESULT
HrFindAndRemoveComponent (
    INetCfg*    pnc,
    const GUID* pguidClass,
    PCWSTR     pszwComponentId,
    OBO_TOKEN*  pOboToken);

HRESULT
HrFindAndRemoveComponents (
    INetCfg*        pnc,
    ULONG           cComponents,
    const GUID**    apguidClass,
    const PCWSTR*  apszwComponentId,
    OBO_TOKEN*      pOboToken);

HRESULT
HrFindAndRemoveComponentsOboComponent (
    INetCfg*            pnc,
    ULONG               cComponents,
    const GUID**        apguidClass,
    const PCWSTR*      apszwComponentId,
    INetCfgComponent*   pnccObo);

HRESULT
HrFindAndRemoveComponentsOboUser (
    INetCfg*            pnc,
    ULONG               cComponents,
    const GUID**        apguidClass,
    const PCWSTR*      apszwComponentId);


HRESULT
HrFindComponents (
    INetCfg*            pnc,
    ULONG               cComponents,
    const GUID**        apguidClass,
    const PCWSTR*      apszwComponentId,
    INetCfgComponent**  apncc);


HRESULT
HrGetBindingInterfaceComponents (
    INetCfgBindingInterface*    pncbi,
    INetCfgComponent**          ppnccUpper,
    INetCfgComponent**          ppnccLower);


HRESULT
HrGetLastComponentAndInterface (
    INetCfgBindingPath* pncbp,
    INetCfgComponent**  ppncc,
    PWSTR*             ppszwInterfaceName);


HRESULT
HrInstallComponent (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    const GUID*                     pguidClass,
    PCWSTR                         pszwComponentId,
    OBO_TOKEN*                      pOboToken,
    INetCfgComponent**              ppncc);

HRESULT
HrInstallComponents (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    ULONG                           cComponents,
    const GUID**                    apguidClass,
    const PCWSTR*                  apszwComponentId,
    OBO_TOKEN*                      pOboToken);

HRESULT
HrInstallComponentsOboComponent (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    ULONG                           cComponents,
    const GUID**                    apguidClass,
    const PCWSTR*                  apszwComponentId,
    INetCfgComponent*               pnccObo);

HRESULT
HrInstallComponentsOboUser (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    ULONG                           cComponents,
    const GUID**                    apguidClass,
    const PCWSTR*                  apszwComponentId);

HRESULT
HrInstallComponentOboComponent (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    const GUID&                     rguidClass,
    PCWSTR                         pszwComponentId,
    INetCfgComponent*               pnccObo,
    INetCfgComponent**              ppncc);

HRESULT
HrInstallComponentOboSoftware(
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    const GUID&                     rguidClass,
    PCWSTR                         pszwComponentId,
    PCWSTR                         pszwManufacturer,
    PCWSTR                         pszwProduct,
    PCWSTR                         pszwDisplayName,
    INetCfgComponent**              ppncc);

HRESULT
HrInstallComponentOboUser (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    const GUID&                     rguidClass,
    PCWSTR                         pszwComponentId,
    INetCfgComponent**              ppncc);


HRESULT
HrInstallRasIfNeeded (
    INetCfg*    pnc);


HRESULT
HrIsLanCapableAdapter (
    INetCfgComponent*   pncc);

HRESULT
HrIsLanCapableProtocol (
    INetCfgComponent*   pncc);

HRESULT
HrQueryNotifyObject (
    INetCfgComponent*   pncc,
    REFIID              riid,
    VOID**              ppvObject);

HRESULT
HrRemoveComponent (
    INetCfg*            pnc,
    INetCfgComponent*   pnccToRemove,
    OBO_TOKEN*          pOboToken,
    PWSTR *            pmszwRefs);

HRESULT
HrRemoveComponentOboComponent (
    INetCfg*            pnc,
    const GUID&         rguidClass,
    PCWSTR             pszwComponentId,
    INetCfgComponent*   pnccObo);

HRESULT
HrRemoveComponentOboSoftware (
    INetCfg*    pnc,
    const GUID& rguidClass,
    PCWSTR     pszwComponentId,
    PCWSTR     pszwManufacturer,
    PCWSTR     pszwProduct,
    PCWSTR     pszwDisplayName);

HRESULT
HrRemoveComponentOboUser (
    INetCfg*    pnc,
    const GUID& rguidClass,
    PCWSTR     pszwComponentId);


HRESULT
HrUninitializeAndReleaseINetCfg (
    BOOL        fUninitCom,
    INetCfg*    pnc,
    BOOL        fHasLock = FALSE);

HRESULT
HrUninitializeAndUnlockINetCfg (
    INetCfg*    pnc);

HRESULT
HrRunWinsock2Migration();

HRESULT
HrNcRemoveComponent(INetCfg* pinc, const GUID& guidClass,
                    PCWSTR pszInstanceGuid);

EXTERN_C
HRESULT
WINAPI
HrDiAddComponentToINetCfg(
    IN INetCfg* pINetCfg,
    IN INetCfgInternalSetup* pInternalSetup,
    IN const NIQ_INFO* pInfo);

EXTERN_C
VOID
WINAPI
UpdateLanaConfigUsingAnswerfile (
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszSection);


HRESULT
HrNcRegCreateComponentNetworkKeyForDevice(const GUID& guidClass, HKEY* phkey,
                                          PCWSTR pszInstanceGuid,
                                          PCWSTR pszPnpId);
HRESULT
HrNcRegCreateComponentNetworkKey(const GUID& guidClass, PHKEY phkeyComponent,
                                 PCWSTR pszInstanceGuid);

HRESULT
HrNcNotifyINetCfgAndConnectionWizardOfInstallation(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN PCWSTR pszPnpId,
    IN const GUID& InstanceGuid,
    IN NC_INSTALL_TYPE eType);

HRESULT
HrNcNotifyINetCfgAndConnectionWizardOfInstallation(HDEVINFO hdi,
        PSP_DEVINFO_DATA pdeid, PCWSTR pszwPnpId, PCWSTR pszInstanceGuid,
        NC_INSTALL_TYPE eType);

HRESULT
HrNcNotifyINetCfgOfRemoval(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                           PCWSTR pszwInstanceGuid);


struct COMPONENT_INFO
{
    PCWSTR         pszComponentId;
    const GUID *   pguidClass;
    PCWSTR         pszInfFile;
};

extern const COMPONENT_INFO*
PComponentInfoFromComponentId (
    PCWSTR pszComponentId);


//------------------------------------------------------------------------
// CIterNetCfgBindingPath - iterator for IEnumNetCfgBindingPath
//
//  This class is is a simple wrapper around CIEnumIter with a call
//  to INetCfgComponent::EnumBindingPaths to get the enumerator.
//
class CIterNetCfgBindingPath : public CIEnumIter<IEnumNetCfgBindingPath, INetCfgBindingPath*>
{
public:
    NOTHROW CIterNetCfgBindingPath (INetCfgComponent* pncc);
    NOTHROW ~CIterNetCfgBindingPath ()  { ReleaseObj(m_pebp); }

protected:
    IEnumNetCfgBindingPath* m_pebp;
};

//------------------------------------------------------------------------
// CIterNetCfgUpperBindingPath - iterator for IEnumNetCfgBindingPath
//
//  This class is is a simple wrapper around CIEnumIter with a call
//  to INetCfgComponent::EnumUpperBindingPaths to get the enumerator.
//
class CIterNetCfgUpperBindingPath : public CIEnumIter<IEnumNetCfgBindingPath, INetCfgBindingPath*>
{
public:
    NOTHROW CIterNetCfgUpperBindingPath (INetCfgComponent* pncc);
    NOTHROW ~CIterNetCfgUpperBindingPath () { ReleaseObj(m_pebp); }

protected:
    IEnumNetCfgBindingPath* m_pebp;
};


//------------------------------------------------------------------------
// CIterNetCfgBindingInterface - iterator for IEnumNetCfgBindingInterface
//
//  This class is is a simple wrapper around CIEnumIter with a call
//  to INetCfgBindingPath::EnumBindingInterfaces to get the enumerator.
//
class CIterNetCfgBindingInterface : public CIEnumIter<IEnumNetCfgBindingInterface, INetCfgBindingInterface*>
{
public:
    NOTHROW CIterNetCfgBindingInterface (INetCfgBindingPath* pncbp);
    NOTHROW ~CIterNetCfgBindingInterface () { ReleaseObj(m_pebi); }

protected:
    IEnumNetCfgBindingInterface* m_pebi;
};


//------------------------------------------------------------------------
// CIterNetCfgComponent - iterator for IEnumNetCfgComponent
//
//  This class is is a simple wrapper around CIEnumIter with a call
//  to INetCfgClass::EnumComponents to get the enumerator.
//
class CIterNetCfgComponent : public CIEnumIter<IEnumNetCfgComponent, INetCfgComponent*>
{
public:
    NOTHROW CIterNetCfgComponent (INetCfg* pnc, const GUID* pguid);
    NOTHROW CIterNetCfgComponent (INetCfgClass* pncclass);
    NOTHROW ~CIterNetCfgComponent () { ReleaseObj(m_pec); }

protected:
    IEnumNetCfgComponent* m_pec;
};

inline NOTHROW CIterNetCfgBindingPath::CIterNetCfgBindingPath(INetCfgComponent* pncc)
    : CIEnumIter<IEnumNetCfgBindingPath, INetCfgBindingPath*> (NULL)
{
    AssertH(pncc);
    INetCfgComponentBindings* pnccb;

    // If EnumBindingPaths() fails, make sure ReleaseObj() won't die.
    m_pebp = NULL;

    m_hrLast = pncc->QueryInterface( IID_INetCfgComponentBindings, reinterpret_cast<LPVOID *>(&pnccb) );
    if (SUCCEEDED(m_hrLast))
    {
        // Get the enumerator and set it for the base class.
        // Important to set m_hrLast so that if this fails, we'll also
        // fail any subsequent calls to HrNext.
        m_hrLast = pnccb->EnumBindingPaths(EBP_BELOW, &m_pebp);
        if (SUCCEEDED(m_hrLast))
        {
            SetEnumerator(m_pebp);
        }
        ReleaseObj( pnccb );
    }

    TraceHr (ttidError, FAL, m_hrLast, FALSE,
        "CIterNetCfgBindingPath::CIterNetCfgBindingPath");
}

inline NOTHROW CIterNetCfgUpperBindingPath::CIterNetCfgUpperBindingPath(INetCfgComponent* pncc)
    : CIEnumIter<IEnumNetCfgBindingPath, INetCfgBindingPath*> (NULL)
{
    AssertH(pncc);
    INetCfgComponentBindings* pnccb;

    // If EnumBindingPaths() fails, make sure ReleaseObj() won't die.
    m_pebp = NULL;

    m_hrLast = pncc->QueryInterface( IID_INetCfgComponentBindings, reinterpret_cast<LPVOID *>(&pnccb) );
    if (SUCCEEDED(m_hrLast))
    {
        // Get the enumerator and set it for the base class.
        // Important to set m_hrLast so that if this fails, we'll also
        // fail any subsequent calls to HrNext.
        m_hrLast = pnccb->EnumBindingPaths(EBP_ABOVE, &m_pebp);
        if (SUCCEEDED(m_hrLast))
        {
            SetEnumerator(m_pebp);
        }
        ReleaseObj( pnccb );
    }

    TraceHr (ttidError, FAL, m_hrLast, FALSE,
        "CIterNetCfgUpperBindingPath::CIterNetCfgUpperBindingPath");
}

inline NOTHROW CIterNetCfgBindingInterface::CIterNetCfgBindingInterface(INetCfgBindingPath* pncbp)
    : CIEnumIter<IEnumNetCfgBindingInterface, INetCfgBindingInterface*> (NULL)
{
    AssertH(pncbp);

    // If EnumBindingInterfaces() fails, make sure ReleaseObj() won't die.
    m_pebi = NULL;

    // Get the enumerator and set it for the base class.
    // Important to set m_hrLast so that if this fails, we'll also
    // fail any subsequent calls to HrNext.
    m_hrLast = pncbp->EnumBindingInterfaces(&m_pebi);
    if (SUCCEEDED(m_hrLast))
    {
        SetEnumerator(m_pebi);
    }

    TraceHr (ttidError, FAL, m_hrLast, FALSE,
        "CIterNetCfgBindingInterface::CIterNetCfgBindingInterface");
}

inline NOTHROW CIterNetCfgComponent::CIterNetCfgComponent(INetCfg* pnc, const GUID* pguid)
    : CIEnumIter<IEnumNetCfgComponent, INetCfgComponent*> (NULL)
{
    AssertH(pnc);

    // If EnumComponents() fails, make sure ReleaseObj() won't die.
    m_pec = NULL;

    INetCfgClass* pncclass;
    m_hrLast = pnc->QueryNetCfgClass(pguid, IID_INetCfgClass,
                reinterpret_cast<void**>(&pncclass));
    if (SUCCEEDED(m_hrLast))
    {
        // Get the enumerator and set it for the base class.
        // Important to set m_hrLast so that if this fails, we'll also
        // fail any subsequent calls to HrNext.
        m_hrLast = pncclass->EnumComponents(&m_pec);
        if (SUCCEEDED(m_hrLast))
        {
            SetEnumerator(m_pec);
        }

        ReleaseObj(pncclass);
    }

    TraceHr (ttidError, FAL, m_hrLast, FALSE,
        "CIterNetCfgComponent::CIterNetCfgComponent");
}

inline NOTHROW CIterNetCfgComponent::CIterNetCfgComponent(INetCfgClass* pncclass)
    : CIEnumIter<IEnumNetCfgComponent, INetCfgComponent*> (NULL)
{
    AssertH(pncclass);

    // If EnumComponents() fails, make sure ReleaseObj() won't die.
    m_pec = NULL;

    // Get the enumerator and set it for the base class.
    // Important to set m_hrLast so that if this fails, we'll also
    // fail any subsequent calls to HrNext.
    m_hrLast = pncclass->EnumComponents(&m_pec);
    if (SUCCEEDED(m_hrLast))
    {
        SetEnumerator(m_pec);
    }

    TraceHr (ttidError, FAL, m_hrLast, FALSE,
        "CIterNetCfgComponent::CIterNetCfgComponent");
}

#endif // _NCNETCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncnetcon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C N E T C O N . H
//
//  Contents:   Common routines for dealing with the connections interfaces.
//
//  Notes:
//
//  Author:     shaunco   25 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCNETCON_H_
#define _NCNETCON_H_

#include "nccom.h"
#include "netconp.h"
#include "oleauto.h"

typedef enum tagNETCONPROPS_EX_FIELDS
{
    NCP_DWSIZE = 0,
    NCP_GUIDID,
    NCP_BSTRNAME,
    NCP_BSTRDEVICENAME,
    NCP_NCSTATUS,
    NCP_MEDIATYPE,
    NCP_SUBMEDIATYPE,
    NCP_DWCHARACTER,
    NCP_CLSIDTHISOBJECT,
    NCP_CLSIDUIOBJECT,
    NCP_BSTRPHONEORHOSTADDRESS,
    NCP_BSTRPERSISTDATA,
    NCP_MAX = NCP_BSTRPERSISTDATA,
    NCP_ELEMENTS = NCP_MAX + 1
} NETCONPROPS_EX_FIELDS;

BOOL
FAnyReasonToEnumerateConnectionsForShowIconInfo (
    VOID);

BOOL
FIsValidConnectionName(
    IN PCWSTR pszName);

VOID
FreeNetconProperties (
    IN NETCON_PROPERTIES* pProps);

HRESULT
HrGetConnectionPersistData (
    IN INetConnection* pConn,
    OUT BYTE** ppbData,
    OUT ULONG* pulSize,
    OUT CLSID* pclsid OPTIONAL);

HRESULT
HrGetConnectionFromPersistData (
    IN const CLSID& clsid,
    IN const BYTE* pbData,
    IN ULONG cbData,
    IN REFIID riid,
    OUT VOID** ppv);

//------------------------------------------------------------------------
// CIterNetCon - iterator for IEnumNetConnection
//
//  This class is is a simple wrapper around CIEnumIter with a call
//  to INetConnectionManager::EnumConnections to get the enumerator.
//
class CIterNetCon : public CIEnumIter<IEnumNetConnection, INetConnection*>
{
public:
    NOTHROW CIterNetCon (
        INetConnectionManager* pConMan,
        NETCONMGR_ENUM_FLAGS   Flags);

    NOTHROW ~CIterNetCon () { ReleaseObj (m_pEnum); }

    // Specialization to set the proxy blanket before returning
    NOTHROW HRESULT HrNext(INetConnection ** ppConnection);

protected:
    IEnumNetConnection* m_pEnum;
};

inline NOTHROW CIterNetCon::CIterNetCon (
    INetConnectionManager*  pConMan,
    NETCONMGR_ENUM_FLAGS    Flags
    )
    : CIEnumIter<IEnumNetConnection, INetConnection*> (NULL)
{
    AssertH (pConMan);

    // If EnumConnections() fails, make sure ReleaseObj() won't die.
    m_pEnum = NULL;

    // Get the enumerator and set it for the base class.
    // Important to set m_hrLast so that if this fails, we'll also
    // fail any subsequent calls to HrNext.
    //
    m_hrLast = pConMan->EnumConnections (Flags, &m_pEnum);

    TraceHr (ttidError, FAL, m_hrLast, FALSE,
        "INetConnectionManager->EnumConnections");

    if (SUCCEEDED(m_hrLast))
    {
        NcSetProxyBlanket (m_pEnum);

        SetEnumerator (m_pEnum);
    }
    TraceHr (ttidError, FAL, m_hrLast, FALSE, "CIterNetCon::CIterNetCon");
}

// Specialization to set the proxy blanket before returning
inline NOTHROW HRESULT CIterNetCon::HrNext(INetConnection ** ppConnection)
{
    HRESULT hr = CIEnumIter<IEnumNetConnection, INetConnection*>::HrNext(ppConnection);
    if(SUCCEEDED(hr) && *ppConnection) 
    {
        NcSetProxyBlanket(*ppConnection);
    }
    return hr;
}


VOID
SetOrQueryAtLeastOneLanWithShowIcon (
    IN BOOL fSet,
    IN BOOL fSetValue,
    OUT BOOL* pfQueriedValue);

HRESULT
HrSafeArrayFromNetConPropertiesEx (
   IN      NETCON_PROPERTIES_EX* pPropsEx,
   OUT     SAFEARRAY** ppsaProperties);

HRESULT HrNetConPropertiesExFromSafeArray(
    IN      SAFEARRAY* psaProperties,
    OUT     NETCON_PROPERTIES_EX** pPropsEx);

HRESULT HrFreeNetConProperties2(
    NETCON_PROPERTIES_EX* pPropsEx);

#endif // _NCNETCON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncpnp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C P N P . H
//
//  Contents:   Common code for PnP.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   10 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCPNP_H_
#define _NCPNP_H_

#include "ndispnp.h"

HRESULT
HrSendServicePnpEvent (
        PCWSTR      pszService,
        DWORD       dwControl);

HRESULT
HrSendNdisPnpReconfig (
        UINT        uiLayer,
        PCWSTR      pszUpper,
        PCWSTR      pszLower    = NULL,
        PVOID       pvData      = NULL,
        DWORD       dwSizeData  = 0);

#endif // _NCPNP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncras.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R A S . H
//
//  Contents:   Common code for RAS connections.
//
//  Notes:
//
//  Author:     shaunco   20 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "netconp.h"
#include <ras.h>
#include <rasuip.h>
#include <rasapip.h>
#include <rasuip.h>

VOID
RciFree (
    RASCON_INFO* pRasConInfo);

BOOL
FExistActiveRasConnections ();

HRESULT
HrRciGetRasConnectionInfo (
    IN INetConnection* pCon,
    OUT RASCON_INFO* pRasConInfo);

HRESULT
HrRasEnumAllActiveConnections (
    OUT RASCONN** ppRasConn,
    OUT DWORD* pcRasConn);

HRESULT
HrRasEnumAllActiveServerConnections (
    OUT RASSRVCONN** paRasSrvConn,
    OUT DWORD* pcRasSrvConn);

HRESULT
HrRasEnumAllEntriesWithDetails (
    IN PCWSTR pszPhonebook,
    OUT RASENUMENTRYDETAILS** paRasEntryDetails,
    OUT DWORD* pcRasEntryDetails);

HRESULT
HrFindRasConnFromGuidId (
    IN const GUID* pguid,
    OUT HRASCONN* phRasConn,
    OUT RASCONN* pRasConn OPTIONAL);

HRESULT
HrRasGetEntryProperties (
    IN PCWSTR pszPhonebook,
    IN PCWSTR pszEntry,
    OUT RASENTRY** ppRasEntry,
    OUT DWORD* pcbRasEntry);

HRESULT
HrRasGetSubEntryProperties (
    IN PCWSTR pszPhonebook,
    IN PCWSTR pszEntry,
    IN DWORD dwSubEntry,
    OUT RASSUBENTRY** ppRasSubEntry);

HRESULT
HrRasGetNetconStatusFromRasConnectStatus (
    IN HRASCONN hRasConn,
    OUT NETCON_STATUS* pStatus);

HRESULT
HrRasHangupUntilDisconnected (
    IN HRASCONN hRasConn);

HRESULT
HrNetConToSharedConnection (
    IN INetConnection* pCon,
    OUT LPRASSHARECONN prsc);

HRESULT
HrRasIsSharedConnection (
    IN LPRASSHARECONN prsc,
    OUT PBOOL pfShared);

#if 0

HRESULT
HrRasQueryLanConnTable (
    IN LPRASSHARECONN prsc,
    OUT NETCON_PROPERTIES** ppLanTable,
    OUT LPDWORD pdwLanCount);

HRESULT
HrRasShareConnection (
    IN LPRASSHARECONN prsc,
    IN GUID* pPrivateLanGuid OPTIONAL);

HRESULT
HrRasUnshareConnection (
    OUT PBOOL pfWasShared);

#endif

NOTHROW
int
WINAPIV
NcRasMsgBoxWithErrorText (
    IN DWORD dwError,
    IN HINSTANCE hinst,
    IN HWND hwnd,
    IN UINT unIdCaption,
    IN UINT unIdCombineFormat,
    IN UINT unIdFormat,
    IN UINT unStyle,
    ...);

DWORD 
RasSrvTypeFromRasDeviceType(
    RASDEVICETYPE rdt
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncperms.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C P E R M S . H
//
//  Contents:   Common routines for dealing with permissions.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   10 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCPERMS_H_
#define _NCPERMS_H_

#include "ncdefine.h"   // for NOTHROW
#include "gpbase.h"

#ifdef DBG
extern DWORD g_dwDbgPermissionsFail; // Debug flag to force permissions to fail
#endif

// Apply Masks
typedef enum tagNCPERM_APPLY_TO
{
    APPLY_TO_ADMIN          = 0x00000001,
    APPLY_TO_NETCONFIGOPS   = 0x00000002,
    APPLY_TO_POWERUSERS     = 0x00000004,
    APPLY_TO_USER           = 0x00000008,
    APPLY_TO_GUEST          = 0x00000010,
    APPLY_TO_LOCATION       = 0x00010000,
    APPLY_TO_ALL_USERS      = APPLY_TO_ADMIN | APPLY_TO_NETCONFIGOPS | APPLY_TO_POWERUSERS | APPLY_TO_USER,
    APPLY_TO_OPS_OR_ADMIN   = APPLY_TO_ADMIN | APPLY_TO_NETCONFIGOPS,
    APPLY_TO_NON_ADMINS     = APPLY_TO_NETCONFIGOPS | APPLY_TO_USER | APPLY_TO_POWERUSERS,
    APPLY_TO_POWERUSERSPLUS = APPLY_TO_POWERUSERS | APPLY_TO_NETCONFIGOPS | APPLY_TO_ADMIN,
    APPLY_TO_EVERYBODY      = APPLY_TO_ALL_USERS | APPLY_TO_GUEST,
    APPLY_TO_ALL            = APPLY_TO_ADMIN | APPLY_TO_NETCONFIGOPS | APPLY_TO_POWERUSERS | APPLY_TO_USER | APPLY_TO_LOCATION
} NCPERM_APPLY_TO;

BOOL
FIsUserAdmin ();

BOOL 
FIsUserNetworkConfigOps ();

BOOL 
FIsUserPowerUser();

BOOL 
FIsUserGuest();

HRESULT
HrSetPermissionsOnTcpIpRegKeys (BOOL bAllowPermission);

HRESULT
HrAllocateSecurityDescriptorAllowAccessToWorld (
    PSECURITY_DESCRIPTOR*   ppSd);

HRESULT
HrEnablePrivilege (
    PCWSTR pszPrivilegeName);

HRESULT
HrEnableAllPrivileges (
    TOKEN_PRIVILEGES**  pptpOld);

HRESULT
HrRestorePrivileges (
    TOKEN_PRIVILEGES*   ptpRestore);

// FHasPermission flags are defined in netconp.idl/.h
//
BOOL
FHasPermission(
    ULONG   ulPermMask,
    CGroupPolicyBase* pGPBase = NULL);

BOOL
FHasPermissionFromCache(
    ULONG   ulPermMask);

VOID
RefreshAllPermission();

BOOL 
FProhibitFromAdmins();

BOOL
IsHNetAllowed(
    DWORD dwPerm
    );

BOOL 
FIsPolicyConfigured(
    DWORD ulPerm);

BOOL
IsSameNetworkAsGroupPolicies();

#endif // _NCPERMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncreg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R E G . H
//
//  Contents:   Common routines for dealing with the registry.
//
//  Notes:
//
//  Author:     danielwe   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCREG_H_
#define _NCREG_H_

#include "ncstring.h"

// constants for HrRegQueryStringAsUlong
const int c_nBase10 = 10;
const int c_nBase16 = 16;
const int c_cchMaxRegKeyLengthWithNull = 257;

const DWORD KEY_READ_WRITE_DELETE = KEY_READ | KEY_WRITE | DELETE;
const DWORD KEY_READ_WRITE = KEY_READ | KEY_WRITE;

HRESULT
HrRegAddStringToMultiSz (
    IN PCWSTR  pszAddString,
    IN HKEY    hkeyRoot,
    IN PCWSTR  pszKeySubPath,
    IN PCWSTR  pszValueName,
    IN DWORD   dwFlags,
    IN DWORD   dwIndex);

HRESULT
HrRegAddStringToSz (
    IN PCWSTR  pszAddString,
    IN HKEY    hkeyRoot,
    IN PCWSTR  pszKeySubPath,
    IN PCWSTR  pszValueName,
    IN WCHAR   chDelimiter,
    IN DWORD   dwFlags,
    IN DWORD   dwStringIndex);

HRESULT
HrRegCopyHive (
    IN HKEY    hkeySrc,
    IN HKEY    hkeyDst);

HRESULT
HrRegCreateKeyEx (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD pdwDisposition);

HRESULT
HrRegDeleteKey (
    IN HKEY hkey,
    IN PCWSTR pszSubkey);

HRESULT
HrRegDeleteKeyTree (
    IN HKEY hkeyParent,
    IN PCWSTR pszRemoveKey);

HRESULT
HrRegDeleteValue (
    IN HKEY hkey,
    IN PCWSTR pszValueName);

HRESULT
HrRegEnumKey (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PWSTR  pszSubkeyName,
    IN DWORD cchSubkeyName);

HRESULT
HrRegEnumKeyEx (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PWSTR  pszSubkeyName,
    OUT LPDWORD pcchSubkeyName,
    OUT PWSTR  pszClass,
    OUT LPDWORD pcchClass,
    OUT FILETIME* pftLastWriteTime);

HRESULT
HrRegEnumValue (
    HKEY hkey,
    DWORD dwIndex,
    PWSTR  pszValueName,
    LPDWORD pcbValueName,
    LPDWORD pdwType,
    LPBYTE  pbData,
    LPDWORD pcbData);

HRESULT
HrRegOpenKeyEx (
    HKEY hkey,
    PCWSTR pszSubkey,
    REGSAM samDesired,
    PHKEY phkResult);

HRESULT
HrRegOpenKeyBestAccess (
    HKEY hkey,
    PCWSTR pszSubkey,
    PHKEY phkResult);

HRESULT
HrRegDuplicateKeyEx (
    HKEY hkey,
    REGSAM samDesired,
    PHKEY phkResult);



HRESULT
HrRegQueryBinaryWithAlloc (
    HKEY    hkey,
    PCWSTR  pszValueName,
    LPBYTE* ppbValue,
    DWORD*  pcbValue);

HRESULT
HrRegQueryDword (
    HKEY    hkey,
    PCWSTR  pszValueName,
    LPDWORD pdwValue);

HRESULT
HrRegQueryExpandString (
    HKEY        hkey,
    PCWSTR      pszValueName,
    tstring*    pstrValue);

HRESULT
HrRegQueryInfoKey (
    HKEY        hkey,
    PWSTR       pszClass,
    LPDWORD     pcbClass,
    LPDWORD     pcSubKeys,
    LPDWORD     pcbMaxSubKeyLen,
    LPDWORD     pcbMaxClassLen,
    LPDWORD     pcValues,
    LPDWORD     pcbMaxValueNameLen,
    LPDWORD     pcbMaxValueLen,
    LPDWORD     pcbSecurityDescriptor,
    PFILETIME   pftLastWriteTime);

HRESULT
HrRegQueryStringAsUlong (
    HKEY        hkey,
    PCWSTR      pszValueName,
    int         nBase,
    ULONG*      pulValue);

HRESULT
HrRegQueryTypeString (
    HKEY        hkey,
    PCWSTR      pszValueName,
    DWORD       dwType,
    tstring*    pstr);

HRESULT
HrRegQueryTypeSzBuffer (
    HKEY    hkey,
    PCWSTR  pszValueName,
    DWORD   dwType,
    PWSTR   pszData,
    DWORD*  pcbData);

HRESULT
HrRegQueryValueEx (
    HKEY        hkey,
    PCWSTR      pszValueName,
    LPDWORD     pdwType,
    LPBYTE      pbData,
    LPDWORD     pcbData);

HRESULT
HrRegQueryValueWithAlloc (
    HKEY        hkey,
    PCWSTR      pszValueName,
    LPDWORD     pdwType,
    LPBYTE*     ppbBuffer,
    LPDWORD     pdwSize);


HRESULT HrRegGetKeySecurity (
    HKEY                    hKey,
    SECURITY_INFORMATION    SecurityInformation,
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    LPDWORD                 lpcbSecurityDescriptor
    );

HRESULT HrRegSetKeySecurity (
    HKEY                    hKey,
    SECURITY_INFORMATION    SecurityInformation,
    PSECURITY_DESCRIPTOR    pSecurityDescriptor
    );

template<class T>
HRESULT HrRegQueryColString( HKEY hkey, PCWSTR pszValueName, T* pcolstr );


inline
HRESULT
HrRegQueryString (
    HKEY        hkey,
    PCWSTR      pszValueName,
    tstring*    pstr)
{
    return HrRegQueryTypeString (hkey, pszValueName, REG_SZ, pstr);
}


HRESULT
HrRegQueryTypeWithAlloc (
    HKEY        hkey,
    PCWSTR      pszValueName,
    DWORD       dwType,
    LPBYTE*     ppbValue,
    DWORD*      pcbValue);

inline
HRESULT
HrRegQueryBinaryWithAlloc (
    HKEY    hkey,
    PCWSTR  pszValueName,
    LPBYTE* ppbValue,
    DWORD*  pcbValue)
{
    return HrRegQueryTypeWithAlloc (hkey, pszValueName, REG_BINARY,
                ppbValue, pcbValue);
}


inline
HRESULT
HrRegQueryMultiSzWithAlloc (
    HKEY        hkey,
    PCWSTR      pszValueName,
    PWSTR*      pszValue)
{
    return HrRegQueryTypeWithAlloc (hkey, pszValueName, REG_MULTI_SZ,
                (LPBYTE*)pszValue, NULL);
}

inline
HRESULT
HrRegQuerySzWithAlloc (
    HKEY        hkey,
    PCWSTR      pszValueName,
    PWSTR*      pszValue)
{
    return HrRegQueryTypeWithAlloc (hkey, pszValueName, REG_SZ,
                (LPBYTE*)pszValue, NULL);
}

inline
HRESULT
HrRegQueryExpandSzBuffer (
    HKEY        hkey,
    PCWSTR      pszValueName,
    PWSTR       pszData,
    DWORD*      pcbData)
{
    return HrRegQueryTypeSzBuffer (hkey, pszValueName, REG_EXPAND_SZ,
                pszData, pcbData);
}

inline
HRESULT
HrRegQuerySzBuffer (
    HKEY        hkey,
    PCWSTR      pszValueName,
    PWSTR       pszData,
    DWORD*      pcbData)
{
    return HrRegQueryTypeSzBuffer (hkey, pszValueName, REG_SZ,
                pszData, pcbData);
}

HRESULT HrRegSaveKey(HKEY hkey, PCWSTR szFileName,
                     LPSECURITY_ATTRIBUTES psa);

HRESULT HrRegSetValueEx (HKEY hkey,
                         PCWSTR szValueName,
                         DWORD dwType,
                         const BYTE *pbData,
                         DWORD cbData);

HRESULT HrRegRemoveStringFromSz(    PCWSTR      pszRemoveString,
                                    HKEY        hkeyRoot,
                                    PCWSTR      pszKeySubPath,
                                    PCWSTR      pszValueName,
                                    WCHAR       chDelimiter,
                                    DWORD       dwFlags );

HRESULT HrRegRemoveStringFromMultiSz (PCWSTR pszRemoveString,
                                      HKEY   hkeyRoot,
                                      PCWSTR pszKeySubPath,
                                      PCWSTR pszValueName,
                                      DWORD  dwFlags);

HRESULT HrRegRestoreKey(HKEY hkey, PCWSTR pszFileName, DWORD dwFlags);


HRESULT HrRegOpenAdapterKey(
        PCWSTR pszComponentName,
        BOOL fCreate,
        HKEY* phkey);

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetColString
//
//  Purpose:    Sets a multi-sz in the registry using the collection of strings
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to set.
//      colstr       [in]    The collection of tstrings to set.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     mikemi   30 Apr 1997
//
//  Notes:
//
//---------------------------------------------------------------------------
template<class T>
HRESULT HrRegSetColString(HKEY hkey, PCWSTR pszValueName, const T& colstr);

HRESULT
HrRegSetBool (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN BOOL fValue);

HRESULT
HrRegSetDword (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN DWORD dwValue);

HRESULT
HrRegSetGuidAsSz (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN const GUID& guid);

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetMultiSz
//
//  Purpose:    Sets a multi-sz in the registry.  Assures that its type and
//              size are correct.  Easier to read than HrRegSetValueEx
//              with 5 parameters.  Type safe (no LPBYTE stuff).
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to set.
//      pszValue     [in]    The multi-sz to set.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   1 Apr 1997
//
//  Notes:
//
inline HRESULT HrRegSetMultiSz (HKEY hkey, PCWSTR pszValueName, PCWSTR pszValue)
{
    return HrRegSetValueEx (
                hkey,
                pszValueName,
                REG_MULTI_SZ,
                (LPBYTE)pszValue,
                (CchOfMultiSzAndTermSafe (pszValue) * sizeof(WCHAR)));
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetSz, HrRegSetString
//
//  Purpose:    Sets a string in the registry.  Assures that its type and
//              size are correct.  Easier to read than HrRegSetValueEx
//              with 5 parameters.  Type safe (no LPBYTE stuff).
//
//  Arguments:
//      hkey          [in]   The registry key.
//      pszValueName  [in]   The name of the value to set.
//      pszValue, str [in]   The string to set.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   1 Apr 1997
//
//  Notes:
//
inline HRESULT HrRegSetSz (HKEY hkey, PCWSTR pszValueName, PCWSTR pszValue)
{
    return HrRegSetValueEx (hkey, pszValueName, REG_SZ,
                            (LPBYTE)pszValue,
                            CbOfSzAndTermSafe (pszValue));
}

inline HRESULT HrRegSetString (HKEY hkey, PCWSTR pszValueName, const tstring& str)
{
    return HrRegSetSz (hkey, pszValueName, str.c_str());
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetBinary
//
//  Purpose:    Sets a binary value into the registry. Assures the type is
//              correct.
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to set.
//      pbData       [in]    Buffer containing binary data to write.
//      cbData       [in]    Size of buffer in bytes.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   16 Apr 1997
//
//  Notes:
//
inline HRESULT HrRegSetBinary(HKEY hkey, PCWSTR pszValueName,
                              const BYTE *pbData, DWORD cbData)
{
    return HrRegSetValueEx(hkey, pszValueName, REG_BINARY,
                           pbData, cbData);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetSzAsUlong
//
//  Purpose:    Writes the given ulong to the given registry value as a
//              REG_SZ.
//
//  Arguments:
//      hkey         [in] See Win32 docs.
//      pszValueName [in] See Win32 docs.
//      ulValue      [in] The value to write as a string
//      nBase        [in] The radix to convert the ulong from
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     billbe   14 Jun 1997
//
//  Notes:
//
inline
HRESULT
HrRegSetSzAsUlong (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN ULONG ulValue,
    IN int nBase)
{
    WCHAR szBuffer[20];

    // convert the value to a string using the specified base
    _ultow(ulValue, szBuffer, nBase);

    return HrRegSetSz(hkey, pszValueName, szBuffer);
}



//
//  Data structures
//

const HKEY      HKLM_SVCS       = (HKEY)(INT_PTR)(int)(0x80000007);

const DWORD     REG_MIN         = REG_QWORD;
const DWORD     REG_CREATE      = (REG_MIN + 1);
const DWORD     REG_BOOL        = (REG_MIN + 2);
const DWORD     REG_IP          = (REG_MIN + 3);
const DWORD     REG_FILE        = (REG_MIN + 4);
const DWORD     REG_HEX         = (REG_MIN + 5);

struct VALUETABLE
{
    // Name of value key
    PCWSTR          pszValueName;

    // Data and offset location
    DWORD           dwType;
    INT             cbOffset;

    // Default values
    BYTE*           pbDefault;
};

struct REGBATCH
{
    // Location of the registry entry
    HKEY            hkey;
    PCWSTR          pszSubkey;
    PCWSTR          pszValueName;

    // Data and offset location
    DWORD           dwType;
    INT             cbOffset;

    // Default values
    BYTE*           pbDefault;
};

VOID
RegReadValues (
    IN INT crvc,
    IN const REGBATCH* arb,
    OUT const BYTE* pbUserData,
    IN REGSAM samDesired);

HRESULT
HrRegWriteValues (
    IN INT crvc,
    IN const REGBATCH* arb,
    IN const BYTE* pbUserData,
    IN DWORD dwOptions,
    IN REGSAM samDesired);

HRESULT
HrRegWriteValueTable(
    IN HKEY hkeyRoot,
    IN INT cvt,
    IN const VALUETABLE* avt,
    IN const BYTE* pbUserData,
    IN DWORD dwOptions,
    IN REGSAM samDesired);

VOID
RegSafeCloseKey (
    IN HKEY hkey);

#endif // _NCREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncstl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S T L . H
//
//  Contents:   STL utilities.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   09 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCSTL_H_
#define _NCSTL_H_

#include "ncstlstr.h"   // CWideString
#include "stllist.h"    // list
#include "stlvec.h"     // vector
using namespace std;


typedef CWideString tstring;
typedef list<tstring*> ListStrings;

//+--------------------------------------------------------------------------
//
//  Funct:  DumpListStrings
//
//  Desc:   debug utility function to dump out the given list
//
//  Args:
//
//  Return: (void)
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
inline
PCWSTR
DumpListStrings(
    IN  const list<tstring *>&  lstr,
    OUT tstring*                pstrOut)
{
    WCHAR szBuf [1024];
    INT i;
    list<tstring *>::const_iterator iter;

    pstrOut->erase();

    for (iter = lstr.begin(), i = 1;
         iter != lstr.end();
         iter++, i++)
    {
        wsprintfW(szBuf, L"   %2i: %s\n", i, (*iter)->c_str());
        pstrOut->append(szBuf);
    }

    return pstrOut->c_str();
}


template<class T>
void
FreeCollectionAndItem (
    T& col)
{
    for(T::iterator iter = col.begin(); iter != col.end(); ++iter)
    {
        T::value_type pElem = *iter;
        delete pElem;
    }

    col.erase (col.begin(), col.end());
}


template<class T>
void
FreeVectorItem (
    vector<T>& v,
    UINT i)
{

    if ((v.size()>0) && (i<v.size()))
    {
       delete v[i];
       vector<T>::iterator iterItem = v.begin() + i;
       v.erase (iterItem);
    }
}


#endif // _NCSTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncshell.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S H E L L . H
//
//  Contents:   Basic common code.
//
//  Notes:
//
//  Author:     anbrad  08  Jun 1999
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _NCSHELL_H_
#define _NCSHELL_H_

#include <shlobj.h>
#include <shlobjp.h>

#ifndef PCONFOLDPIDLDEFINED
class PCONFOLDPIDL;
class PCONFOLDPIDLFOLDER;
#endif

VOID GenerateEvent(
    LONG            lEventId,
    const PCONFOLDPIDLFOLDER& pidlFolder,
    const PCONFOLDPIDL& pidlIn,
    LPCITEMIDLIST    pidlNewIn);

VOID GenerateEvent(
                   LONG          lEventId,
                   LPCITEMIDLIST pidlFolder,
                   LPCITEMIDLIST pidlIn,
                   LPCITEMIDLIST pidlNewIn);
#endif // _NCSHELL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncsetup.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S E T U P . H
//
//  Contents:   HRESULT wrappers for the Setup Api.
//
//  Notes:
//
//  Author:     shaunco   16 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCSETUP_H_
#define _NCSETUP_H_

#include <setupapi.h>
#include "ncstring.h"

enum SD_DEID_FLAG_TYPE
{
    SDDFT_FLAGS,
    SDDFT_FLAGSEX,
};

enum SD_FLAGS_BINARY_OP
{
    SDFBO_AND,
    SDFBO_OR,
    SDFBO_XOR,
};


//+---------------------------------------------------------------------------
// Lower level wrappers
//

HRESULT
HrSetupCommitFileQueue                  (HWND hwndOwner, HSPFILEQ hfq,
                                         PSP_FILE_CALLBACK pfc, PVOID pvCtx);

HRESULT
HrSetupInitDefaultQueueCallbackEx       (HWND hwndOwner,
                                         HWND hwndAlternate,
                                         UINT uMsg,
                                         DWORD dwReserved1,
                                         PVOID dwReserved2,
                                         PVOID* ppvCtx);

HRESULT
HrSetupOpenFileQueue                    (HSPFILEQ* phfq);

HRESULT
HrSetupOpenInfFile                      (PCWSTR pszFileName,
                                         PCWSTR pszInfClass,
                                         DWORD dwInfStyle,
                                         UINT* punErrorLine,
                                         HINF* phinf);
HRESULT
HrSetupFindFirstLine                    (HINF hinf,
                                         PCWSTR pszSection,
                                         PCWSTR pszKey,
                                         INFCONTEXT* pctx);
HRESULT
HrSetupFindNextLine                     (const INFCONTEXT& ctxIn,
                                         INFCONTEXT* pctxOut);
HRESULT
HrSetupFindNextMatchLine                (const INFCONTEXT& ctxIn,
                                         PCWSTR pszKey,
                                         INFCONTEXT* pctxOut);
HRESULT
HrSetupGetLineByIndex                   (HINF hinf,
                                         PCWSTR pszSection,
                                         DWORD dwIndex,
                                         INFCONTEXT* pctx);
HRESULT
HrSetupGetLineCount                     (HINF hinf,
                                         PCWSTR pszSection,
                                         ULONG* pulCount);
HRESULT
HrSetupGetBinaryField                   (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         BYTE* pbBuf, DWORD cbBuf,
                                         DWORD* pbRequired);
HRESULT
HrSetupGetIntField                      (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         INT* pnValue);
HRESULT
HrSetupGetMultiSzField                  (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         PWSTR pszBuf, DWORD cchBuf,
                                         DWORD* pcchRequired);
HRESULT
HrSetupGetMultiSzFieldWithAlloc         (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         PWSTR* ppszBuf);
HRESULT
HrSetupGetStringField                   (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         tstring* pstr);
HRESULT
HrSetupGetStringField                   (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         PWSTR pszBuf, DWORD cchBuf,
                                         DWORD* pcchRequired);

HRESULT
HrSetupScanFileQueueWithNoCallback      (HSPFILEQ hfq, DWORD dwFlags,
                                         HWND hwnd, PDWORD pdwResult);

VOID
SetupCloseInfFileSafe(HINF hinf);


//+---------------------------------------------------------------------------
// Intermediate functionality
//

HRESULT
HrSetupGetMultiSzFieldMapToDword        (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         const MAP_SZ_DWORD* aMapSzDword,
                                         UINT cMapSzDword,
                                         DWORD* pdwValue);
HRESULT
HrSetupGetStringFieldMapToDword         (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         const MAP_SZ_DWORD* aMapSzDword,
                                         UINT cMapSzDword,
                                         DWORD* pdwValue);
HRESULT
HrSetupGetStringFieldAsBool             (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         BOOL* pfValue);

//+---------------------------------------------------------------------------
// Find first and get
//
HRESULT
HrSetupGetFirstDword                    (HINF hinf,
                                         PCWSTR pszSection,
                                         PCWSTR pszKey,
                                         DWORD* pdwValue);
HRESULT
HrSetupGetFirstString                   (HINF hinf,
                                         PCWSTR pszSection,
                                         PCWSTR pszKey,
                                         tstring* pstr);
HRESULT
HrSetupGetFirstMultiSzFieldWithAlloc    (HINF hinf, PCWSTR szSection,
                                         PCWSTR szKey, PWSTR *pszOut);
HRESULT
HrSetupGetFirstMultiSzMapToDword        (HINF hinf,
                                         PCWSTR pszSection,
                                         PCWSTR pszKey,
                                         const MAP_SZ_DWORD* aMapSzDword,
                                         UINT cMapSzDword,
                                         DWORD* pdwValue);
HRESULT
HrSetupGetFirstStringMapToDword         (HINF hinf,
                                         PCWSTR pszSection,
                                         PCWSTR pszKey,
                                         const MAP_SZ_DWORD* aMapSzDword,
                                         UINT cMapSzDword,
                                         DWORD* pdwValue);
HRESULT
HrSetupGetFirstStringAsBool             (HINF hinf,
                                         PCWSTR pszSection,
                                         PCWSTR pszKey,
                                         BOOL* pfValue);

HRESULT
HrSetupGetInfInformation                (LPCVOID pvInfSpec,
                                         DWORD dwSearchControl,
                                         PSP_INF_INFORMATION* ppinfInfo);

HRESULT
HrSetupIsValidNt5Inf                    (HINF hinf);


HRESULT
HrSetupQueryInfVersionInformation       (PSP_INF_INFORMATION pinfInfo,
                                         UINT uiIndex, PCWSTR szKey,
                                         PWSTR* ppszInfo);

//+--------------------------------------------------------------------------
// SetupDi* wrappers and helpers
//

HRESULT
HrSetupCopyOemInf(IN const tstring& strSourceName,
      IN const tstring& strSourceMediaLocation, OPTIONAL
      IN DWORD dwSourceMediaType, IN DWORD dwCopyStyle,
      OUT tstring* pstrDestFilename, OPTIONAL
      OUT tstring* pstrDestFilenameComponent OPTIONAL);



HRESULT
HrSetupCopyOemInfBuffer(
    IN PCWSTR pszSourceName,
    IN PCWSTR pszSourceMediaLocation, OPTIONAL
    IN DWORD SourceMediaType,
    IN DWORD CopyStyle,
    OUT PWSTR pszDestFilename,
    IN DWORD cchDestFilename,
    OUT PWSTR* ppszDestFilenameComponent OPTIONAL);

HRESULT
HrSetupDiBuildDriverInfoList(IN HDEVINFO hdi, IN OUT PSP_DEVINFO_DATA pdeid,
                             IN DWORD dwDriverType);

HRESULT
HrSetupDiCallClassInstaller(DI_FUNCTION dif, HDEVINFO hdi,
                            PSP_DEVINFO_DATA pdeid);

HRESULT
HrSetupDiCreateDeviceInfo(IN HDEVINFO hdi, IN PCWSTR szDeviceName,
                          IN const GUID& guidClass, PCWSTR szDesc,
                          IN HWND hwndParent, IN DWORD dwFlags,
                          OUT PSP_DEVINFO_DATA pdeid);

HRESULT
HrSetupDiEnumDeviceInfo(IN HDEVINFO hdi, IN DWORD dwIndex,
                        PSP_DEVINFO_DATA pdeid);

HRESULT
HrSetupDiEnumDriverInfo(IN HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                        IN DWORD dwDriverType, IN DWORD dwIndex,
                        OUT PSP_DRVINFO_DATA pdrid);

HRESULT
HrSetupDiSelectBestCompatDrv(IN     HDEVINFO         hdi,
                             IN OUT PSP_DEVINFO_DATA pdeid);


HRESULT
HrSetupDiGetClassDevs (
    IN const GUID* pguidClass, OPTIONAL
    IN PCWSTR pszEnumerator, OPTIONAL
    IN HWND hwndParent, OPTIONAL
    IN DWORD dwFlags,
    OUT HDEVINFO* phdi);


HRESULT
HrSetupDiGetDeviceInfoListClass(IN HDEVINFO hdi, OUT GUID* pGuid);

HRESULT
HrSetupDiGetDeviceInstanceId(IN HDEVINFO hdi,
                             IN PSP_DEVINFO_DATA pdeid,
                             OUT PWSTR pszId,
                             IN DWORD cchId,
                             OUT DWORD* cchRequired);

HRESULT
HrSetupDiInstallDevice(IN HDEVINFO hdi, IN OUT PSP_DEVINFO_DATA pdeid);

HRESULT
HrSetupDiOpenDevRegKey(IN HDEVINFO hdi,
                       IN PSP_DEVINFO_DATA pdeid, IN DWORD dwScope,
                       IN DWORD dwHwProfile, IN DWORD dwKeyType,
                       IN REGSAM samDesired, OUT HKEY* phkey);

HRESULT
HrSetupDiSetClassInstallParams(IN HDEVINFO hdi, IN PSP_DEVINFO_DATA pdeid,
                               IN PSP_CLASSINSTALL_HEADER pcih,
                               IN DWORD cbSize);

HRESULT
HrSetupDiGetFixedSizeClassInstallParams(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                                        PSP_CLASSINSTALL_HEADER pcih,
                                        int cbSize);

HRESULT
HrSetupDiGetSelectedDriver(IN HDEVINFO hdi, IN PSP_DEVINFO_DATA pdeid,
                           OUT PSP_DRVINFO_DATA pdrid);

HRESULT
HrSetupDiGetDriverInfoDetail(IN HDEVINFO hdi, IN PSP_DEVINFO_DATA pdeid,
                             IN PSP_DRVINFO_DATA pdrid,
                             OUT PSP_DRVINFO_DETAIL_DATA* ppdridd);

HRESULT
HrSetupDiSetSelectedDriver(IN HDEVINFO hdi, IN PSP_DEVINFO_DATA pdeid,
                           IN OUT PSP_DRVINFO_DATA pdrid);

HRESULT
HrSetupDiCreateDevRegKey(IN HDEVINFO hdi,
                         IN PSP_DEVINFO_DATA pdeid, IN DWORD dwScope,
                         IN DWORD dwHwProfile, IN DWORD dwKeyType,
                         IN HINF hinf,
                         PCWSTR szInfSectionName,
                         OUT HKEY* phkey);


HRESULT
HrSetupDiGetActualSectionToInstall(IN HINF hinf,
                                   IN PCWSTR szSectionName,
                                   OUT tstring* pstrActualSectionName,
                                   OUT tstring* pstrExtension OPTIONAL);

HRESULT
HrSetupDiGetActualSectionToInstallWithAlloc(IN HINF hinf,
                                            IN PWSTR pszSection,
                                            OUT PWSTR* ppszActualSection,
                                            OUT PWSTR* ppszExtension OPTIONAL);


HRESULT
HrSetupDiGetActualSectionToInstallWithBuffer(
    IN  HINF hinf,
    IN  PCWSTR pszSection,
    OUT PWSTR  pszActualSection,
    IN  DWORD  cchActualSection,
    OUT DWORD* pcchRequired,
    OUT PWSTR* ppszExtension OPTIONAL);

HRESULT
HrSetupDiGetDeviceInstallParams(IN const HDEVINFO hdi,
                                IN const PSP_DEVINFO_DATA pdeid, OPTIONAL
                                OUT PSP_DEVINSTALL_PARAMS pdeip);

HRESULT
HrSetupDiGetDriverInstallParams(IN const HDEVINFO hdi,
                                IN const PSP_DEVINFO_DATA pdeid, OPTIONAL
                                IN const PSP_DRVINFO_DATA pdrid,
                                OUT PSP_DRVINSTALL_PARAMS pdrip);


void
SetupDiSetConfigFlags(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid, DWORD dwFlags,
                      SD_FLAGS_BINARY_OP eOp);

HRESULT
HrSetupDiSetDeviceInstallParams(IN const HDEVINFO hdi,
                                IN const PSP_DEVINFO_DATA pdeid, OPTIONAL
                                IN const PSP_DEVINSTALL_PARAMS pdeip);

HRESULT
HrSetupDiSetDriverInstallParams(IN const HDEVINFO hdi,
                                IN const PSP_DEVINFO_DATA pdeid, OPTIONAL
                                IN const PSP_DRVINFO_DATA pdrid,
                                IN const PSP_DRVINSTALL_PARAMS pdrip);

HRESULT
HrSetupDiSetDeipFlags(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                      DWORD dwFlags, SD_DEID_FLAG_TYPE eFlagType,
                      SD_FLAGS_BINARY_OP eOp);

HRESULT
HrSetupDiRemoveDevice(IN HDEVINFO hdi,
                      IN PSP_DEVINFO_DATA pdeid);

HRESULT
HrSetupDiOpenDeviceInfo(IN const HDEVINFO hdi,
                        IN PCWSTR szPnpInstanceId,
                        IN HWND hwndParent, IN DWORD dwOpenFlags,
                        OUT PSP_DEVINFO_DATA pdeid OPTIONAL);

HRESULT
HrSetupDiCreateDeviceInfoList(const GUID* pguidClass, HWND hwndParent,
                              HDEVINFO* phdi);

HRESULT
HrSetupDiGetDeviceName(IN HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                       OUT PWSTR* ppszName);

HRESULT
HrSetupDiSetDeviceName (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN PCWSTR szDeviceName);

HRESULT
HrSetupDiGetDeviceRegistryPropertyWithAlloc(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwProperty,
    OUT DWORD* pdwRegType, OPTIONAL
    OUT BYTE** ppbBuffer);

HRESULT
HrSetupDiGetDeviceRegistryProperty(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwProperty,
    OUT DWORD* pdwRegType, OPTIONAL
    OUT BYTE* pbBuffer,
    IN DWORD cbBufferSize,
    OUT DWORD* pcbRequiredSize OPTIONAL
    );

HRESULT
HrSetupDiSetDeviceRegistryProperty(IN HDEVINFO hdi,
                                   IN OUT PSP_DEVINFO_DATA pdeid,
                                   IN DWORD dwProperty,
                                   IN const BYTE* pbBuffer,
                                   IN DWORD cbSize);
HRESULT
HrSetupDiSendPropertyChangeNotification(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                                        DWORD dwStateChange, DWORD dwScope,
                                        DWORD dwProfileId);

BOOL
FSetupDiCheckIfRestartNeeded(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid);

HRESULT
HrSetupDiGetClassImageList(PSP_CLASSIMAGELIST_DATA pcild);

HRESULT
HrSetupDiDestroyClassImageList(PSP_CLASSIMAGELIST_DATA pcild);

VOID
SetupDiDestroyDeviceInfoListSafe(HDEVINFO hdi);

HRESULT
HrSetupDiGetClassImageIndex(PSP_CLASSIMAGELIST_DATA pcild,
                            const GUID* pguidClass, INT* pnIndex);


HRESULT
HrSetupDiGetParentWindow(IN const HDEVINFO hdi,
                         IN const PSP_DEVINFO_DATA pdeid,
                         OUT HWND* phwndParent);


HRESULT
HrSetupInstallFilesFromInfSection(HINF hinf, HINF hinfLayout, HSPFILEQ hfq,
                                  PCWSTR szSection, PCWSTR szSourcePath,
                                  UINT ulFlags);

HRESULT
HrSetupInstallFromInfSection(HWND hwnd, HINF hinf, PCWSTR szSection,
                             UINT ulFlags, HKEY hkey, PCWSTR szSource,
                             UINT ulCopyFlags, PSP_FILE_CALLBACK pfc,
                             PVOID pvCtx, HDEVINFO hdi,
                             PSP_DEVINFO_DATA pdeid);
HRESULT
HrSetupInstallServicesFromInfSection(HINF hinf, PCWSTR szSection,
                                     DWORD dwFlags);

HRESULT
HrFindDeviceOnInterface (
    const GUID* pguidDeviceId,
    const GUID* pguidInterfaceId,
    PCWSTR     pszwReferenceString,
    DWORD       dwFlagsAndAttributes,
    HANDLE*     phFile);

HRESULT
HrInstallSoftwareDeviceOnInterface (
    const GUID* pguidDeviceId,
    const GUID* pguidInterfaceId,
    PCWSTR     pszwReferenceString,
    BOOL        fForceInstall,
    PCWSTR     pszwInfFilename,
    HWND        hwndParent);

#if defined(REMOTE_BOOT)
HRESULT
HrIsRemoteBootAdapter(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid);
#endif

//+---------------------------------------------------------------------------
//
//  Class:      CSetupInfFile
//
//  Purpose:    Handles operations on an INF file.
//
//  Justification:
//      This is a class instead of seperate functions to allow us to move
//      towards the error handling model associated with throwing exceptions.
//      That is, when one of these objects is declared on the stack, and
//      an exception is thrown, it will clean itself up.  (This object
//      does NOT explicitly throw any exceptions.)
//
class CSetupInfFile
{
public:
    CSetupInfFile   ();
    ~CSetupInfFile  ()  { EnsureClosed(); }

    void    Close   ();
    HRESULT HrOpen  (PCWSTR pszFileName, PCWSTR pszInfClass,
                     DWORD dwInfStyle, UINT* punErrorLine);

    HINF    Hinf ();

    HRESULT HrGetDword              (PCWSTR pszSection, PCWSTR pszKey,
                                     DWORD* pdwValue);
    HRESULT HrGetString             (PCWSTR pszSection, PCWSTR pszKey,
                                     tstring* pstr);
    HRESULT HrGetStringAsBool       (PCWSTR pszSection, PCWSTR pszKey,
                                     BOOL* pfValue);
    HRESULT HrGetStringMapToDword   (PCWSTR pszSection, PCWSTR pszKey,
                                     const MAP_SZ_DWORD* aMapSzDword,
                                     UINT cMapSzDword,
                                     DWORD* pdwValue);
    HRESULT HrGetMultiSzMapToDword  (PCWSTR pszSection, PCWSTR pszKey,
                                     const MAP_SZ_DWORD* aMapSzDword,
                                     UINT cMapSzDword,
                                     DWORD* pdwValue);

protected:
    void    EnsureClosed ();
    HINF    m_hinf;
};


inline CSetupInfFile::CSetupInfFile ()
{
    m_hinf = NULL;
}


inline
HRESULT CSetupInfFile::HrOpen (PCWSTR pszFileName, PCWSTR pszInfClass,
                               DWORD dwInfStyle, UINT* punErrorLine)
{
    AssertSzH (!m_hinf, "You must first close the previous one you opened.");
    return HrSetupOpenInfFile (pszFileName, pszInfClass, dwInfStyle,
                               punErrorLine, &m_hinf);
}

inline HINF CSetupInfFile::Hinf ()
{
    AssertSzH (m_hinf, "You must call HrOpen first.");
    return m_hinf;
}

inline
HRESULT CSetupInfFile::HrGetDword (PCWSTR pszSection, PCWSTR pszKey,
                                   DWORD* pdwValue)
{
    return HrSetupGetFirstDword (Hinf(), pszSection, pszKey, pdwValue);
}

inline
HRESULT CSetupInfFile::HrGetString (PCWSTR pszSection, PCWSTR pszKey,
                                    tstring* pstr)
{
    return HrSetupGetFirstString (Hinf(), pszSection, pszKey, pstr);
}

inline
HRESULT CSetupInfFile::HrGetStringAsBool (PCWSTR pszSection, PCWSTR pszKey,
                                          BOOL* pfValue)
{
    return HrSetupGetFirstStringAsBool (Hinf(), pszSection, pszKey, pfValue);
}

inline
HRESULT CSetupInfFile::HrGetStringMapToDword (PCWSTR pszSection, PCWSTR pszKey,
                                              const MAP_SZ_DWORD* aMapSzDword,
                                              UINT cMapSzDword,
                                              DWORD* pdwValue)
{
    return HrSetupGetFirstStringMapToDword (Hinf(), pszSection, pszKey,
                                            aMapSzDword, cMapSzDword, pdwValue);
}

inline
HRESULT CSetupInfFile::HrGetMultiSzMapToDword (PCWSTR pszSection, PCWSTR pszKey,
                                               const MAP_SZ_DWORD* aMapSzDword,
                                               UINT cMapSzDword,
                                               DWORD* pdwValue)
{
    return HrSetupGetFirstMultiSzMapToDword (Hinf(), pszSection, pszKey,
                                             aMapSzDword, cMapSzDword, pdwValue);
}

inline BOOL
IsValidHandle(HANDLE h)
{
    return (h && INVALID_HANDLE_VALUE != h);
}

// Moved from oemupgrd.h
//
HRESULT HrInstallFromInfSectionInFile(IN HWND    hwndParent,
                                      IN PCWSTR szInfName,
                                      IN PCWSTR szSection,
                                      IN HKEY    hkeyRelative,
                                      IN BOOL    fQuietInstall);

#endif // _NCSETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncstring.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S T R I N G . H
//
//  Contents:   Common string routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once

#include "ncdebug.h"
#include "ncvalid.h"
#include "ncmsz.h"
#include "ncstl.h"


const int c_cchGuidWithTerm = 39; // includes terminating null
const int c_cbGuidWithTerm   = c_cchGuidWithTerm * sizeof(WCHAR);


inline ULONG CbOfSz         (PCWSTR psz)   { AssertH(psz); return wcslen (psz) * sizeof(WCHAR); }
inline ULONG CbOfSza        (PCSTR  psza)  { AssertH(psza); return strlen (psza) * sizeof(CHAR); }

inline ULONG CbOfSzAndTerm  (PCWSTR psz)   { AssertH(psz); return (wcslen (psz) + 1) * sizeof(WCHAR); }
inline ULONG CbOfSzaAndTerm (PCSTR  psza)  { AssertH(psza); return (strlen (psza) + 1) * sizeof(CHAR); }

ULONG CbOfSzSafe            (PCWSTR psz);
ULONG CbOfSzaSafe           (PCSTR  psza);

ULONG CbOfSzAndTermSafe     (PCWSTR psz);
ULONG CbOfSzaAndTermSafe    (PCSTR  psza);

ULONG
CchOfSzSafe (
    PCWSTR psz);

inline ULONG CchToCb        (ULONG cch)     { return cch * sizeof(WCHAR); }


struct MAP_SZ_DWORD
{
    PCWSTR pszValue;
    DWORD  dwValue;
};


PWSTR
PszAllocateAndCopyPsz (
    PCWSTR pszSrc);

extern const WCHAR c_szEmpty[];

template<class T>
VOID
ConvertStringToColString (
    IN  PCWSTR psz,
    IN  const WCHAR chSeparator,
    OUT T& coll)
{
    AssertSz(chSeparator, "Separator can not be \0");

    FreeCollectionAndItem(coll);

    if (NULL == psz)
    {
        return;
    }

    PWSTR  pszBuf = new WCHAR[wcslen(psz) + 1];

    wcscpy(pszBuf, psz);
    WCHAR* pchString = pszBuf;
    WCHAR* pchSeparator;
    while (*pchString)
    {
        pchSeparator = wcschr(pchString, chSeparator);
        if (pchSeparator)
        {
            *pchSeparator = 0;
        }

        if (*pchString)
        {
            coll.push_back(new tstring(pchString));
        }

        if (pchSeparator)
        {
            pchString = pchSeparator + 1;
        }
        else
        {
            break;
        }
    }

    delete [] pszBuf;
}


template<class T>
VOID
ConvertColStringToString (
    IN  const T& coll,
    IN  const WCHAR chSeparator,
    OUT tstring& str)
{
    AssertSz(chSeparator, "Separator can not be \0");

    if (chSeparator)
    {
        T::const_iterator iter = coll.begin();

        while (iter != coll.end())
        {
            str += (*iter)->c_str();

            ++iter;
            if (iter != coll.end())
            {
                str += chSeparator;
            }
        }
    }
}


DWORD
WINAPIV
DwFormatString (
    PCWSTR pszFmt,
    PWSTR  pszBuf,
    DWORD   cchBuf,
    ...);

DWORD
WINAPIV
DwFormatStringWithLocalAlloc (
    PCWSTR pszFmt,
    PWSTR* ppszBuf,
    ...);

enum NC_IGNORE_SPACES
{
    NC_IGNORE,
    NC_DONT_IGNORE,
};


BOOL
FFindStringInCommaSeparatedList (
    PCWSTR pszSubString,
    PCWSTR pszList,
    NC_IGNORE_SPACES eIgnoreSpaces,
    DWORD* pdwPosition);

enum NC_FIND_ACTION
{
    NC_NO_ACTION,
    NC_REMOVE_FIRST_MATCH,
    NC_REMOVE_ALL_MATCHES,
};

inline BOOL
FFindFirstMatch (
    NC_FIND_ACTION eAction)
{
    return (NC_NO_ACTION == eAction) || (NC_REMOVE_FIRST_MATCH == eAction);
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsBstrEmpty
//
//  Purpose:    Determines if the given BSTR is "empty" meaning the pointer
//              is NULL or the string is 0-length.
//
//  Arguments:
//      bstr [in]   BSTR to check.
//
//  Returns:    TRUE if the BSTR is empty, FALSE if not.
//
//  Author:     danielwe   20 May 1997
//
//  Notes:
//
inline
BOOL
FIsBstrEmpty (
    BSTR    bstr)
{
    return !(bstr && *bstr);
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsStrEmpty
//
//  Purpose:    Determines if the given PCWSTR is "empty" meaning the pointer
//              is NULL or the string is 0-length.
//
//  Arguments:
//      bstr [in]   BSTR to check.
//
//  Returns:    TRUE if the BSTR is empty, FALSE if not.
//
//  Author:     danielwe   20 May 1997
//
//  Notes:
//
inline
BOOL
FIsStrEmpty (
    PCWSTR    psz)
{
    return !(psz && *psz);
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsPrefix
//
//  Purpose:    Returns whether a string is a prefix of another string.
//
//  Arguments:
//      pszPrefix [in]   Potential prefix
//      pszString [in]   String that may begin with the prefix
//
//  Returns:    TRUE if given prefix string is a prefix of the target string.
//
//  Author:     danielwe   24 Mar 1997
//
//  Notes:      Uses CompareString with the default locale.
//
inline
BOOL
FIsPrefix (
    PCWSTR pszPrefix,
    PCWSTR pszString)
{
    Assert (pszPrefix);
    Assert (pszString);

    return (0 == _wcsnicmp(pszPrefix, pszString, wcslen(pszPrefix)));
}

BOOL
FIsSubstr (
    PCWSTR pszSubString,
    PCWSTR pszString);

HRESULT
HrAddStringToDelimitedSz (
    PCWSTR pszAddString,
    PCWSTR pszIn,
    WCHAR chDelimiter,
    DWORD dwFlags,
    DWORD dwStringIndex,
    PWSTR* ppszOut);

HRESULT
HrRemoveStringFromDelimitedSz (
    PCWSTR pszRemove,
    PCWSTR pszIn,
    WCHAR chDelimiter,
    DWORD dwFlags,
    PWSTR* ppszOut);


//+---------------------------------------------------------------------------
//
//  Function:   template<class T> ColStringToMultiSz
//
//  Purpose:    Convert an STL collection of tstring pointers to a multi-sz.
//
//  Arguments:
//      listStr [in]    list of tstring pointers to put in the multi-sz.
//      ppszOut [out]   the returned multi-sz.
//
//  Returns:    nothing.
//
//  Author:     shaunco   10 Apr 1997
//
//  Notes:      The output multi-sz should be freed using delete.
//
template<class T>
VOID
ColStringToMultiSz (
    const T&    colStr,
    PWSTR*     ppszOut)
{
    Assert (ppszOut);

    // Count up the count of characters consumed by the list of strings.
    // This count includes the null terminator of each string.
    //
    T::const_iterator iter;
    UINT cch = 0;
    for (iter = colStr.begin(); iter != colStr.end(); iter++)
    {
        tstring* pstr = *iter;
        if (!pstr->empty())
        {
            cch += (UINT)(pstr->length() + 1);
        }
    }

    if (cch)
    {
        // Allocate the multi-sz.  Assumes new will throw on error.
        //
        PWSTR pszOut = new WCHAR [cch + 1];
        *ppszOut = pszOut;

        // Copy the strings to the multi-sz.
        //
        for (iter = colStr.begin(); iter != colStr.end(); iter++)
        {
            tstring* pstr = *iter;
            if (!pstr->empty())
            {
                lstrcpyW (pszOut, pstr->c_str());
                pszOut += pstr->length() + 1;
            }
        }

        // Null terminate the multi-sz.
        Assert (pszOut == *ppszOut + cch);
        *pszOut = 0;
    }
    else
    {
        *ppszOut = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   template<class T> DeleteColString
//
//  Purpose:    Empty a list of tstring and delete each tstring as it is
//              removed.
//
//  Arguments:
//      pcolstr [inout] Collection of tstring pointers to delete and empty
//
//  Returns:    nothing
//
//  Author:     mikemi   30 Apr 1997
//
//  Notes:
//
template<class T>
VOID
DeleteColString (
    T*  pcolstr)
{
    Assert( pcolstr );

    T::const_iterator iter;
    tstring* pstr;

    for (iter = pcolstr->begin(); iter != pcolstr->end(); iter++)
    {
        pstr = *iter;
        delete pstr;
    }
    pcolstr->erase( pcolstr->begin(), pcolstr->end() );
}

//+---------------------------------------------------------------------------
//
//  Function:   template<class T> MultiSzToColString
//
//  Purpose:    Convert an multi-sz buffer to a STL collection of tstring
//              pointers.
//
//  Arguments:
//      pmsz    [in]    the multi-sz to convert (Can be NULL)
//      pcolstr [out]   list of tstring pointers to add allocated tstrings to
//
//  Returns:    nothing
//
//  Author:     mikemi   30 Apr 1997
//
//  Notes:      The output collection should be freed using DeleteColString.
//              This function will delete the collection list passed
//
template<class T>
VOID
MultiSzToColString (
    PCWSTR pmsz,
    T*      pcolstr)
{
    Assert (pcolstr);

    if (!pcolstr->empty())
    {
        DeleteColString (pcolstr);
    }

    if (pmsz)
    {
        while (*pmsz)
        {
            tstring* pstr = new tstring;
            if (pstr)
            {
                *pstr = pmsz;
                pcolstr->push_back (pstr);
            }
            // get the next string even if new failed
            pmsz += lstrlen (pmsz) + 1;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   template<class T> RemoveDupsInColPtr
//
//  Purpose:    Remove all duplicate entries in an STL collection of pointers
//              to objects.
//
//  Arguments:
//      pcol [inout]    Collection of pointers to objects.
//
//  Returns:    nothing
//
//  Author:     mikemi   03 May 1997
//
//  Notes:      The objects pointed at should have a comparison operator
//
template<class T>
VOID
RemoveDupsInColPtr (
    T*  pcol)
{
    Assert (pcol);

    // remove duplicates
    //
    T::iterator     posItem;
    T::iterator     pos;
    T::value_type   pItem;
    T::value_type   p;

    posItem = pcol->begin();
    while (posItem != pcol->end())
    {
        pItem = *posItem;

        // for every other item, remove the duplicates
        pos = posItem;
        pos++;
        while (pos != pcol->end())
        {
            p = *pos;

            if ( *pItem == *p )
            {
                pos = pcol->erase( pos );
                delete p;
            }
            else
            {
                pos++;
            }
        }
        // increment afterwards due to fact that we are removing,
        // and otherwise could have removed the item it pointed to
        posItem++;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   template<class T> CopyColPtr
//
//  Purpose:    Copies one collection of pointers into another.
//
//  Arguments:
//      pcolDest [out]  Collection of pointers to objects.
//      pcolSrc  [in]   Collection of pointers to objects.
//
//  Returns:    nothing
//
//  Author:     BillBe   13 Jun 1998
//
//  Notes:
//
template<class T>
VOID
CopyColPtr (T* pcolDest, const T& colSrc)
{
    Assert (pcolDest);

    T::iterator     posItem;

    // Clear out destination
    pcolDest->erase(pcolDest->begin(), pcolDest->end());

    // Go through each item in pcolSrc and add to pcolDest
    //
    posItem = colSrc.begin();
    while (posItem != colSrc.end())
    {
        pcolDest->push_back(*posItem);
        posItem++;
    }
}


PCWSTR
SzLoadStringPcch (
    HINSTANCE   hinst,
    UINT        unId,
    int*        pcch);

//+---------------------------------------------------------------------------
//
//  Function:   SzLoadString
//
//  Purpose:    Load a resource string.  (This function will never return NULL.)
//
//  Arguments:
//      hinst [in]  Instance handle of module with the string resource.
//      unId  [in]  Resource ID of the string to load.
//
//  Returns:    Pointer to the constant string.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      See SzLoadStringPcch()
//
inline
PCWSTR
SzLoadString (
    HINSTANCE   hinst,
    UINT        unId)
{
    int cch;
    return SzLoadStringPcch(hinst, unId, &cch);
}

PSTR
SzaDupSza (
    IN PCSTR  pszaSrc);

PWSTR
SzDupSz (
    IN PCWSTR pszSrc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\nctraceui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       N C T R A C E U I . H 
//
//  Contents:   Tracing Property sheet UI prototype
//
//  Notes:      
//
//  Author:     jeffspr   31 Aug 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCTRACEUI_H_
#define _NCTRACEUI_H_

//---[ Prototypes ]-----------------------------------------------------------

HRESULT HrOpenTracingUI(HWND hwndOwner);

#endif // _NCTRACEUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncstlstr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S T L S T R . H
//
//  Contents:   STL string class renamed so as to remove our dependance
//              from msvcp50.dll.
//
//  Notes:
//
//  Author:     shaunco   12 Apr 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCSTLSTR_H_
#define _NCSTLSTR_H_

#include <stliter.h>
#include <stlxutil.h>
#include <limits.h>
#include <wchar.h>
#include "ncdebug.h"
using namespace std;


//template<class _E,
//class _Tr = char_traits<_E>,
//class _A  = allocator<_E> >

struct wchar_traits
{
    typedef wchar_t     _E;
    typedef _E          char_type;   // for overloads
    typedef wint_t      int_type;
    typedef mbstate_t   state_type;

    static void __cdecl assign(_E& _X, const _E& _Y)
    {
        _X = _Y;
    }
    static bool __cdecl eq(const _E& _X, const _E& _Y)
    {
        return (_X == _Y);
    }
    static bool __cdecl lt(const _E& _X, const _E& _Y)
    {
        return (_X < _Y);
    }
    static int __cdecl compare(const _E *_U, const _E *_V, size_t _N)
    {
        return (wmemcmp(_U, _V, _N));
    }
    static size_t __cdecl length(const _E *_U)
    {
        return (wcslen(_U));
    }
    static _E *__cdecl copy(_E *_U, const _E *_V, size_t _N)
    {
        return (wmemcpy(_U, _V, _N));
    }
    static const _E * __cdecl find(const _E *_U, size_t _N,
                                   const _E& _C)
    {
        return ((const _E *)wmemchr(_U, _C, _N));
    }
    static _E * __cdecl move(_E *_U, const _E *_V, size_t _N)
    {
        return (wmemmove(_U, _V, _N));
    }
    static _E * __cdecl assign(_E *_U, size_t _N, const _E& _C)
    {
        return (wmemset(_U, _C, _N));
    }
    static _E __cdecl to_char_type(const int_type& _C)
    {
        return (_C);
    }
    static int_type __cdecl to_int_type(const _E& _C)
    {
        return (_C);
    }
    static bool __cdecl eq_int_type(const int_type& _X,
                                    const int_type& _Y)
    {
        return (_X == _Y);
    }
    static int_type __cdecl eof()
    {
        return (WEOF);
    }
    static int_type __cdecl not_eof(const int_type& _C)
    {
        return (_C != eof() ? _C : !eof());
    }
};


class CWideString
{
public:
    typedef CWideString     _Myt;
    typedef wchar_traits    _Tr;
    typedef _Tr::_E         _E;
    typedef size_t          size_type;
    typedef ptrdiff_t       difference_type;
    typedef _E*             pointer;
    typedef const _E*       const_pointer;
    typedef _E&             reference;
    typedef const _E&       const_reference;
    typedef _E              value_type;
    typedef pointer         iterator;
    typedef const_pointer   const_iterator;

    typedef reverse_iterator<const_iterator, value_type, const_reference,
                                const_pointer, difference_type>
                const_reverse_iterator;

    typedef reverse_iterator<iterator, value_type, reference, pointer,
                                difference_type>
                reverse_iterator;

    typedef const_iterator _It;

    explicit CWideString()
    {
        _Tidy();
    }
    CWideString(const _Myt& _X)
    {
        _Tidy(), assign(_X, 0, npos);
    }
    CWideString(const _Myt& _X, size_type _P, size_type _M)
    {
        _Tidy(), assign(_X, _P, _M);
    }
    CWideString(const _E *_S, size_type _N)
    {
        _Tidy(), assign(_S, _N);
    }
    CWideString(const _E *_S)
    {
        _Tidy(), assign(_S);
    }
    CWideString(size_type _N, _E _C)
    {
        _Tidy(), assign(_N, _C);
    }
    CWideString(_It _F, _It _L)
    {
        _Tidy(); assign(_F, _L);
    }
    ~CWideString()
    {
        _Tidy(true);
    }
    enum _Mref
    {
        _FROZEN = USHRT_MAX
    };
    enum _Npos
    {
        // -1 is not arbitrary.  It is chosen because it works in math
        // operations.  npos is treated as size_type and is inolved in
        // arithmetic.
        //
        npos = -1
    };
    _Myt& operator=(const _Myt& _X)
    {
        return (assign(_X));
    }
    _Myt& operator=(const _E *_S)
    {
        return (assign(_S));
    }
    _Myt& operator=(_E _C)
    {
        return (assign(1, _C));
    }
    _Myt& operator+=(const _Myt& _X)
    {
        return (append(_X));
    }
    _Myt& operator+=(const _E *_S)
    {
        return (append(_S));
    }
    _Myt& operator+=(_E _C)
    {
        return (append(1, _C));
    }
    _Myt& append(const _Myt& _X)
    {
        return (append(_X, 0, npos));
    }
    _Myt& append(const _Myt& _X, size_type _P, size_type _M)
    {
        AssertH (_X.size() >= _P);
        //if (_X.size() < _P)
        //    _Xran();

        size_type _N = _X.size() - _P;
        if (_N < _M)
            _M = _N;

        AssertH ((_Len + _M < npos));
        //if (npos - _Len <= _M)
        //    _Xlen();

        if (0 < _M && _Grow(_N = _Len + _M))
        {
            _Tr::copy(_Ptr + _Len, &_X.c_str()[_P], _M);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& append(const _E *_S, size_type _M)
    {
        AssertH ((_Len + _M < npos));
        //if (npos - _Len <= _M)
        //    _Xlen();

        size_type _N;
        if (0 < _M && _Grow(_N = _Len + _M))
        {
            _Tr::copy(_Ptr + _Len, _S, _M);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& append(const _E *_S)
    {
        return (append(_S, _Tr::length(_S)));
    }
    _Myt& append(size_type _M, _E _C)
    {
        AssertH ((_Len + _M < npos));
        //if (npos - _Len <= _M)
        //    _Xlen();

        size_type _N;
        if (0 < _M && _Grow(_N = _Len + _M))
        {
            _Tr::assign(_Ptr + _Len, _M, _C);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& append(_It _F, _It _L)
    {
        return (replace(end(), end(), _F, _L));
    }
    _Myt& assign(const _Myt& _X)
    {
        return (assign(_X, 0, npos));
    }
    _Myt& assign(const _Myt& _X, size_type _P, size_type _M)
    {
        AssertH (_X.size() >= _P);
        //if (_X.size() < _P)
        //    _Xran();

        size_type _N = _X.size() - _P;
        if (_M < _N)
            _N = _M;

        if (this == &_X)
        {
            erase((size_type)(_P + _N)), erase(0, _P);
        }
        else if (0 < _N && _N == _X.size()
                 && _Refcnt(_X.c_str()) < _FROZEN - 1)
        {
            _Tidy(true);
            _Ptr = (_E *)_X.c_str();
            _Len = _X.size();
            _Res = _X.capacity();
            ++_Refcnt(_Ptr);
        }
        else if (_Grow(_N, true))
        {
            _Tr::copy(_Ptr, &_X.c_str()[_P], _N);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& assign(const _E *_S, size_type _N)
    {
        if (_Grow(_N))
        {
            _Tr::copy(_Ptr, _S, _N);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& assign(const _E *_S)
    {
        return (assign(_S, _Tr::length(_S)));
    }
    _Myt& assignSafe(const _E *_S)
    {
        return (_S) ? assign(_S, _Tr::length(_S)) : erase();
    }
    _Myt& assign(size_type _N, _E _C)
    {
        AssertH (npos != _N);
        //if (_N == npos)
        //    _Xlen();

        if (_Grow(_N))
        {
            _Tr::assign(_Ptr, _N, _C);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& assign(_It _F, _It _L)
    {
        return (replace(begin(), end(), _F, _L));
    }
    _Myt& insert(size_type _P0, const _Myt& _X)
    {
        return (insert(_P0, _X, 0, npos));
    }
    _Myt& insert(size_type _P0, const _Myt& _X, size_type _P, size_type _M)
    {
        AssertH ((_Len >= _P0) && (_X.size() >= _P));
        //if (_Len < _P0 || _X.size() < _P)
        //    _Xran();

        size_type _N = _X.size() - _P;
        if (_N < _M)
            _M = _N;

        AssertH ((_Len + _M < npos));
        //if (npos - _Len <= _M)
        //    _Xlen();

        if (0 < _M && _Grow(_N = _Len + _M))
        {
            _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);
            _Tr::copy(_Ptr + _P0, &_X.c_str()[_P], _M);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& insert(size_type _P0, const _E *_S, size_type _M)
    {
        AssertH (_Len >= _P0);
        //if (_Len < _P0)
        //    _Xran();

        AssertH ((_Len + _M < npos));
        //if (npos - _Len <= _M)
        //    _Xlen();

        size_type _N;
        if (0 < _M && _Grow(_N = _Len + _M))
        {
            _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);
            _Tr::copy(_Ptr + _P0, _S, _M);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& insert(size_type _P0, const _E *_S)
    {
        return (insert(_P0, _S, _Tr::length(_S)));
    }
    _Myt& insert(size_type _P0, size_type _M, _E _C)
    {
        AssertH (_Len >= _P0);
        //if (_Len < _P0)
        //    _Xran();

        AssertH ((_Len + _M < npos));
        //if (npos - _Len <= _M)
        //    _Xlen();

        size_type _N;
        if (0 < _M && _Grow(_N = _Len + _M))
        {
            _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);
            _Tr::assign(_Ptr + _P0, _M, _C);
            _Eos(_N);
        }
        return (*this);
    }
    iterator insert(iterator _P, _E _C)
    {
        size_type _P0 = _Pdif(_P, begin());
        insert(_P0, 1, _C);
        return (begin() + _P0);
    }
    void insert(iterator _P, size_type _M, _E _C)
    {
        size_type _P0 = _Pdif(_P, begin());
        insert(_P0, _M, _C);
    }
    void insert(iterator _P, _It _F, _It _L)
    {
        replace(_P, _P, _F, _L);
    }
    _Myt& erase(size_type _P0 = 0, size_type _M = npos)
    {
        AssertH (_Len >= _P0);
        //if (_Len < _P0)
        //    _Xran();

        _Split();
        if (_Len - _P0 < _M)
            _M = _Len - _P0;
        if (0 < _M)
        {
            _Tr::move(_Ptr + _P0, _Ptr + _P0 + _M,
                      _Len - _P0 - _M);
            size_type _N = _Len - _M;
            if (_Grow(_N))
                _Eos(_N);
        }
        return (*this);
    }
    iterator erase(iterator _P)
    {
        size_t _M = _Pdif(_P, begin());
        erase(_M, 1);
        return (_Psum(_Ptr, _M));
    }
    iterator erase(iterator _F, iterator _L)
    {
        size_t _M = _Pdif(_F, begin());
        erase(_M, _Pdif(_L, _F));
        return (_Psum(_Ptr, _M));
    }
    _Myt& replace(size_type _P0, size_type _N0, const _Myt& _X)
    {
        return (replace(_P0, _N0, _X, 0, npos));
    }
    _Myt& replace(size_type _P0, size_type _N0, const _Myt& _X,
                  size_type _P, size_type _M)
    {
        AssertH ((_Len >= _P0) && (_X.size() >= _P));
        //if (_Len < _P0 || _X.size() < _P)
        //    _Xran();

        if (_Len - _P0 < _N0)
            _N0 = _Len - _P0;

        size_type _N = _X.size() - _P;
        if (_N < _M)
            _M = _N;

        AssertH (npos - _M > _Len - _N0);
        //if (npos - _M <= _Len - _N0)
        //    _Xlen();

        _Split();
        size_type _Nm = _Len - _N0 - _P0;
        if (_M < _N0)
            _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);

        if ((0 < _M || 0 < _N0) && _Grow(_N = _Len + _M - _N0))
        {
            if (_N0 < _M)
                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
            _Tr::copy(_Ptr + _P0, &_X.c_str()[_P], _M);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& replace(size_type _P0, size_type _N0, const _E *_S,
                  size_type _M)
    {
        AssertH (_Len >= _P0);
        //if (_Len < _P0)
        //    _Xran();

        if (_Len - _P0 < _N0)
            _N0 = _Len - _P0;

        AssertH (npos - _M > _Len - _N0);
        //if (npos - _M <= _Len - _N0)
        //    _Xlen();

        _Split();
        size_type _Nm = _Len - _N0 - _P0;
        if (_M < _N0)
            _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
        size_type _N;
        if ((0 < _M || 0 < _N0) && _Grow(_N = _Len + _M - _N0))
        {
            if (_N0 < _M)
                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
            _Tr::copy(_Ptr + _P0, _S, _M);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& replace(size_type _P0, size_type _N0, const _E *_S)
    {
        return (replace(_P0, _N0, _S, _Tr::length(_S)));
    }
    _Myt& replace(size_type _P0, size_type _N0,
                  size_type _M, _E _C)
    {
        AssertH (_Len >= _P0);
        //if (_Len < _P0)
        //    _Xran();

        if (_Len - _P0 < _N0)
            _N0 = _Len - _P0;

        AssertH (npos - _M > _Len - _N0);
        //if (npos - _M <= _Len - _N0)
        //    _Xlen();

        _Split();
        size_type _Nm = _Len - _N0 - _P0;
        if (_M < _N0)
            _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
        size_type _N;
        if ((0 < _M || 0 < _N0) && _Grow(_N = _Len + _M - _N0))
        {
            if (_N0 < _M)
                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0,
                          _Nm);
            _Tr::assign(_Ptr + _P0, _M, _C);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& replace(iterator _F, iterator _L, const _Myt& _X)
    {
        return (replace(_Pdif(_F, begin()), _Pdif(_L, _F), _X));
    }
    _Myt& replace(iterator _F, iterator _L, const _E *_S,
                  size_type _M)
    {
        return (replace(_Pdif(_F, begin()), _Pdif(_L, _F), _S, _M));
    }
    _Myt& replace(iterator _F, iterator _L, const _E *_S)
    {
        return (replace(_Pdif(_F, begin()), _Pdif(_L, _F), _S));
    }
    _Myt& replace(iterator _F, iterator _L, size_type _M, _E _C)
    {
        return (replace(_Pdif(_F, begin()), _Pdif(_L, _F), _M, _C));
    }
    _Myt& replace(iterator _F1, iterator _L1,
                  _It _F2, _It _L2)
    {
        size_type _P0 = _Pdif(_F1, begin());
        size_type _M = 0;
        _Distance(_F2, _L2, _M);
        replace(_P0, _Pdif(_L1, _F1), _M, _E(0));
        for (_F1 = begin() + _P0; 0 < _M; ++_F1, ++_F2, --_M)
            *_F1 = *_F2;
        return (*this);
    }
    iterator begin()
    {
        _Freeze();
        return (_Ptr);
    }
    const_iterator begin() const
    {
        return (_Ptr);
    }
    iterator end()
    {
        _Freeze();
        return ((iterator)_Psum(_Ptr, _Len));
    }
    const_iterator end() const
    {
        return ((const_iterator)_Psum(_Ptr, _Len));
    }
    reverse_iterator rbegin()
    {
        return (reverse_iterator(end()));
    }
    const_reverse_iterator rbegin() const
    {
        return (const_reverse_iterator(end()));
    }
    reverse_iterator rend()
    {
        return (reverse_iterator(begin()));
    }
    const_reverse_iterator rend() const
    {
        return (const_reverse_iterator(begin()));
    }
    reference at(size_type _P0)
    {
        AssertH (_Len > _P0);
        //if (_Len <= _P0)
        //    _Xran();

        _Freeze();
        return (_Ptr[_P0]);
    }
    const_reference at(size_type _P0) const
    {
        AssertH (_Len > _P0);
        //if (_Len <= _P0)
        //    _Xran();

        return (_Ptr[_P0]);
    }
    reference operator[](size_type _P0)
    {
        if (_Len < _P0 || _Ptr == 0)
            return ((reference)*_Nullstr());

        _Freeze();
        return (_Ptr[_P0]);
    }
    const_reference operator[](size_type _P0) const
    {
        if (_Ptr == 0)
            return (*_Nullstr());
        else
            return (_Ptr[_P0]);
    }
    const _E *c_str() const
    {
        return (_Ptr == 0 ? _Nullstr() : _Ptr);
    }
    const _E *data() const
    {
        return (c_str());
    }
    size_type length() const
    {
        return (_Len);
    }
    size_type size() const
    {
        return (_Len);
    }
    void resize(size_type _N, _E _C)
    {
        _N <= _Len ? erase(_N) : append(_N - _Len, _C);
    }
    void resize(size_type _N)
    {
        _N <= _Len ? erase(_N) : append(_N - _Len, _E(0));
    }
    size_type capacity() const
    {
        return (_Res);
    }
    void reserve(size_type _N = 0)
    {
        if (_Res < _N)
            _Grow(_N);
    }
    bool empty() const
    {
        return (_Len == 0);
    }
    size_type copy(_E *_S, size_type _N, size_type _P0 = 0) const
    {
        AssertH (_Len >= _P0);
        //if (_Len < _P0)
        //    _Xran();

        if (_Len - _P0 < _N)
            _N = _Len - _P0;
        if (0 < _N)
            _Tr::copy(_S, _Ptr + _P0, _N);
        return (_N);
    }
    void swap(_Myt& _X)
    {
        std::swap(_Ptr, _X._Ptr);
        std::swap(_Len, _X._Len);
        std::swap(_Res, _X._Res);
    }
    void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
    size_type find(const _Myt& _X, size_type _P = 0) const
    {
        return (find(_X.c_str(), _P, _X.size()));
    }
    size_type find(const _E *_S, size_type _P,
                   size_type _N) const
    {
        if (_N == 0 && _P <= _Len)
            return (_P);
        size_type _Nm;
        if (_P < _Len && _N <= (_Nm = _Len - _P))
        {
            const _E *_U, *_V;
            for (_Nm -= _N - 1, _V = _Ptr + _P;
                (_U = _Tr::find(_V, _Nm, *_S)) != 0;
                _Nm -= (size_type)(_U - _V + 1), _V = _U + 1)
                if (_Tr::compare(_U, _S, _N) == 0)
                    return (_U - _Ptr);
        }
        return (npos);
    }
    size_type find(const _E *_S, size_type _P = 0) const
    {
        return (find(_S, _P, _Tr::length(_S)));
    }
    size_type find(_E _C, size_type _P = 0) const
    {
        return (find((const _E *)&_C, _P, 1));
    }
    size_type rfind(const _Myt& _X, size_type _P = npos) const
    {
        return (rfind(_X.c_str(), _P, _X.size()));
    }
    size_type rfind(const _E *_S, size_type _P,
                    size_type _N) const
    {
        if (_N == 0)
            return (_P < _Len ? _P : _Len);
        if (_N <= _Len)
            for (const _E *_U = _Ptr +
                 + (_P < _Len - _N ? _P : _Len - _N); ; --_U)
                if (_Tr::eq(*_U, *_S)
                    && _Tr::compare(_U, _S, _N) == 0)
                    return (_U - _Ptr);
                else if (_U == _Ptr)
                    break;
        return (npos);
    }
    size_type rfind(const _E *_S, size_type _P = npos) const
    {
        return (rfind(_S, _P, _Tr::length(_S)));
    }
    size_type rfind(_E _C, size_type _P = npos) const
    {
        return (rfind((const _E *)&_C, _P, 1));
    }
    size_type find_first_of(const _Myt& _X,
                            size_type _P = 0) const
    {
        return (find_first_of(_X.c_str(), _P, _X.size()));
    }
    size_type find_first_of(const _E *_S, size_type _P,
                            size_type _N) const
    {
        if (0 < _N && _P < _Len)
        {
            const _E *const _V = _Ptr + _Len;
            for (const _E *_U = _Ptr + _P; _U < _V; ++_U)
                if (_Tr::find(_S, _N, *_U) != 0)
                    return (_U - _Ptr);
        }
        return (npos);
    }
    size_type find_first_of(const _E *_S, size_type _P = 0) const
    {
        return (find_first_of(_S, _P, _Tr::length(_S)));
    }
    size_type find_first_of(_E _C, size_type _P = 0) const
    {
        return (find((const _E *)&_C, _P, 1));
    }
    size_type find_last_of(const _Myt& _X,
                           size_type _P = npos) const
    {
        return (find_last_of(_X.c_str(), _P, _X.size()));
    }
    size_type find_last_of(const _E *_S, size_type _P,
                           size_type _N) const
    {
        if (0 < _N && 0 < _Len)
            for (const _E *_U = _Ptr
                 + (_P < _Len ? _P : _Len - 1); ; --_U)
                if (_Tr::find(_S, _N, *_U) != 0)
                    return (_U - _Ptr);
                else if (_U == _Ptr)
                    break;
        return (npos);
    }
    size_type find_last_of(const _E *_S,
                           size_type _P = npos) const
    {
        return (find_last_of(_S, _P, _Tr::length(_S)));
    }
    size_type find_last_of(_E _C, size_type _P = npos) const
    {
        return (rfind((const _E *)&_C, _P, 1));
    }
    size_type find_first_not_of(const _Myt& _X,
                                size_type _P = 0) const
    {
        return (find_first_not_of(_X.c_str(), _P,
                                  _X.size()));
    }
    size_type find_first_not_of(const _E *_S, size_type _P,
                                size_type _N) const
    {
        if (_P < _Len)
        {
            const _E *const _V = _Ptr + _Len;
            for (const _E *_U = _Ptr + _P; _U < _V; ++_U)
                if (_Tr::find(_S, _N, *_U) == 0)
                    return (_U - _Ptr);
        }
        return (npos);
    }
    size_type find_first_not_of(const _E *_S,
                                size_type _P = 0) const
    {
        return (find_first_not_of(_S, _P, _Tr::length(_S)));
    }
    size_type find_first_not_of(_E _C, size_type _P = 0) const
    {
        return (find_first_not_of((const _E *)&_C, _P, 1));
    }
    size_type find_last_not_of(const _Myt& _X,
                               size_type _P = npos) const
    {
        return (find_last_not_of(_X.c_str(), _P, _X.size()));
    }
    size_type find_last_not_of(const _E *_S, size_type _P,
                               size_type _N) const
    {
        if (0 < _Len)
            for (const _E *_U = _Ptr
                 + (_P < _Len ? _P : _Len - 1); ; --_U)
                if (_Tr::find(_S, _N, *_U) == 0)
                    return (_U - _Ptr);
                else if (_U == _Ptr)
                    break;
        return (npos);
    }
    size_type find_last_not_of(const _E *_S,
                               size_type _P = npos) const
    {
        return (find_last_not_of(_S, _P, _Tr::length(_S)));
    }
    size_type find_last_not_of(_E _C, size_type _P = npos) const
    {
        return (find_last_not_of((const _E *)&_C, _P, 1));
    }
    _Myt substr(size_type _P = 0, size_type _M = npos) const
    {
        return (_Myt(*this, _P, _M));
    }
    int compare(const _Myt& _X) const
    {
        return (compare(0, _Len, _X.c_str(), _X.size()));
    }
    int compare(size_type _P0, size_type _N0,
                const _Myt& _X) const
    {
        return (compare(_P0, _N0, _X, 0, npos));
    }
    int compare(size_type _P0, size_type _N0, const _Myt& _X,
                size_type _P, size_type _M) const
    {
        AssertH (_X.size() >= _P);
        //if (_X.size() < _P)
        //    _Xran();

        if (_X._Len - _P < _M)
            _M = _X._Len - _P;
        return (compare(_P0, _N0, _X.c_str() + _P, _M));
    }
    int compare(const _E *_S) const
    {
        return (compare(0, _Len, _S, _Tr::length(_S)));
    }
    int compare(size_type _P0, size_type _N0, const _E *_S) const
    {
        return (compare(_P0, _N0, _S, _Tr::length(_S)));
    }
    int compare(size_type _P0, size_type _N0, const _E *_S,
                size_type _M) const
    {
        AssertH (_Len >= _P0);
        //if (_Len < _P0)
        //    _Xran();

        if (_Len - _P0 < _N0)
            _N0 = _Len - _P0;
        size_type _Ans = _Tr::compare(_Psum(_Ptr, _P0), _S,
                                      _N0 < _M ? _N0 : _M);
        return (_Ans != 0 ? _Ans : _N0 < _M ? -1
                : _N0 == _M ? 0 : +1);
    }
private:
    enum
    {
        // the number of characters that, when multiplied by sizeof(_E) will
        // still fit within the range of size_type.  (We allocate two extra
        // characters -- one for the refcount, the other for the terminator.)
        //
        _MAX_SIZE = (((unsigned int)(-1)) / sizeof(_E)) - 2,

        // _MIN_SIZE seems to be an allocation granularity (in characters).
        // Allocation requests are bit ORed with _MIN_SIZE.
        //
        _MIN_SIZE = 7,
        //_MIN_SIZE = sizeof (_E) <= 32 ? 31 : 7
    };
    void _Copy(size_type _N)
    {
        //AssertSzH (_Len <= _N, "Can't allocate less than we need to copy");
        size_type _Ns = _N | _MIN_SIZE;

        if (_MAX_SIZE < _Ns)
            _Ns = _N;

        size_type _NewLen = (_Ns < _Len) ? _Ns : _Len;

        _E *_S = (_E*) MemAllocRaiseException ((_Ns + 2) * sizeof(_E));

        //_TRY_BEGIN
        //_S = allocator.allocate(_Ns + 2, (void *)0);
        //_CATCH_ALL
        //_Ns = _N;
        //_S = allocator.allocate(_Ns + 2, (void *)0);
        //_CATCH_END

        if (_Len)
        {
            _Tr::copy(_S + 1, _Ptr, _NewLen);
        }

        _Tidy(true);
        _Ptr = _S + 1;
        _Refcnt(_Ptr) = 0;
        _Res = _Ns;
        _Eos(_NewLen);
    }
    void _Eos(size_type _N)
    {
        _Tr::assign(_Ptr[_Len = _N], _E(0));
    }
    void _Freeze()
    {
        if (_Ptr != 0
            && _Refcnt(_Ptr) != 0 && _Refcnt(_Ptr) != _FROZEN)
            _Grow(_Len);
        if (_Ptr != 0)
            _Refcnt(_Ptr) = _FROZEN;
    }
    bool _Grow(size_type _N, bool _Trim = false)
    {
        AssertH (_N < _MAX_SIZE);
        //if (_MAX_SIZE < _N)
        //    _Xlen();

        if (_Ptr != 0 && _Refcnt(_Ptr) != 0 && _Refcnt(_Ptr) != _FROZEN)
        {
            if (_N == 0)
            {
                --_Refcnt(_Ptr), _Tidy();
                return (false);
            }
            else
            {
                _Copy(_N);
                return (true);
            }
        }
        else if (_N == 0)
        {
            if (_Trim)
            {
                _Tidy(true);
            }
            else if (_Ptr != 0)
            {
                _Eos(0);
            }

            return (false);
        }
        else
        {
            if (_Trim && (_N > _Res || _Res > _MIN_SIZE))
            {
                _Tidy(true);
                _Copy(_N);
            }
            else if (!_Trim && (_N > _Res))
            {
                _Copy(_N);
            }

            return (true);
        }
    }
    static const _E * __cdecl _Nullstr()
    {
        static const _E _C = _E(0);
        return (&_C);
    }
    static size_type _Pdif(const_pointer _P2, const_pointer _P1)
    {
        return (_P2 == 0 ? 0 : _P2 - _P1);
    }
    static const_pointer _Psum(const_pointer _P, size_type _N)
    {
        return (_P == 0 ? 0 : _P + _N);
    }
    static pointer _Psum(pointer _P, size_type _N)
    {
        return (_P == 0 ? 0 : _P + _N);
    }
    unsigned short& _Refcnt(const _E *_U)
    {
        return (((unsigned short *)_U)[-1]);
    }
    void _Split()
    {
        if (_Ptr != 0 && _Refcnt(_Ptr) != 0 && _Refcnt(_Ptr) != _FROZEN)
        {
            _E *_Temp = _Ptr;
            _Tidy(true);
            assign(_Temp);
        }
    }
    void _Tidy(bool _Built = false)
    {
        if (!_Built || _Ptr == 0)
        {
            ;
        }
        else if (_Refcnt(_Ptr) == 0 || _Refcnt(_Ptr) == _FROZEN)
        {
            MemFree(_Ptr - 1);
            //allocator.deallocate(_Ptr - 1, _Res + 2);
        }
        else
        {
            --_Refcnt(_Ptr);
        }
        _Ptr = 0, _Len = 0, _Res = 0;
    }
    _E *_Ptr;
    size_type _Len, _Res;
};



inline
CWideString __cdecl operator+(
    const CWideString& _L,
    const CWideString& _R)
{return (CWideString(_L) += _R); }

inline
CWideString __cdecl operator+(
    const CWideString::_E *_L,
    const CWideString& _R)
{return (CWideString(_L) += _R); }

inline
CWideString __cdecl operator+(
    const CWideString::_E _L,
    const CWideString& _R)
{return (CWideString(1, _L) += _R); }

inline
CWideString __cdecl operator+(
    const CWideString& _L,
    const CWideString::_E *_R)
{return (CWideString(_L) += _R); }

inline
CWideString __cdecl operator+(
    const CWideString& _L,
    const CWideString::_E _R)
{return (CWideString(_L) += _R); }

inline
bool __cdecl operator==(
    const CWideString& _L,
    const CWideString& _R)
{return (_L.compare(_R) == 0); }

inline
bool __cdecl operator==(
    const CWideString::_E * _L,
    const CWideString& _R)
{return (_R.compare(_L) == 0); }

inline
bool __cdecl operator==(
    const CWideString& _L,
    const CWideString::_E *_R)
{return (_L.compare(_R) == 0); }

inline
bool __cdecl operator!=(
    const CWideString& _L,
    const CWideString& _R)
{return (!(_L == _R)); }

inline
bool __cdecl operator!=(
    const CWideString::_E *_L,
    const CWideString& _R)
{return (!(_L == _R)); }

inline
bool __cdecl operator!=(
    const CWideString& _L,
    const CWideString::_E *_R)
{return (!(_L == _R)); }

inline
bool __cdecl operator<(
    const CWideString& _L,
    const CWideString& _R)
{return (_L.compare(_R) < 0); }

inline
bool __cdecl operator<(
    const CWideString::_E * _L,
    const CWideString& _R)
{return (_R.compare(_L) > 0); }

inline
bool __cdecl operator<(
    const CWideString& _L,
    const CWideString::_E *_R)
{return (_L.compare(_R) < 0); }

inline
bool __cdecl operator>(
    const CWideString& _L,
    const CWideString& _R)
{return (_R < _L); }

inline
bool __cdecl operator>(
    const CWideString::_E * _L,
    const CWideString& _R)
{return (_R < _L); }

inline
bool __cdecl operator>(
    const CWideString& _L,
    const CWideString::_E *_R)
{return (_R < _L); }

inline
bool __cdecl operator<=(
    const CWideString& _L,
    const CWideString& _R)
{return (!(_R < _L)); }

inline
bool __cdecl operator<=(
    const CWideString::_E * _L,
    const CWideString& _R)
{return (!(_R < _L)); }

inline
bool __cdecl operator<=(
    const CWideString& _L,
    const CWideString::_E *_R)
{return (!(_R < _L)); }

inline
bool __cdecl operator>=(
    const CWideString& _L,
    const CWideString& _R)
{return (!(_L < _R)); }

inline
bool __cdecl operator>=(
    const CWideString::_E * _L,
    const CWideString& _R)
{return (!(_L < _R)); }

inline
bool __cdecl operator>=(
    const CWideString& _L,
    const CWideString::_E *_R)
{return (!(_L < _R)); }

#endif // _NCSTLSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C U I . H
//
//  Contents:   Common user interface routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCUI_H_
#define _NCUI_H_

#include "ncbase.h"

inline
HCURSOR
BeginWaitCursor ()
{
    return SetCursor(LoadCursor(NULL, IDC_WAIT));
}

inline
VOID
EndWaitCursor (
    HCURSOR hcurPrev)
{
    // BeginWaitCursor may return a NULL cursor.  This is just
    // a saftey net.
    //
    if (!hcurPrev)
    {
        hcurPrev = LoadCursor(NULL, IDC_ARROW);
    }
    SetCursor(hcurPrev);
}

// To get an automatic wait cursor, simply declare an instance
// of CWaitCursor.  The cursor will be restored when the instance is
// destroyed.  (i.e. declare it on the stack.)
//
class CWaitCursor
{
private:
    HCURSOR m_hcurPrev;

public:
    CWaitCursor  ()  { m_hcurPrev = BeginWaitCursor (); }
    ~CWaitCursor ()  { EndWaitCursor (m_hcurPrev); }
};


//
// Enables or disables a set of controls in a dialog.
//
// Use this when you're enabling/disabling more than about two controls.
// Be sure to declare the array of control ids as 'static const' if you can.
//
NOTHROW
VOID
EnableOrDisableDialogControls (
    HWND        hDlg,
    INT         ccid,
    const INT*  acid,
    BOOL fEnable);


//
// Map back and forth between a set of radio buttons and a DWORD value.
//
// Be sure to declare the array as 'static const' if you can.
//
struct RADIO_BUTTON_MAP
{
    INT     cid;        // control id of radio button
    DWORD   dwValue;    // value associated with this radio button
};

NOTHROW
BOOL
FMapRadioButtonToValue (
    HWND                    hDlg,
    INT                     crbm,
    const RADIO_BUTTON_MAP* arbm,
    DWORD*                  pdwValue);

NOTHROW
BOOL
FMapValueToRadioButton (
    HWND                    hDlg,
    INT                     crbm,
    const RADIO_BUTTON_MAP* arbm,
    DWORD                   dwValue,
    INT*                    pncid);

INT
GetIntegerFormat (
    LCID    Locale,
    PCWSTR pszValue,
    PWSTR  pszFormattedValue,
    INT     cchFormattedValue);

INT
Format32bitInteger (
    UINT32  unValue,
    BOOL    fSigned,
    PWSTR  pszFormattedValue,
    INT     cchFormattedValue);

INT
Format64bitInteger (
    UINT64   ulValue,
    BOOL     fSigned,
    PWSTR   pszFormattedValue,
    INT      cchFormattedValue);

BOOL
SetDlgItemFormatted32bitInteger (
    HWND    hDlg,
    INT     nIdDlgItem,
    UINT32  unValue,
    BOOL    fSigned);

BOOL
SetDlgItemFormatted64bitInteger (
    HWND    hDlg,
    INT     nIdDlgItem,
    UINT64  ulValue,
    BOOL    fSigned);

// dwFlags for HrNcQueryUserForRebootEx
//
// Combine both to get original behavior, or do one at a time to first prompt
// then second, actually reboot.
//
//#define QUFR_PROMPT 0x00000001
//#define QUFR_REBOOT 0x00000002

HRESULT
HrNcQueryUserForRebootEx (
    HWND        hwndParent,
    PCWSTR     pszCaption,
    PCWSTR     pszText,
    DWORD       dwFlags);

HRESULT
HrNcQueryUserForReboot (
    HINSTANCE   hinst,
    HWND        hwndParent,
    UINT        unIdCaption,
    UINT        unIdText,
    DWORD       dwFlags);

#ifdef _INC_SHELLAPI

HRESULT
HrShell_NotifyIcon (
    DWORD dwMessage,
    PNOTIFYICONDATA pData);

#endif // _INC_SHELLAPI

NOTHROW
LRESULT
LresFromHr (
    HRESULT hr);

NOTHROW
INT
WINAPIV
NcMsgBox (
    HINSTANCE   hinst,
    HWND        hwnd,
    UINT        unIdCaption,
    UINT        unIdFormat,
    UINT        unStyle,
    ...);


NOTHROW
INT
WINAPIV
NcMsgBoxWithVarCaption (
    HINSTANCE   hinst,
    HWND        hwnd,
    UINT        unIdCaption,
    PCWSTR     szCaptionParam,
    UINT        unIdFormat,
    UINT        unStyle,
    ...);

NOTHROW
INT
WINAPIV
NcMsgBoxWithWin32ErrorText (
    DWORD       dwError,
    HINSTANCE   hinst,
    HWND        hwnd,
    UINT        unIdCaption,
    UINT        unIdCombineFormat,
    UINT        unIdFormat,
    UINT        unStyle,
    ...);


VOID
SendDlgItemsMessage (
    HWND        hDlg,
    INT         ccid,
    const INT*  acid,
    UINT        unMsg,
    WPARAM      wParam,
    LPARAM      lParam);

VOID
SetDefaultButton(
    HWND hdlg,
    INT iddef);

struct CONTEXTIDMAP
{
    INT     idControl;
    DWORD   dwContextId;
    DWORD   dwContextIdJapan;
};
typedef const CONTEXTIDMAP * PCCONTEXTIDMAP;

VOID OnHelpGeneric(
    HWND hwnd,
    LPHELPINFO lphi,
    PCCONTEXTIDMAP pContextMap,
    BOOL bJpn,
    PCWSTR pszHelpFile);

#endif // _NCUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       N C U T I L . H
//
//  Contents:   CNCUtility class
//
//  Notes:
//
//  Author:     ckotze   6 July 2000
//
//---------------------------------------------------------------------------

#pragma once

class CNCUtility  
{
public:
	CNCUtility();
	virtual ~CNCUtility();

    static HRESULT StringToSid(const tstring strSid, PSID& pSid);
    static HRESULT SidToString(PCSID pSid, tstring& strSid);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncsvc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S V C . H
//
//  Contents:   This file contains CService and CServiceManager, wrapper
//              classes to the Win32 Service APIs.
//
//  Notes:      Note that not all functionality is currently extended through
//              these classes.
//
//  Author:     mikemi   6 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCSVC_H_
#define _NCSVC_H_

//  DaveA - 4/21/00 - temporary hack to get bvts to work until final
//                    solution is found. 15 seconds was not long enough
//                    for the workstation and dependent services to stop.
//                    Bug 95996. Two minute timeout will be used instead.
const DWORD c_dwDefaultWaitServiceStop = 120000;

// NTRAID9:105797@20001201#deonb REBOOT: FPS ask for reboot when installing it.
// Changing service start timeout value to 60 seconds instead of 15 seconds as FPS
// requires more time to start all it's dependent services.
const DWORD c_dwDefaultWaitServiceStart = 60000;

struct CSFLAGS
{
    // These two fields define the 'control' to be applied.  NULL both
    // to not apply a control.
    //
    BOOL    fStart;     // TRUE to start the service.  FALSE to use dwControl.
    DWORD   dwControl;  // 0 to do nothing.  SERVICE_CONTROL_ flag otherwise.

    // These two fields define the wait behavior to be applied.  NULL both
    // to not apply a wait.
    //
    DWORD   dwMaxWaitMilliseconds;  // How long to wait in milliseconds.
                                    // Zero to not wait.
    DWORD   dwStateToWaitFor;       // Service state flag like SERVICE_STOPPED

    // If TRUE, ignore services that are demand start or disabled.
    //
    BOOL    fIgnoreDisabledAndDemandStart;
};

HRESULT
HrSvcQueryStatus (
    PCWSTR pszService,
    DWORD*  pdwState);

HRESULT
HrQueryServiceConfigWithAlloc (
    SC_HANDLE               hService,
    LPQUERY_SERVICE_CONFIG* ppConfig);

HRESULT
HrChangeServiceStartType (
    PCWSTR szServiceName,
    DWORD   dwStartType);

HRESULT
HrChangeServiceStartTypeOptional (
    PCWSTR szServiceName,
    DWORD   dwStartType);


class CService
{
    friend class CServiceManager;

public:
    CService()
    {
        _schandle = NULL;
    };

    ~CService()
    {
        Close();
    };

    VOID Close();

    HRESULT HrControl           (DWORD      dwControl);

    HRESULT HrRequestStop       ();

    HRESULT HrQueryServiceConfig (LPQUERY_SERVICE_CONFIG* ppConfig)
    {
        HRESULT hr = HrQueryServiceConfigWithAlloc (_schandle, ppConfig);
        TraceError ("CService::HrQueryServiceConfig", hr);
        return hr;
    }

    HRESULT HrQueryState        ( DWORD* pdwState );
    HRESULT HrQueryStartType    ( DWORD* pdwStartType );
    HRESULT HrSetStartType      ( DWORD dwStartType )
    {
        AssertH(_schandle != NULL );

        if (::ChangeServiceConfig( _schandle,
                    SERVICE_NO_CHANGE,
                    dwStartType,
                    SERVICE_NO_CHANGE,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL))
            return S_OK;
        else
            return ::HrFromLastWin32Error();
    }

    HRESULT HrSetImagePath(IN PCWSTR pszImagePath)
    {
        AssertH(pszImagePath);
        AssertH(_schandle != NULL );

        if (::ChangeServiceConfig( _schandle,
                                   SERVICE_NO_CHANGE,  // ServiceType
                                   SERVICE_NO_CHANGE,  // StartType
                                   SERVICE_NO_CHANGE,  // ErrorControl
                                   pszImagePath,       // BinaryPathName
                                   NULL,               // LoadOredrGroup
                                   NULL,               // TagId
                                   NULL,               // Dependencies
                                   NULL,               // ServiceStartName
                                   NULL,               // Password
                                   NULL))              // DisplayName
            return S_OK;
        else
            return ::HrFromLastWin32Error();
    }

    HRESULT HrSetServiceRestartRecoveryOption(IN SERVICE_FAILURE_ACTIONS *psfa);

    HRESULT HrSetDependencies(IN PCWSTR mszDependencyList)
    {
        AssertH(_schandle != NULL );

        if (::ChangeServiceConfig( _schandle,
                                   SERVICE_NO_CHANGE,  // ServiceType
                                   SERVICE_NO_CHANGE,  // StartType
                                   SERVICE_NO_CHANGE,  // ErrorControl
                                   NULL,               // BinaryPathName
                                   NULL,               // LoadOredrGroup
                                   NULL,               // TagId
                                   mszDependencyList,  // Dependencies
                                   NULL,               // ServiceStartName
                                   NULL,               // Password
                                   NULL))              // DisplayName
            return S_OK;
        else
            return ::HrFromLastWin32Error();
    }

    HRESULT HrSetDisplayName(IN PCWSTR mszDisplayName)
    {
        AssertH(_schandle != NULL );

        if (::ChangeServiceConfig( _schandle,
                                   SERVICE_NO_CHANGE,  // ServiceType
                                   SERVICE_NO_CHANGE,  // StartType
                                   SERVICE_NO_CHANGE,  // ErrorControl
                                   NULL,               // BinaryPathName
                                   NULL,               // LoadOredrGroup
                                   NULL,               // TagId
                                   NULL,               // Dependencies
                                   NULL,               // ServiceStartName
                                   NULL,               // Password
                                   mszDisplayName))    // DisplayName
        {
            return S_OK;
        }
        else
        {
            return ::HrFromLastWin32Error();
        }
    }

    HRESULT HrSetServiceObjectSecurity(
        SECURITY_INFORMATION    dwSecurityInformation,
        PSECURITY_DESCRIPTOR    lpSecurityDescriptor)
    {
        AssertH(_schandle != NULL );

        if (::SetServiceObjectSecurity( _schandle,
                dwSecurityInformation, lpSecurityDescriptor))
        {
            return S_OK;
        }
        else
        {
            return ::HrFromLastWin32Error();
        }
    }


private:
    SC_HANDLE _schandle;
};

enum CSLOCK
{
    NO_LOCK,
    WITH_LOCK,
};

class CServiceManager
{
public:
    CServiceManager()
    {
        _schandle = NULL;
        _sclock = NULL;
    };

    ~CServiceManager();

    SC_HANDLE Handle () const
    {
        return _schandle;
    }

    HRESULT HrOpen( CSLOCK eLock = NO_LOCK,
                    DWORD dwDesiredAccess = SC_MANAGER_ALL_ACCESS,
                    PCWSTR pszMachineName = NULL,
                    PCWSTR pszDatabaseName = NULL );

    HRESULT HrControlServicesAndWait (
        UINT            cServices,
        const PCWSTR*  apszServices,
        const CSFLAGS*  pFlags);

    HRESULT HrStartServicesNoWait (UINT cServices, const PCWSTR* apszServices);
    HRESULT HrStartServicesAndWait(UINT cServices, const PCWSTR* apszServices, DWORD dwWaitMilliseconds = c_dwDefaultWaitServiceStart);
    HRESULT HrStopServicesNoWait  (UINT cServices, const PCWSTR* apszServices);
    HRESULT HrStopServicesAndWait (UINT cServices, const PCWSTR* apszServices, DWORD dwWaitMilliseconds = c_dwDefaultWaitServiceStop);

    HRESULT HrStartServiceNoWait (PCWSTR pszService)
    {
        return HrStartServicesNoWait (1, &pszService);
    }

    HRESULT HrStartServiceAndWait(PCWSTR pszService, DWORD dwWaitMilliseconds = c_dwDefaultWaitServiceStart)
    {
        return HrStartServicesAndWait (1, &pszService, dwWaitMilliseconds);
    }

    HRESULT HrStopServiceNoWait  (PCWSTR pszService)
    {
        return HrStopServicesNoWait (1, &pszService);
    }

    HRESULT HrStopServiceAndWait (PCWSTR pszService, DWORD dwWaitMilliseconds = c_dwDefaultWaitServiceStop)
    {
        return HrStopServicesAndWait (1, &pszService, dwWaitMilliseconds);
    }

    VOID Close();

    HRESULT HrLock();

    VOID Unlock();

    HRESULT HrQueryLocked (BOOL*    pfLocked);

    HRESULT HrOpenService (
                CService*   pcsService,
                PCWSTR     pszServiceName,
                CSLOCK      eLock = NO_LOCK,
                DWORD       dwScmAccess = SC_MANAGER_ALL_ACCESS,
                DWORD       dwSvcAccess = SERVICE_ALL_ACCESS);

    HRESULT HrCreateService (CService* pcsService,
            PCWSTR pszServiceName,
            PCWSTR pszDisplayName,
            DWORD dwServiceType,
            DWORD dwStartType,
            DWORD dwErrorControl,
            PCWSTR pszBinaryPathName,
            PCWSTR pslzDependencies = NULL,
            PCWSTR pszLoadOrderGroup = NULL,
            PDWORD pdwTagId = NULL,
            DWORD dwDesiredAccess = SERVICE_ALL_ACCESS,
            PCWSTR pszServiceStartName = NULL,
            PCWSTR pszPassword = NULL,
            PCWSTR pszDescription = NULL);

    enum SERVICE_START_CRITERIA
    {
        SERVICE_NO_CRITERIA,    // Start the service regardless
        SERVICE_ONLY_AUTO_START // Only start the service if it is of type
                                // Auto-Start
    };

    enum DEPENDENCY_ADDREMOVE
    {
        DEPENDENCY_ADD,
        DEPENDENCY_REMOVE
    };

    HRESULT HrAddServiceDependency(PCWSTR szServiceName, PCWSTR szDependency)
    {
        return HrAddRemoveServiceDependency(szServiceName,
                                            szDependency,
                                            DEPENDENCY_ADD);
    }

    HRESULT HrRemoveServiceDependency(PCWSTR szServiceName, PCWSTR szDependency)
    {
        return HrAddRemoveServiceDependency(szServiceName,
                                            szDependency,
                                            DEPENDENCY_REMOVE);
    }

    HRESULT HrAddRemoveServiceDependency(PCWSTR szServiceName,
                                         PCWSTR szDependency,
                                         DEPENDENCY_ADDREMOVE enumFlag);

private:
    SC_HANDLE _schandle;
    SC_LOCK   _sclock;
};

#endif // _NCSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\ncvalid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C V A L I D . H
//
//  Contents:   Generic validation functions.
//
//  Notes:
//
//  Author:     danielwe   19 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCVALID_H_
#define _NCVALID_H_


#define FBadInPtr(_p)           IsBadReadPtr(_p, sizeof(*_p))
#define FBadOutPtr(_p)          IsBadWritePtr(_p, sizeof(*_p))

#define FBadInPtrOptional(_p)   ((NULL != _p) && IsBadReadPtr(_p, sizeof(*_p)))
#define FBadOutPtrOptional(_p)  ((NULL != _p) && IsBadWritePtr(_p, sizeof(*_p)))


inline BOOL FBadInRefiid (REFIID riid)
{
    return IsBadReadPtr(&riid, sizeof(IID));
}


#endif // _NCVALID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\netsetup.h ===
#pragma once

EXTERN_C
HRESULT
WINAPI
HrGetAnswerFileParametersForNetCard(
    IN  HDEVINFO hdi,
    IN  PSP_DEVINFO_DATA pdeid,
    IN  PCWSTR pszServiceInstance,
    IN  const GUID*  pguidNetCardInstance,
    OUT PWSTR* ppszAnswerFile,
    OUT PWSTR* ppszAnswerSections);

EXTERN_C
HRESULT
WINAPI
HrOemUpgrade(
    IN HKEY hkeyDriver,
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszAnswerSections);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\nsexports.h ===
#pragma once
#include "kkstl.h"

enum EPageDisplayMode;

typedef enum EUnattendWorkTypeTag
{
    UAW_Unknown,
    UAW_NetAdapters,
    UAW_NetProtocols,
    UAW_NetClients,
    UAW_NetServices,
    UAW_NetIdentification,
    UAW_NetBindings,
    UAW_RemoveNetComponents
} EUnattendWorkType;

EXTERN_C
HRESULT
WINAPI
HrDoUnattend (
    IN HWND hwndParent,
    IN  IUnknown * punk,
    IN  EUnattendWorkType uawType,
    OUT EPageDisplayMode *ppdm,
    OUT BOOL *pfAllowChanges);

typedef
VOID
(WINAPI *ProgressMessageCallbackFn) (
    IN PCWSTR szMessage,
    va_list arglist);

EXTERN_C
VOID
WINAPI
NetSetupSetProgressCallback (
    ProgressMessageCallbackFn pfn);


typedef
VOID
(WINAPI *NetSetupSetProgressCallbackFn) (
    IN ProgressMessageCallbackFn pfn);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\notifval.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       N O T I F V A L . H
//
//  Contents:   Validation routines for the INetCfgNotify interfaces.
//
//  Notes:
//
//  Author:     shaunco     11 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NOTIFVAL_H_
#define _NOTIFVAL_H_

#include "ncvalid.h"
#include "netcfgn.h"

//+---------------------------------------------------------------------------
// INetCfgNotify
//

BOOL    FBadArgs_INetCfgNotify_Initialize(INetCfgComponent* a, INetCfg* b, BOOL c);
#define Validate_INetCfgNotify_Initialize(a, b, c) \
    if (FBadArgs_INetCfgNotify_Initialize(a, b, c)) \
        {   \
            TraceError("Validate_INetCfgNotify_Initialize", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgNotify_Initialize_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgNotify_Initialize");


BOOL    FBadArgs_INetCfgNotify_ReadAnswerFile(PCWSTR c, PCWSTR d);
#define Validate_INetCfgNotify_ReadAnswerFile(c, d) \
    if (FBadArgs_INetCfgNotify_ReadAnswerFile(c, d)) \
        {   \
            TraceError("Validate_INetCfgNotify_ReadAnswerFile", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgNotify_ReadAnswerFile_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgNotify_ReadAnswerFile");


#define Validate_INetCfgNotify_Install(a)
#define Validate_INetCfgNotify_Install_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgNotify_Install");


#define Validate_INetCfgNotify_Upgrade(a,b)
#define Validate_INetCfgNotify_Upgrade_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgNotify_Upgrade");


#define Validate_INetCfgNotify_Removing_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgNotify_Removing");


#define Validate_INetCfgNotify_Validate_Return(hr) \
    AssertSz ((S_OK == hr) || (S_FALSE == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgNotify_Validate");


#define Validate_INetCfgNotify_Cancel_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgNotify_Cancel");

#define Validate_INetCfgNotify_Apply_Return(hr) \
    AssertSz ((S_OK == hr) || (S_FALSE == hr) || (NETCFG_S_REBOOT == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgNotify_Apply");


//+---------------------------------------------------------------------------
// INetCfgProperties
//

BOOL    FBadArgs_INetCfgProperties_MergePropPages(DWORD* a, LPBYTE* b, UINT* c, HWND hwnd, PCWSTR *psz);
#define Validate_INetCfgProperties_MergePropPages(a, b, c, hwnd, psz)  \
    if (FBadArgs_INetCfgProperties_MergePropPages(a, b, c, hwnd, psz)) \
        {   \
            TraceError("Validate_INetCfgProperties_MergePropPages", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgProperties_MergePropPages_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgProperties_MergePropPages");

BOOL    FBadArgs_INetCfgProperties_ValidateProperties(HWND a);
#define Validate_INetCfgProperties_ValidateProperties(a) \
    if (FBadArgs_INetCfgProperties_ValidateProperties(a)) \
        {   \
            TraceError("Validate_INetCfgProperties_ValidateProperties", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgProperties_ValidateProperties_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgProperties_ValidateProperties");

#define Validate_INetCfgProperties_CancelProperties_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgProperties_CancelProperties");

#define Validate_INetCfgProperties_ApplyProperties_Return(hr) \
    AssertSz ((S_OK == hr) || (S_FALSE == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgProperties_ApplyProperties");


//+---------------------------------------------------------------------------
// INetCfgBindNotify
//
inline BOOL FBadNotifyFlags (DWORD a)
{
    return
        // Can't have pairs of flags at the same time that mean the opposite.
            ((a & NCN_ADD   ) && (a & NCN_REMOVE )) ||
            ((a & NCN_ENABLE) && (a & NCN_DISABLE)) ||

        // Can't remove and enable at the same time.
            ((a & NCN_REMOVE) && (a & NCN_ENABLE))  ||

        // Can't add without an enable or disable.
            ((a & NCN_ADD) && !(a & (NCN_ENABLE | NCN_DISABLE)));
}

inline BOOL FBadArgs_INetCfgBindNotify_QueryBindingPath(DWORD a, INetCfgBindingPath* b)
{
    return FBadNotifyFlags(a) || FBadInPtr(b);
}
#define Validate_INetCfgBindNotify_QueryBindingPath(a, b) \
    if (FBadArgs_INetCfgBindNotify_QueryBindingPath(a, b)) \
        {   \
            TraceError("Validate_INetCfgBindNotify_QueryBindingPath", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgBindNotify_QueryBindingPath_Return(hr) \
    AssertSz ((S_OK == hr) || (NETCFG_S_DISABLE_QUERY == hr) || (NETCFG_S_VETO_QUERY == hr) || FAILED(hr), "Invalid HRESULT returned from Validate_INetCfgBindNotify_QueryBindingPath");


inline BOOL FBadArgs_INetCfgBindNotify_NotifyBindingPath(DWORD a, INetCfgBindingPath* b)
{
    return FBadNotifyFlags(a) || FBadInPtr(b);
}
#define Validate_INetCfgBindNotify_NotifyBindingPath(a, b) \
    if (FBadArgs_INetCfgBindNotify_NotifyBindingPath(a, b)) \
        {   \
            TraceError("Validate_INetCfgBindNotify_NotifyBindingPath", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgBindNotify_NotifyBindingPath_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from Validate_INetCfgBindNotify_NotifyBindingPath");


//+---------------------------------------------------------------------------
// INetCfgSystemNotify
//

BOOL    FBadArgs_INetCfgSystemNotify_GetSupportedNotifications(DWORD* a);
#define Validate_INetCfgSystemNotify_GetSupportedNotifications(a) \
    if (FBadArgs_INetCfgSystemNotify_GetSupportedNotifications(a)) \
        {   \
            TraceError("Validate_INetCfgSystemNotify_GetSupportedNotifications", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgSystemNotify_GetSupportedNotifications_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from Validate_INetCfgSystemNotify_GetSupportedNotifications");


inline BOOL FBadArgs_INetCfgSystemNotify_SysQueryBindingPath(DWORD a, INetCfgBindingPath* b)
{
    return FBadNotifyFlags(a) || FBadInPtr(b);
}
#define Validate_INetCfgSystemNotify_SysQueryBindingPath(a, b) \
    if (FBadArgs_INetCfgSystemNotify_SysQueryBindingPath(a, b)) \
        {   \
            TraceError("Validate_INetCfgSystemNotify_SysQueryBindingPath", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgSystemNotify_SysQueryBindingPath_Return(hr) \
    AssertSz ((S_OK == hr) || (NETCFG_S_DISABLE_QUERY == hr) || (NETCFG_S_VETO_QUERY == hr) || FAILED(hr), "Invalid HRESULT returned from Validate_INetCfgSystemNotify_SysQueryBindingPath");


inline BOOL FBadArgs_INetCfgSystemNotify_SysQueryComponent(DWORD a, INetCfgComponent* b)
{
    return FBadInPtr(b);
}
#define Validate_INetCfgSystemNotify_SysQueryComponent(a, b) \
    if (FBadArgs_INetCfgSystemNotify_SysQueryComponent(a, b)) \
        {   \
            TraceError("Validate_INetCfgSystemNotify_SysQueryComponent", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgSystemNotify_SysQueryComponent_Return(hr) \
    AssertSz ((S_OK == hr) || (NETCFG_S_VETO_QUERY == hr) || FAILED(hr), "Invalid HRESULT returned from Validate_INetCfgSystemNotify_SysQueryComponent");


inline BOOL FBadArgs_INetCfgSystemNotify_SysNotifyBindingPath(DWORD a, INetCfgBindingPath* b)
{
    return FBadNotifyFlags(a) || FBadInPtr(b);
}
#define Validate_INetCfgSystemNotify_SysNotifyBindingPath(a, b) \
    if (FBadArgs_INetCfgSystemNotify_SysNotifyBindingPath(a, b)) \
        {   \
            TraceError("Validate_INetCfgSystemNotify_SysNotifyBindingPath", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgSystemNotify_SysNotifyBindingPath_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from Validate_INetCfgSystemNotify_SysNotifyBindingPath");


inline BOOL FBadArgs_INetCfgSystemNotify_SysNotifyComponent(DWORD a, INetCfgComponent* b)
{
    return FBadInPtr(b);
}
#define Validate_INetCfgSystemNotify_SysNotifyComponent(a, b) \
    if (FBadArgs_INetCfgSystemNotify_SysNotifyComponent(a, b)) \
        {   \
            TraceError("Validate_INetCfgSystemNotify_SysNotifyComponent", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgSystemNotify_SysNotifyComponent_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from Validate_INetCfgSystemNotify_SysNotifyComponent");


// ISupportErrorInfo

inline BOOL FBadArgs_ISupportErrorInfo_InterfaceSupportsErrorInfo(REFIID a)
{
    return FBadInRefiid(a);
}
#define Validate_ISupportErrorInfo_InterfaceSupportsErrorInfo(a) \
    if (FBadArgs_ISupportErrorInfo_InterfaceSupportsErrorInfo(a)) \
        {   \
            TraceError("Validate_ISupportErrorInfo_InterfaceSupportsErrorInfo", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_ISupportErrorInfo_InterfaceSupportsErrorInfo_Return(hr) \
    AssertSz ((S_OK == hr) || (S_FALSE == hr) || FAILED(hr), "Invalid HRESULT returned from Validate_ISupportErrorInfo_InterfaceSupportsErrorInfo");


#endif // _NOTIFVAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\regkyexp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       R E G K Y E X P . H
//
//  Contents:   CRegKeyExplorer class
//
//  Notes:
//
//  Author:     ckotze   12 July 2000
//
//---------------------------------------------------------------------------

#pragma once

typedef struct tagREGKEYS
{
    HKEY hkeyRoot;
    LPCTSTR strRootKeyName;
    ACCESS_MASK amMask;
    KEY_APPLY_MASK kamMask;
    BOOL bEnumerateRelativeEntries;
    HKEY hkeyRelativeRoot;
    LPCTSTR strRelativeKey;
    ACCESS_MASK amChildMask;
    KEY_APPLY_MASK kamChildMask;
} REGKEYS;

class CRegKeyExplorer  
{
public:
	CRegKeyExplorer();
	virtual ~CRegKeyExplorer();
	HRESULT GetRegKeyList(const REGKEYS rkeBuildFrom[], DWORD dwNumEntries,  LISTREGKEYDATA& listRegKeyEntries);

protected:
  	HRESULT EnumerateKeysAndAddToList(REGKEYS rkeCurrent, LISTREGKEYDATA& listRegKeyEntries);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES
#define NETMAN

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>

#include <commdlg.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <infstr.h>
#include <regstr.h>
#include <setupapi.h>
#include <shellapi.h>
#include <shlobj.h>     // must come before shlguid.h
#include <shlguid.h>
#include <stdio.h>
#include <wchar.h>

#include "stlalgor.h"
#include "stllist.h"
#include "stlmap.h"
#include "stlset.h"
#include "stlvec.h"
using namespace std;

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\pidlutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P I D L U T I L . H 
//
//  Contents:   Various PIDL utilities
//
//  Notes:      
//
//  Author:     jeffspr   1 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once

// This avoids duplicate definitions with Shell PIDL functions
// and MUST BE DEFINED!
#define AVOID_NET_CONFIG_DUPLICATES

// #include <windows.h>
// #include <shlobj.h>

// These functions are so trivial & get called so often they should be inlined
// for ship.
//
#if DBG
LPITEMIDLIST 	ILNext(LPCITEMIDLIST pidl);
BOOL			ILIsEmpty(LPCITEMIDLIST pidl);
#else
#define ILNext(pidl) 	((LPITEMIDLIST) ((BYTE *)pidl + ((LPITEMIDLIST)pidl)->mkid.cb))
#define ILIsEmpty(pidl)	(!pidl || !((LPITEMIDLIST)pidl)->mkid.cb)
#endif

//LPITEMIDLIST 	ILGetNext(LPCITEMIDLIST pidl);
//UINT 			ILGetSize(LPCITEMIDLIST pidl);
LPITEMIDLIST 	ILCreate(DWORD dwSize);
VOID            FreeIDL(LPITEMIDLIST pidl);
int				ILCompare(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
BOOL			ILIsSingleID(LPCITEMIDLIST pidl);
UINT			ILGetCID(LPCITEMIDLIST pidl);
UINT 			ILGetSizeCID(LPCITEMIDLIST pidl, UINT cid);
LPITEMIDLIST 	CloneIDLFirstCID(LPCITEMIDLIST pidl, UINT cid);
LPITEMIDLIST 	ILSkipCID(LPCITEMIDLIST pid, UINT cid);
BOOL			ILIsDesktopID(LPCITEMIDLIST pidl);

//LPITEMIDLIST    ILFindLastID(LPCITEMIDLIST pidl);
//LPITEMIDLIST    ILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
BOOL            ILIsEqual(LPITEMIDLIST pidl1, LPITEMIDLIST pidl2);
//BOOL            ILRemoveLastID(LPITEMIDLIST pidl);

LPITEMIDLIST    CloneIDL(LPCITEMIDLIST pidl);

#ifdef PCONFOLDENTRY_DEFINED

HRESULT HrCloneRgIDL(
    const PCONFOLDPIDLVEC& rgpidl,
    BOOL            fFromCache,
    BOOL            fAllowNonCacheItems,
    PCONFOLDPIDLVEC& ppidl);
    
#endif

VOID FreeRgIDL(
    UINT            cidl,
    LPITEMIDLIST  * apidl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\regkysec.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       R E G K Y S E C . H
//
//  Contents:   CRegKeySecurity class and related data types
//
//  Notes:
//
//  Author:     ckotze   6 July 2000
//
//---------------------------------------------------------------------------

#pragma once
#include <ncstl.h>
#include <ncstlstr.h>

typedef BYTE KEY_APPLY_MASK;

const KEY_APPLY_MASK KEY_CURRENT = 1;
const KEY_APPLY_MASK KEY_CHILDREN = 2;
const KEY_APPLY_MASK KEY_ALL = KEY_CURRENT | KEY_CHILDREN;

typedef LPCVOID PCSID;

class CAccessControlEntry
{
public:
    CAccessControlEntry();
    CAccessControlEntry(const ACCESS_ALLOWED_ACE& aaAllowed);
    CAccessControlEntry(const BYTE AceType, const ACCESS_MASK amMask, const BYTE AceFlags, PCSID psidUserOrGroup);
    ~CAccessControlEntry();

    HRESULT AddToACL(PACL* pAcl, ACL_REVISION_INFORMATION AclRevisionInfo);
    BOOL HasExactRights(const ACCESS_MASK amRightsRequired) const;
    BOOL HasExactInheritFlags(BYTE AceFlags);
    DWORD GetLengthSid() const;
    BOOL IsEqualSid(PCSID psidUserOrGroup) const;

private:
    BYTE m_cAceType;
    ACCESS_MASK m_amMask;
    tstring m_strSid;
    DWORD m_dwLengthSid;
    BYTE m_cAceFlags;
};

typedef list<CAccessControlEntry> LISTACE;
typedef LISTACE::iterator ACEITER;

class CRegKeySecurity
{
public:
    CRegKeySecurity();
    ~CRegKeySecurity();

    HRESULT RegOpenKey(const HKEY hkeyRoot, LPCTSTR strKeyName);
    HRESULT RegCloseKey();
    HRESULT GetSecurityDescriptorDacl();
    HRESULT SetSecurityDescriptorDacl(PACL paclDacl, DWORD dwNumEntries);
    HRESULT BuildAndApplyACLFromList(DWORD cbAcl, ACL_REVISION_INFORMATION AclRevisionInfo);
    HRESULT GetAccessControlEntriesFromAcl();
    HRESULT GrantRightsOnRegKey(PCSID psidUserOrGroup, ACCESS_MASK amPermissionsMask, KEY_APPLY_MASK kamMask);
    HRESULT RevokeRightsOnRegKey(PCSID psidUserOrGroup, ACCESS_MASK amPermissionsMask, KEY_APPLY_MASK kamMask);
    HRESULT GetKeySecurity();
    HRESULT SetKeySecurity();

protected:
    PSECURITY_DESCRIPTOR m_psdRegKey;
    BOOL m_bDaclDefaulted;
    HKEY m_hkeyCurrent;
    PACL m_paclDacl;
    BOOL m_bHasDacl;
    PSID m_psidGroup;
    PSID m_psidOwner;
    PACL m_paclSacl;
    BOOL m_bHasSacl;
    LISTACE m_listAllAce;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stlexcep.h ===
/***
*exception - Defines class exception and related functions
*
*   Copyright (c) 1994-1997, Microsoft Corporation. All rights reserved.
*   Modified January 1996 by P.J. Plauger
*
*Purpose:
*       Defines class exception (and derived class bad_exception)
*       plus new and unexpected handler functions.
*
*       [Public]
*
****/

#ifndef _STLEXCEP_H_
#define _STLEXCEP_H_
//#include <xstddef>
//#include <eh.h>

#include <stlxstdd.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif

/*
#ifndef _CRTIMP
#ifdef  _NTSDK
// definition compatible with NT SDK
#define _CRTIMP
#else   // ndef _NTSDK
// current definition
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   // ndef _DLL
#define _CRTIMP
#endif  // _DLL
#endif  // _NTSDK
#endif  // _CRTIMP
*/

typedef const char *__exString;

class /*_CRTIMP*/ exception
{
public:
    exception();
    exception(const __exString&);
    exception(const exception&);
    exception& operator= (const exception&);
    virtual ~exception();
    virtual __exString what() const;
private:
    __exString _m_what;
    int _m_doFree;
};

_STD_BEGIN
using ::exception;

// CLASS bad_exception
class /*_CRTIMP*/ bad_exception : public exception
{
public:
    bad_exception(const char *_S = "bad exception") _THROW0()
    : exception(_S)
    {
    }
    virtual ~bad_exception() _THROW0()
    {
    }
protected:
    virtual void _Doraise() const
    {
        _RAISE(*this);
    }
};

/*_CRTIMP*/
bool __cdecl uncaught_exception();

_STD_END

#ifdef __RTTI_OLDNAMES
typedef exception xmsg;        // A synonym for folks using older standard
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLEXCEP_H_ */

/*
 * 1994-1995, Microsoft Corporation. All rights reserved.
 * Modified January 1996 by P.J. Plauger
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stlalgor.h ===
#pragma once
#ifndef _STLALGOR_H_
#define _STLALGOR_H_
//#include <iterator>
//#include <memory>
//#include <xutility>

#include <stliter.h>
#include <stlmem.h>
#include <stlxutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

const int _CHUNK_SIZE = 7;
const int _SORT_MAX = 16;
// TEMPLATE FUNCTION _Median
template<class _Ty> inline
_Ty _Median(_Ty _X, _Ty _Y, _Ty _Z)
{
    if (_X < _Y)
        return (_Y < _Z ? _Y : _X < _Z ? _Z : _X);
    else
        return (_X < _Z ? _X : _Y < _Z ? _Z : _Y);
}
// TEMPLATE FUNCTION _Median WITH PRED
template<class _Ty, class _Pr> inline
_Ty _Median(_Ty _X, _Ty _Y, _Ty _Z, _Pr _P)
{
    if (_P(_X, _Y))
        return (_P(_Y, _Z) ? _Y : _P(_X, _Z) ? _Z : _X);
    else
        return (_P(_X, _Z) ? _X : _P(_Y, _Z) ? _Z : _Y);
}
// TEMPLATE FUNCTION for_each
template<class _II, class _Fn> inline
_Fn for_each(_II _F, _II _L, _Fn _Op)
{
    for (; _F != _L; ++_F)
        _Op(*_F);
    return (_Op);
}
// TEMPLATE FUNCTION find
template<class _II, class _Ty> inline
_II find(_II _F, _II _L, const _Ty& _V)
{
    for (; _F != _L; ++_F)
        if (*_F == _V)
            break;
    return (_F);
}
// TEMPLATE FUNCTION find_if
template<class _II, class _Pr> inline
_II find_if(_II _F, _II _L, _Pr _P)
{
    for (; _F != _L; ++_F)
        if (_P(*_F))
            break;
    return (_F);
}
// TEMPLATE FUNCTION adjacent_find
template<class _FI> inline
_FI adjacent_find(_FI _F, _FI _L)
{
    for (_FI _Fb; (_Fb = _F) != _L && ++_F != _L; )
        if (*_Fb == *_F)
            return (_Fb);
    return (_L);
}
// TEMPLATE FUNCTION adjacent_find WITH PRED
template<class _FI, class _Pr> inline
_FI adjacent_find(_FI _F, _FI _L, _Pr _P)
{
    for (_FI _Fb; (_Fb = _F) != _L && ++_F != _L; )
        if (_P(*_Fb, *_F))
            return (_Fb);
    return (_L);
}
// TEMPLATE FUNCTION count
template<class _II, class _Ty> inline
_CNTSIZ(_II) count(_II _F, _II _L, const _Ty& _V)
{
    _CNTSIZ(_II) _N = 0;
    for (; _F != _L; ++_F)
        if (*_F == _V)
            ++_N;
    return (_N);
}
// TEMPLATE FUNCTION count_if
template<class _II, class _Pr> inline
_CNTSIZ(_II) count_if(_II _F, _II _L, _Pr _P)
{
    _CNTSIZ(_II) _N = 0;
    for (; _F != _L; ++_F)
        if (_P(*_F))
            ++_N;
    return (_N);
}
// TEMPLATE FUNCTION search
template<class _FI1, class _FI2> inline
_FI1 search(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2)
{
    return (_Search(_F1, _L1, _F2, _L2,
                    _Dist_type(_F1), _Dist_type(_F2)));
}
template<class _FI1, class _FI2, class _Pd1, class _Pd2> inline
_FI1 _Search(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2,
             _Pd1 *, _Pd2 *)
{
    _Pd1 _D1 = 0;
    _Distance(_F1, _L1, _D1);
    _Pd2 _D2 = 0;
    _Distance(_F2, _L2, _D2);
    for (; _D2 <= _D1; ++_F1, --_D1)
    {
        _FI1 _X1 = _F1;
        for (_FI2 _X2 = _F2; ; ++_X1, ++_X2)
            if (_X2 == _L2)
                return (_F1);
            else if (!(*_X1 == *_X2))
                break;
    }
    return (_L1);
}
// TEMPLATE FUNCTION search WITH PRED
template<class _FI1, class _FI2, class _Pr> inline
_FI1 search(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2, _Pr _P)
{
    return (_Search(_F1, _L1, _F2, _L2, _P,
                    _Dist_type(_F1), _Dist_type(_F2)));
}
template<class _FI1, class _FI2, class _Pd1, class _Pd2,
class _Pr> inline
_FI1 _Search(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2,
             _Pr _P, _Pd1 *, _Pd2 *)
{
    _Pd1 _D1 = 0;
    _Distance(_F1, _L1, _D1);
    _Pd2 _D2 = 0;
    _Distance(_F2, _L2, _D2);
    for (; _D2 <= _D1; ++_F1, --_D1)
    {
        _FI1 _X1 = _F1;
        for (_FI2 _X2 = _F2; ; ++_X1, ++_X2)
            if (_X2 == _L2)
                return (_F1);
            else if (!_P(*_X1, *_X2))
                break;
    }
    return (_L1);
}
// TEMPLATE FUNCTION search_n
template<class _FI1, class _Pd2, class _Ty> inline
_FI1 search_n(_FI1 _F1, _FI1 _L1, _Pd2 _N, const _Ty& _V)
{
    return (_Search_n(_F1, _L1, _N, _V, _Dist_type(_F1)));
}
template<class _FI1, class _Pd2, class _Ty, class _Pd1> inline
_FI1 _Search_n(_FI1 _F1, _FI1 _L1,
               _Pd2 _N, const _Ty& _V, _Pd1 *)
{
    _Pd1 _D1 = 0;
    _Distance(_F1, _L1, _D1);
    for (; _N <= _D1; ++_F1, --_D1)
    {
        _FI1 _X1 = _F1;
        for (_Pd2 _D2 = _N; ; ++_X1, --_D2)
            if (_D2 == 0)
                return (_F1);
            else if (!(*_X1 == _V))
                break;
    }
    return (_L1);
}
// TEMPLATE FUNCTION search_n WITH PRED
template<class _FI1, class _Pd2, class _Ty, class _Pr> inline
_FI1 search_n(_FI1 _F1, _FI1 _L1,
              _Pd2 _N, const _Ty& _V, _Pr _P)
{
    return (_Search_n(_F1, _L1,
                      _N, _V, _P, _Dist_type(_F1)));
}
template<class _FI1, class _Pd2,
class _Ty, class _Pd1, class _Pr> inline
_FI1 _Search_n(_FI1 _F1, _FI1 _L1,
               _Pd2 _N, const _Ty& _V, _Pr _P, _Pd1 *)
{
    _Pd1 _D1 = 0;
    _Distance(_F1, _L1, _D1);
    for (; _N <= _D1; ++_F1, --_D1)
    {
        _FI1 _X1 = _F1;
        for (_Pd2 _D2 = _N; ; ++_X1, --_D2)
            if (_D2 == 0)
                return (_F1);
            else if (!_P(*_X1, _V))
                break;
    }
    return (_L1);
}
// TEMPLATE FUNCTION find_end
template<class _FI1, class _FI2> inline
_FI1 find_end(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2)
{
    return (_Find_end(_F1, _L1, _F2, _L2,
                      _Dist_type(_F1), _Dist_type(_F2)));
}
template<class _FI1, class _FI2, class _Pd1, class _Pd2> inline
_FI1 _Find_end(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2,
               _Pd1 *, _Pd2 *)
{
    _Pd1 _D1 = 0;
    _Distance(_F1, _L1, _D1);
    _Pd2 _D2 = 0;
    _Distance(_F2, _L2, _D2);
    _FI1 _Ans = _L1;
    if (0 < _D2)
        for (; _D2 <= _D1; ++_F1, --_D1)
        {
            _FI1 _X1 = _F1;
            for (_FI2 _X2 = _F2; ; ++_X1)
                if (!(*_X1 == *_X2))
                    break;
                else if (++_X2 == _L2)
                {
                    _Ans = _F1;
                    break;
                }
        }
    return (_Ans);
}
// TEMPLATE FUNCTION find_end WITH PRED
template<class _FI1, class _FI2, class _Pr> inline
_FI1 find_end(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2, _Pr _P)
{
    return (_Find_end(_F1, _L1, _F2, _L2, _P,
                      _Dist_type(_F1), _Dist_type(_F2)));
}
template<class _FI1, class _FI2, class _Pd1, class _Pd2,
class _Pr> inline
_FI1 _Find_end(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2, _Pr _P,
               _Pd1 *, _Pd2 *)
{
    _Pd1 _D1 = 0;
    _Distance(_F1, _L1, _D1);
    _Pd2 _D2 = 0;
    _Distance(_F2, _L2, _D2);
    _FI1 _Ans = _L1;
    if (0 < _D2)
        for (; _D2 <= _D1; ++_F1, --_D1)
        {
            _FI1 _X1 = _F1;
            for (_FI2 _X2 = _F2; ; ++_X1)
                if (!_P(*_X1, *_X2))
                    break;
                else if (++_X2 == _L2)
                {
                    _Ans = _F1;
                    break;
                }
        }
    return (_Ans);
}
// TEMPLATE FUNCTION find_first_of
template<class _FI1, class _FI2> inline
_FI1 find_first_of(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2)
{
    for (; _F1 != _L1; ++_F1)
        for (_FI2 _X2 = _F2; _X2 != _L2; ++_X2)
            if (*_F1 == *_X2)
                return (_F1);
    return (_F1);
}
// TEMPLATE FUNCTION find_first_of WITH PRED
template<class _FI1, class _FI2, class _Pr> inline
_FI1 find_first_of(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2,
                   _Pr _P)
{
    for (; _F1 != _L1; ++_F1)
        for (_FI2 _X2 = _F2; _X2 != _L2; ++_X2)
            if (_P(*_F1, *_X2))
                return (_F1);
    return (_F1);
}
// TEMPLATE FUNCTION iter_swap
template<class _FI1, class _FI2> inline
void iter_swap(_FI1 _X, _FI2 _Y)
{
    _Iter_swap(_X, _Y, _Val_type(_X));
}
template<class _FI1, class _FI2, class _Ty> inline
void _Iter_swap(_FI1 _X, _FI2 _Y, _Ty *)
{
    _Ty _Tmp = *_X;
    *_X = *_Y, *_Y = _Tmp;
}
// TEMPLATE FUNCTION swap_ranges
template<class _FI1, class _FI2> inline
_FI2 swap_ranges(_FI1 _F, _FI1 _L, _FI2 _X)
{
    for (; _F != _L; ++_F, ++_X)
        iter_swap(_F, _X);
    return (_X);
}
// TEMPLATE FUNCTION transform WITH UNARY OP
template<class _II, class _OI, class _Uop> inline
_OI transform(_II _F, _II _L, _OI _X, _Uop _U)
{
    for (; _F != _L; ++_F, ++_X)
        *_X = _U(*_F);
    return (_X);
}
// TEMPLATE FUNCTION transform WITH BINARY OP
template<class _II1, class _II2, class _OI, class _Bop> inline
_OI transform(_II1 _F1, _II1 _L1, _II2 _F2, _OI _X, _Bop _B)
{
    for (; _F1 != _L1; ++_F1, ++_F2, ++_X)
        *_X = _B(*_F1, *_F2);
    return (_X);
}
// TEMPLATE FUNCTION replace
template<class _FI, class _Ty> inline
void replace(_FI _F, _FI _L, const _Ty& _Vo, const _Ty& _Vn)
{
    for (; _F != _L; ++_F)
        if (*_F == _Vo)
            *_F = _Vn;
}
// TEMPLATE FUNCTION replace_if
template<class _FI, class _Pr, class _Ty> inline
void replace_if(_FI _F, _FI _L, _Pr _P, const _Ty& _V)
{
    for (; _F != _L; ++_F)
        if (_P(*_F))
            *_F = _V;
}
// TEMPLATE FUNCTION replace_copy
template<class _II, class _OI, class _Ty> inline
_OI replace_copy(_II _F, _II _L, _OI _X,
                 const _Ty& _Vo, const _Ty& _Vn)
{
    for (; _F != _L; ++_F, ++_X)
        *_X = *_F == _Vo ? _Vn : *_F;
    return (_X);
}
// TEMPLATE FUNCTION replace_copy_if
template<class _II, class _OI, class _Pr, class _Ty> inline
_OI replace_copy_if(_II _F, _II _L, _OI _X,
                    _Pr _P, const _Ty& _V)
{
    for (; _F != _L; ++_F, ++_X)
        *_X = _P(*_F) ? _V : *_F;
    return (_X);
}
// TEMPLATE FUNCTION generate
template<class _FI, class _Gen> inline
void generate(_FI _F, _FI _L, _Gen _G)
{
    for (; _F != _L; ++_F)
        *_F = _G();
}
// TEMPLATE FUNCTION generate_n
template<class _OI, class _Pd, class _Gen> inline
void generate_n(_OI _F, _Pd _N, _Gen _G)
{
    for (; 0 < _N; --_N, ++_F)
        *_F = _G();
}
// TEMPLATE FUNCTION remove
template<class _FI, class _Ty> inline
_FI remove(_FI _F, _FI _L, const _Ty& _V)
{
    _F = find(_F, _L, _V);
    if (_F == _L)
        return (_F);
    else
    {
        _FI _Fb = _F;
        return (remove_copy(++_F, _L, _Fb, _V));
    }
}
// TEMPLATE FUNCTION remove_if
template<class _FI, class _Pr> inline
_FI remove_if(_FI _F, _FI _L, _Pr _P)
{
    _F = find_if(_F, _L, _P);
    if (_F == _L)
        return (_F);
    else
    {
        _FI _Fb = _F;
        return (remove_copy_if(++_F, _L, _Fb, _P));
    }
}
// TEMPLATE FUNCTION remove_copy
template<class _II, class _OI, class _Ty> inline
_OI remove_copy(_II _F, _II _L, _OI _X, const _Ty& _V)
{
    for (; _F != _L; ++_F)
        if (!(*_F == _V))
            *_X++ = *_F;
    return (_X);
}
// TEMPLATE FUNCTION remove_copy_if
template<class _II, class _OI, class _Pr> inline
_OI remove_copy_if(_II _F, _II _L, _OI _X, _Pr _P)
{
    for (; _F != _L; ++_F)
        if (!_P(*_F))
            *_X++ = *_F;
    return (_X);
}
// TEMPLATE FUNCTION unique
template<class _FI> inline
_FI unique(_FI _F, _FI _L)
{
    _F = adjacent_find(_F, _L);
    return (unique_copy(_F, _L, _F));
}
// TEMPLATE FUNCTION unique WITH PRED
template<class _FI, class _Pr> inline
_FI unique(_FI _F, _FI _L, _Pr _P)
{
    _F = adjacent_find(_F, _L, _P);
    return (unique_copy(_F, _L, _F, _P));
}
// TEMPLATE FUNCTION unique_copy
template<class _II, class _OI> inline
_OI unique_copy(_II _F, _II _L, _OI _X)
{
    return (_F == _L ? _X :
            _Unique_copy(_F, _L, _X, _Iter_cat(_F)));
}
template<class _II, class _OI> inline
_OI _Unique_copy(_II _F, _II _L, _OI _X, input_iterator_tag)
{
    return (_Unique_copy(_F, _L, _X, _Val_type(_F)));
}
template<class _II, class _OI, class _Ty> inline
_OI _Unique_copy(_II _F, _II _L, _OI _X, _Ty *)
{
    _Ty _V = *_F;
    for (*_X++ = _V; ++_F != _L; )
        if (!(_V == *_F))
            _V = *_F, *_X++ = _V;
    return (_X);
}
template<class _FI, class _OI> inline
_OI _Unique_copy(_FI _F, _FI _L, _OI _X, forward_iterator_tag)
{
    _FI _Fb = _F;
    for (*_X++ = *_Fb; ++_F != _L; )
        if (!(*_Fb == *_F))
            _Fb = _F, *_X++ = *_Fb;
    return (_X);
}
template<class _BI, class _OI> inline
_OI _Unique_copy(_BI _F, _BI _L, _OI _X,
                 bidirectional_iterator_tag)
{
    return (_Unique_copy(_F, _L, _X, forward_iterator_tag()));
}
template<class _RI, class _OI> inline
_OI _Unique_copy(_RI _F, _RI _L, _OI _X,
                 random_access_iterator_tag)
{
    return (_Unique_copy(_F, _L, _X, forward_iterator_tag()));
}
// TEMPLATE FUNCTION unique_copy WITH PRED
template<class _II, class _OI, class _Pr> inline
_OI unique_copy(_II _F, _II _L, _OI _X, _Pr _P)
{
    return (_F == _L ? _X :
            _Unique_copy(_F, _L, _X, _P, _Iter_cat(_F)));
}
template<class _II, class _OI, class _Pr> inline
_OI _Unique_copy(_II _F, _II _L, _OI _X, _Pr _P,
                 input_iterator_tag)
{
    return (_Unique_copy(_F, _L, _X, _P, _Val_type(_F)));
}
template<class _II, class _OI, class _Ty, class _Pr> inline
_OI _Unique_copy(_II _F, _II _L, _OI _X, _Pr _P, _Ty *)
{
    _Ty _V = *_F;
    for (*_X++ = _V; ++_F != _L; )
        if (!_P(_V, *_F))
            _V = *_F, *_X++ = _V;
    return (_X);
}
template<class _FI, class _OI, class _Pr> inline
_OI _Unique_copy(_FI _F, _FI _L, _OI _X, _Pr _P,
                 forward_iterator_tag)
{
    _FI _Fb = _F;
    for (*_X++ = *_Fb; ++_F != _L; )
        if (!_P(*_Fb, *_F))
            _Fb = _F, *_X++ = *_Fb;
    return (_X);
}
template<class _BI, class _OI, class _Pr> inline
_OI _Unique_copy(_BI _F, _BI _L, _OI _X, _Pr _P,
                 bidirectional_iterator_tag)
{
    return (_Unique_copy(_F, _L, _X, _P,
                         forward_iterator_tag()));
}
template<class _RI, class _OI, class _Pr> inline
_OI _Unique_copy(_RI _F, _RI _L, _OI _X, _Pr _P,
                 random_access_iterator_tag)
{
    return (_Unique_copy(_F, _L, _X, _P,
                         forward_iterator_tag()));
}
// TEMPLATE FUNCTION reverse
template<class _BI> inline
void reverse(_BI _F, _BI _L)
{
    _Reverse(_F, _L, _Iter_cat(_F));
}
template<class _BI> inline
void _Reverse(_BI _F, _BI _L, bidirectional_iterator_tag)
{
    for (; _F != _L && _F != --_L; ++_F)
        iter_swap(_F, _L);
}
template<class _RI> inline
void _Reverse(_RI _F, _RI _L, random_access_iterator_tag)
{
    for (; _F < _L; ++_F)
        iter_swap(_F, --_L);
}
// TEMPLATE FUNCTION reverse_copy
template<class _BI, class _OI> inline
_OI reverse_copy(_BI _F, _BI _L, _OI _X)
{
    for (; _F != _L; ++_X)
        *_X = *--_L;
    return (_X);
}
// TEMPLATE FUNCTION rotate
template<class _FI> inline
void rotate(_FI _F, _FI _M, _FI _L)
{
    if (_F != _M && _M != _L)
        _Rotate(_F, _M, _L, _Iter_cat(_F));
}
template<class _FI> inline
void _Rotate(_FI _F, _FI _M, _FI _L,
             forward_iterator_tag)
{
    for (_FI _X = _M; ; )
    {
        iter_swap(_F, _X);
        if (++_F == _M)
            if (++_X == _L)
                break;
            else
                _M = _X;
        else if (++_X == _L)
            _X = _M;
    }
}
template<class _BI> inline
void _Rotate(_BI _F, _BI _M, _BI _L,
             bidirectional_iterator_tag)
{
    reverse(_F, _M);
    reverse(_M, _L);
    reverse(_F, _L);
}
template<class _RI> inline
void _Rotate(_RI _F, _RI _M, _RI _L,
             random_access_iterator_tag)
{
    _Rotate(_F, _M, _L, _Dist_type(_F), _Val_type(_F));
}
template<class _RI, class _Pd, class _Ty> inline
void _Rotate(_RI _F, _RI _M, _RI _L, _Pd *, _Ty *)
{
    _Pd _D = _M - _F;
    _Pd _N = _L - _F;
    for (_Pd _I = _D; _I != 0; )
    {
        _Pd _J = _N % _I;
        _N = _I, _I = _J;
    }
    if (_N < _L - _F)
        for (; 0 < _N; --_N)
        {
            _RI _X = _F + _N;
            _RI _Y = _X;
            _Ty _V = *_X;
            _RI _Z = _Y + _D == _L ? _F : _Y + _D;
            while (_Z != _X)
            {
                *_Y = *_Z;
                _Y = _Z;
                _Z = _D < _L - _Z ? _Z + _D
                     : _F + (_D - (_L - _Z));
            }
            *_Y = _V;
        }
}
// TEMPLATE FUNCTION rotate_copy
template<class _FI, class _OI> inline
_OI rotate_copy(_FI _F, _FI _M, _FI _L, _OI _X)
{
    return (copy(_F, _M, copy(_M, _L, _X)));
}
// TEMPLATE FUNCTION random_shuffle
template<class _RI> inline
void random_shuffle(_RI _F, _RI _L)
{
    if (_F != _L)
        _Random_shuffle(_F, _L, _Dist_type(_F));
}
template<class _RI, class _Pd> inline
void _Random_shuffle(_RI _F, _RI _L, _Pd *)
{
    const int _RBITS = 15;
    const int _RMAX = (1U << _RBITS) - 1;
    _RI _X = _F;
    for (_Pd _D = 1; ++_X != _L; ++_D)
    {
        unsigned long _Rm = _RMAX;
        unsigned long _Rn = rand() & _RMAX;
        for (; _Rm < _D && _Rm != ~0UL;
            _Rm = _Rm << _RBITS | _RMAX)
            _Rn = _Rn << _RBITS | _RMAX;
        iter_swap(_X, _F + _Pd(_Rn % _D));
    }
}
template<class _RI, class _Pf> inline
void random_shuffle(_RI _F, _RI _L, _Pf& _R)
{
    if (_F != _L)
        _Random_shuffle(_F, _L, _R, _Dist_type(_F));
}
template<class _RI, class _Pf, class _Pd> inline
void _Random_shuffle(_RI _F, _RI _L, _Pf& _R, _Pd *)
{
    _RI _X = _F;
    for (_Pd _D = 1; ++_X != _L; ++_D)
        iter_swap(_X, _F + _Pd(_R(_D)));
}
// TEMPLATE FUNCTION partition
template<class _BI, class _Pr> inline
_BI partition(_BI _F, _BI _L, _Pr _P)
{
    for (; ; ++_F)
    {
        for (; _F != _L && _P(*_F); ++_F)
            ;
        if (_F == _L)
            break;
        for (; _F != --_L && !_P(*_L); )
            ;
        if (_F == _L)
            break;
        iter_swap(_F, _L);
    }
    return (_F);
}
// TEMPLATE FUNCTION stable_partition
template<class _FI, class _Pr> inline
_FI stable_partition(_FI _F, _FI _L, _Pr _P)
{
    return (_F == _L ? _F : _Stable_partition(_F, _L, _P,
                                              _Dist_type(_F), _Val_type(_F)));
}
template<class _FI, class _Pr, class _Pd, class _Ty> inline
_FI _Stable_partition(_FI _F, _FI _L, _Pr _P, _Pd *, _Ty *)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    _Temp_iterator<_Ty> _Xb(_N);
    return (_Stable_partition(_F, _L, _P, _N, _Xb));
}
template<class _FI, class _Pr, class _Pd, class _Ty> inline
_FI _Stable_partition(_FI _F, _FI _L, _Pr _P, _Pd _N,
                      _Temp_iterator<_Ty>& _Xb)
{
    if (_N == 1)
        return (_P(*_F) ? _L : _F);
    else if (_N <= _Xb._Maxlen())
    {
        _FI _X = _F;
        for (_Xb._Init(); _F != _L; ++_F)
            if (_P(*_F))
                *_X++ = *_F;
            else
                *_Xb++ = *_F;
        copy(_Xb._First(), _Xb._Last(), _X);
        return (_X);
    }
    else
    {
        _FI _M = _F;
        advance(_M, _N / 2);
        _FI _Lp = _Stable_partition(_F, _M, _P, _N / 2, _Xb);
        _FI _Rp = _Stable_partition(_M, _L, _P, _N - _N / 2, _Xb);
        _Pd _D1 = 0;
        _Distance(_Lp, _M, _D1);
        _Pd _D2 = 0;
        _Distance(_M, _Rp, _D2);
        return (_Buffered_rotate(_Lp, _M, _Rp, _D1, _D2, _Xb));
    }
}
// TEMPLATE FUNCTION sort
template<class _RI> inline
void sort(_RI _F, _RI _L)
{
    _Sort_0(_F, _L, _Val_type(_F));
}
template<class _RI, class _Ty> inline
void _Sort_0(_RI _F, _RI _L, _Ty *)
{
    if (_L - _F <= _SORT_MAX)
        _Insertion_sort(_F, _L);
    else
    {
        _Sort(_F, _L, (_Ty *)0);
        _Insertion_sort(_F, _F + _SORT_MAX);
        for (_F += _SORT_MAX; _F != _L; ++_F)
            _Unguarded_insert(_F, _Ty(*_F));
    }
}
template<class _RI, class _Ty> inline
void _Sort(_RI _F, _RI _L, _Ty *)
{
    for (; _SORT_MAX < _L - _F; )
    {
        _RI _M = _Unguarded_partition(_F, _L, _Median(_Ty(*_F),
                                                      _Ty(*(_F + (_L - _F) / 2)), _Ty(*(_L - 1))));
        if (_L - _M <= _M - _F)
            _Sort(_M, _L, _Val_type(_F)), _L = _M;
        else
            _Sort(_F, _M, _Val_type(_F)), _F = _M;
    }
}
template<class _RI, class _Ty> inline
_RI _Unguarded_partition(_RI _F, _RI _L, _Ty _Piv)
{
    for (; ; ++_F)
    {
        for (; *_F < _Piv; ++_F)
            ;
        for (; _Piv < *--_L; )
            ;
        if (_L <= _F)
            return (_F);
        iter_swap(_F, _L);
    }
}
template<class _RI> inline
void _Insertion_sort(_RI _F, _RI _L)
{
    _Insertion_sort_1(_F, _L, _Val_type(_F));
}
template<class _BI, class _Ty> inline
void _Insertion_sort_1(_BI _F, _BI _L, _Ty *)
{
    if (_F != _L)
        for (_BI _M = _F; ++_M != _L; )
        {
            _Ty _V = *_M;
            if (!(_V < *_F))
                _Unguarded_insert(_M, _V);
            else
            {
                copy_backward(_F, _M, _M + 1);
                *_F = _V;
            }
        }
}
template<class _BI, class _Ty> inline
void _Unguarded_insert(_BI _L, _Ty _V)
{
    for (_BI _M = _L; _V < *--_M; _L = _M)
        *_L = *_M;
    *_L = _V;
}
// TEMPLATE FUNCTION sort WITH PRED
template<class _RI, class _Pr> inline
void sort(_RI _F, _RI _L, _Pr _P)
{
    _Sort_0(_F, _L, _P, _Val_type(_F));
}
template<class _RI, class _Ty, class _Pr> inline
void _Sort_0(_RI _F, _RI _L, _Pr _P, _Ty *)
{
    if (_L - _F <= _SORT_MAX)
        _Insertion_sort(_F, _L, _P);
    else
    {
        _Sort(_F, _L, _P, (_Ty *)0);
        _Insertion_sort(_F, _F + _SORT_MAX, _P);
        for (_F += _SORT_MAX; _F != _L; ++_F)
            _Unguarded_insert(_F, _Ty(*_F), _P);
    }
}
template<class _RI, class _Ty, class _Pr> inline
void _Sort(_RI _F, _RI _L, _Pr _P, _Ty *)
{
    for (; _SORT_MAX < _L - _F; )
    {
        _RI _M = _Unguarded_partition(_F, _L, _Median(_Ty(*_F),
                                                      _Ty(*(_F + (_L - _F) / 2)), _Ty(*(_L - 1)), _P), _P);
        if (_L - _M <= _M - _F)
            _Sort(_M, _L, _P, _Val_type(_F)), _L = _M;
        else
            _Sort(_F, _M, _P, _Val_type(_F)), _F = _M;
    }
}
template<class _RI, class _Ty, class _Pr> inline
_RI _Unguarded_partition(_RI _F, _RI _L, _Ty _Piv, _Pr _P)
{
    for (; ; ++_F)
    {
        for (; _P(*_F, _Piv); ++_F)
            ;
        for (; _P(_Piv, *--_L); )
            ;
        if (_L <= _F)
            return (_F);
        iter_swap(_F, _L);
    }
}
template<class _RI, class _Pr> inline
void _Insertion_sort(_RI _F, _RI _L, _Pr _P)
{
    _Insertion_sort_1(_F, _L, _P, _Val_type(_F));
}
template<class _RI, class _Ty, class _Pr> inline
void _Insertion_sort_1(_RI _F, _RI _L, _Pr _P, _Ty *)
{
    if (_F != _L)
        for (_RI _M = _F; ++_M != _L; )
        {
            _Ty _V = *_M;
            if (!_P(_V, *_F))
                _Unguarded_insert(_M, _V, _P);
            else
            {
                copy_backward(_F, _M, _M + 1);
                *_F = _V;
            }
        }
}
template<class _RI, class _Ty, class _Pr> inline
void _Unguarded_insert(_RI _L, _Ty _V, _Pr _P)
{
    for (_RI _M = _L; _P(_V, *--_M); _L = _M)
        *_L = *_M;
    *_L = _V;
}
// TEMPLATE FUNCTION stable_sort
template<class _BI> inline
void stable_sort(_BI _F, _BI _L)
{
    if (_F != _L)
        _Stable_sort(_F, _L, _Dist_type(_F), _Val_type(_F));
}
template<class _BI, class _Pd, class _Ty> inline
void _Stable_sort(_BI _F, _BI _L, _Pd *, _Ty *)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    _Temp_iterator<_Ty> _Xb(_N);
    _Stable_sort(_F, _L, _N, _Xb);
}
template<class _BI, class _Pd, class _Ty> inline
void _Stable_sort(_BI _F, _BI _L, _Pd _N,
                  _Temp_iterator<_Ty>& _Xb)
{
    if (_N <= _SORT_MAX)
        _Insertion_sort(_F, _L);
    else
    {
        _Pd _N2 = (_N + 1) / 2;
        _BI _M = _F;
        advance(_M, _N2);
        if (_N2 <= _Xb._Maxlen())
        {
            _Buffered_merge_sort(_F, _M, _N2, _Xb);
            _Buffered_merge_sort(_M, _L, _N - _N2, _Xb);
        }
        else
        {
            _Stable_sort(_F, _M, _N2, _Xb);
            _Stable_sort(_M, _L, _N - _N2, _Xb);
        }
        _Buffered_merge(_F, _M, _L, _N2, _N - _N2, _Xb);
    }
}
template<class _BI, class _Pd, class _Ty> inline
void _Buffered_merge_sort(_BI _F, _BI _L, _Pd _N,
                          _Temp_iterator<_Ty>& _Xb)
{
    _BI _M = _F;
    for (_Pd _I = _N; _CHUNK_SIZE <= _I; _I -= _CHUNK_SIZE)
    {
        _BI _Mn = _M;
        advance(_Mn, (int)_CHUNK_SIZE);
        _Insertion_sort(_M, _Mn);
        _M = _Mn;
    }
    _Insertion_sort(_M, _L);
    for (_Pd _D = _CHUNK_SIZE; _D < _N; _D *= 2)
    {
        _BI _Ft = _F;
        _Chunked_merge(_F, _L, _Xb._Init(), _D, _N);
        _Chunked_merge(_Xb._First(), _Xb._Last(), _Ft,
                       _D *= 2, _N);
    }
}
template<class _BI, class _OI, class _Pd> inline
void _Chunked_merge(_BI _F, _BI _L, _OI& _X, _Pd _D, _Pd _N)
{
    _Pd _D2 = _D * 2;
    for (; _D2 <= _N; _N -= _D2)
    {
        _BI _F1 = _F;
        advance(_F1, _D);
        _BI _F2 = _F1;
        advance(_F2, _D);
        _X = merge(_F, _F1, _F1, _F2, _X);
        _F = _F2;
    }
    if (_N <= _D)
        copy(_F, _L, _X);
    else
    {
        _BI _F1 = _F;
        advance(_F1, _D);
        merge(_F, _F1, _F1, _L, _X);
    }
}
// TEMPLATE FUNCTION stable_sort WITH PRED
template<class _BI, class _Pr> inline
void stable_sort(_BI _F, _BI _L, _Pr _P)
{
    if (_F != _L)
        _Stable_sort(_F, _L,
                     _Dist_type(_F), _Val_type(_F), _P);
}
template<class _BI, class _Pd, class _Ty, class _Pr> inline
void _Stable_sort(_BI _F, _BI _L, _Pd *, _Ty *, _Pr _P)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    _Temp_iterator<_Ty> _Xb(_N);
    _Stable_sort(_F, _L, _N, _Xb, _P);
}
template<class _BI, class _Pd, class _Ty, class _Pr> inline
void _Stable_sort(_BI _F, _BI _L, _Pd _N,
                  _Temp_iterator<_Ty>& _Xb, _Pr _P)
{
    if (_N <= _SORT_MAX)
        _Insertion_sort(_F, _L, _P);
    else
    {
        _Pd _N2 = (_N + 1) / 2;
        _BI _M = _F;
        advance(_M, _N2);
        if (_N2 <= _Xb._Maxlen())
        {
            _Buffered_merge_sort(_F, _M, _N2, _Xb, _P);
            _Buffered_merge_sort(_M, _L, _N - _N2, _Xb, _P);
        }
        else
        {
            _Stable_sort(_F, _M, _N2, _Xb, _P);
            _Stable_sort(_M, _L, _N - _N2, _Xb, _P);
        }
        _Buffered_merge(_F, _M, _L, _N2, _N - _N2, _Xb, _P);
    }
}
template<class _BI, class _Pd, class _Ty, class _Pr> inline
void _Buffered_merge_sort(_BI _F, _BI _L, _Pd _N,
                          _Temp_iterator<_Ty>& _Xb, _Pr _P)
{
    _BI _M = _F;
    for (_Pd _I = _N; _CHUNK_SIZE <= _I; _I -= _CHUNK_SIZE)
    {
        _BI _Mn = _M;
        advance(_Mn, (int)_CHUNK_SIZE);
        _Insertion_sort(_M, _Mn, _P);
        _M = _Mn;
    }
    _Insertion_sort(_M, _L, _P);
    for (_Pd _D = _CHUNK_SIZE; _D < _N; _D *= 2)
    {
        _BI _Ft = _F;
        _Chunked_merge(_F, _L, _Xb._Init(), _D, _N, _P);
        _Chunked_merge(_Xb._First(), _Xb._Last(), _Ft,
                       _D *= 2, _N, _P);
    }
}
template<class _BI, class _OI, class _Pd, class _Pr> inline
void _Chunked_merge(_BI _F, _BI _L, _OI& _X,
                    _Pd _D, _Pd _N, _Pr _P)
{
    _Pd _D2 = _D * 2;
    for (; _D2 <= _N; _N -= _D2)
    {
        _BI _F1 = _F;
        advance(_F1, _D);
        _BI _F2 = _F1;
        advance(_F2, _D);
        _X = merge(_F, _F1, _F1, _F2, _X, _P);
        _F = _F2;
    }
    if (_N <= _D)
        copy(_F, _L, _X);
    else
    {
        _BI _F1 = _F;
        advance(_F1, _D);
        merge(_F, _F1, _F1, _L, _X, _P);
    }
}
// TEMPLATE FUNCTION partial_sort
template<class _RI> inline
void partial_sort(_RI _F, _RI _M, _RI _L)
{
    _Partial_sort(_F, _M, _L, _Val_type(_F));
}
template<class _RI, class _Ty> inline
void _Partial_sort(_RI _F, _RI _M, _RI _L, _Ty *)
{
    make_heap(_F, _M);
    for (_RI _I = _M; _I < _L; ++_I)
        if (*_I < *_F)
            _Pop_heap(_F, _M, _I, _Ty(*_I), _Dist_type(_F));
    sort_heap(_F, _M);
}
// TEMPLATE FUNCTION partial_sort WITH PRED
template<class _RI, class _Pr> inline
void partial_sort(_RI _F, _RI _M, _RI _L, _Pr _P)
{
    _Partial_sort(_F, _M, _L, _P, _Val_type(_F));
}
template<class _RI, class _Ty, class _Pr> inline
void _Partial_sort(_RI _F, _RI _M, _RI _L, _Pr _P, _Ty *)
{
    make_heap(_F, _M, _P);
    for (_RI _I = _M; _I < _L; ++_I)
        if (_P(*_I, *_F))
            _Pop_heap(_F, _M, _I, _Ty(*_I), _P, _Dist_type(_F));
    sort_heap(_F, _M, _P);
}
// TEMPLATE FUNCTION partial_sort_copy
template<class _II, class _RI> inline
_RI partial_sort_copy(_II _F1, _II _L1, _RI _F2, _RI _L2)
{
    return (_Partial_sort_copy(_F1, _L1, _F2, _L2,
                               _Dist_type(_F2), _Val_type(_F1)));
}
template<class _II, class _RI, class _Pd, class _Ty> inline
_RI _Partial_sort_copy(_II _F1, _II _L1, _RI _F2, _RI _L2,
                       _Pd *, _Ty *)
{
    _RI _X = _F2;
    if (_X != _L2)
    {
        for (; _F1 != _L1 && _X != _L2; ++_F1, ++_X)
            *_X = *_F1;
        make_heap(_F2, _X);
        for (; _F1 != _L1; ++_F1)
            if (*_F1 < *_F2)
                _Adjust_heap(_F2, _Pd(0), _Pd(_X - _F2),
                             _Ty(*_F1));
        sort_heap(_F2, _X);
    }
    return (_X);
}
// TEMPLATE FUNCTION partial_sort_copy WITH PRED
template<class _II, class _RI, class _Pr> inline
_RI partial_sort_copy(_II _F1, _II _L1, _RI _F2, _RI _L2,
                      _Pr _P)
{
    return (_Partial_sort_copy(_F1, _L1, _F2, _L2, _P,
                               _Dist_type(_F2), _Val_type(_F1)));
}
template<class _II, class _RI, class _Pd,
class _Ty, class _Pr> inline
_RI _Partial_sort_copy(_II _F1, _II _L1, _RI _F2, _RI _L2,
                       _Pr _P, _Pd *, _Ty *)
{
    _RI _X = _F2;
    if (_X != _L2)
    {
        for (; _F1 != _L1 && _X != _L2; ++_F1, ++_X)
            *_X = *_F1;
        make_heap(_F2, _X, _P);
        for (; _F1 != _L1; ++_F1)
            if (_P(*_F1, *_F2))
                _Adjust_heap(_F2, _Pd(0), _Pd(_X - _F2),
                             _Ty(*_F1), _P);
        sort_heap(_F2, _X, _P);
    }
    return (_X);
}
// TEMPLATE FUNCTION nth_element
template<class _RI> inline
void nth_element(_RI _F, _RI _Nth, _RI _L)
{
    _Nth_element(_F, _Nth, _L, _Val_type(_F));
}
template<class _RI, class _Ty> inline
void _Nth_element(_RI _F, _RI _Nth, _RI _L, _Ty *)
{
    for (; _SORT_MAX < _L - _F; )
    {
        _RI _M = _Unguarded_partition(_F, _L, _Median(_Ty(*_F),
                                                      _Ty(*(_F + (_L - _F) / 2)), _Ty(*(_L - 1))));
        if (_M <= _Nth)
            _F = _M;
        else
            _L = _M;
    }
    _Insertion_sort(_F, _L);
}
// TEMPLATE FUNCTION nth_element WITH PRED
template<class _RI, class _Pr> inline
void nth_element(_RI _F, _RI _Nth, _RI _L, _Pr _P)
{
    _Nth_element(_F, _Nth, _L, _P, _Val_type(_F));
}
template<class _RI, class _Ty, class _Pr> inline
void _Nth_element(_RI _F, _RI _Nth, _RI _L, _Pr _P, _Ty *)
{
    for (; _SORT_MAX < _L - _F; )
    {
        _RI _M = _Unguarded_partition(_F, _L, _Median(_Ty(*_F),
                                                      _Ty(*(_F + (_L - _F) / 2)), _Ty(*(_L - 1)), _P), _P);
        if (_M <= _Nth)
            _F = _M;
        else
            _L = _M;
    }
    _Insertion_sort(_F, _L, _P);
}
// TEMPLATE FUNCTION lower_bound
template<class _FI, class _Ty> inline
_FI lower_bound(_FI _F, _FI _L, const _Ty& _V)
{
    return (_Lower_bound(_F, _L, _V, _Dist_type(_F)));
}
template<class _FI, class _Ty, class _Pd> inline
_FI _Lower_bound(_FI _F, _FI _L, const _Ty& _V, _Pd *)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    for (; 0 < _N; )
    {
        _Pd _N2 = _N / 2;
        _FI _M = _F;
        advance(_M, _N2);
        if (*_M < _V)
            _F = ++_M, _N -= _N2 + 1;
        else
            _N = _N2;
    }
    return (_F);
}
// TEMPLATE FUNCTION lower_bound WITH PRED
template<class _FI, class _Ty, class _Pr> inline
_FI lower_bound(_FI _F, _FI _L, const _Ty& _V, _Pr _P)
{
    return (_Lower_bound(_F, _L, _V, _P, _Dist_type(_F)));
}
template<class _FI, class _Ty, class _Pd, class _Pr> inline
_FI _Lower_bound(_FI _F, _FI _L, const _Ty& _V, _Pr _P, _Pd *)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    for (; 0 < _N; )
    {
        _Pd _N2 = _N / 2;
        _FI _M = _F;
        advance(_M, _N2);
        if (_P(*_M, _V))
            _F = ++_M, _N -= _N2 + 1;
        else
            _N = _N2;
    }
    return (_F);
}
// TEMPLATE FUNCTION upper_bound
template<class _FI, class _Ty> inline
_FI upper_bound(_FI _F, _FI _L, const _Ty& _V)
{
    return (_Upper_bound(_F, _L, _V, _Dist_type(_F)));
}
template<class _FI, class _Ty, class _Pd> inline
_FI _Upper_bound(_FI _F, _FI _L, const _Ty& _V, _Pd *)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    for (; 0 < _N; )
    {
        _Pd _N2 = _N / 2;
        _FI _M = _F;
        advance(_M, _N2);
        if (!(_V < *_M))
            _F = ++_M, _N -= _N2 + 1;
        else
            _N = _N2;
    }
    return (_F);
}
// TEMPLATE FUNCTION upper_bound WITH PRED
template<class _FI, class _Ty, class _Pr> inline
_FI upper_bound(_FI _F, _FI _L, const _Ty& _V, _Pr _P)
{
    return (_Upper_bound(_F, _L, _V, _P, _Dist_type(_F)));
}
template<class _FI, class _Ty, class _Pd, class _Pr> inline
_FI _Upper_bound(_FI _F, _FI _L, const _Ty& _V, _Pr _P, _Pd *)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    for (; 0 < _N; )
    {
        _Pd _N2 = _N / 2;
        _FI _M = _F;
        advance(_M, _N2);
        if (!_P(_V, *_M))
            _F = ++_M, _N -= _N2 + 1;
        else
            _N = _N2;
    }
    return (_F);
}
// TEMPLATE FUNCTION equal_range
template<class _FI, class _Ty> inline
pair<_FI, _FI> equal_range(_FI _F, _FI _L, const _Ty& _V)
{
    return (_Equal_range(_F, _L, _V, _Dist_type(_F)));
}
template<class _FI, class _Ty, class _Pd> inline
pair<_FI, _FI> _Equal_range(_FI _F, _FI _L,
                            const _Ty& _V, _Pd *)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    for (; 0 < _N; )
    {
        _Pd _N2 = _N / 2;
        _FI _M = _F;
        advance(_M, _N2);
        if (*_M < _V)
            _F = ++_M, _N -= _N2 + 1;
        else if (_V < *_M)
            _N = _N2;
        else
        {
            _FI _F2 = lower_bound(_F, _M, _V);
            advance(_F, _N);
            _FI _L2 = upper_bound(++_M, _F, _V);
            return (pair<_FI, _FI>(_F2, _L2));
        }
    }
    return (pair<_FI, _FI>(_F, _F));
}
// TEMPLATE FUNCTION equal_range WITH PRED
template<class _FI, class _Ty, class _Pr> inline
pair<_FI, _FI> equal_range(_FI _F, _FI _L, const _Ty& _V,
                           _Pr _P)
{
    return (_Equal_range(_F, _L, _V, _P, _Dist_type(_F)));
}
template<class _FI, class _Ty, class _Pd, class _Pr> inline
pair<_FI, _FI> _Equal_range(_FI _F, _FI _L, const _Ty& _V,
                            _Pr _P, _Pd *)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    for (; 0 < _N; )
    {
        _Pd _N2 = _N / 2;
        _FI _M = _F;
        advance(_M, _N2);
        if (_P(*_M, _V))
            _F = ++_M, _N -= _N2 + 1;
        else if (_P(_V, *_M))
            _N = _N2;
        else
        {
            _FI _F2 = lower_bound(_F, _M, _V, _P);
            advance(_F, _N);
            _FI _L2 = upper_bound(++_M, _F, _V, _P);
            return (pair<_FI, _FI>(_F2, _L2));
        }
    }
    return (pair<_FI, _FI>(_F, _F));
}
// TEMPLATE FUNCTION binary_search
template<class _FI, class _Ty> inline
bool binary_search(_FI _F, _FI _L, const _Ty& _V)
{
    _FI _I = lower_bound(_F, _L, _V);
    return (_I != _L && !(_V < *_I));
}
// TEMPLATE FUNCTION binary_search WITH PRED
template<class _FI, class _Ty, class _Pr> inline
bool binary_search(_FI _F, _FI _L, const _Ty& _V, _Pr _P)
{
    _FI _I = lower_bound(_F, _L, _V, _P);
    return (_I != _L && !_P(_V, *_I));
}
// TEMPLATE FUNCTION merge
template<class _II1, class _II2, class _OI> inline
_OI merge(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _OI _X)
{
    for (; _F1 != _L1 && _F2 != _L2; ++_X)
        if (*_F2 < *_F1)
            *_X = *_F2++;
        else
            *_X = *_F1++;
    return (copy(_F2, _L2, copy(_F1, _L1, _X)));
}
// TEMPLATE FUNCTION merge WITH PRED
template<class _II1, class _II2, class _OI, class _Pr> inline
_OI merge(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _OI _X,
          _Pr _P)
{
    for (; _F1 != _L1 && _F2 != _L2; ++_X)
        if (_P(*_F2, *_F1))
            *_X = *_F2++;
        else
            *_X = *_F1++;
    return (copy(_F2, _L2, copy(_F1, _L1, _X)));
}
// TEMPLATE FUNCTION inplace_merge
template<class _BI> inline
void inplace_merge(_BI _F, _BI _M, _BI _L)
{
    if (_F != _L)
        _Inplace_merge(_F, _M, _L,
                       _Dist_type(_F), _Val_type(_F));
}
template<class _BI, class _Pd, class _Ty> inline
void _Inplace_merge(_BI _F, _BI _M, _BI _L, _Pd *, _Ty *)
{
    _Pd _D1 = 0;
    _Distance(_F, _M, _D1);
    _Pd _D2 = 0;
    _Distance(_M, _L, _D2);
    _Temp_iterator<_Ty> _Xb(_D1 < _D2 ? _D1 : _D2);
    _Buffered_merge(_F, _M, _L, _D1, _D2, _Xb);
}
template<class _BI, class _Pd, class _Ty> inline
void _Buffered_merge(_BI _F, _BI _M, _BI _L,
                     _Pd _D1, _Pd _D2, _Temp_iterator<_Ty>& _Xb)
{
    if (_D1 == 0 || _D2 == 0)
        ;
    else if (_D1 + _D2 == 2)
    {
        if (*_M < *_F)
            iter_swap(_F, _M);
    }
    else if (_D1 <= _D2 && _D1 <= _Xb._Maxlen())
    {
        copy(_F, _M, _Xb._Init());
        merge(_Xb._First(), _Xb._Last(), _M, _L, _F);
    }
    else if (_D2 <= _Xb._Maxlen())
    {
        copy(_M, _L, _Xb._Init());
        _Merge_backward(_F, _M, _Xb._First(), _Xb._Last(), _L);
    }
    else
    {
        _BI _Fn, _Ln;
        _Pd _D1n, _D2n;
        if (_D2 < _D1)
        {
            _D1n = _D1 / 2;
            _Fn = _F;
            advance(_Fn, _D1n);
            _Ln = lower_bound(_M, _L, _Ty(*_Fn));
            _Distance(_M, _Ln, _D2n);
        }
        else
        {
            _D2n = _D2 / 2;
            _Ln = _M;
            advance(_Ln, _D2n);
            _Fn = upper_bound(_F, _M, _Ty(*_Ln));
            _Distance(_F, _Fn, _D1n);
        }
        _BI _Mn = _Buffered_rotate(_Fn, _M, _Ln,
                                   _D1 - _D1n, _D2n, _Xb);
        _Buffered_merge(_F, _Fn, _Mn, _D1n, _D2n, _Xb);
        _Buffered_merge(_Mn, _Ln, _L,
                        _D1 - _D1n, _D2 - _D2n, _Xb);
    }
}
template<class _BI1, class _BI2, class _BI3> inline
_BI3 _Merge_backward(_BI1 _F1, _BI1 _L1, _BI2 _F2, _BI2 _L2,
                     _BI3 _X)
{
    for (; ; )
        if (_F1 == _L1)
            return (copy_backward(_F2, _L2, _X));
        else if (_F2 == _L2)
            return (copy_backward(_F1, _L1, _X));
        else if (*--_L2 < *--_L1)
            *--_X = *_L1, ++_L2;
        else
            *--_X = *_L2, ++_L1;
}
template<class _BI, class _Pd, class _Ty> inline
_BI _Buffered_rotate(_BI _F, _BI _M, _BI _L,
                     _Pd _D1, _Pd _D2, _Temp_iterator<_Ty>& _Xb)
{
    if (_D1 <= _D2 && _D1 <= _Xb._Maxlen())
    {
        copy(_F, _M, _Xb._Init());
        copy(_M, _L, _F);
        return (copy_backward(_Xb._First(), _Xb._Last(), _L));
    }
    else if (_D2 <= _Xb._Maxlen())
    {
        copy(_M, _L, _Xb._Init());
        copy_backward(_F, _M, _L);
        return (copy(_Xb._First(), _Xb._Last(), _F));
    }
    else
    {
        rotate(_F, _M, _L);
        advance(_F, _D2);
        return (_F);
    }
}
// TEMPLATE FUNCTION inplace_merge WITH PRED
template<class _BI, class _Pr> inline
void inplace_merge(_BI _F, _BI _M, _BI _L, _Pr _P)
{
    if (_F != _L)
        _Inplace_merge(_F, _M, _L, _P,
                       _Dist_type(_F), _Val_type(_F));
}
template<class _BI, class _Pd, class _Ty, class _Pr> inline
void _Inplace_merge(_BI _F, _BI _M, _BI _L, _Pr _P,
                    _Pd *, _Ty *)
{
    _Pd _D1 = 0;
    _Distance(_F, _M, _D1);
    _Pd _D2 = 0;
    _Distance(_M, _L, _D2);
    _Temp_iterator<_Ty> _Xb(_D1 < _D2 ? _D1 : _D2);
    _Buffered_merge(_F, _M, _L, _D1, _D2, _Xb, _P);
}
template<class _BI, class _Pd, class _Ty, class _Pr> inline
void _Buffered_merge(_BI _F, _BI _M, _BI _L,
                     _Pd _D1, _Pd _D2, _Temp_iterator<_Ty>& _Xb, _Pr _P)
{
    if (_D1 == 0 || _D2 == 0)
        ;
    else if (_D1 + _D2 == 2)
    {
        if (_P(*_M, *_F))
            iter_swap(_F, _M);
    }
    else if (_D1 <= _D2 && _D1 <= _Xb._Maxlen())
    {
        copy(_F, _M, _Xb._Init());
        merge(_Xb._First(), _Xb._Last(), _M, _L, _F, _P);
    }
    else if (_D2 <= _Xb._Maxlen())
    {
        copy(_M, _L, _Xb._Init());
        _Merge_backward(_F, _M, _Xb._First(), _Xb._Last(),
                        _L, _P);
    }
    else
    {
        _BI _Fn, _Ln;
        _Pd _D1n, _D2n;
        if (_D2 < _D1)
        {
            _D1n = _D1 / 2;
            _Fn = _F;
            advance(_Fn, _D1n);
            _Ln = lower_bound(_M, _L, _Ty(*_Fn), _P);
            _Distance(_M, _Ln, _D2n);
        }
        else
        {
            _D2n = _D2 / 2;
            _Ln = _M;
            advance(_Ln, _D2n);
            _Fn = upper_bound(_F, _M, _Ty(*_Ln), _P);
            _Distance(_F, _Fn, _D1n);
        }
        _BI _Mn = _Buffered_rotate(_Fn, _M, _Ln,
                                   _D1 - _D1n, _D2n, _Xb);
        _Buffered_merge(_F, _Fn, _Mn, _D1n, _D2n, _Xb, _P);
        _Buffered_merge(_Mn, _Ln, _L,
                        _D1 - _D1n, _D2 - _D2n, _Xb, _P);
    }
}
template<class _BI1, class _BI2, class _BI3, class _Pr> inline
_BI3 _Merge_backward(_BI1 _F1, _BI1 _L1, _BI2 _F2, _BI2 _L2,
                     _BI3 _X, _Pr _P)
{
    for (; ; )
        if (_F1 == _L1)
            return (copy_backward(_F2, _L2, _X));
        else if (_F2 == _L2)
            return (copy_backward(_F1, _L1, _X));
        else if (_P(*--_L2, *--_L1))
            *--_X = *_L1, ++_L2;
        else
            *--_X = *_L2, ++_L1;
}
// TEMPLATE FUNCTION includes
template<class _II1, class _II2> inline
bool includes(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (*_F2 < *_F1)
            return (false);
        else if (*_F1 < *_F2)
            ++_F1;
        else
            ++_F2;
    return (_F2 == _L2);
}
// TEMPLATE FUNCTION includes WITH PRED
template<class _II1, class _II2, class _Pr> inline
bool includes(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _Pr _P)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (_P(*_F2, *_F1))
            return (false);
        else if (_P(*_F1, *_F2))
            ++_F1;
        else
            ++_F2;
    return (_F2 == _L2);
}
// TEMPLATE FUNCTION set_union
template<class _II1, class _II2, class _OI> inline
_OI set_union(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _OI _X)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (*_F1 < *_F2)
            *_X++ = *_F1++;
        else if (*_F2 < *_F1)
            *_X++ = *_F2++;
        else
            *_X++ = *_F1++, ++_F2;
    return (copy(_F2, _L2, copy(_F1, _L1, _X)));
}
// TEMPLATE FUNCTION set_union WITH PRED
template<class _II1, class _II2, class _OI, class _Pr> inline
_OI set_union(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _OI _X,
              _Pr _P)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (_P(*_F1, *_F2))
            *_X++ = *_F1++;
        else if (_P(*_F2, *_F1))
            *_X++ = *_F2++;
        else
            *_X++ = *_F1++, ++_F2;
    return (copy(_F2, _L2, copy(_F1, _L1, _X)));
}
// TEMPLATE FUNCTION set_intersection
template<class _II1, class _II2, class _OI> inline
_OI set_intersection(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2,
                     _OI _X)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (*_F1 < *_F2)
            ++_F1;
        else if (*_F2 < *_F1)
            ++_F2;
        else
            *_X++ = *_F1++, ++_F2;
    return (_X);
}
// TEMPLATE FUNCTION set_intersection WITH PRED
template<class _II1, class _II2, class _OI, class _Pr> inline
_OI set_intersection(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2,
                     _OI _X, _Pr _P)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (_P(*_F1, *_F2))
            ++_F1;
        else if (_P(*_F2, *_F1))
            ++_F2;
        else
            *_X++ = *_F1++, ++_F2;
    return (_X);
}
// TEMPLATE FUNCTION set_difference
template<class _II1, class _II2, class _OI> inline
_OI set_difference(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2,
                   _OI _X)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (*_F1 < *_F2)
            *_X++ = *_F1++;
        else if (*_F2 < *_F1)
            ++_F2;
        else
            ++_F1, ++_F2;
    return (copy(_F1, _L1, _X));
}
// TEMPLATE FUNCTION set_difference WITH PRED
template<class _II1, class _II2, class _OI, class _Pr> inline
_OI set_difference(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2,
                   _OI _X, _Pr _P)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (_P(*_F1, *_F2))
            *_X++ = *_F1++;
        else if (_P(*_F2, *_F1))
            ++_F2;
        else
            ++_F1, ++_F2;
    return (copy(_F1, _L1, _X));
}
// TEMPLATE FUNCTION set_symmetric_difference
template<class _II1, class _II2, class _OI> inline
_OI set_symmetric_difference(_II1 _F1, _II1 _L1, _II2 _F2,
                             _II2 _L2, _OI _X)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (*_F1 < *_F2)
            *_X++ = *_F1++;
        else if (*_F2 < *_F1)
            *_X++ = *_F2++;
        else
            ++_F1, ++_F2;
    return (copy(_F2, _L2, copy(_F1, _L1, _X)));
}
// TEMPLATE FUNCTION set_symmetric_difference WITH PRED
template<class _II1, class _II2, class _OI, class _Pr> inline
_OI set_symmetric_difference(_II1 _F1, _II1 _L1, _II2 _F2,
                             _II2 _L2, _OI _X, _Pr _P)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (_P(*_F1, *_F2))
            *_X++ = *_F1++;
        else if (_P(*_F2, *_F1))
            *_X++ = *_F2++;
        else
            ++_F1, ++_F2;
    return (copy(_F2, _L2, copy(_F1, _L1, _X)));
}
// TEMPLATE FUNCTION push_heap
template<class _RI> inline
void push_heap(_RI _F, _RI _L)
{
    _Push_heap_0(_F, _L, _Dist_type(_F), _Val_type(_F));
}
template<class _RI, class _Pd, class _Ty> inline
void _Push_heap_0(_RI _F, _RI _L, _Pd *, _Ty *)
{
    _Push_heap(_F, _Pd(_L - _F - 1), _Pd(0), _Ty(*(_L - 1)));
}
template<class _RI, class _Pd, class _Ty> inline
void _Push_heap(_RI _F, _Pd _H, _Pd _J, _Ty _V)
{
    for (_Pd _I = (_H - 1) / 2; _J < _H && *(_F + _I) < _V;
        _I = (_H - 1) / 2)
        *(_F + _H) = *(_F + _I), _H = _I;
    *(_F + _H) = _V;
}
// TEMPLATE FUNCTION push_heap WITH PRED
template<class _RI, class _Pr> inline
void push_heap(_RI _F, _RI _L, _Pr _P)
{
    _Push_heap_0(_F, _L, _P,
                 _Dist_type(_F), _Val_type(_F));
}
template<class _RI, class _Pd, class _Ty, class _Pr> inline
void _Push_heap_0(_RI _F, _RI _L, _Pr _P, _Pd *, _Ty *)
{
    _Push_heap(_F, _Pd(_L - _F - 1), _Pd(0),
               _Ty(*(_L - 1)), _P);
}
template<class _RI, class _Pd, class _Ty, class _Pr> inline
void _Push_heap(_RI _F, _Pd _H, _Pd _J, _Ty _V, _Pr _P)
{
    for (_Pd _I = (_H - 1) / 2; _J < _H && _P(*(_F + _I), _V);
        _I = (_H - 1) / 2)
        *(_F + _H) = *(_F + _I), _H = _I;
    *(_F + _H) = _V;
}
// TEMPLATE FUNCTION pop_heap
template<class _RI> inline
void pop_heap(_RI _F, _RI _L)
{
    _Pop_heap_0(_F, _L, _Val_type(_F));
}
template<class _RI, class _Ty> inline
void _Pop_heap_0(_RI _F, _RI _L, _Ty *)
{
    _Pop_heap(_F, _L - 1, _L - 1, _Ty(*(_L - 1)),
              _Dist_type(_F));
}
template<class _RI, class _Pd, class _Ty> inline
void _Pop_heap(_RI _F, _RI _L, _RI _X, _Ty _V, _Pd *)
{
    *_X = *_F;
    _Adjust_heap(_F, _Pd(0), _Pd(_L - _F), _V);
}
template<class _RI, class _Pd, class _Ty> inline
void _Adjust_heap(_RI _F, _Pd _H, _Pd _N, _Ty _V)
{
    _Pd _J = _H;
    _Pd _K = 2 * _H + 2;
    for (; _K < _N; _K = 2 * _K + 2)
    {
        if (*(_F + _K) < *(_F + (_K - 1)))
            --_K;
        *(_F + _H) = *(_F + _K), _H = _K;
    }
    if (_K == _N)
        *(_F + _H) = *(_F + (_K - 1)), _H = _K - 1;
    _Push_heap(_F, _H, _J, _V);
}
// TEMPLATE FUNCTION pop_heap WITH PRED
template<class _RI, class _Pr> inline
void pop_heap(_RI _F, _RI _L, _Pr _P)
{
    _Pop_heap_0(_F, _L, _P, _Val_type(_F));
}
template<class _RI, class _Ty, class _Pr> inline
void _Pop_heap_0(_RI _F, _RI _L, _Pr _P, _Ty *)
{
    _Pop_heap(_F, _L - 1, _L - 1, _Ty(*(_L - 1)), _P,
              _Dist_type(_F));
}
template<class _RI, class _Pd, class _Ty, class _Pr> inline
void _Pop_heap(_RI _F, _RI _L, _RI _X, _Ty _V, _Pr _P, _Pd *)
{
    *_X = *_F;
    _Adjust_heap(_F, _Pd(0), _Pd(_L - _F), _V, _P);
}
template<class _RI, class _Pd, class _Ty, class _Pr> inline
void _Adjust_heap(_RI _F, _Pd _H, _Pd _N, _Ty _V, _Pr _P)
{
    _Pd _J = _H;
    _Pd _K = 2 * _H + 2;
    for (; _K < _N; _K = 2 * _K + 2)
    {
        if (_P(*(_F + _K), *(_F + (_K - 1))))
            --_K;
        *(_F + _H) = *(_F + _K), _H = _K;
    }
    if (_K == _N)
        *(_F + _H) = *(_F + (_K - 1)), _H = _K - 1;
    _Push_heap(_F, _H, _J, _V, _P);
}
// TEMPLATE FUNCTION make_heap
template<class _RI> inline
void make_heap(_RI _F, _RI _L)
{
    if (2 <= _L - _F)
        _Make_heap(_F, _L, _Dist_type(_F), _Val_type(_F));
}
template<class _RI, class _Pd, class _Ty> inline
void _Make_heap(_RI _F, _RI _L, _Pd *, _Ty *)
{
    _Pd _N = _L - _F;
    for (_Pd _H = _N / 2; 0 < _H; )
        --_H, _Adjust_heap(_F, _H, _N, _Ty(*(_F + _H)));
}
// TEMPLATE FUNCTION make_heap WITH PRED
template<class _RI, class _Pr> inline
void make_heap(_RI _F, _RI _L, _Pr _P)
{
    if (2 <= _L - _F)
        _Make_heap(_F, _L, _P,
                   _Dist_type(_F), _Val_type(_F));
}
template<class _RI, class _Pd, class _Ty, class _Pr> inline
void _Make_heap(_RI _F, _RI _L, _Pr _P, _Pd *, _Ty *)
{
    _Pd _N = _L - _F;
    for (_Pd _H = _N / 2; 0 < _H; )
        --_H, _Adjust_heap(_F, _H, _N, _Ty(*(_F + _H)), _P);
}
// TEMPLATE FUNCTION sort_heap
template<class _RI> inline
void sort_heap(_RI _F, _RI _L)
{
    for (; 1 < _L - _F; --_L)
        pop_heap(_F, _L);
}
// TEMPLATE FUNCTION sort_heap WITH PRED
template<class _RI, class _Pr> inline
void sort_heap(_RI _F, _RI _L, _Pr _P)
{
    for (; 1 < _L - _F; --_L)
        pop_heap(_F, _L, _P);
}
// TEMPLATE FUNCTION max_element
template<class _FI> inline
_FI max_element(_FI _F, _FI _L)
{
    _FI _X = _F;
    if (_F != _L)
        for (; ++_F != _L; )
            if (*_X < *_F)
                _X = _F;
    return (_X);
}
// TEMPLATE FUNCTION max_element WITH PRED
template<class _FI, class _Pr> inline
_FI max_element(_FI _F, _FI _L, _Pr _P)
{
    _FI _X = _F;
    if (_F != _L)
        for (; ++_F != _L; )
            if (_P(*_X, *_F))
                _X = _F;
    return (_X);
}
// TEMPLATE FUNCTION min_element
template<class _FI> inline
_FI min_element(_FI _F, _FI _L)
{
    _FI _X = _F;
    if (_F != _L)
        for (; ++_F != _L; )
            if (*_F < *_X)
                _X = _F;
    return (_X);
}
// TEMPLATE FUNCTION min_element WITH PRED
template<class _FI, class _Pr> inline
_FI min_element(_FI _F, _FI _L, _Pr _P)
{
    _FI _X = _F;
    if (_F != _L)
        for (; ++_F != _L; )
            if (_P(*_F, *_X))
                _X = _F;
    return (_X);
}
// TEMPLATE FUNCTION next_permutation
template<class _BI> inline
bool next_permutation(_BI _F, _BI _L)
{
    _BI _I = _L;
    if (_F == _L || _F == --_I)
        return (false);
    for (; ; )
    {
        _BI _Ip = _I;
        if (*--_I < *_Ip)
        {
            _BI _J = _L;
            for (; !(*_I < *--_J); )
                ;
            iter_swap(_I, _J);
            reverse(_Ip, _L);
            return (true);
        }
        if (_I == _F)
        {
            reverse(_F, _L);
            return (false);
        }
    }
}
// TEMPLATE FUNCTION next_permutation WITH PRED
template<class _BI, class _Pr> inline
bool next_permutation(_BI _F, _BI _L, _Pr _P)
{
    _BI _I = _L;
    if (_F == _L || _F == --_I)
        return (false);
    for (; ; )
    {
        _BI _Ip = _I;
        if (_P(*--_I, *_Ip))
        {
            _BI _J = _L;
            for (; !_P(*_I, *--_J); )
                ;
            iter_swap(_I, _J);
            reverse(_Ip, _L);
            return (true);
        }
        if (_I == _F)
        {
            reverse(_F, _L);
            return (false);
        }
    }
}
// TEMPLATE FUNCTION prev_permutation
template<class _BI> inline
bool prev_permutation(_BI _F, _BI _L)
{
    _BI _I = _L;
    if (_F == _L || _F == --_I)
        return (false);
    for (; ; )
    {
        _BI _Ip = _I;
        if (!(*--_I < *_Ip))
        {
            _BI _J = _L;
            for (; *_I < *--_J; )
                ;
            iter_swap(_I, _J);
            reverse(_Ip, _L);
            return (true);
        }
        if (_I == _F)
        {
            reverse(_F, _L);
            return (false);
        }
    }
}
// TEMPLATE FUNCTION prev_permutation WITH PRED
template<class _BI, class _Pr> inline
bool prev_permutation(_BI _F, _BI _L, _Pr _P)
{
    _BI _I = _L;
    if (_F == _L || _F == --_I)
        return (false);
    for (; ; )
    {
        _BI _Ip = _I;
        if (!_P(*--_I, *_Ip))
        {
            _BI _J = _L;
            for (; _P(*_I, *--_J); )
                ;
            iter_swap(_I, _J);
            reverse(_Ip, _L);
            return (true);
        }
        if (_I == _F)
        {
            reverse(_F, _L);
            return (false);
        }
    }
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLALGOR_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stliter.h ===
#pragma once
#ifndef _STLITER_H_
#define _STLITER_H_
//#include <utility>

#include <stlutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE CLASS reverse_bidirectional_iterator
template<class _BI, class _Ty, class _Rt = _Ty&,
class _Pt = _Ty *, class _D = ptrdiff_t>
class reverse_bidirectional_iterator : public _Bidit<_Ty, _D>
{
public:
    typedef reverse_bidirectional_iterator<_BI,
    _Ty, _Rt, _Pt, _D> _Myt;
    typedef _BI iter_type;
    typedef _Rt reference_type;
    typedef _Pt pointer_type;
    reverse_bidirectional_iterator()
    {
    }
    explicit reverse_bidirectional_iterator(_BI _X) : current(_X)
    {
    }
    _BI base() const
    {
        return (current);
    }
    _Rt operator*() const
    {
        _BI _Tmp = current;
        return (*--_Tmp);
    }
    _Pt operator->() const
    {
        return (&**this);
    }
    _Myt& operator++()
    {
        --current;
        return (*this);
    }
    _Myt operator++(int)
    {
        _Myt _Tmp = *this;
        --current;
        return (_Tmp);
    }
    _Myt& operator--()
    {
        ++current;
        return (*this);
    }
    _Myt operator--(int)
    {
        _Myt _Tmp = *this;
        ++current;
        return (_Tmp);
    }
protected:
    _BI current;
};
template<class _BI, class _Ty, class _Rt, class _Pt,
class _D> inline
bool operator==(const reverse_bidirectional_iterator<_BI,
                _Ty, _Rt, _Pt, _D>& _X,
                const reverse_bidirectional_iterator<_BI,
                _Ty, _Rt, _Pt, _D>& _Y)
{
    return (_X.base() == _Y.base());
}
template<class _BI, class _Ty, class _Rt, class _Pt, class _D> inline
bool operator!=(const reverse_bidirectional_iterator<_BI,
                _Ty, _Rt, _Pt, _D>& _X,
                const reverse_bidirectional_iterator<_BI,
                _Ty, _Rt, _Pt, _D>& _Y)
{
    return (!(_X == _Y));
}

// TEMPLATE CLASS back_insert_iterator
template<class _C>
class back_insert_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _C container_type;
    typedef _C::value_type value_type;
    explicit back_insert_iterator(_C& _X) : container(_X)
    {
    }
    back_insert_iterator<_C>& operator=(const value_type& _V)
    {
        container.push_back(_V);
        return (*this);
    }
    back_insert_iterator<_C>& operator*()
    {
        return (*this);
    }
    back_insert_iterator<_C>& operator++()
    {
        return (*this);
    }
    back_insert_iterator<_C> operator++(int)
    {
        return (*this);
    }protected:
    _C& container;
};
template<class _C> inline
back_insert_iterator<_C> back_inserter(_C& _X)
{
    return (back_insert_iterator<_C>(_X));
}

// TEMPLATE CLASS front_insert_iterator
template<class _C>
class front_insert_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _C container_type;
    typedef _C::value_type value_type;
    explicit front_insert_iterator(_C& _X) : container(_X)
    {
    }
    front_insert_iterator<_C>& operator=(
                                        const value_type& _V)
    {
        container.push_front(_V);
        return (*this);
    }
    front_insert_iterator<_C>& operator*()
    {
        return (*this);
    }
    front_insert_iterator<_C>& operator++()
    {
        return (*this);
    }
    front_insert_iterator<_C> operator++(int)
    {
        return (*this);
    }
protected:
    _C& container;
};

template<class _C> inline
front_insert_iterator<_C> front_inserter(_C& _X)
{
    return (front_insert_iterator<_C>(_X));
}

// TEMPLATE CLASS insert_iterator
template<class _C>
class insert_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _C container_type;
    typedef _C::value_type value_type;
    insert_iterator(_C& _X, _C::iterator _I) : container(_X), iter(_I)
    {
    }
    insert_iterator<_C>& operator=(
                                  const value_type& _V)
    {
        iter = container.insert(iter, _V);
        ++iter;
        return (*this);
    }
    insert_iterator<_C>& operator*()
    {
        return (*this);
    }
    insert_iterator<_C>& operator++()
    {
        return (*this);
    }
    insert_iterator<_C>& operator++(int)
    {
        return (*this);
    }
protected:
    _C& container;
    _C::iterator iter;
};

template<class _C, class _XI> inline
insert_iterator<_C> inserter(_C& _X, _XI _I)
{
    return (insert_iterator<_C>(_X, _C::iterator(_I)));
}

/*
// TEMPLATE CLASS istream_iterator
template<class _U, class _E = char, class _Tr = char_traits<_E> >
class istream_iterator : public iterator<input_iterator_tag, _U, ptrdiff_t>
{
public:
    typedef _E char_type;
    typedef _Tr traits_type;
    typedef basic_istream<_E, _Tr> istream_type;
    istream_iterator() : _Istr(0)
    {
    }
    istream_iterator(istream_type& _I) : _Istr(&_I)
    {
        _Getval();
    }
    const _U& operator*() const
    {
        return (_Val);
    }
    const _U *operator->() const
    {
        return (&**this);
    }
    istream_iterator<_U, _E, _Tr>& operator++()
    {
        _Getval();
        return (*this);
    }
    istream_iterator<_U, _E, _Tr> operator++(int)
    {
        istream_iterator<_U, _E, _Tr> _Tmp = *this;
        _Getval();
        return (_Tmp);
    }
    bool _Equal(const istream_iterator<_U, _E, _Tr>& _X) const
    {
        return (_Istr == _X._Istr);
    }
protected:
    void _Getval()
    {
        if (_Istr != 0 && !(*_Istr >> _Val))
            _Istr = 0;
    }
    istream_type *_Istr;
    _U _Val;
};
template<class _U, class _E, class _Tr> inline
bool operator==(const istream_iterator<_U, _E, _Tr>& _X,
                const istream_iterator<_U, _E, _Tr>& _Y)
{
    return (_X._Equal(_Y));
}
template<class _U, class _E, class _Tr> inline
bool operator!=(const istream_iterator<_U, _E, _Tr>& _X,
                const istream_iterator<_U, _E, _Tr>& _Y)
{
    return (!(_X == _Y));
}
// TEMPLATE CLASS ostream_iterator
template<class _U, class _E = char,
class _Tr = char_traits<_E> >
class ostream_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _U value_type;
    typedef _E char_type;
    typedef _Tr traits_type;
    typedef basic_ostream<_E, _Tr> ostream_type;
    ostream_iterator(ostream_type& _O,
                     const _E *_D = 0) : _Ostr(&_O), _Delim(_D)
    {
    }
    ostream_iterator<_U, _E, _Tr>& operator=(const _U& _X)
    {
        *_Ostr << _X;
        if (_Delim != 0)
            *_Ostr << _Delim;
        return (*this);
    }
    ostream_iterator<_U, _E, _Tr>& operator*()
    {
        return (*this);
    }
    ostream_iterator<_U, _E, _Tr>& operator++()
    {
        return (*this);
    }
    ostream_iterator<_U, _E, _Tr> operator++(int)
    {
        return (*this);
    }
protected:
    const _E *_Delim;
    ostream_type *_Ostr;
};
*/

// TEMPLATE FUNCTION _Val_type
template<class _C, class _Ty, class _D> inline
_Ty *_Val_type(const iterator<_C, _Ty, _D>&)
{
    return ((_Ty *)0);
}
template<class _Ty> inline
_Ty *_Val_type(const _Ty *)
{
    return ((_Ty *)0);
}
// TEMPLATE FUNCTION advance
template<class _II, class _D> inline
void advance(_II& _I, _D _N)
{
    _Advance(_I, _N, _Iter_cat(_I));
}
template<class _II, class _D> inline
void _Advance(_II& _I, _D _N, input_iterator_tag)
{
    for (; 0 < _N; --_N)
        ++_I;
}
template<class _FI, class _D> inline
void _Advance(_FI& _I, _D _N, forward_iterator_tag)
{
    for (; 0 < _N; --_N)
        ++_I;
}
template<class _BI, class _D> inline
void _Advance(_BI& _I, _D _N, bidirectional_iterator_tag)
{
    for (; 0 < _N; --_N)
        ++_I;
    for (; _N < 0; ++_N)
        --_I;
}
template<class _RI, class _D> inline
void _Advance(_RI& _I, _D _N, random_access_iterator_tag)
{
    _I += _N;
}
// TEMPLATE FUNCTION _Dist_type
template<class _C, class _Ty, class _D> inline
_D *_Dist_type(const iterator<_C, _Ty, _D>&)
{
    return ((_D *)0);
}
template<class _Ty> inline
ptrdiff_t *_Dist_type(const _Ty *)
{
    return ((ptrdiff_t *)0);
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLITER_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stlmap.h ===
#pragma once
#ifndef _STLMAP_H_
#define _STLMAP_H_
//#include <functional>
//#include <xtree>

#include <stlfunc.h>
#include <stlxtree.h>
#include <stlxutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE CLASS map
template<class _K, class _Ty, class _Pr = less<_K>, class _A = allocator<_Ty> >
class map
{
public:
    typedef map<_K, _Ty, _Pr, _A> _Myt;
    typedef pair<const _K, _Ty> value_type;
    struct _Kfn : public unary_function<value_type, _K>
    {
        const _K& operator()(const value_type& _X) const
        {
            return (_X.first);
        }
    };
    class value_compare
    : public binary_function<value_type, value_type, bool>
    {
        friend class map<_K, _Ty, _Pr, _A>;
    public:
        bool operator()(const value_type& _X,
                        const value_type& _Y) const
        {
            return (comp(_X.first, _Y.first));
        }
        _PROTECTED:
        value_compare(_Pr _Pred)
        : comp(_Pred)
        {

        }
        _Pr comp;
    };
    typedef _K key_type;
    typedef _Ty referent_type;
    typedef _Pr key_compare;
    typedef _A allocator_type;
    typedef _A::reference _Tref;
    typedef _Tree<_K, value_type, _Kfn, _Pr, _A> _Imp;
    typedef _Imp::size_type size_type;
    typedef _Imp::difference_type difference_type;
    typedef _Imp::reference reference;
    typedef _Imp::const_reference const_reference;
    typedef _Imp::iterator iterator;
    typedef _Imp::const_iterator const_iterator;
    typedef _Imp::reverse_iterator reverse_iterator;
    typedef _Imp::const_reverse_iterator const_reverse_iterator;
    typedef pair<iterator, bool> _Pairib;
    typedef pair<iterator, iterator> _Pairii;
    typedef pair<const_iterator, const_iterator> _Paircc;
    explicit map(const _Pr& _Pred = _Pr(), const _A& _Al = _A())
    : _Tr(_Pred, false, _Al)
    {

    }
    typedef const value_type *_It;
    map(_It _F, _It _L, const _Pr& _Pred = _Pr(),
        const _A& _Al = _A())
    : _Tr(_Pred, false, _Al)
    {
        for (; _F != _L; ++_F)
            _Tr.insert(*_F);
    }
    iterator begin()
    {
        return (_Tr.begin());
    }
    const_iterator begin() const
    {
        return (_Tr.begin());
    }
    iterator end()
    {
        return (_Tr.end());
    }
    const_iterator end() const
    {
        return (_Tr.end());
    }
    reverse_iterator rbegin()
    {
        return (_Tr.rbegin());
    }
    const_reverse_iterator rbegin() const
    {
        return (_Tr.rbegin());
    }
    reverse_iterator rend()
    {
        return (_Tr.rend());
    }
    const_reverse_iterator rend() const
    {
        return (_Tr.rend());
    }
    size_type size() const
    {
        return (_Tr.size());
    }
    size_type max_size() const
    {
        return (_Tr.max_size());
    }
    bool empty() const
    {
        return (_Tr.empty());
    }
    _A get_allocator() const
    {
        return (_Tr.get_allocator());
    }
    _Tref operator[](const key_type& _Kv)
    {
        iterator _P = insert(value_type(_Kv, _Ty())).first;
        return ((*_P).second);
    }
    _Pairib insert(const value_type& _X)
    {
        _Imp::_Pairib _Ans = _Tr.insert(_X);
        return (_Pairib(_Ans.first, _Ans.second));
    }
    iterator insert(iterator _P, const value_type& _X)
    {
        return (_Tr.insert((_Imp::iterator&)_P, _X));
    }
    void insert(_It _F, _It _L)
    {
        for (; _F != _L; ++_F)
            _Tr.insert(*_F);
    }
    iterator erase(iterator _P)
    {
        return (_Tr.erase((_Imp::iterator&)_P));
    }
    iterator erase(iterator _F, iterator _L)
    {
        return (_Tr.erase((_Imp::iterator&)_F,
                          (_Imp::iterator&)_L));
    }
    size_type erase(const _K& _Kv)
    {
        return (_Tr.erase(_Kv));
    }
    void clear()
    {
        _Tr.clear();
    }
    void swap(_Myt& _X)
    {
        std::swap(_Tr, _X._Tr);
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
    key_compare key_comp() const
    {
        return (_Tr.key_comp());
    }
    value_compare value_comp() const
    {
        return (value_compare(_Tr.key_comp()));
    }
    iterator find(const _K& _Kv)
    {
        return (_Tr.find(_Kv));
    }
    const_iterator find(const _K& _Kv) const
    {
        return (_Tr.find(_Kv));
    }
    size_type count(const _K& _Kv) const
    {
        return (_Tr.count(_Kv));
    }
    iterator lower_bound(const _K& _Kv)
    {
        return (_Tr.lower_bound(_Kv));
    }
    const_iterator lower_bound(const _K& _Kv) const
    {
        return (_Tr.lower_bound(_Kv));
    }
    iterator upper_bound(const _K& _Kv)
    {
        return (_Tr.upper_bound(_Kv));
    }
    const_iterator upper_bound(const _K& _Kv) const
    {
        return (_Tr.upper_bound(_Kv));
    }
    _Pairii equal_range(const _K& _Kv)
    {
        return (_Tr.equal_range(_Kv));
    }
    _Paircc equal_range(const _K& _Kv) const
    {
        return (_Tr.equal_range(_Kv));
    }
protected:
    _Imp _Tr;
};
// map TEMPLATE OPERATORS
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator==(const map<_K, _Ty, _Pr, _A>& _X,
                const map<_K, _Ty, _Pr, _A>& _Y)
{
    return (_X.size() == _Y.size()
            && equal(_X.begin(), _X.end(), _Y.begin()));
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator!=(const map<_K, _Ty, _Pr, _A>& _X,
                const map<_K, _Ty, _Pr, _A>& _Y)
{
    return (!(_X == _Y));
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator<(const map<_K, _Ty, _Pr, _A>& _X,
               const map<_K, _Ty, _Pr, _A>& _Y)
{
    return (lexicographical_compare(_X.begin(), _X.end(),
                                    _Y.begin(), _Y.end()));
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator>(const map<_K, _Ty, _Pr, _A>& _X,
               const map<_K, _Ty, _Pr, _A>& _Y)
{
    return (_Y < _X);
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator<=(const map<_K, _Ty, _Pr, _A>& _X,
                const map<_K, _Ty, _Pr, _A>& _Y)
{
    return (!(_Y < _X));
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator>=(const map<_K, _Ty, _Pr, _A>& _X,
                const map<_K, _Ty, _Pr, _A>& _Y)
{
    return (!(_X < _Y));
}
// TEMPLATE CLASS multimap
template<class _K, class _Ty, class _Pr = less<_K>,
class _A = allocator<_Ty> >
class multimap
{
public:
    typedef multimap<_K, _Ty, _Pr, _A> _Myt;
    typedef pair<const _K, _Ty> value_type;
    struct _Kfn : public unary_function<value_type, _K>
    {
        const _K& operator()(const value_type& _X) const
        {
            return (_X.first);
        }
    };
    class value_compare
    : public binary_function<value_type, value_type, bool>
    {
        friend class map<_K, _Ty, _Pr, _A>;
    public:
        bool operator()(const value_type& _X,
                        const value_type& _Y) const
        {
            return (comp(_X.first, _Y.first));
        }
        _PROTECTED:
        value_compare(_Pr _Pred)
        : comp(_Pred)
        {

        }
        _Pr comp;
    };
    typedef _K key_type;
    typedef _Ty referent_type;
    typedef _Pr key_compare;
    typedef _A allocator_type;
    typedef _Tree<_K, value_type, _Kfn, _Pr, _A> _Imp;
    typedef _Imp::size_type size_type;
    typedef _Imp::difference_type difference_type;
    typedef _Imp::reference reference;
    typedef _Imp::const_reference const_reference;
    typedef _Imp::iterator iterator;
    typedef _Imp::const_iterator const_iterator;
    typedef _Imp::reverse_iterator reverse_iterator;
    typedef _Imp::const_reverse_iterator const_reverse_iterator;
    typedef pair<iterator, iterator> _Pairii;
    typedef pair<const_iterator, const_iterator> _Paircc;
    explicit multimap(const _Pr& _Pred = _Pr(),
                      const _A& _Al = _A())
    : _Tr(_Pred, true, _Al)
    {

    }
    typedef const value_type *_It;
    multimap(_It _F, _It _L, const _Pr& _Pred = _Pr(),
             const _A& _Al = _A())
    : _Tr(_Pred, true, _Al)
    {
        for (; _F != _L; ++_F)
            _Tr.insert(*_F);
    }
    iterator begin()
    {
        return (_Tr.begin());
    }
    const_iterator begin() const
    {
        return (_Tr.begin());
    }
    iterator end()
    {
        return (_Tr.end());
    }
    const_iterator end() const
    {
        return (_Tr.end());
    }
    reverse_iterator rbegin()
    {
        return (_Tr.rbegin());
    }
    const_reverse_iterator rbegin() const
    {
        return (_Tr.rbegin());
    }
    reverse_iterator rend()
    {
        return (_Tr.rend());
    }
    const_reverse_iterator rend() const
    {
        return (_Tr.rend());
    }
    size_type size() const
    {
        return (_Tr.size());
    }
    size_type max_size() const
    {
        return (_Tr.max_size());
    }
    bool empty() const
    {
        return (_Tr.empty());
    }
    _A get_allocator() const
    {
        return (_Tr.get_allocator());
    }
    iterator insert(const value_type& _X)
    {
        return (_Tr.insert(_X).first);
    }
    iterator insert(iterator _P, const value_type& _X)
    {
        return (_Tr.insert((_Imp::iterator&)_P, _X));
    }
    void insert(_It _F, _It _L)
    {
        for (; _F != _L; ++_F)
            _Tr.insert(*_F);
    }
    iterator erase(iterator _P)
    {
        return (_Tr.erase((_Imp::iterator&)_P));
    }
    iterator erase(iterator _F, iterator _L)
    {
        return (_Tr.erase((_Imp::iterator&)_F,
                          (_Imp::iterator&)_L));
    }
    size_type erase(const _K& _Kv = _K())
    {
        return (_Tr.erase(_Kv));
    }
    void clear()
    {
        _Tr.clear();
    }
    void swap(_Myt& _X)
    {
        std::swap(_Tr, _X._Tr);
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
    key_compare key_comp() const
    {
        return (_Tr.key_comp());
    }
    value_compare value_comp() const
    {
        return (value_compare(_Tr.key_comp()));
    }
    iterator find(const _K& _Kv)
    {
        return (_Tr.find(_Kv));
    }
    const_iterator find(const _K& _Kv) const
    {
        return (_Tr.find(_Kv));
    }
    size_type count(const _K& _Kv) const
    {
        return (_Tr.count(_Kv));
    }
    iterator lower_bound(const _K& _Kv)
    {
        return (_Tr.lower_bound(_Kv));
    }
    const_iterator lower_bound(const _K& _Kv) const
    {
        return (_Tr.lower_bound(_Kv));
    }
    iterator upper_bound(const _K& _Kv)
    {
        return (_Tr.upper_bound(_Kv));
    }
    const_iterator upper_bound(const _K& _Kv) const
    {
        return (_Tr.upper_bound(_Kv));
    }
    _Pairii equal_range(const _K& _Kv)
    {
        return (_Tr.equal_range(_Kv));
    }
    _Paircc equal_range(const _K& _Kv) const
    {
        return (_Tr.equal_range(_Kv));
    }
protected:
    _Imp _Tr;
};
// multimap TEMPLATE OPERATORS
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator==(const multimap<_K, _Ty, _Pr, _A>& _X,
                const multimap<_K, _Ty, _Pr, _A>& _Y)
{
    return (_X.size() == _Y.size()
            && equal(_X.begin(), _X.end(), _Y.begin()));
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator!=(const multimap<_K, _Ty, _Pr, _A>& _X,
                const multimap<_K, _Ty, _Pr, _A>& _Y)
{
    return (!(_X == _Y));
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator<(const multimap<_K, _Ty, _Pr, _A>& _X,
               const multimap<_K, _Ty, _Pr, _A>& _Y)
{
    return (lexicographical_compare(_X.begin(), _X.end(),
                                    _Y.begin(), _Y.end()));
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator>(const multimap<_K, _Ty, _Pr, _A>& _X,
               const multimap<_K, _Ty, _Pr, _A>& _Y)
{
    return (_Y < _X);
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator<=(const multimap<_K, _Ty, _Pr, _A>& _X,
                const multimap<_K, _Ty, _Pr, _A>& _Y)
{
    return (!(_Y < _X));
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator>=(const multimap<_K, _Ty, _Pr, _A>& _X,
                const multimap<_K, _Ty, _Pr, _A>& _Y)
{
    return (!(_X < _Y));
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLMAP_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stldeque.h ===
#pragma once
#ifndef _STLDEQUE_H_
#define _STLDEQUE_H_
//#include <cstddef>
//#include <functional>
//#include <iterator>
//#include <memory>
//#include <stdexcept>
//#include <xutility>

#include <stlxstdd.h>
#include <stlfunc.h>
#include <stliter.h>
#include <stlmem.h>
#include <stlxutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN
#define _DEQUEMAPSIZ	2
#define _DEQUESIZ (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty))
		// TEMPLATE CLASS deque
template<class _Ty, class _A = allocator<_Ty> >
	class deque {
public:
	typedef deque<_Ty, _A> _Myt;
	typedef _A allocator_type;
	typedef _A::size_type size_type;
	typedef _A::difference_type difference_type;
	typedef _A::pointer _Tptr;
	typedef _A::const_pointer _Ctptr;
	typedef _POINTER_X(_Tptr, _A) _Mapptr;
	typedef _A::reference reference;
	typedef _A::const_reference const_reference;
	typedef _A::value_type value_type;
		// CLASS const_iterator
	class iterator;
	class const_iterator : public _Ranit<_Ty, difference_type> {
	public:
		friend class deque<_Ty, _A>;
		const_iterator()
			: _First(0), _Last(0), _Next(0), _Map(0) {}
		const_iterator(_Tptr _P, _Mapptr _M)
			: _First(*_M), _Last(*_M + _DEQUESIZ),
				_Next(_P), _Map(_M) {}
		const_iterator(const iterator& _X)
			: _First(_X._First), _Last(_X._Last), _Next(_X._Next), 
			  _Map(_X._Map) {}
		const_reference operator*() const
			{return (*_Next); }
		_Ctptr operator->() const
			{return (&**this); }
		const_iterator& operator++()
			{if (++_Next == _Last)
				{_First = *++_Map;
				_Last = _First + _DEQUESIZ;
				_Next = _First; }
			return (*this); }
		const_iterator operator++(int)
			{const_iterator _Tmp = *this;
			++*this;
			return (_Tmp); }
		const_iterator& operator--()
			{if (_Next == _First)
				{_First = *--_Map;
				_Last = _First + _DEQUESIZ;
				_Next = _Last; }
			--_Next;
			return (*this); }
		const_iterator operator--(int)
			{const_iterator _Tmp = *this;
			--*this;
			return (_Tmp); }
		const_iterator& operator+=(difference_type _N)
			{_Add(_N);
			return (*this); }
		const_iterator& operator-=(difference_type _N)
			{return (*this += -_N); }
		const_iterator operator+(difference_type _N) const
			{const_iterator _Tmp = *this;
			return (_Tmp += _N); }
		const_iterator operator-(difference_type _N) const
			{const_iterator _Tmp = *this;
			return (_Tmp -= _N); }
		difference_type operator-(const const_iterator& _X) const
			{return (_Map == _X._Map ? _Next - _X._Next
				: _DEQUESIZ * (_Map - _X._Map - 1)
				+ (_Next - _First) + (_X._Last - _X._Next)); }
		const_reference operator[](difference_type _N) const
			{return (*(*this + _N)); }
		bool operator==(const const_iterator& _X) const
			{return (_Next == _X._Next); }
		bool operator!=(const const_iterator& _X) const
			{return (!(*this == _X)); }
		bool operator<(const const_iterator& _X) const
			{return (_Map < _X._Map
				|| _Map == _X._Map && _Next < _X._Next); }
		bool operator<=(const const_iterator& _X) const
			{return (!(_X < *this)); }
		bool operator>(const const_iterator& _X) const
			{return (_X < *this); }
		bool operator>=(const const_iterator& _X) const
			{return (!(*this < _X)); }
	protected:
		void _Add(difference_type _N)
			{difference_type _Off = _N + _Next - _First;
			difference_type _Moff = (0 <= _Off)
				? _Off / _DEQUESIZ
				: -((_DEQUESIZ - 1 - _Off) / _DEQUESIZ);
			if (_Moff == 0)
				_Next += _N;
			else
				{_Map += _Moff;
				_First = *_Map;
				_Last = _First + _DEQUESIZ;
				_Next = _First + (_Off - _Moff * _DEQUESIZ); }}
	_PROTECTED:
		_Tptr _First, _Last, _Next;
		_Mapptr _Map;
		};
		// CLASS iterator
	class iterator : public const_iterator {
	public:
		iterator()
			{}
		iterator(_Tptr _P, _Mapptr _M)
			: const_iterator(_P, _M) {}
		reference operator*() const
			{return (*_Next); }
		_Tptr operator->() const
			{return (&**this); }
		iterator& operator++()
			{if (++_Next == _Last)
				{_First = *++_Map;
				_Last = _First + _DEQUESIZ;
				_Next = _First; }
			return (*this); }
		iterator operator++(int)
			{iterator _Tmp = *this;
			++*this;
			return (_Tmp); }
		iterator& operator--()
			{if (_Next == _First)
				{_First = *--_Map;
				_Last = _First + _DEQUESIZ;
				_Next = _Last; }
			--_Next;
			return (*this); }
		iterator operator--(int)
			{iterator _Tmp = *this;
			--*this;
			return (_Tmp); }
		iterator& operator+=(difference_type _N)
			{_Add(_N);
			return (*this); }
		iterator& operator-=(difference_type _N)
			{return (*this += -_N); }
		iterator operator+(difference_type _N) const
			{iterator _Tmp = *this;
			return (_Tmp += _N); }
		iterator operator-(difference_type _N) const
			{iterator _Tmp = *this;
			return (_Tmp -= _N); }
		difference_type operator-(const iterator& _X) const
			{return (_Map == _X._Map ? _Next - _X._Next
				: _DEQUESIZ * (_Map - _X._Map - 1)
				+ (_Next - _First) + (_X._Last - _X._Next)); }
		reference operator[](difference_type _N) const
			{return (*(*this + _N)); }
		bool operator==(const iterator& _X) const
			{return (_Next == _X._Next); }
		bool operator!=(const iterator& _X) const
			{return (!(*this == _X)); }
		bool operator<(const iterator& _X) const
			{return (_Map < _X._Map
				|| _Map == _X._Map && _Next < _X._Next); }
		bool operator<=(const iterator& _X) const
			{return (!(_X < *this)); }
		bool operator>(const iterator& _X) const
			{return (_X < *this); }
		bool operator>=(const iterator& _X) const
			{return (!(*this < _X)); }
		};
	typedef reverse_iterator<const_iterator, value_type,
		const_reference, _Ctptr, difference_type>
			const_reverse_iterator;
	typedef reverse_iterator<iterator, value_type,
		reference, _Tptr, difference_type>
			reverse_iterator;
	explicit deque(const _A& _Al = _A())
		: allocator(_Al),
			_First(), _Last(), _Map(0), _Mapsize(0), _Size(0)
		{}
	explicit deque(size_type _N, const _Ty& _V = _Ty(),
		const _A& _Al = _A())
		: allocator(_Al),
			_First(), _Last(), _Map(0), _Mapsize(0), _Size(0)
		{insert(begin(), _N, _V); }
	deque(const _Myt& _X)
		: allocator(_X.allocator),
			_First(), _Last(), _Map(0), _Mapsize(0), _Size(0)
		{copy(_X.begin(), _X.end(), back_inserter(*this)); }
	typedef const_iterator _It;
		deque(_It _F, _It _L, const _A& _Al = _A())
		: allocator(_Al),
			_First(), _Last(), _Map(0), _Mapsize(0), _Size(0)
		{copy(_F, _L, back_inserter(*this)); }
	~deque()
		{while (!empty())
			pop_front(); }
	_Myt& operator=(const _Myt& _X)
		{if (this != &_X)
			{iterator _S;
			if (_X.size() <= size())
				{_S = copy(_X.begin(), _X.end(), begin());
				erase(_S, end()); }
			else
				{const_iterator _Sx = _X.begin() + size();
				_S = copy(_X.begin(), _Sx, begin());
				copy(_Sx, _X.end(), inserter(*this, _S)); }}
		return (*this); }
	iterator begin()
		{return (_First); }
	const_iterator begin() const
		{return ((const_iterator)_First); }
	iterator end()
		{return (_Last); }
	const_iterator end() const
		{return ((const_iterator)_Last); }
	reverse_iterator rbegin()
		{return (reverse_iterator(end())); }
	const_reverse_iterator rbegin() const
		{return (const_reverse_iterator(end())); }
	reverse_iterator rend()
		{return (reverse_iterator(begin())); }
	const_reverse_iterator rend() const
		{return (const_reverse_iterator(begin())); }
	void resize(size_type _N, _Ty _X = _Ty())
		{if (size() < _N)
			insert(end(), _N - size(), _X);
		else if (_N < size())
			erase(begin() + _N, end()); }
	size_type size() const
		{return (_Size); }
	size_type max_size() const
		{return (allocator.max_size()); }
	bool empty() const
		{return (size() == 0); }
	_A get_allocator() const
		{return (allocator); }
	const_reference at(size_type _P) const
		{if (size() <= _P)
			_Xran();
		return (*(begin() + _P)); }
	reference at(size_type _P)
		{if (size() <= _P)
			_Xran();
		return (*(begin() + _P)); }
	const_reference operator[](size_type _P) const
		{return (*(begin() + _P)); }
	reference operator[](size_type _P)
		{return (*(begin() + _P)); }
	reference front()
		{return (*begin()); }
	const_reference front() const
		{return (*begin()); }
	reference back()
		{return (*(end() - 1)); }
	const_reference back() const
		{return (*(end() - 1)); }
	void push_front(const _Ty& _X)
		{if (empty() || _First._Next == _First._First)
			_Buyfront();
		allocator.construct(--_First._Next, _X);
		++_Size; }
	void pop_front()
		{allocator.destroy(_First._Next++);
		--_Size;
		if (empty() || _First._Next == _First._Last)
			_Freefront(); }
	void push_back(const _Ty& _X)
		{
		if (empty() || (_Last._Next == _Last._Last))
        {
            _Buyback();
            allocator.construct(_Last._Next++, _X);
        }
        else if (_Last._Next + 1 == _Last._Last)
        {
            allocator.construct(_Last._Next++, _X);
            _Buyback();
        }
        else
            allocator.construct(_Last._Next++, _X);
        ++_Size; }
	void pop_back()
		{
        if (_Last._Next == _Last._First)
			_Freeback();
		if (!empty())
			allocator.destroy(--_Last._Next);
		--_Size;
		if (empty())
			_Freeback(); }
	void assign(_It _F, _It _L)
		{erase(begin(), end());
		insert(begin(), _F, _L); }
	void assign(size_type _N, const _Ty& _X = _Ty())
		{erase(begin(), end());
		insert(begin(), _N, _X); }
	iterator insert(iterator _P, const _Ty& _X = _Ty())
		{if (_P == begin())
			{push_front(_X);
			return (begin()); }
		else if (_P == end())
			{push_back(_X);
			return (end() - 1); }
		else
			{iterator _S;
			size_type _Off = _P - begin();
			if (_Off < size() / 2)
				{push_front(front());
				_S = begin() + _Off;
				copy(begin() + 2, _S + 1, begin() + 1); }
			else
				{push_back(back());
				_S = begin() + _Off;
				copy_backward(_S, end() - 2, end() - 1); }
			*_S = _X;
			return (_S); }}
	void insert(iterator _P, size_type _M, const _Ty& _X)
		{iterator _S;
		size_type _I;
		size_type _Off = _P - begin();
		size_type _Rem = _Size - _Off;
		if (_Off < _Rem)
			if (_Off < _M)
				{for (_I = _M - _Off; 0 < _I; --_I)
					push_front(_X);
				for (_I = _Off; 0 < _I; --_I)
					push_front(begin()[_M - 1]);
				_S = begin() + _M;
				fill(_S, _S + _Off, _X); }
			else
				{for (_I = _M; 0 < _I; --_I)
					push_front(begin()[_M - 1]);
				_S = begin() + _M;
				copy(_S + _M, _S + _Off, _S);
				fill(begin() + _Off, _S + _Off, _X); }
		else
			if (_Rem < _M)
				{for (_I = _M - _Rem; 0 < _I; --_I)
					push_back(_X);
				for (_I = 0; _I < _Rem; ++_I)
					push_back(begin()[_Off + _I]);
				_S = begin() + _Off;
				fill(_S, _S + _Rem, _X); }
			else
				{for (_I = 0; _I < _M; ++_I)
					push_back(begin()[_Off + _Rem - _M + _I]);
				_S = begin() + _Off;
				copy_backward(_S, _S + _Rem - _M, _S + _Rem);
				fill(_S, _S + _M, _X); }}
	void insert(iterator _P, _It _F, _It _L)
		{size_type _M = 0;
		_Distance(_F, _L, _M);
		size_type _I;
		size_type _Off = _P - begin();
		size_type _Rem = _Size - _Off;
		if (_Off < _Rem)
			if (_Off < _M)
				{_It _Qx = _F;
				advance(_Qx, _M - _Off);
				for (_It _Q = _Qx; _F != _Q; )
					push_front(*--_Q);
				for (_I = _Off; 0 < _I; --_I)
					push_front(begin()[_M - 1]);
				copy(_Qx, _L, begin() + _M); }
			else
				{for (_I = _M; 0 < _I; --_I)
					push_front(begin()[_M - 1]);
				iterator _S = begin() + _M;
				copy(_S + _M, _S + _Off, _S);
				copy(_F, _L, begin() + _Off); }
		else
			if (_Rem < _M)
				{_It _Qx = _F;
				advance(_Qx, _Rem);
				for (_It _Q = _Qx; _Q != _L; ++_Q)
					push_back(*_Q);
				for (_I = 0; _I < _Rem; ++_I)
					push_back(begin()[_Off + _I]);
				copy(_F, _Qx, begin() + _Off); }
			else
				{for (_I = 0; _I < _M; ++_I)
					push_back(begin()[_Off + _Rem - _M + _I]);
				iterator _S = begin() + _Off;
				copy_backward(_S, _S + _Rem - _M, _S + _Rem);
				copy(_F, _L, _S); }}
	iterator erase(iterator _P)
		{return (erase(_P, _P + 1)); }
	iterator erase(iterator _F, iterator _L)
		{size_type _N = _L - _F;
		size_type _M = _F - begin();
		if (_M < end() - _L)
			{copy_backward(begin(), _F, _L);
			for (; 0 < _N; --_N)
				pop_front(); }
		else
			{copy(_L, end(), _F);
			for (; 0 < _N; --_N)
				pop_back(); }
		return (_M == 0 ? begin() : begin() + _M); }
	void clear()
		{erase(begin(), end()); }
	void swap(_Myt& _X)
		{if (allocator == _X.allocator)
			{std::swap(_First, _X._First);
			std::swap(_Last, _X._Last);
			std::swap(_Map, _X._Map);
			std::swap(_Mapsize, _X._Mapsize);
			std::swap(_Size, _X._Size); }
		else
			{_Myt _Ts = *this; *this = _X, _X = _Ts; }}
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
protected:
	void _Buyback()
		{_Tptr _P = allocator.allocate(_DEQUESIZ, (void *)0);
		if (empty())
			{_Mapsize = _DEQUEMAPSIZ;
			size_type _N = _Mapsize / 2;
			_Getmap();
			_Setptr(_Map + _N, _P);
			_First = iterator(_P + _DEQUESIZ / 2, _Map + _N);
			_Last = _First; }
		else if (_Last._Map < _Map + (_Mapsize - 1))
			{_Setptr(++_Last._Map, _P);
			_Last = iterator(_P, _Last._Map); }
		else
			{difference_type _I = _Last._Map - _First._Map + 1;
			_Mapptr _M = _Growmap(2 * _I);
			_Setptr(_M + _I, _P);
			_First = iterator(_First._Next, _M);
			_Last = iterator(_P, _M + _I); }}
	void _Buyfront()
		{_Tptr _P = allocator.allocate(_DEQUESIZ, (void *)0);
		if (empty())
			{_Mapsize = _DEQUEMAPSIZ;
			size_type _N = _Mapsize / 2;
			_Getmap();
			_Setptr(_Map + _N, _P);
			_First = iterator(_P + (_DEQUESIZ / 2 + 1),
				_Map + _N);
			_Last = _First; }
		else if (_Map < _First._Map)
			{_Setptr(--_First._Map, _P);
			_First = iterator(_P + _DEQUESIZ, _First._Map); }
		else if (_Last._Map == _First._Map)
			{_Setptr(_Last._Map++, *_First._Map);
			_Setptr(_First._Map+1, *_First._Map);
			_Setptr(_First._Map, _P);
			_First = iterator(_P + _DEQUESIZ, _First._Map); }
		else
			{difference_type _I = _Last._Map - _First._Map + 1;
			_Mapptr _M = _Growmap(2 * _I);
			_Setptr(--_M, _P);
			_First = iterator(_P + _DEQUESIZ, _M);
			_Last = iterator(_Last._Next, _M + _I); }}
	void _Freeback()
		{_Freeptr(_Last._Map--);
		if (empty())
			{if (_First._Map == _Last._Map)
                _Freeptr(_First._Map);
			_First = iterator();
			_Last = _First;
			_Freemap(); }
		else
			_Last = iterator(*_Last._Map + _DEQUESIZ,
				_Last._Map); }
	void _Freefront()
		{_Freeptr(_First._Map++);
		if (empty())
			{_First = iterator();
			_Last = _First;
			_Freemap(); }
		else
			_First = iterator(*_First._Map, _First._Map); }
	void _Xran() const
		{_THROW(out_of_range, "invalid deque<T> subscript"); }
	void _Freemap()
		{allocator.deallocate(_Map, _Mapsize); }
	void _Freeptr(_Mapptr _M)
		{allocator.deallocate(*_M, _DEQUESIZ); }
	void _Getmap()
		{_Map = (_Mapptr)allocator._Charalloc(
			_Mapsize * sizeof (_Tptr)); }
	_Mapptr _Growmap(size_type _Newsize)
		{_Mapptr _M = (_Mapptr)allocator._Charalloc(
			_Newsize * sizeof (_Tptr));
		copy(_First._Map, _Last._Map + 1,
			_M + _Newsize / 4);
		allocator.deallocate(_Map, _Mapsize);
		_Map = _M;
		_Mapsize = _Newsize;
		return (_M + _Newsize / 4); }
	void _Setptr(_Mapptr _M, _Tptr _P)
		{*_M = _P; }
	_A allocator;
	iterator _First, _Last;
	_Mapptr _Map;
	size_type _Mapsize, _Size;
	};
		// deque TEMPLATE OPERATORS
template<class _Ty, class _A> inline
	bool operator==(const deque<_Ty, _A>& _X,
		const deque<_Ty, _A>& _Y)
	{return (_X.size() == _Y.size()
		&& equal(_X.begin(), _X.end(), _Y.begin())); }
template<class _Ty, class _A> inline
	bool operator!=(const deque<_Ty, _A>& _X,
		const deque<_Ty, _A>& _Y)
	{return (!(_X == _Y)); }
template<class _Ty, class _A> inline
	bool operator<(const deque<_Ty, _A>& _X,
		const deque<_Ty, _A>& _Y)
	{return (lexicographical_compare(_X.begin(), _X.end(),
		_Y.begin(), _Y.end())); }
template<class _Ty, class _A> inline
	bool operator<=(const deque<_Ty, _A>& _X,
		const deque<_Ty, _A>& _Y)
	{return (!(_Y < _X)); }
template<class _Ty, class _A> inline
	bool operator>(const deque<_Ty, _A>& _X,
		const deque<_Ty, _A>& _Y)
	{return (_Y < _X); }
template<class _Ty, class _A> inline
	bool operator>=(const deque<_Ty, _A>& _X,
		const deque<_Ty, _A>& _Y)
	{return (!(_X < _Y)); }
_STD_END
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _DEQUE_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stllist.h ===
#pragma once
#ifndef _STLLIST_H_
#define _STLLIST_H_
//#include <cstddef>
//#include <functional>
//#include <iterator>
//#include <memory>
//#include <stdexcept>
//#include <xutility>

#include <stlxstdd.h>
#include <stlfunc.h>
#include <stliter.h>
#include <stlmem.h>
#include <stlxutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE CLASS list
template<class _Ty, class _A = allocator<_Ty> >
class list
{
protected:
    typedef _POINTER_X(void, _A) _Genptr;
    struct _Node;
    friend struct _Node;
    struct _Node
    {
        _Genptr _Next, _Prev;
        _Ty _Value;
    };
    typedef _POINTER_X(_Node, _A) _Nodeptr;
    struct _Acc;
    friend struct _Acc;
    struct _Acc
    {
        typedef _REFERENCE_X(_Nodeptr, _A) _Nodepref;
        typedef _A::reference _Vref;
        static _Nodepref _Next(_Nodeptr _P)
        {
            return ((_Nodepref)(*_P)._Next);
        }
        static _Nodepref _Prev(_Nodeptr _P)
        {
            return ((_Nodepref)(*_P)._Prev);
        }
        static _Vref _Value(_Nodeptr _P)
        {
            return ((_Vref)(*_P)._Value);
        }
    };
public:
    typedef list<_Ty, _A> _Myt;
    typedef _A allocator_type;
    typedef _A::size_type size_type;
    typedef _A::difference_type difference_type;
    typedef _A::pointer _Tptr;
    typedef _A::const_pointer _Ctptr;
    typedef _A::reference reference;
    typedef _A::const_reference const_reference;
    typedef _A::value_type value_type;
    // CLASS iterator
    class iterator;
    friend class iterator;
    class iterator : public _Bidit<_Ty, difference_type>
    {
    public:
        iterator()
        {

        }
        iterator(_Nodeptr _P)
        : _Ptr(_P)
        {

        }
        reference operator*() const
        {
            return (_Acc::_Value(_Ptr));
        }
        _Tptr operator->() const
        {
            return (&**this);
        }
        iterator& operator++()
        {
            _Ptr = _Acc::_Next(_Ptr);
            return (*this);
        }
        iterator operator++(int)
        {
            iterator _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        iterator& operator--()
        {
            _Ptr = _Acc::_Prev(_Ptr);
            return (*this);
        }
        iterator operator--(int)
        {
            iterator _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        bool operator==(const iterator& _X) const
        {
            return (_Ptr == _X._Ptr);
        }
        bool operator!=(const iterator& _X) const
        {
            return (!(*this == _X));
        }
        _Nodeptr _Mynode() const
        {
            return (_Ptr);
        }
    protected:
        _Nodeptr _Ptr;
    };
    // CLASS const_iterator
    class const_iterator;
    friend class const_iterator;
    class const_iterator : public iterator
    {
    public:
        const_iterator()
        {

        }
        const_iterator(_Nodeptr _P)
        : iterator(_P)
        {

        }
        const_iterator(const iterator& _X)
        : iterator(_X)
        {

        }
        const_reference operator*() const
        {
            return (_Acc::_Value(_Ptr));
        }
        _Ctptr operator->() const
        {
            return (&**this);
        }
        const_iterator& operator++()
        {
            _Ptr = _Acc::_Next(_Ptr);
            return (*this);
        }
        const_iterator operator++(int)
        {
            iterator _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        const_iterator& operator--()
        {
            _Ptr = _Acc::_Prev(_Ptr);
            return (*this);
        }
        const_iterator operator--(int)
        {
            iterator _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        bool operator==(const const_iterator& _X) const
        {
            return (_Ptr == _X._Ptr);
        }
        bool operator!=(const const_iterator& _X) const
        {
            return (!(*this == _X));
        }
    };
    typedef reverse_bidirectional_iterator<iterator,
    value_type, reference, _Tptr, difference_type>
    reverse_iterator;
    typedef reverse_bidirectional_iterator<const_iterator,
    value_type, const_reference, _Ctptr, difference_type>
    const_reverse_iterator;
    explicit list(const _A& _Al = _A())
    : allocator(_Al),
    _Head(_Buynode()), _Size(0)
    {

    }
    explicit list(size_type _N, const _Ty& _V = _Ty(),
                  const _A& _Al = _A())
    : allocator(_Al),
    _Head(_Buynode()), _Size(0)
    {
        insert(begin(), _N, _V);
    }
    list(const _Myt& _X)
    : allocator(_X.allocator),
    _Head(_Buynode()), _Size(0)
    {
        insert(begin(), _X.begin(), _X.end());
    }
    typedef const_iterator _It;
    list(_It _F, _It _L, const _A& _Al = _A())
    : allocator(_Al),
    _Head(_Buynode()), _Size(0)
    {
        insert(begin(), _F, _L);
    }
    ~list()
    {
        erase(begin(), end());
        _Freenode(_Head);
        _Head = 0, _Size = 0;
    }
    _Myt& operator=(const _Myt& _X)
    {
        if (this != &_X)
        {
            iterator _F1 = begin();
            iterator _L1 = end();
            const_iterator _F2 = _X.begin();
            const_iterator _L2 = _X.end();
            for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
                *_F1 = *_F2;
            erase(_F1, _L1);
            insert(_L1, _F2, _L2);
        }
        return (*this);
    }
    iterator begin()
    {
        return (iterator(_Acc::_Next(_Head)));
    }
    const_iterator begin() const
    {
        return (const_iterator(_Acc::_Next(_Head)));
    }
    iterator end()
    {
        return (iterator(_Head));
    }
    const_iterator end() const
    {
        return (const_iterator(_Head));
    }
    reverse_iterator rbegin()
    {
        return (reverse_iterator(end()));
    }
    const_reverse_iterator rbegin() const
    {
        return (const_reverse_iterator(end()));
    }
    reverse_iterator rend()
    {
        return (reverse_iterator(begin()));
    }
    const_reverse_iterator rend() const
    {
        return (const_reverse_iterator(begin()));
    }
    void resize(size_type _N, _Ty _X = _Ty())
    {
        if (size() < _N)
            insert(end(), _N - size(), _X);
        else
            while (_N < size())
                pop_back();
    }
    size_type size() const
    {
        return (_Size);
    }
    size_type max_size() const
    {
        return (allocator.max_size());
    }
    bool empty() const
    {
        return (size() == 0);
    }
    _A get_allocator() const
    {
        return (allocator);
    }
    reference front()
    {
        return (*begin());
    }
    const_reference front() const
    {
        return (*begin());
    }
    reference back()
    {
        return (*(--end()));
    }
    const_reference back() const
    {
        return (*(--end()));
    }
    void push_front(const _Ty& _X)
    {
        insert(begin(), _X);
    }
    void pop_front()
    {
        erase(begin());
    }
    void push_back(const _Ty& _X)
    {
        insert(end(), _X);
    }
    void pop_back()
    {
        erase(--end());
    }
    void assign(_It _F, _It _L)
    {
        erase(begin(), end());
        insert(begin(), _F, _L);
    }
    void assign(size_type _N, const _Ty& _X = _Ty())
    {
        erase(begin(), end());
        insert(begin(), _N, _X);
    }
    iterator insert(iterator _P, const _Ty& _X = _Ty())
    {
        _Nodeptr _S = _P._Mynode();
        _Acc::_Prev(_S) = _Buynode(_S, _Acc::_Prev(_S));
        _S = _Acc::_Prev(_S);
        _Acc::_Next(_Acc::_Prev(_S)) = _S;
        allocator.construct(&_Acc::_Value(_S), _X);
        ++_Size;
        return (iterator(_S));
    }
    void insert(iterator _P, size_type _M, const _Ty& _X)
    {
        for (; 0 < _M; --_M)
            insert(_P, _X);
    }
    void insert(iterator _P, const _Ty *_F, const _Ty *_L)
    {
        for (; _F != _L; ++_F)
            insert(_P, *_F);
    }
    void insert(iterator _P, _It _F, _It _L)
    {
        for (; _F != _L; ++_F)
            insert(_P, *_F);
    }
    iterator erase(iterator _P)
    {
        _Nodeptr _S = (_P++)._Mynode();
        _Acc::_Next(_Acc::_Prev(_S)) = _Acc::_Next(_S);
        _Acc::_Prev(_Acc::_Next(_S)) = _Acc::_Prev(_S);
        allocator.destroy(&_Acc::_Value(_S));
        _Freenode(_S);
        --_Size;
        return (_P);
    }
    iterator erase(iterator _F, iterator _L)
    {
        while (_F != _L)
            erase(_F++);
        return (_F);
    }
    void clear()
    {
        erase(begin(), end());
    }
    void swap(_Myt& _X)
    {
        if (allocator == _X.allocator)
        {
            std::swap(_Head, _X._Head);
            std::swap(_Size, _X._Size);
        }
        else
        {
            iterator _P = begin();
            splice(_P, _X);
            _X.splice(_X.begin(), *this, _P, end());
        }
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
    void splice(iterator _P, _Myt& _X)
    {
        if (!_X.empty())
        {
            _Splice(_P, _X, _X.begin(), _X.end());
            _Size += _X._Size;
            _X._Size = 0;
        }
    }
    void splice(iterator _P, _Myt& _X, iterator _F)
    {
        iterator _L = _F;
        if (_P != _F && _P != ++_L)
        {
            _Splice(_P, _X, _F, _L);
            ++_Size;
            --_X._Size;
        }
    }
    void splice(iterator _P, _Myt& _X, iterator _F, iterator _L)
    {
        if (_F != _L)
        {
            if (&_X != this)
            {
                size_type _N = 0;
                _Distance(_F, _L, _N);
                _Size += _N;
                _X._Size -= _N;
            }
            _Splice(_P, _X, _F, _L);
        }
    }
    void remove(const _Ty& _V)
    {
        iterator _L = end();
        for (iterator _F = begin(); _F != _L; )
            if (*_F == _V)
                erase(_F++);
            else
                ++_F;
    }
    typedef binder2nd<not_equal_to<_Ty> > _Pr1;
    void remove_if(_Pr1 _Pr)
    {
        iterator _L = end();
        for (iterator _F = begin(); _F != _L; )
            if (_Pr(*_F))
                erase(_F++);
            else
                ++_F;
    }
    void unique()
    {
        iterator _F = begin(), _L = end();
        if (_F != _L)
            for (iterator _M = _F; ++_M != _L; _M = _F)
                if (*_F == *_M)
                    erase(_M);
                else
                    _F = _M;
    }
    typedef not_equal_to<_Ty> _Pr2;
    void unique(_Pr2 _Pr)
    {
        iterator _F = begin(), _L = end();
        if (_F != _L)
            for (iterator _M = _F; ++_M != _L; _M = _F)
                if (_Pr(*_F, *_M))
                    erase(_M);
                else
                    _F = _M;
    }
    void merge(_Myt& _X)
    {
        if (&_X != this)
        {
            iterator _F1 = begin(), _L1 = end();
            iterator _F2 = _X.begin(), _L2 = _X.end();
            while (_F1 != _L1 && _F2 != _L2)
                if (*_F2 < *_F1)
                {
                    iterator _Mid2 = _F2;
                    _Splice(_F1, _X, _F2, ++_Mid2);
                    _F2 = _Mid2;
                }
                else
                    ++_F1;
            if (_F2 != _L2)
                _Splice(_L1, _X, _F2, _L2);
            _Size += _X._Size;
            _X._Size = 0;
        }
    }
    typedef greater<_Ty> _Pr3;
    void merge(_Myt& _X, _Pr3 _Pr)
    {
        if (&_X != this)
        {
            iterator _F1 = begin(), _L1 = end();
            iterator _F2 = _X.begin(), _L2 = _X.end();
            while (_F1 != _L1 && _F2 != _L2)
                if (_Pr(*_F2, *_F1))
                {
                    iterator _Mid2 = _F2;
                    _Splice(_F1, _X, _F2, ++_Mid2);
                    _F2 = _Mid2;
                }
                else
                    ++_F1;
            if (_F2 != _L2)
                _Splice(_L1, _X, _F2, _L2);
            _Size += _X._Size;
            _X._Size = 0;
        }
    }
    void sort()
    {
        if (2 <= size())
        {
            const size_t _MAXN = 15;
            _Myt _X(allocator), _A[_MAXN + 1];
            size_t _N = 0;
            while (!empty())
            {
                _X.splice(_X.begin(), *this, begin());
                size_t _I;
                for (_I = 0; _I < _N && !_A[_I].empty(); ++_I)
                {
                    _A[_I].merge(_X);
                    _A[_I].swap(_X);
                }
                if (_I == _MAXN)
                    _A[_I].merge(_X);
                else
                {
                    _A[_I].swap(_X);
                    if (_I == _N)
                        ++_N;
                }
            }
            while (0 < _N)
                merge(_A[--_N]);
        }
    }
    void sort(_Pr3 _Pr)
    {
        if (2 <= size())
        {
            const size_t _MAXN = 15;
            _Myt _X(allocator), _A[_MAXN + 1];
            size_t _N = 0;
            while (!empty())
            {
                _X.splice(_X.begin(), *this, begin());
                size_t _I;
                for (_I = 0; _I < _N && !_A[_I].empty(); ++_I)
                {
                    _A[_I].merge(_X, _Pr);
                    _A[_I].swap(_X);
                }
                if (_I == _MAXN)
                    _A[_I].merge(_X, _Pr);
                else
                {
                    _A[_I].swap(_X);
                    if (_I == _N)
                        ++_N;
                }
            }
            while (0 < _N)
                merge(_A[--_N], _Pr);
        }
    }
    void reverse()
    {
        if (2 <= size())
        {
            iterator _L = end();
            for (iterator _F = ++begin(); _F != _L; )
            {
                iterator _M = _F;
                _Splice(begin(), *this, _M, ++_F);
            }
        }
    }
protected:
    _Nodeptr _Buynode(_Nodeptr _Narg = 0, _Nodeptr _Parg = 0)
    {
        _Nodeptr _S = (_Nodeptr)allocator._Charalloc(
                                                    1 * sizeof (_Node));
        _Acc::_Next(_S) = _Narg != 0 ? _Narg : _S;
        _Acc::_Prev(_S) = _Parg != 0 ? _Parg : _S;
        return (_S);
    }
    void _Freenode(_Nodeptr _S)
    {
        allocator.deallocate(_S, 1);
    }
    void _Splice(iterator _P, _Myt& _X, iterator _F, iterator _L)
    {
        if (allocator == _X.allocator)
        {
            _Acc::_Next(_Acc::_Prev(_L._Mynode())) =
            _P._Mynode();
            _Acc::_Next(_Acc::_Prev(_F._Mynode())) =
            _L._Mynode();
            _Acc::_Next(_Acc::_Prev(_P._Mynode())) =
            _F._Mynode();
            _Nodeptr _S = _Acc::_Prev(_P._Mynode());
            _Acc::_Prev(_P._Mynode()) =
            _Acc::_Prev(_L._Mynode());
            _Acc::_Prev(_L._Mynode()) =
            _Acc::_Prev(_F._Mynode());
            _Acc::_Prev(_F._Mynode()) = _S;
        }
        else
        {
            insert(_P, _F, _L);
            _X.erase(_F, _L);
        }
    }
    void _Xran() const
    {
        _THROW(out_of_range, "invalid list<T> subscript");
    }
    _A allocator;
    _Nodeptr _Head;
    size_type _Size;
};

// list TEMPLATE OPERATORS
template<class _Ty, class _A> inline
bool operator==(const list<_Ty, _A>& _X,
                const list<_Ty, _A>& _Y)
{
    return (_X.size() == _Y.size()
            && equal(_X.begin(), _X.end(), _Y.begin()));
}
template<class _Ty, class _A> inline
bool operator!=(const list<_Ty, _A>& _X,
                const list<_Ty, _A>& _Y)
{
    return (!(_X == _Y));
}
template<class _Ty, class _A> inline
bool operator<(const list<_Ty, _A>& _X,
               const list<_Ty, _A>& _Y)
{
    return (lexicographical_compare(_X.begin(), _X.end(),
                                    _Y.begin(), _Y.end()));
}
template<class _Ty, class _A> inline
bool operator>(const list<_Ty, _A>& _X,
               const list<_Ty, _A>& _Y)
{
    return (_Y < _X);
}
template<class _Ty, class _A> inline
bool operator<=(const list<_Ty, _A>& _X,
                const list<_Ty, _A>& _Y)
{
    return (!(_Y < _X));
}
template<class _Ty, class _A> inline
bool operator>=(const list<_Ty, _A>& _X,
                const list<_Ty, _A>& _Y)
{
    return (!(_X < _Y));
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLLIST_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stlmem.h ===
#pragma once
#ifndef _STLMEM_H_
#define _STLMEM_H_
//#include <memory>

#include <stlxmem.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

// TEMPLATE OPERATOR new
template<class _Ty> inline
void *operator new(size_t _N, std::allocator<_Ty>& _Al)
{
    return (_Al._Charalloc(_N));
}

_STD_BEGIN

// TEMPLATE FUNCTION get_temporary_buffer
template<class _Ty> inline
pair<_Ty _FARQ *, _PDFT>
get_temporary_buffer(_PDFT _N, _Ty _FARQ *)
{
    _Ty _FARQ *_P;
    for (_P = 0; 0 < _N; _N /= 2)
        if ((_P = (_Ty _FARQ *)operator new(
                                           (_SIZT)_N * sizeof (_Ty), nothrow)) != 0)
            break;
    return (pair<_Ty _FARQ *, _PDFT>(_P, _N));
}

// TEMPLATE FUNCTION return_temporary_buffer
template<class _Ty> inline
void return_temporary_buffer(_Ty *_P)
{
    operator delete(_P);
}

// TEMPLATE FUNCTION uninitialized_copy
template<class _II, class _FI> inline
_FI uninitialized_copy(_II _F, _II _L, _FI _X)
{
    for (; _F != _L; ++_X, ++_F)
        _Construct(&*_X, *_F);
    return (_X);
}

// TEMPLATE FUNCTION uninitialized_fill
template<class _FI, class _Ty> inline
void uninitialized_fill(_FI _F, _FI _L, const _Ty& _X)
{
    for (; _F != _L; ++_F)
        _Construct(&*_F, _X);
}

// TEMPLATE FUNCTION uninitialized_fill_n
template<class _FI, class _S, class _Ty> inline
void uninitialized_fill_n(_FI _F, _S _N, const _Ty& _X)
{
    for (; 0 < _N; --_N, ++_F)
        _Construct(&*_F, _X);
}

// TEMPLATE CLASS raw_storage_iterator
template<class _OI, class _Ty>
class raw_storage_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _OI iterator_type;
    typedef _Ty element_type;
    explicit raw_storage_iterator(_OI _X) : _Next(_X)
    {
    }
    raw_storage_iterator<_OI, _Ty>& operator*()
    {
        return (*this);
    }
    raw_storage_iterator<_OI, _Ty>& operator=(const _Ty& _X)
    {
        _Construct(&*_Next, _X);
        return (*this);
    }
    raw_storage_iterator<_OI, _Ty>& operator++()
    {
        ++_Next;
        return (*this);
    }
    raw_storage_iterator<_OI, _Ty> operator++(int)
    {
        raw_storage_iterator<_OI, _Ty> _Ans = *this;
        ++_Next;
        return (_Ans);
    }
private:
    _OI _Next;
};

// TEMPLATE CLASS _Temp_iterator
template<class _Ty>
class _Temp_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _Ty _FARQ *_Pty;
    _Temp_iterator(_PDFT _N = 0)
    {
        pair<_Pty, _PDFT> _Pair =
        get_temporary_buffer(_N, (_Pty)0);
        _Buf._Begin = _Pair.first;
        _Buf._Cur = _Pair.first;
        _Buf._Hiwater = _Pair.first;
        _Buf._Len = _Pair.second;
        _Pb = &_Buf;
    }
    _Temp_iterator(const _Temp_iterator<_Ty>& _X)
    {
        _Buf._Begin = 0;
        _Buf._Cur = 0;
        _Buf._Hiwater = 0;
        _Buf._Len = 0;
        *this = _X;
    }
    ~_Temp_iterator()
    {
        if (_Buf._Begin != 0)
        {
            for (_Pty _F = _Buf._Begin;
                _F != _Buf._Hiwater; ++_F)
                _Destroy(&*_F);
            return_temporary_buffer(_Buf._Begin);
        }
    }
    _Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _X)
    {
        _Pb = _X._Pb;
        return (*this);
    }
    _Temp_iterator<_Ty>& operator=(const _Ty& _V)
    {
        if (_Pb->_Cur < _Pb->_Hiwater)
            *_Pb->_Cur++ = _V;
        else
        {
            _Construct(&*_Pb->_Cur, _V);
            _Pb->_Hiwater = ++_Pb->_Cur;
        }
        return (*this);
    }
    _Temp_iterator<_Ty>& operator*()
    {
        return (*this);
    }
    _Temp_iterator<_Ty>& operator++()
    {
        return (*this);
    }
    _Temp_iterator<_Ty>& operator++(int)
    {
        return (*this);
    }
    _Temp_iterator<_Ty>& _Init()
    {
        _Pb->_Cur = _Pb->_Begin;
        return (*this);
    }
    _Pty _First() const
    {
        return (_Pb->_Begin);
    }
    _Pty _Last() const
    {
        return (_Pb->_Cur);
    }
    _PDFT _Maxlen() const
    {
        return (_Pb->_Len);
    }
private:
    struct _Bufpar
    {
        _Pty _Begin;
        _Pty _Cur;
        _Pty _Hiwater;
        _PDFT _Len;
    } _Buf, *_Pb;
};

// TEMPLATE CLASS auto_ptr
template<class _Ty>
class auto_ptr
{
public:
    typedef _Ty element_type;
    explicit auto_ptr(_Ty *_P = 0) _THROW0() : _Owns(_P != 0), _Ptr(_P)
    {
    }
    auto_ptr(const auto_ptr<_Ty>& _Y) _THROW0()
        : _Owns(_Y._Owns), _Ptr(_Y.release())
    {
    }
    auto_ptr<_Ty>& operator=(const auto_ptr<_Ty>& _Y) _THROW0()
    {
        if (_Ptr != _Y.get())
        {
            if (_Owns)
                delete _Ptr;
            _Owns = _Y._Owns;
            _Ptr = _Y.release();
        }
        else if (_Y._Owns)
            _Owns = true;
        return (*this);
    }
    ~auto_ptr()
    {
        if (_Owns)
            delete _Ptr;
    }
    _Ty& operator*() const _THROW0()
    {
        return (*get());
    }
    _Ty *operator->() const _THROW0()
    {
        return (get());
    }
    _Ty *get() const _THROW0()
    {
        return (_Ptr);
    }
    _Ty *release() const _THROW0()
    {
        ((auto_ptr<_Ty> *)this)->_Owns = false;
        return (_Ptr);
    }
private:
    bool _Owns;
    _Ty *_Ptr;
};

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLMEM_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stlnew.h ===
#pragma once
#ifndef _STLNEW_H_
#define _STLNEW_H_
//#include <exception>

#include <stlexcep.h>
#include "ncmem.h"

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// CLASS bad_alloc
class /*_CRTIMP*/ bad_alloc : public exception
{
public:
    bad_alloc(const char *_S = "bad allocation") _THROW0() : exception(_S)
    {
    }
    virtual ~bad_alloc() _THROW0()
    {
    }
protected:
    virtual void _Doraise() const
    {
        _RAISE(*this);
    }
};

// SUPPORT TYPES
struct nothrow_t
{
};
extern /*_CRTIMP*/ const nothrow_t nothrow;

_STD_END

/*
typedef void (__cdecl *new_handler)();
extern new_handler _New_hand;

// new AND delete DECLARATIONS
void  __cdecl operator delete(void *) _THROW0();
void* __cdecl operator new(size_t) _THROW1(std::bad_alloc);
void* __cdecl operator new(size_t, const std::nothrow_t&) _THROW0();
*/

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
{
    return (_P);
}
#if  _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void*)
{
    return;
}
#endif
#endif

/*
#ifdef _CRTIMP
_CRTIMP
#endif
new_handler __cdecl set_new_handler(new_handler) _THROW0();
*/

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLNEW_H_ */

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stlfunc.h ===
#pragma once
#ifndef _STLFUNC_H_
#define _STLFUNC_H_
//#include <xstddef>

#include <stddef.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE STRUCT unary_function
template<class _A, class _R>
struct unary_function
{
    typedef _A argument_type;
    typedef _R result_type;
};

// TEMPLATE STRUCT binary_function
template<class _A1, class _A2, class _R>
struct binary_function
{
    typedef _A1 first_argument_type;
    typedef _A2 second_argument_type;
    typedef _R result_type;
};

// TEMPLATE STRUCT plus
template<class _Ty>
struct plus : binary_function<_Ty, _Ty, _Ty>
{
    _Ty operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X + _Y);
    }
};

// TEMPLATE STRUCT minus
template<class _Ty>
struct minus : binary_function<_Ty, _Ty, _Ty>
{
    _Ty operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X - _Y);
    }
};

// TEMPLATE STRUCT multiplies
template<class _Ty>
struct multiplies : binary_function<_Ty, _Ty, _Ty>
{
    _Ty operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X * _Y);
    }
};

// TEMPLATE STRUCT divides
template<class _Ty>
struct divides : binary_function<_Ty, _Ty, _Ty>
{
    _Ty operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X / _Y);
    }
};

// TEMPLATE STRUCT modulus
template<class _Ty>
struct modulus : binary_function<_Ty, _Ty, _Ty>
{
    _Ty operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X % _Y);
    }
};

// TEMPLATE STRUCT negate
template<class _Ty>
struct negate : unary_function<_Ty, _Ty>
{
    _Ty operator()(const _Ty& _X) const
    {
        return (-_X);
    }
};

// TEMPLATE STRUCT equal_to
template<class _Ty>
struct equal_to : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X == _Y);
    }
};

// TEMPLATE STRUCT not_equal_to
template<class _Ty>
struct not_equal_to : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X != _Y);
    }
};

// TEMPLATE STRUCT greater
template<class _Ty>
struct greater : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X > _Y);
    }
};

// TEMPLATE STRUCT less
template<class _Ty>
struct less : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X < _Y);
    }
};

// TEMPLATE STRUCT greater_equal
template<class _Ty>
struct greater_equal : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X >= _Y);
    }
};

// TEMPLATE STRUCT less_equal
template<class _Ty>
struct less_equal : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X <= _Y);
    }
};

// TEMPLATE STRUCT logical_and
template<class _Ty>
struct logical_and : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X && _Y);
    }
};

// TEMPLATE STRUCT logical_or
template<class _Ty>
struct logical_or : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X || _Y);
    }
};

// TEMPLATE STRUCT logical_not
template<class _Ty>
struct logical_not : unary_function<_Ty, bool>
{
    bool operator()(const _Ty& _X) const
    {
        return (!_X);
    }
};

// TEMPLATE CLASS unary_negate
template<class _Ufn>
class unary_negate
: public unary_function<_Ufn::argument_type, bool>
{
public:
    explicit unary_negate(const _Ufn& _X)
    : _Fn(_X)
    {

    }
    bool operator()(const _Ufn::argument_type& _X) const
    {
        return (!_Fn(_X));
    }
protected:
    _Ufn _Fn;
};

// TEMPLATE FUNCTION not1
template<class _Ufn> inline
unary_negate<_Ufn> not1(const _Ufn& _X)
{
    return (unary_negate<_Ufn>(_X));
}

// TEMPLATE CLASS binary_negate
template<class _Bfn>
class binary_negate
: public binary_function<_Bfn::first_argument_type,
_Bfn::second_argument_type, bool>
{
public:
    explicit binary_negate(const _Bfn& _X)
    : _Fn(_X)
    {

    }
    bool operator()(const _Bfn::first_argument_type& _X,
                    const _Bfn::second_argument_type& _Y) const
    {
        return (!_Fn(_X, _Y));
    }
protected:
    _Bfn _Fn;
};

// TEMPLATE FUNCTION not2
template<class _Bfn> inline
binary_negate<_Bfn> not2(const _Bfn& _X)
{
    return (binary_negate<_Bfn>(_X));
}

// TEMPLATE CLASS binder1st
template<class _Bfn>
class binder1st
: public unary_function<_Bfn::second_argument_type,
_Bfn::result_type>
{
public:
    binder1st(const _Bfn& _X,
              const _Bfn::first_argument_type& _Y)
    : op(_X), value(_Y)
    {

    }
    result_type operator()(const argument_type& _X) const
    {
        return (op(value, _X));
    }
protected:
    _Bfn op;
    _Bfn::first_argument_type value;
};

// TEMPLATE FUNCTION bind1st
template<class _Bfn, class _Ty> inline
binder1st<_Bfn> bind1st(const _Bfn& _X, const _Ty& _Y)
{
    return (binder1st<_Bfn>(_X,
                            _Bfn::first_argument_type(_Y)));
}

// TEMPLATE CLASS binder2nd
template<class _Bfn>
class binder2nd
: public unary_function<_Bfn::first_argument_type,
_Bfn::result_type>
{
public:
    binder2nd(const _Bfn& _X,
              const _Bfn::second_argument_type& _Y)
    : op(_X), value(_Y)
    {

    }
    result_type operator()(const argument_type& _X) const
    {
        return (op(_X, value));
    }
protected:
    _Bfn op;
    _Bfn::second_argument_type value;
};

// TEMPLATE FUNCTION bind2nd
template<class _Bfn, class _Ty> inline
binder2nd<_Bfn> bind2nd(const _Bfn& _X, const _Ty& _Y)
{
    return (binder2nd<_Bfn>(_X,
                            _Bfn::second_argument_type(_Y)));
}

// TEMPLATE CLASS pointer_to_unary_function
template<class _A, class _R>
class pointer_to_unary_function
: public unary_function<_A, _R>
{
public:
    explicit pointer_to_unary_function(_R (__cdecl *_X)(_A))
    : _Fn(_X)
    {

    }
    _R operator()(_A _X) const
    {
        return (_Fn(_X));
    }
protected:
    _R (__cdecl *_Fn)(_A);
};

// TEMPLATE CLASS pointer_to_binary_function
template<class _A1, class _A2, class _R>
class pointer_to_binary_function
: public binary_function<_A1, _A2, _R>
{
public:
    explicit pointer_to_binary_function(
                                       _R (__cdecl *_X)(_A1, _A2))
    : _Fn(_X)
    {

    }
    _R operator()(_A1 _X, _A2 _Y) const
    {
        return (_Fn(_X, _Y));
    }
protected:
    _R (__cdecl *_Fn)(_A1, _A2);
};

// TEMPLATE FUNCTION ptr_fun
template<class _A, class _R> inline
pointer_to_unary_function<_A, _R>
ptr_fun(_R (__cdecl *_X)(_A))
{
    return (pointer_to_unary_function<_A, _R>(_X));
}
template<class _A1, class _A2, class _R> inline
pointer_to_binary_function<_A1, _A2, _R>
ptr_fun(_R (__cdecl *_X)(_A1, _A2))
{
    return (pointer_to_binary_function<_A1, _A2, _R>(_X));
}

// TEMPLATE CLASS mem_fun_t
template<class _R, class _Ty>
class mem_fun_t : public unary_function<_Ty *, _R>
{
public:
    explicit mem_fun_t(_R (_Ty::*_Pm)())
    : _Ptr(_Pm)
    {

    }
    _R operator()(_Ty *_P)
    {
        return ((_P->*_Ptr)());
    }
private:
    _R (_Ty::*_Ptr)();
};

// TEMPLATE FUNCTION mem_fun
template<class _R, class _Ty> inline
mem_fun_t<_R, _Ty> mem_fun(_R (_Ty::*_Pm)())
{
    return (mem_fun_t<_R, _Ty>(_Pm));
}

// TEMPLATE CLASS mem_fun1_t
template<class _R, class _Ty, class _A>
class mem_fun1_t : public binary_function<_Ty *, _A, _R>
{
public:
    explicit mem_fun1_t(_R (_Ty::*_Pm)(_A))
    : _Ptr(_Pm)
    {

    }
    _R operator()(_Ty *_P, _A _Arg)
    {
        return ((_P->*_Ptr)(_Arg));
    }
private:
    _R (_Ty::*_Ptr)(_A);
};

// TEMPLATE FUNCTION mem_fun1
template<class _R, class _Ty, class _A> inline
mem_fun1_t<_R, _Ty, _A> mem_fun1(_R (_Ty::*_Pm)(_A))
{
    return (mem_fun1_t<_R, _Ty, _A>(_Pm));
}

// TEMPLATE CLASS mem_fun_ref_t
template<class _R, class _Ty>
class mem_fun_ref_t : public unary_function<_Ty *, _R>
{
public:
    explicit mem_fun_ref_t(_R (_Ty::*_Pm)())
    : _Ptr(_Pm)
    {

    }
    _R operator()(_Ty& _X)
    {
        return ((_X.*_Ptr)());
    }
private:
    _R (_Ty::*_Ptr)();
};

// TEMPLATE FUNCTION mem_fun_ref
template<class _R, class _Ty> inline
mem_fun_ref_t<_R, _Ty> mem_fun_ref(_R (_Ty::*_Pm)())
{
    return (mem_fun_ref_t<_R, _Ty>(_Pm));
}

// TEMPLATE CLASS mem_fun1_ref_t
template<class _R, class _Ty, class _A>
class mem_fun1_ref_t : public binary_function<_Ty *, _A, _R>
{
public:
    explicit mem_fun1_ref_t(_R (_Ty::*_Pm)(_A))
    : _Ptr(_Pm)
    {

    }
    _R operator()(_Ty& _X, _A _Arg)
    {
        return ((_X.*_Ptr)(_Arg));
    }
private:
    _R (_Ty::*_Ptr)(_A);
};

// TEMPLATE FUNCTION mem_fun1_ref
template<class _R, class _Ty, class _A> inline
mem_fun1_ref_t<_R, _Ty, _A> mem_fun1_ref(_R (_Ty::*_Pm)(_A))
{
    return (mem_fun1_ref_t<_R, _Ty, _A>(_Pm));
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLFUNC_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stlset.h ===
#pragma once
#ifndef _STLSET_H_
#define _STLSET_H_
//#include <functional>
//#include <xtree>

#include <stlfunc.h>
#include <stlxtree.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN
// TEMPLATE CLASS set
template<class _K, class _Pr = less<_K>, class _A = allocator<_K> >
class set
{
public:
    typedef set<_K, _Pr, _A> _Myt;
    typedef _K value_type;
    struct _Kfn : public unary_function<value_type, _K>
    {
        const _K& operator()(const value_type& _X) const
        {
            return (_X);
        }
    };
    typedef _Pr value_compare;
    typedef _K key_type;
    typedef _Pr key_compare;
    typedef _A allocator_type;
    typedef _Tree<_K, value_type, _Kfn, _Pr, _A> _Imp;
    typedef _Imp::size_type size_type;
    typedef _Imp::difference_type difference_type;
    typedef _Imp::const_reference reference;
    typedef _Imp::const_reference const_reference;
    typedef _Imp::const_iterator iterator;
    typedef _Imp::const_iterator const_iterator;
    typedef _Imp::const_reverse_iterator reverse_iterator;
    typedef _Imp::const_reverse_iterator const_reverse_iterator;
    typedef pair<iterator, bool> _Pairib;
    typedef pair<const_iterator, const_iterator> _Paircc;
    explicit set(const _Pr& _Pred = _Pr(), const _A& _Al = _A())
    : _Tr(_Pred, false, _Al)
    {

    }
    typedef const value_type *_It;
    set(_It _F, _It _L, const _Pr& _Pred = _Pr(),
        const _A& _Al = _A())
    : _Tr(_Pred, false, _Al)
    {
        for (; _F != _L; ++_F)
            _Tr.insert(*_F);
    }
    const_iterator begin() const
    {
        return (_Tr.begin());
    }
    const_iterator end() const
    {
        return (_Tr.end());
    }
    const_reverse_iterator rbegin() const
    {
        return (_Tr.rbegin());
    }
    const_reverse_iterator rend() const
    {
        return (_Tr.rend());
    }
    size_type size() const
    {
        return (_Tr.size());
    }
    size_type max_size() const
    {
        return (_Tr.max_size());
    }
    bool empty() const
    {
        return (_Tr.empty());
    }
    _A get_allocator() const
    {
        return (_Tr.get_allocator());
    }
    _Pairib insert(const value_type& _X)
    {
        _Imp::_Pairib _Ans = _Tr.insert(_X);
        return (_Pairib(_Ans.first, _Ans.second));
    }
    iterator insert(iterator _P, const value_type& _X)
    {
        return (_Tr.insert((_Imp::iterator&)_P, _X));
    }
    void insert(_It _F, _It _L)
    {
        for (; _F != _L; ++_F)
            _Tr.insert(*_F);
    }
    iterator erase(iterator _P)
    {
        return (_Tr.erase((_Imp::iterator&)_P));
    }
    iterator erase(iterator _F, iterator _L)
    {
        return (_Tr.erase((_Imp::iterator&)_F,
                          (_Imp::iterator&)_L));
    }
    size_type erase(const _K& _Kv)
    {
        return (_Tr.erase(_Kv));
    }
    void clear()
    {
        _Tr.clear();
    }
    void swap(_Myt& _X)
    {
        std::swap(_Tr, _X._Tr);
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
    key_compare key_comp() const
    {
        return (_Tr.key_comp());
    }
    value_compare value_comp() const
    {
        return (_Tr.key_comp());
    }
    const_iterator find(const _K& _Kv) const
    {
        return (_Tr.find(_Kv));
    }
    size_type count(const _K& _Kv) const
    {
        return (_Tr.count(_Kv));
    }
    const_iterator lower_bound(const _K& _Kv) const
    {
        return (_Tr.lower_bound(_Kv));
    }
    const_iterator upper_bound(const _K& _Kv) const
    {
        return (_Tr.upper_bound(_Kv));
    }
    _Paircc equal_range(const _K& _Kv) const
    {
        return (_Tr.equal_range(_Kv));
    }
protected:
    _Imp _Tr;
};

// set TEMPLATE OPERATORS
template<class _K, class _Pr, class _A> inline
bool operator==(const set<_K, _Pr, _A>& _X,
                const set<_K, _Pr, _A>& _Y)
{
    return (_X.size() == _Y.size()
            && equal(_X.begin(), _X.end(), _Y.begin()));
}
template<class _K, class _Pr, class _A> inline
bool operator!=(const set<_K, _Pr, _A>& _X,
                const set<_K, _Pr, _A>& _Y)
{
    return (!(_X == _Y));
}
template<class _K, class _Pr, class _A> inline
bool operator<(const set<_K, _Pr, _A>& _X,
               const set<_K, _Pr, _A>& _Y)
{
    return (lexicographical_compare(_X.begin(), _X.end(),
                                    _Y.begin(), _Y.end()));
}
template<class _K, class _Pr, class _A> inline
bool operator>(const set<_K, _Pr, _A>& _X,
               const set<_K, _Pr, _A>& _Y)
{
    return (_Y < _X);
}
template<class _K, class _Pr, class _A> inline
bool operator<=(const set<_K, _Pr, _A>& _X,
                const set<_K, _Pr, _A>& _Y)
{
    return (!(_Y < _X));
}
template<class _K, class _Pr, class _A> inline
bool operator>=(const set<_K, _Pr, _A>& _X,
                const set<_K, _Pr, _A>& _Y)
{
    return (!(_X < _Y));
}

// TEMPLATE CLASS multiset
template<class _K, class _Pr = less<_K>, class _A = allocator<_K> >
class multiset
{
public:
    typedef multiset<_K, _Pr, _A> _Myt;
    typedef _K value_type;
    struct _Kfn : public unary_function<value_type, _K>
    {
        const _K& operator()(const value_type& _X) const
        {
            return (_X);
        }
    };
    typedef _Pr value_compare;
    typedef _K key_type;
    typedef _Pr key_compare;
    typedef _A allocator_type;
    typedef _Tree<_K, value_type, _Kfn, _Pr, _A> _Imp;
    typedef _Imp::size_type size_type;
    typedef _Imp::difference_type difference_type;
    typedef _Imp::const_reference reference;
    typedef _Imp::const_reference const_reference;
    typedef _Imp::const_iterator iterator;
    typedef _Imp::const_iterator const_iterator;
    typedef _Imp::const_reverse_iterator reverse_iterator;
    typedef _Imp::const_reverse_iterator const_reverse_iterator;
    typedef pair<const_iterator, const_iterator> _Paircc;
    explicit multiset(const _Pr& _Pred = _Pr(),
                      const _A& _Al = _A())
    : _Tr(_Pred, true, _Al)
    {

    }
    typedef const value_type *_It;
    multiset(_It _F, _It _L, const _Pr& _Pred = _Pr(),
             const _A& _Al = _A())
    : _Tr(_Pred, true, _Al)
    {
        for (; _F != _L; ++_F)
            _Tr.insert(*_F);
    }
    const_iterator begin() const
    {
        return (_Tr.begin());
    }
    const_iterator end() const
    {
        return (_Tr.end());
    }
    const_reverse_iterator rbegin() const
    {
        return (_Tr.rbegin());
    }
    const_reverse_iterator rend() const
    {
        return (_Tr.rend());
    }
    size_type size() const
    {
        return (_Tr.size());
    }
    size_type max_size() const
    {
        return (_Tr.max_size());
    }
    bool empty() const
    {
        return (_Tr.empty());
    }
    _A get_allocator() const
    {
        return (_Tr.get_allocator());
    }
    iterator insert(const value_type& _X)
    {
        return (_Tr.insert(_X).first);
    }
    iterator insert(iterator _P, const value_type& _X)
    {
        return (_Tr.insert((_Imp::iterator&)_P, _X));
    }
    void insert(_It _F, _It _L)
    {
        for (; _F != _L; ++_F)
            _Tr.insert(*_F);
    }
    iterator erase(iterator _P)
    {
        return (_Tr.erase((_Imp::iterator&)_P));
    }
    iterator erase(iterator _F, iterator _L)
    {
        return (_Tr.erase((_Imp::iterator&)_F,
                          (_Imp::iterator&)_L));
    }
    size_type erase(const _K& _Kv)
    {
        return (_Tr.erase(_Kv));
    }
    void clear()
    {
        _Tr.clear();
    }
    void swap(_Myt& _X)
    {
        std::swap(_Tr, _X._Tr);
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
    key_compare key_comp() const
    {
        return (_Tr.key_comp());
    }
    value_compare value_comp() const
    {
        return (_Tr.key_comp());
    }
    const_iterator find(const _K& _Kv) const
    {
        return (_Tr.find(_Kv));
    }
    size_type count(const _K& _Kv) const
    {
        return (_Tr.count(_Kv));
    }
    const_iterator lower_bound(const _K& _Kv) const
    {
        return (_Tr.lower_bound(_Kv));
    }
    const_iterator upper_bound(const _K& _Kv) const
    {
        return (_Tr.upper_bound(_Kv));
    }
    _Paircc equal_range(const _K& _Kv) const
    {
        return (_Tr.equal_range(_Kv));
    }
protected:
    _Imp _Tr;
};

// multiset TEMPLATE OPERATORS
template<class _K, class _Pr, class _A> inline
bool operator==(const multiset<_K, _Pr, _A>& _X,
                const multiset<_K, _Pr, _A>& _Y)
{
    return (_X.size() == _Y.size()
            && equal(_X.begin(), _X.end(), _Y.begin()));
}
template<class _K, class _Pr, class _A> inline
bool operator!=(const multiset<_K, _Pr, _A>& _X,
                const multiset<_K, _Pr, _A>& _Y)
{
    return (!(_X == _Y));
}
template<class _K, class _Pr, class _A> inline
bool operator<(const multiset<_K, _Pr, _A>& _X,
               const multiset<_K, _Pr, _A>& _Y)
{
    return (lexicographical_compare(_X.begin(), _X.end(),
                                    _Y.begin(), _Y.end()));
}
template<class _K, class _Pr, class _A> inline
bool operator>(const multiset<_K, _Pr, _A>& _X,
               const multiset<_K, _Pr, _A>& _Y)
{
    return (_Y < _X);
}
template<class _K, class _Pr, class _A> inline
bool operator<=(const multiset<_K, _Pr, _A>& _X,
                const multiset<_K, _Pr, _A>& _Y)
{
    return (!(_Y < _X));
}
template<class _K, class _Pr, class _A> inline
bool operator>=(const multiset<_K, _Pr, _A>& _X,
                const multiset<_K, _Pr, _A>& _Y)
{
    return (!(_X < _Y));
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLSET_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stlutil.h ===
#pragma once
#ifndef _STLUTIL_H_
#define _STLUTIL_H_

#include <stlxstdd.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE STRUCT pair
template<class _T1, class _T2> struct pair
{
    typedef _T1 first_type;
    typedef _T2 second_type;
    pair()
    : first(_T1()), second(_T2())
    {

    }
    pair(const _T1& _V1, const _T2& _V2)
    : first(_V1), second(_V2)
    {

    }
    _T1 first;
    _T2 second;
};
template<class _T1, class _T2> inline
bool __cdecl operator==(const pair<_T1, _T2>& _X,
                        const pair<_T1, _T2>& _Y)
{
    return (_X.first == _Y.first && _X.second == _Y.second);
}
template<class _T1, class _T2> inline
bool __cdecl operator!=(const pair<_T1, _T2>& _X,
                        const pair<_T1, _T2>& _Y)
{
    return (!(_X == _Y));
}
template<class _T1, class _T2> inline
bool __cdecl operator<(const pair<_T1, _T2>& _X,
                       const pair<_T1, _T2>& _Y)
{
    return (_X.first < _Y.first ||
            !(_Y.first < _X.first) && _X.second < _Y.second);
}
template<class _T1, class _T2> inline
bool __cdecl operator>(const pair<_T1, _T2>& _X,
                       const pair<_T1, _T2>& _Y)
{
    return (_Y < _X);
}
template<class _T1, class _T2> inline
bool __cdecl operator<=(const pair<_T1, _T2>& _X,
                        const pair<_T1, _T2>& _Y)
{
    return (!(_Y < _X));
}
template<class _T1, class _T2> inline
bool __cdecl operator>=(const pair<_T1, _T2>& _X,
                        const pair<_T1, _T2>& _Y)
{
    return (!(_X < _Y));
}
template<class _T1, class _T2> inline
pair<_T1, _T2> __cdecl make_pair(const _T1& _X, const _T2& _Y)
{
    return (pair<_T1, _T2>(_X, _Y));
}


// ITERATOR TAGS (from <iterator>)
struct input_iterator_tag
{
};
struct output_iterator_tag
{
};
struct forward_iterator_tag
: public input_iterator_tag
{
};
struct bidirectional_iterator_tag
: public forward_iterator_tag
{
};
struct random_access_iterator_tag
: public bidirectional_iterator_tag
{
};


// TEMPLATE CLASS iterator (from <iterator>)
template<class _C, class _Ty, class _D = ptrdiff_t>
struct iterator
{
   typedef _C iterator_category;
   typedef _Ty value_type;
   typedef _D distance_type;
};

template<class _Ty, class _D>
struct _Bidit : public iterator<bidirectional_iterator_tag, _Ty, _D>
{
};

template<class _Ty, class _D>
struct _Ranit : public iterator<random_access_iterator_tag, _Ty, _D>
{
};

// TEMPLATE CLASS iterator_traits (from <iterator>)
template<class _It>
struct iterator_traits
{
   typedef _It::iterator_category iterator_category;
   typedef _It::value_type value_type;
   typedef _It::distance_type distance_type;
};

// TEMPLATE FUNCTION _Iter_cat (from <iterator>)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4700)

template<class _C, class _Ty, class _D>
inline
_C __cdecl _Iter_cat(const iterator<_C, _Ty, _D>&)
{
    _C _X;
    return (_X);
}

template<class _Ty>
inline
random_access_iterator_tag __cdecl _Iter_cat(const _Ty *)
{
    random_access_iterator_tag _X;
    return (_X);
}

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4700)
#endif

// TEMPLATE FUNCTION _Distance
template<class _II>
inline
_CNTSIZ(_II) __cdecl distance(_II _F, _II _L)
{
    _CNTSIZ(_II) _N = 0;
    _Distance(_F, _L, _N, _Iter_cat(_F));
    return (_N);
}

template<class _II, class _D>
inline
void __cdecl _Distance(_II _F, _II _L, _D& _N)
{
    _Distance(_F, _L, _N, _Iter_cat(_F));
}

template<class _II, class _D>
inline
void __cdecl _Distance(_II _F, _II _L, _D& _N, input_iterator_tag)
{
    for (; _F != _L; ++_F)
        ++_N;
}

template<class _II, class _D>
inline
void __cdecl _Distance(_II _F, _II _L, _D& _N, forward_iterator_tag)
{
    for (; _F != _L; ++_F)
        ++_N;
}

template<class _II, class _D>
inline
void __cdecl _Distance(_II _F, _II _L, _D& _N,
                       bidirectional_iterator_tag)
{
    for (; _F != _L; ++_F)
        ++_N;
}

template<class _RI, class _D>
inline
void __cdecl _Distance(_RI _F, _RI _L, _D& _N,
                       random_access_iterator_tag)
{
    _N += (_D)(_L - _F);
}

// TEMPLATE CLASS reverse_iterator (from <iterator>)
template<class _RI, class _Ty, class _Rt = _Ty&, class _Pt = _Ty *,
            class _D = ptrdiff_t>
class reverse_iterator : public _Ranit<_Ty, _D>
{
public:
   typedef reverse_iterator<_RI, _Ty, _Rt, _Pt, _D> _Myt;
   typedef _RI iter_type;
   typedef _Rt reference_type;
   typedef _Pt pointer_type;
   reverse_iterator()
   {
   }
   explicit reverse_iterator(_RI _X)
   : current(_X)
   {
   }
   _RI base() const
   {
       return (current);
   }
   _Rt operator*() const
   {
       return (*(current - 1));
   }
   _Pt operator->() const
   {
       return (&**this);
   }
   _Myt& operator++()
   {
       --current;
       return (*this);
   }
   _Myt operator++(int)
   {
       _Myt _Tmp = *this;
       --current;
       return (_Tmp);
   }
   _Myt& operator--()
   {
       ++current;
       return (*this);
   }
   _Myt operator--(int)
   {
       _Myt _Tmp = *this;
       ++current;
       return (_Tmp);
   }
   _Myt& operator+=(_D _N)
   {
       current -= _N;
       return (*this);
   }
   _Myt operator+(_D _N) const
   {
       return (_Myt(current - _N));
   }
   _Myt& operator-=(_D _N)
   {
       current += _N;
       return (*this);
   }
   _Myt operator-(_D _N) const
   {
       return (_Myt(current + _N));
   }
   _Rt operator[](_D _N) const
   {
       return (*(*this + _N));
   }
protected:
   _RI current;
};

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator==(
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (_X.base() == _Y.base());
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator!=(
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (!(_X == _Y));
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator<(
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (_Y.base() < _X.base());
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator>(
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (_Y < _X);
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator<=(
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (!(_Y < _X));
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator>=(
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (!(_X < _Y));
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
_D __cdecl operator-(
                    const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                    const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (_Y.base() - _X.base());
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
reverse_iterator<_RI, _Ty, _Rt, _Pt, _D> __cdecl operator+(_D _N,
               const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>(
                                                    _Y.base() - _N));
}

/*
// TEMPLATE CLASS istreambuf_iterator (from <iterator>)
template<class _E, class _Tr = char_traits<_E> >
class istreambuf_iterator :
    public iterator<input_iterator_tag, _E, _Tr::off_type>
{
public:
    typedef istreambuf_iterator<_E, _Tr> _Myt;
    typedef _E char_type;
    typedef _Tr traits_type;
    typedef _Tr::int_type int_type;
    typedef basic_streambuf<_E, _Tr> streambuf_type;
    typedef basic_istream<_E, _Tr> istream_type;
    istreambuf_iterator(streambuf_type *_Sb = 0) _THROW0()
    : _Sbuf(_Sb), _Got(_Sb == 0)
    {

    }
    istreambuf_iterator(istream_type& _I) _THROW0()
    : _Sbuf(_I.rdbuf()), _Got(_I.rdbuf() == 0)
    {

    }
    const _E& operator*() const
    {
        if (!_Got)
            ((_Myt *)this)->_Peek();
        return (_Val);
    }
    const _E *operator->() const
    {
        return (&**this);
    }
    _Myt& operator++()
    {
        _Inc();
        return (*this);
    }
    _Myt operator++(int)
    {
        if (!_Got)
            _Peek();
        _Myt _Tmp = *this;
        _Inc();
        return (_Tmp);
    }
    bool equal(const _Myt& _X) const
    {
        if (!_Got)
            ((_Myt *)this)->_Peek();
        if (!_X._Got)
            ((_Myt *)&_X)->_Peek();
        return (_Sbuf == 0 && _X._Sbuf == 0
                || _Sbuf != 0 && _X._Sbuf != 0);
    }
private:
    void _Inc()
    {
        if (_Sbuf == 0
            || _Tr::eq_int_type(_Tr::eof(), _Sbuf->sbumpc()))
            _Sbuf = 0, _Got = true;
        else
            _Got = false;
    }
    _E _Peek()
    {
        int_type _C;
        if (_Sbuf == 0
            || _Tr::eq_int_type(_Tr::eof(), _C = _Sbuf->sgetc()))
            _Sbuf = 0;
        else
            _Val = _Tr::to_char_type(_C);
        _Got = true;
        return (_Val);
    }
    streambuf_type *_Sbuf;
    bool _Got;
    _E _Val;
};
template<class _E, class _Tr> inline
bool __cdecl operator==(const istreambuf_iterator<_E, _Tr>& _X,
                        const istreambuf_iterator<_E, _Tr>& _Y)
{
    return (_X.equal(_Y));
}
template<class _E, class _Tr> inline
bool __cdecl operator!=(const istreambuf_iterator<_E, _Tr>& _X,
                        const istreambuf_iterator<_E, _Tr>& _Y)
{
    return (!(_X == _Y));
}

// TEMPLATE CLASS ostreambuf_iterator (from <iterator>)
template<class _E, class _Tr = char_traits<_E> >
class ostreambuf_iterator :
    public iterator<output_iterator_tag, void, void>
{
    typedef ostreambuf_iterator<_E, _Tr> _Myt;
public:
    typedef _E char_type;
    typedef _Tr traits_type;
    typedef basic_streambuf<_E, _Tr> streambuf_type;
    typedef basic_ostream<_E, _Tr> ostream_type;
    ostreambuf_iterator(streambuf_type *_Sb) _THROW0()
    : _Failed(false), _Sbuf(_Sb)
    {

    }
    ostreambuf_iterator(ostream_type& _O) _THROW0()
    : _Failed(false), _Sbuf(_O.rdbuf())
    {

    }
    _Myt& operator=(_E _X)
    {
        if (_Sbuf == 0
            || _Tr::eq_int_type(_Tr::eof(), _Sbuf->sputc(_X)))
            _Failed = true;
        return (*this);
    }
    _Myt& operator*()
    {
        return (*this);
    }
    _Myt& operator++()
    {
        return (*this);
    }
    _Myt& operator++(int)
    {
        return (*this);
    }
    bool failed() const _THROW0()
    {
        return (_Failed);
    }
private:
    bool _Failed;
    streambuf_type *_Sbuf;
};
*/

// TEMPLATE OPERATORS
namespace rel_ops
{
    template<class _Ty> inline
    bool __cdecl operator!=(const _Ty& _X, const _Ty& _Y)
    {
        return (!(_X == _Y));
    }
    template<class _Ty> inline
    bool __cdecl operator>(const _Ty& _X, const _Ty& _Y)
    {
        return (_Y < _X);
    }
    template<class _Ty> inline
    bool __cdecl operator<=(const _Ty& _X, const _Ty& _Y)
    {
        return (!(_Y < _X));
    }
    template<class _Ty> inline
    bool __cdecl operator>=(const _Ty& _X, const _Ty& _Y)
    {
        return (!(_X < _Y));
    }
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLUTIL_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stlqueue.h ===
#pragma once
#ifndef _STLQUEUE_H_
#define _STLQUEUE_H_
//#include <cstddef>
//#include <functional>
//#include <iterator>
//#include <memory>
//#include <stdexcept>
//#include <xutility>

#include <stlxstdd.h>
#include <stlfunc.h>
#include <stliter.h>
#include <stlmem.h>
#include <stlxutil.h>
#include <stldeque.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN
    // TEMPLATE CLASS queue
template<class _Ty, class _C = deque<_Ty> >
	class queue {
public:
	typedef _C::allocator_type allocator_type;
	typedef _C::value_type value_type;
	typedef _C::size_type size_type;
	explicit queue(const allocator_type& _Al = allocator_type())
		: c(_Al) {}
	allocator_type get_allocator() const
		{return (c.get_allocator()); }
	bool empty() const
		{return (c.empty()); }
	size_type size() const
		{return (c.size()); }
	value_type& front()
		{return (c.front()); }
	const value_type& front() const
		{return (c.front()); }
	value_type& back()
		{return (c.back()); }
	const value_type& back() const
		{return (c.back()); }
	void push(const value_type& _X)
		{c.push_back(_X); }
	void pop()
		{c.pop_front(); }
	bool operator==(const queue<_Ty, _C>& _X) const
		{return (c == _X.c); }
	bool operator!=(const queue<_Ty, _C>& _X) const
		{return (!(*this == _X)); }
	bool operator<(const queue<_Ty, _C>& _X) const
		{return (c < _X.c); }
	bool operator>(const queue<_Ty, _C>& _X) const
		{return (_X < *this); }
	bool operator<=(const queue<_Ty, _C>& _X) const
		{return (!(_X < *this)); }
	bool operator>=(const queue<_Ty, _C>& _X) const
		{return (!(*this < _X)); }
protected:
	_C c;
	};
		// TEMPLATE CLASS priority_queue
template<class _Ty, class _C = vector<_Ty>,
	class _Pr = less<_C::value_type> >
	class priority_queue {
public:
	typedef _C::allocator_type allocator_type;
	typedef _C::value_type value_type;
	typedef _C::size_type size_type;
	explicit priority_queue(const _Pr& _X = _Pr(),
		const allocator_type& _Al = allocator_type())
		: c(_Al), comp(_X) {}
	typedef const value_type *_It;
	priority_queue(_It _F, _It _L, const _Pr& _X = _Pr(),
		const allocator_type& _Al = allocator_type())
		: c(_Al), comp(_X)
		{for (; _F != _L; ++_F)
			push(*_F); }
	allocator_type get_allocator() const
		{return (c.get_allocator()); }
	bool empty() const
		{return (c.empty()); }
	size_type size() const
		{return (c.size()); }
	value_type& top()
		{return (c.front()); }
	const value_type& top() const
		{return (c.front()); }
	void push(const value_type& _X)
		{c.push_back(_X);
		push_heap(c.begin(), c.end(), comp); }
	void pop()
		{pop_heap(c.begin(), c.end(), comp);
		c.pop_back(); }
protected:
	_C c;
	_Pr comp;
	};
_STD_END
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _QUEUE_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stlxstdd.h ===
#pragma once
#ifndef _STLXSTDD_H_
#define _STLXSTDD_H_

//#ifndef _YVALS
//#include <yvals.h>
//#endif
//#include <cstddef>

#include <stddef.h>

/*
// Define _CRTIMP
#ifndef _CRTIMP
#ifdef  CRTDLL2
#define _CRTIMP __declspec(dllexport)
#else   // ndef CRTDLL2
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   // ndef _DLL
#define _CRTIMP
#endif  // _DLL
#endif  // CRTDLL2
#endif  // _CRTIMP
*/

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */


// begin yyvals.h include

#pragma warning(disable: 4244)

//#pragma warning(4: 4018 4114 4146 4244 4245)
//#pragma warning(4: 4663 4664 4665)
//#pragma warning(disable: 4237 4514)

// 4284:
// return type for 'identifier::operator >' is not a UDT or reference to a
// UDT. Will produce errors if applied using infix notation
//
#pragma warning(disable: 4284)

// 4290: C++ Exception Specification ignored
// A function was declared using exception specification.
// At this time the implementation details of exception specification have
// not been standardized, and are accepted but not implemented in Microsoft
// Visual C++.
//
#pragma warning(disable: 4290)



// NAMESPACE
#if defined(__cplusplus)
#define _STD            std::
#define _STD_BEGIN      namespace std {
#define _STD_END        };
#define _STD_USING
#else
#define _STD            ::
#define _STD_BEGIN
#define _STD_END
#endif // __cplusplus

_STD_BEGIN

// TYPE bool
#if defined(__cplusplus)
typedef bool _Bool;
#endif // __cplusplus

// INTEGER PROPERTIES
#define _MAX_EXP_DIG    8   // for parsing numerics
#define _MAX_INT_DIG    32
#define _MAX_SIG_DIG    36

// STDIO PROPERTIES
#define _Filet _iobuf

#ifndef _FPOS_T_DEFINED
#define _FPOSOFF(fp)    ((long)(fp))
#endif // _FPOS_T_DEFINED

// NAMING PROPERTIES
#if defined(__cplusplus)
#define _C_LIB_DECL extern "C" {
#define _END_C_LIB_DECL }
#else
#define _C_LIB_DECL
#define _END_C_LIB_DECL
#endif // __cplusplus
#define _CDECL

/*
// CLASS _Lockit
#if defined(__cplusplus)
class _CRTIMP _Lockit
{   // lock while object in existence
public:
    #ifdef _MT
        #define _LOCKIT(x)  lockit x
        _Lockit();
        ~_Lockit();
    #else
        #define _LOCKIT(x)
        _Lockit()
        {
        }
        ~_Lockit()
        {
        }
    #endif // _MT
};
#endif // __cplusplus
*/

// MISCELLANEOUS MACROS
#define _L(c)   L##c
#define _Mbstinit(x)    mbstate_t x = {0}
#define _MAX    _cpp_max
#define _MIN    _cpp_min

// end yyvals.h include


// EXCEPTION MACROS
//#define _TRY_BEGIN              try {
//#define _CATCH(x)               } catch (x) {
//#define _CATCH_ALL              } catch (...) {
//#define _CATCH_END              }
#define _RAISE(x)               throw (x)
//#define _RERAISE                throw
#define _THROW0()               throw ()
#define _THROW1(x)              throw (x)
#define _THROW(x, y)            throw x(y)

// explicit KEYWORD
// BITMASK MACROS
#define _BITMASK(E, T)          typedef int T
#define _BITMASK_OPS(T)

// MISCELLANEOUS MACROS
#define _DESTRUCTOR(ty, ptr)    (ptr)->~ty()
#define _PROTECTED              public
#define _TDEF(x)                = x
#define _TDEF2(x, y)            = x, y
#define _CNTSIZ(iter)           ptrdiff_t
#define _TDEFP(x)
#define _STCONS(ty, name, val)  enum {name = val}

// TYPE DEFINITIONS
enum _Uninitialized
{
    _Noinit
};

// FUNCTIONS
/*_CRTIMP*/
void __cdecl _Nomemory();

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLXSTDD_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stlvec.h ===
#pragma once
#ifndef _STLVEC_H_
#define _STLVEC_H_
//#include <climits>
//#include <memory>
//#include <stdexcept>

#include <limits.h>
#include <stlmem.h>
#include <stlxutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE CLASS vector
template<class _Ty, class _A = allocator<_Ty> >
class vector
{
public:
    typedef vector<_Ty, _A>     _Myt;
    typedef _A                  allocator_type;
    typedef _A::size_type       size_type;
    typedef _A::difference_type difference_type;
    typedef _A::pointer         _Tptr;
    typedef _A::const_pointer   _Ctptr;
    typedef _A::reference       reference;
    typedef _A::const_reference const_reference;
    typedef _A::value_type      value_type;
    typedef _Tptr               iterator;
    typedef _Ctptr              const_iterator;
    typedef reverse_iterator<const_iterator, value_type, const_reference,
                                _Ctptr, difference_type>
                const_reverse_iterator;

    typedef reverse_iterator<iterator, value_type,reference, _Tptr,
                                difference_type>
                reverse_iterator;

    explicit vector(const _A& _Al = _A())
    : allocator(_Al), _First(0), _Last(0), _End(0)
    {

    }
    explicit vector(size_type _N, const _Ty& _V = _Ty(),
                    const _A& _Al = _A())
    : allocator(_Al)
    {
        _First = allocator.allocate(_N, (void *)0);
        _Ufill(_First, _N, _V);
        _Last = _First + _N;
        _End = _Last;
    }
    vector(const _Myt& _X)
    : allocator(_X.allocator)
    {
        _First = allocator.allocate(_X.size(), (void *)0);
        _Last = _Ucopy(_X.begin(), _X.end(), _First);
        _End = _Last;
    }
    typedef const_iterator _It;
    vector(_It _F, _It _L, const _A& _Al = _A())
    : allocator(_Al), _First(0), _Last(0), _End(0)
    {
        insert(begin(), _F, _L);
    }
    ~vector()
    {
        _Destroy(_First, _Last);
        allocator.deallocate(_First, _End - _First);
        _First = 0, _Last = 0, _End = 0;
    }
    _Myt& operator=(const _Myt& _X)
    {
        if (this == &_X)
            ;
        else if (_X.size() <= size())
        {
            iterator _S = copy(_X.begin(), _X.end(), _First);
            _Destroy(_S, _Last);
            _Last = _First + _X.size();
        }
        else if (_X.size() <= capacity())
        {
            const_iterator _S = _X.begin() + size();
            copy(_X.begin(), _S, _First);
            _Ucopy(_S, _X.end(), _Last);
            _Last = _First + _X.size();
        }
        else
        {
            _Destroy(_First, _Last);
            allocator.deallocate(_First, _End - _First);
            _First = allocator.allocate(_X.size(), (void *)0);
            _Last = _Ucopy(_X.begin(), _X.end(),
                           _First);
            _End = _Last;
        }
        return (*this);
    }
    void reserve(size_type _N)
    {
        if (capacity() < _N)
        {
            iterator _S = allocator.allocate(_N, (void *)0);
            _Ucopy(_First, _Last, _S);
            _Destroy(_First, _Last);
            allocator.deallocate(_First, _End - _First);
            _End = _S + _N;
            _Last = _S + size();
            _First = _S;
        }
    }
    size_type capacity() const
    {
        return (_First == 0 ? 0 : _End - _First);
    }
    iterator begin()
    {
        return (_First);
    }
    const_iterator begin() const
    {
        return ((const_iterator)_First);
    }
    iterator end()
    {
        return (_Last);
    }
    const_iterator end() const
    {
        return ((const_iterator)_Last);
    }
    reverse_iterator rbegin()
    {
        return (reverse_iterator(end()));
    }
    const_reverse_iterator rbegin() const
    {
        return (const_reverse_iterator(end()));
    }
    reverse_iterator rend()
    {
        return (reverse_iterator(begin()));
    }
    const_reverse_iterator rend() const
    {
        return (const_reverse_iterator(begin()));
    }
    void resize(size_type _N, const _Ty& _X = _Ty())
    {
        if (size() < _N)
            insert(end(), _N - size(), _X);
        else if (_N < size())
            erase(begin() + _N, end());
    }
    size_type size() const
    {
        return (_First == 0 ? 0 : _Last - _First);
    }
    size_type max_size() const
    {
        return (allocator.max_size());
    }
    bool empty() const
    {
        return (size() == 0);
    }
    _A get_allocator() const
    {
        return (allocator);
    }
    const_reference at(size_type _P) const
    {
        ASSERT (_P < size());
        return (*(begin() + _P));
    }
    reference at(size_type _P)
    {
        ASSERT (_P < size());
        return (*(begin() + _P));
    }
    const_reference operator[](size_type _P) const
    {
        return (*(begin() + _P));
    }
    reference operator[](size_type _P)
    {
        return (*(begin() + _P));
    }
    reference front()
    {
        return (*begin());
    }
    const_reference front() const
    {
        return (*begin());
    }
    reference back()
    {
        return (*(end() - 1));
    }
    const_reference back() const
    {
        return (*(end() - 1));
    }
    void push_back(const _Ty& _X)
    {
        insert(end(), _X);
    }
    void pop_back()
    {
        erase(end() - 1);
    }
    void assign(_It _F, _It _L)
    {
        erase(begin(), end());
        insert(begin(), _F, _L);
    }
    void assign(size_type _N, const _Ty& _X = _Ty())
    {
        erase(begin(), end());
        insert(begin(), _N, _X);
    }
    iterator insert(iterator _P, const _Ty& _X = _Ty())
    {
        size_type _O = _P - begin();
        insert(_P, 1, _X);
        return (begin() + _O);
    }
    void insert(iterator _P, size_type _M, const _Ty& _X)
    {
        if ((size_type)(_End - _Last) < _M)
        {
            size_type _N = size() + (_M < size() ? size() : _M);
            iterator _S = allocator.allocate(_N, (void *)0);
            iterator _Q = _Ucopy(_First, _P, _S);
            _Ufill(_Q, _M, _X);
            _Ucopy(_P, _Last, _Q + _M);
            _Destroy(_First, _Last);
            allocator.deallocate(_First, _End - _First);
            _End = _S + _N;
            _Last = _S + size() + _M;
            _First = _S;
        }
        else if ((size_type)(_Last - _P) < _M)
        {
            _Ucopy(_P, _Last, _P + _M);
            _Ufill(_Last, _M - (_Last - _P), _X);
            fill(_P, _Last, _X);
            _Last += _M;
        }
        else if (0 < _M)
        {
            _Ucopy(_Last - _M, _Last, _Last);
            copy_backward(_P, _Last - _M, _Last);
            fill(_P, _P + _M, _X);
            _Last += _M;
        }
    }
    void insert(iterator _P, _It _F, _It _L)
    {
        difference_type _M = 0;
        _Distance(_F, _L, _M);
        if (_End - _Last < _M)
        {
            size_type _N = size() + (_M < (difference_type)size() ? size() : _M);
            iterator _S = allocator.allocate(_N, (void *)0);
            iterator _Q = _Ucopy(_First, _P, _S);
            _Q = _Ucopy(_F, _L, _Q);
            _Ucopy(_P, _Last, _Q);
            _Destroy(_First, _Last);
            allocator.deallocate(_First, _End - _First);
            _End = _S + _N;
            _Last = _S + size() + _M;
            _First = _S;
        }
        else if (_Last - _P < _M)
        {
            _Ucopy(_P, _Last, _P + _M);
            _Ucopy(_F + (_Last - _P), _L, _Last);
            copy(_F, _F + (_Last - _P), _P);
            _Last += _M;
        }
        else if (0 < _M)
        {
            _Ucopy(_Last - _M, _Last, _Last);
            copy_backward(_P, _Last - _M, _Last);
            copy(_F, _L, _P);
            _Last += _M;
        }
    }
    iterator erase(iterator _P)
    {
        copy(_P + 1, end(), _P);
        _Destroy(_Last - 1, _Last);
        --_Last;
        return (_P);
    }
    iterator erase(iterator _F, iterator _L)
    {
        iterator _S = copy(_L, end(), _F);
        _Destroy(_S, end());
        _Last = _S;
        return (_F);
    }
    void clear()
    {
        erase(begin(), end());
    }
/*
    bool operator==(const _Myt& _X) const
    {
        return (size() == _X.size()
                && equal(begin(), end(), _X.begin()));
    }
    bool operator!=(const _Myt& _X) const
    {
        return (!(*this == _X));
    }
    bool operator<(const _Myt& _X) const
    {
        return (lexicographical_compare(begin(), end(),
                                        _X.begin(), _X.end()));
    }
    bool operator>(const _Myt& _X) const
    {
        return (_X < *this);
    }
    bool operator<=(const _Myt& _X) const
    {
        return (!(_X < *this));
    }
    bool operator>=(const _Myt& _X) const
    {
        return (!(*this < _X));
    }
*/
    void swap(_Myt& _X)
    {
        if (allocator == _X.allocator)
        {
            std::swap(_First, _X._First);
            std::swap(_Last, _X._Last);
            std::swap(_End, _X._End);
        }
        else
        {
            _Myt _Ts = *this; *this = _X, _X = _Ts;
        }
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
protected:
    void _Destroy(iterator _F, iterator _L)
    {
        for (; _F != _L; ++_F)
            allocator.destroy(_F);
    }
    iterator _Ucopy(const_iterator _F, const_iterator _L,
                    iterator _P)
    {
        for (; _F != _L; ++_P, ++_F)
            allocator.construct(_P, *_F);
        return (_P);
    }
    void _Ufill(iterator _F, size_type _N, const _Ty &_X)
    {
        for (; 0 < _N; --_N, ++_F)
            allocator.construct(_F, _X);
    }
    _A allocator;
    iterator _First, _Last, _End;
};

/*
// CLASS vector<_Bool, allocator>
typedef unsigned int _Vbase;
const int _VBITS = CHAR_BIT * sizeof (_Vbase);
typedef allocator<_Vbase> _Bool_allocator;
class vector<_Bool, _Bool_allocator>
{
public:
    typedef _Bool_allocator _A;
    typedef _Bool _Ty;
    typedef vector<_Ty, _A> _Myt;
    typedef vector<_Vbase, _A> _Vbtype;
    typedef _A allocator_type;
    typedef _A::size_type size_type;
    typedef _A::difference_type difference_type;
    // CLASS reference
    class reference
    {
    public:
        reference()
        : _Mask(0), _Ptr(0)
        {

        }
        reference(size_t _O, _Vbase *_P)
        : _Mask((_Vbase)1 << _O), _Ptr(_P)
        {

        }
        reference& operator=(const reference& _X)
        {
            return (*this = bool(_X));
        }
        reference& operator=(bool _V)
        {
            if (_V)
                *_Ptr |= _Mask;
            else
                *_Ptr &= ~_Mask;
            return (*this);
        }
        void flip()
        {
            *_Ptr ^= _Mask;
        }
        bool operator~() const
        {
            return (!bool(*this));
        }
        operator bool() const
        {
            return ((*_Ptr & _Mask) != 0);
        }
    protected:
        _Vbase _Mask, *_Ptr;
    };
    typedef const reference const_reference;
    typedef bool value_type;
    // CLASS iterator
    class iterator : public _Ranit<_Bool, difference_type>
    {
    public:
        iterator()
        : _Off(0), _Ptr(0)
        {

        }
        iterator(size_t _O, _Vbase *_P)
        : _Off(_O), _Ptr(_P)
        {

        }
        reference operator*() const
        {
            return (reference(_Off, _Ptr));
        }
        iterator& operator++()
        {
            _Inc();
            return (*this);
        }
        iterator operator++(int)
        {
            iterator _Tmp = *this;
            _Inc();
            return (_Tmp);
        }
        iterator& operator--()
        {
            _Dec();
            return (*this);
        }
        iterator operator--(int)
        {
            iterator _Tmp = *this;
            _Dec();
            return (_Tmp);
        }
        iterator& operator+=(difference_type _N)
        {
            _Off += (size_t)_N;
            _Ptr += _Off / _VBITS;
            _Off %= _VBITS;
            return (*this);
        }
        iterator& operator-=(difference_type _N)
        {
            return (*this += -_N);
        }
        iterator operator+(difference_type _N) const
        {
            iterator _Tmp = *this;
            return (_Tmp += _N);
        }
        iterator operator-(difference_type _N) const
        {
            iterator _Tmp = *this;
            return (_Tmp -= _N);
        }
        difference_type operator-(const iterator _X) const
        {
            return (_VBITS * (_Ptr - _X._Ptr)
                    + (difference_type)_Off
                    - (difference_type)_X._Off);
        }
        reference operator[](difference_type _N) const
        {
            return (*(*this + _N));
        }
        bool operator==(const iterator& _X) const
        {
            return (_Ptr == _X._Ptr && _Off == _X._Off);
        }
        bool operator!=(const iterator& _X) const
        {
            return (!(*this == _X));
        }
        bool operator<(const iterator& _X) const
        {
            return (_Ptr < _X._Ptr
                    || _Ptr == _X._Ptr && _Off < _X._Off);
        }
        bool operator>(const iterator& _X) const
        {
            return (_X < *this);
        }
        bool operator<=(const iterator& _X) const
        {
            return (!(_X < *this));
        }
        bool operator>=(const iterator& _X) const
        {
            return (!(*this < _X));
        }
    protected:
        void _Dec()
        {
            if (_Off != 0)
                --_Off;
            else
                _Off = _VBITS - 1, --_Ptr;
        }
        void _Inc()
        {
            if (_Off < _VBITS - 1)
                ++_Off;
            else
                _Off = 0, ++_Ptr;
        }
        size_t _Off;
        _Vbase *_Ptr;
    };
    // CLASS const_iterator
    class const_iterator : public iterator
    {
    public:
        const_iterator()
        : iterator()
        {

        }
        const_iterator(size_t _O, const _Vbase *_P)
        : iterator(_O, (_Vbase *)_P)
        {

        }
        const_iterator(const iterator& _X)
        : iterator(_X)
        {

        }
        const_reference operator*() const
        {
            return (reference(_Off, _Ptr));
        }
        const_iterator& operator++()
        {
            _Inc();
            return (*this);
        }
        const_iterator operator++(int)
        {
            const_iterator _Tmp = *this;
            _Inc();
            return (_Tmp);
        }
        const_iterator& operator--()
        {
            _Dec();
            return (*this);
        }
        const_iterator operator--(int)
        {
            const_iterator _Tmp = *this;
            _Dec();
            return (_Tmp);
        }
        const_iterator& operator+=(difference_type _N)
        {
            _Off += (size_t)_N;
            _Ptr += _Off / _VBITS;
            _Off %= _VBITS;
            return (*this);
        }
        const_iterator& operator-=(difference_type _N)
        {
            return (*this += -_N);
        }
        const_iterator operator+(difference_type _N) const
        {
            const_iterator _Tmp = *this;
            return (_Tmp += _N);
        }
        const_iterator operator-(difference_type _N) const
        {
            const_iterator _Tmp = *this;
            return (_Tmp -= _N);
        }
        difference_type operator-(const const_iterator _X) const
        {
            return (_VBITS * (_Ptr - _X._Ptr)
                    + (difference_type)_Off
                    - (difference_type)_X._Off);
        }
        const_reference operator[](difference_type _N) const
        {
            return (*(*this + _N));
        }
        bool operator==(const const_iterator& _X) const
        {
            return (_Ptr == _X._Ptr && _Off == _X._Off);
        }
        bool operator!=(const const_iterator& _X) const
        {
            return (!(*this == _X));
        }
        bool operator<(const const_iterator& _X) const
        {
            return (_Ptr < _X._Ptr
                    || _Ptr == _X._Ptr && _Off < _X._Off);
        }
        bool operator>(const const_iterator& _X) const
        {
            return (_X < *this);
        }
        bool operator<=(const const_iterator& _X) const
        {
            return (!(_X < *this));
        }
        bool operator>=(const const_iterator& _X) const
        {
            return (!(*this < _X));
        }
    };
    typedef reverse_iterator<const_iterator, value_type,
    const_reference, const_reference *, difference_type>
    const_reverse_iterator;
    typedef reverse_iterator<iterator, value_type,
    reference, reference *, difference_type>
    reverse_iterator;
    explicit vector(const _A& _Al = _A())
    : _Size(0), _Vec(_Al)
    {

    }
    explicit vector(size_type _N, const bool _V = false,
                    const _A& _Al = _A())
    : _Vec(_Nw(_N), _V ? -1 : 0, _Al)
    {
        _Trim(_N);
    }
    typedef const_iterator _It;
    vector(_It _F, _It _L, const _A& _Al = _A())
    : _Size(0), _Vec(_Al)
    {
        insert(begin(), _F, _L);
    }
    ~vector()
    {
        _Size = 0;
    }
    void reserve(size_type _N)
    {
        _Vec.reserve(_Nw(_N));
    }
    size_type capacity() const
    {
        return (_Vec.capacity() * _VBITS);
    }
    iterator begin()
    {
        return (iterator(0, _Vec.begin()));
    }
    const_iterator begin() const
    {
        return (const_iterator(0, _Vec.begin()));
    }
    iterator end()
    {
        iterator _Tmp = begin();
        if (0 < _Size)
            _Tmp += _Size;
        return (_Tmp);
    }
    const_iterator end() const
    {
        const_iterator _Tmp = begin();
        if (0 < _Size)
            _Tmp += _Size;
        return (_Tmp);
    }
    reverse_iterator rbegin()
    {
        return (reverse_iterator(end()));
    }
    const_reverse_iterator rbegin() const
    {
        return (const_reverse_iterator(end()));
    }
    reverse_iterator rend()
    {
        return (reverse_iterator(begin()));
    }
    const_reverse_iterator rend() const
    {
        return (const_reverse_iterator(begin()));
    }
    void resize(size_type _N, bool _X = false)
    {
        if (size() < _N)
            insert(end(), _N - size(), _X);
        else if (_N < size())
            erase(begin() + _N, end());
    }
    size_type size() const
    {
        return (_Size);
    }
    size_type max_size() const
    {
        return (_Vec.max_size() * _VBITS);
    }
    bool empty() const
    {
        return (size() == 0);
    }
    _A get_allocator() const
    {
        return (_Vec.get_allocator());
    }
    const_reference at(size_type _P) const
    {
        if (size() <= _P)
            _Xran();
        return (*(begin() + _P));
    }
    reference at(size_type _P)
    {
        if (size() <= _P)
            _Xran();
        return (*(begin() + _P));
    }
    const_reference operator[](size_type _P) const
    {
        return (*(begin() + _P));
    }
    reference operator[](size_type _P)
    {
        return (*(begin() + _P));
    }
    reference front()
    {
        return (*begin());
    }
    const_reference front() const
    {
        return (*begin());
    }
    reference back()
    {
        return (*(end() - 1));
    }
    const_reference back() const
    {
        return (*(end() - 1));
    }
    void push_back(const bool _X)
    {
        insert(end(), _X);
    }
    void pop_back()
    {
        erase(end() - 1);
    }
    void assign(_It _F, _It _L)
    {
        erase(begin(), end());
        insert(begin(), _F, _L);
    }
    void assign(size_type _N, const bool _X = false)
    {
        erase(begin(), end());
        insert(begin(), _N, _X);
    }
    iterator insert(iterator _P, const bool _X = false)
    {
        size_type _O = _P - begin();
        insert(_P, 1, _X);
        return (begin() + _O);
    }
    void insert(iterator _P, size_type _M, const bool _X)
    {
        if (0 < _M)
        {
            if (capacity() - size() < _M)
            {
                size_type _O = _P - begin();
                _Vec.resize(_Nw(size() + _M), 0);
                _P = begin() + _O;
            }
            copy_backward(_P, end(), end() + _M);
            fill(_P, _P + _M, _X);
            _Size += _M;
        }
    }
    void insert(iterator _P, _It _F, _It _L)
    {
        size_type _M = 0;
        _Distance(_F, _L, _M);
        if (0 < _M)
        {
            if (capacity() - size() < _M)
            {
                size_type _O = _P - begin();
                _Vec.resize(_Nw(size() + _M), 0);
                _P = begin() + _O;
            }
            copy_backward(_P, end(), end() + _M);
            copy(_F, _L, _P);
            _Size += _M;
        }
    }
    iterator erase(iterator _P)
    {
        copy(_P + 1, end(), _P);
        _Trim(_Size - 1);
        return (_P);
    }
    iterator erase(iterator _F, iterator _L)
    {
        iterator _S = copy(_L, end(), _F);
        _Trim(_S - begin());
        return (_F);
    }
    void clear()
    {
        erase(begin(), end());
    }
    void flip()
    {
        for (_Vbtype::iterator _S = _Vec.begin();
            _S != _Vec.end(); ++_S)
            *_S = ~*_S;
        _Trim(_Size);
    }
    bool operator==(const _Myt& _X) const
    {
        return (_Size == _X._Size && _Vec == _X._Vec);
    }
    bool operator!=(const _Myt& _X) const
    {
        return (!(*this == _X));
    }
    bool operator<(const _Myt& _X) const
    {
        return (_Size < _X._Size
                || _Size == _X._Size && _Vec < _X._Vec);
    }
    bool operator>(const _Myt& _X) const
    {
        return (_X < *this);
    }
    bool operator<=(const _Myt& _X) const
    {
        return (!(_X < *this));
    }
    bool operator>=(const _Myt& _X) const
    {
        return (!(*this < _X));
    }
    void swap(_Myt& _X)
    {
        std::swap(_Size, _X._Size);
        _Vec.swap(_X._Vec);
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
    static void swap(reference _X, reference _Y)
    {
        bool _V = _X;
        _X = _Y;
        _Y = _V;
    }
protected:
    static size_type _Nw(size_type _N)
    {
        return ((_N + _VBITS - 1) / _VBITS);
    }
    void _Trim(size_type _N)
    {
        size_type _M = _Nw(_N);
        if (_M < _Vec.size())
            _Vec.erase(_Vec.begin() + _M, _Vec.end());
        _Size = _N;
        _N %= _VBITS;
        if (0 < _N)
            _Vec[_M - 1] &= ((_Vbase)1 << _N) - 1;
    }
    void _Xran() const
    {
        _THROW(out_of_range, "invalid vector<bool> subscript");
    }
    size_type _Size;
    _Vbtype _Vec;
};
typedef vector<_Bool, _Bool_allocator> _Bvector;
*/

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLVEC_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stlxtree.h ===
#pragma once
#ifndef _STLTREE_H_
#define _STLTREE_H_
//#include <cstddef>
//#include <iterator>
//#include <memory>
//#include <xutility>

#include <stddef.h>
#include <stliter.h>
#include <stlmem.h>
#include <stlxutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE CLASS _Tree
template<class _K, class _Ty, class _Kfn, class _Pr, class _A>
class _Tree
{
protected:
    typedef _POINTER_X(void, _A) _Genptr;
    enum _Redbl
    {
        _Red, _Black
    };
    struct _Node;
    friend struct _Node;
    struct _Node
    {
        _Genptr _Left, _Parent, _Right;
        _Ty _Value;
        _Redbl _Color;
    };
    typedef _POINTER_X(_Node, _A) _Nodeptr;
    typedef _REFERENCE_X(_Nodeptr, _A) _Nodepref;
    typedef _REFERENCE_X(const _K, _A) _Keyref;
    typedef _REFERENCE_X(_Redbl, _A) _Rbref;
    typedef _REFERENCE_X(_Ty, _A) _Vref;
    static _Rbref _Color(_Nodeptr _P)
    {
        return ((_Rbref)(*_P)._Color);
    }
    static _Keyref _Key(_Nodeptr _P)
    {
        return (_Kfn()(_Value(_P)));
    }
    static _Nodepref _Left(_Nodeptr _P)
    {
        return ((_Nodepref)(*_P)._Left);
    }
    static _Nodepref _Parent(_Nodeptr _P)
    {
        return ((_Nodepref)(*_P)._Parent);
    }
    static _Nodepref _Right(_Nodeptr _P)
    {
        return ((_Nodepref)(*_P)._Right);
    }
    static _Vref _Value(_Nodeptr _P)
    {
        return ((_Vref)(*_P)._Value);
    }
public:
    typedef _Tree<_K, _Ty, _Kfn, _Pr, _A> _Myt;
    typedef _K key_type;
    typedef _Ty value_type;
    typedef _A::size_type size_type;
    typedef _A::difference_type difference_type;
    typedef _POINTER_X(_Ty, _A) _Tptr;
    typedef _POINTER_X(const _Ty, _A) _Ctptr;
    typedef _REFERENCE_X(_Ty, _A) reference;
    typedef _REFERENCE_X(const _Ty, _A) const_reference;
    // CLASS iterator
    class iterator;
    friend class iterator;
    class iterator : public _Bidit<_Ty, difference_type>
    {
    public:
        iterator()
        {
        }
        iterator(_Nodeptr _P) : _Ptr(_P)
        {
        }
        reference operator*() const
        {
            return (_Value(_Ptr));
        }
        _Tptr operator->() const
        {
            return (&**this);
        }
        iterator& operator++()
        {
            _Inc();
            return (*this);
        }
        iterator operator++(int)
        {
            iterator _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        iterator& operator--()
        {
            _Dec();
            return (*this);
        }
        iterator operator--(int)
        {
            iterator _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        bool operator==(const iterator& _X) const
        {
            return (_Ptr == _X._Ptr);
        }
        bool operator!=(const iterator& _X) const
        {
            return (!(*this == _X));
        }
        void _Dec()
        {
            //_Lockit _Lk;
            if (_Color(_Ptr) == _Red
                && _Parent(_Parent(_Ptr)) == _Ptr)
                _Ptr = _Right(_Ptr);
            else if (_Left(_Ptr) != _Nil)
                _Ptr = _Max(_Left(_Ptr));
            else
            {
                _Nodeptr _P;
                while (_Ptr == _Left(_P = _Parent(_Ptr)))
                    _Ptr = _P;
                _Ptr = _P;
            }
        }
        void _Inc()
        {
            //_Lockit _Lk;
            if (_Right(_Ptr) != _Nil)
                _Ptr = _Min(_Right(_Ptr));
            else
            {
                _Nodeptr _P;
                while (_Ptr == _Right(_P = _Parent(_Ptr)))
                    _Ptr = _P;
                if (_Right(_Ptr) != _P)
                    _Ptr = _P;
            }
        }
        _Nodeptr _Mynode() const
        {
            return (_Ptr);
        }
    protected:
        _Nodeptr _Ptr;
    };
    // CLASS const_iterator
    class const_iterator;
    friend class const_iterator;
    class const_iterator : public iterator
    {
    public:
        const_iterator()
        {

        }
        const_iterator(_Nodeptr _P)
        : iterator(_P)
        {

        }
        const_iterator(const iterator& _X)
        : iterator(_X)
        {

        }
        const_reference operator*() const
        {
            return (_Value(_Ptr));
        }
        _Ctptr operator->() const
        {
            return (&**this);
        }
        const_iterator& operator++()
        {
            _Inc();
            return (*this);
        }
        const_iterator operator++(int)
        {
            iterator _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        const_iterator& operator--()
        {
            _Dec();
            return (*this);
        }
        const_iterator operator--(int)
        {
            iterator _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        bool operator==(const const_iterator& _X) const
        {
            return (_Ptr == _X._Ptr);
        }
        bool operator!=(const const_iterator& _X) const
        {
            return (!(*this == _X));
        }
    };
    typedef reverse_bidirectional_iterator<iterator,
    value_type, reference, _Tptr, difference_type>
    reverse_iterator;
    typedef reverse_bidirectional_iterator<const_iterator,
    value_type, const_reference, _Ctptr, difference_type>
    const_reverse_iterator;
    typedef pair<iterator, bool> _Pairib;
    typedef pair<iterator, iterator> _Pairii;
    typedef pair<const_iterator, const_iterator> _Paircc;
    explicit _Tree(const _Pr& _Parg, bool _Marg = true,
                   const _A& _Al = _A())
    : allocator(_Al),
    key_compare(_Parg), _Multi(_Marg)
    {
        _Init();
    }
    _Tree(const _Ty *_F, const _Ty *_L,
          const _Pr& _Parg, bool _Marg = true,
          const _A& _Al = _A())
    : allocator(_Al),
    key_compare(_Parg), _Multi(_Marg)
    {
        _Init();
        insert(_F, _L);
    }
    _Tree(const _Myt& _X)
    : allocator(_X.allocator),
    key_compare(_X.key_compare), _Multi(_X._Multi)
    {
        _Init();
        _Copy(_X);
    }
    ~_Tree()
    {
        erase(begin(), end());
        _Freenode(_Head);
        _Head = 0, _Size = 0;
        {
            //_Lockit _Lk;
            if (--_Nilrefs == 0)
            {
                _Freenode(_Nil);
                _Nil = 0;
            }
        }
    }
    _Myt& operator=(const _Myt& _X)
    {
        if (this != &_X)
        {
            erase(begin(), end());
            key_compare = _X.key_compare;
            _Copy(_X);
        }
        return (*this);
    }
    iterator begin()
    {
        return (iterator(_Lmost()));
    }
    const_iterator begin() const
    {
        return (const_iterator(_Lmost()));
    }
    iterator end()
    {
        return (iterator(_Head));
    }
    const_iterator end() const
    {
        return (const_iterator(_Head));
    }
    reverse_iterator rbegin()
    {
        return (reverse_iterator(end()));
    }
    const_reverse_iterator rbegin() const
    {
        return (const_reverse_iterator(end()));
    }
    reverse_iterator rend()
    {
        return (reverse_iterator(begin()));
    }
    const_reverse_iterator rend() const
    {
        return (const_reverse_iterator(begin()));
    }
    size_type size() const
    {
        return (_Size);
    }
    size_type max_size() const
    {
        return (allocator.max_size());
    }
    bool empty() const
    {
        return (size() == 0);
    }
    _A get_allocator() const
    {
        return (allocator);
    }
    _Pr key_comp() const
    {
        return (key_compare);
    }
    _Pairib insert(const value_type& _V)
    {
        _Nodeptr _X = _Root();
        _Nodeptr _Y = _Head;
        bool _Ans = true;
        {
            //_Lockit Lk;
            while (_X != _Nil)
            {
                _Y = _X;
                _Ans = key_compare(_Kfn()(_V), _Key(_X));
                _X = _Ans ? _Left(_X) : _Right(_X);
            }
        }
        if (_Multi)
            return (_Pairib(_Insert(_X, _Y, _V), true));
        iterator _P = iterator(_Y);
        if (!_Ans)
            ;
        else if (_P == begin())
            return (_Pairib(_Insert(_X, _Y, _V), true));
        else
            --_P;
        if (key_compare(_Key(_P._Mynode()), _Kfn()(_V)))
            return (_Pairib(_Insert(_X, _Y, _V), true));
        return (_Pairib(_P, false));
    }
    iterator insert(iterator _P, const value_type& _V)
    {
        if (size() == 0)
            ;
        else if (_P == begin())
        {
            if (key_compare(_Kfn()(_V), _Key(_P._Mynode())))
                return (_Insert(_Head, _P._Mynode(), _V));
        }
        else if (_P == end())
        {
            //_Lockit Lk;
            if (key_compare(_Key(_Rmost()), _Kfn()(_V)))
                return (_Insert(_Nil, _Rmost(), _V));
        }
        else
        {
            iterator _Pb = _P;
            if (key_compare(_Key((--_Pb)._Mynode()), _Kfn()(_V))
                && key_compare(_Kfn()(_V), _Key(_P._Mynode())))
            {
                //_Lockit _Lk;
                if (_Right(_Pb._Mynode()) == _Nil)
                    return (_Insert(_Nil, _Pb._Mynode(), _V));
                else
                    return (_Insert(_Head, _P._Mynode(), _V));
            }
        }
        return (insert(_V).first);
    }
    void insert(iterator _F, iterator _L)
    {
        for (; _F != _L; ++_F)
            insert(*_F);
    }
    void insert(const value_type *_F, const value_type *_L)
    {
        for (; _F != _L; ++_F)
            insert(*_F);
    }
    iterator erase(iterator _P)
    {
        _Nodeptr _X;
        _Nodeptr _Y = (_P++)._Mynode();
        _Nodeptr _Z = _Y;
        //_Lockit _Lk;
        if (_Left(_Y) == _Nil)
            _X = _Right(_Y);
        else if (_Right(_Y) == _Nil)
            _X = _Left(_Y);
        else
            _Y = _Min(_Right(_Y)), _X = _Right(_Y);
        if (_Y != _Z)
        {
            _Parent(_Left(_Z)) = _Y;
            _Left(_Y) = _Left(_Z);
            if (_Y == _Right(_Z))
                _Parent(_X) = _Y;
            else
            {
                _Parent(_X) = _Parent(_Y);
                _Left(_Parent(_Y)) = _X;
                _Right(_Y) = _Right(_Z);
                _Parent(_Right(_Z)) = _Y;
            }
            if (_Root() == _Z)
                _Root() = _Y;
            else if (_Left(_Parent(_Z)) == _Z)
                _Left(_Parent(_Z)) = _Y;
            else
                _Right(_Parent(_Z)) = _Y;
            _Parent(_Y) = _Parent(_Z);
            std::swap(_Color(_Y), _Color(_Z));
            _Y = _Z;
        }
        else
        {
            _Parent(_X) = _Parent(_Y);
            if (_Root() == _Z)
                _Root() = _X;
            else if (_Left(_Parent(_Z)) == _Z)
                _Left(_Parent(_Z)) = _X;
            else
                _Right(_Parent(_Z)) = _X;
            if (_Lmost() != _Z)
                ;
            else if (_Right(_Z) == _Nil)
                _Lmost() = _Parent(_Z);
            else
                _Lmost() = _Min(_X);
            if (_Rmost() != _Z)
                ;
            else if (_Left(_Z) == _Nil)
                _Rmost() = _Parent(_Z);
            else
                _Rmost() = _Max(_X);
        }
        if (_Color(_Y) == _Black)
        {
            while (_X != _Root() && _Color(_X) == _Black)
                if (_X == _Left(_Parent(_X)))
                {
                    _Nodeptr _W = _Right(_Parent(_X));
                    if (_Color(_W) == _Red)
                    {
                        _Color(_W) = _Black;
                        _Color(_Parent(_X)) = _Red;
                        _Lrotate(_Parent(_X));
                        _W = _Right(_Parent(_X));
                    }
                    if (_Color(_Left(_W)) == _Black
                        && _Color(_Right(_W)) == _Black)
                    {
                        _Color(_W) = _Red;
                        _X = _Parent(_X);
                    }
                    else
                    {
                        if (_Color(_Right(_W)) == _Black)
                        {
                            _Color(_Left(_W)) = _Black;
                            _Color(_W) = _Red;
                            _Rrotate(_W);
                            _W = _Right(_Parent(_X));
                        }
                        _Color(_W) = _Color(_Parent(_X));
                        _Color(_Parent(_X)) = _Black;
                        _Color(_Right(_W)) = _Black;
                        _Lrotate(_Parent(_X));
                        break;
                    }
                }
                else
                {
                    _Nodeptr _W = _Left(_Parent(_X));
                    if (_Color(_W) == _Red)
                    {
                        _Color(_W) = _Black;
                        _Color(_Parent(_X)) = _Red;
                        _Rrotate(_Parent(_X));
                        _W = _Left(_Parent(_X));
                    }
                    if (_Color(_Right(_W)) == _Black
                        && _Color(_Left(_W)) == _Black)
                    {
                        _Color(_W) = _Red;
                        _X = _Parent(_X);
                    }
                    else
                    {
                        if (_Color(_Left(_W)) == _Black)
                        {
                            _Color(_Right(_W)) = _Black;
                            _Color(_W) = _Red;
                            _Lrotate(_W);
                            _W = _Left(_Parent(_X));
                        }
                        _Color(_W) = _Color(_Parent(_X));
                        _Color(_Parent(_X)) = _Black;
                        _Color(_Left(_W)) = _Black;
                        _Rrotate(_Parent(_X));
                        break;
                    }
                }
            _Color(_X) = _Black;
        }
        _Destval(&_Value(_Y));
        _Freenode(_Y);
        --_Size;
        return (_P);
    }
    iterator erase(iterator _F, iterator _L)
    {
        if (size() == 0 || _F != begin() || _L != end())
        {
            while (_F != _L)
                erase(_F++);
            return (_F);
        }
        else
        {
            //_Lockit Lk;
            _Erase(_Root());
            _Root() = _Nil, _Size = 0;
            _Lmost() = _Head, _Rmost() = _Head;
            return (begin());
        }
    }
    size_type erase(const _K& _X)
    {
        _Pairii _P = equal_range(_X);
        size_type _N = 0;
        _Distance(_P.first, _P.second, _N);
        erase(_P.first, _P.second);
        return (_N);
    }
    void erase(const _K *_F, const _K *_L)
    {
        for (; _F != _L; ++_F)
            erase(*_F);
    }
    void clear()
    {
        erase(begin(), end());
    }
    iterator find(const _K& _Kv)
    {
        iterator _P = lower_bound(_Kv);
        return (_P == end()
                || key_compare(_Kv, _Key(_P._Mynode()))
                ? end() : _P);
    }
    const_iterator find(const _K& _Kv) const
    {
        const_iterator _P = lower_bound(_Kv);
        return (_P == end()
                || key_compare(_Kv, _Key(_P._Mynode()))
                ? end() : _P);
    }
    size_type count(const _K& _Kv) const
    {
        _Paircc _Ans = equal_range(_Kv);
        size_type _N = 0;
        _Distance(_Ans.first, _Ans.second, _N);
        return (_N);
    }
    iterator lower_bound(const _K& _Kv)
    {
        return (iterator(_Lbound(_Kv)));
    }
    const_iterator lower_bound(const _K& _Kv) const
    {
        return (const_iterator(_Lbound(_Kv)));
    }
    iterator upper_bound(const _K& _Kv)
    {
        return (iterator(_Ubound(_Kv)));
    }
    const_iterator upper_bound(const _K& _Kv) const
    {
        return (iterator(_Ubound(_Kv)));
    }
    _Pairii equal_range(const _K& _Kv)
    {
        return (_Pairii(lower_bound(_Kv), upper_bound(_Kv)));
    }
    _Paircc equal_range(const _K& _Kv) const
    {
        return (_Paircc(lower_bound(_Kv), upper_bound(_Kv)));
    }
    void swap(_Myt& _X)
    {
        std::swap(key_compare, _X.key_compare);
        if (allocator == _X.allocator)
        {
            std::swap(_Head, _X._Head);
            std::swap(_Multi, _X._Multi);
            std::swap(_Size, _X._Size);
        }
        else
        {
            _Myt _Ts = *this; *this = _X, _X = _Ts;
        }
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
protected:
    static _Nodeptr _Nil;
    static size_t _Nilrefs;
    void _Copy(const _Myt& _X)
    {
        //_Lockit _Lk;
        _Root() = _Copy(_X._Root(), _Head);
        _Size = _X.size();
        if (_Root() != _Nil)
        {
            _Lmost() = _Min(_Root());
            _Rmost() = _Max(_Root());
        }
        else
            _Lmost() = _Head, _Rmost() = _Head;
    }
    _Nodeptr _Copy(_Nodeptr _X, _Nodeptr _P)
    {
        //_Lockit _Lk;
        _Nodeptr _R = _X;
        for (; _X != _Nil; _X = _Left(_X))
        {
            _Nodeptr _Y = _Buynode(_P, _Color(_X));
            if (_R == _X)
                _R = _Y;
            _Right(_Y) = _Copy(_Right(_X), _Y);
            _Consval(&_Value(_Y), _Value(_X));
            _Left(_P) = _Y;
            _P = _Y;
        }
        _Left(_P) = _Nil;
        return (_R);
    }
    void _Erase(_Nodeptr _X)
    {
        //_Lockit _Lk;
        for (_Nodeptr _Y = _X; _Y != _Nil; _X = _Y)
        {
            _Erase(_Right(_Y));
            _Y = _Left(_Y);
            _Destval(&_Value(_X));
            _Freenode(_X);
        }
    }
    void _Init()
    {
        //_Lockit _Lk;
        if (_Nil == 0)
        {
            _Nil = _Buynode(0, _Black);
            _Left(_Nil) = 0, _Right(_Nil) = 0;
        }
        ++_Nilrefs;
        _Head = _Buynode(_Nil, _Red), _Size = 0;
        _Lmost() = _Head, _Rmost() = _Head;
    }
    iterator _Insert(_Nodeptr _X, _Nodeptr _Y, const _Ty& _V)
    {
        //_Lockit _Lk;
        _Nodeptr _Z = _Buynode(_Y, _Red);
        _Left(_Z) = _Nil, _Right(_Z) = _Nil;
        _Consval(&_Value(_Z), _V);
        ++_Size;
        if (_Y == _Head || _X != _Nil
            || key_compare(_Kfn()(_V), _Key(_Y)))
        {
            _Left(_Y) = _Z;
            if (_Y == _Head)
            {
                _Root() = _Z;
                _Rmost() = _Z;
            }
            else if (_Y == _Lmost())
                _Lmost() = _Z;
        }
        else
        {
            _Right(_Y) = _Z;
            if (_Y == _Rmost())
                _Rmost() = _Z;
        }
        for (_X = _Z; _X != _Root()
            && _Color(_Parent(_X)) == _Red; )
            if (_Parent(_X) == _Left(_Parent(_Parent(_X))))
            {
                _Y = _Right(_Parent(_Parent(_X)));
                if (_Color(_Y) == _Red)
                {
                    _Color(_Parent(_X)) = _Black;
                    _Color(_Y) = _Black;
                    _Color(_Parent(_Parent(_X))) = _Red;
                    _X = _Parent(_Parent(_X));
                }
                else
                {
                    if (_X == _Right(_Parent(_X)))
                    {
                        _X = _Parent(_X);
                        _Lrotate(_X);
                    }
                    _Color(_Parent(_X)) = _Black;
                    _Color(_Parent(_Parent(_X))) = _Red;
                    _Rrotate(_Parent(_Parent(_X)));
                }
            }
            else
            {
                _Y = _Left(_Parent(_Parent(_X)));
                if (_Color(_Y) == _Red)
                {
                    _Color(_Parent(_X)) = _Black;
                    _Color(_Y) = _Black;
                    _Color(_Parent(_Parent(_X))) = _Red;
                    _X = _Parent(_Parent(_X));
                }
                else
                {
                    if (_X == _Left(_Parent(_X)))
                    {
                        _X = _Parent(_X);
                        _Rrotate(_X);
                    }
                    _Color(_Parent(_X)) = _Black;
                    _Color(_Parent(_Parent(_X))) = _Red;
                    _Lrotate(_Parent(_Parent(_X)));
                }
            }
        _Color(_Root()) = _Black;
        return (iterator(_Z));
    }
    _Nodeptr _Lbound(const _K& _Kv) const
    {
        //_Lockit _Lk;
        _Nodeptr _X = _Root();
        _Nodeptr _Y = _Head;
        while (_X != _Nil)
            if (key_compare(_Key(_X), _Kv))
                _X = _Right(_X);
            else
                _Y = _X, _X = _Left(_X);
        return (_Y);
    }
    _Nodeptr& _Lmost()
    {
        return (_Left(_Head));
    }
    _Nodeptr& _Lmost() const
    {
        return (_Left(_Head));
    }
    void _Lrotate(_Nodeptr _X)
    {
        //_Lockit _Lk;
        _Nodeptr _Y = _Right(_X);
        _Right(_X) = _Left(_Y);
        if (_Left(_Y) != _Nil)
            _Parent(_Left(_Y)) = _X;
        _Parent(_Y) = _Parent(_X);
        if (_X == _Root())
            _Root() = _Y;
        else if (_X == _Left(_Parent(_X)))
            _Left(_Parent(_X)) = _Y;
        else
            _Right(_Parent(_X)) = _Y;
        _Left(_Y) = _X;
        _Parent(_X) = _Y;
    }
    static _Nodeptr _Max(_Nodeptr _P)
    {
        //_Lockit _Lk;
        while (_Right(_P) != _Nil)
            _P = _Right(_P);
        return (_P);
    }
    static _Nodeptr _Min(_Nodeptr _P)
    {
        //_Lockit _Lk;
        while (_Left(_P) != _Nil)
            _P = _Left(_P);
        return (_P);
    }
    _Nodeptr& _Rmost()
    {
        return (_Right(_Head));
    }
    _Nodeptr& _Rmost() const
    {
        return (_Right(_Head));
    }
    _Nodeptr& _Root()
    {
        return (_Parent(_Head));
    }
    _Nodeptr& _Root() const
    {
        return (_Parent(_Head));
    }
    void _Rrotate(_Nodeptr _X)
    {
        //_Lockit _Lk;
        _Nodeptr _Y = _Left(_X);
        _Left(_X) = _Right(_Y);
        if (_Right(_Y) != _Nil)
            _Parent(_Right(_Y)) = _X;
        _Parent(_Y) = _Parent(_X);
        if (_X == _Root())
            _Root() = _Y;
        else if (_X == _Right(_Parent(_X)))
            _Right(_Parent(_X)) = _Y;
        else
            _Left(_Parent(_X)) = _Y;
        _Right(_Y) = _X;
        _Parent(_X) = _Y;
    }
    _Nodeptr _Ubound(const _K& _Kv) const
    {
        //_Lockit _Lk;
        _Nodeptr _X = _Root();
        _Nodeptr _Y = _Head;
        while (_X != _Nil)
            if (key_compare(_Kv, _Key(_X)))
                _Y = _X, _X = _Left(_X);
            else
                _X = _Right(_X);
        return (_Y);
    }
    _Nodeptr _Buynode(_Nodeptr _Parg, _Redbl _Carg)
    {
        _Nodeptr _S = (_Nodeptr)allocator._Charalloc(
                                                    1 * sizeof (_Node));
        _Parent(_S) = _Parg;
        _Color(_S) = _Carg;
        return (_S);
    }
    void _Consval(_Tptr _P, const _Ty& _V)
    {
        _Construct(&*_P, _V);
    }
    void _Destval(_Tptr _P)
    {
        _Destroy(&*_P);
    }
    void _Freenode(_Nodeptr _S)
    {
        allocator.deallocate(_S, 1);
    }
    _A          allocator;
    _Pr         key_compare;
    _Nodeptr    _Head;
    bool        _Multi;
    size_type   _Size;
};

template<class _K, class _Ty, class _Kfn, class _Pr, class _A>
_Tree<_K, _Ty, _Kfn, _Pr, _A>::_Nodeptr
_Tree<_K, _Ty, _Kfn, _Pr, _A>::_Nil = 0;

template<class _K, class _Ty, class _Kfn, class _Pr, class _A>
size_t _Tree<_K, _Ty, _Kfn, _Pr, _A>::_Nilrefs = 0;

// tree TEMPLATE OPERATORS
template<class _K, class _Ty, class _Kfn,
class _Pr, class _A> inline
bool operator==(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,
                const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
{
    return (_X.size() == _Y.size()
            && equal(_X.begin(), _X.end(), _Y.begin()));
}
template<class _K, class _Ty, class _Kfn,
class _Pr, class _A> inline
bool operator!=(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,
                const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
{
    return (!(_X == _Y));
}
template<class _K, class _Ty, class _Kfn,
class _Pr, class _A> inline
bool operator<(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,
               const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
{
    return (lexicographical_compare(_X.begin(), _X.end(),
                                    _Y.begin(), _Y.end()));
}
template<class _K, class _Ty, class _Kfn,
class _Pr, class _A> inline
bool operator>(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,
               const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
{
    return (_Y < _X);
}
template<class _K, class _Ty, class _Kfn,
class _Pr, class _A> inline
bool operator<=(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,
                const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
{
    return (!(_Y < _X));
}
template<class _K, class _Ty, class _Kfn,
class _Pr, class _A> inline
bool operator>=(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,
                const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
{
    return (!(_X < _Y));
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLTREE_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stlxmem.h ===
#pragma once
#ifndef _STLXMEM_H_
#define _STLXMEM_H_
//#include <cstdlib>
//#include <new>
//#include <utility>

#include <stdlib.h>
#include <stlnew.h>
#include <stlutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifndef _FARQ   /* specify standard memory model */
#define _FARQ
#define _PDFT  ptrdiff_t
#define _SIZT  size_t
#endif
#define _POINTER_X(T, A)   T _FARQ *
#define _REFERENCE_X(T, A) T _FARQ &

_STD_BEGIN

// TEMPLATE FUNCTION _Allocate
template<class _Ty> inline
_Ty _FARQ *_Allocate(_PDFT _N, _Ty _FARQ *)
{
    if (_N < 0)
        _N = 0;
    return ((_Ty _FARQ *)operator new((_SIZT)_N * sizeof (_Ty), raiseexception));
}

// TEMPLATE FUNCTION _Construct
template<class _T1, class _T2> inline
void _Construct(_T1 _FARQ *_P, const _T2& _V)
{
    new ((void _FARQ *)_P) _T1(_V);
}

// TEMPLATE FUNCTION _Destroy
template<class _Ty> inline
void _Destroy(_Ty _FARQ *_P)
{
    _DESTRUCTOR(_Ty, _P);
}
inline void _Destroy(char _FARQ *_P)
{

}
inline void _Destroy(wchar_t _FARQ *_P)
{

}

// TEMPLATE CLASS allocator
template<class _Ty>
class allocator
{
public:
    typedef _SIZT size_type;
    typedef _PDFT difference_type;
    typedef _Ty _FARQ *pointer;
    typedef const _Ty _FARQ *const_pointer;
    typedef _Ty _FARQ& reference;
    typedef const _Ty _FARQ& const_reference;
    typedef _Ty value_type;
    pointer address(reference _X) const
    {
        return (&_X);
    }
    const_pointer address(const_reference _X) const
    {
        return (&_X);
    }
    pointer allocate(size_type _N, const void *)
    {
        return (_Allocate((difference_type)_N, (pointer)0));
    }
    char _FARQ *_Charalloc(size_type _N)
    {
        return (_Allocate((difference_type)_N, (char _FARQ *)0));
    }
    void deallocate(void _FARQ *_P, size_type)
    {
        operator delete(_P);
    }
    void construct(pointer _P, const _Ty& _V)
    {
        _Construct(_P, _V);
    }
    void destroy(pointer _P)
    {
        _Destroy(_P);
    }
    _SIZT max_size() const
    {
        _SIZT _N = (_SIZT)(-1) / sizeof (_Ty);
        return (0 < _N ? _N : 1);
    }
};
template<class _Ty, class _U> inline
bool operator==(const allocator<_Ty>&, const allocator<_U>&)
{
    return (true);
}
template<class _Ty, class _U> inline
bool operator!=(const allocator<_Ty>&, const allocator<_U>&)
{
    return (false);
}

// CLASS allocator<void>
class /*_CRTIMP*/ allocator<void>
{
public:
    typedef void _Ty;
    typedef _Ty _FARQ *pointer;
    typedef const _Ty _FARQ *const_pointer;
    typedef _Ty value_type;
};

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLXMEM_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\tracetag.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E T A G . H
//
//  Contents:   Trace tag definitions for the Netcfg project
//
//  Notes:      B-flat, C-sharp
//
//  Author:     jeffspr   9 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _TRACETAG_H_
#define _TRACETAG_H_


// TraceTagIds are the identifiers for tracing areas, and are used in calls
// to TraceTag.  We need this defined outside of of ENABLETRACE so that
// calls to the TraceTag macro don't break when ENABLETRACE is not defined.
//
// Hungarian == ttid
//
enum TraceTagId
{
    ttidDefault         = 0,
    ttidAdvCfg,
    ttidAllocations,
    ttidAnswerFile,
    ttidAtmArps,
    ttidAtmLane,
    ttidAtmUni,
    ttidBeDiag,
    ttidBenchmark,
    ttidBrdgCfg,
    ttidClassInst,
    ttidConFoldEntry,
    ttidConman,
    ttidConnectionList,
    ttidDHCPServer,
    ttidDun,
    ttidEAPOL,
    ttidError,
    ttidEsLock,
    ttidEvents,
    ttidFilter,
    ttidGPNLA,
    ttidGuiModeSetup,
    ttidIcons,
    ttidInfExt,
    ttidInstallQueue,
    ttidISDNCfg,
    ttidLana,
    ttidLanCon,
    ttidLanUi,
    ttidMenus,
    ttidMSCliCfg,
    ttidNcDiag,
    ttidNetAfx,
    ttidNetBios,
    ttidNetComm,
    ttidNetOc,
    ttidNetSetup,
    ttidNetUpgrade,
    ttidNetcfgBase,
    ttidNetCfgBind,
    ttidNetCfgPnp,
    ttidNotifySink,
    ttidNWClientCfg,
    ttidNWClientCfgFn,
    ttidRasCfg,
    ttidSFNCfg,
    ttidSecTest,
    ttidShellEnum,
    ttidShellFolder,
    ttidShellFolderIface,
    ttidShellViewMsgs,
    ttidSrvrCfg,
    ttidStatMon,
    ttidSvcCtl,
    ttidSystray,
    ttidTcpip,
    ttidWanCon,
    ttidWanOrder,
    ttidWizard,
    ttidWlbs, /* maiken 5.25.00 */
    ttidWmi   /* AlanWar */
};


// Just for kicks
//
typedef enum TraceTagId TRACETAGID;

#ifdef ENABLETRACE

// Maximum sizes for the trace tag elements.
const int c_iMaxTraceTagShortName   = 16;
const int c_iMaxTraceTagDescription = 128;

// For each element in the tracetag list
//
struct TraceTagElement
{
    TRACETAGID  ttid;
    CHAR        szShortName[c_iMaxTraceTagShortName+1];
    CHAR        szDescription[c_iMaxTraceTagDescription+1];
    BOOL        fOutputDebugString;
    BOOL        fOutputToFile;
    BOOL        fVerboseOnly;
};

typedef struct TraceTagElement  TRACETAGELEMENT;

//---[ Externs ]--------------------------------------------------------------

extern TRACETAGELEMENT      g_TraceTags[];
extern const INT            g_nTraceTagCount;

#endif // ENABLETRACE

#endif  // _TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\trnrgsec.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       T R N R G S E C . H
//
//  Contents:   CTransactedRegistrySecurity and accompanying data types
//
//  Notes:
//
//  Author:     ckotze   13 July 2000
//
//---------------------------------------------------------------------------

#pragma once

typedef struct tagREGKEYDATA
{
    HKEY hkeyRoot;
    tstring strKeyName;
    ACCESS_MASK amMask;
    KEY_APPLY_MASK kamMask;
} REGKEYDATA;

typedef list<REGKEYDATA> LISTREGKEYDATA;
typedef LISTREGKEYDATA::iterator REGKEYDATAITER;

class CTransactedRegistrySecurity : protected CRegKeySecurity
{
public:
    CTransactedRegistrySecurity();
    virtual ~CTransactedRegistrySecurity();

    HRESULT SetPermissionsForKeysFromList(PCSID psidUserOrGroup, LISTREGKEYDATA& listRegKeyApply, BOOL bGrantRights);
    HRESULT ApplySecurityToKey(PCSID psidUserOrGroup, const REGKEYDATA rkdInfo, const BOOL bGrantRights);
private:
    LISTREGKEYDATA m_listTransaction;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\stlxutil.h ===
#pragma once
#ifndef _STLXUTIL_H_
#define _STLXUTIL_H_
//#include <utility>

#include <stlutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE FUNCTION copy
template<class _II, class _OI> inline
_OI copy(_II _F, _II _L, _OI _X)
{
    for (; _F != _L; ++_X, ++_F)
        *_X = *_F;
    return (_X);
}
// TEMPLATE FUNCTION copy_backward
template<class _BI1, class _BI2> inline
_BI2 copy_backward(_BI1 _F, _BI1 _L, _BI2 _X)
{
    while (_F != _L)
        *--_X = *--_L;
    return (_X);
}
// TEMPLATE FUNCTION equal
template<class _II1, class _II2> inline
bool equal(_II1 _F, _II1 _L, _II2 _X)
{
    return (mismatch(_F, _L, _X).first == _L);
}
// TEMPLATE FUNCTION equal WITH PRED
template<class _II1, class _II2, class _Pr> inline
bool equal(_II1 _F, _II1 _L, _II2 _X, _Pr _P)
{
    return (mismatch(_F, _L, _X, _P).first == _L);
}
// TEMPLATE FUNCTION fill
template<class _FI, class _Ty> inline
void fill(_FI _F, _FI _L, const _Ty& _X)
{
    for (; _F != _L; ++_F)
        *_F = _X;
}
// TEMPLATE FUNCTION fill_n
template<class _OI, class _Sz, class _Ty> inline
void fill_n(_OI _F, _Sz _N, const _Ty& _X)
{
    for (; 0 < _N; --_N, ++_F)
        *_F = _X;
}
// TEMPLATE FUNCTION lexicographical_compare
template<class _II1, class _II2> inline
bool lexicographical_compare(_II1 _F1, _II1 _L1,
                             _II2 _F2, _II2 _L2)
{
    for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
        if (*_F1 < *_F2)
            return (true);
        else if (*_F2 < *_F1)
            return (false);
    return (_F1 == _L1 && _F2 != _L2);
}
// TEMPLATE FUNCTION lexicographical_compare WITH PRED
template<class _II1, class _II2, class _Pr> inline
bool lexicographical_compare(_II1 _F1, _II1 _L1,
                             _II2 _F2, _II2 _L2, _Pr _P)
{
    for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
        if (_P(*_F1, *_F2))
            return (true);
        else if (_P(*_F2, *_F1))
            return (false);
    return (_F1 == _L1 && _F2 != _L2);
}
// TEMPLATE FUNCTION max
#ifndef _MAX
 #define _MAX   _cpp_max
 #define _MIN   _cpp_min
#endif
template<class _Ty> inline
const _Ty& _cpp_max(const _Ty& _X, const _Ty& _Y)
{
    return (_X < _Y ? _Y : _X);
}
// TEMPLATE FUNCTION max WITH PRED
template<class _Ty, class _Pr> inline
const _Ty& _cpp_max(const _Ty& _X, const _Ty& _Y, _Pr _P)
{
    return (_P(_X, _Y) ? _Y : _X);
}
// TEMPLATE FUNCTION min
template<class _Ty> inline
const _Ty& _cpp_min(const _Ty& _X, const _Ty& _Y)
{
    return (_Y < _X ? _Y : _X);
}
// TEMPLATE FUNCTION min WITH PRED
template<class _Ty, class _Pr> inline
const _Ty& _cpp_min(const _Ty& _X, const _Ty& _Y, _Pr _P)
{
    return (_P(_Y, _X) ? _Y : _X);
}
// TEMPLATE FUNCTION mismatch
template<class _II1, class _II2> inline
pair<_II1, _II2> mismatch(_II1 _F, _II1 _L, _II2 _X)
{
    for (; _F != _L && *_F == *_X; ++_F, ++_X)
        ;
    return (pair<_II1, _II2>(_F, _X));
}
// TEMPLATE FUNCTION mismatch WITH PRED
template<class _II1, class _II2, class _Pr> inline
pair<_II1, _II2> mismatch(_II1 _F, _II1 _L, _II2 _X, _Pr _P)
{
    for (; _F != _L && _P(*_F, *_X); ++_F, ++_X)
        ;
    return (pair<_II1, _II2>(_F, _X));
}
// TEMPLATE FUNCTION swap
template<class _Ty> inline
void swap(_Ty& _X, _Ty& _Y)
{
    _Ty _Tmp = _X;
    _X = _Y, _Y = _Tmp;
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLXUTIL_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\alanecfg\alanehlp.h ===
#define IDH_ELAN_NAME	30000501
#define IDH_ELAN_LIST	30000551
#define	IDH_ELAN_ADD	30000552
#define IDH_ELAN_EDIT	30000553
#define	IDH_ELAN_REMOVE	30000554

const DWORD g_aHelpIDs_IDD_ELAN_PROPERTIES[]=
{
	IDC_ELAN_NAME, IDH_ELAN_NAME,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MAIN[]=
{
	IDC_ELAN_LIST, IDH_ELAN_LIST,
	IDC_ELAN_ADD, IDH_ELAN_ADD,
	IDC_ELAN_EDIT, IDH_ELAN_EDIT,
	IDC_ELAN_REMOVE, IDH_ELAN_REMOVE,
	0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\wizentry.h ===
#pragma once

#include "netcon.h"
EXTERN_C
HRESULT
WINAPI
NetSetupAddRasConnection (
    IN HWND hwnd,
    OUT INetConnection** ppConn);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\alanecfg\alaneobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:      A L A N E O B J . H
//
//  Contents:  Declaration of the CALaneCfg notify object model
//
//  Notes:
//
//  Author:     v-lcleet    01 Aug 97
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include <nceh.h>
#include <notifval.h>
#include "resource.h"
#include <laneinfo.h>

#define ELAN_NAME_LIMIT 32

enum ElanChangeType
{
    ADD_ELAN = ATMLANE_RECONFIG_OP_ADD_ELAN,
    DEL_ELAN = ATMLANE_RECONFIG_OP_DEL_ELAN,
    MOD_ELAN = ATMLANE_RECONFIG_OP_MOD_ELAN
};

//
//  CALaneCfgElanData
//

class CALaneCfgElanInfo
{
public:
    CALaneCfgElanInfo(VOID);

    VOID SetElanBindName(PCWSTR pszElanBindName);
    PCWSTR SzGetElanBindName(VOID);
    VOID SetElanDeviceName(PCWSTR pszElanDeviceName);
    PCWSTR SzGetElanDeviceName(VOID);
    VOID SetElanName(PCWSTR pszElanName);
    VOID SetElanName(PWSTR pszElanName);
    PCWSTR SzGetElanName(VOID);

    BOOL        m_fDeleted;
    BOOL        m_fNewElan;

    BOOL        m_fRemoveMiniportOnPropertyApply;
    BOOL        m_fCreateMiniportOnPropertyApply;

private:
    tstring     m_strElanBindName;
    tstring     m_strElanDeviceName;
    tstring     m_strElanName;
};

typedef list<CALaneCfgElanInfo*>   ELAN_INFO_LIST;

//
//  CALaneCfgAdapterInfo
//

class CALaneCfgAdapterInfo
{
public:
    CALaneCfgAdapterInfo(VOID);
    ~CALaneCfgAdapterInfo(VOID);

    VOID SetAdapterBindName(PCWSTR pszAdapterBindName);
    PCWSTR SzGetAdapterBindName(VOID);

    VOID SetAdapterPnpId(PCWSTR szAdapterBindName);
    PCWSTR SzGetAdapterPnpId(VOID);

    GUID    m_guidInstanceId;

    ELAN_INFO_LIST      m_lstElans;
    ELAN_INFO_LIST      m_lstOldElans;

    BOOL                m_fDeleted;

    // If the adapter has been added, removed, enabled or disabled.
    BOOL                m_fBindingChanged;

private:
    tstring             m_strAdapterBindName;
    tstring             m_strAdapterPnpId;
};

typedef list<CALaneCfgAdapterInfo*>   ATMLANE_ADAPTER_INFO_LIST;


//
// CALaneCfg
//
class ATL_NO_VTABLE CALaneCfg :
    public CComObjectRoot,
    public CComCoClass<CALaneCfg, &CLSID_CALaneCfg>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentPropertyUi,
    public INetCfgComponentNotifyBinding
{
protected:
    CALaneCfg(VOID);
    ~CALaneCfg(VOID);

public:
    BEGIN_COM_MAP(CALaneCfg)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CSkeleton)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_ALANECFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (Install)         (DWORD dwSetupFlags);
    STDMETHOD (Upgrade)         (DWORD dwSetupFlags,
                                 DWORD dwUpgradeFomBuildNo );
    STDMETHOD (ReadAnswerFile)  (PCWSTR pszAnswerFile,
                                 PCWSTR pszAnswerSection);
    STDMETHOD (Removing)();

// INetCfgProperties
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk);
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk);
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

    // INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

private:
    INetCfgComponent*           m_pncc;
    INetCfg*                    m_pnc;
    ATMLANE_ADAPTER_INFO_LIST   m_lstAdaptersPrimary;
    CALaneCfgAdapterInfo *      m_pAdapterSecondary;

    BOOL                        m_fDirty;
    BOOL                        m_fValid;
    BOOL                        m_fUpgrade;
    BOOL                        m_fNoElanInstalled;

    // Property sheet pages
    enum {c_cALanePages = 1};
    CPropSheetPage*             m_ppsp;

    // Context
    IUnknown * m_pUnkContext;
    tstring  m_strGuidConn;

// Utility functions
private:
    HRESULT HrNotifyBindingAdd(
        INetCfgComponent* pnccAdapter,
        PCWSTR pszBindName);

    HRESULT HrNotifyBindingRemove(
        INetCfgComponent* pnccAdapter,
        PCWSTR pszBindName);

    HRESULT HrLoadConfiguration();

    HRESULT HrLoadAdapterConfiguration(HKEY hkeyAdapterList,
            PWSTR szAdapterName);

    HRESULT HrLoadElanListConfiguration(HKEY hkeyAdapter,
            CALaneCfgAdapterInfo* pAdapterInfo);

    HRESULT HrLoadElanConfiguration(HKEY hkeyElanList,
            PWSTR szElanName, CALaneCfgAdapterInfo* pAdapterInfo);

    HRESULT HrFlushConfiguration();

    HRESULT HrFlushAdapterConfiguration(HKEY hkeyAdapterList,
            CALaneCfgAdapterInfo *pAdapterInfo);

    HRESULT HrFlushElanListConfiguration(HKEY hkeyAdapter,
            CALaneCfgAdapterInfo *pAdapterInfo);

    HRESULT HrFlushElanConfiguration(HKEY hkeyElanList,
            CALaneCfgElanInfo *pElanInfo);

    HRESULT HrRemoveMiniportInstance(PCWSTR pszBindNameToRemove);

    HRESULT HrFindNetCardInstance(PCWSTR pszBindNameToFind, INetCfgComponent **ppncc);

    VOID    HrMarkAllDeleted();

    VOID    UpdateElanDisplayNames();

    HRESULT HrSetConnectionContext();
    HRESULT HrALaneSetupPsh(HPROPSHEETPAGE** pahpsp);

    VOID    CopyAdapterInfoPrimaryToSecondary();
    VOID    CopyAdapterInfoSecondaryToPrimary();

    HRESULT HrReconfigLane(CALaneCfgAdapterInfo * pAdapterInfo);
    HRESULT HrNotifyElanChange(CALaneCfgAdapterInfo * pAdapterInfo,
                                          CALaneCfgElanInfo * pElanInfo,
                                          ElanChangeType elanChangeType);
    BOOL    FIsAdapterEnabled(const GUID* pguidId);
};

// some utility functions

void ClearElanList(ELAN_INFO_LIST *plstElans);
void ClearAdapterList(ATMLANE_ADAPTER_INFO_LIST *plstAdapters);
void ClearAdapterInfo(CALaneCfgAdapterInfo * pAdapterInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\inc\trace.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E . H
//
//  Contents:   Class definition for CTracing
//
//  Notes:
//
//  Author:     jeffspr   15 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once

#include "tracetag.h"
#include "stlalgor.h"
#include "stldeque.h"
#include "stlmap.h"

// ISSUE: The customized STL that we have conflicts with the declarations pulled in 
//        from stdexcpt.h which gets included by typeinfo.h. This sucks!
//        Hence we can't include typeinfo.h to get RTTI's type_info structure, 
//        so we have to declare type_info ourselves. This is a well documented 
//        structure inside MSDN though.
class type_info {
public:
    _CRTIMP virtual ~type_info();
    _CRTIMP int operator==(const type_info& rhs) const;
    _CRTIMP int operator!=(const type_info& rhs) const;
    _CRTIMP int before(const type_info& rhs) const;
    _CRTIMP const char* name() const;
    _CRTIMP const char* raw_name() const;
private:
    void *_m_data;
    char _m_d_name[1];
    type_info(const type_info& rhs);
    type_info& operator=(const type_info& rhs);
};

#define TAKEOWNERSHIP

#ifdef ENABLETRACE

// This is needed for TraceHr, since we can't use a macro (vargs), but we
// need to get the file and line from the source.
#define FAL __FILE__,__LINE__,__FUNCTION__

// The Trace Stack functions
#if defined (_IA64_)
#include <ia64reg.h>

extern "C" unsigned __int64 __getReg(int whichReg);
extern "C" void __setReg(int whichReg, __int64 value);
#pragma intrinsic(__getReg)
#pragma intrinsic(__setReg)

#define GetR32 __getReg(CV_IA64_IntR32)
#define GetR33 __getReg(CV_IA64_IntR33)
#define GetR34 __getReg(CV_IA64_IntR34)
#endif // defined(_IA64_)

extern "C" void* _ReturnAddress(void);
#pragma intrinsic(_ReturnAddress)

extern LPCRITICAL_SECTION g_csTracing;

class CTracingIndent;

class CTracingFuncCall
{
public:
#if defined (_X86_) || defined (_AMD64_)
    CTracingFuncCall(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, const DWORD_PTR ReturnAddress, const DWORD_PTR dwFramePointer);
#elif defined (_IA64_) 
    CTracingFuncCall(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, const DWORD_PTR ReturnAddress, const __int64 Args1, const __int64 Args2, const __int64 Args3);
#else
    CTracingFuncCall(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine);
#endif
    
    CTracingFuncCall(const CTracingFuncCall& TracingFuncCall);
    ~CTracingFuncCall();

public:
    LPSTR   m_szFunctionName;
    LPSTR   m_szFunctionDName;
    LPSTR   m_szFile;
    DWORD_PTR m_ReturnAddress;

#if defined (_X86_) || defined (_AMD64_)
    DWORD   m_arguments[3];
#elif defined (_IA64_ )
    __int64 m_arguments[3];
#else
    // ... add other processors here
#endif

    DWORD   m_dwFramePointer;
    DWORD   m_dwThreadId;
    DWORD   m_dwLine;
    
    friend CTracingIndent;
};

class CTracingThreadInfo
{
public:
    CTracingThreadInfo();
    ~CTracingThreadInfo();

public:
    LPVOID m_pfnStack;
    DWORD m_dwLevel;
    DWORD m_dwThreadId;
    friend CTracingIndent;
};

class CTracingIndent
{
    LPSTR   m_szFunctionDName;
    DWORD   m_dwFramePointer;
    BOOL    bFirstTrace;
    
public:
#if defined (_X86_) || defined (_AMD64_)
    void AddTrace(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, LPCVOID pReturnAddress, const DWORD_PTR dwFramePointer);
#elif defined (_IA64_) 
    void AddTrace(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, LPCVOID pReturnAddress, const __int64 Args1, const __int64 Args2, const __int64 Args3);
#else
    void AddTrace(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine);
#endif
    void RemoveTrace(LPCSTR szFunctionDName, const DWORD dwFramePointer);

    CTracingIndent();
    ~CTracingIndent();

    static CTracingThreadInfo* GetThreadInfo();
    static DWORD getspaces();
    static void TraceStackFn(TRACETAGID TraceTagId);
    static void TraceStackFn(IN OUT LPSTR szString, IN OUT LPDWORD pdwSize);
};


#define IDENT_ADD2(x) indent ## x
#define IDENT_ADD(x)  IDENT_ADD2(x)
#define __INDENT__ IDENT_ADD(__LINE__)

#define FP_ADD2(x) FP ## x
#define FP_ADD(x)  FP_ADD2(x)
#define __FP__ FP_ADD(__LINE__)

#if defined (_X86_)
#define AddTraceLevel \
    __if_not_exists(NetCfgFramePointer) \
    { \
        DWORD NetCfgFramePointer;  \
        BOOL fForceC4715Check = TRUE;  \
    } \
    if (fForceC4715Check) \
    { \
        __asm { mov NetCfgFramePointer, ebp }; \
    } \
    __if_not_exists(NetCfgIndent) \
    { \
        CTracingIndent NetCfgIndent; \
    } \
    NetCfgIndent.AddTrace(__FUNCTION__, __FUNCDNAME__, __FILE__, __LINE__, _ReturnAddress(), NetCfgFramePointer);
#elif defined (_IA64_) 
#define AddTraceLevel \
    __if_not_exists(NetCfgIndent) \
    { \
        CTracingIndent NetCfgIndent; \
    } \
    NetCfgIndent.AddTrace(__FUNCTION__, __FUNCDNAME__, __FILE__, __LINE__, _ReturnAddress(), 0, 0, 0);

    // NetCfgIndent.AddTrace(__FUNCTION__, __FUNCDNAME__, __FILE__, __LINE__, _ReturnAddress(), GetR32, GetR33, GetR34);
    // ISSUE: GetR32, GetR33, GetR34 is inherently unsafe and can cause an STATUS_REG_NAT_CONSUMPTION exception
    // if a register is being read that has the NAT bit set. Removing this for now until the compiler
    // team provides a safe version of __getReg
#elif defined (_AMD64_)
#define AddTraceLevel \
    __if_not_exists(NetCfgIndent) \
    { \
        CTracingIndent NetCfgIndent; \
    } \
    NetCfgIndent.AddTrace(__FUNCTION__, __FUNCDNAME__, __FILE__, __LINE__, _ReturnAddress(), 0);
#else
#define AddTraceLevel \
    __if_not_exists(NetCfgIndent) \
    { \
        CTracingIndent NetCfgIndent; \
    } \
    NetCfgIndent.AddTrace(__FUNCTION__, __FUNCDNAME__, __FILE__, __LINE__);
#endif

// Trace error functions. The leaading _ is to establish the real function,
// while adding a new macro so we can add __FILE__ and __LINE__ to the output.
//
VOID    WINAPI   TraceErrorFn           (PCSTR pszaFile, INT nLine, PCSTR psza, HRESULT hr);
VOID    WINAPI   TraceErrorOptionalFn   (PCSTR pszaFile, INT nLine, PCSTR psza, HRESULT hr, BOOL fOpt);
VOID    WINAPI   TraceErrorSkipFn       (PCSTR pszaFile, INT nLine, PCSTR psza, HRESULT hr, UINT c, ...);
VOID    WINAPIV  TraceLastWin32ErrorFn  (PCSTR pszaFile, INT nLine, PCSTR psza);

#define TraceError(sz, hr)                      TraceErrorFn(__FILE__, __LINE__, sz, hr);
#define TraceErrorOptional(sz, hr, _bool)       TraceErrorOptionalFn(__FILE__, __LINE__, sz, hr, _bool);
#define TraceErrorSkip1(sz, hr, hr1)            TraceErrorSkipFn(__FILE__, __LINE__, sz, hr, 1, hr1);
#define TraceErrorSkip2(sz, hr, hr1, hr2)       TraceErrorSkipFn(__FILE__, __LINE__, sz, hr, 2, hr1, hr2);
#define TraceErrorSkip3(sz, hr, hr1, hr2, hr3)  TraceErrorSkipFn(__FILE__, __LINE__, sz, hr, 3, hr1, hr2, hr3);
#define TraceLastWin32Error(sz)                 TraceLastWin32ErrorFn(__FILE__,__LINE__, sz);

VOID
WINAPIV
TraceHrFn (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    HRESULT     hr,
    BOOL        fIgnore,
    PCSTR       pszaFmt,
    ...);

VOID
WINAPIV
TraceHrFn (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    PCSTR       pszaFunc,
    HRESULT     hr,
    BOOL        fIgnore,
    PCSTR       pszaFmt,
    ...);

VOID
WINAPIV
TraceTagFn (
    TRACETAGID  ttid,
    PCSTR       pszaFmt,
    ...);

VOID
WINAPIV
TraceFileFuncFn (
            TRACETAGID  ttid);

#define TraceFileFunc(ttidWhich) AddTraceLevel; TraceFileFuncFn(ttidWhich);
#define TraceStack(ttidWhich) AddTraceLevel; CTracingIndent::TraceStackFn(ttidWhich);
#define TraceStackToString(szString, nSize) AddTraceLevel; CTracingIndent::TraceStackFn(szString, nSize);
#define TraceHr AddTraceLevel; TraceHrFn
#define TraceTag AddTraceLevel; TraceTagFn
#define TraceException(hr, szExceptionName) TraceHr(ttidError, FAL, hr, FALSE, "A (%s) exception occurred", szExceptionName);

LPCSTR DbgEvents(DWORD Event);
LPCSTR DbgEventManager(DWORD EventManager);
LPCSTR DbgNcm(DWORD ncm);
LPCSTR DbgNcs(DWORD ncs);
LPCSTR DbgNccf(DWORD nccf);
LPCSTR DbgNcsm(DWORD ncsm);

#else   // !ENABLETRACE

#define FAL                                         (void)0
#define TraceError(_sz, _hr)
#define TraceErrorOptional(_sz, _hr, _bool)
#define TraceErrorSkip1(_sz, _hr, _hr1)
#define TraceErrorSkip2(_sz, _hr, _hr1, _hr2)
#define TraceErrorSkip3(_sz, _hr, _hr1, _hr2, _hr3)
#define TraceLastWin32Error(_sz)
#define TraceHr                                       NOP_FUNCTION
#define TraceTag                                      NOP_FUNCTION
#define TraceFileFunc(ttidWhich)                      NOP_FUNCTION
#define TraceException(hr, szExceptionName)           NOP_FUNCTION
#define TraceStack(ttidWhich)                         NOP_FUNCTION
#define TraceStackToString(szString, nSize)           NOP_FUNCTION

#define DbgEvents(Event) ""
#define DbgEventManager(EventManager) ""
#define DbgNcm(ncm) ""
#define DbgNcs(ncs) ""
#define DbgNccf(nccf) ""
#define DbgNcsm(nccf) ""

#endif  // ENABLETRACE

#ifdef ENABLETRACE

//---[ Initialization stuff ]-------------------------------------------------

HRESULT HrInitTracing();
HRESULT HrUnInitTracing();
HRESULT HrOpenTraceUI(HWND  hwndOwner);

#endif // ENABLETRACE

#define ENABLELEAKDETECTION

#if (defined(ENABLETRACE) && defined(ENABLELEAKDETECTION))

template <class T> class CNetCfgDebug; // Fwd template to make this friendly to CObjectLeakTrack

//+---------------------------------------------------------------------------
//
//  class:      CObjectLeakTrack
//
//  Purpose:    Keep a list of all the CNetCfgDebug derived object instances and
//              dump these out on request
//
//  Author:     deonb  7 July 2001
//
//  Notes:      The data types in here are of type LPVOID in order to minimize
//              dependencies when including the trace header.
//  
class CObjectLeakTrack
{
public:
    CObjectLeakTrack();
    ~CObjectLeakTrack();
    void DumpAllocatedObjects(IN TRACETAGID TraceTagId, IN LPCSTR szClassName);
    BOOL AssertIfObjectsStillAllocated(IN LPCSTR szClassName);

protected: 
    // For these, pThis is really of type CNetCfgDebug<T> *. Since this should only ever be called
    // from CNetCfgDebug or ISSUE_knownleak, we are ok with the lack of compile-time type checking.
    void Insert(IN LPCVOID pThis, IN LPCSTR szdbgClassName, IN TAKEOWNERSHIP LPSTR pszConstructionStack);
    void Remove(IN LPCVOID pThis);

    friend class CNetCfgDebug;
    friend void RemoveKnownleakFn(LPCVOID pThis);

protected:
    LPVOID g_mapObjLeak; // This will actually be of type map<LPCVOID, pair<LPSTR, LPSTR> > ;
};

extern CObjectLeakTrack *g_pObjectLeakTrack; // The global list of NetConfig objects in the process.
                                             // Call DumpAllocatedObjects on this to dump out the objects.
void RemoveKnownleakFn(LPCVOID pThis);

//+---------------------------------------------------------------------------
//
//  class:      CNetCfgDebug
//
//  Purpose:    In order to debug instance leaks of your class instances, you can
//              derive your class from CNetCfgDebug. This adds no data members nor 
//              a v-table nor virtual functions to your class. It will add 
//              a constructor and destructor that will be called before & after yours
//              respectively, in order to keep track of your class instances.
//  
//              This will only happen on CHK builds. On FRE builds deriving from this
//              class has no effect, and is safe.
//
//  Author:     deonb  7 July 2001
//
//  Notes:      
//              This is s an ATL style parent template derive, e.g.:
//              CNetCfgDbg<parent>
//              e.g.
//              
//              class CConnectionManager : public ClassX, 
//                                         public classY,
//                                         public CNetCfgBase<CConnectionManager>
//
//              No other interaction with your class is needed. This will now automatically 
//              keep a list of all the instances allocated of this class (in debug mode), 
//              with a stack trace where they were allocated from. This is a Tracing
//              stack trace so it's only successful for functions inside the callstack which
//              actually used a TraceXxx statement (any trace statement) before they called
//              the child functions.
//
//              e.g. 
//              void X()
//              {
//                  TraceFileFunc(ttidSomething);
//                  void Y()
//                  {
//                      void Z()
//                      {
//                          TraceTag(ttidSomething, "allocation class");
//                          CConnectionManager *pConnectionManager = new CConnectionManager();
//                      }
//                      TraceTag(ttidSomething, "Z called");
//                  }
//              }
//  
//              This will spew the following when the process terminates (or when TraceAllocatedObjects is called):
//              ASSERT: "An object leak has been detected. Please attach a user or kernel mode debugger and hit 
//                       IGNORE to dump the offending stacks"
//              
//              The object of type 'class CConnectionManager' allocated at 0x7fe2345 has not been freed:
//                  it was constructed from the stack below: 
//              Z [EBP: 0x731d3128] 0x00000001 0x00000000 0x0000000a
//              X [EBP: 0x731d310f] 0x0000000f 0x0000000e 0x0000000a
//
//              (since Y() did not contain a trace statement before the call to Z() )
//
template <class T> 
class CNetCfgDebug
{
public:
    CNetCfgDebug()
    {
        if (FIsDebugFlagSet(dfidTrackObjectLeaks))
        {
            if (g_csTracing && g_pObjectLeakTrack)
            {
                EnterCriticalSection(g_csTracing);

                DWORD dwConstructionStackSize = 16384;
                LPSTR pszConstructionStack = new CHAR[dwConstructionStackSize];
                if (pszConstructionStack)
                {
                    TraceStackToString(pszConstructionStack, &dwConstructionStackSize);

                    if (dwConstructionStackSize < 16384)
                    {
                        // Reduce the amount of memory required
                        LPSTR szTemp = new CHAR[dwConstructionStackSize];
                        if (szTemp)
                        {
                            memcpy(szTemp, pszConstructionStack, dwConstructionStackSize);
                            delete[] pszConstructionStack;

                            pszConstructionStack = szTemp;
                        }
                    }
                    else
                    {
                        
                    }
                }

                TraceTag(ttidAllocations, "An object of type '%s' was allocated at '0x%08x'", typeid(T).name(), this);
                g_pObjectLeakTrack->Insert(this, typeid(T).name(), pszConstructionStack); // ok to insert if pszConstructionStack is NULL.

                LeaveCriticalSection(g_csTracing);
            }
        }
    };

    ~CNetCfgDebug()
    {
        if (FIsDebugFlagSet(dfidTrackObjectLeaks))
        {
            if (g_csTracing && g_pObjectLeakTrack)
            {
                EnterCriticalSection(g_csTracing);

                TraceTag(ttidAllocations, "An object of type '%s' was deleted at '0x%08x'", typeid(T).name(), this);
                g_pObjectLeakTrack->Remove(this);

                LeaveCriticalSection(g_csTracing);
            }
        }
    };
};

#define ISSUE_knownleak(pThis) RemoveKnownleakFn(pThis);

#define TraceAllocatedObjects(ttidWhich, ClassName) g_pObjectLeakTrack->DumpAllocatedObjects(ttidWhich, typeid(ClassName).name());
#define AssertIfAllocatedObjects(ClassName)         g_pObjectLeakTrack->AssertIfObjectsStillAllocated(typeid(ClassName).name());

#define TraceAllAllocatedObjects(ttidWhich) g_pObjectLeakTrack->DumpAllocatedObjects(ttidWhich, NULL);
#define AssertIfAnyAllocatedObjects()       g_pObjectLeakTrack->AssertIfObjectsStillAllocated(NULL);

#else // ENABLETRACE && ENABLELEAKDETECTION

template <class T> 
    class CNetCfgDebug
{
};

#define ISSUE_knownleak(pThis)                        NOP_FUNCTION
#define TraceAllocatedObjects(ttidWhich, szClassName) NOP_FUNCTION
#define AssertNoAllocatedInstances(szClassName)       NOP_FUNCTION

#endif // ENABLETRACE && ENABLELEAKDETECTION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\alanecfg\alaneobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:      A L A N E O B J . C P P
//
//  Contents:   Implementation of the CALaneCfg notify object model
//
//  Notes:
//
//  Author:     v-lcleet    01 Aug 97
//
//----------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop
#include "alaneobj.h"
#include "alanepsh.h"
#include "ncreg.h"
#include "netconp.h"
#include "ncpnp.h"

#include "alanehlp.h"

static const WCHAR c_szAtmLane[]            = L"AtmLane";
static const WCHAR c_szElanList[]           = L"ElanList";
static const WCHAR c_szElanDevice[]         = L"Device";
static const WCHAR c_szElanName[]           = L"ElanName";

extern const WCHAR c_szDevice[];

extern const WCHAR c_szInfId_MS_AtmElan[];

const WCHAR c_szAtmAdapterPnpId[]          = L"AtmAdapterPnpId";

//
//  CALaneCfg
//
//  Constructor/Destructor methods
//

CALaneCfg::CALaneCfg(VOID) :
        m_pncc(NULL),
        m_pnc(NULL),
        m_ppsp(NULL),
        m_pAdapterSecondary(NULL),
        m_pUnkContext(NULL)
{
    m_fDirty = FALSE;
    m_fValid = FALSE;
    m_fUpgrade = FALSE;
    m_fNoElanInstalled = TRUE;

    return;
}

CALaneCfg::~CALaneCfg(VOID)
{
    ClearAdapterList(&m_lstAdaptersPrimary);
    ClearAdapterInfo(m_pAdapterSecondary);

    ReleaseObj(m_pncc);
    ReleaseObj(m_pnc);

    delete m_ppsp;

    // Just a safty check to make sure the context is released.
    AssertSz((m_pUnkContext == NULL), "Why is context not released ?");
    ReleaseObj(m_pUnkContext) ;

    return;
}

//
//  CALaneCfg
//
//  INetCfgComponentControl interface methods
//

STDMETHODIMP CALaneCfg::Initialize (INetCfgComponent* pncc,
                                    INetCfg* pnc,
                                    BOOL fInstalling)
{
    HRESULT hr = S_OK;

    Validate_INetCfgNotify_Initialize(pncc, pnc, fInstalling);

    // reference and save away the component and interface.
    AddRefObj(m_pncc = pncc);
    AddRefObj(m_pnc = pnc);

    // if not installing then load the current config from registry
    if (!fInstalling)
    {
        hr = HrLoadConfiguration();
    }

    Validate_INetCfgNotify_Initialize_Return(hr);

    TraceError("CALaneCfg::Initialize", hr);
    return hr;
}

STDMETHODIMP CALaneCfg::Validate ()
{
    return S_OK;
}

STDMETHODIMP CALaneCfg::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP CALaneCfg::ApplyRegistryChanges ()
{
    HRESULT hr = S_OK;

    if (m_fValid && m_fDirty)
    {
        UpdateElanDisplayNames();

        // flush out the registry and send reconfig notifications
        hr = HrFlushConfiguration();
    }
    else
    {
        // no change
        hr = S_FALSE;
    }

    TraceError("CALaneCfg::ApplyRegistryChanges",
        (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//  INetCfgComponentSetup interface methods
//
STDMETHODIMP CALaneCfg::Install (DWORD dwSetupFlags)
{
    // mark configuration as valid (but empty)
    m_fValid = TRUE;

    return S_OK;
}

STDMETHODIMP CALaneCfg::Upgrade( DWORD dwSetupFlags,
                                 DWORD dwUpgradeFomBuildNo )
{
    // mark configuration as valid (but empty)
    m_fValid = TRUE;
    m_fUpgrade = TRUE;

    return S_OK;
}

STDMETHODIMP CALaneCfg::ReadAnswerFile (PCWSTR pszAnswerFile,
                                        PCWSTR pszAnswerSection)
{
    return S_OK;
}

STDMETHODIMP CALaneCfg::Removing ()
{
    // mark everything for deletion
    (VOID) HrMarkAllDeleted();

    return S_OK;
}

//
//  CALaneCfg
//
//  INetCfgProperties interface methods
//

STDMETHODIMP CALaneCfg::QueryPropertyUi(IUnknown* pUnk)
{
    HRESULT hr = S_FALSE;

    if (pUnk)
    {
        // Is this a lan connection ?
        INetLanConnectionUiInfo * pLanConnUiInfo;
        hr = pUnk->QueryInterface( IID_INetLanConnectionUiInfo,
                                   reinterpret_cast<LPVOID *>(&pLanConnUiInfo));

        if(FAILED(hr))
        {
            // don't show UI
            hr = S_FALSE;
        }
    }

    TraceError("CALaneCfg::QueryPropertyUi", hr);
    return hr;
}

STDMETHODIMP CALaneCfg::SetContext(IUnknown * pUnk)
{
    HRESULT hr = S_OK;

    // release previous context, if any
    if (m_pUnkContext)
        ReleaseObj(m_pUnkContext);
    m_pUnkContext = NULL;

    if (pUnk) // set the new context
    {
        m_pUnkContext = pUnk;
        m_pUnkContext->AddRef();
    }

    TraceError("CALaneCfg::SetContext", hr);
    return hr;
}

STDMETHODIMP CALaneCfg::MergePropPages (
    IN OUT DWORD* pdwDefPages,
    OUT LPBYTE* pahpspPrivate,
    OUT UINT* pcPages,
    IN HWND hwndParent,
    OUT PCWSTR* pszStartPage)
{
    Validate_INetCfgProperties_MergePropPages(pdwDefPages, pahpspPrivate,
                                              pcPages, hwndParent, pszStartPage);

    // Don't show any default pages
    *pdwDefPages = 0;
    *pcPages = 0;
    *pahpspPrivate = NULL;

    HPROPSHEETPAGE*     ahpsp   = NULL;
    HRESULT hr = HrALaneSetupPsh(&ahpsp);
    if (SUCCEEDED(hr))
    {
        *pahpspPrivate = (LPBYTE)ahpsp;
        *pcPages = c_cALanePages;
    }

    Validate_INetCfgProperties_MergePropPages_Return(hr);

    TraceError("CALaneCfg::MergePropPages", hr);
    return hr;
}

STDMETHODIMP CALaneCfg::ValidateProperties (HWND hwndSheet)
{
    return S_OK;
}

STDMETHODIMP CALaneCfg::CancelProperties ()
{
    // throw away the secondary adapter list
    ClearAdapterInfo(m_pAdapterSecondary);
    m_pAdapterSecondary = NULL;

    return S_OK;
}

STDMETHODIMP CALaneCfg::ApplyProperties ()
{
    HRESULT hr = S_OK;
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    ELAN_INFO_LIST::iterator    iterLstElans;
    CALaneCfgElanInfo *         pElanInfo;
    INetCfgComponent *          pnccAtmElan   = NULL;
    tstring     strAtmElan;

    // go thru the secondary adapter info and
    // add miniports for elans that were added and
    // remove miniports for elans that were deleted.

    // loop thru the elan list on this adapter

    BOOL bCommitNow = FALSE;

    for (iterLstElans = m_pAdapterSecondary->m_lstElans.begin();
            iterLstElans != m_pAdapterSecondary->m_lstElans.end();
            iterLstElans++)
    {
        pElanInfo = *iterLstElans;

        if (pElanInfo->m_fCreateMiniportOnPropertyApply)
        {
            bCommitNow = TRUE;

            //  create associated miniport
            hr = HrAddOrRemoveAdapter(m_pnc,
                        c_szInfId_MS_AtmElan, ARA_ADD,
                        NULL, 1, &pnccAtmElan);

            if (S_OK == hr)
            {
                // This is a new Elan
                pElanInfo->m_fNewElan = TRUE;

                //  BindName
                PWSTR pszTmpBindName;
                hr = pnccAtmElan->GetBindName(&pszTmpBindName);
                if (SUCCEEDED(hr))
                {
                    pElanInfo->SetElanBindName(pszTmpBindName);
                    CoTaskMemFree(pszTmpBindName);

                    //  Device param
                    strAtmElan = c_szDevice;
                    strAtmElan.append(pElanInfo->SzGetElanBindName());

                    pElanInfo->SetElanDeviceName(strAtmElan.c_str());
                }

                ReleaseObj(pnccAtmElan);
            }

            if (FAILED(hr))
            {
                TraceError("CALaneCfg::ApplyProperties, failed creating an Elan", hr);
                hr = S_OK;
            }
        }
        
        if (pElanInfo->m_fRemoveMiniportOnPropertyApply)
        {
            bCommitNow = TRUE;

            pElanInfo = *iterLstElans;

            hr = HrRemoveMiniportInstance(pElanInfo->SzGetElanBindName());

            if (FAILED(hr))
            {
                pElanInfo->m_fDeleted = FALSE;

                TraceError("CALaneCfg::ApplyProperties, failed removing an Elan", hr);
                hr = S_OK;
            }
        }
    }

    // all is well
    // copy secondary list to primary
    CopyAdapterInfoSecondaryToPrimary();
    m_fDirty = TRUE;


    ClearAdapterInfo(m_pAdapterSecondary);
    m_pAdapterSecondary = NULL;

    Validate_INetCfgProperties_ApplyProperties_Return(hr);

    if(bCommitNow && SUCCEEDED(hr))
    {
        hr = NETCFG_S_COMMIT_NOW;
    }

    TraceError("CALaneCfg::ApplyProperties", hr);
    return hr;
}

//
//  CALaneCfg
//
//  INetCfgBindNotify interface methods
//
STDMETHODIMP CALaneCfg::QueryBindingPath (DWORD dwChangeFlag,
                                          INetCfgBindingPath* pncbp)
{
    return S_OK;
}

STDMETHODIMP CALaneCfg::NotifyBindingPath (DWORD dwChangeFlag,
                                           INetCfgBindingPath* pncbp)
{
    Assert(!(dwChangeFlag & NCN_ADD && dwChangeFlag & NCN_REMOVE));
    Assert(!(dwChangeFlag & NCN_ENABLE && dwChangeFlag & NCN_DISABLE));

    // If we are told to add a card, we must be told at the same time whether the
    // binding is enabled or disabled
    Assert(FImplies((dwChangeFlag & NCN_ADD),
                    ((dwChangeFlag & NCN_ENABLE)||(dwChangeFlag & NCN_DISABLE))));

    INetCfgComponent * pnccLastComponent;
    HRESULT hr = HrGetLastComponentAndInterface(pncbp,
                    &pnccLastComponent, NULL);

    if (S_OK == hr)
    {
        PWSTR pszBindName;
        hr = pnccLastComponent->GetBindName(&pszBindName);
        if (S_OK == hr)
        {
            if (dwChangeFlag & NCN_ADD)
            {
                hr = HrNotifyBindingAdd(pnccLastComponent, pszBindName);
            }
            else if (dwChangeFlag & NCN_REMOVE)
            {
                hr = HrNotifyBindingRemove(pnccLastComponent, pszBindName);
            }
            else
            {
                // simply mark the adapter as binding changed so we don't
                // send Elan add\remove notifications (Raid #255910)

                // Get the adapter component's instance name
                CALaneCfgAdapterInfo *  pAdapterInfo;

                //  search the in-memory list for this adapter
                BOOL    fFound;
                ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
                for (iterLstAdapters = m_lstAdaptersPrimary.begin(), fFound = FALSE;
                        iterLstAdapters != m_lstAdaptersPrimary.end();
                        iterLstAdapters++)
                {
                    pAdapterInfo = *iterLstAdapters;

                    if (!lstrcmpiW(pszBindName, pAdapterInfo->SzGetAdapterBindName()))
                    {
                        fFound = TRUE;
                        break;
                    }
                }

                if (fFound)
                {
                    // mark it as changed
                    pAdapterInfo->m_fBindingChanged = TRUE;
                }
            }

            CoTaskMemFree (pszBindName);
        }

        ReleaseObj (pnccLastComponent);
    }

    TraceError("CALaneCfg::NotifyBindingPath", hr);
    return hr;
}

//
//  CALaneCfg
//
//  Private methods
//
HRESULT
CALaneCfg::HrNotifyBindingAdd (
    INetCfgComponent* pnccAdapter,
    PCWSTR pszBindName)
{
    HRESULT hr = S_OK;

    // $REVIEW(tongl 1/25/98): Added this: we should see if this adapter is
    // is already in our list but marked as for deletion. If so, simply unmark
    // the adapter and all of it's Elans. The Binding Add could be a fake one
    // when it is in uprade process.

    BOOL fFound;
    CALaneCfgAdapterInfo*  pAdapterInfo  = NULL;

    //  search the in-memory list for this adapter
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    for (iterLstAdapters = m_lstAdaptersPrimary.begin(), fFound = FALSE;
            iterLstAdapters != m_lstAdaptersPrimary.end();
            iterLstAdapters++)
    {
        pAdapterInfo = *iterLstAdapters;

        if (!lstrcmpiW(pszBindName, pAdapterInfo->SzGetAdapterBindName()))
        {
            fFound = TRUE;
            break;
        }
    }

    if (fFound) // Add an old adapter back
    {
        Assert(pAdapterInfo->m_fDeleted);

        // mark it un-deleted
        pAdapterInfo->m_fDeleted = FALSE;

        if (m_fUpgrade)
        {
            // the Elans are not deleted, just mark them as un-deleted
            ELAN_INFO_LIST::iterator iterLstElans;
            for (iterLstElans = pAdapterInfo->m_lstElans.begin();
                    iterLstElans!= pAdapterInfo->m_lstElans.end();
                    iterLstElans++)
            {
                Assert((*iterLstElans)->m_fDeleted);
                (*iterLstElans)->m_fDeleted = FALSE;
            }
        }
    }
    else
    {
        // if this is a new atm adapter

        //  Create a new in-memory adapter object
        pAdapterInfo = new CALaneCfgAdapterInfo;

        if (pAdapterInfo)
        {
            GUID guidAdapter;
            hr = pnccAdapter->GetInstanceGuid(&guidAdapter); 
            if (S_OK == hr)
            {
                pAdapterInfo->m_guidInstanceId = guidAdapter;
            }

            // the adapter is newly added
            pAdapterInfo->m_fBindingChanged = TRUE;

            // Set the bind name of the adapter
            pAdapterInfo->SetAdapterBindName(pszBindName);

            // Set the PnpId of the adapter
            PWSTR pszPnpDevNodeId;
            hr = pnccAdapter->GetPnpDevNodeId(&pszPnpDevNodeId);
            if (S_OK == hr)
            {
                Assert(pszPnpDevNodeId);

                pAdapterInfo->SetAdapterPnpId(pszPnpDevNodeId);
                CoTaskMemFree(pszPnpDevNodeId);
            }

            //  Create a new in-memory elan object
            CALaneCfgElanInfo * pElanInfo;
            pElanInfo = new CALaneCfgElanInfo;

            if (pElanInfo)
            {
                pElanInfo->m_fNewElan = TRUE;

                //  Install a virtual miniport for a default ELAN
                INetCfgComponent*   pnccAtmElan;

                hr = HrAddOrRemoveAdapter(m_pnc, c_szInfId_MS_AtmElan,
                                          ARA_ADD, NULL, 1, &pnccAtmElan);

                if (SUCCEEDED(hr))
                {
                    Assert(pnccAtmElan);

                    //  Update the BindName
                    PWSTR pszElanBindName;
                    hr = pnccAtmElan->GetBindName(&pszElanBindName);
                    if (S_OK == hr)
                    {
                        pElanInfo->SetElanBindName(pszElanBindName);
                        CoTaskMemFree(pszElanBindName);
                    }

                    //  Update the Device param
                    tstring strAtmElan;
                    strAtmElan = c_szDevice;
                    strAtmElan.append(pElanInfo->SzGetElanBindName());

                    pElanInfo->SetElanDeviceName(strAtmElan.c_str());

                    //  Push the Elan onto the the adapter's list
                    pAdapterInfo->m_lstElans.push_back(pElanInfo);

                    //  Push the Adapter onto the adapter list
                    m_lstAdaptersPrimary.push_back(pAdapterInfo);

                    //  Mark the in-memory configuration dirty
                    m_fDirty = TRUE;

                    ReleaseObj(pnccAtmElan);
                }
            }
        }
    }

    TraceError("CALaneCfg::HrNotifyBindingAdd", hr);
    return hr;
}

HRESULT
CALaneCfg::HrNotifyBindingRemove (
    INetCfgComponent* pnccAdapter,
    PCWSTR pszBindName)
{
    HRESULT hr = S_OK;
    CALaneCfgAdapterInfo *  pAdapterInfo;

    //  search the in-memory list for this adapter
    BOOL    fFound;
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    for (iterLstAdapters = m_lstAdaptersPrimary.begin(), fFound = FALSE;
            iterLstAdapters != m_lstAdaptersPrimary.end();
            iterLstAdapters++)
    {
        pAdapterInfo = *iterLstAdapters;

        if (!lstrcmpiW (pszBindName, pAdapterInfo->SzGetAdapterBindName()))
        {
            fFound = TRUE;
            break;
        }
    }

    if (fFound)
    {
        // mark it deleted
        pAdapterInfo->m_fDeleted = TRUE;

        // mark as binding changed
        pAdapterInfo->m_fBindingChanged = TRUE;

        // if this is upgrade, then mark all associated ELANs deleted
        // otherwise, delete them now
        HRESULT hrElan = S_OK;

        for (ELAN_INFO_LIST::iterator iterLstElans = pAdapterInfo->m_lstElans.begin();
             iterLstElans!= pAdapterInfo->m_lstElans.end();
             iterLstElans++)
        {
            if (!m_fUpgrade)
            {
                // Remove corresponding miniport.
                hrElan = HrRemoveMiniportInstance((*iterLstElans)->SzGetElanBindName());

                if (SUCCEEDED(hr))
                {
                    (*iterLstElans)->m_fDeleted = TRUE;
                }
                else
                {
                    TraceError("HrRemoveMiniportInstance failed", hrElan);
                    hrElan = S_OK;
                }
            }
        }

        // mark the in-memory configuration dirty
        m_fDirty = TRUE;
    }

    TraceError("CALaneCfg::HrNotifyBindingRemove", hr);
    return hr;
}

HRESULT CALaneCfg::HrLoadConfiguration()
{
    HRESULT     hr  = S_OK;

    // mark the memory version of the registy valid
    m_fValid = TRUE;

    // open adapter list subkey
    HKEY    hkeyAdapterList = NULL;

    // Try to open an existing key first.
    //
    hr = HrRegOpenAdapterKey(c_szAtmLane, FALSE, &hkeyAdapterList);
    if (FAILED(hr))
    {
        // Only on failure do we try to create it
        //
        hr = HrRegOpenAdapterKey(c_szAtmLane, TRUE, &hkeyAdapterList);
    }
    if (S_OK == hr)
    {
        WCHAR       szBuf[MAX_PATH+1];
        FILETIME    time;
        DWORD       dwSize;
        DWORD       dwRegIndex = 0;

        dwSize = celems(szBuf);
        while (S_OK == (hr = HrRegEnumKeyEx (hkeyAdapterList, dwRegIndex,
                szBuf, &dwSize, NULL, NULL, &time)))
        {
            Assert(szBuf);

            // load this adapter's config
            hr = HrLoadAdapterConfiguration (hkeyAdapterList, szBuf);
            if (S_OK != hr)
            {
                TraceTag (ttidAtmLane, "CALaneCfg::HrLoadConfiguration failed on adapter %S", szBuf);
                hr = S_OK;
            }

            // increment index and reset size variable
            dwRegIndex++;
            dwSize = celems (szBuf);
        }

        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            hr = S_OK;
        }

        RegCloseKey (hkeyAdapterList);
    }

    TraceError("CALaneCfg::HrLoadConfiguration", hr);
    return hr;
}

HRESULT CALaneCfg::HrLoadAdapterConfiguration(HKEY hkeyAdapterList,
                                              PWSTR pszAdapterName)
{
    HRESULT hr = S_OK;

    // load this adapter
    CALaneCfgAdapterInfo*   pAdapterInfo;
    pAdapterInfo = new CALaneCfgAdapterInfo;

    if (pAdapterInfo)
    {
        pAdapterInfo->SetAdapterBindName(pszAdapterName);
        m_lstAdaptersPrimary.push_back(pAdapterInfo);

        // open this adapter's subkey
        HKEY    hkeyAdapter = NULL;
        DWORD   dwDisposition;

        hr = HrRegCreateKeyEx(
                    hkeyAdapterList,
                    pszAdapterName,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hkeyAdapter,
                    &dwDisposition);

        if (S_OK == hr)
        {
            // load the PnpId
            INetCfgComponent*   pnccAdapter    = NULL;
            hr = HrFindNetCardInstance(pszAdapterName, &pnccAdapter);
            if (S_OK == hr)
            {
                PWSTR pszPnpDevNodeId;
                hr = pnccAdapter->GetPnpDevNodeId(&pszPnpDevNodeId);
                if (S_OK == hr)
                {
                    Assert(pszPnpDevNodeId);
                    pAdapterInfo->SetAdapterPnpId(pszPnpDevNodeId);
                    CoTaskMemFree(pszPnpDevNodeId);
                }

                GUID guidAdapter;
                hr = pnccAdapter->GetInstanceGuid(&guidAdapter); 
                if (S_OK == hr)
                {
                    pAdapterInfo->m_guidInstanceId = guidAdapter;
                }

                // load the ElanList
                hr = HrLoadElanListConfiguration(hkeyAdapter, pAdapterInfo);

                ReleaseObj(pnccAdapter);
            }
            else if (S_FALSE == hr)
            {
                // nromalize return
                hr = S_OK;
            }

            RegCloseKey(hkeyAdapter);
        }
    }

    TraceError("CALaneCfg::HrLoadAdapterConfiguration", hr);
    return hr;
}

HRESULT
CALaneCfg::HrLoadElanListConfiguration(
    HKEY hkeyAdapter,
    CALaneCfgAdapterInfo* pAdapterInfo)
{
    HRESULT hr;

    // open the ElanList subkey
    HKEY    hkeyElanList    = NULL;
    DWORD   dwDisposition;
    hr = HrRegCreateKeyEx(hkeyAdapter, c_szElanList, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL, &hkeyElanList, &dwDisposition);

    if (S_OK == hr)
    {

        WCHAR       szBuf[MAX_PATH+1];
        FILETIME    time;
        DWORD       dwSize;
        DWORD       dwRegIndex = 0;

        dwSize = celems(szBuf);
        while(SUCCEEDED(hr = HrRegEnumKeyEx(hkeyElanList, dwRegIndex, szBuf,
                                            &dwSize, NULL, NULL, &time)))
        {
            Assert(szBuf);

            // load this ELAN's config
            hr = HrLoadElanConfiguration(hkeyElanList,
                                         szBuf,
                                         pAdapterInfo);
            if (S_OK != hr)
            {
                TraceTag(ttidAtmLane, "CALaneCfg::HrLoadConfiguration failed on Elan %S", szBuf);
                hr = S_OK;
            }
            else if (m_fNoElanInstalled)
            {
                m_fNoElanInstalled = FALSE;
            }

            // increment index and reset size variable
            dwRegIndex ++;
            dwSize = celems(szBuf);
        }

        if(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
            hr = S_OK;

        RegCloseKey(hkeyElanList);
    }

    TraceError("CALaneCfg::HrLoadElanListConfiguration", hr);
    return hr;
}

HRESULT
CALaneCfg::HrLoadElanConfiguration(
    HKEY hkeyElanList,
    PWSTR pszElan,
    CALaneCfgAdapterInfo* pAdapterInfo)
{
    HRESULT hr  = S_OK;

    do
    {
		// load this ELAN info
		CALaneCfgElanInfo * pElanInfo = NULL;
		pElanInfo = new CALaneCfgElanInfo;

		CALaneCfgElanInfo * pOldElanInfo = NULL;
		pOldElanInfo = new CALaneCfgElanInfo;

		if ((pElanInfo == NULL) ||
			(pOldElanInfo == NULL))
		{
			hr = E_OUTOFMEMORY;
			if (pElanInfo)
			{
				delete pElanInfo;
			}
			if (pOldElanInfo)
			{
				delete pOldElanInfo;
			}

			break;
        }

		pAdapterInfo->m_lstElans.push_back(pElanInfo);
		pElanInfo->SetElanBindName(pszElan);

		pAdapterInfo->m_lstOldElans.push_back(pOldElanInfo);
		pOldElanInfo->SetElanBindName(pszElan);

		// open the ELAN's key
		HKEY    hkeyElan    = NULL;
		DWORD   dwDisposition;
		hr = HrRegCreateKeyEx (hkeyElanList, pszElan, REG_OPTION_NON_VOLATILE,
				KEY_ALL_ACCESS, NULL, &hkeyElan, &dwDisposition);

		if (S_OK == hr)
		{
			// read the Device parameter
			PWSTR pszElanDevice;
			hr = HrRegQuerySzWithAlloc (hkeyElan, c_szElanDevice, &pszElanDevice);
			if (S_OK == hr)
			{
				// load the Device name
				pElanInfo->SetElanDeviceName(pszElanDevice);
				pOldElanInfo->SetElanDeviceName(pszElanDevice);
				MemFree (pszElanDevice);

				// read the ELAN Name parameter
				PWSTR pszElanName;
				hr = HrRegQuerySzWithAlloc (hkeyElan, c_szElanName, &pszElanName);
				if (SUCCEEDED(hr))
				{
					// load the ELAN name
					pElanInfo->SetElanName (pszElanName);
					pOldElanInfo->SetElanName (pszElanName);
					MemFree (pszElanName);
				}
			}
			RegCloseKey (hkeyElan);
		}
	}
	while (FALSE);

    TraceError ("CALaneCfg::HrLoadElanConfiguration", hr);
    return hr;
}

HRESULT CALaneCfg::HrFlushConfiguration()
{
    HRESULT hr  = S_OK;
    HKEY    hkeyAdapterList = NULL;

    //  Open the "Adapters" list key
    hr = ::HrRegOpenAdapterKey(c_szAtmLane, TRUE, &hkeyAdapterList);

    if (S_OK == hr)
    {
        ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
        CALaneCfgAdapterInfo *  pAdapterInfo;

        HRESULT hrTmp;

        //  Iterate thru the adapters
        for (iterLstAdapters = m_lstAdaptersPrimary.begin();
             iterLstAdapters != m_lstAdaptersPrimary.end();
             iterLstAdapters++)
        {
            pAdapterInfo = *iterLstAdapters;

            //  Flush this adapter's configuration
            hrTmp = HrFlushAdapterConfiguration(hkeyAdapterList, pAdapterInfo);
            if (SUCCEEDED(hrTmp))
            {
                // Raid #255910: only send Elan change notification if the
                // binding to the physical adapter has not changed
                if (!pAdapterInfo->m_fBindingChanged)
                {
                    // Compare Elan list and send notifications
                    hrTmp = HrReconfigLane(pAdapterInfo);

                    if (FAILED(hrTmp))
                        hrTmp = NETCFG_S_REBOOT;
                }
            }
            else
            {
                TraceTag(ttidAtmLane,"HrFlushAdapterConfiguration failed for adapter %S", pAdapterInfo->SzGetAdapterBindName());
                hrTmp = S_OK;
            }

            if (S_OK ==hr)
                hr = hrTmp;
        }
        RegCloseKey(hkeyAdapterList);
    }

    if (hr != NETCFG_S_REBOOT) {
        TraceError("CALaneCfg::HrFlushConfiguration", hr);
    }

    return hr;
}

HRESULT CALaneCfg::HrFlushAdapterConfiguration(HKEY hkeyAdapterList,
                                               CALaneCfgAdapterInfo *pAdapterInfo)
{
    HRESULT hr  = S_OK;

    HKEY    hkeyAdapter     = NULL;
    DWORD   dwDisposition;

    if (pAdapterInfo->m_fDeleted)
    {
        //  Adapter is marked for deletion
        //  Delete this adapter's whole registry branch
        hr = HrRegDeleteKeyTree(hkeyAdapterList,
                                pAdapterInfo->SzGetAdapterBindName());
    }
    else
    {
        // open this adapter's subkey
        hr = HrRegCreateKeyEx(
                                hkeyAdapterList,
                                pAdapterInfo->SzGetAdapterBindName(),
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hkeyAdapter,
                                &dwDisposition);

        if (S_OK == hr)
        {
            //  Flush the ELAN configuration
            hr = HrFlushElanListConfiguration(hkeyAdapter, pAdapterInfo);

            RegCloseKey(hkeyAdapter);
        }
    }

    TraceError("CALaneCfg::HrFlushAdapterConfiguration", hr);
    return hr;
}

HRESULT CALaneCfg::HrFlushElanListConfiguration(HKEY hkeyAdapter,
                                                CALaneCfgAdapterInfo *pAdapterInfo)
{
    HRESULT hr  = S_OK;

    HKEY    hkeyElanList    = NULL;
    DWORD   dwDisposition;

    //  Open the Elan list subkey
    hr = HrRegCreateKeyEx(
                            hkeyAdapter,
                            c_szElanList,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hkeyElanList,
                            &dwDisposition);

    if (S_OK == hr)
    {
        ELAN_INFO_LIST::iterator    iterLstElans;
        CALaneCfgElanInfo *         pElanInfo;

        // iterate thru the Elans
        for (iterLstElans = pAdapterInfo->m_lstElans.begin();
             iterLstElans != pAdapterInfo->m_lstElans.end();
             iterLstElans++)
        {
            pElanInfo = *iterLstElans;

            hr = HrFlushElanConfiguration(hkeyElanList, pElanInfo);
            if (FAILED(hr))
            {
                TraceError("HrFlushElanConfiguration failure", hr);
                hr = S_OK;
            }

            // $REVIEW(tongl 9/9/98): write ATM adapter's pnp id to registry (#169025)
            if ((!pElanInfo->m_fDeleted) && (pElanInfo->m_fNewElan))
            {
                INetCfgComponent * pnccAtmElan;
                hr = HrFindNetCardInstance(pElanInfo->SzGetElanBindName(),
                                           &pnccAtmElan);
                if (S_OK == hr)
                {
                    HKEY hkeyElan = NULL;

                    hr = pnccAtmElan->OpenParamKey(&hkeyElan);
                    if (S_OK == hr)
                    {
                        Assert(hkeyElan);
                        HrRegSetSz(hkeyElan, c_szAtmAdapterPnpId,
                                    pAdapterInfo->SzGetAdapterPnpId());
                    }
                    RegSafeCloseKey(hkeyElan);
                }
                ReleaseObj(pnccAtmElan);
            }
        }

        RegCloseKey(hkeyElanList);
    }

    TraceError("CALaneCfg::HrFlushElanListConfiguration", hr);
    return hr;
}

HRESULT CALaneCfg::HrFlushElanConfiguration(HKEY hkeyElanList,
                                            CALaneCfgElanInfo *pElanInfo)
{
    HRESULT hr  = S_OK;
    
    if (pElanInfo->m_fDeleted)
    {
        PCWSTR szBindName = pElanInfo->SzGetElanBindName();

        if (lstrlenW(szBindName)) // only if the bindname is not empty
        {
            //  Elan is marked for deletion
            //  Delete this Elan's whole registry branch
            hr = HrRegDeleteKeyTree(hkeyElanList,
                                    pElanInfo->SzGetElanBindName());
        }
    }
    else
    {
        HKEY    hkeyElan = NULL;
        DWORD   dwDisposition;

        // open/create this Elan's key
        hr = HrRegCreateKeyEx(
                                hkeyElanList,
                                pElanInfo->SzGetElanBindName(),
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hkeyElan,
                                &dwDisposition);

        if (S_OK == hr)
        {
            //  Write the Device parameter
            hr = HrRegSetSz(hkeyElan, c_szElanDevice,
                            pElanInfo->SzGetElanDeviceName());

            if (FAILED(hr))
            {
                TraceError("Failed save Elan device parameter", hr);
                hr = S_OK;
            }

            //  Write the ElanName parameter
            hr = HrRegSetSz(hkeyElan, c_szElanName,
                            pElanInfo->SzGetElanName());

            if (FAILED(hr))
            {
                TraceError("Failed save Elan name parameter", hr);
                hr = S_OK;
            }
        }
        RegSafeCloseKey(hkeyElan);
    }

    TraceError("CALaneCfg::HrFlushElanConfiguration", hr);
    return hr;
}

HRESULT CALaneCfg::HrRemoveMiniportInstance(PCWSTR pszBindNameToRemove)
{
    // Enumerate adapters in the system.
    //
    HRESULT hr = S_OK;
    CIterNetCfgComponent nccIter (m_pnc, &GUID_DEVCLASS_NET);
    BOOL fFound = FALSE;

    INetCfgComponent* pnccAdapter;
    while ((!fFound) && SUCCEEDED(hr) &&
           S_OK == (hr = nccIter.HrNext (&pnccAdapter)))
    {
        if (FIsComponentId(c_szInfId_MS_AtmElan, pnccAdapter))
        {
            //  Get the bindname of the miniport
            PWSTR pszBindName;
            hr = pnccAdapter->GetBindName(&pszBindName);

            if (S_OK == hr)
            {
                //  If the right one tell it to remove itself and end
                BOOL fRemove = !lstrcmpiW (pszBindName, pszBindNameToRemove);

                if (fRemove)
                {
                    fFound = TRUE;
                    hr = HrRemoveComponent( m_pnc, pnccAdapter, NULL, NULL);
                }

                CoTaskMemFree (pszBindName);
            }
        }
        ReleaseObj (pnccAdapter);
    }

    TraceError("CALaneCfg::HrRemoveMiniportInstance", hr);
    return hr;
}

HRESULT
CALaneCfg::HrFindNetCardInstance(
    PCWSTR             pszBindNameToFind,
    INetCfgComponent** ppncc)
{
    *ppncc = NULL;

    // Enumerate adapters in the system.
    //
    HRESULT hr = S_OK;
    CIterNetCfgComponent nccIter (m_pnc, &GUID_DEVCLASS_NET);
    BOOL fFound = FALSE;

    INetCfgComponent* pnccAdapter;
    while ((!fFound) && SUCCEEDED(hr) &&
           S_OK == (hr = nccIter.HrNext (&pnccAdapter)))
    {
        //  Get the bindname of the miniport
        PWSTR pszBindName;
        hr = pnccAdapter->GetBindName(&pszBindName);

        if (S_OK == hr)
        {
            //  If the right one tell it to remove itself and end
            fFound = !lstrcmpiW(pszBindName, pszBindNameToFind);
            CoTaskMemFree (pszBindName);

            if (fFound)
            {
                *ppncc = pnccAdapter;
            }
        }

        if (!fFound)
        {
            ReleaseObj (pnccAdapter);
        }
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "CALaneCfg::HrFindNetCardInstance", hr);
    return hr;
}

VOID CALaneCfg::HrMarkAllDeleted()
{
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    ELAN_INFO_LIST::iterator            iterLstElans;

    // loop thru the adapter list
    for (iterLstAdapters = m_lstAdaptersPrimary.begin();
            iterLstAdapters != m_lstAdaptersPrimary.end();
            iterLstAdapters++)
    {
        (*iterLstAdapters)->m_fDeleted = TRUE;

        // loop thru the ELAN list
        for (iterLstElans = (*iterLstAdapters)->m_lstElans.begin();
                iterLstElans != (*iterLstAdapters)->m_lstElans.end();
                iterLstElans++)
        {
            (*iterLstElans)->m_fDeleted = TRUE;
        }
    }

    return;
}

VOID CALaneCfg::UpdateElanDisplayNames()
{
    HRESULT hr = S_OK;

    // loop thru the adapter list
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    for (iterLstAdapters = m_lstAdaptersPrimary.begin();
            iterLstAdapters != m_lstAdaptersPrimary.end();
            iterLstAdapters++)
    {
        // loop thru the ELAN list
        ELAN_INFO_LIST::iterator    iterLstElans;
        CALaneCfgElanInfo * pElanInfo;

        for (iterLstElans = (*iterLstAdapters)->m_lstElans.begin();
                iterLstElans != (*iterLstAdapters)->m_lstElans.end();
                iterLstElans++)
        {
            pElanInfo = *iterLstElans;

            //  Update the miniport's display name with
            //  the ELAN name appended.
            INetCfgComponent*   pnccAtmElan   = NULL;
            hr = HrFindNetCardInstance(pElanInfo->SzGetElanBindName(),
                                       &pnccAtmElan);
            if (S_OK == hr)
            {
                PWSTR pszDisplayName;
                hr = pnccAtmElan->GetDisplayName(&pszDisplayName);
                if (S_OK == hr)
                {
                    tstring     strNewDisplayName;
                    int         pos;

                    strNewDisplayName = pszDisplayName;
                    pos = strNewDisplayName.find_last_of(L"(");
                    if (pos != strNewDisplayName.npos)
                        strNewDisplayName.resize(pos);
                    strNewDisplayName.append(L"(");

                    if (lstrlenW(pElanInfo->SzGetElanName()) > 0)
                    {
                        strNewDisplayName.append(pElanInfo->SzGetElanName());
                    }
                    else
                    {
                        strNewDisplayName.append(SzLoadIds(IDS_ALANECFG_UNSPECIFIEDNAME));
                    }

                    strNewDisplayName.append(L")");

                    (VOID)pnccAtmElan->SetDisplayName(strNewDisplayName.c_str());
                    CoTaskMemFree(pszDisplayName);
                }

                ReleaseObj(pnccAtmElan);
            }
        }
    }
}

HRESULT CALaneCfg::HrALaneSetupPsh(HPROPSHEETPAGE** pahpsp)
{
    HRESULT             hr      = S_OK;
    HPROPSHEETPAGE*     ahpsp   = NULL;

    AssertSz(pahpsp, "We must have a place to put prop sheets");

    // set connections context
    hr = HrSetConnectionContext();
    if SUCCEEDED(hr)
    {
        // copy the primary adapter list to the secondary adapters list
        CopyAdapterInfoPrimaryToSecondary();

        *pahpsp = NULL;

        // Allocate a buffer large enough to hold the handles to all of our
        // property pages.
        ahpsp = (HPROPSHEETPAGE*)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE));
        if (ahpsp)
        {
            if (!m_ppsp)
                delete m_ppsp;

            // Allocate each of the CPropSheetPage objects
            m_ppsp = new CALanePsh(this, m_pAdapterSecondary, g_aHelpIDs_IDD_MAIN);

            // Create the actual PROPSHEETPAGE for each object.
            // This needs to be done regardless of whether the classes existed before.
            ahpsp[0] = m_ppsp->CreatePage(IDD_MAIN, PSP_DEFAULT);

            *pahpsp = ahpsp;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceError("CALaneCfg::HrALaneSetupPsh", hr);
    return hr;
}

// Added by tongl at 12\11\97
HRESULT CALaneCfg::HrSetConnectionContext()
{
    AssertSz(m_pUnkContext, "Invalid IUnknown pointer passed to CALaneCfg::SetContext?");

    if (!m_pUnkContext)
        return E_FAIL;

    HRESULT hr = S_OK;
    GUID guidConn;

    // Is this a lan connection ?
    INetLanConnectionUiInfo * pLanConnUiInfo;
    hr = m_pUnkContext->QueryInterface( IID_INetLanConnectionUiInfo,
                                        reinterpret_cast<LPVOID *>(&pLanConnUiInfo));
    if (S_OK == hr)
    {
        // yes, lan connection
        pLanConnUiInfo->GetDeviceGuid(&guidConn);

        WCHAR szGuid[c_cchGuidWithTerm];
        INT cch = StringFromGUID2(guidConn, szGuid, c_cchGuidWithTerm);
        Assert(cch);
        m_strGuidConn = szGuid;
    }
    ReleaseObj(pLanConnUiInfo);

    TraceError("CALaneCfg::HrSetConnectionContext", hr);
    return hr;
}

VOID CALaneCfg::CopyAdapterInfoPrimaryToSecondary()
{
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    CALaneCfgAdapterInfo *              pAdapterInfo;

    ELAN_INFO_LIST::iterator            iterLstElans;
    CALaneCfgElanInfo *                 pElanInfo;
    CALaneCfgElanInfo *                 pElanInfoNew;

    // free any existing secondary data
    ClearAdapterInfo(m_pAdapterSecondary);
    m_pAdapterSecondary = NULL;

    // loop thru the primary adapter list
    for (iterLstAdapters = m_lstAdaptersPrimary.begin();
            iterLstAdapters != m_lstAdaptersPrimary.end();
            iterLstAdapters++)
    {
        pAdapterInfo = *iterLstAdapters;

        // create new and copy from primary
        if (FIsSubstr(m_strGuidConn.c_str(), pAdapterInfo->SzGetAdapterBindName()))
        {
            // we found a match
            m_pAdapterSecondary = new CALaneCfgAdapterInfo;

            m_pAdapterSecondary->m_guidInstanceId = pAdapterInfo-> m_guidInstanceId;
            m_pAdapterSecondary->m_fDeleted = pAdapterInfo->m_fDeleted;
            m_pAdapterSecondary->SetAdapterBindName(pAdapterInfo->SzGetAdapterBindName());
            m_pAdapterSecondary->SetAdapterPnpId(pAdapterInfo->SzGetAdapterPnpId());

            // loop thru the elan list on this adapter

            for (iterLstElans = pAdapterInfo->m_lstElans.begin();
                    iterLstElans != pAdapterInfo->m_lstElans.end();
                    iterLstElans++)
            {
                pElanInfo = *iterLstElans;

                // create new and copy from primary
                pElanInfoNew = new CALaneCfgElanInfo;

                pElanInfoNew->SetElanBindName(pElanInfo->SzGetElanBindName());
                pElanInfoNew->SetElanDeviceName(pElanInfo->SzGetElanDeviceName());
                pElanInfoNew->SetElanName(pElanInfo->SzGetElanName());
                pElanInfoNew->m_fDeleted = pElanInfo->m_fDeleted;
                pElanInfoNew->m_fNewElan = pElanInfo->m_fNewElan;
                pElanInfoNew->m_fRemoveMiniportOnPropertyApply = FALSE;
                pElanInfoNew->m_fCreateMiniportOnPropertyApply = FALSE;

                // push onto new secondary adapter's elan list

                m_pAdapterSecondary->m_lstElans.push_back(pElanInfoNew);
            }
            break;
        }
    }

    Assert(m_pAdapterSecondary != NULL);
    return;
}

VOID CALaneCfg::CopyAdapterInfoSecondaryToPrimary()
{
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    CALaneCfgAdapterInfo *              pAdapterInfo;
    CALaneCfgAdapterInfo *              pAdapterInfoNew;
    ELAN_INFO_LIST::iterator            iterLstElans;
    CALaneCfgElanInfo *                 pElanInfo;
    CALaneCfgElanInfo *                 pElanInfoNew;

    // loop thru the primary adapter list
    for (iterLstAdapters = m_lstAdaptersPrimary.begin();
            iterLstAdapters != m_lstAdaptersPrimary.end();
            iterLstAdapters++)
    {
        pAdapterInfo = *iterLstAdapters;

        if (FIsSubstr(m_strGuidConn.c_str(), pAdapterInfo->SzGetAdapterBindName()))
        {
            pAdapterInfo->m_fDeleted = m_pAdapterSecondary->m_fDeleted;
            pAdapterInfo->SetAdapterBindName(m_pAdapterSecondary->SzGetAdapterBindName());
            pAdapterInfo->SetAdapterPnpId(m_pAdapterSecondary->SzGetAdapterPnpId());

            // rebuild Elan list
            ClearElanList(&pAdapterInfo->m_lstElans);

            // loop thru the elan list on this adapter
            for (iterLstElans = m_pAdapterSecondary->m_lstElans.begin();
                    iterLstElans != m_pAdapterSecondary->m_lstElans.end();
                    iterLstElans++)
            {
                pElanInfo = *iterLstElans;

                // create new and copy from secondary
                pElanInfoNew = new CALaneCfgElanInfo;

                pElanInfoNew->SetElanBindName(pElanInfo->SzGetElanBindName());
                pElanInfoNew->SetElanDeviceName(pElanInfo->SzGetElanDeviceName());
                pElanInfoNew->SetElanName(pElanInfo->SzGetElanName());
                pElanInfoNew->m_fDeleted = pElanInfo->m_fDeleted;
                pElanInfoNew->m_fNewElan = pElanInfo->m_fNewElan;
                pElanInfoNew->m_fRemoveMiniportOnPropertyApply = FALSE;
                pElanInfoNew->m_fCreateMiniportOnPropertyApply = FALSE;

                // add to adapter's elan list
                pAdapterInfo->m_lstElans.push_back(pElanInfoNew);
            }
            break;
        }
    }
    return;
}

HRESULT CALaneCfg::HrReconfigLane(CALaneCfgAdapterInfo * pAdapterInfo)
{
    HRESULT hr = S_OK;

    // Note: if atm physical adapter is deleted, no notification of removing elan
    // is necessary. Lane protocol driver will know to delete all the elans
    // (confirmed above with ArvindM 3/12).

    // Raid #371343, don't send notification if ATM card not connected
    if ((!pAdapterInfo->m_fDeleted) && 
        FIsAdapterEnabled(&(pAdapterInfo->m_guidInstanceId)))  
    {
        ElanChangeType elanChangeType;

        // loop thru the elan list on this adapter
        ELAN_INFO_LIST::iterator    iterLstElans;

        for (iterLstElans = pAdapterInfo->m_lstElans.begin();
                iterLstElans != pAdapterInfo->m_lstElans.end();
                iterLstElans++)
        {
            CALaneCfgElanInfo * pElanInfo = *iterLstElans;

            // if this Elan is marked as for delete
            if (pElanInfo->m_fDeleted)
            {
                PCWSTR szBindName = pElanInfo->SzGetElanBindName();

                if (lstrlenW(szBindName)) // only if the bindname is not empty
                {
                    // notify deletion
                    elanChangeType = DEL_ELAN;
                    hr = HrNotifyElanChange(pAdapterInfo, pElanInfo,
                                            elanChangeType);
                }
            }
            else
            {
                BOOL fFound = FALSE;

                ELAN_INFO_LIST::iterator    iterLstOldElans;

                // loop through the old elan list, see if we can find a match
                for (iterLstOldElans = pAdapterInfo->m_lstOldElans.begin();
                        iterLstOldElans != pAdapterInfo->m_lstOldElans.end();
                        iterLstOldElans++)
                {
                    CALaneCfgElanInfo * pOldElanInfo = * iterLstOldElans;

                    if (0 == lstrcmpiW(pElanInfo->SzGetElanBindName(),
                                      pOldElanInfo->SzGetElanBindName()))
                    {
                        // we found a match
                        fFound = TRUE;

                        // has the elan name changed ?
                        if (lstrcmpiW(pElanInfo->SzGetElanName(),
                                     pOldElanInfo->SzGetElanName()) != 0)
                        {
                            elanChangeType = MOD_ELAN;
                            hr = HrNotifyElanChange(pAdapterInfo, pElanInfo,
                                                    elanChangeType);
                        }
                    }
                }

                if (!fFound)
                {
                    elanChangeType = ADD_ELAN;
                    hr = HrNotifyElanChange(pAdapterInfo, pElanInfo,
                                            elanChangeType);

                    // Raid #384380: If no ELAN was installed, ignore the error
                    if ((S_OK != hr) &&(m_fNoElanInstalled))
                    {
                        TraceError("Adding ELAN failed but error ignored since there was no ELAN installed so LANE driver is not started, reset hr to S_OK", hr);
                        hr = S_OK;
                    }
                }
            }
        }
    }

    TraceError("CALaneCfg::HrReconfigLane", hr);
    return hr;
}

HRESULT CALaneCfg::HrNotifyElanChange(CALaneCfgAdapterInfo * pAdapterInfo,
                                      CALaneCfgElanInfo * pElanInfo,
                                      ElanChangeType elanChangeType)
{
    // ATMLANE_PNP_RECONFIG_REQUEST is defined in \nt\private\inc\laneinfo.h

    const DWORD dwBytes = sizeof(ATMLANE_PNP_RECONFIG_REQUEST) +
                          CbOfSzAndTerm (pElanInfo->SzGetElanBindName());

    ATMLANE_PNP_RECONFIG_REQUEST* pLaneReconfig;

    HRESULT hr = HrMalloc (dwBytes, (PVOID*)&pLaneReconfig);
    if (SUCCEEDED(hr))
    {
        pLaneReconfig->Version =1;
        pLaneReconfig->OpType = elanChangeType;
        pLaneReconfig->ElanKeyLength = lstrlenW(pElanInfo->SzGetElanBindName())+1;
        lstrcpyW(pLaneReconfig->ElanKey, pElanInfo->SzGetElanBindName());

        hr = HrSendNdisPnpReconfig( NDIS, c_szAtmLane,
                                    pAdapterInfo->SzGetAdapterBindName(),
                                    pLaneReconfig,
                                    dwBytes);
        if ( S_OK != hr)
        {
            TraceError("Notifying LANE of ELAN change returns failure, prompt for reboot ...", hr);
            hr = NETCFG_S_REBOOT;
        }

        MemFree (pLaneReconfig);
    }
    TraceError("CALaneCfg::HrNotifyElanChange", hr);
    return hr;
}

BOOL CALaneCfg::FIsAdapterEnabled(const GUID* pguidId)
{
    FARPROC pfnHrGetPnpDeviceStatus;
    HMODULE hNetman;

    HRESULT         hr = S_OK;
    NETCON_STATUS   ncStatus = NCS_CONNECTED;

    hr = HrLoadLibAndGetProc(L"netman.dll", "HrGetPnpDeviceStatus",
                             &hNetman, &pfnHrGetPnpDeviceStatus);

    if (SUCCEEDED(hr))
    {
        hr = (*(PHRGETPNPDEVICESTATUS)pfnHrGetPnpDeviceStatus)(
                pguidId, &ncStatus);

        FreeLibrary(hNetman);
    }

    return (NCS_CONNECTED == ncStatus);
}

//
//  CALaneCfgAdapterInfo
//

CALaneCfgAdapterInfo::CALaneCfgAdapterInfo(VOID)
{
    m_fDeleted = FALSE;
    m_fBindingChanged = FALSE;

    return;
}

CALaneCfgAdapterInfo::~CALaneCfgAdapterInfo(VOID)
{
    ClearElanList(&m_lstElans);
    ClearElanList(&m_lstOldElans);
    return;
}

VOID CALaneCfgAdapterInfo::SetAdapterBindName(PCWSTR pszAdapterBindName)
{
    m_strAdapterBindName = pszAdapterBindName;
    return;
}

PCWSTR CALaneCfgAdapterInfo::SzGetAdapterBindName(VOID)
{
    return m_strAdapterBindName.c_str();
}

VOID CALaneCfgAdapterInfo::SetAdapterPnpId(PCWSTR pszAdapterPnpId)
{
    m_strAdapterPnpId = pszAdapterPnpId;
    return;
}

PCWSTR CALaneCfgAdapterInfo::SzGetAdapterPnpId(VOID)
{
    return m_strAdapterPnpId.c_str();
}

//
//  CALaneCfgElanInfo
//

CALaneCfgElanInfo::CALaneCfgElanInfo(VOID)
{
    m_fDeleted = FALSE;
    m_fNewElan = FALSE;

    m_fCreateMiniportOnPropertyApply = FALSE;
    m_fRemoveMiniportOnPropertyApply = FALSE;
    return;
}

VOID CALaneCfgElanInfo::SetElanBindName(PCWSTR pszElanBindName)
{
    m_strElanBindName = pszElanBindName;
    return;
}

PCWSTR CALaneCfgElanInfo::SzGetElanBindName(VOID)
{
    return m_strElanBindName.c_str();
}

VOID CALaneCfgElanInfo::SetElanDeviceName(PCWSTR pszElanDeviceName)
{
    m_strElanDeviceName = pszElanDeviceName;
    return;
}

PCWSTR CALaneCfgElanInfo::SzGetElanDeviceName(VOID)
{
    return m_strElanDeviceName.c_str();
}

VOID CALaneCfgElanInfo::SetElanName(PCWSTR pszElanName)
{
    m_strElanName = pszElanName;
    return;
}

VOID CALaneCfgElanInfo::SetElanName(PWSTR pszElanName)
{
    m_strElanName = pszElanName;
    return;
}

PCWSTR CALaneCfgElanInfo::SzGetElanName(VOID)
{
    return m_strElanName.c_str();
}

// utility functions

void ClearElanList(ELAN_INFO_LIST *plstElans)
{
    ELAN_INFO_LIST::iterator            iterLstElans;
    CALaneCfgElanInfo *                 pElanInfo;

    for (iterLstElans = plstElans->begin();
            iterLstElans != plstElans->end();
            iterLstElans++)
    {
        pElanInfo = *iterLstElans;
        delete pElanInfo;
    }

    plstElans->clear();
    return;
}

void ClearAdapterList(ATMLANE_ADAPTER_INFO_LIST *plstAdapters)
{
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    CALaneCfgAdapterInfo *              pAdapterInfo;
    ELAN_INFO_LIST::iterator            iterLstElans;

    for (iterLstAdapters = plstAdapters->begin();
            iterLstAdapters != plstAdapters->end();
            iterLstAdapters++)
    {

        pAdapterInfo = *iterLstAdapters;

        ClearElanList(&pAdapterInfo->m_lstElans);

        delete pAdapterInfo;
    }

    plstAdapters->clear();

    return;
}

void ClearAdapterInfo(CALaneCfgAdapterInfo * pAdapterInfo)
{
    ELAN_INFO_LIST::iterator            iterLstElans;

    if (pAdapterInfo)
    {
        ClearElanList(&pAdapterInfo->m_lstElans);
        delete pAdapterInfo;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\alanecfg\resource.h ===
#include <ncres.h>

#define IDS_ALANECFG_UNSPECIFIEDNAME     (IDS_NC_ALANECFG + 1)
#define IDS_MSFT_LANE_TEXT               (IDS_NC_ALANECFG + 2)
#define IDS_DUPLICATE_ELANNAME           (IDS_NC_ALANECFG + 3)

#define IDD_MAIN                        101
#define IDD_ELAN_PROPERTIES             102
#define IDC_ADAPTER_TEXT                1001
#define IDC_ELAN_GROUP                  1003
#define IDC_ELAN_LIST                   1004
#define IDC_ELAN_ADD                    1005
#define IDC_ELAN_EDIT                   1006
#define IDC_ELAN_REMOVE                 1007
#define IDC_ELAN_NAMETEXT               1008
#define IDC_ELAN_NAME                   1009
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\alanecfg\alanepsh.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A L A N E P S H . H
//
//  Contents:   Dialog box handling for ATM LAN Emulation configuration.
//
//  Notes:
//
//  Author:     v-lcleet   08/10/97
//
//----------------------------------------------------------------------------
#pragma once
#include "alaneobj.h"

void ShowContextHelp(HWND hDlg, UINT uCommand, const DWORD*  pdwHelpIDs); 

//
// Configuration Dialog
//

class CALanePsh: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CALanePsh)

        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive);

        COMMAND_ID_HANDLER(IDC_ELAN_ADD,        OnAdd);
        COMMAND_ID_HANDLER(IDC_ELAN_EDIT,       OnEdit);
        COMMAND_ID_HANDLER(IDC_ELAN_REMOVE,     OnRemove);

    END_MSG_MAP()

    CALanePsh(CALaneCfg* palcfg, CALaneCfgAdapterInfo * pAdapter, 
              const DWORD * adwHelpIDs = NULL);
    ~CALanePsh(VOID);

// Message handlers
public:

    LRESULT OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

public:

    void SendAdapterInfo();
    void SendElanInfo();

    CALaneCfgElanInfo *GetSelectedElan();
    void SetButtons();

    int CheckDupElanName();

    BOOL        m_fEditState;
    tstring     m_strAddElan;

private:
    CALaneCfg*                  m_palcfg;
    CALaneCfgAdapterInfo *      m_pAdapterInfo;

    const DWORD * m_adwHelpIDs;

    HWND    m_hElanList;
    HWND    m_hbtnAdd;
    HWND    m_hbtnEdit;
    HWND    m_hbtnRemove;

};

class CElanPropertiesDialog : public CDialogImpl<CElanPropertiesDialog>
{
public:

    enum { IDD = IDD_ELAN_PROPERTIES };

    BEGIN_MSG_MAP(CElanPropertiesDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        COMMAND_ID_HANDLER(IDOK,            OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,        OnCancel);
    END_MSG_MAP()

public:
    CElanPropertiesDialog(CALanePsh * pCALanePsh, CALaneCfgElanInfo *pElanInfo,
                          const DWORD * adwHelpIDs = NULL);
    ~CElanPropertiesDialog(){};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

private:
    HWND                m_hElanName;
    CALaneCfgElanInfo * m_pElanInfo;

    CALanePsh   * m_pParentDlg;
    const DWORD * m_adwHelpIDs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\alanecfg\alanepsh.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A L A N E P S H . C P P
//
//  Contents:   Dialog box handling for the ATM LAN Emulation configuration.
//
//  Notes:
//
//  Author:     v-lcleet   08/10/1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "alaneobj.h"
#include "alanepsh.h"
#include "alanehlp.h"

#include "ncatlui.h"
#include <stlalgor.h>

//
//  CALanePsh
//
//  Constructor/Destructor methods
//
CALanePsh::CALanePsh(CALaneCfg* palcfg, CALaneCfgAdapterInfo * pAdapterInfo,
                     const DWORD * adwHelpIDs)
{
    AssertSz(palcfg, "We don't have a CALaneCfg*");
    AssertSz(pAdapterInfo, "We don't have a CALaneCfgAdapterInfo *");

    m_palcfg        = palcfg;
    m_pAdapterInfo  = pAdapterInfo;

    m_adwHelpIDs      = adwHelpIDs;

    return;
}

CALanePsh::~CALanePsh(VOID)
{
    return;
}

LRESULT CALanePsh::OnInitDialog(UINT uMsg, WPARAM wParam,
                                LPARAM lParam, BOOL& bHandled)
{
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    m_fEditState = FALSE;

    // Get the Add ELAN button text
    WCHAR   szAddElan[16] = {0};
    GetDlgItemText(IDC_ELAN_ADD, szAddElan, celems(szAddElan));
    szAddElan[lstrlenW(szAddElan) - 3]; // remove ampersand

    m_strAddElan = szAddElan;

    //  get hwnd to the adapter and elan list
    // m_hAdapterList = GetDlgItem(IDC_ADAPTER_LIST);
    m_hElanList = GetDlgItem(IDC_ELAN_LIST);

    //  get hwnd to the three buttons
    m_hbtnAdd = GetDlgItem(IDC_ELAN_ADD);
    m_hbtnEdit = GetDlgItem(IDC_ELAN_EDIT);
    m_hbtnRemove = GetDlgItem(IDC_ELAN_REMOVE);

    //  fill in adapter list
    SendAdapterInfo();

    //  fill in elan list
    SendElanInfo();

    //  set the state of the buttons
    SetButtons();

    SetChangedFlag();

    return 0;
}

LRESULT CALanePsh::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CALanePsh::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CALanePsh::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL err = FALSE; // Allow page to lose active status

    // Check duplicate Elan names on the same ATM adapter
    int iDupElanName = CheckDupElanName();

    if (iDupElanName >=0)
    {
        NcMsgBox(m_hWnd, IDS_MSFT_LANE_TEXT, IDS_DUPLICATE_ELANNAME,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        err = TRUE;
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, err);

    return err;
}

int CALanePsh::CheckDupElanName()
{
    int ret = -1;
    int idx = 0;

    for(ELAN_INFO_LIST::iterator iterElan = m_pAdapterInfo->m_lstElans.begin();
        iterElan != m_pAdapterInfo->m_lstElans.end();
        iterElan++)
    {
        // skip deleted ones
        if (!(*iterElan)->m_fDeleted)
        {
            ELAN_INFO_LIST::iterator iterElanComp = iterElan;

            iterElanComp++;
            while (iterElanComp != m_pAdapterInfo->m_lstElans.end())
            {
                if (!(*iterElanComp)->m_fDeleted)
                {
                    if (!lstrcmpW( ((*iterElan)->SzGetElanName()),
                                   ((*iterElanComp)->SzGetElanName())))
                    {
                        // we find a duplicate name
                        ret = idx;
                        break;
                    }
                }

                iterElanComp++;
            }

            // duplicate name found
            if (ret >=0 )
                break;

            // move next
            idx ++;
        }
    }

    return ret;
}

LRESULT CALanePsh::OnAdd(WORD wNotifyCode, WORD wID,
                         HWND hWndCtl, BOOL& bHandled)
{
    CALaneCfgElanInfo *     pElanInfo   = NULL;
    CElanPropertiesDialog * pDlgProp    = NULL;

    m_fEditState = FALSE;

    //  create a new ELAN info object
    pElanInfo = new CALaneCfgElanInfo;

    //  create the dialog object, passing in the new ELAN info ptr
    pDlgProp = new CElanPropertiesDialog(this, pElanInfo, g_aHelpIDs_IDD_ELAN_PROPERTIES);

    if (pElanInfo && pDlgProp)
    {
		//  see if user hit ADD
		if (pDlgProp->DoModal() == IDOK)
		{
			//  Push the Elan onto the the adapter's list
			m_pAdapterInfo->m_lstElans.push_back(pElanInfo);

			//  Mark it so miniport gets created if user hits OK/APPLY
			pElanInfo->m_fCreateMiniportOnPropertyApply = TRUE;
			pElanInfo = NULL;   // don't let cleanup delete it

			// refresh the ELAN list
			SendElanInfo();

			//  set the state of the buttons
			SetButtons();
		}
	}

	//  release objects as needed
    if (pElanInfo)
        delete pElanInfo;
    if (pDlgProp)
        delete pDlgProp;

    return 0;
}

LRESULT CALanePsh::OnEdit(WORD wNotifyCode, WORD wID,
                        HWND hWndCtl, BOOL& bHandled)
{
    CALaneCfgElanInfo * pElanInfo;
    int idx;

    m_fEditState = TRUE;

    //  get index of current ELAN selection
    idx = (int) ::SendMessage(m_hElanList, LB_GETCURSEL, 0, 0);
    Assert(idx >= 0);

    //  get the ElanInfo pointer from the current selection
    pElanInfo = (CALaneCfgElanInfo *)::SendMessage(m_hElanList,
                                            LB_GETITEMDATA, idx, 0L);

    //  create the dialog, passing in the ELAN info ptr
    CElanPropertiesDialog * pDlgProp = new CElanPropertiesDialog(this, pElanInfo,
                                                                 g_aHelpIDs_IDD_ELAN_PROPERTIES);

    if (pDlgProp->DoModal() == IDOK)
    {
        // refresh the ELAN list
        SendElanInfo();
    }

    delete pDlgProp;
    return 0;
}


LRESULT CALanePsh::OnRemove(WORD wNotifyCode, WORD wID,
                            HWND hWndCtl, BOOL& bHandled)
{
    CALaneCfgElanInfo * pElanInfo;
    int idx;

    //  get index of current ELAN selection
    idx = (int) ::SendMessage(m_hElanList, LB_GETCURSEL, 0, 0);
    Assert(idx >= 0);

    //  get the ElanInfo pointer from the current selection
    pElanInfo = (CALaneCfgElanInfo *)::SendMessage(m_hElanList,
                                                   LB_GETITEMDATA, idx, 0L);

    //  mark as deleted
    pElanInfo->m_fDeleted = TRUE;
    pElanInfo->m_fRemoveMiniportOnPropertyApply = TRUE;

    // RAID 31445: ATM:  AssertFail in \engine\remove.cpp line 180 
    //             when add & remove ELAN w/o committing changes.
    // mbend 20 May 2000
    //
    // Remove newly created adapters
    if (pElanInfo->m_fCreateMiniportOnPropertyApply)
    {
        ELAN_INFO_LIST::iterator iter = find(
            m_pAdapterInfo->m_lstElans.begin(), 
            m_pAdapterInfo->m_lstElans.end(),
            pElanInfo);

        Assert(m_pAdapterInfo->m_lstElans.end() != iter);
        m_pAdapterInfo->m_lstElans.erase(iter);

        delete pElanInfo;
    }

    // refresh the ELAN list
    SendElanInfo();

    //  set the state of the buttons
    SetButtons();

    return 0;
}

void CALanePsh::SendAdapterInfo()
{
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    CALaneCfgAdapterInfo *  pAdapterInfo;

    return;
}

void CALanePsh::SendElanInfo()
{
    ELAN_INFO_LIST::iterator    iterLstElans;
    CALaneCfgElanInfo *         pElanInfo = NULL;

    // pAdapterInfo = GetSelectedAdapter();
    Assert (NULL != m_pAdapterInfo);

    ::SendMessage(m_hElanList, LB_RESETCONTENT, 0, 0L);

    // loop thru the ELANs
    for (iterLstElans = m_pAdapterInfo->m_lstElans.begin();
            iterLstElans != m_pAdapterInfo->m_lstElans.end();
            iterLstElans++)
    {
        int idx;
        pElanInfo = *iterLstElans;

        // only add to list if not deleted

        if (!pElanInfo->m_fDeleted)
        {

            // set name to "unspecified" or actual specified name
            if (0 == lstrlen(pElanInfo->SzGetElanName()))
            {
                idx = ::SendMessage(m_hElanList, LB_ADDSTRING, 0,
                            (LPARAM)(SzLoadIds(IDS_ALANECFG_UNSPECIFIEDNAME)));
            }
            else
            {
                idx = ::SendMessage(m_hElanList, LB_ADDSTRING, 0,
                            (LPARAM)((PCWSTR)(pElanInfo->SzGetElanName())));
            }

            // store pointer to ElanInfo with text
            if (idx != LB_ERR)
                ::SendMessage(m_hElanList, LB_SETITEMDATA, idx,
                        (LPARAM)(pElanInfo));
        }
    }

    //  select the first one

    ::SendMessage(m_hElanList, LB_SETCURSEL, 0, (LPARAM)0);

    return;
}

CALaneCfgElanInfo *CALanePsh::GetSelectedElan()
{
    int         nCount;
    int         idx;
    DWORD_PTR   dw;
    CALaneCfgElanInfo *pElanInfo = NULL;

    nCount = (int) ::SendMessage(m_hElanList, LB_GETCOUNT, 0, 0);
    if (nCount > 0)
    {
        idx = (int) ::SendMessage(m_hElanList, LB_GETCURSEL, 0, 0);
        if (LB_ERR != idx)
        {
            dw = ::SendMessage(m_hElanList, LB_GETITEMDATA, idx, (LPARAM)0);
            if (dw && ((DWORD_PTR)LB_ERR != dw))
            {
                pElanInfo = (CALaneCfgElanInfo *)dw;
            }
        }
    }
    return pElanInfo;
}

void CALanePsh::SetButtons()
{
    int     nCount;

    //  get count of Elans in list
    nCount = (int) ::SendMessage(m_hElanList, LB_GETCOUNT, 0, 0);

    if (!nCount)
    {
        // remove the default on the remove button, if any
        ::SendMessage(m_hbtnRemove, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE );

        // move focus to Add button
        ::SetFocus(m_hbtnAdd);
    }

    //  enable/disable "Edit" and "Remove" buttons based existing Elans
    ::EnableWindow(m_hbtnEdit, !!nCount);
    ::EnableWindow(m_hbtnRemove, !!nCount);

    return;
}

//
//  CElanPropertiesDialog
//

CElanPropertiesDialog::CElanPropertiesDialog(CALanePsh * pCALanePsh,
                                             CALaneCfgElanInfo *pElanInfo,
                                             const DWORD * adwHelpIDs)
{
    m_pParentDlg = pCALanePsh;
    m_pElanInfo = pElanInfo;

    m_adwHelpIDs = adwHelpIDs;

    return;
}


LRESULT CElanPropertiesDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                            LPARAM lParam, BOOL& fHandled)
{
    // change the ok button to add if we are not editing
    if (m_pParentDlg->m_fEditState == FALSE)
        SetDlgItemText(IDOK, m_pParentDlg->m_strAddElan.c_str());

    // Set the position of the pop up dialog to be right over the listbox
    // on parent dialog

    HWND hList = ::GetDlgItem(m_pParentDlg->m_hWnd, IDC_ELAN_LIST);
    RECT rect;

    ::GetWindowRect(hList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
                                SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    // Save handle to the edit box
    m_hElanName = GetDlgItem(IDC_ELAN_NAME);

    // ELAN names have a 32 character limit
    ::SendMessage(m_hElanName, EM_SETLIMITTEXT, ELAN_NAME_LIMIT, 0);

    // fill in the edit box with the current elan's name
    ::SetWindowText(m_hElanName, m_pElanInfo->SzGetElanName());
    ::SendMessage(m_hElanName, EM_SETSEL, 0, -1);

    ::SetFocus(m_hElanName);

    return TRUE;
}

LRESULT CElanPropertiesDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                             LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CElanPropertiesDialog::OnHelp(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CElanPropertiesDialog::OnOk(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    WCHAR szElan[ELAN_NAME_LIMIT + 1];

    // Get the current name from the control and
    // store in the elan info
    ::GetWindowText(m_hElanName, szElan, ELAN_NAME_LIMIT + 1);

    m_pElanInfo->SetElanName(szElan);
    EndDialog(IDOK);

    return 0;
}

LRESULT CElanPropertiesDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                        HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atlkcfg\atlkhlp.h ===
// Copyright (c) 1999, Microsoft Corporation, all rights reserved.
//
// AppleTalk.h is used by atlkcfg.rc
// Help IDs file
//
// Created in Dev Studio
// 5-17-99 Carol Troup

#define IDH_CMB_GENERAL_ZONE	18000001 
#define IDH_CHK_GENERAL_DEFAULT	18000000

const DWORD g_aHelpIDs_DLG_ATLK_GENERAL[]=
{
        CHK_GENERAL_DEFAULT,IDH_CHK_GENERAL_DEFAULT,
        CMB_GENERAL_ZONE,IDH_CMB_GENERAL_ZONE,
        IDC_TXT_ZONELIST,IDH_CMB_GENERAL_ZONE,
        0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atlkcfg\atlkdlg.cpp ===
// ATlkDlg.cpp : Implementation of CATLKRoutingDlg and CATLKGeneralDlg

#include "pch.h"
#pragma hdrstop
#include "atlkobj.h"
#include "ncatlui.h"
#include "ncui.h"
#include "atlkhlp.h"

extern const WCHAR c_szDevice[];
extern const WCHAR c_szNetCfgHelpFile[];

const WCHAR c_chAmpersand = L'&';
const WCHAR c_chAsterisk  = L'*';
const WCHAR c_chColon     = L':';
const WCHAR c_chPeriod    = L'.';
const WCHAR c_chQuote     = L'\"';
const WCHAR c_chSpace     = L' ';

//
// Function:    PGetCurrentAdapterInfo
//
// Purpose:     Based on the currently selected item in the adapter combobox.
//              Extract and return the AdapterInfo *
//
// Parameters:  pATLKEnv [IN] - Enviroment block for this property page
//
// Returns:     CAdapterInfo *, Pointer to the adapter info if it exists,
//              NULL otherwise
//
static CAdapterInfo *PGetCurrentAdapterInfo(CATLKEnv * pATLKEnv)
{
    Assert(NULL != pATLKEnv);
    if (pATLKEnv->AdapterInfoList().empty())
    {
        return NULL;
    }
    else
    {
        return pATLKEnv->AdapterInfoList().front();
    }
}

//
// Function:    CATLKGeneralDlg::CATLKGeneralDlg
//
// Purpose:     ctor for the CATLKGeneralDlg class
//
// Parameters:  pmsc     - Ptr to the ATLK notification object
//              pATLKEnv - Ptr to the current ATLK configuration
//
// Returns:     nothing
//
CATLKGeneralDlg::CATLKGeneralDlg(CATlkObj *pmsc, CATLKEnv * pATLKEnv)
{
    m_pmsc              = pmsc;
    m_pATLKEnv          = pATLKEnv;
    Assert(NULL != m_pATLKEnv);
}

//
// Function:    CATLKGeneralDlg::~CATLKGeneralDlg
//
// Purpose:     dtor for the CATLKGeneralDlg class
//
// Parameters:  none
//
// Returns:     nothing
//
CATLKGeneralDlg::~CATLKGeneralDlg()
{
    // Don't free m_pmsc or m_pATLKEnv, they're borrowed only
}

//
// Function:    CATLKGeneralDlg::HandleChkBox
//
// Purpose:     Process the BN_PUSHBUTTON message for ATLK's General page
//
// Parameters:  Standard ATL params
//
// Returns:     LRESULT, 0L
//
LRESULT CATLKGeneralDlg::HandleChkBox(WORD wNotifyCode, WORD wID,
                                      HWND hWndCtl, BOOL& bHandled)
{
    if (BN_CLICKED == wNotifyCode)
    {
        UINT uIsCheckBoxChecked;

        uIsCheckBoxChecked = IsDlgButtonChecked(CHK_GENERAL_DEFAULT);

        ::EnableWindow(GetDlgItem(CMB_GENERAL_ZONE),
                     uIsCheckBoxChecked);
        ::EnableWindow(GetDlgItem(IDC_TXT_ZONELIST),
                     uIsCheckBoxChecked);
    }

    return 0;
}

//
// Function:    CATLKGeneralDlg::OnInitDialog
//
// Purpose:     Process the WM_INITDIALOG message for ATLK's General page
//
// Parameters:  Standard ATL params
//
// Returns:     LRESULT, 0L
//
LRESULT
CATLKGeneralDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                              LPARAM lParam, BOOL& bHandled)
{
    tstring        strDefPort;
    CAdapterInfo * pAI = PGetCurrentAdapterInfo(m_pATLKEnv);
    HWND           hwndChk = GetDlgItem(CHK_GENERAL_DEFAULT);
	HCURSOR        WaitCursor;

	WaitCursor = BeginWaitCursor();

    // If no adapters we're successfully added, disable everything
    if (NULL == pAI)
    {
        ::EnableWindow(hwndChk, FALSE);
        ::EnableWindow(GetDlgItem(CMB_GENERAL_ZONE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_TXT_ZONELIST), FALSE);
        ::EnableWindow(::GetDlgItem(::GetParent(m_hWnd), IDOK), FALSE);
		EndWaitCursor(WaitCursor);	
        return 0L;
    }

    // Retain what we currently consider the "Default" adapter
    strDefPort = c_szDevice;
    strDefPort += pAI->SzBindName();
    if (0 == _wcsicmp(strDefPort.c_str(), m_pATLKEnv->SzDefaultPort()))
    {
        ::CheckDlgButton(m_hWnd, CHK_GENERAL_DEFAULT, 1);
        ::EnableWindow(hwndChk, FALSE);
    }
    else
    {
        // Disable the zone combo if the current adapter is not the
        // default adapter.
        ::EnableWindow(GetDlgItem(CMB_GENERAL_ZONE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_TXT_ZONELIST), FALSE);
    }

    // danielwe: RAID #347398: Hide the checkbox completely if this is a
    // LocalTalk adapter.
    //
    if (pAI->DwMediaType() == MEDIATYPE_LOCALTALK)
    {
        ::ShowWindow(GetDlgItem(CHK_GENERAL_DEFAULT), SW_HIDE);
    }

    // Populate the Zone dialog
    RefreshZoneCombo();

    SetChangedFlag();

	EndWaitCursor(WaitCursor);
    return 1L;
}

//
// Function:    CATLKGeneralDlg::RefreshZoneCombo()
//
// Purpose:     Populate the Zone combo box with the supplied list of zones
//
// Parameters:  pAI - Adapter info
//
// Returns:     none
//
VOID CATLKGeneralDlg::RefreshZoneCombo()
{
    HWND           hwndComboZones = GetDlgItem(CMB_GENERAL_ZONE);
    INT            nIdx;
    CAdapterInfo * pAI = PGetCurrentAdapterInfo(m_pATLKEnv);

    if (NULL == pAI)
        return;         // No adapter selected, available

    ::SendMessage(hwndComboZones, CB_RESETCONTENT, 0, 0L);

    // Populate the Zone dialog
    if (!pAI->FSeedingNetwork() || !m_pATLKEnv->FRoutingEnabled())
    {
        // this port is not seeding the network
        // if we found a router on this port then add the found zone
        // list to the desired zone box. Else do nothing.
        if(pAI->FRouterOnNetwork())
        {
            if (pAI->LstpstrDesiredZoneList().empty())
                return;

            if (FALSE == FAddZoneListToControl(&pAI->LstpstrDesiredZoneList()))
                return;

            nIdx = ::SendMessage(hwndComboZones, CB_FINDSTRINGEXACT, -1,
                                 (LPARAM)m_pATLKEnv->SzDesiredZone());
            ::SendMessage(hwndComboZones, CB_SETCURSEL,
                          ((CB_ERR == nIdx) ? 0 : nIdx), 0L);
        }
    }
    else
    {
        // This port is seeding the network, populate the zone list with the
        // zones managed by this port.
        if (pAI->LstpstrZoneList().empty())
            return;

        if (FALSE == FAddZoneListToControl(&pAI->LstpstrZoneList()))
            return;

        nIdx = ::SendMessage(hwndComboZones, CB_FINDSTRINGEXACT,
                             -1, (LPARAM)m_pATLKEnv->SzDesiredZone());
        if (CB_ERR == nIdx)
            nIdx = ::SendMessage(hwndComboZones, CB_FINDSTRINGEXACT,
                                 -1, (LPARAM)pAI->SzDefaultZone());

        ::SendMessage(hwndComboZones, CB_SETCURSEL,
                      ((CB_ERR == nIdx) ? 0 : nIdx), 0L);
    }
}

//
// Function:    CATLKGeneralDlg::FAddZoneListToControl
//
// Purpose:     Populate the Zone combo box with the supplied list of zones
//
// Parameters:  plstpstr - Pointer to a list of pointers to tstrings
//
// Returns:     BOOL, TRUE if at least one zone was added to the combo box
//
BOOL CATLKGeneralDlg::FAddZoneListToControl(list<tstring*> * plstpstr)
{
    HWND hwndComboZones = GetDlgItem(CMB_GENERAL_ZONE);
    list<tstring*>::iterator iter;
    tstring * pstr;

    Assert(NULL != plstpstr);
    for (iter = plstpstr->begin();
         iter != plstpstr->end();
         iter++)
    {
        pstr = *iter;
        ::SendMessage(hwndComboZones, CB_ADDSTRING, 0, (LPARAM)pstr->c_str());
    }

    return (0 != ::SendMessage(hwndComboZones, CB_GETCOUNT, 0, 0L));
}

//
// Function:    CATLKGeneralDlg::OnOk
//
// Purpose:     Process the PSN_APPLY notification for the property page
//
// Parameters:  Standard ATL params
//
// Returns:     LRESULT, 0L
//
LRESULT
CATLKGeneralDlg::OnOk(INT idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    INT            nIdx;
    CAdapterInfo * pAI = PGetCurrentAdapterInfo(m_pATLKEnv);
    HWND           hwndComboZones = GetDlgItem(CMB_GENERAL_ZONE);

    if (NULL == pAI)
    {
        return 0;
    }

    if (IsDlgButtonChecked(CHK_GENERAL_DEFAULT))
    {
        tstring        strPortName;

        // Retain adapter selection as the default port
        //
        strPortName = c_szDevice;
        strPortName += pAI->SzBindName();
        if (wcscmp(strPortName.c_str(), m_pATLKEnv->SzDefaultPort()))
        {
            m_pATLKEnv->SetDefaultPort(strPortName.c_str());
            m_pATLKEnv->SetDefAdapterChanged(TRUE);

            // Tell the user what checking the box means...
            //
            tstring str;
            str = SzLoadIds(IDS_ATLK_INBOUND_MSG1);
            str += SzLoadIds(IDS_ATLK_INBOUND_MSG2);
            ::MessageBox(m_hWnd, str.c_str(),
                         SzLoadIds(IDS_CAPTION_NETCFG), MB_OK);
        }
    }
    else
    {
        // If the check box is not checked then the zone combo is
        // disabled and its contents don't need to be retained.
        return 0;
    }

    // Retain the zone selection as the default zone
    nIdx = ::SendMessage(hwndComboZones, CB_GETCURSEL, 0, 0L);
    if (CB_ERR != nIdx)
    {
        WCHAR szBuf[MAX_ZONE_NAME_LEN + 1];
        if (CB_ERR != ::SendMessage(hwndComboZones, CB_GETLBTEXT, nIdx,
                                    (LPARAM)(PCWSTR)szBuf))
        {
            // If the new zone is different then the original, then
            // mark the adapter as dirty
            
            if (0 != _wcsicmp(szBuf, m_pATLKEnv->SzDesiredZone()))
            {
                // If the earlier desired zone was NOT NULL, only then
                // mark adapter dirty to request a PnP to the stack
                if (0 != _wcsicmp(c_szEmpty, m_pATLKEnv->SzDesiredZone()))
                {
                    pAI->SetDirty(TRUE);
                }
            }
            m_pATLKEnv->SetDesiredZone(szBuf);
        }
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Method: CATLKGeneralDlg::OnContextMenu
//
//  Desc:   Bring up context-sensitive help
//
//  Args:   Standard command parameters
//
//  Return: LRESULT
//
LRESULT
CATLKGeneralDlg::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (g_aHelpIDs_DLG_ATLK_GENERAL != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)g_aHelpIDs_DLG_ATLK_GENERAL);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Method: CATLKGeneralDlg::OnHelp
//
//  Desc:   Bring up context-sensitive help when dragging ? icon over a control
//
//  Args:   Standard command parameters
//
//  Return: LRESULT
//
//
LRESULT
CATLKGeneralDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((g_aHelpIDs_DLG_ATLK_GENERAL != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)g_aHelpIDs_DLG_ATLK_GENERAL);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atlkcfg\resource.h ===
#include <ncres.h>

// Dialog IDs
#define DLG_ATLK_GENERAL            2500   // == IDS_NS_ATLKCFG
#define DLG_ATLK_ROUTING            2501
#define DLG_ATLK_ADD_ZONE           2502

// String IDs
#define IDS_ATLK_CAPTION                (IDS_NC_ATLKCFG + 1)
#define IDS_ATLK_INSTALL_PENDING        (IDS_NC_ATLKCFG + 2)
#define IDS_ATLK_INBOUND_MSG1           (IDS_NC_ATLKCFG + 3)
#define IDS_ATLK_INBOUND_MSG2           (IDS_NC_ATLKCFG + 4)

// Control IDs
#define CMB_GENERAL_ZONE            100
#define CHK_GENERAL_DEFAULT         101
#define IDC_TXT_ZONELIST            102
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\arpsdlg.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A R P S D L G . C P P
//
//  Contents:   CArpsPage declaration
//
//  Notes:
//
//  Author:     tongl   2 Feb 1998
//
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "arpsobj.h"
#include "arpsdlg.h"
#include "ncatlui.h"
#include "ncstl.h"
//#include "ncui.h"
//#include "resource.h"
#include "atmcommon.h"

#include "atmhelp.h"

//
// CArpsPage
//

CArpsPage::CArpsPage(CArpsCfg * pArpscfg, const DWORD * adwHelpIDs)
{
    Assert(pArpscfg);
    m_pArpscfg = pArpscfg;
    m_adwHelpIDs = adwHelpIDs;

    m_pAdapterInfo = pArpscfg->GetSecondMemoryAdapterInfo();

    m_fEditState = FALSE;
    m_fModified = FALSE;
}

CArpsPage::~CArpsPage()
{
}

LRESULT CArpsPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                LPARAM lParam, BOOL& fHandled)
{
    RECT rect;
    LV_COLUMN lvCol = {0};    // list view column structure

    // initialize registered atm address list view
    ::GetClientRect(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), &rect);
    lvCol.mask = LVCF_FMT | LVCF_WIDTH;
    lvCol.fmt = LVCFMT_LEFT;
    lvCol.cx = rect.right;

    ListView_InsertColumn(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), 0, &lvCol);

    // initialize report view of multicast address list view
    int index, iNewItem;

    // Calculate column width
    ::GetClientRect(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), &rect);
    int colWidth = (rect.right/c_nColumns);

    // The mask specifies that the fmt, width and pszText members
    // of the structure are valid
    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT ;
    lvCol.fmt = LVCFMT_LEFT;   // left-align column
    lvCol.cx = colWidth;       // width of column in pixels

    // Add the two columns and header text.
    for (index = 0; index < c_nColumns; index++)
    {
        // column header text
        if (0 == index) // first column
        {
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_IPADDRESS_FROM);
        }
        else
        {
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_IPADDRESS_TO);
        }

        iNewItem = ListView_InsertColumn(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR),
                                         index, &lvCol);

        AssertSz((iNewItem == index), "Invalid item inserted to list view !");
    }

    m_hRegAddrs.m_hListView = GetDlgItem(IDC_LVW_ARPS_REG_ADDR);
    m_hRegAddrs.m_hAdd      = GetDlgItem(IDC_PSH_ARPS_REG_ADD);
    m_hRegAddrs.m_hEdit     = GetDlgItem(IDC_PSH_ARPS_REG_EDT);
    m_hRegAddrs.m_hRemove   = GetDlgItem(IDC_PSH_ARPS_REG_RMV);

    m_hMulAddrs.m_hListView = GetDlgItem(IDC_LVW_ARPS_MUL_ADDR);
    m_hMulAddrs.m_hAdd      = GetDlgItem(IDC_PSH_ARPS_MUL_ADD);
    m_hMulAddrs.m_hEdit     = GetDlgItem(IDC_PSH_ARPS_MUL_EDT);
    m_hMulAddrs.m_hRemove   = GetDlgItem(IDC_PSH_ARPS_MUL_RMV);

    // do this last
    SetRegisteredAtmAddrInfo();
    SetMulticastIpAddrInfo();

    return 0;
}

LRESULT CArpsPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CArpsPage::OnHelp(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CArpsPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CArpsPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL err = FALSE;

    // Update the in memory with what's in the UI
    UpdateInfo();

    // Check duplicate ATM address
    int iDupRegAddr = CheckDupRegAddr();

    if (iDupRegAddr >=0)
    {
        NcMsgBox(m_hWnd, IDS_MSFT_ARPS_TEXT, IDS_DUPLICATE_REG_ADDR,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        ListView_SetItemState(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), iDupRegAddr,
                              LVIS_SELECTED, LVIS_SELECTED);
        err = TRUE;
    }

    // Check overlapped IP address range
    if (!err)
    {
        int iOverlappedIpRange = CheckOverlappedIpRange();
        if (iOverlappedIpRange >=0)
        {
            NcMsgBox(m_hWnd, IDS_MSFT_ARPS_TEXT, IDS_OVERLAP_MUL_ADDR,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            ListView_SetItemState(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), iOverlappedIpRange,
                                  LVIS_SELECTED, LVIS_SELECTED);

            err = TRUE;
        }
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, err);
    return err;
}

LRESULT CArpsPage::OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);
    Assert(pnmlv);

    // Reset the buttons based on the changed selection
    if (idCtrl == IDC_LVW_ARPS_REG_ADDR)
    {
        SetButtons(m_hRegAddrs);
    }
    else if (idCtrl == IDC_LVW_ARPS_MUL_ADDR)
    {
        SetButtons(m_hMulAddrs);
    }

    return 0;
}

int CArpsPage::CheckDupRegAddr()
{
    int ret = -1;
    int idx = 0;

    for(VECSTR::iterator iterAtmAddr = m_pAdapterInfo->m_vstrRegisteredAtmAddrs.begin();
        iterAtmAddr != m_pAdapterInfo->m_vstrRegisteredAtmAddrs.end();
        iterAtmAddr ++)
    {
        VECSTR::iterator iterAtmAddrComp = iterAtmAddr;

        iterAtmAddrComp ++;
        while (iterAtmAddrComp != m_pAdapterInfo->m_vstrRegisteredAtmAddrs.end())
        {
            if (**iterAtmAddr == **iterAtmAddrComp)
            {
                // we find a duplicate address
                ret = idx;
                break;
            }

            iterAtmAddrComp++;
        }

        // duplicate address found
        if (ret >=0 )
        {
            break;
        }

        // move next
        idx ++;
    }

    return ret;
}

int CArpsPage::CheckOverlappedIpRange()
{
    int ret = -1;
    int idx = 0;

    for(VECSTR::iterator iterIpRange = m_pAdapterInfo->m_vstrMulticastIpAddrs.begin();
        iterIpRange != m_pAdapterInfo->m_vstrMulticastIpAddrs.end();
        iterIpRange ++)
    {
        tstring strUpperIp;
        GetUpperIp( **iterIpRange, &strUpperIp);

        VECSTR::iterator iterIpRangeComp = iterIpRange;

        iterIpRangeComp ++;
        while (iterIpRangeComp != m_pAdapterInfo->m_vstrMulticastIpAddrs.end())
        {
            tstring strLowerIpComp;
            GetLowerIp( **iterIpRangeComp, &strLowerIpComp);

            if (strUpperIp >= strLowerIpComp)
            {
                // we find an overlapped range
                ret = idx;
                break;
            }

            iterIpRangeComp++;
        }

        // duplicate address found
        if (ret >=0 )
        {
            break;
        }

        // move next
        idx ++;
    }
    return ret;
}

LRESULT CArpsPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    if (!IsModified())
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
        return nResult;
    }

    m_pArpscfg->SetSecondMemoryModified();

    SetModifiedTo(FALSE);   // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}

LRESULT CArpsPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CArpsPage::OnAddRegisteredAddr(WORD wNotifyCode, WORD wID,
                                       HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = FALSE;

    CAtmAddrDlg * pDlgAddr = new CAtmAddrDlg(this, g_aHelpIDs_IDD_ARPS_REG_ADDR);

	if (pDlgAddr == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    pDlgAddr->m_strNewAtmAddr = m_strRemovedAtmAddr;

    // See if the address is added
    if (pDlgAddr->DoModal() == IDOK)
    {
        int nCount = ListView_GetItemCount(GetDlgItem(IDC_LVW_ARPS_REG_ADDR));

        // insert the new item at the end of list
        LV_ITEM lvItem;

        lvItem.mask = LVIF_TEXT;
        lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
        lvItem.state = 0;

        lvItem.iItem=nCount;
        lvItem.iSubItem=0;
        lvItem.pszText= (PWSTR)(m_strRemovedAtmAddr.c_str());

        int ret = ListView_InsertItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), &lvItem);

        // empty strings, this removes the saved address from RemoveAtmAddr
        m_strRemovedAtmAddr = c_szEmpty;

        SetButtons(m_hRegAddrs);
        PageModified();
    }

    delete pDlgAddr;
    return 0;
}

LRESULT CArpsPage::OnEditRegisteredAddr(WORD wNotifyCode, WORD wID,
                                        HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = TRUE;

    CAtmAddrDlg * pDlgAddr = new CAtmAddrDlg(this, g_aHelpIDs_IDD_ARPS_REG_ADDR);

	if (pDlgAddr == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    // get the user selection
    int itemSelected = ListView_GetNextItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR),
                                            -1, LVNI_SELECTED);
    if (itemSelected != -1)
    {
        WCHAR buf[MAX_ATM_ADDRESS_LENGTH+1];

        // save off the removed address
        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT;

        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 0;
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), &lvItem);

        pDlgAddr->m_strNewAtmAddr = buf;

        // See if the address is edited & address changed
        if ((pDlgAddr->DoModal() == IDOK) && (m_strRemovedAtmAddr != buf))
        {
            // delete the old address
            ListView_DeleteItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), itemSelected);

            // replace the item with the new address
            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.lParam =0;
            lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
            lvItem.state = 0;

            lvItem.iItem=itemSelected;
            lvItem.iSubItem=0;
            lvItem.pszText= (PWSTR)(m_strRemovedAtmAddr.c_str());

            ListView_InsertItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), &lvItem);

            PageModified();
        }
    }
    else // no current selection
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_ARPS_TEXT, IDS_NO_ITEM_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }

    // don't save this registered address
    m_strRemovedAtmAddr = c_szEmpty;

    delete pDlgAddr;
    return 0;
}

LRESULT CArpsPage::OnRemoveRegisteredAddr(WORD wNotifyCode, WORD wID,
                                          HWND hWndCtl, BOOL& fHandled)
{
    // get the current selected item and remove it
    int itemSelected = ListView_GetNextItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), -1,
                                            LVNI_SELECTED);

    if (itemSelected != -1)
    {
        WCHAR buf[MAX_ATM_ADDRESS_LENGTH+1];

        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);

        // save off the removed address and delete it from the listview
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 0;
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), &lvItem);

        m_strRemovedAtmAddr = buf;
        ListView_DeleteItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), itemSelected);

        SetButtons(m_hRegAddrs);

        PageModified();
    }
    else
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_ARPS_TEXT,
                 IDS_NO_ITEM_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }

    return 0;
}

LRESULT CArpsPage::OnAddMulticastAddr(WORD wNotifyCode, WORD wID,
                                      HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = FALSE;

    CIpAddrRangeDlg * pDlgAddr = new CIpAddrRangeDlg(this, g_aHelpIDs_IDD_ARPS_MUL_ADDR);

	if (pDlgAddr == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    pDlgAddr->m_strNewIpRange = m_strRemovedIpRange;

    // See if the address is added
    if (pDlgAddr->DoModal() == IDOK)
    {
        LvInsertIpRangeInOrder(pDlgAddr->m_strNewIpRange);

        // empty strings, this removes the saved address from RemoveIP
        pDlgAddr->m_strNewIpRange = c_szEmpty;

        SetButtons(m_hMulAddrs);
        PageModified();
    }
    m_strRemovedIpRange = pDlgAddr->m_strNewIpRange;

    delete pDlgAddr;
    return 0;
}

LRESULT CArpsPage::OnEditMulticastAddr(WORD wNotifyCode, WORD wID,
                                       HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = TRUE;

    CIpAddrRangeDlg * pDlgAddr = new CIpAddrRangeDlg(this, g_aHelpIDs_IDD_ARPS_MUL_ADDR);

	if (pDlgAddr == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    // get the user selection
    int itemSelected = ListView_GetNextItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR),
                                            -1, LVNI_SELECTED);
    if (itemSelected != -1)
    {
        WCHAR szBuf[IPRANGE_LIMIT];

        // save off the removed address and delete it from the listview
        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT;

        // lower ip
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 0;
        lvItem.pszText = szBuf;
        lvItem.cchTextMax = celems(szBuf);
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), &lvItem);

        pDlgAddr->m_strNewIpRange = szBuf;
        pDlgAddr->m_strNewIpRange += c_chSeparator;

        // upper ip
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 1;
        lvItem.pszText = szBuf;
        lvItem.cchTextMax = celems(szBuf);
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), &lvItem);

        pDlgAddr->m_strNewIpRange += szBuf;

        // See if the address is edited & address changed
        if ((pDlgAddr->DoModal() == IDOK) && (pDlgAddr->m_strNewIpRange != szBuf))
        {
            // delete the old address
            ListView_DeleteItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), itemSelected);

            // insert new one
            LvInsertIpRangeInOrder(pDlgAddr->m_strNewIpRange);

            // empty strings, this removes the saved address from RemoveIP
            pDlgAddr->m_strNewIpRange = c_szEmpty;

            PageModified();
        }
    }
    else // no current selection
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_ARPS_TEXT,
                 IDS_NO_ITEM_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }

    // don't save this IP range
    m_strRemovedIpRange = c_szEmpty;

    delete pDlgAddr;
    return 0;
}

void CArpsPage::LvInsertIpRangeInOrder(tstring& strNewIpRange)
{
    tstring strLowerIp;
    GetLowerIp(strNewIpRange, &strLowerIp);

    int nCount = ListView_GetItemCount(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR));

    // find the index to insert the new item
    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT;

    WCHAR buf[IPRANGE_LIMIT];
    lvItem.pszText = buf;
    lvItem.cchTextMax = celems(buf);

    for (int iItem =0; iItem <nCount; iItem++)
    {
        lvItem.iItem = iItem;
        lvItem.iSubItem = 0;
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), &lvItem);

        Assert(buf);

        if (strLowerIp < buf)
        {
            break;
        }
    }

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam =0;
    lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
    lvItem.state = 0;

    // lower IP address
    lvItem.iItem=iItem;
    lvItem.iSubItem=0;
    lvItem.pszText= (PWSTR)(strLowerIp.c_str());
    SendDlgItemMessage(IDC_LVW_ARPS_MUL_ADDR, LVM_INSERTITEM, 0, (LPARAM)&lvItem);

    // upper IP address
    tstring strUpperIp;
    GetUpperIp(strNewIpRange, &strUpperIp);

    lvItem.iItem=iItem;
    lvItem.iSubItem=1;
    lvItem.pszText= (PWSTR)(strUpperIp.c_str());
    SendDlgItemMessage(IDC_LVW_ARPS_MUL_ADDR, LVM_SETITEMTEXT, iItem, (LPARAM)&lvItem);
}

LRESULT CArpsPage::OnRemoveMulticastAddr(WORD wNotifyCode, WORD wID,
                                         HWND hWndCtl, BOOL& fHandled)
{
    // get the current selected item and remove it
    int itemSelected = ListView_GetNextItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), -1,
                                            LVNI_SELECTED);

    if (itemSelected != -1)
    {
        WCHAR szBuf[IPRANGE_LIMIT];

        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = szBuf;
        lvItem.cchTextMax = celems(szBuf);

        // save off the removed address
        // lower ip
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 0;
        lvItem.cchTextMax = celems(szBuf);
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), &lvItem);

        m_strRemovedIpRange = szBuf;
        m_strRemovedIpRange += c_chSeparator;

        // upper ip
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 1;
        lvItem.pszText = szBuf;
        lvItem.cchTextMax = celems(szBuf);
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), &lvItem);

        m_strRemovedIpRange += szBuf;

        // delete it from the list view
        ListView_DeleteItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), itemSelected);

        SetButtons(m_hMulAddrs);

        PageModified();
    }
    else
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_ARPS_TEXT,
                 IDS_NO_ITEM_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }

    return 0;
}

void CArpsPage::SetRegisteredAtmAddrInfo()
{
    BOOL ret = ListView_DeleteAllItems(GetDlgItem(IDC_LVW_ARPS_REG_ADDR));
    Assert(ret);

    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam =0;
    lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
    lvItem.state = 0;

    int iItem =0;

    for (VECSTR::iterator iterAtmAddr = m_pAdapterInfo->m_vstrRegisteredAtmAddrs.begin();
         iterAtmAddr != m_pAdapterInfo->m_vstrRegisteredAtmAddrs.end();
         iterAtmAddr ++)
    {
        if ((**iterAtmAddr) == c_szEmpty)
        {
            continue;
        }

        lvItem.iItem=iItem;
        lvItem.iSubItem=0;
        lvItem.pszText=(PWSTR)((*iterAtmAddr)->c_str());
        lvItem.cchTextMax = celems((*iterAtmAddr)->c_str());

        int ret = ListView_InsertItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), &lvItem);

        iItem++;
    }

    // now set the button states
    SetButtons(m_hRegAddrs);
}

void CArpsPage::SetMulticastIpAddrInfo()
{
    BOOL ret = ListView_DeleteAllItems(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR));
    Assert(ret);

    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam =0;
    lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
    lvItem.state = 0;

    int iItem =0;
    tstring strIpLower;
    tstring strIpUpper;

    for (VECSTR::iterator iterIpAddrRange = m_pAdapterInfo->m_vstrMulticastIpAddrs.begin();
         iterIpAddrRange != m_pAdapterInfo->m_vstrMulticastIpAddrs.end();
         iterIpAddrRange ++)
    {
        if ((**iterIpAddrRange) == c_szEmpty)
        {
            continue;
        }

        GetLowerIp((**iterIpAddrRange), &strIpLower);
        GetUpperIp((**iterIpAddrRange), &strIpUpper);

        // Add the lower IP address
        lvItem.iItem=iItem;
        lvItem.iSubItem=0;
        lvItem.pszText=(PWSTR)(strIpLower.c_str());

        SendDlgItemMessage(IDC_LVW_ARPS_MUL_ADDR, LVM_INSERTITEM, iItem, (LPARAM)&lvItem);

        // Add the upper IP address
        lvItem.iItem=iItem;
        lvItem.iSubItem=1;
        lvItem.pszText=(PWSTR)(strIpUpper.c_str());

        // sub-item can not be inserted by ListView_InsertItem
        SendDlgItemMessage(IDC_LVW_ARPS_MUL_ADDR, LVM_SETITEMTEXT, iItem, (LPARAM)&lvItem);

        iItem++;
    }
    SetButtons(m_hMulAddrs);
}

void CArpsPage::SetButtons(HandleGroup& handles)
{
    INT iSelected = ListView_GetNextItem(handles.m_hListView, -1, LVNI_SELECTED);
    if (iSelected == -1) // Nothing selected or list empty
    {
        ::EnableWindow(handles.m_hEdit,   FALSE);
        ::EnableWindow(handles.m_hRemove, FALSE);

        ::SetFocus(handles.m_hListView);
    }
    else
    {
        ::EnableWindow(handles.m_hEdit,   TRUE);
        ::EnableWindow(handles.m_hRemove, TRUE);
    }
}

void CArpsPage::UpdateInfo()
{
    int i;

    // Update Registered ATM address
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrRegisteredAtmAddrs);

    int nCount = ListView_GetItemCount(GetDlgItem(IDC_LVW_ARPS_REG_ADDR));
    WCHAR szAtmAddr[MAX_ATM_ADDRESS_LENGTH+1];

    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT;

    for (i=0; i< nCount; i++)
    {
        lvItem.iItem = i;
        lvItem.iSubItem = 0;
        lvItem.pszText = szAtmAddr;
        lvItem.cchTextMax = celems(szAtmAddr);

        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), &lvItem);

        m_pAdapterInfo->m_vstrRegisteredAtmAddrs.push_back(new tstring(szAtmAddr));
    }

    // Update Multicast IP address
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrMulticastIpAddrs);

    nCount = ListView_GetItemCount(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR));
    WCHAR szBuf[IPRANGE_LIMIT];
    tstring strIpRange;

    for (i=0; i< nCount; i++)
    {
        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT;

        // lower ip
        lvItem.iItem = i;
        lvItem.iSubItem = 0;
        lvItem.pszText = szBuf;
        lvItem.cchTextMax = celems(szBuf);
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), &lvItem);

        strIpRange = szBuf;
        strIpRange += c_chSeparator;

        // upper ip
        lvItem.iItem = i;
        lvItem.iSubItem = 1;
        lvItem.pszText = szBuf;
        lvItem.cchTextMax = celems(szBuf);
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), &lvItem);

        strIpRange += szBuf;

        m_pAdapterInfo->m_vstrMulticastIpAddrs.push_back(new tstring(strIpRange.c_str()));
    }
}

//
// CAtmAddrDlg
//

CAtmAddrDlg::CAtmAddrDlg(CArpsPage * pAtmArpsPage, const DWORD* adwHelpIDs)
{
    m_pParentDlg = pAtmArpsPage;
    m_adwHelpIDs = adwHelpIDs;

    m_hOkButton = 0;
}

LRESULT CAtmAddrDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    // change the "Ok" button to "Add" if we are not editing
    if (FALSE == m_pParentDlg->m_fEditState)
    {
        SetDlgItemText(IDOK, L"Add");
    }

    // Set the position of the pop up dialog to be right over the listbox
    // on parent dialog
    RECT rect;

    HWND hwndList = m_pParentDlg->m_hRegAddrs.m_hListView;
    Assert(hwndList);
    ::GetWindowRect(hwndList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
                                SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    // Save handles to the "Ok" button and the edit box
    m_hOkButton =  GetDlgItem(IDOK);
    m_hEditBox  =  GetDlgItem(IDC_EDT_ARPS_REG_Address);

    // ATM addresses have a 40 character limit + separaters
    ::SendMessage(m_hEditBox, EM_SETLIMITTEXT,
        MAX_ATM_ADDRESS_LENGTH + (MAX_ATM_ADDRESS_LENGTH / 2), 0);

    // add the address that was just removed
    if (m_strNewAtmAddr.size())
    {
        ::SetWindowText(m_hEditBox, m_strNewAtmAddr.c_str());
        ::SendMessage(m_hEditBox, EM_SETSEL, 0, -1);
        ::EnableWindow(m_hOkButton, TRUE);
    }
    else
    {
        ::EnableWindow(m_hOkButton, FALSE);
    }

    ::SetFocus(m_hEditBox);
    return 0;
}

LRESULT CAtmAddrDlg::OnContextMenu(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CAtmAddrDlg::OnHelp(UINT uMsg, WPARAM wParam,
                            LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CAtmAddrDlg::OnOk(WORD wNotifyCode, WORD wID,
                          HWND hWndCtl, BOOL& fHandled)
{
    WCHAR szAtmAddress[MAX_ATM_ADDRESS_LENGTH+1];

    // Get the current address from the control and
    // add them to the adapter if valid
    ::GetWindowText(m_hEditBox, szAtmAddress, MAX_ATM_ADDRESS_LENGTH+1);

    int i, nId;

    if (! FIsValidAtmAddress(szAtmAddress, &i, &nId))
    {   // If invalid ATM address, we pop up a message box and set focus
        // back to the edit box

        // REVIEW(tongl): report first invalid character in mesg box
        NcMsgBox(m_hWnd, IDS_MSFT_ARPS_TEXT, IDS_INVALID_ATM_ADDRESS,
                                MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        ::SetFocus(GetDlgItem(IDC_EDT_ARPS_REG_Address));
        return 0;
    }

    if (m_pParentDlg->m_fEditState == FALSE) // Add new address
    {
        m_pParentDlg->m_strRemovedAtmAddr = szAtmAddress;
    }
    else // if edit, see if string is having a diferent value now
    {
        if (m_pParentDlg->m_strRemovedAtmAddr != szAtmAddress)
        {
            m_pParentDlg->m_strRemovedAtmAddr = szAtmAddress; // update save addresses
        }
        else
        {
            EndDialog(IDCANCEL);
        }
    }

    EndDialog(IDOK);
    return 0;
}

LRESULT CAtmAddrDlg::OnCancel(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

LRESULT CAtmAddrDlg::OnChange(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& fHandled)
{
    WCHAR buf[2];

    // Enable or disable the "Ok" button
    // based on whether the edit box is empty

    if (::GetWindowText(m_hEditBox, buf, celems(buf)) == 0)
    {
        ::EnableWindow(m_hOkButton, FALSE);
    }
    else
    {
        ::EnableWindow(m_hOkButton, TRUE);
    }

    return 0;
}

//
//  CIpAddrRangeDlg
//
CIpAddrRangeDlg::CIpAddrRangeDlg( CArpsPage * pAtmArpsPage, const DWORD* adwHelpIDs)
{
    m_pParentDlg = pAtmArpsPage;
    m_hOkButton = 0;

    m_adwHelpIDs = adwHelpIDs;
}

LRESULT CIpAddrRangeDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& fHandled)
{
    // change the ok button to add if we are not editing
    if (FALSE == m_pParentDlg->m_fEditState)
    {
        SetDlgItemText(IDOK, L"Add");
    }

    // Set the position of the pop up dialog to be right over the listbox
    // on parent dialog
    RECT rect;

    HWND hwndList = m_pParentDlg->m_hMulAddrs.m_hListView;
    Assert(hwndList);
    ::GetWindowRect(hwndList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
                                SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    // Save handles to the "Ok" button and the edit box
    m_hOkButton =  GetDlgItem(IDOK);

    // create ip controls
    m_ipLower.Create(m_hWnd,IDC_ARPS_MUL_LOWER_IP);
    m_ipUpper.Create(m_hWnd,IDC_ARPS_MUL_UPPER_IP);

    // add the address that was just removed
    if (m_strNewIpRange.size())
    {
        GetLowerIp(m_strNewIpRange, &m_strNewIpLower);
        GetUpperIp(m_strNewIpRange, &m_strNewIpUpper);

        Assert(m_strNewIpLower.size()>0);
        Assert(m_strNewIpUpper.size()>0);

        m_ipLower.SetAddress(m_strNewIpLower.c_str());
        m_ipUpper.SetAddress(m_strNewIpUpper.c_str());

        ::EnableWindow(m_hOkButton, TRUE);
    }
    else
    {
        m_strNewIpLower = c_szEmpty;
        m_strNewIpUpper = c_szEmpty;

        // the ip and subnet are blank, so there's nothing to save
        ::EnableWindow(m_hOkButton, FALSE);
    }

    return 0;
}

LRESULT CIpAddrRangeDlg::OnContextMenu(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CIpAddrRangeDlg::OnHelp(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CIpAddrRangeDlg::OnOk(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& fHandled)
{
    tstring strIpLower;
    tstring strIpUpper;

    // Get the current address from the control and add them to the adapter if valid
    m_ipLower.GetAddress(&strIpLower);
    m_ipUpper.GetAddress(&strIpUpper);

    if (!IsValidIpRange(strIpLower, strIpUpper))
    {
        NcMsgBox(::GetActiveWindow(),
                 IDS_MSFT_ARPS_TEXT,
                 IDS_INCORRECT_IPRANGE,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        ::SetFocus(m_ipLower);
        return 0;
    }

    if (m_pParentDlg->m_fEditState == FALSE) // when adding a new range
    {
        // Get the current address from the control and add them to the adapter if valid
        MakeIpRange(strIpLower, strIpUpper, &m_strNewIpRange);
        EndDialog(IDOK);
    }
    else // if editing an existing range
    {
        if ((strIpLower != m_strNewIpLower)||(strIpUpper != m_strNewIpUpper))
        {
            MakeIpRange(strIpLower, strIpUpper, &m_strNewIpRange);
            EndDialog(IDOK);
        }
        else
        {
            // no change
            EndDialog(IDCANCEL);
        }
    }

    EndDialog(IDOK);
    return 0;
}

LRESULT CIpAddrRangeDlg::OnCancel(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

LRESULT CIpAddrRangeDlg::OnChangeLowerIp(WORD wNotifyCode, WORD wID,
                                         HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case EN_CHANGE:
        if (m_ipLower.IsBlank() || m_ipUpper.IsBlank())
        {
            ::EnableWindow(m_hOkButton, FALSE);
        }
        else
        {
            ::EnableWindow(m_hOkButton, TRUE);
        }

        break;

    default:
        break;
    }

    return 0;
}

LRESULT CIpAddrRangeDlg::OnChangeUpperIp(WORD wNotifyCode, WORD wID,
                                         HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case EN_CHANGE:
        if (m_ipLower.IsBlank() || m_ipUpper.IsBlank())
        {
            ::EnableWindow(m_hOkButton, FALSE);
        }
        else
        {
            ::EnableWindow(m_hOkButton, TRUE);
        }

        break;

    default:
        break;
    }

    return 0;
}

LRESULT CIpAddrRangeDlg::OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atlkcfg\atlkobj.h ===
#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include <nceh.h>
#include <ncsetup.h>
#include <notifval.h>
#include <winsock2.h>
#include "resource.h"

extern const WCHAR c_szEmpty[];

// AppleTalk Globally visible strings
extern const WCHAR c_chAt;

// Define the possible media types (Used also as array indices)
#define MEDIATYPE_ETHERNET      1
#define MEDIATYPE_TOKENRING     2
#define MEDIATYPE_FDDI          3
#define MEDIATYPE_WAN           4
#define MEDIATYPE_LOCALTALK     5

#define MAX_ZONES           255
#define ZONELISTSIZE        2048
#define MAX_ZONE_NAME_LEN   32
#define MAX_RANGE_ALLOWED   65279
#define MIN_RANGE_ALLOWED   1
#define ZONEBUFFER_LEN      32*255

// Seed Info  Validation returns
#define NO_SEED_INFO        0x0
#define VALID_SEED_INFO     0x1
#define INVALID_SEED_INFO   0x2

typedef enum
{
    AT_PNP_SWITCH_ROUTING = 0,
    AT_PNP_SWITCH_DEFAULT_ADAPTER,
    AT_PNP_RECONFIGURE_PARMS
} ATALK_PNP_MSGTYPE;

typedef struct _ATALK_PNP_EVENT
{
    ATALK_PNP_MSGTYPE   PnpMessage;
} ATALK_PNP_EVENT, *PATALK_PNP_EVENT;

// Class Forwards
class CATlkObj;
class CATLKEnv;
class CAdapterInfo;

// Define a structure for reading/writing all information necessary about an adapter
typedef struct
{
    DWORD  m_dwAarpRetries;
    DWORD  m_dwDdpCheckSums;
    DWORD  m_dwNetworkRangeLowerEnd;
    DWORD  m_dwNetworkRangeUpperEnd;
    DWORD  m_dwRouterPramNode;
    DWORD  m_dwSeedingNetwork;
    DWORD  m_dwUserPramNode1;
    DWORD  m_dwUserPramNode2;
    DWORD  m_dwMediaType;
    WCHAR* m_szDefaultZone;
    WCHAR* m_szPortName;
} ATLK_ADAPTER;

typedef list<CAdapterInfo *> ATLK_ADAPTER_INFO_LIST;

// Class:   CAdapters
//
// Purpose: Contain all information necessary about a single adapter instance
//
class CAdapterInfo
{
friend class CATLKEnv;
public:
    CAdapterInfo();
    ~CAdapterInfo();

    // Make a duplicate copy of 'this'
    HRESULT HrCopy(CAdapterInfo ** ppAI);

    void          SetDeletePending(BOOL f) {m_fDeletePending = f;}
    BOOL          FDeletePending() {return m_fDeletePending;}

    void          SetDisabled(BOOL f) {m_fDisabled = f;}
    BOOL          FDisabled() {return m_fDisabled;}

    void          SetCharacteristics(DWORD dw) {m_dwCharacteristics = dw;}
    DWORD         GetCharacteristics() {return m_dwCharacteristics;}
    BOOL          FHidden() {return !!(NCF_HIDDEN & m_dwCharacteristics);}

    void          SetMediaType(DWORD dw)     {m_AdapterInfo.m_dwMediaType = dw;}
    DWORD         DwMediaType()              {return m_AdapterInfo.m_dwMediaType;}

    void          SetDisplayName(PCWSTR psz) {m_strDisplayName = psz;}
    PCWSTR        SzDisplayName()            {return m_strDisplayName.c_str();}

    void          SetBindName(PCWSTR psz)    {m_strBindName = psz;}
    PCWSTR        SzBindName()               {return m_strBindName.c_str();}

    ATLK_ADAPTER* PAdapterInfo()             {return &m_AdapterInfo;}

    void          SetPortName(PCWSTR psz);
    PCWSTR        SzPortName()               {return m_AdapterInfo.m_szPortName ?
                                                     m_AdapterInfo.m_szPortName :
                                                     c_szEmpty;}

    void          SetDefaultZone(PCWSTR psz);
    PCWSTR        SzDefaultZone()            {return m_AdapterInfo.m_szDefaultZone ?
                                                     m_AdapterInfo.m_szDefaultZone :
                                                     c_szEmpty;}

    list<tstring*> &LstpstrZoneList()         {return m_lstpstrZoneList;}
    list<tstring*> &LstpstrDesiredZoneList()  {return m_lstpstrDesiredZoneList;}

    void          SetSeedingNetwork(BOOL fSeeding)
                                    {m_AdapterInfo.m_dwSeedingNetwork = (fSeeding ? 1 : 0);}
    DWORD         FSeedingNetwork() {return (1 == m_AdapterInfo.m_dwSeedingNetwork);}

    void          SetRouterOnNetwork(BOOL f) {m_fRouterOnNetwork = f;}
    BOOL          FRouterOnNetwork()         {return m_fRouterOnNetwork;}

    void          SetExistingNetRange(DWORD dwLower, DWORD dwUpper)
                                             {m_dwNetworkLower = dwLower;
                                              m_dwNetworkUpper = dwUpper;}
    DWORD         DwQueryNetworkUpper() {return m_dwNetworkUpper;}
    DWORD         DwQueryNetworkLower() {return m_dwNetworkLower;}

    void          SetAdapterNetRange(DWORD dwLower, DWORD dwUpper)
                                     {m_AdapterInfo.m_dwNetworkRangeLowerEnd = dwLower;
                                      m_AdapterInfo.m_dwNetworkRangeUpperEnd = dwUpper;}
    DWORD         DwQueryNetRangeUpper() {return m_AdapterInfo.m_dwNetworkRangeUpperEnd;}
    DWORD         DwQueryNetRangeLower() {return m_AdapterInfo.m_dwNetworkRangeLowerEnd;}

    void          SetNetDefaultZone(PCWSTR psz) {m_strNetDefaultZone = psz;}
    PCWSTR        SzNetDefaultZone() {return m_strNetDefaultZone.c_str();}

    HRESULT       HrConvertZoneListAndAddToPortInfo(CHAR * szZoneList, ULONG NumZones);
    HRESULT       HrGetAndSetNetworkInformation(SOCKET, PCWSTR);

    VOID          SetInstanceGuid(GUID guid) {memcpy(&m_guidInstance, &guid, sizeof(GUID));}
    GUID *        PInstanceGuid()   {return &m_guidInstance;}

    BOOL          IsDirty() {return m_fDirty;}
    VOID          SetDirty(BOOL f) {m_fDirty = f;}

    BOOL          IsRasAdapter() {return m_fRasAdapter;}
    VOID          SetRasAdapter(BOOL f) {m_fRasAdapter = f;}

    VOID          ZeroSpecialParams() {m_AdapterInfo.m_dwUserPramNode1 = 0;
                                       m_AdapterInfo.m_dwUserPramNode2 = 0;
                                       m_AdapterInfo.m_dwRouterPramNode = 0; }

    // m_guidInstance is the instance guid of the adapter
    GUID              m_guidInstance;

    // m_lstpstrZoneList is the REG_MULTI_SZ value found under
    // AppleTalk\Parameters\Adapters\<adapter>\ZoneList
    list<tstring*>    m_lstpstrZoneList;

    // Desired zone will be choosen from this list
    list<tstring*>    m_lstpstrDesiredZoneList;

    // m_AdapterInfo is the collection of values found under
    // AppleTalk\Parameters\Adapters\<adapter> with the exception of the
    // ZoneList : REG_MULTI_SZ value which is stored in m_lstpstrZoneList above.
    ATLK_ADAPTER      m_AdapterInfo;

private:
    // m_fDisabled is a boolean that, when TRUE, indicates this adapter
    // is currently disabled
    BOOL              m_fDisabled;

    // If true, this adapter's info has changed
    BOOL              m_fDirty;

    // m_fDeletePending is a boolean that, when TRUE, indicates this adapter
    // is being removed from the adapter list (eventually)
    BOOL              m_fDeletePending;

    // If true, the zone list contents are considered valid
    BOOL              m_fZoneListValid;

    // If true, this adapter exposes ndiswanatlk
    BOOL              m_fRasAdapter;

    // m_dwCharacteristics contains the adapter's characteristic settings
    DWORD             m_dwCharacteristics;

    // m_strBindName is the BindName for the adapter
    tstring           m_strBindName;

    // m_strDisplayName is the display name of the adapter
    tstring           m_strDisplayName;

    // Default zone returned by stack
    tstring           m_strNetDefaultZone;

    // Router network state
    BOOL              m_fRouterOnNetwork;

    DWORD             m_dwNetworkUpper;          // existing network # returned by stack
    DWORD             m_dwNetworkLower;          // existing network # returned by stack
};

// Define a structure for reading/writing AppleTalk\Parameters values
typedef struct
{
    DWORD  dwEnableRouter;
    WCHAR* szDefaultPort;
    WCHAR* szDesiredZone;
} ATLK_PARAMS;

// Class:   CATLKEnv
//
// Purpose: Contains the "Known" enviroment state regarding AppleTalk Params/Settings
//
class CATLKEnv
{
private:
    CATLKEnv(CATlkObj *pmsc);

public:
    // Automatic two-phase constructor
    static HRESULT HrCreate(CATLKEnv **, CATlkObj *);
    ~CATLKEnv();

    HRESULT HrCopy(CATLKEnv **ppEnv);

    HRESULT HrReadAppleTalkInfo();
    HRESULT HrGetAppleTalkInfoFromNetwork(CAdapterInfo * pAI);
    HRESULT HrGetAdapterInfo();
    HRESULT HrGetOneAdaptersInfo(INetCfgComponent*, CAdapterInfo **);
    HRESULT HrAddAdapter(INetCfgComponent * pnccFound);

    void    SetDefaultPort(PCWSTR psz);
    PCWSTR  SzDefaultPort()             {return (NULL != m_Params.szDefaultPort ?
                                                 m_Params.szDefaultPort :
                                                 c_szEmpty);}

    void    SetDesiredZone(PCWSTR psz);
    PCWSTR  SzDesiredZone()             {return (NULL != m_Params.szDesiredZone ?
                                                 m_Params.szDesiredZone :
                                                 c_szEmpty);}

    DWORD   DwDefaultAdaptersMediaType()  {return m_dwDefaultAdaptersMediaType;}
    void    SetDefaultMediaType(DWORD dw) {m_dwDefaultAdaptersMediaType = dw;}

    void    EnableRouting(BOOL f)         {m_Params.dwEnableRouter = (f ? 1 : 0);}
    BOOL    FRoutingEnabled()             {return (1 == m_Params.dwEnableRouter);}

    ATLK_ADAPTER_INFO_LIST &AdapterInfoList() {return m_lstpAdapters;}

    BOOL    FIsAppleTalkRunning() {return m_fATrunning;}
    void    SetATLKRunning(BOOL fRunning) {m_fATrunning = fRunning;}

    HRESULT HrUpdateRegistry();
    HRESULT HrWriteOneAdapter(CAdapterInfo *pAI);
    DWORD   DwMediaPriority(DWORD dwMediaType);
    void    InitDefaultPort();

    BOOL    FRouterChanged() {return m_fRouterChanged;}
    VOID    SetRouterChanged(BOOL f) {m_fRouterChanged = f;}

    BOOL    FDefAdapterChanged() {return m_fDefAdapterChanged;}
    VOID    SetDefAdapterChanged(BOOL f) {m_fDefAdapterChanged = f;}

    CAdapterInfo * PAIFindDefaultPort();

    ATLK_ADAPTER_INFO_LIST m_lstpAdapters;

private:
    CATlkObj *             m_pmsc;
    BOOL                   m_fRouterChanged;
    BOOL                   m_fDefAdapterChanged;
    BOOL                   m_fATrunning;
    DWORD                  m_dwDefaultAdaptersMediaType;
    ATLK_PARAMS            m_Params;
};

// Class:   CATLKGeneralDlg
//
// Purpose: Manage the "General" property page
//
class CATLKGeneralDlg: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CATLKGeneralDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOk)
        COMMAND_ID_HANDLER(CHK_GENERAL_DEFAULT, HandleChkBox)
    END_MSG_MAP()

    CATLKGeneralDlg(CATlkObj *pmsc, CATLKEnv * pATLKEnv);
    ~CATLKGeneralDlg();

    LRESULT HandleChkBox(WORD wNotifyCode, WORD wID,
                         HWND hWndCtl, BOOL& bHandled);
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& Handled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOk(INT idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    BOOL           FAddZoneListToControl(list<tstring*> * plstpstr);
    VOID           RefreshZoneCombo();

private:
    CATlkObj *      m_pmsc;
    CATLKEnv *      m_pATLKEnv;
};


/////////////////////////////////////////////////////////////////////////////
// CATlkObj

class ATL_NO_VTABLE CATlkObj :
    public CComObjectRoot,
    public CComCoClass<CATlkObj, &CLSID_CATlkObj>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentPropertyUi,
    public INetCfgComponentNotifyBinding
{
public:
    CATlkObj();
    ~CATlkObj();

    BEGIN_COM_MAP(CATlkObj)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CATlkObj)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_ATLKCFG)

    // Install Action (Unknown, Install, Remove)
    enum INSTALLACTION {eActUnknown, eActInstall, eActRemove};

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

    // INetCfgComponentSetup
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo) {return S_OK;}
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Removing)            ();

// INetCfgProperties
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk) { return S_OK; }
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk);
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

    // INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

    INetCfg          * PNetCfg() {return m_pNetCfg;}
    INetCfgComponent * PNCComponent() {return m_pNCC;}
    HRESULT HrCommitInstall();
    HRESULT HrCommitRemove();
    CATLKEnv * PATLKEnv() {return m_pATLKEnv;}

    VOID MarkAdapterListChanged() {m_fAdapterListChanged = TRUE;};

private:
    VOID CleanupPropPages();
    HRESULT HrProcessAnswerFile(PCWSTR pszAnswerFile,
                                PCWSTR pszAnswerSection);
    HRESULT HrReadAdapterAnswerFileSection(CSetupInfFile * pcsif,
                                           PCWSTR pszSection);
    HRESULT HrAtlkReconfig();

private:
    INetCfgComponent* m_pNCC;
    INetCfg*          m_pNetCfg;
    INSTALLACTION     m_eInstallAction;
    CPropSheetPage *  m_pspObj;
    CATLKEnv *        m_pATLKEnv;
    CATLKEnv *        m_pATLKEnv_PP;            // Used by prop pages only
    IUnknown *        m_pUnkPropContext;
    INT               m_nIdxAdapterSelected;    // Used by Prop Pages only
    BOOL              m_fAdapterListChanged;
    BOOL              m_fPropertyChange;
    BOOL              m_fFirstTimeInstall;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\arpsdlg.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A R P S D L G . H
//
//  Contents:   CArpsPage declaration
//
//  Notes:
//
//  Author:     tongl   2 Feb 1998
//
//-----------------------------------------------------------------------

#pragma once
#include "ncxbase.h"
#include "ncatlps.h"
#include "ipctrl.h"

const int c_nColumns =2;
const int IPRANGE_LIMIT = 66;

struct HandleGroup
{
    HWND    m_hListView;
    HWND    m_hAdd;
    HWND    m_hEdit;
    HWND    m_hRemove;
};

void ShowContextHelp(HWND hDlg, UINT uCommand, const DWORD*  pdwHelpIDs); 

//
// CArpsPage
//
class CArpsPage : public CPropSheetPage
{
public:
    // Declare the message map
    BEGIN_MSG_MAP(CArpsPage)
        // Initialize dialog
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)

        // List view handlers
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChanged)

        // Control message handlers
        COMMAND_ID_HANDLER(IDC_PSH_ARPS_REG_ADD,    OnAddRegisteredAddr);
        COMMAND_ID_HANDLER(IDC_PSH_ARPS_REG_EDT,    OnEditRegisteredAddr);
        COMMAND_ID_HANDLER(IDC_PSH_ARPS_REG_RMV,    OnRemoveRegisteredAddr);

        COMMAND_ID_HANDLER(IDC_PSH_ARPS_MUL_ADD,    OnAddMulticastAddr);
        COMMAND_ID_HANDLER(IDC_PSH_ARPS_MUL_EDT,    OnEditMulticastAddr);
        COMMAND_ID_HANDLER(IDC_PSH_ARPS_MUL_RMV,    OnRemoveMulticastAddr);

    END_MSG_MAP()

    // Constructors/Destructors
    CArpsPage(CArpsCfg * pArpscfg, const DWORD * phelpIDs = NULL);
    ~CArpsPage();

// Interface
public:

    // message map functions
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // command ID handlers
    LRESULT OnAddRegisteredAddr(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditRegisteredAddr(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveRegisteredAddr(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnAddMulticastAddr(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditMulticastAddr(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveMulticastAddr(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    friend class CAtmAddrDlg;
    friend class CIpAddrRangeDlg;

// Implementation
private:

    CArpsCfg *      m_pArpscfg;
    BOOL            m_fModified;
    const DWORD*    m_adwHelpIDs;

    CArpsAdapterInfo *  m_pAdapterInfo;

    HandleGroup m_hRegAddrs;
    HandleGroup m_hMulAddrs;

    BOOL m_fEditState;
    tstring m_strRemovedAtmAddr;
    tstring m_strRemovedIpRange;

    // Inlines
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}
    void PageModified() {
                            m_fModified = TRUE;
                            PropSheet_Changed(GetParent(), m_hWnd);
                        }

    // help functions
    void SetRegisteredAtmAddrInfo();
    void SetMulticastIpAddrInfo();

    void SetButtons(HandleGroup& handles);
    void LvInsertIpRangeInOrder(tstring& strNewIpRange);

    void UpdateInfo();

    int CheckDupRegAddr();
    int CheckOverlappedIpRange();
};

//
//  CAtmAddrDlg
//
class CAtmAddrDlg : public CDialogImpl<CAtmAddrDlg>
{
public:

    enum { IDD = IDD_ARPS_REG_ADDR };

    BEGIN_MSG_MAP(CAtmAddrDlg)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        COMMAND_ID_HANDLER(IDC_EDT_ARPS_REG_Address, OnChange);
    END_MSG_MAP()

public:
    CAtmAddrDlg(CArpsPage * pAtmArpsPage, const DWORD* pamhidsHelp = NULL);
    ~CAtmAddrDlg(){};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    friend class CArpsPage;

private:
    HWND m_hOkButton;     // this is the IDOK button, the text of the button changes
                          // with the context.
    HWND m_hEditBox;      // this is the edit box for the ATM address

    CArpsPage * m_pParentDlg;

    tstring m_strNewAtmAddr;

    const DWORD*    m_adwHelpIDs;
//    HINSTANCE       m_hInstance;
};

//
//  CIpAddrRangeDlg
//
class CIpAddrRangeDlg : public CDialogImpl<CIpAddrRangeDlg>
{
public:

    enum { IDD = IDD_ARPS_MUL_ADDR };

    BEGIN_MSG_MAP(CIpAddrRangeDlg)

        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        COMMAND_ID_HANDLER(IDC_ARPS_MUL_LOWER_IP, OnChangeLowerIp)
        COMMAND_ID_HANDLER(IDC_ARPS_MUL_UPPER_IP, OnChangeUpperIp)
        NOTIFY_CODE_HANDLER(IPN_FIELDCHANGED, OnIpFieldChange)

    END_MSG_MAP()
//
public:
    CIpAddrRangeDlg( CArpsPage * pAtmArpsPage,
                     const DWORD* pamhidsHelp = NULL);
    ~CIpAddrRangeDlg(){};

// Dialog creation overides
public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnChangeLowerIp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnChangeUpperIp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    BOOL InitDialog();

    friend class CArpsPage;

public:
    IpControl   m_ipLower;
    IpControl   m_ipUpper;

private:

    // this is the IDOK button, the text of the button changes
    // with the context.
    HWND m_hOkButton;

    CArpsPage * m_pParentDlg;

    tstring m_strNewIpRange;
    tstring m_strNewIpLower;
    tstring m_strNewIpUpper;

    const DWORD*    m_adwHelpIDs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\advdlg.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:      A D V D L G . C P P
//
//  Contents:  PVC advanced property pages message handler implementation
//
//  Notes:
//
//  Author:     tongl   1 Mar, 1998
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "auniobj.h"
#include "atmutil.h"
#include "aunidlg.h"
//#include "atmcommon.h"

#include "ncatlui.h"
#include "ncstl.h"
#include "ncui.h"

const int MAX_FIELD_LENGTH = 3;

const DWORD c_dwUserSpecProtocol = 16;
const WCHAR c_szUserSpecProtocol[] = L"16";

const DWORD c_dwUserSpecHighLayer = 1;
const WCHAR c_szUserSpecHighLayer[] = L"1";

const DWORD c_dwFieldHigh = 255;
const DWORD c_dwFieldLow  = 0;

enum Location
{
    LOCAL,
    DEST
};

void InitBroadbandInfo(HWND hDlg);

void SetBroadbandInfo(HWND hDlg, CPvcInfo * pPvcInfo, Location location);
void SetProtocolInfo(HWND hDlg, int nIDDlgItemCombo, int nIDDlgItemEdit,
                     DWORD dwProtocol, DWORD dwUserSpecValue);
void SetHighLayerInfo(HWND hDlg, DWORD dwHighLayerInfoType,
                      tstring & strHighLayerInfo);

void GetBroadbandInfo(HWND hDlg, CPvcInfo * pPvcInfo, Location location);
void GetProtocolInfo(HWND hDlg, int nIDDlgItemCombo, int nIDDlgItemEdit,
                     DWORD * pdwProtocol, DWORD * pdwUserSpecValue);
void GetHighLayerInfo(HWND hDlg, DWORD * pdwHighLayerInfoType,
                      tstring * pstrHighLayerInfo);

void OnLayer2EdtChange(HWND hDlg);
void OnLayer2SelChange(HWND hDlg);

void OnLayer3EdtChange(HWND hDlg);
void OnLayer3SelChange(HWND hDlg);

void OnHighLayerEdtChange(HWND hDlg);
void OnHighLayerSelChange(HWND hDlg);

void GetNumFromString(PWSTR pszBuf, DWORD * dwNum);

BOOL InvalidBroadbandInfo(HWND hDlg);
BOOL IsValidCmbSelection(HWND hDlg, int nIDDlgItemCombo);
BOOL IsValidDwordField(HWND hDlg, int nIDDlgItemEdit);
BOOL IsValidBinaryField(HWND hDlg, int nIDDlgItemEdit, int nMaxBytes);

//
// CPvcLocalPage
//

// Constructors/Destructors
CPvcLocalPage::CPvcLocalPage(CPVCMainDialog * pParentDlg,
                             CPvcInfo * pPvcInfo, const DWORD * adwHelpIDs)
{
    Assert(pPvcInfo);
    Assert(pParentDlg);

    m_pParentDlg = pParentDlg;
    m_pPvcInfo = pPvcInfo;
    m_adwHelpIDs = adwHelpIDs;
}

CPvcLocalPage::~CPvcLocalPage()
{
}

// Command handlers
LRESULT CPvcLocalPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Add strings to the combo boxes
    InitBroadbandInfo(m_hWnd);

    // Now set the value based on what's in our data structure
    SetBroadbandInfo(m_hWnd, m_pPvcInfo, LOCAL);

    return 0;
}

LRESULT CPvcLocalPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                     LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CPvcLocalPage::OnHelp(UINT uMsg, WPARAM wParam,
                                LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

// notify handlers for the property page
LRESULT CPvcLocalPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    m_pParentDlg->m_fPropShtOk = TRUE;

    GetBroadbandInfo(m_hWnd, m_pPvcInfo, LOCAL);

    // did any field change ?
    if ((m_pPvcInfo->m_dwLocalLayer2Protocol    != m_pPvcInfo->m_dwOldLocalLayer2Protocol) ||
        (m_pPvcInfo->m_dwLocalUserSpecLayer2    != m_pPvcInfo->m_dwOldLocalUserSpecLayer2) ||
        (m_pPvcInfo->m_dwLocalLayer3Protocol    != m_pPvcInfo->m_dwOldLocalLayer3Protocol) ||
        (m_pPvcInfo->m_dwLocalUserSpecLayer3    != m_pPvcInfo->m_dwOldLocalUserSpecLayer3) ||
        (m_pPvcInfo->m_dwLocalLayer3IPI         != m_pPvcInfo->m_dwOldLocalLayer3IPI) ||
        (m_pPvcInfo->m_strLocalSnapId           != m_pPvcInfo->m_strOldLocalSnapId) ||
        (m_pPvcInfo->m_dwLocalHighLayerInfoType != m_pPvcInfo->m_dwOldLocalHighLayerInfoType) ||
        (m_pPvcInfo->m_strLocalHighLayerInfo    != m_pPvcInfo->m_strOldLocalHighLayerInfo)
       )
    {
       m_pParentDlg->m_fPropShtModified = TRUE;
    }

    return 0;
}

LRESULT CPvcLocalPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    // check that all values are valid
    BOOL err = InvalidBroadbandInfo(m_hWnd);

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, err);
    return err;
}

LRESULT CPvcLocalPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CPvcLocalPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CPvcLocalPage::OnLayer2(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case CBN_EDITCHANGE:
            OnLayer2EdtChange(m_hWnd);
            break;

        case CBN_SELCHANGE:
            OnLayer2SelChange(m_hWnd);
            break;

        default:
            break;
    }

    return 0;
}

LRESULT CPvcLocalPage::OnLayer3(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case CBN_EDITCHANGE:
            OnLayer3EdtChange(m_hWnd);
            break;

        case CBN_SELCHANGE:
            OnLayer3SelChange(m_hWnd);
            break;

        default:
            break;
    }

    return 0;
}

LRESULT CPvcLocalPage::OnHighLayer(WORD wNotifyCode, WORD wID,
                                   HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case CBN_EDITCHANGE:
            OnHighLayerEdtChange(m_hWnd);
            break;

        case CBN_SELCHANGE:
            OnHighLayerSelChange(m_hWnd);
            break;

        default:
            break;
    }

    return 0;
}

//
// CPvcDestPage
//

// Constructors/Destructors
CPvcDestPage::CPvcDestPage(CPVCMainDialog * pParentDlg,
                           CPvcInfo * pPvcInfo, const DWORD * adwHelpIDs)
{
    Assert(pPvcInfo);
    Assert(pParentDlg);

    m_pParentDlg = pParentDlg;
    m_pPvcInfo = pPvcInfo;
    m_adwHelpIDs = adwHelpIDs;
}

CPvcDestPage::~CPvcDestPage()
{
}

// Command handlers
LRESULT CPvcDestPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Add strings to the combo boxes
    InitBroadbandInfo(m_hWnd);

    // Now set the value based on what's in our data structure
    SetBroadbandInfo(m_hWnd, m_pPvcInfo, DEST);

    return 0;
}

LRESULT CPvcDestPage::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CPvcDestPage::OnHelp(UINT uMsg, WPARAM wParam,
                                LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

// notify handlers for the property page
LRESULT CPvcDestPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    m_pParentDlg->m_fPropShtOk = TRUE;

    GetBroadbandInfo(m_hWnd, m_pPvcInfo, DEST);

    // did any field change ?
    if ((m_pPvcInfo->m_dwDestnLayer2Protocol    != m_pPvcInfo->m_dwOldDestnLayer2Protocol) ||
        (m_pPvcInfo->m_dwDestnUserSpecLayer2    != m_pPvcInfo->m_dwOldDestnUserSpecLayer2) ||
        (m_pPvcInfo->m_dwDestnLayer3Protocol    != m_pPvcInfo->m_dwOldDestnLayer3Protocol) ||
        (m_pPvcInfo->m_dwDestnUserSpecLayer3    != m_pPvcInfo->m_dwOldDestnUserSpecLayer3) ||
        (m_pPvcInfo->m_dwDestnLayer3IPI         != m_pPvcInfo->m_dwOldDestnLayer3IPI) ||
        (m_pPvcInfo->m_strDestnSnapId           != m_pPvcInfo->m_strOldDestnSnapId) ||
        (m_pPvcInfo->m_dwDestnHighLayerInfoType != m_pPvcInfo->m_dwOldDestnHighLayerInfoType) ||
        (m_pPvcInfo->m_strDestnHighLayerInfo    != m_pPvcInfo->m_strOldDestnHighLayerInfo)
       )
    {
       m_pParentDlg->m_fPropShtModified = TRUE;
    }

    return 0;
}

LRESULT CPvcDestPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    // check that all values are valid
    BOOL err = InvalidBroadbandInfo(m_hWnd);

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, err);
    return err;
}

LRESULT CPvcDestPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CPvcDestPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

// Control notification handlers
LRESULT CPvcDestPage::OnLayer2(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case CBN_EDITCHANGE:
            OnLayer2EdtChange(m_hWnd);
            break;

        case CBN_SELCHANGE:
            OnLayer2SelChange(m_hWnd);
            break;

        default:
            break;
    }

    return 0;
}

LRESULT CPvcDestPage::OnLayer3(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case CBN_EDITCHANGE:
            OnLayer3EdtChange(m_hWnd);
            break;

        case CBN_SELCHANGE:
            OnLayer3SelChange(m_hWnd);
            break;

        default:
            break;
    }

    return 0;
}

LRESULT CPvcDestPage::OnHighLayer(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case CBN_EDITCHANGE:
            OnHighLayerEdtChange(m_hWnd);
            break;

        case CBN_SELCHANGE:
            OnHighLayerSelChange(m_hWnd);
            break;

        default:
            break;
    }

    return 0;
}



//+---------------------------------------------------------------------------
//
//  Member:     AtmEditSubclassProc
//
//  Purpose:    Subclass proc for hex number edit controls.  The
//              subclassing forces only correct input
//
//  Author:     [from scottbri 28-Apr-1997]
//
STDAPI AtmEditSubclassProc( HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
    WNDPROC pAtmEditProc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if ((wMsg == WM_CHAR) &&
        !(((WCHAR)wParam >= L'0' && (WCHAR)wParam <= L'9') ||
          ((WCHAR)wParam >= L'a' && (WCHAR)wParam <= L'f') ||
          ((WCHAR)wParam >= L'A' && (WCHAR)wParam <= L'F') ||
          ((WCHAR)wParam == VK_BACK)))
    {
        MessageBeep(MB_ICONEXCLAMATION);
        return 0L;
    }

    return CallWindowProc( pAtmEditProc, hwnd, wMsg, wParam, lParam );
}

//
// Common utility functions shared by both local and destination dialogs
//
void InitBroadbandInfo(HWND hDlg)
{
    HWND hwndTmp;

    // layer2 protocol: IDC_CMB_PVC_Layer2
    static const int nrgLayer2Ids[] = { IDS_PVC_Any,
                                        IDS_PVC_Absent,
                                        IDS_PVC_Layer2_1,
                                        IDS_PVC_Layer2_2,
                                        IDS_PVC_Layer2_6,
                                        IDS_PVC_Layer2_7,
                                        IDS_PVC_Layer2_8,
                                        IDS_PVC_Layer2_9,
                                        IDS_PVC_Layer2_10,
                                        IDS_PVC_Layer2_11,
                                        IDS_PVC_Layer2_12,
                                        IDS_PVC_Layer2_13,
                                        IDS_PVC_Layer2_14,
                                        IDS_PVC_Layer2_16,
                                        IDS_PVC_Layer2_17 };

    InitComboWithStringArray(hDlg, IDC_CMB_PVC_Layer2, celems(nrgLayer2Ids), nrgLayer2Ids);

    // layer3 protocol: IDC_CMB_PVC_Layer3
    static const int nrgLayer3Ids[] = { IDS_PVC_Any,
                                        IDS_PVC_Absent,
                                        IDS_PVC_Layer3_6,
                                        IDS_PVC_Layer3_7,
                                        IDS_PVC_Layer3_8,
                                        IDS_PVC_Layer3_9,
                                        IDS_PVC_Layer3_10,
                                        IDS_PVC_Layer3_11,
                                        IDS_PVC_Layer3_16 };

    InitComboWithStringArray(hDlg, IDC_CMB_PVC_Layer3, celems(nrgLayer3Ids), nrgLayer3Ids);

    // high layer type: IDC_CMB_PVC_High_Type
    static const int nrgHighLayerIds[] = {  IDS_PVC_Any,
                                            IDS_PVC_Absent,
                                            IDS_PVC_HighLayer_0,
                                            IDS_PVC_HighLayer_1,
                                            IDS_PVC_HighLayer_3 };

    InitComboWithStringArray(hDlg, IDC_CMB_PVC_High_Type,
                             celems(nrgHighLayerIds), nrgHighLayerIds);

    // set length limits for edit boxes
    ::SendDlgItemMessage(hDlg, IDC_EDT_PVC_User_Layer2, EM_SETLIMITTEXT, MAX_FIELD_LENGTH, 0);
    ::SendDlgItemMessage(hDlg, IDC_EDT_PVC_User_Layer3, EM_SETLIMITTEXT, MAX_FIELD_LENGTH, 0);
    ::SendDlgItemMessage(hDlg, IDC_EDT_PVC_Layer3_IPI, EM_SETLIMITTEXT, MAX_FIELD_LENGTH, 0);

    hwndTmp = GetDlgItem(hDlg, IDC_EDT_PVC_SNAP_ID);

    // Subclass the edit control to allow only hex digits
    ::SetWindowLongPtr(hwndTmp, GWLP_USERDATA, ::GetWindowLongPtr(hwndTmp, GWLP_WNDPROC));
    ::SetWindowLongPtr(hwndTmp, GWLP_WNDPROC, (LONG_PTR)AtmEditSubclassProc);

    ::SendDlgItemMessage(hDlg, IDC_EDT_PVC_SNAP_ID, EM_SETLIMITTEXT, c_nSnapIdMaxBytes*2, 0);
    ::SendDlgItemMessage(hDlg, IDC_CMB_PVC_High_Value, EM_SETLIMITTEXT, c_nHighLayerInfoMaxBytes*2, 0);
}

void SetBroadbandInfo(HWND hDlg, CPvcInfo * pPvcInfo, Location location)
{
    // layer2 protocol and user specified value
    DWORD dwLayer2Protocol;
    DWORD dwUserSpecLayer2;

    if (location == LOCAL)
    {
        dwLayer2Protocol = pPvcInfo->m_dwLocalLayer2Protocol;
        dwUserSpecLayer2 = pPvcInfo->m_dwLocalUserSpecLayer2;
    }
    else
    {
        dwLayer2Protocol = pPvcInfo->m_dwDestnLayer2Protocol;
        dwUserSpecLayer2 = pPvcInfo->m_dwDestnUserSpecLayer2;
    }

    SetProtocolInfo(hDlg, IDC_CMB_PVC_Layer2, IDC_EDT_PVC_User_Layer2,
                    dwLayer2Protocol, dwUserSpecLayer2);

    // layer3 protocol and user specified value
    DWORD dwLayer3Protocol;
    DWORD dwUserSpecLayer3;

    if (location == LOCAL)
    {
        dwLayer3Protocol = pPvcInfo->m_dwLocalLayer3Protocol;
        dwUserSpecLayer3 = pPvcInfo->m_dwLocalUserSpecLayer3;
    }
    else
    {
        dwLayer3Protocol = pPvcInfo->m_dwDestnLayer3Protocol;
        dwUserSpecLayer3 = pPvcInfo->m_dwDestnUserSpecLayer3;
    }

    SetProtocolInfo(hDlg, IDC_CMB_PVC_Layer3, IDC_EDT_PVC_User_Layer3,
                    dwLayer3Protocol, dwUserSpecLayer3);


    // Layer3 IPI
    DWORD dwLayer3IPI;
    if (location == LOCAL)
    {
        dwLayer3IPI = pPvcInfo->m_dwLocalLayer3IPI;
    }
    else
    {
        dwLayer3IPI = pPvcInfo->m_dwDestnLayer3IPI;
    }

    SetDwordEdtField(hDlg, dwLayer3IPI, IDC_EDT_PVC_Layer3_IPI);

    // Snap ID
    if (location == LOCAL)
    {
        SetDlgItemText(hDlg,IDC_EDT_PVC_SNAP_ID, pPvcInfo->m_strLocalSnapId.c_str());
    }
    else
    {
        SetDlgItemText(hDlg,IDC_EDT_PVC_SNAP_ID, pPvcInfo->m_strDestnSnapId.c_str());
    }

    // High layer
    DWORD    dwHighLayerInfoType;
    tstring  strHighLayerInfo;

    if (location == LOCAL)
    {
        dwHighLayerInfoType = pPvcInfo->m_dwLocalHighLayerInfoType;
        strHighLayerInfo = pPvcInfo->m_strLocalHighLayerInfo;
    }
    else
    {
        dwHighLayerInfoType = pPvcInfo->m_dwDestnHighLayerInfoType;
        strHighLayerInfo = pPvcInfo->m_strDestnHighLayerInfo;
    }

    SetHighLayerInfo(hDlg, dwHighLayerInfoType, strHighLayerInfo);
}

void SetProtocolInfo(HWND hDlg, int nIDDlgItemCombo, int nIDDlgItemEdit,
                     DWORD dwProtocol, DWORD dwUserSpecValue)
{
    if ( FIELD_ANY == dwProtocol)
    {
        SendDlgItemMessage(hDlg, nIDDlgItemCombo, CB_SETCURSEL, (LPARAM)(0), 0);
    }
    else if ( FIELD_ABSENT == dwProtocol)
    {
        SendDlgItemMessage(hDlg, nIDDlgItemCombo, CB_SETCURSEL, (LPARAM)(1), 0);
    }
    else if (FIELD_UNSET != dwProtocol)
    {
        WCHAR szBuf[MAX_FIELD_LENGTH+1];
        wsprintfW(szBuf, c_szItoa, dwProtocol);

        tstring strBuf = szBuf;

        // attached the separator '-'
        strBuf+= c_chSeparator;

        // see if the value is one of the pre-defined protocol
        int nIdx = SendDlgItemMessage(hDlg, nIDDlgItemCombo, CB_FINDSTRING, -1,
                                      (LPARAM)strBuf.c_str());

        if (CB_ERR == nIdx) // not one of the pre-defined protocols
        {
            SetDlgItemText(hDlg, nIDDlgItemCombo, szBuf);
        }
        else
        {
            SendDlgItemMessage(hDlg, nIDDlgItemCombo, CB_SETCURSEL, nIdx, 0L);
        }
    }

    if (dwProtocol == c_dwUserSpecProtocol)
    {
        SetDwordEdtField(hDlg, dwUserSpecValue, nIDDlgItemEdit);
    }
    else
    {
        ::EnableWindow(::GetDlgItem(hDlg,nIDDlgItemEdit), FALSE);
    }
}

void SetHighLayerInfo(HWND hDlg, DWORD dwHighLayerInfoType, tstring & strHighLayerInfo)
{
    if ( FIELD_ANY == dwHighLayerInfoType)
    {
        SendDlgItemMessage(hDlg, IDC_CMB_PVC_High_Type, CB_SETCURSEL, (LPARAM)(0), 0);
    }
    else if ( FIELD_ABSENT == dwHighLayerInfoType)
    {
        SendDlgItemMessage(hDlg, IDC_CMB_PVC_High_Type, CB_SETCURSEL, (LPARAM)(1), 0);
    }
    else if ( FIELD_UNSET != dwHighLayerInfoType)
    {
        WCHAR szBuf[MAX_FIELD_LENGTH+1];
        wsprintfW(szBuf, c_szItoa, dwHighLayerInfoType);

        tstring strBuf = szBuf;

        // attached the separator '-'
        strBuf+= c_chSeparator;

        // see if the value is one of the pre-defined protocol
        int nIdx = SendDlgItemMessage(hDlg, IDC_CMB_PVC_High_Type, CB_FINDSTRING, -1,
                                      (LPARAM)strBuf.c_str());

        if (CB_ERR == nIdx) // not one of the pre-defined protocols
        {
            SetDlgItemText(hDlg, IDC_CMB_PVC_High_Type, szBuf);
        }
        else
        {
            SendDlgItemMessage(hDlg, IDC_CMB_PVC_High_Type, CB_SETCURSEL, nIdx, 0L);
        }
    }

    if (dwHighLayerInfoType == c_dwUserSpecHighLayer)
    {
        HWND    hwndTmp;

        hwndTmp = GetDlgItem(hDlg, IDC_CMB_PVC_High_Value);

        // Subclass the edit control to allow only hex digits
        ::SetWindowLongPtr(hwndTmp, GWLP_USERDATA, ::GetWindowLongPtr(hwndTmp,
                                        GWLP_WNDPROC));
        ::SetWindowLongPtr(hwndTmp, GWLP_WNDPROC, (LONG_PTR)AtmEditSubclassProc);

        SetDlgItemText(hDlg, IDC_CMB_PVC_High_Value, strHighLayerInfo.c_str());
    }
    else
    {
        ::EnableWindow(::GetDlgItem(hDlg,IDC_CMB_PVC_High_Value), FALSE);
        ::EnableWindow(::GetDlgItem(hDlg,IDC_TXT_PVC_Value), FALSE);
    }
}

void GetBroadbandInfo(HWND hDlg, CPvcInfo * pPvcInfo, Location location)
{
    // layer2 protocol and user specified value
    DWORD * pdwLayer2Protocol;
    DWORD * pdwUserSpecLayer2;

    if (location == LOCAL)
    {
        pdwLayer2Protocol = &(pPvcInfo->m_dwLocalLayer2Protocol);
        pdwUserSpecLayer2 = &(pPvcInfo->m_dwLocalUserSpecLayer2);
    }
    else
    {
        pdwLayer2Protocol = &(pPvcInfo->m_dwDestnLayer2Protocol);
        pdwUserSpecLayer2 = &(pPvcInfo->m_dwDestnUserSpecLayer2);
    }

    GetProtocolInfo(hDlg, IDC_CMB_PVC_Layer2, IDC_EDT_PVC_User_Layer2,
                    pdwLayer2Protocol, pdwUserSpecLayer2);

    // layer3 protocol and user specified value
    DWORD * pdwLayer3Protocol;
    DWORD * pdwUserSpecLayer3;

    if (location == LOCAL)
    {
        pdwLayer3Protocol = &(pPvcInfo->m_dwLocalLayer3Protocol);
        pdwUserSpecLayer3 = &(pPvcInfo->m_dwLocalUserSpecLayer3);
    }
    else
    {
        pdwLayer3Protocol = &(pPvcInfo->m_dwDestnLayer3Protocol);
        pdwUserSpecLayer3 = &(pPvcInfo->m_dwDestnUserSpecLayer3);
    }

    GetProtocolInfo(hDlg, IDC_CMB_PVC_Layer3, IDC_EDT_PVC_User_Layer3,
                    pdwLayer3Protocol, pdwUserSpecLayer3);

    // Layer3 IPI
    DWORD * pdwLayer3IPI;
    if (location == LOCAL)
    {
        pdwLayer3IPI = &(pPvcInfo->m_dwLocalLayer3IPI);
    }
    else
    {
        pdwLayer3IPI = &(pPvcInfo->m_dwDestnLayer3IPI);
    }

    GetDwordEdtField(hDlg, pdwLayer3IPI, IDC_EDT_PVC_Layer3_IPI);

    // Snap ID
    WCHAR   szSnapId[MAX_PATH];
    GetDlgItemText(hDlg, IDC_EDT_PVC_SNAP_ID, szSnapId, celems(szSnapId));
    if (location == LOCAL)
    {
        pPvcInfo->m_strLocalSnapId = szSnapId;
    }
    else
    {
        pPvcInfo->m_strDestnSnapId = szSnapId;
    }

    // High layer
    DWORD * pdwHighLayerInfoType;
    tstring * pstrHighLayerInfo;

    if (location == LOCAL)
    {
        pdwHighLayerInfoType = &(pPvcInfo->m_dwLocalHighLayerInfoType);
        pstrHighLayerInfo = &(pPvcInfo->m_strLocalHighLayerInfo);
    }
    else
    {
        pdwHighLayerInfoType = &(pPvcInfo->m_dwDestnHighLayerInfoType);
        pstrHighLayerInfo = &(pPvcInfo->m_strDestnHighLayerInfo);
    }

    GetHighLayerInfo(hDlg, pdwHighLayerInfoType, pstrHighLayerInfo);
}

void GetProtocolInfo(HWND hDlg, int nIDDlgItemCombo, int nIDDlgItemEdit,
                     DWORD * pdwProtocol, DWORD * pdwUserSpecValue)
{
    WCHAR szBuf[MAX_PATH];

    int nlen = GetDlgItemText(hDlg, nIDDlgItemCombo, szBuf, MAX_PATH);
    if (nlen==0)
    {
        // empty protocol2 field
        *pdwProtocol = FIELD_UNSET;
        *pdwUserSpecValue = FIELD_UNSET;

    }
    else
    {
        int nIdx = SendDlgItemMessage(hDlg, nIDDlgItemCombo, CB_FINDSTRINGEXACT, -1,
                                      (LPARAM)(PCWSTR)szBuf);

        if (0 == nIdx)
        {
            *pdwProtocol = FIELD_ANY;
            *pdwUserSpecValue = 0;
        }
        else if (1 == nIdx)
        {
            *pdwProtocol = FIELD_ABSENT;
            *pdwUserSpecValue = 0;
        }
        else
        {
            GetNumFromString(szBuf, pdwProtocol);

            *pdwUserSpecValue = 0;
            if (*pdwProtocol == c_dwUserSpecProtocol)
            {
                GetDwordEdtField(hDlg, pdwUserSpecValue, nIDDlgItemEdit);
            }
        }
    }
}

void GetHighLayerInfo(HWND hDlg, DWORD * pdwHighLayerInfoType, tstring * pstrHighLayerInfo)
{
    WCHAR szBuf[MAX_PATH];

    *pstrHighLayerInfo = c_szEmpty;

    int nlen = GetDlgItemText(hDlg, IDC_CMB_PVC_High_Type, szBuf, MAX_PATH);
    if (nlen==0)
    {
        // empty field
        *pdwHighLayerInfoType = FIELD_UNSET;
    }
    else
    {
        int nIdx = SendDlgItemMessage(hDlg, IDC_CMB_PVC_High_Type, CB_FINDSTRINGEXACT, -1,
                                      (LPARAM)(PCWSTR)szBuf);

        if (0 == nIdx)
        {
            *pdwHighLayerInfoType = FIELD_ANY;
        }
        else if (1 == nIdx)
        {
            *pdwHighLayerInfoType = FIELD_ABSENT;
        }
        else
        {
            GetNumFromString(szBuf, pdwHighLayerInfoType);
            if (*pdwHighLayerInfoType == c_dwUserSpecHighLayer)
            {
                WCHAR   szHighLayerInfo[MAX_PATH];
                GetDlgItemText(hDlg, IDC_CMB_PVC_High_Value,
                               szHighLayerInfo, celems(szHighLayerInfo));

                *pstrHighLayerInfo = szHighLayerInfo;
            }
        }
    }
}

void OnLayer2EdtChange(HWND hDlg)
{
    // get the current value in the control,
    // and see if we should enable or disable the edit box for user specified value
    WCHAR szBuf[MAX_PATH];
    GetDlgItemText(hDlg, IDC_CMB_PVC_Layer2, szBuf, MAX_PATH);

    if (!(*szBuf))
    {
        ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer2), FALSE);
    }
    else
    {
        // the string has to be equal to the specific number
        if (0 == wcscmp(szBuf, c_szUserSpecProtocol))
        {
            ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer2), TRUE);
        }
        else
        {
            ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer2), FALSE);
        }
    }
}

void OnLayer2SelChange(HWND hDlg)
{
    // get the index of the new selection
    int idx = SendDlgItemMessage(hDlg, IDC_CMB_PVC_Layer2, CB_GETCURSEL, (LPARAM)(0), 0);

    if (idx != CB_ERR)
    {
        // get the string of the current selection
        WCHAR szBuf[MAX_PATH];
        int len = SendDlgItemMessage(hDlg, IDC_CMB_PVC_Layer2, CB_GETLBTEXT,
                                     (LPARAM)(idx), (WPARAM)(PCWSTR)szBuf);

        if ((len != CB_ERR) && (len>0))
        {
            DWORD dwNum;
            GetNumFromString(szBuf, &dwNum);

            if (dwNum == c_dwUserSpecProtocol)
            {
                ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer2), TRUE);
            }
            else
            {
                ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer2), FALSE);
            }
        }
    }
}

void OnLayer3EdtChange(HWND hDlg)
{
    // get the current value in the control,
    // and see if we should enable or disable the edit box for user specified value
    WCHAR szBuf[MAX_PATH];
    GetDlgItemText(hDlg, IDC_CMB_PVC_Layer3, szBuf, MAX_PATH);

    if (!(*szBuf))
    {
        ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer3), FALSE);
    }
    else
    {
        // the string has to be equal to the specific number
        if (0 == wcscmp(szBuf, c_szUserSpecProtocol))
        {
            ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer3), TRUE);
        }
        else
        {
            ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer3), FALSE);
        }
    }
}

void OnLayer3SelChange(HWND hDlg)
{
    // get the index of the new selection
    int idx = SendDlgItemMessage(hDlg, IDC_CMB_PVC_Layer3, CB_GETCURSEL, (LPARAM)(0), 0);

    if (idx != CB_ERR)
    {
        // get the string of the current selection
        WCHAR szBuf[MAX_PATH];
        int len = SendDlgItemMessage(hDlg, IDC_CMB_PVC_Layer3, CB_GETLBTEXT,
                                     (LPARAM)(idx), (WPARAM)(PCWSTR)szBuf);

        if ((len != CB_ERR) && (len>0))
        {
            DWORD dwNum;
            GetNumFromString(szBuf, &dwNum);

            if (dwNum == c_dwUserSpecProtocol)
            {
                ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer3), TRUE);
            }
            else
            {
                ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer3), FALSE);
            }
        }
    }
}

void OnHighLayerEdtChange(HWND hDlg)
{
    // get the current value in the control,
    // and see if we should enable or disable the edit box for user specified value
    WCHAR szBuf[MAX_PATH];
    GetDlgItemText(hDlg, IDC_CMB_PVC_High_Type, szBuf, MAX_PATH);

    if (!(*szBuf))
    {
        ::EnableWindow(::GetDlgItem(hDlg, IDC_CMB_PVC_High_Value), FALSE);
        ::EnableWindow(::GetDlgItem(hDlg, IDC_TXT_PVC_Value), FALSE);
    }
    else
    {
        // the string has to be equal to the specific number
        if (0 == wcscmp(szBuf, c_szUserSpecHighLayer))
        {
            ::EnableWindow(::GetDlgItem(hDlg,IDC_CMB_PVC_High_Value), TRUE);
            ::EnableWindow(::GetDlgItem(hDlg, IDC_TXT_PVC_Value), TRUE);
        }
        else
        {
            ::EnableWindow(::GetDlgItem(hDlg,IDC_CMB_PVC_High_Value), FALSE);
            ::EnableWindow(::GetDlgItem(hDlg, IDC_TXT_PVC_Value), FALSE);
        }
    }
}

void OnHighLayerSelChange(HWND hDlg)
{
    // get the index of the new selection
    int idx = SendDlgItemMessage(hDlg, IDC_CMB_PVC_High_Type, CB_GETCURSEL, (LPARAM)(0), 0);

    if (idx != CB_ERR)
    {
        // get the string of the current selection
        WCHAR szBuf[MAX_PATH];
        int len = SendDlgItemMessage(hDlg, IDC_CMB_PVC_High_Type, CB_GETLBTEXT,
                                     (LPARAM)(idx), (WPARAM)(PCWSTR)szBuf);

        if ((len != CB_ERR) && (len>0))
        {
            DWORD dwNum;
            GetNumFromString(szBuf, &dwNum);

            if (dwNum == c_dwUserSpecHighLayer)
            {
                HWND    hwndTmp;

                hwndTmp = GetDlgItem(hDlg, IDC_CMB_PVC_High_Value);

                // Subclass the edit control to allow only hex digits
                ::SetWindowLongPtr(hwndTmp, GWLP_USERDATA, ::GetWindowLongPtr(hwndTmp,
                                                GWLP_WNDPROC));
                ::SetWindowLongPtr(hwndTmp, GWLP_WNDPROC, (LONG_PTR)AtmEditSubclassProc);

                ::EnableWindow(::GetDlgItem(hDlg,IDC_CMB_PVC_High_Value), TRUE);
                ::EnableWindow(::GetDlgItem(hDlg, IDC_TXT_PVC_Value), TRUE);
            }
            else
            {
                ::EnableWindow(::GetDlgItem(hDlg,IDC_CMB_PVC_High_Value), FALSE);
                ::EnableWindow(::GetDlgItem(hDlg, IDC_TXT_PVC_Value), FALSE);
            }
        }
    }
}

void GetNumFromString(PWSTR pszBuf, DWORD * pdwNum)
{
    *pdwNum=0;

    WCHAR * pch;
    pch = pszBuf;

    while ((*pch >= L'0') && (*pch <= L'9'))
    {
        *pdwNum = (*pdwNum*10) + (*pch - L'0');
        pch++;
    }
}

BOOL InvalidBroadbandInfo(HWND hDlg)
{
    BOOL err = FALSE;

    // layer2 protocol & value
    if (!IsValidCmbSelection(hDlg, IDC_CMB_PVC_Layer2))
    {
        NcMsgBox(hDlg, IDS_MSFT_UNI_TEXT, IDS_INVALID_Layer2_Protocol,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        SetFocus(GetDlgItem(hDlg, IDC_CMB_PVC_Layer2));
        err = TRUE;
    }
    else if ((!err) && (IsWindowEnabled(GetDlgItem(hDlg, IDC_EDT_PVC_User_Layer2))))
    {
        if (!IsValidDwordField(hDlg, IDC_EDT_PVC_User_Layer2))
        {
            NcMsgBox(hDlg, IDS_MSFT_UNI_TEXT, IDS_INVALID_Layer2_UserSpec,
             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            SetFocus(GetDlgItem(hDlg, IDC_EDT_PVC_User_Layer2));
            err = TRUE;
        }
    }

    // layer3 protocol & value
    if (!err)
    {
        if (!IsValidCmbSelection(hDlg, IDC_CMB_PVC_Layer3))
        {
            NcMsgBox(hDlg, IDS_MSFT_UNI_TEXT, IDS_INVALID_Layer3_Protocol,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            SetFocus(GetDlgItem(hDlg,IDC_CMB_PVC_Layer3));
            err = TRUE;
        }
        else if ((!err) && (IsWindowEnabled(GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer3))))
        {
            if (!IsValidDwordField(hDlg, IDC_EDT_PVC_User_Layer2))
            {
                NcMsgBox(hDlg, IDS_MSFT_UNI_TEXT, IDS_INVALID_Layer3_UserSpec,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                SetFocus(GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer3));
                err = TRUE;
            }
        }
    }

    //Layer3 IPI
    if (!err)
    {
        if (!IsValidDwordField(hDlg, IDC_EDT_PVC_Layer3_IPI))
        {
            NcMsgBox(hDlg, IDS_MSFT_UNI_TEXT, IDS_INVALID_Layer3_IPI,
             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            SetFocus(GetDlgItem(hDlg,IDC_EDT_PVC_Layer3_IPI));
            err = TRUE;
        }
    }

    // SnapId
    if (!IsValidBinaryField(hDlg, IDC_EDT_PVC_SNAP_ID, c_nSnapIdMaxBytes))
    {
        NcMsgBox(hDlg, IDS_MSFT_UNI_TEXT, IDS_INVALID_SnapId,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        SetFocus(GetDlgItem(hDlg, IDC_EDT_PVC_SNAP_ID));
        err = TRUE;
    }

    // High layer info
    if (!err)
    {
        if (!IsValidCmbSelection(hDlg, IDC_CMB_PVC_High_Type))
        {
            NcMsgBox(hDlg, IDS_MSFT_UNI_TEXT, IDS_INVALID_Highlayer_Type,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            SetFocus(GetDlgItem(hDlg,IDC_CMB_PVC_High_Type));

            err = TRUE;
        }
        else if ((!err) && (IsWindowEnabled(GetDlgItem(hDlg,IDC_CMB_PVC_High_Value))))
        {
            if (!IsValidBinaryField(hDlg, IDC_CMB_PVC_High_Value, c_nHighLayerInfoMaxBytes))
            {
                NcMsgBox(hDlg, IDS_MSFT_UNI_TEXT, IDS_INVALID_HighLayerValue,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                SetFocus(GetDlgItem(hDlg,IDC_CMB_PVC_High_Value));
                err = TRUE;
            }
        }
    }
    return err;
}

BOOL IsValidCmbSelection(HWND hDlg, int nIDDlgItemCombo)
{
    BOOL ret = TRUE;

    WCHAR szBuf[MAX_PATH];

    int nlen = GetDlgItemText(hDlg, nIDDlgItemCombo, szBuf, MAX_PATH);
    if (nlen > 0) // empty string is ok
    {
        int nIdx = SendDlgItemMessage(hDlg, nIDDlgItemCombo, CB_FINDSTRINGEXACT, -1,
                                      (LPARAM)(PCWSTR)szBuf);

        if (nIdx == CB_ERR) // any string in the selection is ok
        {
            DWORD dwProtocol;

            GetNumFromString(szBuf, &dwProtocol);

#pragma warning(push)
#pragma warning(disable:4296)
            if ((dwProtocol > c_dwFieldHigh) || (dwProtocol < c_dwFieldLow))
            {
                ret = FALSE;
            }
#pragma warning(pop)
        }
    }

    return ret;
}

BOOL IsValidDwordField(HWND hDlg, int nIDDlgItemEdit)
{
    BOOL ret = TRUE;

    DWORD dwValue;
    GetDwordEdtField(hDlg, &dwValue, nIDDlgItemEdit);

    if (FIELD_UNSET != dwValue) // empty field is ok
    {

#pragma warning(push)
#pragma warning(disable:4296)
        if ((dwValue > c_dwFieldHigh) || (dwValue < c_dwFieldLow))
        {
            ret = FALSE;
        }
#pragma warning(pop)
    }

    return ret;
}

BOOL IsValidBinaryField(HWND hDlg, int nIDDlgItemEdit, int nMaxBytes)
{
    BOOL ret = TRUE;

    WCHAR   szBuff[MAX_PATH];
    GetDlgItemText(hDlg, nIDDlgItemEdit, szBuff, celems(szBuff));

    //length
    int nlen = wcslen(szBuff);

    if (nlen % 2) // must be even number of hex digits
    {
        ret = FALSE;
    }
    else
    {
        if ((szBuff[0] == L'0') &&
            ((szBuff[1] == L'x') || (szBuff[1] == L'X')))
        {
            nlen -= 2;
        }

        if (nlen > nMaxBytes*2)
        {
            ret = FALSE;
        }
    }

    if (ret)
    {
        int i=0;
        nlen = wcslen(szBuff);
        if ((szBuff[0] == L'0') &&
            ((szBuff[1] == L'x') || (szBuff[1] == L'X')))
        {
            i = 2;
        }

        while (i<nlen)
        {
            if (((szBuff[i] >= L'0') && (szBuff[i] <= L'9')) ||
                ((szBuff[i] >= L'a') && (szBuff[i] <= L'f')) ||
                ((szBuff[i] >= L'A') && (szBuff[i] <= L'F')))
            {
                i++;
            }
            else
            {
                ret = FALSE;
                break;
            }
        }
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atlkcfg\atlkobj.cpp ===
// ATlkObj.cpp : Implementation of CATlkObj

#include "pch.h"
#pragma hdrstop
#include <atalkwsh.h>
#include "atlkobj.h"
#include "ncatlui.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "ncpnp.h"
#include "ncsvc.h"
#include <netconp.h>

extern const WCHAR c_szAdapterSections[];
//extern const WCHAR c_szAdapters[];
extern const WCHAR c_szBackslash[];
extern const WCHAR c_szDevice[];
extern const WCHAR c_szSpecificTo[];
extern const WCHAR c_szInfId_MS_NdisWanAtalk[];
extern const WCHAR c_szEmpty[];

// Registry Paths
static const WCHAR c_szAtlk[]                 = L"AppleTalk";
static const WCHAR c_szATLKParameters[]       = L"System\\CurrentControlSet\\Services\\AppleTalk\\Parameters";
static const WCHAR c_szATLKAdapters[]         = L"System\\CurrentControlSet\\Services\\AppleTalk\\Parameters\\Adapters";

// Values under the Adapter component's "Parameters" key
static const WCHAR c_szMediaType[]            = L"MediaType";  //$ REVIEW duplicate string

// Values under AppleTalk\Parameters
static const WCHAR c_szDefaultPort[]          = L"DefaultPort";  // REG_SZ
static const WCHAR c_szDesiredZone[]          = L"DesiredZone";  // REG_SZ
static const WCHAR c_szEnableRouter[]         = L"EnableRouter"; // REG_DWORD

// Values under AppleTalk\Parameters\Adapters\<AdapterId>
static const WCHAR c_szAarpRetries[]          = L"AarpRetries";         // REG_DWORD
static const WCHAR c_szDdpCheckSums[]         = L"DdpCheckSums";        // REG_DWORD
static const WCHAR c_szDefaultZone[]          = L"DefaultZone";         // REG_SZ
static const WCHAR c_szNetworkRangeLowerEnd[] = L"NetworkRangeLowerEnd";// REG_DWORD
static const WCHAR c_szNetworkRangeUpperEnd[] = L"NetworkRangeUpperEnd";// REG_DWORD
static const WCHAR c_szPortName[]             = L"PortName";            // REG_SZ
static const WCHAR c_szRouterPramNode[]       = L"RouterPramNode";      // REG_DWORD
static const WCHAR c_szSeedingNetwork[]       = L"SeedingNetwork";      // REG_DWORD
static const WCHAR c_szUserPramNode1[]        = L"UserPramNode1";       // REG_DWORD
static const WCHAR c_szUserPramNode2[]        = L"UserPramNode2";       // REG_DWORD
static const WCHAR c_szZoneList[]             = L"ZoneList";            // REG_MULTI_SZ

// Useful default constant
const WCHAR c_chAt                            = L'@';
static const WCHAR c_dwZero                   = 0L;
static const WCHAR c_dwTen                    = 10L;
//static const WCHAR c_szMacPrint[]             = L"MacPrint";


// Declare structure for reading/writing AppleTalk\Parameters values
static const REGBATCH regbatchATLKParams[]    = {
            {HKEY_LOCAL_MACHINE, c_szATLKParameters, c_szDefaultPort, REG_SZ,
             offsetof(ATLK_PARAMS,szDefaultPort), (BYTE *)&c_szEmpty},
            {HKEY_LOCAL_MACHINE, c_szATLKParameters, c_szDesiredZone, REG_SZ,
             offsetof(ATLK_PARAMS,szDesiredZone), (BYTE *)&c_szEmpty},
            {HKEY_LOCAL_MACHINE, c_szATLKParameters, c_szEnableRouter, REG_DWORD,
             offsetof(ATLK_PARAMS,dwEnableRouter), (BYTE *)&c_szEmpty}};

static const REGBATCH regbatchATLKAdapters[]  = {
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szAarpRetries, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwAarpRetries), (BYTE *)&c_dwTen},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szDdpCheckSums, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwDdpCheckSums), (BYTE *)&c_dwZero},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szNetworkRangeLowerEnd, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwNetworkRangeLowerEnd), (BYTE *)&c_dwZero},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szNetworkRangeUpperEnd, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwNetworkRangeUpperEnd), (BYTE *)&c_dwZero},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szRouterPramNode, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwRouterPramNode), (BYTE *)&c_dwZero},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szSeedingNetwork, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwSeedingNetwork), (BYTE *)&c_dwZero},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szUserPramNode1, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwUserPramNode1), (BYTE *)&c_dwZero},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szUserPramNode2, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwUserPramNode2), (BYTE *)&c_dwZero},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szMediaType, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwMediaType), (BYTE *)&c_dwZero},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szDefaultZone, REG_SZ,
             offsetof(ATLK_ADAPTER,m_szDefaultZone), (BYTE *)&c_szEmpty},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szPortName, REG_SZ,
             offsetof(ATLK_ADAPTER,m_szPortName), (BYTE *)&c_szEmpty}};

// Local utility functions
HRESULT HrQueryAdapterComponentInfo(INetCfgComponent *pncc,
                                    CAdapterInfo * pAI);

HRESULT HrPortNameFromAdapter(INetCfgComponent *pncc, tstring * pstr);

// Prototype from nwlnkcfg\nwlnkutl.h
HRESULT HrAnswerFileAdapterToPNCC(INetCfg *pnc, PCWSTR pszAdapterId,
                                  INetCfgComponent** ppncc);

//
// Function:    CATlkObj::CATlkObj
//
// Purpose:     ctor for the CATlkObj class
//
// Parameters:  none
//
// Returns:     none
//
CATlkObj::CATlkObj() : m_pNetCfg(NULL),
             m_pNCC(NULL),
             m_eInstallAction(eActUnknown),
             m_pspObj(NULL),
             m_pATLKEnv(NULL),
             m_pATLKEnv_PP(NULL),
             m_pUnkPropContext(NULL),
             m_nIdxAdapterSelected(CB_ERR),
             m_fAdapterListChanged(FALSE),
             m_fPropertyChange(FALSE),
             m_fFirstTimeInstall(FALSE)
{
}

//
// Function:    CATlkObj::CATlkObj
//
// Purpose:     dtor for the CATlkObj class
//
// Parameters:  none
//
// Returns:     none
//
CATlkObj::~CATlkObj()
{
    // Should always be cleaned up in advance of reach this dtor
    Assert(NULL == m_pATLKEnv_PP);

    ReleaseObj(m_pUnkPropContext);
    ReleaseObj(m_pNetCfg);
    ReleaseObj(m_pNCC);
    CleanupPropPages();
    delete m_pATLKEnv;
}


// INetCfgNotify
STDMETHODIMP CATlkObj::Initialize ( INetCfgComponent* pnccItem,
                                    INetCfg* pNetCfg, BOOL fInstalling )
{
    Validate_INetCfgNotify_Initialize(pnccItem, pNetCfg, fInstalling);

    ReleaseObj(m_pNCC);
    m_pNCC    = pnccItem;
    AddRefObj(m_pNCC);
    ReleaseObj(m_pNetCfg);
    m_pNetCfg = pNetCfg;
    AddRefObj(m_pNetCfg);
    m_fFirstTimeInstall = fInstalling;

    // Read the current configuration
    HRESULT hr = CATLKEnv::HrCreate(&m_pATLKEnv, this);

    TraceError("CATlkObj::Initialize",hr);
    return hr;
}

STDMETHODIMP CATlkObj::ReadAnswerFile(PCWSTR pszAnswerFile,
                    PCWSTR pszAnswerSection )
{
    Validate_INetCfgNotify_ReadAnswerFile(pszAnswerFile, pszAnswerSection );

    HRESULT hr = S_OK;

    m_eInstallAction = eActInstall;

    // Only process answer file and install sub-components if the answer file
    // is present.  If the answer file is not present we should already be installed.
    if (NULL != pszAnswerFile)
    {
        hr = HrProcessAnswerFile(pszAnswerFile, pszAnswerSection);
    }

    TraceError("CATlkObj::ReadAnswerFile",hr);
    return hr;
}

//
// Function:    CATlkObj::HrProcessAnswerFile
//
// Purpose:     Process the answer file information, merging
//              its contents into the internal information
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATlkObj::HrProcessAnswerFile(PCWSTR pszAnswerFile,
                                      PCWSTR pszAnswerSection)
{
    TraceFileFunc(ttidDefault);

    CSetupInfFile   csif;
    BOOL            fValue;
    HRESULT         hr = S_OK;
    INFCONTEXT      infctx;
    tstring         str;

    AssertSz(pszAnswerFile, "Answer file string is NULL!");
    AssertSz(pszAnswerSection, "Answer file sections string is NULL!");

    // Open the answer file.
    hr = csif.HrOpen(pszAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Read the property containing the list of adapter sections
    hr = ::HrSetupFindFirstLine(csif.Hinf(), pszAnswerSection,
                                c_szAdapterSections, &infctx);
    if (S_OK == hr)
    {
        DWORD dwIdx;
        DWORD dwCnt = SetupGetFieldCount(&infctx);

        // For each adapter in the list read the adapter information
        for (dwIdx=1; dwIdx <= dwCnt; dwIdx++)
        {
            hr = ::HrSetupGetStringField(infctx, dwIdx, &str);
            if (FAILED(hr))
            {
                TraceError("CATlkObj::HrProcessAnswerFile - Failed to read adapter section name",hr);
                break;
            }

            hr = HrReadAdapterAnswerFileSection(&csif, str.c_str());
            if (FAILED(hr))
            {
                goto Error;
            }
        }
    }

    TraceTag(ttidDefault, "***Appletalk processing default port***");

    // Read the default port property (REG_SZ)
    hr = csif.HrGetString(pszAnswerSection, c_szDefaultPort, &str);
    if (SUCCEEDED(hr))
    {
        tstring strNew = str;

        // If the \device\ prefix is present, strip it off
        //
        if (0 == _wcsnicmp(str.c_str(), c_szDevice, wcslen(c_szDevice)))
        {
            strNew = ((PWSTR)str.c_str()) + wcslen(c_szDevice);
            TraceTag(ttidDefault, "Removing the device prefix. Device=%S",strNew.c_str());
        }

        // Convert the Adapter0x to \Device\{bind-name}
        INetCfgComponent* pncc = NULL;
        hr = ::HrAnswerFileAdapterToPNCC(PNetCfg(), strNew.c_str(), &pncc);
        if (S_OK == hr)
        {
            PWSTR pszBindName;
            hr = pncc->GetBindName(&pszBindName);
            ReleaseObj(pncc);
            if (FAILED(hr))
            {
                goto Error;
            }

            str = c_szDevice;
            str += pszBindName;

            CoTaskMemFree(pszBindName);

            TraceTag(ttidDefault, "Port located and configured");
            m_pATLKEnv->SetDefaultPort(str.c_str());
        }
    }

    TraceTag(ttidDefault, "***Appletalk finished processing default port***");

    // Read the default zone property (REG_SZ)
    hr = csif.HrGetString(pszAnswerSection, c_szDesiredZone, &str);
    if (SUCCEEDED(hr))
    {
        m_pATLKEnv->SetDesiredZone(str.c_str());
    }

    // Read the EnableRouter property (DWORD used as a boolean)
    hr = csif.HrGetStringAsBool(pszAnswerSection, c_szEnableRouter, &fValue);
    if (SUCCEEDED(hr))
    {
        m_pATLKEnv->EnableRouting(fValue);
    }

    // Determine the best default port overriding the recorded default only
    // if the default port cannot be found
    m_pATLKEnv->InitDefaultPort();

    hr = S_OK;
    m_fPropertyChange = TRUE;

Error:
    TraceError("CATlkObj::HrProcessAnswerFile", hr);
    return hr;
}

//
// Function:    CATlkObj::HrReadAdapterAnswerFileSection
//
// Purpose:     Read the adapter answer file section and create
//              the adapter info section if successful
//
// Parameters:
//
// Returns:
//
HRESULT
CATlkObj::HrReadAdapterAnswerFileSection(CSetupInfFile * pcsif,
                                         PCWSTR pszSection)
{
    HRESULT           hr = S_OK;
    CAdapterInfo *    pAI = NULL;
    tstring           str;

    INetCfgComponent* pncc = NULL;

    // Read the SpecificTo adapter name
    hr = pcsif->HrGetString(pszSection, c_szSpecificTo, &str);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Search for the specified adapter in the set of existing adapters
    hr = ::HrAnswerFileAdapterToPNCC(PNetCfg(), str.c_str(), &pncc);
    if (FAILED(hr))
    {
        goto Error;
    }

    // if we found the adapter component object (pncc != NULL) process
    // the adapter section
    if (pncc)
    {
        DWORD       dwData;
        DWORD       dwDataUpper;
        INFCONTEXT  infctx;

        pAI = new CAdapterInfo();
        Assert(NULL != pAI);

        pAI->SetDirty(TRUE);

        // Get the adapter component info (media type, description, ...)
        hr = ::HrQueryAdapterComponentInfo(pncc, pAI);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Read the NetworkRangeUpperEnd
        hr = pcsif->HrGetDword(pszSection, c_szNetworkRangeUpperEnd, &dwDataUpper);
        if (FAILED(hr))
        {
            dwDataUpper = pAI->DwQueryNetRangeUpper();
            TraceTag(ttidDefault, "CATlkObj::HrReadAdapterAnswerFileSection - Defaulting property %S",c_szNetworkRangeUpperEnd);
        }

        // Read the NetworkRangeLowerEnd
        hr = pcsif->HrGetDword(pszSection, c_szNetworkRangeLowerEnd, &dwData);
        if (FAILED(hr))
        {
            dwData = pAI->DwQueryNetRangeLower();
            TraceTag(ttidDefault, "CATlkObj::HrReadAdapterAnswerFileSection - Defaulting property %S",c_szNetworkRangeLowerEnd);
        }

        pAI->SetAdapterNetRange(dwData, dwDataUpper);

        // Read the DefaultZone
        hr = pcsif->HrGetString(pszSection, c_szDefaultZone, &str);
        if (SUCCEEDED(hr))
        {
            pAI->SetDefaultZone(str.c_str());
        }

        // Read the SeedingNetwork
        hr = pcsif->HrGetDword(pszSection, c_szNetworkRangeLowerEnd, &dwData);
        if (SUCCEEDED(hr))
        {
            pAI->SetSeedingNetwork(!!dwData);
        }

        // Generate the PortName
        hr = ::HrPortNameFromAdapter(pncc, &str);
        if (FAILED(hr))
        {
            goto Error;
        }

        pAI->SetPortName(str.c_str());

        // Read the ZoneList
        hr = HrSetupFindFirstLine(pcsif->Hinf(), pszSection, c_szZoneList,
                                    &infctx);
        if (S_OK == hr)
        {
            DWORD dwIdx;
            DWORD dwCnt = SetupGetFieldCount(&infctx);

            // For each adapter in the list read the adapter information
            for (dwIdx=1; dwIdx <= dwCnt; dwIdx++)
            {
                hr = ::HrSetupGetStringField(infctx, dwIdx, &str);
                if (FAILED(hr))
                {
                    TraceError("CATlkObj::HrProcessAnswerFile - Failed to read adapter section name",hr);
                    goto Error;
                }

                if (!str.empty())
                {
                    pAI->LstpstrZoneList().push_back(new tstring(str));
                }
            }
        }

        pAI->SetDirty(TRUE);
        m_pATLKEnv->AdapterInfoList().push_back(pAI);
        MarkAdapterListChanged();
    }

    // Normalize any errors
    hr = S_OK;

Done:
    ReleaseObj(pncc);
    return hr;

Error:
    delete pAI;
    TraceError("CATlkObj::HrReadAdapterAnswerFileSection",hr);
    goto Done;
}

STDMETHODIMP CATlkObj::Install (DWORD)
{
    CAdapterInfo *  pAI;
    ATLK_ADAPTER_INFO_LIST::iterator iter;

    m_eInstallAction = eActInstall;

    // Mark all the initially detected adapters as dirty
    for (iter = m_pATLKEnv->AdapterInfoList().begin();
         iter != m_pATLKEnv->AdapterInfoList().end();
         iter++)
    {
        pAI = *iter;
        pAI->SetDirty(TRUE);
    }
    return S_OK;
}

STDMETHODIMP CATlkObj::Removing ()
{
    m_eInstallAction = eActRemove;
    return S_OK;
}

STDMETHODIMP CATlkObj::Validate ()
{
    return S_OK;
}

STDMETHODIMP CATlkObj::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP CATlkObj::ApplyRegistryChanges ()
{
    HRESULT hr = S_OK;

    // Have any changes been validated?
    switch(m_eInstallAction)
    {
    case eActInstall:
        hr = HrCommitInstall();
        if (SUCCEEDED(hr))
        {
            m_fFirstTimeInstall = FALSE;
            hr = HrAtlkReconfig();
        }
        break;
    case eActRemove:
        hr = HrCommitRemove();
        break;
    default:    // eActUnknown
        if (m_fAdapterListChanged || m_fPropertyChange)
        {
            // Update the registry if the adapter list changed
            Assert(NULL != m_pATLKEnv);
            hr = m_pATLKEnv->HrUpdateRegistry();
            if (SUCCEEDED(hr))
            {
                hr = HrAtlkReconfig();
            }
        }
        break;
    }

    TraceError("CATlkObj::ApplyRegistryChanges",hr);
    return hr;
}

// INetCfgProperties

STDMETHODIMP CATlkObj::SetContext(IUnknown * pUnk)
{
    ReleaseObj(m_pUnkPropContext);
    m_pUnkPropContext = pUnk;
    if (m_pUnkPropContext)
    {
        AddRefObj(m_pUnkPropContext);
    }

    return S_OK;
}

STDMETHODIMP CATlkObj::MergePropPages (
    IN OUT DWORD* pdwDefPages,
    OUT LPBYTE* pahpspPrivate,
    OUT UINT* pcPages,
    IN HWND hwndParent,
    OUT PCWSTR* pszStartPage)
{
    Validate_INetCfgProperties_MergePropPages (
        pdwDefPages, pahpspPrivate, pcPages, hwndParent, pszStartPage);

    HRESULT         hr = S_OK;
    HPROPSHEETPAGE *ahpsp = NULL;
    CAdapterInfo *  pAI = NULL;

    Assert(pahpspPrivate);
    Assert(NULL == *pahpspPrivate);    // Out param init done via Validate above
    *pcPages = 0;
    Assert(NULL != m_pATLKEnv);

    if (NULL != m_pATLKEnv_PP)
    {
        TraceError("CATlkObj::MergePropPages - multiple property page instances requested.", hr);
        return E_UNEXPECTED;
    }

    // AppleTalk requires "complete" installation before property changes are
    // allowed.  If we've just installed but Apply has not yet been pressed,
    // disallow property page display
    if (m_fFirstTimeInstall)
    {
        NcMsgBox(::GetFocus(), IDS_ATLK_CAPTION, IDS_ATLK_INSTALL_PENDING,
                 MB_OK | MB_ICONEXCLAMATION);
        return S_FALSE;
    }

    // Start with new property pages each time.
    CleanupPropPages();

    // Locate the adapter referenced in the connection we stashed away
    if (NULL != m_pUnkPropContext)
    {
        INetLanConnectionUiInfo * pLanConn = NULL;
        ATLK_ADAPTER_INFO_LIST::iterator iter;

        hr = m_pUnkPropContext->QueryInterface(IID_INetLanConnectionUiInfo,
                                               reinterpret_cast<LPVOID *>(&pLanConn));
        if (S_OK == hr)
        {
            GUID guid;
            hr = pLanConn->GetDeviceGuid(&guid);
            ReleaseObj(pLanConn);
            if (SUCCEEDED(hr))
            {
                // Find the adapter in our adapter list
                for (iter = m_pATLKEnv->AdapterInfoList().begin();
                     iter != m_pATLKEnv->AdapterInfoList().end();
                     iter++)
                {
                    CAdapterInfo * pAITmp = *iter;

                    if (guid == *pAITmp->PInstanceGuid())
                    {
                        // Copy the adapter data
                        hr = pAITmp->HrCopy(&pAI);
                        break;
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            // If no adapter in this connection or it's
            // disabled/hidden/deleted we show no pages
            if ((NULL == pAI) || pAI->FDeletePending() ||
                pAI->FDisabled() || pAI->FHidden())
            {
                Assert(0 == *pcPages);
                hr = S_FALSE;
                goto cleanup;
            }
        }
    }
    else
    {
        // m_pUnkPropContext should have been set first
        hr = E_UNEXPECTED;
    }

    if (FAILED(hr))
    {
        goto Error;
    }

    // Create a copy of the enviroment for property page usage
    hr = m_pATLKEnv->HrCopy(&m_pATLKEnv_PP);
    if (FAILED(hr))
    {
        goto Error;
    }

    Assert(NULL != m_pATLKEnv_PP);
    Assert(NULL != pAI);

    // Query the zonelist every time, only for non-Seeding adapters.
    if (!pAI->FSeedingNetwork() || !m_pATLKEnv_PP->FRoutingEnabled())
    {
        (void) m_pATLKEnv->HrGetAppleTalkInfoFromNetwork(pAI);
    }

    // Add the adapter to the property sheet's list
    m_pATLKEnv_PP->AdapterInfoList().push_back(pAI);

    // Allocate the CPropSheetPage object for the "General" page
    m_pspObj = new CATLKGeneralDlg(this, m_pATLKEnv_PP);

    // Allocate a buffer large enough to hold the handle to the Appletalk config.
    // property page.
    ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE));
    if (!ahpsp)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;       // Alloc failed to no need to free ahpsp
    }

    // Create the actual PROPSHEETPAGE for each object.
    ahpsp[0] = m_pspObj->CreatePage(DLG_ATLK_GENERAL, 0);

    // Validate what we've created
    if (NULL == ahpsp[0])
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }
    else
    {
        *pahpspPrivate = (LPBYTE)ahpsp;
        *pcPages = 1;
    }

cleanup:
    TraceError("CATlkObj::MergePropPages", hr);
    return hr;

Error:
    CoTaskMemFree(ahpsp);
    delete m_pATLKEnv_PP;
    m_pATLKEnv_PP = NULL;
    goto cleanup;
}

//
// Function:    CATlkObj::CleanupPropPages
//
// Purpose:
//
// Parameters:
//
// Returns:     nothing
//
VOID CATlkObj::CleanupPropPages()
{
    delete m_pspObj;
    m_pspObj = NULL;
}

//
// Function:    CATlkObj::ValidateProperties
//
// Purpose:
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//
STDMETHODIMP CATlkObj::ValidateProperties (HWND)
{
    return S_OK;
}

//
// Function:    CATlkObj::CancelProperties
//
// Purpose:
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//
STDMETHODIMP CATlkObj::CancelProperties ()
{
    // Discard any changes made via the property pages
    delete m_pATLKEnv_PP;
    m_pATLKEnv_PP = NULL;
    return S_OK;
}

//
// Function:    CATlkObj::ApplyProperties
//
// Purpose:
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//
STDMETHODIMP CATlkObj::ApplyProperties ()
{
    // Extract the adapter info from the property sheet's
    // enviroment block
    Assert(!m_pATLKEnv_PP->AdapterInfoList().empty());
    CAdapterInfo * pAICurrent = m_pATLKEnv_PP->AdapterInfoList().front();
    m_pATLKEnv_PP->AdapterInfoList().pop_front();
    Assert(NULL != pAICurrent);

    // Remove the current adapter from the original enviroment
    CAdapterInfo * pAI;
    ATLK_ADAPTER_INFO_LIST::iterator iter;
    for (iter = m_pATLKEnv->AdapterInfoList().begin();
         iter != m_pATLKEnv->AdapterInfoList().end();
         iter++)
    {
        pAI = *iter;
        if (0 == _wcsicmp(pAI->SzBindName(), pAICurrent->SzBindName()))
        {
            m_pATLKEnv->AdapterInfoList().erase(iter, iter);
            break;
        }
    }

    // Add pAICurrent to the base enviroment block
    m_pATLKEnv->AdapterInfoList().push_back(pAICurrent);

    // Update the base enviroment from the property sheet's enviroment
    m_pATLKEnv->SetDefaultMediaType(m_pATLKEnv_PP->DwDefaultAdaptersMediaType());
    m_pATLKEnv->EnableRouting(m_pATLKEnv_PP->FRoutingEnabled());
    m_pATLKEnv->SetDefaultPort(m_pATLKEnv_PP->SzDefaultPort());
    m_pATLKEnv->SetDesiredZone(m_pATLKEnv_PP->SzDesiredZone());
    m_pATLKEnv->SetRouterChanged(m_pATLKEnv_PP->FRouterChanged());
    m_pATLKEnv->SetDefAdapterChanged(m_pATLKEnv_PP->FDefAdapterChanged());

    // Delete the property pages enviroment block
    delete m_pATLKEnv_PP;
    m_pATLKEnv_PP = NULL;

    // Properties changed
    m_fPropertyChange = TRUE;
    return S_OK;
}


// INetCfgBindNotify

STDMETHODIMP
CATlkObj::QueryBindingPath (
    DWORD dwChangeFlag,
    INetCfgBindingPath* pncbpItem )
{
    Validate_INetCfgBindNotify_QueryBindingPath( dwChangeFlag, pncbpItem );
    return S_OK;
}

STDMETHODIMP
CATlkObj::NotifyBindingPath (
    DWORD dwChangeFlag,
    INetCfgBindingPath* pncbpItem )
{
    HRESULT hr = S_OK;
    INetCfgComponent *pnccFound = NULL;

    Validate_INetCfgBindNotify_NotifyBindingPath( dwChangeFlag, pncbpItem );

    Assert(NULL != m_pATLKEnv);

    // Only Interested in lower binding Add's and Remove's
    if (dwChangeFlag & (NCN_ADD | NCN_REMOVE | NCN_ENABLE | NCN_DISABLE))
    {
        CIterNetCfgBindingInterface ncbiIter(pncbpItem);
        INetCfgBindingInterface *pncbi;

        // Enumerate the binding interfaces looking for the last Adapter
        while (SUCCEEDED(hr) &&
               (S_OK == (hr = ncbiIter.HrNext (&pncbi))))
        {
            INetCfgComponent *pncc;

            hr = pncbi->GetLowerComponent(&pncc);
            if (S_OK == hr)
            {
                GUID guidClass;
                hr = pncc->GetClassGuid(&guidClass);
                if ((S_OK == hr) && (GUID_DEVCLASS_NET == guidClass))
                {
                    ULONG ulStatus = 0;
                    hr = pncc->GetDeviceStatus(&ulStatus);

                    if(S_OK == hr)
                    {
                        ReleaseObj(pnccFound);
                        pnccFound = pncc;   // Transfer Ownership
                        pncc = NULL;
                    }
                    else
                    {
                        ReleaseObj(pncc);
                    }
                }
                else
                {
                    ReleaseObj(pncc);
                }
            }

            ReleaseObj(pncbi);
        }

        if (FAILED(hr))
        {
            goto Error;
        }

        // Did we find the Adapter?
        if (pnccFound)
        {
            BOOL                             fFound = FALSE;
            PWSTR                           pszBindName = NULL;
            CAdapterInfo *                   pAI;
            ATLK_ADAPTER_INFO_LIST::iterator iterAdapterInfo;

            Assert(NULL != m_pATLKEnv);
            ATLK_ADAPTER_INFO_LIST pAI_List = m_pATLKEnv->AdapterInfoList();

            hr = pnccFound->GetBindName(&pszBindName);
            if (S_OK != hr)
            {
                goto Error;
            }

            // Search the adapter list
            for (iterAdapterInfo = pAI_List.begin();
                 iterAdapterInfo != pAI_List.end();
                 iterAdapterInfo++)
            {
                pAI = *iterAdapterInfo;
                if (0 == lstrcmpiW(pszBindName, pAI->SzBindName()))
                {
                    fFound = TRUE;
                    break;
                }
            }

            Assert(NULL != pszBindName);
            CoTaskMemFree(pszBindName);

            // Apply the appropriate delta to the adapter list
            if (fFound && (dwChangeFlag & NCN_REMOVE))
            {
                // Delete the adapter from the list
                pAI->SetDeletePending(TRUE);
                m_fAdapterListChanged = TRUE;
            }
            else if (!fFound && (dwChangeFlag & NCN_ADD))
            {
                // Add the adapter to the list
                hr = m_pATLKEnv->HrAddAdapter(pnccFound);
                m_fAdapterListChanged = TRUE;
            }
            else if (fFound && (dwChangeFlag & NCN_ADD))
            {
                // Re-enable the adapters existance
                pAI->SetDeletePending(FALSE);
            }

            if (fFound)
            {
                if (dwChangeFlag & NCN_ENABLE)
                {
                    pAI->SetDisabled(FALSE);
                    m_fAdapterListChanged = TRUE;
                }
                else if (dwChangeFlag & NCN_DISABLE)
                {
                    pAI->SetDisabled(TRUE);
                    m_fAdapterListChanged = TRUE;
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = S_OK;      // Normalize return value
        }
    }

Error:
    ::ReleaseObj(pnccFound);
    TraceError("CATlkObj::NotifyBindingPath",hr);
    return hr;
}

//
// Function:    CATlkObj::HrCommitInstall
//
// Purpose:     Commit Installation registry changes to the registry
//
// Parameters:  None
//
// Returns:     HRESULT, S_OK on success
//
//
HRESULT CATlkObj::HrCommitInstall()
{
    HRESULT hr;

    Assert(NULL != m_pATLKEnv);
    hr = m_pATLKEnv->HrUpdateRegistry();

    TraceError("CATlkObj::HrCommitInstall",hr);
    return hr;
}

//
// Function:    CATlkObj::HrCommitRemove
//
// Purpose:     Remove from the registry settings which were created by this
//              component's installation.
//
// Parameters:  None
//
// Returns:     HRESULT, S_OK on success
//
//
HRESULT CATlkObj::HrCommitRemove()
{
    // Everything is removed via the inf file presently
    return S_OK;
}

//
// Function:    CATLKEnv::HrCreate
//
// Purpose:     Construct the AppleTalk Enviroment tracking object
//
// Paramaters:  ppATLKEnv [out] - AppleTalk Enviroment Object created
//              pmsc       [in] - AppleTalk notification object
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrCreate(CATLKEnv **ppATLKEnv, CATlkObj *pmsc)
{
    HRESULT hr = S_OK;
    CATLKEnv *pATLKEnv = NULL;

    *ppATLKEnv = NULL;

    // Construct the new enviroment object
    pATLKEnv = new CATLKEnv(pmsc);

	if (pATLKEnv == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    // Read AppleTalk Info
    hr = pATLKEnv->HrReadAppleTalkInfo();
    if (FAILED(hr))
    {
        goto Error;
    }

    *ppATLKEnv = pATLKEnv;

Done:
    return hr;

Error:
    TraceError("CATLKEnv::HrCreate",hr);
    delete pATLKEnv;
    goto Done;
}

//
// Function:    CATLKEnv::CATLKEnv
//
// Purpose:     ctor for the CATLKEnv class
//
// Parameters:  none
//
// Returns:     none
//
CATLKEnv::CATLKEnv(CATlkObj *pmsc) :
            m_pmsc(pmsc),
            m_fATrunning(FALSE),
            m_dwDefaultAdaptersMediaType(MEDIATYPE_ETHERNET),
            m_fRouterChanged(FALSE),
            m_fDefAdapterChanged(FALSE)
{
    ZeroMemory(&m_Params, sizeof(m_Params));
}

//
// Function:    CATLKEnv::~CATLKEnv
//
// Purpose:     dtor for the CATLKEnv class
//
// Parameters:  none
//
// Returns:     none
//
CATLKEnv::~CATLKEnv()
{
    // Cleanup the AppleTalk\Parameters internal data structure
    delete [] m_Params.szDefaultPort;
    delete [] m_Params.szDesiredZone;

    // Cleanup the contents of the Adapter Info List
    while (!m_lstpAdapters.empty())
    {
        delete m_lstpAdapters.front();
        m_lstpAdapters.pop_front();
    }
}

//
// Function:    CATLKEnv::HrCopy
//
// Purpose:     Creates a copy of the current Enviroment
//
// Parameters:  ppEnv [out] - If the function succeeds, ppEnv will contain a
//                            copy of the enviroment.
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrCopy(CATLKEnv **ppEnv)
{
    HRESULT hr = S_OK;
    CATLKEnv * pEnv;

    // Allocate a new enviroment object
    *ppEnv = NULL;
    pEnv = new CATLKEnv(m_pmsc);
    if (NULL != pEnv)
    {
        // Copy the members
        pEnv->m_fATrunning = m_fATrunning;
        pEnv->SetDefaultMediaType(DwDefaultAdaptersMediaType());
        pEnv->EnableRouting(FRoutingEnabled());
        pEnv->SetDefaultPort(SzDefaultPort());
        pEnv->SetDesiredZone(SzDesiredZone());
        pEnv->SetRouterChanged(FRouterChanged());
        pEnv->SetDefAdapterChanged(FDefAdapterChanged());

        *ppEnv = pEnv;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceError("CATLKEnv::HrCopy",hr);
    return S_OK;
}

//
// Function:    CATLKEnv::HrReadAppleTalkInfo
//
// Purpose:     Retrieve the AppleTalk registry Settings
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrReadAppleTalkInfo()
{
    HRESULT hr;

    // Read the AppleTalk\Parameters values
    RegReadValues(celems(regbatchATLKParams), regbatchATLKParams,
                  (BYTE *)&m_Params, KEY_READ);

    // Read info for each adapter listed under AppleTalk\Parameters\Adapters
    hr = HrGetAdapterInfo();

    TraceError("CATLKEnv::HrReadAppleTalkInfo",hr);
    return hr;
}

//
// Function:    CATLKEnv::HrGetOneAdaptersInfo
//
// Purpose:     Retrieve the AppleTalk Adapter information for one adapter
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrGetOneAdaptersInfo(INetCfgComponent* pncc,
                                       CAdapterInfo **ppAI)
{
    HKEY            hkeyAdapterRoot = NULL;
    HKEY            hkeyAdapter = NULL;
    HRESULT         hr;
    INT             idx;
    CAdapterInfo *  pAI = NULL;
    REGBATCH        regbatch;
    tstring         strKey;
    tstring         strKeyPath = c_szATLKAdapters;

    *ppAI = NULL;

    // Construct the adapter info object
    pAI = new CAdapterInfo;

	if (pAI == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    // Get the adapter component info (media type, description, ...)
    hr = ::HrQueryAdapterComponentInfo(pncc, pAI);
    if (FAILED(hr))
    {
        goto Error;
    }

    hr = ::HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, strKeyPath.c_str(),
                          KEY_READ, &hkeyAdapterRoot);
    if (S_OK == hr)
    {
        strKey = pAI->SzBindName();

        // Try to open the key for this specific adapter
        hr = ::HrRegOpenKeyEx(hkeyAdapterRoot, pAI->SzBindName(),
                              KEY_READ, &hkeyAdapter);
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            // We weren't able to find this in the registry, write it out
            // when we can (self repair)
            pAI->SetDirty(TRUE);
        }

        strKeyPath += c_szBackslash;
        strKeyPath += strKey.c_str();

        // If we located the key query the data
        if (S_OK == hr)
        {
            hr = HrRegQueryColString(hkeyAdapter, c_szZoneList,
                    &pAI->LstpstrZoneList());

            // Since CAdapterInfo defaults allocations, need to free
            // them before RegReadValues writes over them and causes a leak.
            //
            delete [] pAI->m_AdapterInfo.m_szDefaultZone;
            delete [] pAI->m_AdapterInfo.m_szPortName;
            pAI->m_AdapterInfo.m_szDefaultZone = NULL;
            pAI->m_AdapterInfo.m_szPortName = NULL;

            // Read the adapter information
            for (idx=0; idx<celems(regbatchATLKAdapters); idx++)
            {
                regbatch = regbatchATLKAdapters[idx];
                regbatch.pszSubkey = strKeyPath.c_str();

                RegReadValues(1, &regbatch, (BYTE *)pAI->PAdapterInfo(), KEY_READ);
            }
        }
    }

    if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr))
    {
        // Something other than a "not found" error
        goto Error;
    }

    // Normalize return value
    hr = S_OK;

    // If the port name was not found then generate one
    if (0 == wcslen(pAI->SzPortName()))
    {
        tstring str;
        hr = ::HrPortNameFromAdapter(pncc, &str);
        if (FAILED(hr))
        {
            goto Error;
        }

        pAI->SetPortName(str.c_str());
    }

    // Set the return value
    *ppAI = pAI;

Done:
    ::RegSafeCloseKey(hkeyAdapter);
    ::RegSafeCloseKey(hkeyAdapterRoot);
    return hr;

Error:
    TraceError("CATLKEnv::HrGetOneAdaptersInfo",hr);
    delete pAI;
    goto Done;
}

//
// Function:    CATLKEnv::HrGetAdapterInfo
//
// Purpose:     Retrieve the AppleTalk Adapter information
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrGetAdapterInfo()
{
    HRESULT           hr = S_OK;
    CAdapterInfo *    pAI = NULL;
    INetCfgComponent* pncc = NULL;
    INetCfgComponent* pnccUse = NULL;

    // Find each netcard, to do so, trace the bindings to their end
    // If the endpoint is a netcard then add it to the list
    CIterNetCfgBindingPath ncbpIter(m_pmsc->PNCComponent());
    INetCfgBindingPath*    pncbp;

    while (SUCCEEDED(hr) &&
           (S_OK == (hr = ncbpIter.HrNext (&pncbp))))
    {
        // Iterate the binding interfaces of this path.
        CIterNetCfgBindingInterface ncbiIter(pncbp);
        INetCfgBindingInterface* pncbi;

        while (SUCCEEDED(hr) &&
               (S_OK == (hr = ncbiIter.HrNext (&pncbi))))
        {
            // Retrieve the lower component
            hr = pncbi->GetLowerComponent(&pncc);
            if (S_OK == hr)
            {
                GUID guidClass;

                // Is it an Adapter?
                hr = pncc->GetClassGuid(&guidClass);
                if ((S_OK == hr) && (guidClass == GUID_DEVCLASS_NET))
                {
                    ULONG ulStatus = 0;
                    hr = pncc->GetDeviceStatus(&ulStatus);
                    if(SUCCEEDED(hr))
                    {
                        ReleaseObj(pnccUse);
                        pnccUse = pncc;
                        pncc = NULL;
                    }
                    else
                    {
                        // Release the lower component
                        ReleaseObj(pncc);
                        hr = S_OK;
                        break;
                    }
                }
                else
                {
                    // Release the lower component
                    ReleaseObj(pncc);
                }
            }

            // Release the binding interface
            ReleaseObj (pncbi);
        }

        if (NULL != pnccUse)
        {
            // Query the Adapter information
            hr = HrGetOneAdaptersInfo(pnccUse, &pAI);
            if (SUCCEEDED(hr))
            {
                if (S_FALSE == pncbp->IsEnabled())
                {
                    pAI->SetDisabled(TRUE);
                }

                // Add this Adapter to the list
                m_lstpAdapters.push_back(pAI);
            }

            ReleaseObj(pnccUse);
            pnccUse = NULL;
        }

        // Release the binding path
        ReleaseObj (pncbp);
    }

    if (FAILED(hr))
    {
        goto Error;
    }

    // Initialize the default port, etc
    InitDefaultPort();

    // Normalize the HRESULT.  (i.e. don't return S_FALSE)
    hr = S_OK;

Error:
    TraceError("CATLKEnv::HrGetAdapterInfo",hr);
    return hr;
}

//
// Function:    CATLKEnv::HrGetAppleTalkInfoFromNetwork
//
// Purpose:     ???
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrGetAppleTalkInfoFromNetwork(CAdapterInfo * pAI)
{
    SOCKADDR_AT    address;
    HRESULT        hr = S_FALSE;
    BOOL           fWSInitialized = FALSE;
    SOCKET         mysocket = INVALID_SOCKET;
    WSADATA        wsadata;
    DWORD          wsaerr = 0;
    tstring        strPortName;

    // Create the socket/bind
    wsaerr = WSAStartup(0x0101, &wsadata);
    if (0 != wsaerr)
    {
        goto Error;
    }

    // Winsock successfully initialized
    fWSInitialized = TRUE;

    mysocket = socket(AF_APPLETALK, SOCK_DGRAM, DDPPROTO_ZIP);
    if (INVALID_SOCKET == mysocket)
    {
        goto Error;
    }

    address.sat_family = AF_APPLETALK;
    address.sat_net = 0;
    address.sat_node = 0;
    address.sat_socket = 0;

    wsaerr = bind(mysocket, (struct sockaddr *)&address, sizeof(address));
    if (wsaerr != 0)
    {
        goto Error;
    }

    // Mark AppleTalk as running
    SetATLKRunning(TRUE);

    // For each known adapter, create a device name by merging the "\\device\\"
    // prefix and the adapter's bind name.
    strPortName = c_szDevice;
    strPortName += pAI->SzBindName();

    // Failures from query the zone list for a given adapter can be from
    // the adapter not connected to the network, zone seeder not running, etc.
    // Because we want to process all the adapters, we ignore these errors.
    (void)pAI->HrGetAndSetNetworkInformation(mysocket,strPortName.c_str());

    // Success, or at least not a critical failure
    hr = S_OK;

Done:
    if (INVALID_SOCKET != mysocket)
    {
        closesocket(mysocket);
    }

    if (fWSInitialized)
    {
        WSACleanup();
    }

    TraceError("CATLKEnv::HrGetAppleTalkInfoFromNetwork",(S_FALSE == hr ? S_OK : hr));
    return hr;

Error:
    wsaerr = ::WSAGetLastError();
    goto Done;
}

//
// Function:    CATLKEnv::HrAddAdapter
//
// Purpose:     Add and adapter to the list of currently bound adapters
//
// Parameters:  pnccFound - Notification object for the bound adapter to add
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrAddAdapter(INetCfgComponent * pnccFound)
{
    HRESULT        hr;
    CAdapterInfo * pAI = NULL;

    Assert(NULL != pnccFound);

    // Create an AdapterInfo instance for the adapter
    hr = HrGetOneAdaptersInfo(pnccFound, &pAI);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Add this Adapter to the list
    m_lstpAdapters.push_back(pAI);
    pAI->SetDirty(TRUE);

    // If there is now only one adapter in the list, update the defaults
    if (1 == m_lstpAdapters.size())
    {
        tstring str;
        str = c_szDevice;
        str += m_lstpAdapters.front()->SzBindName();
        SetDefaultPort(str.c_str());
        SetDefaultMediaType(m_lstpAdapters.front()->DwMediaType());
    }

Error:
    TraceError("CATLKEnv::HrAddAdapter",hr);
    return hr;
}

//
// Function:    CATLKEnv::SetDefaultPort
//
// Purpose:     Change the default port name
//
// Parameters:  psz [in] - The new default port name
//
// Returns:     HRESULT, S_OK on success
//
void CATLKEnv::SetDefaultPort(PCWSTR psz)
{
    Assert(psz);
    delete [] m_Params.szDefaultPort;
    m_Params.szDefaultPort = new WCHAR[wcslen(psz)+1];
    wcscpy(m_Params.szDefaultPort, psz);
}

//
// Function:    CATLKEnv::SetDesiredZone
//
// Purpose:     Change the desired zone
//
// Parameters:  sz [in] - The new desired zone
//
// Returns:     HRESULT, S_OK on success
//
void CATLKEnv::SetDesiredZone(PCWSTR psz)
{
    Assert(psz);
    delete [] m_Params.szDesiredZone;
    m_Params.szDesiredZone = new WCHAR[wcslen(psz)+1];
    wcscpy(m_Params.szDesiredZone, psz);
}

CAdapterInfo * CATLKEnv::PAIFindDefaultPort()
{
    CAdapterInfo *                   pAI = NULL;
    ATLK_ADAPTER_INFO_LIST::iterator iter;

    // Find the default port
    //
    for (iter = m_lstpAdapters.begin();
         iter != m_lstpAdapters.end();
         iter++)
    {
        tstring        strPortName;

        pAI = *iter;

        // Retain adapter selection as the default port
        strPortName = c_szDevice;
        strPortName += pAI->SzBindName();

        if (pAI->FDeletePending() || pAI->FDisabled() || pAI->FHidden() ||
            pAI->IsRasAdapter())
        {
            continue;
        }

        if (0 == _wcsicmp(SzDefaultPort(), strPortName.c_str()))
        {
            return pAI;
        }
    }

    return NULL;
}

//
// Function:    CATLKEnv::HrUpdateRegistry
//
// Purpose:     Write the AppleTalk local (internal) data back to the registry
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrUpdateRegistry()
{
    HRESULT        hr = S_OK;
    CAdapterInfo * pAI = NULL;
    HKEY           hkeyAdapter;
    DWORD          dwDisposition;
    ATLK_ADAPTER_INFO_LIST::iterator iter;

    // If the current default port is unavailable, find an alternate
    pAI = PAIFindDefaultPort();
    if (NULL == pAI)
    {
        InitDefaultPort();
        pAI = PAIFindDefaultPort();
    }

    // If the default adapter changed then three specific values for that
    //  adapter need to be reset to zero.
    //
    if (pAI && FDefAdapterChanged())
    {
        pAI->ZeroSpecialParams();
        pAI->SetDirty(TRUE);
    }

    // Commit the registry changes
    hr = ::HrRegWriteValues(celems(regbatchATLKParams), regbatchATLKParams,
                            (BYTE *)&m_Params, REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS);
    if (S_OK != hr)
    {
        goto Error;
    }

    // Create the Adapters key AppleTalk\Parameters\Adapters)
    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szATLKAdapters,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                             &hkeyAdapter, &dwDisposition);
    if (S_OK == hr)
    {
        // Enumerate the bound adapters and write the internal adapter list
        for (iter = m_lstpAdapters.begin();
             (iter != m_lstpAdapters.end()) && (SUCCEEDED(hr));
             iter++)
        {
            pAI = *iter;

            if (pAI->FDeletePending())
            {
                // Remove the AppleTalk\Adapter\{bindname} tree
                hr = ::HrRegDeleteKeyTree(hkeyAdapter, pAI->SzBindName());
                if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr))
                {
                    goto Error;
                }
            }
            else if (pAI->IsDirty())
            {
                hr = HrWriteOneAdapter(pAI);
            }
        }

        RegCloseKey (hkeyAdapter);
    }

Error:
    TraceError("CATLKEnv::HrUpdateRegistry",hr);
    return hr;
}

//
// Function:    CATLKEnv::HrWriteOneAdapter
//
// Purpose:     Write one adapter instance to the registry
//
// Parameters:  pAI [in] - The adapter to presist in the registry
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrWriteOneAdapter(CAdapterInfo *pAI)
{
    DWORD    dwDisposition;
    HKEY     hkeyAdapter = NULL;
    HRESULT  hr;
    INT      idx;
    REGBATCH regbatch;
    tstring  str;

    str = c_szATLKAdapters;
    str += c_szBackslash;
    str += pAI->SzBindName();

    // Create the key described in str (AppleTalk\Parameters\Adapters\<adapter>)
    hr = ::HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, str.c_str(),
                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                            &hkeyAdapter, &dwDisposition);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Write out the adapter parameters
    for (idx = 0; idx < celems(regbatchATLKAdapters); idx++)
    {
        regbatch = regbatchATLKAdapters[idx];
        regbatch.pszSubkey = str.c_str();

        hr = ::HrRegWriteValues(1, &regbatch, (BYTE *)pAI->PAdapterInfo(),
                                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS);
        if (FAILED(hr))
        {
            goto Error;
        }
    }

    // Write out the zone list multi-sz (managed seperately)
    hr = ::HrRegSetColString(hkeyAdapter, c_szZoneList, pAI->LstpstrZoneList());

Error:
    ::RegSafeCloseKey(hkeyAdapter);
    TraceError("CATLKEnv::HrWriteOneAdapter",hr);
    return S_OK;
}

//
// Function:    CATLKEnv::DwMediaPriority
//
// Purpose:     When determining the appropriate adapter for use as the
//              "DefaultPort" certain mediatype's are faster.  So all
//              other things being equal, selecting a faster mediatype
//              benefits the user the most.
//
// Parameters:  dwMediaType [in] - MediaType used to determine priority ranking
//
// Returns:     DWORD, value (1-5) with the lowest value representing the
//                                 highest priority.
//
DWORD CATLKEnv::DwMediaPriority(DWORD dwMediaType)
{
    switch(dwMediaType)
    {
        case MEDIATYPE_ETHERNET:
            return 2;
        case MEDIATYPE_TOKENRING:
            return 3;
        case MEDIATYPE_FDDI:
            return 1;
        case MEDIATYPE_LOCALTALK:
            return 4;
        default:
            return 5;
    }
}

//
// Function:    CATLKEnv::InitDefaultPort
//
// Purpose:     Select a default port if none yet has been selected.  Retain
//              some select information for assisting in dialog display issues.
//
// Parameters:  none
//
// Returns:     nothing
//
void CATLKEnv::InitDefaultPort()
{
    CAdapterInfo * pAI = NULL;
    tstring        str;

    ATLK_ADAPTER_INFO_LIST::iterator iter;

    // If DefaultPort is set, does the associated adapter exist?
    if (wcslen(SzDefaultPort()))
    {
        // Search for the adapter in the list
        for (iter = AdapterInfoList().begin();
             iter != AdapterInfoList().end();
             iter++)
        {
            pAI = *iter;

            if (pAI->FDeletePending() || pAI->FDisabled() || pAI->FHidden() ||
                pAI->IsRasAdapter())
            {
                pAI = NULL;
                continue;
            }

            str = c_szDevice;
            str += pAI->SzBindName();
            if (0 == wcscmp(str.c_str(), SzDefaultPort()))
            {
                break;
            }

            pAI = NULL;
        }
    }

    // If DefaultPort is not set locate the best candidate
    if (NULL == pAI)
    {
        CAdapterInfo * pAIBest = NULL;
        SetDefaultPort(c_szEmpty);

        // Search through the adapter list for the adapter
        // with the fastest media type.
        for (iter = AdapterInfoList().begin();
             iter != AdapterInfoList().end();
             iter++)
        {
            pAI = *iter;

            if (pAI->FDeletePending() || pAI->FDisabled() || pAI->FHidden() ||
                pAI->IsRasAdapter())
            {
                continue;
            }

            if ((NULL == pAIBest) ||
                (DwMediaPriority(pAIBest->DwMediaType()) >
                 DwMediaPriority(pAI->DwMediaType())))
            {
                SetDefAdapterChanged(TRUE);
                pAIBest = pAI;
            }
        }

        pAI = pAIBest;
    }

    if (NULL != pAI)
    {
        // retain the selected adapter as the default port
        str = c_szDevice;
        str += pAI->SzBindName();
        SetDefaultPort(str.c_str());

        // retain the default media type
        SetDefaultMediaType(pAI->DwMediaType());
    }
    else
    {
        SetDefaultPort(c_szEmpty);
    }
}

//
// Function:    CAdapterInfo::CAdapterInfo
//
// Purpose:     ctor for the CAdapters class
//
// Parameters:  none
//
// Returns:     nothing
//
CAdapterInfo::CAdapterInfo() :
    m_fDeletePending(FALSE),
    m_fDisabled(FALSE),
    m_fDirty(FALSE),
    m_fRasAdapter(FALSE),
    m_fRouterOnNetwork(FALSE),
    m_fZoneListValid(FALSE),
    m_dwNetworkUpper(0),
    m_dwNetworkLower(0),
    m_dwCharacteristics(0)
{
    ZeroMemory(&m_guidInstance, sizeof(m_guidInstance));

    // Initialize the AdapterInfo default values
    ZeroMemory(&m_AdapterInfo, sizeof(m_AdapterInfo));
    m_AdapterInfo.m_dwAarpRetries = c_dwTen;
    m_AdapterInfo.m_dwMediaType   = MEDIATYPE_ETHERNET;
    SetDefaultZone(c_szEmpty);
    SetPortName(c_szEmpty);
}

//
// Function:    CAdapterInfo::~CAdapterInfo
//
// Purpose:     ctor for the CAdapters class
//
// Parameters:  none
//
// Returns:     nothing
//
CAdapterInfo::~CAdapterInfo()
{
    // Cleanup the AppleTalk\Adapters\<adapter> internal data structure
    delete [] m_AdapterInfo.m_szDefaultZone;
    delete [] m_AdapterInfo.m_szPortName;

    DeleteColString(&m_lstpstrDesiredZoneList);
    DeleteColString(&m_lstpstrZoneList);
}

//
// Function:    CAdapterInfo::SetDefaultZone
//
// Purpose:     Set the default zone for this adapter
//
// Parameters:  sz - The new default zone
//
// Returns:     nothing
//
void CAdapterInfo::SetDefaultZone(PCWSTR psz)
{
    Assert(psz);
    delete [] m_AdapterInfo.m_szDefaultZone;
    m_AdapterInfo.m_szDefaultZone = NULL;
    m_AdapterInfo.m_szDefaultZone = new WCHAR[wcslen(psz)+1];
    wcscpy(m_AdapterInfo.m_szDefaultZone, psz);
}

//
// Function:    CAdapterInfo::SetPortName
//
// Purpose:     Set the port name for this adapter
//
// Parameters:  sz - The new port name
//
// Returns:     nothing
//
void CAdapterInfo::SetPortName(PCWSTR psz)
{
    Assert(psz);
    delete [] m_AdapterInfo.m_szPortName;
    m_AdapterInfo.m_szPortName = NULL;
    m_AdapterInfo.m_szPortName = new WCHAR[wcslen(psz)+1];
    wcscpy(m_AdapterInfo.m_szPortName, psz);
}

//
// Function:    CAdapterInfo::HrGetAndSetNetworkInformation
//
// Purpose:
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//
#define PARM_BUF_LEN    512
#define ASTERISK_CHAR   "*"

HRESULT
CAdapterInfo::HrGetAndSetNetworkInformation (
    SOCKET socket,
    PCWSTR pszDevName)
{
    HRESULT      hr = FALSE;
    CHAR         *pZoneBuffer = NULL;
    CHAR         *pDefParmsBuffer = NULL;
    CHAR         *pZoneListStart;
    INT          BytesNeeded ;
    WCHAR        *pwDefZone = NULL;
    tstring      strTmpZone;
    INT          ZoneLen = 0;
    DWORD        wsaerr = 0;
    CHAR         *pDefZone = NULL;

    PWSH_LOOKUP_ZONES                pGetNetZones;
    PWSH_LOOKUP_NETDEF_ON_ADAPTER    pGetNetDefaults;

    Assert(pszDevName);

    pZoneBuffer = new CHAR [ZONEBUFFER_LEN + sizeof(WSH_LOOKUP_ZONES)];
    Assert(pZoneBuffer);

	if (pZoneBuffer == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    pGetNetZones = (PWSH_LOOKUP_ZONES)pZoneBuffer;

    wcscpy((WCHAR *)(pGetNetZones+1), pszDevName);

    BytesNeeded = ZONEBUFFER_LEN;

    wsaerr = getsockopt(socket, SOL_APPLETALK, SO_LOOKUP_ZONES_ON_ADAPTER,
                        (char *)pZoneBuffer, &BytesNeeded);
    if (0 != wsaerr)
    {
        //$ REVIEW - error mapping
#ifdef DBG
        DWORD dwErr = WSAGetLastError();
        TraceTag(ttidError, "CAdapterInfo::HrGetAndSetNetworkInformation getsocketopt returned: %08X",dwErr);
#endif
        hr = E_UNEXPECTED;
        goto Error;
    }

    pZoneListStart = pZoneBuffer + sizeof(WSH_LOOKUP_ZONES);
    if (!lstrcmpA(pZoneListStart, ASTERISK_CHAR))
    {
        // Success, wildcard zone set.
        goto Done;
    }

    hr = HrConvertZoneListAndAddToPortInfo(pZoneListStart,
                                           ((PWSH_LOOKUP_ZONES)pZoneBuffer)->NoZones);
    if (FAILED(hr))
    {
        goto Error;
    }

    SetRouterOnNetwork(TRUE);

    //
    // Get the DefaultZone/NetworkRange Information
    pDefParmsBuffer = new CHAR[PARM_BUF_LEN+sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER)];
    Assert(pDefParmsBuffer);

	if (pDefParmsBuffer == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    pGetNetDefaults = (PWSH_LOOKUP_NETDEF_ON_ADAPTER)pDefParmsBuffer;
    BytesNeeded = PARM_BUF_LEN + sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER);

    wcscpy((WCHAR*)(pGetNetDefaults+1), pszDevName);
    pGetNetDefaults->NetworkRangeLowerEnd = pGetNetDefaults->NetworkRangeUpperEnd = 0;

    wsaerr = getsockopt(socket, SOL_APPLETALK, SO_LOOKUP_NETDEF_ON_ADAPTER,
                        (char*)pDefParmsBuffer, &BytesNeeded);
    if (0 != wsaerr)
    {
#ifdef DBG
        DWORD dwErr = WSAGetLastError();
#endif
        hr = E_UNEXPECTED;
        goto Error;
    }

    // Save the default information to PORT_INFO
    SetExistingNetRange(pGetNetDefaults->NetworkRangeLowerEnd,
                        pGetNetDefaults->NetworkRangeUpperEnd);

    pDefZone  = pDefParmsBuffer + sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER);
    ZoneLen = lstrlenA(pDefZone) + 1;

    pwDefZone = new WCHAR [sizeof(WCHAR) * ZoneLen];
    Assert(NULL != pwDefZone);

	if (pwDefZone == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    mbstowcs(pwDefZone, pDefZone, ZoneLen);

    strTmpZone = pwDefZone;

    SetNetDefaultZone(strTmpZone.c_str());

    if (pZoneBuffer != NULL)
    {
        delete [] pZoneBuffer;
    }

    if (pwDefZone != NULL)
    {
        delete [] pwDefZone;
    }

    if (pDefParmsBuffer != NULL)
    {
        delete [] pDefParmsBuffer;
    }

Done:
Error:
    TraceError("CAdapterInfo::HrGetAndSetNetworkInformation",hr);
    return hr;
}

//
// Function:    CAdapterInfo::HrConvertZoneListAndAddToPortInfo
//
// Purpose:
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CAdapterInfo::HrConvertZoneListAndAddToPortInfo(CHAR * szZoneList, ULONG NumZones)
{
    INT      cbAscii = 0;
    WCHAR    *pszZone = NULL;
    tstring  *pstr;

    Assert(NULL != szZoneList);
    DeleteColString(&m_lstpstrDesiredZoneList);

    while(NumZones--)
    {
        cbAscii = lstrlenA(szZoneList) + 1;

        pszZone = new WCHAR [sizeof(WCHAR) * cbAscii];
        Assert(NULL != pszZone);

		if (pszZone == NULL)
		{
			return(ERROR_NOT_ENOUGH_MEMORY);
		}

        mbstowcs(pszZone, szZoneList, cbAscii);

        pstr = new tstring(pszZone);
        Assert(NULL != pstr);

        m_lstpstrDesiredZoneList.push_back(pstr);
        szZoneList += cbAscii;

       delete [] pszZone;
    }

    return S_OK;
}

//
// Function:    CAdapterInfo::HrCopy
//
// Purpose:     Create a duplicate copy of 'this'
//
// Parameters:  ppAI [out] - if the function succeeds, ppAI will contain the
//                           copy of 'this'.
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CAdapterInfo::HrCopy(CAdapterInfo ** ppAI)
{
    CAdapterInfo *pAI;
    list<tstring*>::iterator iter;
    tstring * pstr;

    Assert(NULL != ppAI);

    // Create an adapter info structure
    pAI = new CAdapterInfo;
    Assert(pAI);

	if (pAI == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    // Make a copy of everything
    pAI->SetDisabled(FDisabled());
    pAI->SetDeletePending(FDeletePending());
    pAI->SetCharacteristics(GetCharacteristics());
    pAI->SetMediaType(DwMediaType());
    pAI->SetBindName(SzBindName());
    pAI->SetDisplayName(SzDisplayName());
    pAI->SetNetDefaultZone(SzNetDefaultZone());
    pAI->SetRouterOnNetwork(FRouterOnNetwork());
    pAI->SetExistingNetRange(DwQueryNetworkLower(), DwQueryNetworkUpper());
    pAI->SetDirty(IsDirty());
    pAI->SetRasAdapter(IsRasAdapter());

    // Free the default data set by the constructor before overwriting it.
    // (this whole thing is not a very good approach.)
    //
    delete [] pAI->m_AdapterInfo.m_szDefaultZone;
    delete [] pAI->m_AdapterInfo.m_szPortName;

    pAI->m_AdapterInfo = m_AdapterInfo;

    // Cleanup the 'allocated' data cause by the bit copy
    // so that SetDefaultZone and SetPortName don't try to free bogus
    // stuff.  (more "programming by side-affect")
    //
    pAI->m_AdapterInfo.m_szDefaultZone = NULL;
    pAI->m_AdapterInfo.m_szPortName = NULL;

    // Now copy the 'allocated' data
    pAI->SetDefaultZone(SzDefaultZone());
    pAI->SetPortName(SzPortName());

    for (iter = LstpstrZoneList().begin();
         iter != LstpstrZoneList().end();
         iter++)
    {
        pstr = *iter;
        pAI->LstpstrZoneList().push_back(new tstring(pstr->c_str()));
    }

    for (iter = LstpstrDesiredZoneList().begin();
         iter != LstpstrDesiredZoneList().end();
         iter++)
    {
        pstr = *iter;
        pAI->LstpstrDesiredZoneList().push_back(new tstring(pstr->c_str()));
    }

    *ppAI = pAI;
    return S_OK;
}

//
// Function:    HrQueryAdapterComponentInfo
//
// Purpose:     Fill out an CAdapterInfo instance with the data retrieved
//              specifically from the component itself.
//
// Parameters:  pncc [in] - The component object (adapter) to query
//              pAI [in/out] - Where to place the queried info
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrQueryAdapterComponentInfo(INetCfgComponent *pncc,
                                    CAdapterInfo * pAI)
{
    PWSTR  psz = NULL;
    DWORD   dwCharacteristics;
    HRESULT hr;

    Assert(NULL != pncc);
    Assert(NULL != pAI);

    // Retrieve the component's name
    hr = pncc->GetBindName(&psz);
    if (FAILED(hr))
    {
        goto Error;
    }

    Assert(psz && *psz);
    pAI->SetBindName(psz);
    CoTaskMemFree(psz);
    psz = NULL;

    hr = pncc->GetInstanceGuid(pAI->PInstanceGuid());
    if (FAILED(hr))
    {
        goto Error;
    }

    // Get the Adapter's display name
    hr = pncc->GetDisplayName(&psz);
    if (FAILED(hr))
    {
        goto Error;
    }

    Assert(psz);
    pAI->SetDisplayName(psz);
    CoTaskMemFree(psz);
    psz = NULL;

    // Get the Component ID so we can check if this is a RAS adapter
    //
    hr = pncc->GetId(&psz);
    if (FAILED(hr))
    {
        goto Error;
    }

    Assert(psz && *psz);
    pAI->SetRasAdapter(0 == _wcsicmp(c_szInfId_MS_NdisWanAtalk, psz));
    CoTaskMemFree(psz);
    psz = NULL;

    // Failure is non-fatal
    hr = pncc->GetCharacteristics(&dwCharacteristics);
    if (SUCCEEDED(hr))
    {
        pAI->SetCharacteristics(dwCharacteristics);
    }

    // Get the media type (Optional key)
    {
        DWORD dwMediaType = MEDIATYPE_ETHERNET ;
        INetCfgComponentBindings* pnccBindings = NULL;

        hr = pncc->QueryInterface(IID_INetCfgComponentBindings,
                                  reinterpret_cast<void**>(&pnccBindings));
        if (S_OK == hr)
        {
            static const struct
            {
                PCWSTR pszInterface;
                DWORD   dwInterface;
                DWORD   dwFlags;
            } InterfaceMap[] = {{L"ethernet", MEDIATYPE_ETHERNET, NCF_LOWER},
                                {L"tokenring", MEDIATYPE_TOKENRING, NCF_LOWER},
                                {L"fddi", MEDIATYPE_FDDI, NCF_LOWER},
                                {L"localtalk", MEDIATYPE_LOCALTALK, NCF_LOWER},
                                {L"wan", MEDIATYPE_WAN, NCF_LOWER}};

            for (UINT nIdx=0; nIdx < celems(InterfaceMap); nIdx++)
            {
                hr = pnccBindings->SupportsBindingInterface(InterfaceMap[nIdx].dwFlags,
                                                            InterfaceMap[nIdx].pszInterface);
                if (S_OK == hr)
                {
                    dwMediaType = InterfaceMap[nIdx].dwInterface;
                    break;
                }
            }

            ::ReleaseObj(pnccBindings);
        }

        pAI->SetMediaType(dwMediaType);
        hr = S_OK;
    }

Error:
    TraceError("HrQueryAdapterComponentInfo",hr);
    return hr;
}

//
// Function:    HrPortNameFromAdapter
//
// Purpose:     Create a port name, for use as an adapters PortName
//
// Parameters:  pncc [in] - The component object (adapter) to query
//              pstr [in/out] - On success will contain the PortName
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrPortNameFromAdapter(INetCfgComponent *pncc, tstring * pstr)
{
    HRESULT hr;
    PWSTR psz;
    PWSTR pszBindName = NULL;
    WCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize = sizeof(szComputerName) / sizeof(WCHAR);

    Assert(NULL != pstr);
    Assert(NULL != pncc);

    if (!GetComputerName(szComputerName, &dwSize))
    {
        hr = ::HrFromLastWin32Error();
        goto Error;
    }

    hr = pncc->GetBindName(&pszBindName);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Replace the instances of '-' and '{' with '0' so the constructed
    // portname is of the form [a-zA-Z0-9]*@<Computer Name> and is less
    // than MAX_ZONE_NAME_LEN long.
    psz = pszBindName;
    while (*psz)
    {
        if ((*psz == L'-') || (*psz == L'{'))
        {
            *psz = L'0';
        }
        psz++;
    }

    *pstr = pszBindName;
    if (pstr->size() + 1 + dwSize > MAX_ZONE_NAME_LEN)
    {
        pstr->resize(MAX_ZONE_NAME_LEN - (dwSize + 1));
    }

    *pstr += c_chAt;
    *pstr += szComputerName;
    Assert( MAX_ZONE_NAME_LEN >= pstr->size());

Error:
    CoTaskMemFree(pszBindName);
    TraceError("HrPortNameFromAdapter",hr);
    return hr;
}

HRESULT CATlkObj::HrAtlkReconfig()
{
    CServiceManager csm;
    CService        svr;
    HRESULT         hr = S_OK;
    HRESULT         hrRet;
    BOOL            fDirty = FALSE;
    CAdapterInfo *  pAI;
    CAdapterInfo *  pAIDefault = NULL;
    ATLK_ADAPTER_INFO_LIST::iterator iter;
    ATALK_PNP_EVENT Config;

    if (m_pATLKEnv->AdapterInfoList().empty())
    {
        return hr;
    }

    ZeroMemory(&Config, sizeof(Config));

    // If routing changed notify appletalk and return.  No need to do the
    // per adapter notifications.
    if (m_pATLKEnv->FRouterChanged())
    {
        // notify atlk
        Config.PnpMessage = AT_PNP_SWITCH_ROUTING;
        hrRet = HrSendNdisPnpReconfig(NDIS, c_szAtlk, c_szEmpty,
                                      &Config, sizeof(ATALK_PNP_EVENT));
        if (FAILED(hrRet) &&
            (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hrRet))
        {
            hr = NETCFG_S_REBOOT;
        }

        m_pATLKEnv->SetRouterChanged(FALSE);

        return hr;
    }

    // Find the default adapter and also if any adapter's have changed
    for (iter = m_pATLKEnv->AdapterInfoList().begin();
         iter != m_pATLKEnv->AdapterInfoList().end();
         iter++)
    {
        pAI = *iter;

        tstring strPortName = c_szDevice;
        strPortName += pAI->SzBindName();

        if (pAI->FDeletePending() || pAI->FDisabled())
        {
            continue;
        }

        // Locate the default port
        if (0 == _wcsicmp(strPortName.c_str(), m_pATLKEnv->SzDefaultPort()))
        {
            pAIDefault = pAI;
        }

        if (pAI->IsDirty())
        {
            fDirty = TRUE;
        }
    }

    if ((NULL != pAIDefault) && m_pATLKEnv->FDefAdapterChanged())
    {
        // notify atlk
        Config.PnpMessage = AT_PNP_SWITCH_DEFAULT_ADAPTER;
        hrRet = HrSendNdisPnpReconfig(NDIS, c_szAtlk, NULL,
                                      &Config, sizeof(ATALK_PNP_EVENT));
        if (FAILED(hrRet) &&
            (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hrRet))
        {
            hr = NETCFG_S_REBOOT;
        }

        // Clear the dirty state
        m_pATLKEnv->SetDefAdapterChanged(FALSE);
        pAIDefault->SetDirty(FALSE);
    }

    Config.PnpMessage = AT_PNP_RECONFIGURE_PARMS;
    for (iter = m_pATLKEnv->AdapterInfoList().begin();
         iter != m_pATLKEnv->AdapterInfoList().end();
         iter++)
    {
        pAI = *iter;

        if (pAI->FDeletePending() || pAI->FDisabled())
        {
            continue;
        }

        if (pAI->IsDirty())
        {
            // Now submit the reconfig notification
            hrRet = HrSendNdisPnpReconfig(NDIS, c_szAtlk, pAI->SzBindName(),
                                          &Config, sizeof(ATALK_PNP_EVENT));
            if (FAILED(hrRet) &&
                (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hrRet))
            {
                hr = NETCFG_S_REBOOT;
            }

            // Clear the dirty state
            pAI->SetDirty(FALSE);
        }
    }

    TraceError("CATLKObj::HrAtlkReconfig",hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\arpsfunc.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A R P S F U N C . C P P
//
//  Contents:   CArpsCfg help member function implementation
//
//  Notes:
//
//  Author:     tongl   12 Mar 1997
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "arpsobj.h"
#include "arpsdlg.h"
#include "atmutil.h"
#include "ncreg.h"
#include "ncatlui.h"
#include "ncstl.h"
//#include "ncui.h"

#include "netconp.h"
#include "atmhelp.h"

extern const WCHAR c_szAdapters[];

//
// Load cards on bind path to m_listAdapters on Initialize
//
HRESULT CArpsCfg::HrLoadSettings()
{
    HRESULT hr = S_OK;

    CIterNetCfgBindingPath      ncbpIter(m_pnccArps);
    INetCfgBindingPath *        pncbp;

    // Go through all binding paths in search of arps to netcard bindings
    while(SUCCEEDED(hr) && (hr = ncbpIter.HrNext(&pncbp)) == S_OK)
    {
        INetCfgComponent * pnccNetComponent;
        hr = HrGetLastComponentAndInterface(pncbp,
                                            &pnccNetComponent,
                                            NULL);
        if (SUCCEEDED(hr))
        {
            Assert(pnccNetComponent);

            // The last component should be of NET CLASS
            GUID    ClassGuid;

            // What type is it?
            hr = pnccNetComponent->GetClassGuid(&ClassGuid);
            if (SUCCEEDED(hr))
            {
                // Is it a netcard?
                if (IsEqualGUID(ClassGuid, GUID_DEVCLASS_NET))
                {
                    hr = HrAddAdapter(pnccNetComponent);

                    if (SUCCEEDED(hr))
                    {
                        // Is the binding enabled ??
                        hr = pncbp->IsEnabled();

                        // hr == S_OK if the card is enabled (ie: bound)
                        if (hr == S_OK)
                        {   // bind the card in our data strucutres
                            hr = HrBindAdapter(pnccNetComponent);
                        }
                        else if (hr == S_FALSE)
                        {
                            hr = HrUnBindAdapter(pnccNetComponent);
                        }

                        // Now load cofigurable parameters
                        if (SUCCEEDED(hr))
                        {
                            HKEY hkeyArpsParam;

                            hr = m_pnccArps->OpenParamKey(&hkeyArpsParam);
                            if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                            {
                                hr = S_OK;
                            }
                            else if (SUCCEEDED(hr))
                            {
                                Assert(hkeyArpsParam);
                                hr = HrLoadArpsRegistry(hkeyArpsParam);

                                RegCloseKey(hkeyArpsParam);
                            }
                        }
                    }
                }
            }
            ReleaseObj(pnccNetComponent);
        }
        ReleaseObj(pncbp);
    }
    AssertSz(!pncbp, "BindingPath wasn't released");

    if (hr == S_FALSE) // We just got to the end of the loop
        hr = S_OK;

    TraceError("CArpsCfg::HrLoadSettings", hr);
    return hr;
}

// Load registry settings for configurable parameters into memory
HRESULT CArpsCfg::HrLoadArpsRegistry(HKEY hkeyArpsParam)
{
    HRESULT hr = S_OK;

    HKEY    hkeyAdapters = NULL;
    hr = HrRegOpenKeyEx(hkeyArpsParam, c_szAdapters,
                        KEY_READ, &hkeyAdapters);

    if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        hr = S_OK;
    else if(SUCCEEDED(hr))
    {
        HKEY    hkeyAdapterParam = NULL;

        for(ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
            iterAdapter != m_listAdapters.end();
            iterAdapter ++)
        {
            // Open the AtmArps\Adapters to get per adapter ARPS settings
            hr = HrRegOpenKeyEx(hkeyAdapters,
                                (*iterAdapter)->m_strBindName.c_str(),
                                KEY_READ, &hkeyAdapterParam);

            if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                hr = S_OK;
            }
            else if (S_OK == hr)
            {
                TraceTag(ttidAtmArps, "CArpsCfg::HrLoadArpsRegistry");
                TraceTag(ttidAtmArps, "Adapter: %S", (*iterAdapter)->m_strBindName.c_str());

                HRESULT hrTmp = S_OK;

                // Sap selecter
                hrTmp = HrRegQueryDword(hkeyAdapterParam,
                                       c_szSapSel,
                                       &((*iterAdapter)->m_dwSapSelector));

                (*iterAdapter)->m_dwOldSapSelector = (*iterAdapter)->m_dwSapSelector;

                hr = hrTmp;

                // Registered addresses
                hrTmp = HrRegQueryColString(hkeyAdapterParam,
                                           c_szRegAddrs,
                                           &((*iterAdapter)->m_vstrRegisteredAtmAddrs));

                // Save the registry value in old address
                CopyColString(&((*iterAdapter)->m_vstrOldRegisteredAtmAddrs),
                              (*iterAdapter)->m_vstrRegisteredAtmAddrs);

                if (S_OK == hr)
                {
                    hr = hrTmp;
                }

                // Multicast addresses
                hrTmp = HrRegQueryColString(hkeyAdapterParam,
                                           c_szMCAddrs,
                                           &((*iterAdapter)->m_vstrMulticastIpAddrs));

                CopyColString(&((*iterAdapter)->m_vstrOldMulticastIpAddrs),
                              (*iterAdapter)->m_vstrMulticastIpAddrs);

                if (S_OK == hr)
                {
                    hr = hrTmp;
                }
            }

            RegSafeCloseKey(hkeyAdapterParam);
            hkeyAdapterParam = NULL;
        }
    }
    RegSafeCloseKey(hkeyAdapters);

    TraceError("CArpsCfg::HrLoadArpsRegistry", hr);
    return hr;
}

//
// Update registry with info in m_listAdapters on Apply
//
HRESULT CArpsCfg::HrSaveSettings()
{
    HRESULT hr = S_OK;
    HKEY hkeyArpsParam = NULL;

    hr = m_pnccArps->OpenParamKey(&hkeyArpsParam);

    if (S_OK == hr)
    {
        HKEY hkeyAdapters = NULL;
        DWORD dwDisposition;

        // Create or open the "Adapters" key under "Services\Atmarps\Parameters"
        hr = HrRegCreateKeyEx(hkeyArpsParam,
                              c_szAdapters,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hkeyAdapters,
                              &dwDisposition);

        if (S_OK == hr)
        {
            Assert(hkeyAdapters);
            HRESULT hrTmp = S_OK;

            if (dwDisposition == REG_OPENED_EXISTING_KEY)
            { // if the "adapters" key existed, there might be some old cards
              // Cleanup subkeys for adapters that are not in our memory structure

                VECSTR vstrAdapters;
                hrTmp = HrLoadSubkeysFromRegistry(hkeyAdapters, &vstrAdapters);

                if SUCCEEDED(hrTmp)
                {
                    for (size_t i=0; i<vstrAdapters.size(); i++)
                    {
                        BOOL fFound = FALSE;
                        for (ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
                             iterAdapter != m_listAdapters.end();
                             iterAdapter ++)
                        {
                            if ((*iterAdapter)->m_strBindName == vstrAdapters[i]->c_str())
                            {
                                fFound = TRUE;
                                break;
                            }
                        }

                        if ((!fFound) || ((*iterAdapter)->m_fDeleted))
                        {
                            hrTmp = HrRegDeleteKeyTree(hkeyAdapters,
                                                       vstrAdapters[i]->c_str());
                            if SUCCEEDED(hr)
                                hr = hrTmp;
                        }
                    }
                }
            }

            // Save adapter info in memory state to registry
            for (ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
                 iterAdapter != m_listAdapters.end();
                 iterAdapter ++)
            {

                if ((*iterAdapter)->m_fDeleted)
                    continue;

                HKEY    hkeyAdapterParam;

                // Create specific card bindname key under
                // "Services\Atmarps\Parameters\Adapters\<card bind name>"
                hrTmp = HrRegCreateKeyEx(hkeyAdapters,
                                         ((*iterAdapter)->m_strBindName).c_str(),
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_ALL_ACCESS,
                                         NULL,
                                         &hkeyAdapterParam,
                                         &dwDisposition);
                if(SUCCEEDED(hr))
                    hr = hrTmp;

                if(SUCCEEDED(hrTmp))
                {
                    /*
                    hrTmp = HrSetDefaultAdapterParam(hkeyAdapterParam);

                    if SUCCEEDED(hr)
                        hr = hrTmp;
                    */

                    // Sap selecter
                    hrTmp = HrRegSetDword(hkeyAdapterParam,
                                          c_szSapSel,
                                          (*iterAdapter)->m_dwSapSelector);
                    if SUCCEEDED(hr)
                        hr = hrTmp;

                    // Registered addresses
                    hrTmp = HrRegSetColString(hkeyAdapterParam,
                                              c_szRegAddrs,
                                              (*iterAdapter)->m_vstrRegisteredAtmAddrs);

                    if SUCCEEDED(hr)
                        hr = hrTmp;

                    // Multicast addresses
                    hrTmp = HrRegSetColString(hkeyAdapterParam,
                                              c_szMCAddrs,
                                              (*iterAdapter)->m_vstrMulticastIpAddrs);

                    if SUCCEEDED(hr)
                        hr = hrTmp;
                }
                RegSafeCloseKey(hkeyAdapterParam);
            }
        }
        RegSafeCloseKey(hkeyAdapters);
    }
    RegSafeCloseKey(hkeyArpsParam);

    TraceError("CArpsCfg::HrSaveSettings", hr);
    return hr;
}

//
// Adding a card
//
HRESULT CArpsCfg::HrAddAdapter(INetCfgComponent * pncc)
{
    HRESULT hr = S_OK;

    PWSTR pszwBindName = NULL;
    hr = pncc->GetBindName(&pszwBindName);

    AssertSz( SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

    // check if the adapter already existsed and marked as deleted,
    // if so, just unmark it

    BOOL fFound = FALSE;

    for (ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
         iterAdapter != m_listAdapters.end();
         iterAdapter ++)
    {
        if ((*iterAdapter)->m_strBindName == pszwBindName)
        {
            Assert((*iterAdapter)->m_fDeleted);
            (*iterAdapter)->m_fDeleted = FALSE;

            fFound = TRUE;
            break;
        }
    }

    if (!fFound) // add a new item
    {
        CArpsAdapterInfo * pAdapterInfo = new CArpsAdapterInfo;
        pAdapterInfo->HrSetDefaults(pszwBindName);

        // create a new item for the ARPS_ADAPT_INFO list
        m_listAdapters.push_back(pAdapterInfo);
    }

    CoTaskMemFree(pszwBindName);

    TraceError("CArpsCfg::HrAddAdapter", hr);
    return hr;
}

//
// Removing a card
//
HRESULT CArpsCfg::HrRemoveAdapter(INetCfgComponent * pncc)
{
    HRESULT hr = S_OK;

    PWSTR pszwBindName = NULL;
    hr = pncc->GetBindName(&pszwBindName);

    AssertSz( SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

    // mark the adapter as removed
    for (ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
         iterAdapter != m_listAdapters.end();
         iterAdapter ++)
    {
        if ((*iterAdapter)->m_strBindName == pszwBindName)
        {
            (*iterAdapter)->m_fDeleted = TRUE;
        }
    }
    CoTaskMemFree(pszwBindName);

    TraceError("CArpsCfg::HrRemoveAdapter", hr);
    return hr;
}

HRESULT CArpsCfg::HrBindAdapter(INetCfgComponent * pnccAdapter)
{
    HRESULT hr = S_OK;

    PWSTR pszwBindName = NULL;
    hr = pnccAdapter->GetBindName(&pszwBindName);

    AssertSz(SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

    for (ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
         iterAdapter != m_listAdapters.end();
         iterAdapter ++)
    {
        if ((*iterAdapter)->m_strBindName == pszwBindName)
        {
            (*iterAdapter)->m_BindingState = BIND_ENABLE;
            break;
        }
    }

    CoTaskMemFree(pszwBindName);

    TraceError("CArpsCfg::HrBindAdapter", hr);
    return hr;
}

HRESULT CArpsCfg::HrUnBindAdapter(INetCfgComponent * pnccAdapter)
{
    HRESULT hr = S_OK;

    PWSTR pszwBindName = NULL;
    hr = pnccAdapter->GetBindName(&pszwBindName);

    AssertSz(SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

    for (ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
         iterAdapter != m_listAdapters.end();
         iterAdapter ++)
    {
        if ((*iterAdapter)->m_strBindName == pszwBindName)
        {
            (*iterAdapter)->m_BindingState = BIND_DISABLE;
            break;
        }
    }

    CoTaskMemFree(pszwBindName);

    TraceError("CArpsCfg::HrUnBindAdapter", hr);
    return hr;
}

// Called by CArpsCfg::MergePropPages
// Set the context in which the UI is brought up
HRESULT CArpsCfg::HrSetConnectionContext()
{
    AssertSz(m_pUnkContext, "Invalid IUnknown pointer passed to CArpsCfg::SetContext?");

    if (!m_pUnkContext)
        return E_FAIL;

    HRESULT hr = S_OK;
    GUID guidConn;

    // Is this a lan connection ?
    INetLanConnectionUiInfo * pLanConnUiInfo;
    hr = m_pUnkContext->QueryInterface( IID_INetLanConnectionUiInfo,
                                        reinterpret_cast<LPVOID *>(&pLanConnUiInfo));
    if (SUCCEEDED(hr))
    {
        // yes, lan connection
        pLanConnUiInfo->GetDeviceGuid(&guidConn);
        ReleaseObj(pLanConnUiInfo);

        WCHAR szGuid[c_cchGuidWithTerm];

        BOOL fSucceeded = StringFromGUID2(guidConn,
                                          szGuid,
                                          c_cchGuidWithTerm);
        Assert(fSucceeded);
        m_strGuidConn = szGuid;
    }

    TraceError("CArpsCfg::HrSetConnectionContext", hr);
    return hr;
}

// Called by CArpsCfg::MergePropPages
// Allocate property pages
HRESULT CArpsCfg::HrSetupPropSheets(HPROPSHEETPAGE ** pahpsp, INT * pcPages)
{
    HRESULT hr = S_OK;
    int cPages = 0;
    HPROPSHEETPAGE *ahpsp = NULL;

    m_fSecondMemoryModified = FALSE;

    // Copy adapter specific info: enabled cards only !!
    hr = HrLoadAdapterInfo();

    // If we have found the matching adapter
    if SUCCEEDED(hr)
    {
        cPages = 1;

        delete m_arps;
        m_arps = new CArpsPage(this, g_aHelpIDs_IDD_ARPS_PROP);

		if (m_arps == NULL)
		{
			return(ERROR_NOT_ENOUGH_MEMORY);
		}

        // Allocate a buffer large enough to hold the handles to all of our
        // property pages.
        ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE)
                                                 * cPages);
        if (!ahpsp)
        {
            hr = E_OUTOFMEMORY;
            goto err;
        }

        cPages =0;

        ahpsp[cPages++] = m_arps->CreatePage(IDD_ARPS_PROP, 0);

        *pahpsp = ahpsp;
        *pcPages = cPages;
    }
    else // if we don't have any bound cards, pop-up message box and don't show UI
    {
        NcMsgBox(::GetActiveWindow(),
                 IDS_MSFT_ARPS_TEXT,
                 IDS_ARPS_NO_BOUND_CARDS,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        AssertSz((0== *pcPages), "Invalid page number when no bound cards");
        AssertSz((NULL == *pahpsp), "Invalid page array pointer when no bound cards");
    }

err:

    TraceError("CArpsCfg::HrSetupPropSheets", hr);
    return hr;
}

// Called by CArpsCfg::HrSetupPropSheets
// Creates the second memory adapter info from the first memory structure
// Note: Bound cards only
HRESULT CArpsCfg::HrLoadAdapterInfo()
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_MATCH);

    delete m_pSecondMemoryAdapterInfo;
    m_pSecondMemoryAdapterInfo = NULL;

    for(ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
        iterAdapter != m_listAdapters.end();
        iterAdapter++)
    {
        if (FIsSubstr(m_strGuidConn.c_str(), (*iterAdapter)->m_strBindName.c_str()))
        {
            // enabled LAN adapter
            if ((*iterAdapter)->m_BindingState == BIND_ENABLE)
            {
                m_pSecondMemoryAdapterInfo = new CArpsAdapterInfo;

				if (m_pSecondMemoryAdapterInfo == NULL)
				{
					return(ERROR_NOT_ENOUGH_MEMORY);
				}

                *m_pSecondMemoryAdapterInfo = **iterAdapter;
                hr = S_OK;
            }
        }
    }

    AssertSz((S_OK == hr), "Can not raise UI on a disabled or non-exist adapter !");
    TraceError("CArpsCfg::HrLoadAdapterInfo", hr);
    return hr;
}

// Called by CArpsCfg::ApplyProperties
// Saves the second memory state back into the first
HRESULT CArpsCfg::HrSaveAdapterInfo()
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_MATCH);

    for(ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
        iterAdapter != m_listAdapters.end();
        iterAdapter++)
    {
        if(m_pSecondMemoryAdapterInfo->m_strBindName == (*iterAdapter)->m_strBindName)
        {
            // The card can not get unbound while in the properties UI !
            Assert((*iterAdapter)->m_BindingState == BIND_ENABLE);
            Assert(m_pSecondMemoryAdapterInfo->m_BindingState == BIND_ENABLE);

            **iterAdapter = *m_pSecondMemoryAdapterInfo;
            hr = S_OK;
            break;
        }
    }

    AssertSz((S_OK == hr),
             "Adapter in second memory not found in first memory!");

    TraceError("CArpsCfg::HrSaveAdapterInfo", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\arpsobj.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A R P S O B J . C P P
//
//  Contents:   CArpsCfg interface method function implementation
//
//  Notes:
//
//  Author:     tongl   12 Mar 1997
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "arpsobj.h"
#include "arpsdlg.h"
#include "atmutil.h"
#include "atmcommon.h"
#include "ncstl.h"
#include "netconp.h"

#include "ncpnp.h"

static const WCHAR c_szAtmarps[] = L"Atmarps";

CArpsCfg::CArpsCfg()
{
    m_pnccArps  = NULL;
    m_fSaveRegistry = FALSE;
    m_fReconfig = FALSE;
    m_fSecondMemoryModified = FALSE;
    m_fRemoving = FALSE;

    m_pSecondMemoryAdapterInfo = NULL;

    m_strGuidConn = c_szEmpty;
    m_pUnkContext = NULL;

    m_arps = NULL;
}

CArpsCfg::~CArpsCfg()
{
    ReleaseObj(m_pnccArps);
    FreeCollectionAndItem(m_listAdapters);

    // Just a safty check to make sure the context is released.
    AssertSz((m_pUnkContext == NULL), "Why is context not released ? Not a bug in ARPS config.");
    if (m_pUnkContext)
        ReleaseObj(m_pUnkContext) ;

    delete m_arps;
}

// INetCfgComponentControl
STDMETHODIMP CArpsCfg::Initialize (INetCfgComponent* pnccItem,
                                   INetCfg* pNetCfg, BOOL fInstalling )
{
    Validate_INetCfgNotify_Initialize(pnccItem, pNetCfg, fInstalling);

    HRESULT hr = S_OK;

    // Save in the data members the pointer to the
    // INetCfgComponent
    AssertSz(!m_pnccArps, "CArpsCfg::m_pnccArps not initialized!");
    m_pnccArps = pnccItem;
    AssertSz(m_pnccArps, "Component pointer is NULL!");
    AddRefObj(m_pnccArps);

    // Initialize in memory state
    if (!fInstalling)
    {
        hr = HrLoadSettings();
    }

    Validate_INetCfgNotify_Initialize_Return(hr);

    TraceError("CArpsCfg::Initialize", hr);
    return hr;
}

STDMETHODIMP CArpsCfg::Validate ( )
{
    return S_OK;
}

STDMETHODIMP CArpsCfg::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP CArpsCfg::ApplyRegistryChanges ()
{
    HRESULT hr = S_OK;

    if (m_fSaveRegistry && !m_fRemoving)
    {
        hr = HrSaveSettings();

        if (SUCCEEDED(hr) && m_fReconfig)
        {
            HRESULT hrReconfig;

            // send reconfig notification if parameter has changed
            for (ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
                 iterAdapter != m_listAdapters.end();
                 iterAdapter ++)
            {
                if ((*iterAdapter)->m_fDeleted)
                    continue;

                if ( ((*iterAdapter)->m_dwSapSelector !=
                      (*iterAdapter)->m_dwOldSapSelector) ||
                     !fIsSameVstr((*iterAdapter)->m_vstrRegisteredAtmAddrs,
                                  (*iterAdapter)->m_vstrOldRegisteredAtmAddrs) ||
                     !fIsSameVstr((*iterAdapter)->m_vstrMulticastIpAddrs,
                                  (*iterAdapter)->m_vstrOldMulticastIpAddrs))
                {
                    hrReconfig  = HrSendNdisPnpReconfig(NDIS, c_szAtmarps,
                                                        (*iterAdapter)->m_strBindName.c_str(),
                                                        NULL, 0);
                    if (FAILED(hrReconfig))
                    {
                        TraceTag(ttidAtmArps,"Notifying Atm ARP server of parameter change returns failure, prompt for reboot ...");
                        hr = NETCFG_S_REBOOT;
                    }
                }
            }
        }
    }
    else
    {
        hr = S_FALSE;
    }

    Validate_INetCfgNotify_Apply_Return(hr);

    TraceError("CArpsCfg::ApplyRegistryChanges", (S_FALSE == hr)? S_OK : hr);
    return hr;
}

// INetCfgComponentSetup
STDMETHODIMP CArpsCfg::Install (DWORD dwSetupFlags)
{
    m_fSaveRegistry = TRUE;
    m_fRemoving = FALSE;
    return S_OK;
}

STDMETHODIMP CArpsCfg::Upgrade( DWORD dwSetupFlags,
                                DWORD dwUpgradeFomBuildNo )
{
    return S_FALSE;
}

STDMETHODIMP CArpsCfg::ReadAnswerFile(PCWSTR pszAnswerFile,
                                      PCWSTR pszAnswerSection)
{
    return S_OK;
}

STDMETHODIMP CArpsCfg::Removing ()
{
    m_fRemoving = TRUE;
    return S_OK;
}

// INetCfgBindNotify

STDMETHODIMP CArpsCfg::QueryBindingPath (DWORD dwChangeFlag,
                                         INetCfgBindingPath* pncbpItem )
{
    // OK to bind request
    return S_OK;
}

STDMETHODIMP CArpsCfg::NotifyBindingPath (DWORD dwChangeFlag,
                                          INetCfgBindingPath* pncbp )
{
    Assert(!(dwChangeFlag & NCN_ADD && dwChangeFlag & NCN_REMOVE));
    Assert(!(dwChangeFlag & NCN_ENABLE && dwChangeFlag & NCN_DISABLE));

    // If we are told to add a card, we must be told at the same time whether the
    // binding is enabled or disabled
    Assert(FImplies((dwChangeFlag & NCN_ADD),
                    ((dwChangeFlag & NCN_ENABLE)||(dwChangeFlag & NCN_DISABLE))));

    // We handle NCN_ADD and NCN_REMOVE only:
    // NCN_ADD:     if item not on list, add a new item
    //
    // NCN_REMOVE:  if item already on list, remove the item

    // We do this in NotifyBindingPath because we only want to do this
    // once for each binding change between arps and the card.
    // If NotifyBindingInterface was used, we will get notified multiple
    // times if the interface is on multiple paths.

    HRESULT hr = S_OK;

    Validate_INetCfgBindNotify_NotifyBindingPath(dwChangeFlag, pncbp);

    INetCfgComponent * pnccLastComponent;

    hr = HrGetLastComponentAndInterface(pncbp, &pnccLastComponent, NULL);

    if (SUCCEEDED(hr))
    {
        GUID guidNetClass;
        hr = pnccLastComponent->GetClassGuid (&guidNetClass);

        AssertSz(IsEqualGUID(guidNetClass, GUID_DEVCLASS_NET), "Why the last component on the path is not an adapter?");

        if (IsEqualGUID(guidNetClass, GUID_DEVCLASS_NET))
        {
            // If we are adding/removing cards, set m_fSaveRegistry
            // so we apply the changes to registry
            if ((dwChangeFlag & NCN_ADD) || (dwChangeFlag & NCN_REMOVE))
                m_fSaveRegistry = TRUE;

            if (dwChangeFlag & NCN_ADD)
            {
                hr = HrAddAdapter(pnccLastComponent);
            }

            if(dwChangeFlag & NCN_ENABLE)
            {
                hr = HrBindAdapter(pnccLastComponent);
            }

            if(dwChangeFlag & NCN_DISABLE)
            {
                hr = HrUnBindAdapter(pnccLastComponent);
            }

            if (dwChangeFlag & NCN_REMOVE)
            {
                hr = HrRemoveAdapter(pnccLastComponent);
            }
        }
        ReleaseObj (pnccLastComponent);
    }

    Validate_INetCfgBindNotify_NotifyBindingPath_Return(hr);

    TraceError("CArpsCfg::NotifyBindingPath", hr);
    return hr;
}

// INetCfgProperties
STDMETHODIMP CArpsCfg::QueryPropertyUi(IUnknown* pUnk) 
{
    HRESULT hr = S_FALSE;
    if (pUnk)
    {
        // Is this a lan connection ?
        INetLanConnectionUiInfo * pLanConnUiInfo;
        hr = pUnk->QueryInterface( IID_INetLanConnectionUiInfo,
                                   reinterpret_cast<LPVOID *>(&pLanConnUiInfo));

        if(FAILED(hr))
        {
            hr = S_FALSE;
        }
    }

    TraceError("CArpsCfg::SetContext", hr);
    return hr;
}

STDMETHODIMP CArpsCfg::SetContext(IUnknown * pUnk)
{
    HRESULT hr = S_OK;

    // release previous context, if any
    if (m_pUnkContext)
        ReleaseObj(m_pUnkContext);
    m_pUnkContext = NULL;

    if (pUnk) // set the new context
    {
        m_pUnkContext = pUnk;
        m_pUnkContext->AddRef();
    }

    TraceError("CArpsCfg::SetContext", hr);
    return hr;
}

STDMETHODIMP CArpsCfg::MergePropPages(
    IN OUT DWORD* pdwDefPages,
    OUT LPBYTE* pahpspPrivate,
    OUT UINT* pcPages,
    IN HWND hwndParent,
    OUT PCWSTR* pszStartPage)
{
    HRESULT hr = S_OK;

    // Initialize output parameter
    HPROPSHEETPAGE *ahpsp = NULL;
    int cPages = 0;

    Validate_INetCfgProperties_MergePropPages (
        pdwDefPages, pahpspPrivate, pcPages, hwndParent, pszStartPage);

    // We don't want any default pages to be shown
    *pdwDefPages = 0;
    *pcPages = NULL;
    *pahpspPrivate = NULL;

    // get the connection context in which we are bringing up the UI
    hr = HrSetConnectionContext();

    if SUCCEEDED(hr)
    {
        // Initialize the common controls library
        INITCOMMONCONTROLSEX icc;
        icc.dwSize = sizeof(icc);
        icc.dwICC  = ICC_INTERNET_CLASSES;

        SideAssert(InitCommonControlsEx(&icc));

        hr = HrSetupPropSheets(&ahpsp, &cPages);
        if (SUCCEEDED(hr))
        {
            *pahpspPrivate = (LPBYTE)ahpsp;
            *pcPages = cPages;
        }
        else
        {
            *pcPages = 0;
            CoTaskMemFree(ahpsp);

        }
    }
    Validate_INetCfgProperties_MergePropPages_Return(hr);

    TraceError("CArpsCfg::MergePropPages", hr);
    return hr;
}

STDMETHODIMP CArpsCfg::ValidateProperties(HWND hwndSheet)
{
    return S_OK;
}

STDMETHODIMP CArpsCfg::CancelProperties()
{
    // Release second memory info
    delete m_pSecondMemoryAdapterInfo;
    m_pSecondMemoryAdapterInfo = NULL;

    return S_OK;
}

STDMETHODIMP CArpsCfg::ApplyProperties()
{
    HRESULT hr = S_OK;

    if(!m_fSaveRegistry)
        m_fSaveRegistry = m_fSecondMemoryModified;

    if (!m_fReconfig)
        m_fReconfig = m_fSecondMemoryModified;

    // Copy info from second memory state to first memory state
    if (m_fSecondMemoryModified)
    {
        hr = HrSaveAdapterInfo();
    }

    // Release second memory info
    delete m_pSecondMemoryAdapterInfo;
    m_pSecondMemoryAdapterInfo = NULL;

    TraceError("CArpsCfg::ApplyProperties", hr);
    return hr;
}

//
// CArpsAdapterInfo
//
CArpsAdapterInfo & CArpsAdapterInfo::operator=(const CArpsAdapterInfo & info)
{
    Assert(this != &info);

    if (this == &info)
        return *this;

    m_strBindName = info.m_strBindName;

    m_BindingState = info.m_BindingState;

    m_dwSapSelector = info.m_dwSapSelector;
    m_dwOldSapSelector = info.m_dwOldSapSelector;

    CopyColString(&m_vstrRegisteredAtmAddrs, info.m_vstrRegisteredAtmAddrs);
    CopyColString(&m_vstrOldRegisteredAtmAddrs, info.m_vstrOldRegisteredAtmAddrs);

    CopyColString(&m_vstrMulticastIpAddrs, info.m_vstrMulticastIpAddrs);
    CopyColString(&m_vstrOldMulticastIpAddrs, info.m_vstrOldMulticastIpAddrs);

    m_fDeleted = info.m_fDeleted;

    return *this;
}

HRESULT CArpsAdapterInfo::HrSetDefaults(PCWSTR pszBindName)
{
    HRESULT hr = S_OK;

    AssertSz(pszBindName, "NULL BindName passed to CArpsAdapterInfo::HrSetDefaults.");

    m_strBindName = pszBindName;

    m_BindingState = BIND_UNSET;

    // SAP selector
    m_dwSapSelector = c_dwDefSapSel;
    m_dwOldSapSelector = c_dwDefSapSel;

    // registered atm address
    FreeCollectionAndItem(m_vstrRegisteredAtmAddrs);
    m_vstrRegisteredAtmAddrs.push_back(new tstring(c_szDefRegAddrs));
    CopyColString(&m_vstrOldRegisteredAtmAddrs, m_vstrRegisteredAtmAddrs);

    // multicast ip address
    FreeCollectionAndItem(m_vstrMulticastIpAddrs);
    m_vstrMulticastIpAddrs.push_back(new tstring(c_szDefMCAddr1));
    m_vstrMulticastIpAddrs.push_back(new tstring(c_szDefMCAddr2));
    CopyColString(&m_vstrOldMulticastIpAddrs, m_vstrMulticastIpAddrs);

    m_fDeleted = FALSE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\arpsobj.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A R P S O B J . H
//
//  Contents:   CArpsCfg declaration
//
//  Notes:
//
//  Author:     tongl   12 Mar 1997
//
//-----------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include "atmutil.h"
#include "resource.h"

// Reg key value names for parameters
static const WCHAR c_szSapSel[] = L"Selector";
static const WCHAR c_szRegAddrs[] = L"RegisteredAddresses";
static const WCHAR c_szMCAddrs[] = L"MulticastAddresses";

// Default parameter values
static const c_dwDefSapSel = 0;
static const WCHAR c_szDefRegAddrs[] =
            L"4700790001020000000000000000A03E00000200";
#pragma warning( disable : 4125 )
static const WCHAR c_szDefMCAddr1[] = L"224.0.0.1-239.255.255.255";
static const WCHAR c_szDefMCAddr2[] = L"255.255.255.255-255.255.255.255";
#pragma warning( default : 4125 )

//
// parameter data structure
//

class CArpsAdapterInfo
{
public:

    CArpsAdapterInfo() {};
    ~CArpsAdapterInfo(){};

    CArpsAdapterInfo &  operator=(const CArpsAdapterInfo & AdapterInfo);  // copy operator
    HRESULT HrSetDefaults(PCWSTR pszBindName);

    // the adapter's binding state
    AdapterBindingState    m_BindingState;

    // Instance Guid of net card
    tstring m_strBindName;

    // SAP selector
    DWORD m_dwSapSelector;
    DWORD m_dwOldSapSelector;

    // Registered ATM Address
    VECSTR m_vstrRegisteredAtmAddrs;
    VECSTR m_vstrOldRegisteredAtmAddrs;

    // Multicast IP address
    VECSTR m_vstrMulticastIpAddrs;
    VECSTR m_vstrOldMulticastIpAddrs;

    // flags
    BOOL    m_fDeleted;
};

typedef list<CArpsAdapterInfo*> ARPS_ADAPTER_LIST;

/////////////////////////////////////////////////////////////////////////////
// ArpsCfg

class ATL_NO_VTABLE CArpsCfg :
    public CComObjectRoot,
    public CComCoClass<CArpsCfg, &CLSID_CArpsCfg>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyBinding,
    public INetCfgComponentPropertyUi
{
public:
    CArpsCfg();
    ~CArpsCfg();

    BEGIN_COM_MAP(CArpsCfg)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CArpsCfg)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_ARPSCFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (Install)         (DWORD dwSetupFlags);
    STDMETHOD (Upgrade)         (DWORD dwSetupFlags,
                                 DWORD dwUpgradeFomBuildNo );
    STDMETHOD (ReadAnswerFile)  (PCWSTR pszAnswerFile,
                                 PCWSTR pszAnswerSection);
    STDMETHOD (Removing)();

// INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

// INetCfgProperties
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk);
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk);
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

// help functions
    CArpsAdapterInfo * GetSecondMemoryAdapterInfo()
    {
        return m_pSecondMemoryAdapterInfo;
    }

    void SetSecondMemoryModified()
    {
        m_fSecondMemoryModified = TRUE;
    }

// Private state info and help functions
private:

    // Place to keep corresponding component object, i.e. ATMARPS
    INetCfgComponent    *m_pnccArps;

    // Place to keep the pointer to UI context
    IUnknown * m_pUnkContext;

    // (STL) List of adapter info structures
    ARPS_ADAPTER_LIST    m_listAdapters;

    // Guid of the current connection
    tstring m_strGuidConn;

    // Second memory adapter info structures
    CArpsAdapterInfo *   m_pSecondMemoryAdapterInfo;

    // Do we need to update registry on Apply
    BOOL    m_fSaveRegistry;
    BOOL    m_fReconfig;
    BOOL    m_fSecondMemoryModified;
    BOOL    m_fRemoving;

    // property page
    class CArpsPage * m_arps;

    // Update registry with contents of m_listAdapters
    HRESULT HrSaveSettings();

    HRESULT HrLoadSettings();
    HRESULT HrLoadArpsRegistry(HKEY hkey);

    // Set the default parameter values to registry
    HRESULT HrSetDefaultAdapterParam(HKEY hkey);

    // Handling add or remove a card in memory
    HRESULT HrAddAdapter(INetCfgComponent * pncc);
    HRESULT HrRemoveAdapter(INetCfgComponent * pncc);

    HRESULT HrBindAdapter(INetCfgComponent * pnccAdapter);
    HRESULT HrUnBindAdapter(INetCfgComponent * pnccAdapter);

    HRESULT HrSetConnectionContext();

    HRESULT HrSetupPropSheets(HPROPSHEETPAGE ** pahpsp, INT * pcPages);

    // load and save adapter parameters to second memory
    HRESULT HrLoadAdapterInfo();
    HRESULT HrSaveAdapterInfo();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\atmhelp.h ===
#define IDH_ARPS_MUL_LOWER_IP	30000001
#define IDH_ARPS_MUL_UPPER_IP	30000003
#define IDH_LVW_ARPS_REG_ADDR	30000051
#define IDH_PSH_ARPS_REG_ADD	30000052
#define IDH_PSH_ARPS_REG_EDT	30000053
#define IDH_PSH_ARPS_REG_RMV	30000054
#define IDH_LVW_ARPS_MUL_ADDR	30000057
#define IDH_PSH_ARPS_MUL_ADD	30000058
#define IDH_PSH_ARPS_MUL_EDT	30000059
#define IDH_PSH_ARPS_MUL_RMV	30000060
#define IDH_EDT_ARPS_REG_Address	30000101
#define IDH_CMB_PVC_Layer2	30000153
#define IDH_EDT_PVC_User_Layer2	30000155
#define IDH_CMB_PVC_Layer3	30000157
#define IDH_EDT_PVC_User_Layer3	30000159
#define IDH_EDT_PVC_Layer3_IPI	30000161
#define IDH_EDT_PVC_SNAP_ID	30000163
#define IDH_CMB_PVC_High_Type	30000166
#define IDH_CMB_PVC_High_Value	30000168
#define IDH_CMB_PVC_Layer2_2	30000203
#define IDH_CMB_PVC_Layer3_2	30000207
#define IDH_CMB_PVC_High_Type_2	30000216
#define IDH_EDT_PVC_Name	30000252
#define IDH_EDT_PVC_VPI	30000254
#define IDH_EDT_PVC_VCI	30000256
#define IDH_CMB_PVC_AAL	30000258
#define IDH_CMB_PVC_Type	30000261
#define IDH_CHK_PVC_CallAddr	30000262
#define IDH_EDT_PVC_CallAddr	30000263
#define IDH_CHK_PVC_AnswerAddr	30000264
#define IDH_EDT_PVC_AnswerAddr	30000265
#define IDH_PBN_PVC_Advanced	30000266
#define IDH_EDT_PVC_TRANS_PEAK	30000302
#define IDH_EDT_PVC_TRANS_AVG	30000304
#define IDH_EDT_PVC_TRANS_BURST	30000306
#define IDH_EDT_PVC_TRANS_MAX_SIZE	30000308
#define IDH_CMB_PVC_TRANS_SERVICE	30000310
#define IDH_EDT_PVC_RECEIVE_PEAK	30000313
#define IDH_EDT_PVC_RECEIVE_AVG	30000315
#define IDH_EDT_PVC_RECEIVE_BURST	30000317
#define IDH_EDT_PVC_RECEIVE_MAX_SIZE	30000319
#define IDH_CMB_PVC_RECEIVE_SERVICE	30000321
#define IDH_LVW_PVC_LIST	30000351
#define IDH_PBN_PVC_Add	30000352
#define IDH_PBN_PVC_Remove	30000353
#define IDH_PBN_PVC_Properties	30000354


const DWORD g_aHelpIDs_IDD_ARPS_MUL_ADDR[]=
{
	IDC_ARPS_MUL_LOWER_IP, IDH_ARPS_MUL_LOWER_IP,
	IDC_ARPS_MUL_UPPER_IP, IDH_ARPS_MUL_UPPER_IP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ARPS_PROP[]=
{
	IDC_LVW_ARPS_REG_ADDR, IDH_LVW_ARPS_REG_ADDR,
	IDC_PSH_ARPS_REG_ADD, IDH_PSH_ARPS_REG_ADD,
	IDC_PSH_ARPS_REG_EDT, IDH_PSH_ARPS_REG_EDT,
	IDC_PSH_ARPS_REG_RMV, IDH_PSH_ARPS_REG_RMV,
	IDC_LVW_ARPS_MUL_ADDR, IDH_LVW_ARPS_MUL_ADDR,
	IDC_PSH_ARPS_MUL_ADD, IDH_PSH_ARPS_MUL_ADD,
	IDC_PSH_ARPS_MUL_EDT, IDH_PSH_ARPS_MUL_EDT,
	IDC_PSH_ARPS_MUL_RMV, IDH_PSH_ARPS_MUL_RMV,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ARPS_REG_ADDR[]=
{
	IDC_EDT_ARPS_REG_Address, IDH_EDT_ARPS_REG_Address,
	0,0
};

const DWORD g_aHelpIDs_IDD_PVC_Dest[]=
{
	IDC_CMB_PVC_Layer2, IDH_CMB_PVC_Layer2,
	IDC_EDT_PVC_User_Layer2, IDH_EDT_PVC_User_Layer2,
	IDC_CMB_PVC_Layer3, IDH_CMB_PVC_Layer3,
	IDC_EDT_PVC_User_Layer3, IDH_EDT_PVC_User_Layer3,
	IDC_EDT_PVC_Layer3_IPI, IDH_EDT_PVC_Layer3_IPI,
	IDC_EDT_PVC_SNAP_ID, IDH_EDT_PVC_SNAP_ID,
	IDC_CMB_PVC_High_Type, IDH_CMB_PVC_High_Type,
	IDC_CMB_PVC_High_Value, IDH_CMB_PVC_High_Value,
	0,0
};

const DWORD g_aHelpIDs_IDD_PVC_Local[]=
{
	IDC_CMB_PVC_Layer2, IDH_CMB_PVC_Layer2_2,
	IDC_EDT_PVC_User_Layer2, IDH_EDT_PVC_User_Layer2,
	IDC_CMB_PVC_Layer3, IDH_CMB_PVC_Layer3_2,
	IDC_EDT_PVC_User_Layer3, IDH_EDT_PVC_User_Layer3,
	IDC_EDT_PVC_Layer3_IPI, IDH_EDT_PVC_Layer3_IPI,
	IDC_EDT_PVC_SNAP_ID, IDH_EDT_PVC_SNAP_ID,
	IDC_CMB_PVC_High_Type, IDH_CMB_PVC_High_Type_2,
	IDC_CMB_PVC_High_Value, IDH_CMB_PVC_High_Value,
	0,0
};

const DWORD g_aHelpIDs_IDD_PVC_Main[]=
{
	IDC_EDT_PVC_Name, IDH_EDT_PVC_Name,
	IDC_EDT_PVC_VPI, IDH_EDT_PVC_VPI,
	IDC_EDT_PVC_VCI, IDH_EDT_PVC_VCI,
	IDC_CMB_PVC_AAL, IDH_CMB_PVC_AAL,
	IDC_CMB_PVC_Type, IDH_CMB_PVC_Type,
	IDC_CHK_PVC_CallAddr, IDH_CHK_PVC_CallAddr,
	IDC_EDT_PVC_CallAddr, IDH_EDT_PVC_CallAddr,
	IDC_CHK_PVC_AnswerAddr, IDH_CHK_PVC_AnswerAddr,
	IDC_EDT_PVC_AnswerAddr, IDH_EDT_PVC_AnswerAddr,
	IDC_PBN_PVC_Advanced, IDH_PBN_PVC_Advanced,
	0,0
};

const DWORD g_aHelpIDs_IDD_PVC_Traffic[]=
{
	IDC_EDT_PVC_TRANS_PEAK, IDH_EDT_PVC_TRANS_PEAK,
	IDC_EDT_PVC_TRANS_AVG, IDH_EDT_PVC_TRANS_AVG,
	IDC_EDT_PVC_TRANS_BURST, IDH_EDT_PVC_TRANS_BURST,
	IDC_EDT_PVC_TRANS_MAX_SIZE, IDH_EDT_PVC_TRANS_MAX_SIZE,
	IDC_CMB_PVC_TRANS_SERVICE, IDH_CMB_PVC_TRANS_SERVICE,
	IDC_EDT_PVC_RECEIVE_PEAK, IDH_EDT_PVC_RECEIVE_PEAK,
	IDC_EDT_PVC_RECEIVE_AVG, IDH_EDT_PVC_RECEIVE_AVG,
	IDC_EDT_PVC_RECEIVE_BURST, IDH_EDT_PVC_RECEIVE_BURST,
	IDC_EDT_PVC_RECEIVE_MAX_SIZE, IDH_EDT_PVC_RECEIVE_MAX_SIZE,
	IDC_CMB_PVC_RECEIVE_SERVICE, IDH_CMB_PVC_RECEIVE_SERVICE,
	0,0
};

const DWORD g_aHelpIDs_IDD_UNI_PROP[]=
{
	IDC_LVW_PVC_LIST, IDH_LVW_PVC_LIST,
	IDC_PBN_PVC_Add, IDH_PBN_PVC_Add,
	IDC_PBN_PVC_Remove, IDH_PBN_PVC_Remove,
	IDH_PBN_PVC_Properties, IDH_PBN_PVC_Properties,
	0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\atmutil.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A T M U T I L . H
//
//  Contents:   Utility function declaration
//
//  Notes:
//
//  Author:     tongl   12 Mar 1997
//
//-----------------------------------------------------------------------
#pragma once
#include "ncxbase.h"

typedef vector<tstring *>   VECSTR;

static const WCHAR  c_chSeparator  = L'-';

enum AdapterBindingState
{
    BIND_ENABLE,
    BIND_DISABLE,
    BIND_UNSET
};

HRESULT HrLoadSubkeysFromRegistry(const HKEY hkeyParam,
                                  OUT VECSTR * const pvstrAdapters);

VOID GetNodeNum(PCWSTR pszIpAddress, DWORD ardw[4]);

void GetLowerIp(tstring& strIpRange, tstring * pstrLowerIp);
void GetUpperIp(tstring& strIpRange, tstring * pstrUpperIp);

BOOL IsValidIpRange(tstring& strIpLower, tstring& strIpUpper);

void MakeIpRange(tstring& strIpLower, tstring& strIpUpper, tstring * pstrNewIpRange);

void ConvertBinaryToHexString(BYTE * pbData, DWORD cbData, tstring * pstrData);
void ConvertByteToSz(BYTE * pbData, PWSTR pszByte);
void ConvertHexStringToBinaryWithAlloc(PCWSTR pszParamInHex, LPBYTE * ppbData, LPDWORD pcbData);

template<class T>
void CopyColString(T * colDest, const T & colSrc)
{
    FreeCollectionAndItem(*colDest);
    colDest->reserve(colSrc.size());

    for(T::const_iterator iter = colSrc.begin(); iter != colSrc.end(); ++iter)
    {
        colDest->push_back(new tstring(**iter));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\aunidlg.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A U N I D L G . C P P
//
//  Contents:   ATMUNI call manager dialogbox message handler implementation
//
//  Notes:
//
//  Author:     tongl   21 Mar 1997
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "arpsobj.h"
#include "auniobj.h"
#include "atmutil.h"
#include "aunidlg.h"

#include "ncatlui.h"
#include "ncstl.h"
//#include "ncui.h"

#include "atmhelp.h"

const int c_nColumns =3;
const int c_nMAX_PVC_ID_LEN =10;
//
// CUniPage
//
CUniPage::CUniPage(CAtmUniCfg * pAtmUniCfg, const DWORD * adwHelpIDs)
{
    Assert(pAtmUniCfg);
    m_patmunicfg = pAtmUniCfg;
    m_adwHelpIDs = adwHelpIDs;

    m_pAdapterInfo = pAtmUniCfg->GetSecondMemoryAdapterInfo();
    m_fModified = FALSE;
}

CUniPage::~CUniPage()
{
}

LRESULT CUniPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                               LPARAM lParam, BOOL& bHandled)
{
    // initialize PVC name list view
    int nIndex;
    m_hPVCList = GetDlgItem(IDC_LVW_PVC_LIST);

    // Calculate column width
    RECT rect;

    ::GetClientRect(m_hPVCList, &rect);
    int colWidth = (rect.right/(c_nColumns*2));

    // set the column header
    // The mask specifies that the fmt, width and pszText members
    // of the structure are valid
    LV_COLUMN lvCol = {0};
    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT ;
    lvCol.fmt = LVCFMT_LEFT;   // left-align column

    // Add the two columns and header text.
    for (nIndex = 0; nIndex < c_nColumns; nIndex++)
    {
        // column header text
        if (0 == nIndex) // first column
        {
            lvCol.cx = colWidth*4;
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_PVC_NAME);
        }
        else if (1 == nIndex)
        {
            lvCol.cx = colWidth;
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_PVC_VPI);
        }
        else if (2 == nIndex)
        {
            lvCol.cx = colWidth;
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_PVC_VCI);
        }

        int iNewItem = ListView_InsertColumn(GetDlgItem(IDC_LVW_PVC_LIST),
                                             nIndex, &lvCol);

        AssertSz((iNewItem == nIndex), "Invalid item inserted to list view !");
    }

    // insert existing PVCs into the list view
    int idx =0;

    for (PVC_INFO_LIST::iterator iterPvc = m_pAdapterInfo->m_listPVCs.begin();
         iterPvc != m_pAdapterInfo->m_listPVCs.end();
         iterPvc ++)
    {
        if ((*iterPvc)->m_fDeleted)
            continue;

        InsertNewPvc(*iterPvc, idx);
        idx++;
    }

    // select the first item
    ListView_SetItemState(GetDlgItem(IDC_LVW_PVC_LIST), 0, LVIS_SELECTED, LVIS_SELECTED);

    SetButtons();
    return 0;
}

LRESULT CUniPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CUniPage::OnHelp(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CUniPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    if (!IsModified())
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
        return nResult;
    }

    m_patmunicfg->SetSecondMemoryModified();
    SetModifiedTo(FALSE);   // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}

LRESULT CUniPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL err = FALSE;

    // Error checking: unique Vci\Vpi pair
    int iDupPvcIdx = CheckDupPvcId();

    if (iDupPvcIdx >=0)
    {
        NcMsgBox(m_hWnd, IDS_MSFT_UNI_TEXT, IDS_DUPLICATE_PVC,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        ListView_SetItemState(GetDlgItem(IDC_LVW_PVC_LIST), iDupPvcIdx,
                              LVIS_SELECTED, LVIS_SELECTED);
        err = TRUE;
    }

    return err;
}

int CUniPage::CheckDupPvcId()
{
    int ret = -1;
    int idx = 0;

    for(PVC_INFO_LIST::iterator iterPvc = m_pAdapterInfo->m_listPVCs.begin();
        iterPvc != m_pAdapterInfo->m_listPVCs.end();
        iterPvc ++)
    {
        if ((*iterPvc)->m_fDeleted)
            continue;

        PVC_INFO_LIST::iterator iterPvcComp = iterPvc;

        iterPvcComp ++;
        while (iterPvcComp != m_pAdapterInfo->m_listPVCs.end())
        {
            if (!(*iterPvcComp)->m_fDeleted)
            {
                if ( ((*iterPvc)->m_dwVpi == (*iterPvcComp)->m_dwVpi) &&
                     ((*iterPvc)->m_dwVci == (*iterPvcComp)->m_dwVci))
                {
                    // we find a duplicate address
                    ret = idx;
                    break;
                }
            }
            iterPvcComp++;
        }

        // duplicate address found
        if (ret >=0 )
            break;

        // move next
        idx ++;
    }

    return ret;
}

LRESULT CUniPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CUniPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CUniPage::OnAddPVC(WORD wNotifyCode, WORD wID,
                           HWND hWndCtl, BOOL& bHandled)
{
    // make a new PVC Info structure and pass to the dialog
    tstring strNewPvcId;
    GetNewPvcId(m_pAdapterInfo, &strNewPvcId);

    CPvcInfo * pDlgPvcInfo = new CPvcInfo(strNewPvcId.c_str());

	if (pDlgPvcInfo == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    pDlgPvcInfo->m_dwPVCType = PVC_CUSTOM;
    pDlgPvcInfo->SetDefaults(PVC_CUSTOM);

    CPVCMainDialog * pPvcMainDlg = new CPVCMainDialog(this, pDlgPvcInfo,
                                                      g_aHelpIDs_IDD_PVC_Main);
	if (pPvcMainDlg == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    if (pPvcMainDlg->DoModal() == IDOK)
    {
        // add the new PVC
        m_pAdapterInfo->m_listPVCs.push_back(pDlgPvcInfo);

        int nCount = ListView_GetItemCount(m_hPVCList);

        // insert the new item at the end of list
        InsertNewPvc(pDlgPvcInfo, nCount);

        SetButtons();
        PageModified();
    }
    else
    {
        delete pDlgPvcInfo;
    }

    delete pPvcMainDlg;
    return 0;
}

LRESULT CUniPage::OnPVCProperties(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& bHandled)
{
    // mark the PVC as deleted and from the list view
    // get the current selected item and remove it
    int iSelected = ListView_GetNextItem(m_hPVCList, -1, LVNI_SELECTED);

    if (iSelected != -1)
    {
        LV_ITEM lvItem;
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iSelected;
        lvItem.iSubItem = 0;

        if (ListView_GetItem(m_hPVCList, &lvItem))
        {
            CPvcInfo * pPvcInfo = NULL;

            pPvcInfo = reinterpret_cast<CPvcInfo *>(lvItem.lParam);

            if (pPvcInfo)
            {
                CPvcInfo * pDlgPvcInfo = new CPvcInfo(pPvcInfo->m_strPvcId.c_str());

                if (pDlgPvcInfo)
                {
					*pDlgPvcInfo = *pPvcInfo;

					CPVCMainDialog * pPvcMainDlg = new CPVCMainDialog(this, pDlgPvcInfo,
  																	g_aHelpIDs_IDD_PVC_Main);

					if (pPvcMainDlg->DoModal() == IDOK)
					{
						// update PVC info
						*pPvcInfo = *pDlgPvcInfo;

						// update the list view
						UpdatePvc(pDlgPvcInfo, iSelected);

						// set the new state of the Add\Remove\Property buttons
						SetButtons();

						if (pPvcMainDlg->m_fDialogModified)
							PageModified();
					}

					delete pDlgPvcInfo;

					delete pPvcMainDlg;
				}
            }
        }
    }
    else // no current selection
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_UNI_TEXT, IDS_NO_ITEM_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }
    return 0;
}

LRESULT CUniPage::OnRemovePVC(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& bHandled)
{
    // get the selected PVC, make a copy and pass to the dialog
    int iSelected = ListView_GetNextItem(m_hPVCList, -1, LVNI_SELECTED);

    if (iSelected != -1)
    {
        LV_ITEM lvItem;
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iSelected;
        lvItem.iSubItem = 0;

        if (ListView_GetItem(m_hPVCList, &lvItem))
        {
            CPvcInfo * pPvcInfo = NULL;

            pPvcInfo = reinterpret_cast<CPvcInfo *>(lvItem.lParam);
            if (pPvcInfo)
            {
                // mark as deleted
                pPvcInfo->m_fDeleted = TRUE;

                // delete from list view
                ListView_DeleteItem(m_hPVCList, iSelected);
            }
        }

        SetButtons();
        PageModified();
    }

    return 0;
}

LRESULT CUniPage::OnPVCListChange(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& bHandled)
{
    return 0;
}

void CUniPage::InsertNewPvc(CPvcInfo * pPvcInfo, int idx)
{
    LV_ITEM lvItem = {0};
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;

    int ret;

    // name
    lvItem.iItem = idx;
    lvItem.iSubItem=0;
    lvItem.lParam = reinterpret_cast<LPARAM>(pPvcInfo);
    lvItem.pszText = (PWSTR)(pPvcInfo->m_strName.c_str());

    ret = ListView_InsertItem(m_hPVCList, &lvItem);

    // VPI
    lvItem.iItem = idx;
    lvItem.iSubItem=1;

    WCHAR szVpi[MAX_VPI_LENGTH];
    wsprintfW(szVpi, c_szItoa, pPvcInfo->m_dwVpi);
    lvItem.pszText = szVpi;

    SendDlgItemMessage(IDC_LVW_PVC_LIST, LVM_SETITEMTEXT, idx, (LPARAM)&lvItem);

    // VCI
    lvItem.iItem = idx;
    lvItem.iSubItem=2;

    WCHAR szVci[MAX_VCI_LENGTH];
    wsprintfW(szVci, c_szItoa, pPvcInfo->m_dwVci);
    lvItem.pszText = szVci;

    SendDlgItemMessage(IDC_LVW_PVC_LIST, LVM_SETITEMTEXT, idx, (LPARAM)&lvItem);
}

void CUniPage::UpdatePvc(CPvcInfo * pPvcInfo, int idx)
{
    LV_ITEM lvItem = {0};
    lvItem.mask = LVIF_TEXT;

    int ret;

    // name
    lvItem.iItem = idx;
    lvItem.iSubItem=0;
    lvItem.pszText = (PWSTR)(pPvcInfo->m_strName.c_str());

    ret = SendDlgItemMessage(IDC_LVW_PVC_LIST, LVM_SETITEMTEXT, idx, (LPARAM)&lvItem);

    // VPI
    lvItem.iItem = idx;
    lvItem.iSubItem=1;

    WCHAR szVpi[MAX_VPI_LENGTH];
    wsprintfW(szVpi, c_szItoa, pPvcInfo->m_dwVpi);
    lvItem.pszText = szVpi;

    ret = SendDlgItemMessage(IDC_LVW_PVC_LIST, LVM_SETITEMTEXT, idx, (LPARAM)&lvItem);

    // VCI
    lvItem.iItem = idx;
    lvItem.iSubItem=2;

    WCHAR szVci[MAX_VCI_LENGTH];
    wsprintfW(szVci, c_szItoa, pPvcInfo->m_dwVci);
    lvItem.pszText = szVci;

    ret = SendDlgItemMessage(IDC_LVW_PVC_LIST, LVM_SETITEMTEXT, idx, (LPARAM)&lvItem);
}

void CUniPage::SetButtons()
{
    int nCount = ListView_GetItemCount(m_hPVCList);

    if (nCount == 0)
        ::SetFocus(m_hPVCList);

    ::EnableWindow(GetDlgItem(IDC_PBN_PVC_Remove), nCount);
    ::EnableWindow(GetDlgItem(IDC_PBN_PVC_Properties), nCount);

}

void CUniPage::GetNewPvcId(CUniAdapterInfo * pAdapterInfo,
                           tstring * pstrNewPvcId)
{
    Assert(pstrNewPvcId);

    tstring strPvcId;
    WCHAR szPvcId[c_nMAX_PVC_ID_LEN];

    int uiPvcNum = pAdapterInfo->m_listPVCs.size();
    _itow(uiPvcNum, szPvcId, 10);
    strPvcId = c_szPVC;
    strPvcId += szPvcId;

    while (!IsUniquePvcId(pAdapterInfo, strPvcId))
    {
        uiPvcNum++;
        _itow(uiPvcNum, szPvcId, 10);
        strPvcId = c_szPVC;
        strPvcId += szPvcId;
    }

    *pstrNewPvcId = strPvcId;
}

BOOL CUniPage::IsUniquePvcId(CUniAdapterInfo * pAdapterInfo,
                             tstring& strNewPvcId)
{
    BOOL fUnique = TRUE;

    for (PVC_INFO_LIST::iterator iterPvcInfo = pAdapterInfo->m_listPVCs.begin();
         iterPvcInfo != pAdapterInfo->m_listPVCs.end();
         iterPvcInfo++)
    {
        if (strNewPvcId == (*iterPvcInfo)->m_strName)
        {
            fUnique = FALSE;
            break;
        }
    }
    return fUnique;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\aunidlg.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A U N I D L G . H
//
//  Contents:   ATMUNI call manager dialogbox message handler declaration
//
//  Notes:
//
//  Author:     tongl   21 Mar 1997
//
//-----------------------------------------------------------------------
#pragma once
#include "ncxbase.h"
#include "ncatlps.h"

class CPvcInfo;

const WCHAR c_szItoa[] = L"%d";

const int MAX_VPI_LENGTH = 3;
const int MAX_VCI_LENGTH = 4;

void InitComboWithStringArray(HWND hwndDlg, int nIDDlgItem,
                              int csid, const int*  asid);

void SetDwordEdtField(HWND hDlg, DWORD dwData, int nIDDlgItem);
void GetDwordEdtField(HWND hDlg, DWORD * pdwData, int nIDDlgItem);

void ShowContextHelp(HWND hDlg, UINT uCommand, const DWORD*  pdwHelpIDs);

// ATM UNI Property Dialog
class CUniPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CUniPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)

        // Message handlers for the push buttons
        COMMAND_ID_HANDLER(IDC_PBN_PVC_Add, OnAddPVC)
        COMMAND_ID_HANDLER(IDC_PBN_PVC_Remove, OnRemovePVC)
        COMMAND_ID_HANDLER(IDC_PBN_PVC_Properties, OnPVCProperties)

        // Message handlers for the PVC list view
        COMMAND_ID_HANDLER(IDC_LVW_PVC_LIST, OnPVCListChange)
    END_MSG_MAP()

    // Constructors/Destructors
    CUniPage(CAtmUniCfg * pAtmUniCfg, const DWORD * padwHelpIDs = NULL);
    ~CUniPage();

    // Command handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // command handlers
    LRESULT OnAddPVC(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRemovePVC(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPVCProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnPVCListChange(WORD wNotifyCode, WORD wID,
                            HWND hWndCtl, BOOL& bHandled);

private:
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}

    void PageModified() {
                            m_fModified = TRUE;
                            PropSheet_Changed(GetParent(), m_hWnd);
                        }

    void SetButtons();
    void GetNewPvcId(CUniAdapterInfo * pAdapterInfo, tstring * pstrNewPvcId);
    BOOL IsUniquePvcId(CUniAdapterInfo * pAdapterInfo, tstring& strNewPvcId);

    void InsertNewPvc(CPvcInfo * pPvcInfo, int idx);
    void UpdatePvc(CPvcInfo * pPvcInfo, int idx);

    int CheckDupPvcId();

    // data members
    CAtmUniCfg *m_patmunicfg;
    CUniAdapterInfo *   m_pAdapterInfo;
    HWND    m_hPVCList;

    BOOL            m_fModified;
    const DWORD*    m_adwHelpIDs;
};

// The main PVC dialog
class CPVCMainDialog : public CDialogImpl<CPVCMainDialog>
{
public:

    enum { IDD = IDD_PVC_Main };

    BEGIN_MSG_MAP(CPVCMainDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        COMMAND_ID_HANDLER(IDC_CMB_PVC_Type,        OnType);
        COMMAND_ID_HANDLER(IDC_CHK_PVC_CallAddr,    OnSpecifyCallAddr);
        COMMAND_ID_HANDLER(IDC_CHK_PVC_AnswerAddr,  OnSpecifyAnswerAddr);
        COMMAND_ID_HANDLER(IDC_PBN_PVC_Advanced,    OnAdvanced);

    END_MSG_MAP()

public:

    CPVCMainDialog(CUniPage * pUniPage,
                   CPvcInfo *  pPvcInfo,
                   const DWORD* padwHelpIDs = NULL);
    ~CPVCMainDialog();

// Dialog creation overrides
public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnType(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnSpecifyCallAddr(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnSpecifyAnswerAddr(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnAdvanced(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

public:
    BOOL    m_fDialogModified;

    BOOL    m_fPropShtOk;
    BOOL    m_fPropShtModified;

private:

    // The PVC we are adding or modifying
    CPvcInfo *   m_pPvcInfo ;

    // The current application type of the PVC
    PVCType m_CurType;

    // We save the pointer to the parent dialog
    CUniPage *      m_pParentDlg;
    const DWORD*    m_adwHelpIDs;

    class CPvcQosPage   * m_pQosPage;
    class CPvcLocalPage * m_pLocalPage;
    class CPvcDestPage  * m_pDestPage;

    // help functions
    void InitInfo();
    void SetInfo();

    void UpdateInfo();

    HRESULT HrDoPvcPropertySheet(CPvcInfo * pPvcInfoDlg);
    HRESULT HrSetupPropPages(CPvcInfo * pPvcInfoDlg, HPROPSHEETPAGE ** pahpsp, INT * pcPages);
};

class CPvcQosPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CPvcQosPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)
    END_MSG_MAP()

    // Constructors/Destructors
    CPvcQosPage(CPVCMainDialog * pParentDlg, CPvcInfo * pPvcInfo, const DWORD * padwHelpIDs = NULL);
    ~CPvcQosPage();

public:
    // Command handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

private:
    void SetQosServiceCategory(ATM_SERVICE_CATEGORY dwServiceType, int nIDDlgItem);
    void GetQosServiceCategory(ATM_SERVICE_CATEGORY * pdwServiceType, int nIDDlgItem);

    // data
    CPVCMainDialog * m_pParentDlg;
    CPvcInfo    *    m_pPvcInfo;
    const DWORD *    m_adwHelpIDs;
};

class CPvcLocalPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CPvcLocalPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)

        // Control notification handlers
        COMMAND_ID_HANDLER(IDC_CMB_PVC_Layer2,      OnLayer2);
        COMMAND_ID_HANDLER(IDC_CMB_PVC_Layer3,      OnLayer3);
        COMMAND_ID_HANDLER(IDC_CMB_PVC_High_Type,   OnHighLayer);

    END_MSG_MAP()

    // Constructors/Destructors
    CPvcLocalPage(CPVCMainDialog * pParentDlg, CPvcInfo * pPvcInfo, const DWORD * padwHelpIDs = NULL);
    ~CPvcLocalPage();

    // Command handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // Control notification handlers
    LRESULT OnLayer2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnLayer3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnHighLayer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

private:
    // data
    CPVCMainDialog * m_pParentDlg;
    CPvcInfo    *    m_pPvcInfo;
    const DWORD *    m_adwHelpIDs;
};

class CPvcDestPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CPvcDestPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)

        // Control notification handlers
        COMMAND_ID_HANDLER(IDC_CMB_PVC_Layer2,      OnLayer2);
        COMMAND_ID_HANDLER(IDC_CMB_PVC_Layer3,      OnLayer3);
        COMMAND_ID_HANDLER(IDC_CMB_PVC_High_Type,   OnHighLayer);
    END_MSG_MAP()

    // Constructors/Destructors
    CPvcDestPage(CPVCMainDialog * pParentDlg, CPvcInfo * pPvcInfo, const DWORD * padwHelpIDs = NULL);
    ~CPvcDestPage();

    // Command handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

     // Control notification handlers
    LRESULT OnLayer2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnLayer3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnHighLayer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

private:

    // data
    CPVCMainDialog * m_pParentDlg;
    CPvcInfo    *    m_pPvcInfo;
    const DWORD *    m_adwHelpIDs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\aunifunc.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A U N I F U N C . C P P
//
//  Contents:   CAtmUniCfg help member function implementation
//
//  Notes:
//
//  Author:     tongl   21 Mar 1997
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "auniobj.h"
#include "aunidlg.h"
#include "atmutil.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "ncstl.h"
#include "ncatlui.h"
//#include "ncui.h"

#include "netconp.h"
#include "atmhelp.h"

extern const WCHAR c_szAdapters[];

//
// Load cards on bind path to m_listAdapters on Initialize
//
HRESULT CAtmUniCfg::HrLoadSettings()
{
    HRESULT hr = S_OK;

    CIterNetCfgBindingPath      ncbpIter(m_pnccUni);
    INetCfgBindingPath *        pncbp;

    // Go through all binding paths in search of uni call mgr to netcard bindings
    while(SUCCEEDED(hr) && (hr = ncbpIter.HrNext(&pncbp)) == S_OK)
    {
        INetCfgComponent * pnccNetComponent;
        hr = HrGetLastComponentAndInterface(pncbp,
                                            &pnccNetComponent,
                                            NULL);
        if SUCCEEDED(hr)
        {
            Assert(pnccNetComponent);

            // The last component should be of NET CLASS
            GUID    ClassGuid;

            // What type is it?
            hr = pnccNetComponent->GetClassGuid(&ClassGuid);
            if (SUCCEEDED(hr))
            {
                // Is it a netcard?
                if (IsEqualGUID(ClassGuid, GUID_DEVCLASS_NET))
                {
                    hr = HrAddAdapter(pnccNetComponent);

                    if (SUCCEEDED(hr))
                    {
                        // Is the binding enabled ??
                        hr = pncbp->IsEnabled();

                        // hr == S_OK if the card is enabled (ie: bound)
                        if (S_OK == hr)
                        {   // bind the card in our data strucutres
                            hr = HrBindAdapter(pnccNetComponent);
                        }
                        else if (S_FALSE == hr)
                        {
                            hr = HrUnBindAdapter(pnccNetComponent);
                        }
                    }
                }
            }

            ReleaseObj(pnccNetComponent);
        }
        ReleaseObj(pncbp);
    }
    AssertSz(!pncbp, "BindingPath wasn't released");

    if (hr == S_FALSE) // We just got to the end of the loop
        hr = S_OK;

    TraceError("CAtmUniCfg::HrLoadSettings", hr);
    return hr;
}

//
// Update registry with info in m_listAdapters on Apply
//
HRESULT CAtmUniCfg::HrSaveSettings()
{
    HRESULT hr = S_OK;
    HKEY hkeyUniParam = NULL;

    hr = m_pnccUni->OpenParamKey(&hkeyUniParam);

    if SUCCEEDED(hr)
    {
        HKEY hkeyAdapters = NULL;
        DWORD dwDisposition;

        // Create or open the "Adapters" key under "Services\Atmuni\Parameters"
        hr = HrRegCreateKeyEx(hkeyUniParam,
                              c_szAdapters,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hkeyAdapters,
                              &dwDisposition);

        if SUCCEEDED(hr)
        {
            Assert(hkeyAdapters);
            HRESULT hrTmp = S_OK;

            if (dwDisposition == REG_OPENED_EXISTING_KEY)
            { // if the "adapters" key existed, there might be some old cards
              // Cleanup subkeys for adapters that are not in our memory structure

                VECSTR vstrAdapters;
                hrTmp = HrLoadSubkeysFromRegistry(hkeyAdapters, &vstrAdapters);

                if SUCCEEDED(hrTmp)
                {
                    for (VECSTR::iterator iterRegKey = vstrAdapters.begin();
                         iterRegKey != vstrAdapters.end();
                         iterRegKey ++)
                    {
                        BOOL fFound = FALSE;
                        for (UNI_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
                             iterAdapter != m_listAdapters.end();
                             iterAdapter ++)
                        {
                            if ((*iterAdapter)->m_strBindName == (*iterRegKey)->c_str())
                            {
                                fFound = TRUE;
                                break;
                            }
                        }

                        if ((!fFound) ||
                            ( fFound && ((*iterAdapter)->m_fDeleted)))
                        {
                            hrTmp = HrRegDeleteKeyTree(hkeyAdapters,
                                                       (*iterRegKey)->c_str());
                            if SUCCEEDED(hr)
                                hr = hrTmp;
                        }
                    }
                }
            }

            // Save adapter info in memory state to registry
            for (UNI_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
                 iterAdapter != m_listAdapters.end();
                 iterAdapter ++)
            {

                if ((*iterAdapter)->m_fDeleted)
                    continue;

                HKEY    hkeyAdapterParam;

                // Create specific card bindname key under
                // "Services\Atmuni\Parameters\Adapters\<card bind name>"
                hrTmp = HrRegCreateKeyEx(hkeyAdapters,
                                         (*iterAdapter)->m_strBindName.c_str(),
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_ALL_ACCESS,
                                         NULL,
                                         &hkeyAdapterParam,
                                         &dwDisposition);
                if(SUCCEEDED(hrTmp))
                    hr = hrTmp;

                if(SUCCEEDED(hrTmp))
                {

                #if 0
                    // $REVIEW(tongl 4/27/98): Per ArvindM, we should no longer
                    // write these to registry.

                    // save defaults for SVC parameters for new adapters
                    if (dwDisposition != REG_OPENED_EXISTING_KEY)
                    {
                        hrTmp = HrSaveDefaultSVCParam(hkeyAdapterParam);

                        if SUCCEEDED(hr)
                            hr = hrTmp;
                    }
                #endif

                    // Now update any PVC parameters
                    // Only need to update PVC parameters for the Adapter of the
                    // current connection, and if changes are made through the UI
                    if (m_fUIParamChanged)
                    {
                        if (FIsSubstr(m_strGuidConn.c_str(), (*iterAdapter)->m_strBindName.c_str()))
                        {
                            if ((*iterAdapter)->m_listPVCs.size() > 0)
                            {
                                hrTmp = HrSaveAdapterPVCRegistry(hkeyAdapterParam, *iterAdapter);
                                if SUCCEEDED(hr)
                                    hr = hrTmp;
                            }
                        }
                    }
                }
                RegSafeCloseKey(hkeyAdapterParam);
            }
        }
        RegSafeCloseKey(hkeyAdapters);
    }
    RegSafeCloseKey(hkeyUniParam);

    TraceError("CAtmUniCfg::HrSaveSettings", hr);
    return hr;
}

// Adding a card
HRESULT CAtmUniCfg::HrAddAdapter(INetCfgComponent * pnccAdapter)
{
    PWSTR pszwBindName = NULL;
    HRESULT hr = pnccAdapter->GetBindName(&pszwBindName);

    AssertSz( SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

    CUniAdapterInfo * pAdapterInfo = NULL;
    if (fIsAdapterOnList(pszwBindName, &pAdapterInfo))
    {
        AssertSz(pAdapterInfo->m_fDeleted, "Trying to add a card that already exists on binding path");
        pAdapterInfo->m_fDeleted = FALSE;
    }
    else  // Add a new item
    {
        // create a new item
        m_listAdapters.push_back(new CUniAdapterInfo);
        m_listAdapters.back()->SetDefaults(pszwBindName);
    }

    CoTaskMemFree(pszwBindName);

    TraceError("CAtmUniCfg::HrAddAdapter", hr);
    return hr;
}

// Removing a card
HRESULT CAtmUniCfg::HrRemoveAdapter(INetCfgComponent * pnccAdapter)
{
    PWSTR pszwBindName = NULL;
    HRESULT hr = pnccAdapter->GetBindName(&pszwBindName);

    AssertSz( SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

    CUniAdapterInfo * pAdapterInfo = NULL;
    if (!fIsAdapterOnList(pszwBindName, &pAdapterInfo))
    {
        AssertSz(FALSE, "Trying to remove a card that does not exists on binding path");
    }
    else  // remove the card
    {
        // mark the adapter as for removal
        pAdapterInfo->m_fDeleted = TRUE;
    }

    CoTaskMemFree(pszwBindName);

    TraceError("CAtmUniCfg::HrRemoveAdapter", hr);
    return hr;
}

// Set binding state to enabled
HRESULT CAtmUniCfg::HrBindAdapter(INetCfgComponent * pnccAdapter)
{
    PWSTR pszwBindName = NULL;
    HRESULT hr = pnccAdapter->GetBindName(&pszwBindName);

    AssertSz(SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

    CUniAdapterInfo * pAdapterInfo = NULL;
    if (!fIsAdapterOnList(pszwBindName, &pAdapterInfo))
    {
        AssertSz(FALSE, "Trying to bind a card that does not exists on binding path");
    }
    else  // bind the adapter
    {
        pAdapterInfo->m_BindingState = BIND_ENABLE;
    }

    CoTaskMemFree(pszwBindName);

    TraceError("CAtmUniCfg::HrBindAdapter", hr);
    return hr;
}

// Set binding state to disabled
HRESULT CAtmUniCfg::HrUnBindAdapter(INetCfgComponent * pnccAdapter)
{
    PWSTR pszwBindName = NULL;
    HRESULT hr = pnccAdapter->GetBindName(&pszwBindName);

    AssertSz(SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

    CUniAdapterInfo * pAdapterInfo = NULL;
    if (!fIsAdapterOnList(pszwBindName, &pAdapterInfo))
    {
        AssertSz(FALSE, "Trying to unbind a card that does not exists on binding path");
    }
    else  // unbind the adapter
    {
        pAdapterInfo->m_BindingState = BIND_DISABLE;
    }

    CoTaskMemFree(pszwBindName);

    TraceError("CAtmUniCfg::HrUnBindAdapter", hr);
    return hr;
}

//
// Save default values of non-configurable params to registry
//
HRESULT CAtmUniCfg::HrSaveDefaultSVCParam(HKEY hkey)
{
    HRESULT hr = S_OK;

    PRODUCT_FLAVOR pf;
    // NT server and workstation has different default values
    GetProductFlavor(NULL, &pf);
    AssertSz( ((pf == PF_WORKSTATION) || (pf == PF_SERVER)),
              "Invalid product flavor.");

    HRESULT hrTmp = S_OK;
    switch (pf)
    {
    case PF_WORKSTATION:
        hr = HrRegSetDword(hkey,c_szMaxActiveSVCs,c_dwWksMaxActiveSVCs);

        if SUCCEEDED(hr)
            hr = hrTmp;

        hr = HrRegSetDword(hkey,c_szMaxSVCsInProgress,c_dwWksMaxSVCsInProgress);

        if SUCCEEDED(hr)
            hr = hrTmp;

        hr = HrRegSetDword(hkey,c_szMaxPMPSVCs,c_dwWksMaxPMPSVCs);
        if SUCCEEDED(hr)
            hr = hrTmp;

        hr = HrRegSetDword(hkey,c_szMaxActiveParties,c_dwWksMaxActiveParties);
        if SUCCEEDED(hr)
            hr = hrTmp;

        hr = HrRegSetDword(hkey,c_szMaxPartiesInProgress,c_dwWksMaxPartiesInProgress);
        if SUCCEEDED(hr)
            hr = hrTmp;

        break;

    case PF_SERVER:
        hr = HrRegSetDword(hkey,c_szMaxActiveSVCs,c_dwSrvMaxActiveSVCs);

        if SUCCEEDED(hr)
            hr = hrTmp;

        hr = HrRegSetDword(hkey,c_szMaxSVCsInProgress,c_dwSrvMaxSVCsInProgress);

        if SUCCEEDED(hr)
            hr = hrTmp;

        hr = HrRegSetDword(hkey,c_szMaxPMPSVCs,c_dwSrvMaxPMPSVCs);
        if SUCCEEDED(hr)
            hr = hrTmp;

        hr = HrRegSetDword(hkey,c_szMaxActiveParties,c_dwSrvMaxActiveParties);

        if SUCCEEDED(hr)
            hr = hrTmp;

        hr = HrRegSetDword(hkey,c_szMaxPartiesInProgress,c_dwSrvMaxPartiesInProgress);
        if SUCCEEDED(hr)
            hr = hrTmp;

        break;
    }

    TraceError("CAtmUniCfg::HrSaveDefaultSVCParam", hr);
    return hr;
}

// Checks if a card is on m_listAdapters
BOOL CAtmUniCfg::fIsAdapterOnList(PCWSTR pszBindName, CUniAdapterInfo ** ppAdapterInfo)
{

    BOOL fRet = FALSE;
    *ppAdapterInfo = NULL;

    for (UNI_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
         iterAdapter != m_listAdapters.end();
         iterAdapter ++)
    {
        if ((*iterAdapter)->m_strBindName == pszBindName)
        {
            fRet = TRUE;
            *ppAdapterInfo = *iterAdapter;

            break;
        }
    }

    return fRet;
}

// Called by CAtmUniCfg::MergePropPages
// Set the context in which the UI is brought up
HRESULT CAtmUniCfg::HrSetConnectionContext()
{
    AssertSz(m_pUnkContext, "Invalid IUnknown pointer passed to CAtmUniCfg::SetContext?");

    if (!m_pUnkContext)
        return E_FAIL;

    HRESULT hr = S_OK;
    GUID guidConn;

    // Is this a lan connection ?
    INetLanConnectionUiInfo * pLanConnUiInfo;
    hr = m_pUnkContext->QueryInterface( IID_INetLanConnectionUiInfo,
                                        reinterpret_cast<LPVOID *>(&pLanConnUiInfo));
    if (SUCCEEDED(hr))
    {
        // yes, lan connection
        pLanConnUiInfo->GetDeviceGuid(&guidConn);
        ReleaseObj(pLanConnUiInfo);

        WCHAR szGuid[c_cchGuidWithTerm];

        BOOL fSucceeded = StringFromGUID2(guidConn,
                                          szGuid,
                                          c_cchGuidWithTerm);
        Assert(fSucceeded);
        m_strGuidConn = szGuid;
    }

    TraceError("CAtmUniCfg::HrSetConnectionContext", hr);
    return hr;
}


// Called by CAtmUniCfg::MergePropPages
// Inits the prop sheet page objects and creates the pages to be returned to
// the installer object.
HRESULT CAtmUniCfg::HrSetupPropSheets(HPROPSHEETPAGE **pahpsp, INT * pcPages)
{
    HRESULT hr = S_OK;

    // initialize output parameters
    *pahpsp = NULL;
    *pcPages = 0;

    int cPages = 0;
    HPROPSHEETPAGE *ahpsp = NULL;

    m_fSecondMemoryModified = FALSE;

    // If PVC info has not been read from registry yet, load them
    if (!m_fPVCInfoLoaded)
    {
        hr = HrLoadPVCRegistry();
        m_fPVCInfoLoaded = TRUE;
    }

    if SUCCEEDED(hr)
    {
        // Copy PVC info of the corrent adapter to second memory
        hr = HrLoadAdapterPVCInfo();
    }

    // If we have found the matching adapter
    if SUCCEEDED(hr)
    {
        cPages = 1;

        delete m_uniPage;
        m_uniPage = new CUniPage(this, g_aHelpIDs_IDD_UNI_PROP);

        // Allocate a buffer large enough to hold the handles to all of our
        // property pages.
        ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE)
                                                 * cPages);
        if (!ahpsp)
        {
            hr = E_OUTOFMEMORY;
            goto err;
        }

        cPages =0;
        ahpsp[cPages++] = m_uniPage->CreatePage(IDD_UNI_PROP, 0);

        *pahpsp = ahpsp;
        *pcPages = cPages;
    }
    else // if the adapter is not bound, pop-up message box and don't show UI
    {
        NcMsgBox(::GetActiveWindow(),
                 IDS_MSFT_UNI_TEXT,
                 IDS_UNI_NO_BOUND_CARDS,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        AssertSz((0== *pcPages), "Invalid page number when no bound cards");
        AssertSz((NULL == *pahpsp), "Invalid page array pointer when no bound cards");
    }

err:

    TraceError("CAtmUniCfg::HrSetupPropSheets", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\atmutil.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A T M U T I L . C P P
//
//  Contents:   Utility function declaration
//
//  Notes:
//
//  Author:     tongl   3 Feb 1997
//
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "atmutil.h"
#include "ncmisc.h"
//#include "ncreg.h"
#include "ncstl.h"

void GetLowerIp(tstring& strIpRange, tstring * pstrLowerIp)
{
    size_t iSeparator = strIpRange.find(c_chSeparator);
    if(iSeparator != tstring::npos)
    {
        // get the first half of the string
        *pstrLowerIp = strIpRange.substr(0, iSeparator);
    }

    return;
}

void GetUpperIp(tstring& strIpRange, tstring * pstrUpperIp)
{
    size_t iSeparator = strIpRange.find(c_chSeparator);
    if(iSeparator != tstring::npos)
    {
        // get the first half of the string
        *pstrUpperIp = strIpRange.substr(iSeparator+1);
    }

    return;
}

BOOL IsValidIpRange(tstring& strIpLower, tstring& strIpUpper)
{
    if (strIpLower > strIpUpper)
        return FALSE;
    else
        return TRUE;
}

void MakeIpRange(tstring& strIpLower, tstring& strIpUpper, tstring * pstrNewIpRange)
{
    tstring strNewIpRange = strIpLower;
    strNewIpRange += c_chSeparator;
    strNewIpRange += strIpUpper;

    *pstrNewIpRange = strNewIpRange;

    return;
}

void InitComboWithStringArray(HWND hDlg, int nIDDlgItem,
                              int csid, const int*  asid)
{
    while (csid--)
    {
        SendDlgItemMessage(hDlg, nIDDlgItem, CB_ADDSTRING,
                           0, (LPARAM)((PWSTR) SzLoadIds(* asid++)));
    }
}

void ConvertBinaryToHexString(BYTE * pbData, DWORD cbData, tstring * pstrData)
{
    Assert(pstrData);
    Assert(pbData);

    tstring strData = c_szEmpty;
    WCHAR szByte[3];

    while (cbData>0)
    {
        ConvertByteToSz(pbData, szByte);
        strData += szByte;

        pbData ++;
        cbData --;
    }

    *pstrData = strData;
}

void ConvertByteToSz(BYTE * pbData, PWSTR pszByte)
{
    // high 4 bits
    BYTE bHighData = *pbData;
    bHighData &= 0xF0;
    bHighData >>= 4;
    pszByte[0] = (bHighData < 10) ? L'0'+bHighData : L'A'+(bHighData-10);

    // low 4 bits
    BYTE bLowData = *pbData;
    bLowData &= 0x0F;
    pszByte[1] = (bLowData < 10) ? L'0'+bLowData : L'A'+(bLowData-10);

    // terminater.
    pszByte[2] = L'\0';
}

void ConvertHexCharToByte(WCHAR ch, BYTE * pByte)
{
    *pByte =0;

    if ((ch >= L'0') && (ch <= L'9'))
        *pByte = ch-L'0';
    else if ((ch >= L'A') && (ch <= L'F'))
        *pByte = ch-L'A'+10;
    else if ((ch >= L'a') && (ch <= L'f'))
        *pByte = ch-L'a'+10;
    else
        AssertSz(FALSE, "Invalid hex character.");
}

void ConvertHexStringToBinaryWithAlloc(PCWSTR pszData, LPBYTE * ppbData, LPDWORD pcbData)
{
    // Initialize the output parameters.
    *ppbData = NULL;
    *pcbData = 0;

    LPBYTE  pbBuffer = NULL;
    DWORD   cbBuffer = wcslen(pszData)/2;
    const WCHAR * pChar = pszData;

    if ((*pszData == L'0') &&
        ((*(pszData+1) == L'x') || (*(pszData+1) == L'X')))
    {
        cbBuffer -=2;
        pChar +=2;
    }

    if (cbBuffer)
    {
        pbBuffer = new BYTE[cbBuffer];

		if (pbBuffer == NULL)
		{
            AssertSz(FALSE, "new returned a NULL pointer");
			return;
		}

        BYTE * pByte = pbBuffer;

        if (pByte != NULL)
        {
			while (*pChar)
			{
				*pByte=0;

				BYTE bData;

				// first 4 bits
				ConvertHexCharToByte(*pChar, &bData);
				bData <<= 4;
				*pByte |= bData;
				pChar++;

				// second 4 bits
				ConvertHexCharToByte(*pChar, &bData);
				*pByte |= bData;
				pChar++;

				pByte++;
			}
		}
    }

    *ppbData = pbBuffer;
    *pcbData = cbBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\pvcdata.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P V C D A T A. C P P
//
//  Contents:   PVC parameters
//
//  Notes:
//
//  Author:     tongl   20 Feb, 1998
//
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "arpsobj.h"
#include "auniobj.h"
#include "atmutil.h"
#include "ncstl.h"
#include "pvcdata.h"

#include "ncreg.h"

extern const WCHAR c_szAdapters[];

void SetPvcDwordParam(HKEY hkeyAdapterPVCId,
                      PCWSTR pszParamName,
                      DWORD dwParam)
{
    HRESULT hrTmp;

    if (FIELD_UNSET == dwParam)
    {
        // delete the value
        hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                 pszParamName);
    }
    else
    {
        // save the value
        hrTmp = HrRegSetDword(hkeyAdapterPVCId, pszParamName, dwParam);
    }

    TraceTag(ttidAtmUni, "SetPvcDword Failed on %S", pszParamName);
}

void SetPvcBinaryParamFromString(HKEY hkeyAdapterPVCId,
                                 PCWSTR pszParamName,
                                 PCWSTR pszData)
{
    HRESULT hrTmp;

    if (!(*pszData)) // empty string
    {
        // delete the value
        hrTmp = HrRegDeleteValue(hkeyAdapterPVCId, pszParamName);
    }
    else
    {
        // convert to binary
        BYTE * pbData = NULL;
        DWORD  cbData = 0;

        ConvertHexStringToBinaryWithAlloc(pszData, &pbData, &cbData);

        // save the value
        hrTmp = HrRegSetBinary(hkeyAdapterPVCId, pszParamName, pbData, cbData);

        delete pbData;
    }

    TraceTag(ttidAtmUni, "SetPvcBinaryParamFromString Failed on %S", pszParamName);
}

// Load PVC settings for the current adapter from registry to first memory
HRESULT CAtmUniCfg::HrLoadPVCRegistry()
{
    HRESULT hr = S_OK;

    HKEY hkeyUniParam;
    hr = m_pnccUni->OpenParamKey(&hkeyUniParam);
    if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        hr = S_OK;
    else if(SUCCEEDED(hr))
    {
        Assert(hkeyUniParam);

        // find the adapter we want to load
        for (UNI_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
             iterAdapter != m_listAdapters.end();
             iterAdapter ++)
        {
            if (FIsSubstr(m_strGuidConn.c_str(), (*iterAdapter)->m_strBindName.c_str()))
            {
                // found the adapter we want to load ...
                // open the adapters subkey
                HKEY    hkeyAdapters = NULL;
                hr = HrRegOpenKeyEx(hkeyUniParam, c_szAdapters,
                                    KEY_READ, &hkeyAdapters);

                if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                    hr = S_OK;
                else if(SUCCEEDED(hr))
                {
                    Assert(hkeyAdapters);
                    HKEY hkeyAdapterParam = NULL;
                    hr = HrRegOpenKeyEx(hkeyAdapters,
                                        (*iterAdapter)->m_strBindName.c_str(),
                                        KEY_READ, &hkeyAdapterParam);

                    if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                        hr = S_OK;
                    else if(SUCCEEDED(hr))
                    {
                        Assert(hkeyAdapterParam);
                        HrLoadAdapterPVCRegistry(hkeyAdapterParam, *iterAdapter);
                    }
                    RegSafeCloseKey(hkeyAdapterParam);
                }
                RegSafeCloseKey(hkeyAdapters);
                break;
            }
        }
    }
    RegSafeCloseKey(hkeyUniParam);

    TraceError("CAtmUniCfg::HrLoadPVCRegistry", hr);
    return hr;
}

HRESULT CAtmUniCfg::HrLoadAdapterPVCRegistry(HKEY hkeyAdapterParam,
                                             CUniAdapterInfo * pAdapterInfo)
{
    HRESULT hr = S_OK;

    Assert(hkeyAdapterParam);
    Assert(pAdapterInfo);

    // there should not have been any PVC on the list
    Assert(pAdapterInfo->m_listPVCs.size() ==0);

    // open the PVC subkey and enumerate the PVCs under that
    HKEY hkeyAdapterPVC = NULL;
    hr = HrRegOpenKeyEx(hkeyAdapterParam,
                        c_szPVC,
                        KEY_READ,
                        &hkeyAdapterPVC);

    if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        hr = S_OK;
    else if(SUCCEEDED(hr))
    {
        Assert(hkeyAdapterPVC);

        // enumerate the sub keys, and create a CPvcInfo object for each PVC
        VECSTR vstrPVCIdList;
        hr = HrLoadSubkeysFromRegistry(hkeyAdapterPVC, &vstrPVCIdList);

        // now load parameters for each PVC
        for (VECSTR::iterator iterPvcId = vstrPVCIdList.begin();
             iterPvcId != vstrPVCIdList.end();
             iterPvcId ++)
        {
            HKEY hkeyAdapterPVCId = NULL;
            hr = HrRegOpenKeyEx(hkeyAdapterPVC,
                                (*iterPvcId)->c_str(),
                                KEY_READ,
                                &hkeyAdapterPVCId);

            if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                hr = S_OK;
            else if(SUCCEEDED(hr))
            {
                CPvcInfo * pNewPVC = new CPvcInfo((*iterPvcId)->c_str());

                if (pNewPVC)
                {
					pAdapterInfo->m_listPVCs.push_back(pNewPVC);

					HRESULT hrTmp = S_OK;

					// Get the PVC Type
					DWORD dwType;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId,
											c_szPVCType,
											&dwType);

					if (hrTmp == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
					{
						pNewPVC->m_dwPVCType = PVC_CUSTOM;
						hrTmp = S_OK;
					}
					else if SUCCEEDED(hrTmp)
					{
						Assert( (dwType == PVC_ATMARP) ||
								(dwType == PVC_PPP_ATM_CLIENT) ||
								(dwType == PVC_PPP_ATM_SERVER) ||
								(dwType == PVC_CUSTOM));

						switch(dwType)
						{
						case PVC_ATMARP:
							pNewPVC->m_dwPVCType = PVC_ATMARP;
							break;

						case PVC_PPP_ATM_CLIENT:
							pNewPVC->m_dwPVCType = PVC_PPP_ATM_CLIENT;
							break;

						case PVC_PPP_ATM_SERVER:
							pNewPVC->m_dwPVCType = PVC_PPP_ATM_SERVER;
							break;

						default:
							pNewPVC->m_dwPVCType = PVC_CUSTOM;
							break;
						}
					}
					else
					{
						TraceError("Failed reading PVCType", hrTmp);
						hrTmp = S_OK;

						pNewPVC->m_dwPVCType = PVC_CUSTOM;
					}

					// set the default values for the type
					pNewPVC->SetDefaults(pNewPVC->m_dwPVCType);

					// now read any existing value from the registry
					// pvc name
					tstring strName;
					hrTmp = HrRegQueryString(hkeyAdapterPVCId, c_szPVCName, &strName);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_strName = strName;

					// VPI (required), if failed, default to 0
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szVpi, &(pNewPVC->m_dwVpi));

					// VCI (required), if failed, default to 0
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szVci, &(pNewPVC->m_dwVci));

					// AAL Type
					DWORD dwAALType;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szAALType, &dwAALType);
					if SUCCEEDED(hrTmp)
					{
						switch (dwAALType)
						{
						/* $REVIEW(tongl 2/23/98): Per ArvindM, only AAL5 is supported in NT5
						case AAL_TYPE_AAL0:
							pNewPVC->m_dwAAL = AAL_TYPE_AAL0;
							break;
	
						case AAL_TYPE_AAL1:
							pNewPVC->m_dwAAL = AAL_TYPE_AAL1;
							break;
	
						case AAL_TYPE_AAL34:
							pNewPVC->m_dwAAL = AAL_TYPE_AAL34;
							break;
						*/
	
						case AAL_TYPE_AAL5:
							pNewPVC->m_dwAAL = AAL_TYPE_AAL5;
							break;
	
						default:
							AssertSz(FALSE, "Invalid AAL type.");
							pNewPVC->m_dwAAL = AAL_TYPE_AAL5;
						}
					}
	
					// Local address
					tstring strCallingAddr;
					hrTmp = HrRegQueryString(hkeyAdapterPVCId, c_szCallingParty, &strCallingAddr);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_strCallingAddr = strCallingAddr;
	
					// Destination address
					tstring strCalledAddr;
					hrTmp = HrRegQueryString(hkeyAdapterPVCId, c_szCalledParty, &strCalledAddr);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_strCalledAddr = strCalledAddr;
	
					// Flags
					DWORD dwFlags;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szFlags, &dwFlags);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwFlags = dwFlags;
	
					// Quality Info
					// TransmitPeakCellRate
					DWORD dwTransmitPeakCellRate;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szTransmitPeakCellRate,
											&dwTransmitPeakCellRate);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwTransmitPeakCellRate = dwTransmitPeakCellRate*c_iCellSize/c_iKbSize;
	
					// TransmitAvgCellRate
					DWORD dwTransmitAvgCellRate;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szTransmitAvgCellRate,
											&dwTransmitAvgCellRate);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwTransmitAvgCellRate = dwTransmitAvgCellRate*c_iCellSize/c_iKbSize;
	
					// TransmitByteBurstLength
					DWORD dwTransmitByteBurstLength;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szTransmitByteBurstLength,
											&dwTransmitByteBurstLength);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwTransmitByteBurstLength = dwTransmitByteBurstLength;
	
					// TransmitMaxSduSize
					DWORD dwTransmitMaxSduSize;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szTransmitMaxSduSize,
											&dwTransmitMaxSduSize);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwTransmitMaxSduSize = dwTransmitMaxSduSize;
	
					// TransmitServiceCategory
					DWORD dwTransmitServiceCategory;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szTransmitServiceCategory,
											&dwTransmitServiceCategory);
					if SUCCEEDED(hrTmp)
					{
						switch(dwTransmitServiceCategory)
						{
						case ATM_SERVICE_CATEGORY_CBR:
							pNewPVC->m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_CBR;
                        break;

						case ATM_SERVICE_CATEGORY_VBR:
							pNewPVC->m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_VBR;
							break;
	
						case ATM_SERVICE_CATEGORY_UBR:
							pNewPVC->m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_UBR;
							break;
	
						case ATM_SERVICE_CATEGORY_ABR:
							pNewPVC->m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_ABR;
							break;
	
						default:
							AssertSz(FALSE, "Invalid service category.");
							pNewPVC->m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_UBR;
						}
					}
	
					// ReceivePeakCellRate
					DWORD dwReceivePeakCellRate;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szReceivePeakCellRate,
											&dwReceivePeakCellRate);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwReceivePeakCellRate = dwReceivePeakCellRate*c_iCellSize/c_iKbSize;
	
					// ReceiveAvgCellRate
					DWORD dwReceiveAvgCellRate;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szReceiveAvgCellRate,
											&dwReceiveAvgCellRate);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwReceiveAvgCellRate = dwReceiveAvgCellRate*c_iCellSize/c_iKbSize;
	
					// ReceiveByteBurstLength
					DWORD dwReceiveByteBurstLength;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szReceiveByteBurstLength,
											&dwReceiveByteBurstLength);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwReceiveByteBurstLength = dwReceiveByteBurstLength;
	
					// ReceiveMaxSduSize
					DWORD dwReceiveMaxSduSize;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szReceiveMaxSduSize,
											&dwReceiveMaxSduSize);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwReceiveMaxSduSize = dwReceiveMaxSduSize;
	
					// ReceiveServiceCategory
					DWORD dwReceiveServiceCategory;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szReceiveServiceCategory,
											&dwReceiveServiceCategory);
					if SUCCEEDED(hrTmp)
					{
						switch(dwReceiveServiceCategory)
						{
						case ATM_SERVICE_CATEGORY_CBR:
							pNewPVC->m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_CBR;
							break;
	
						case ATM_SERVICE_CATEGORY_VBR:
							pNewPVC->m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_VBR;
							break;
	
						case ATM_SERVICE_CATEGORY_UBR:
							pNewPVC->m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_UBR;
							break;
	
						case ATM_SERVICE_CATEGORY_ABR:
							pNewPVC->m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_ABR;
							break;
	
						default:
							AssertSz(FALSE, "Invalid service category.");
							pNewPVC->m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_UBR;
						}
					}
	
					// Local BLLI & BHLI
					DWORD dwLocalLayer2Protocol;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szLocalLayer2Protocol,
											&dwLocalLayer2Protocol);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwLocalLayer2Protocol = dwLocalLayer2Protocol;
	
					DWORD dwLocalUserSpecLayer2;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szLocalUserSpecLayer2,
											&dwLocalUserSpecLayer2);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwLocalUserSpecLayer2 = dwLocalUserSpecLayer2;
	
					DWORD dwLocalLayer3Protocol;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szLocalLayer3Protocol,
											&dwLocalLayer3Protocol);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwLocalLayer3Protocol = dwLocalLayer3Protocol;
	
					DWORD dwLocalUserSpecLayer3;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szLocalUserSpecLayer3,
											&dwLocalUserSpecLayer3);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwLocalUserSpecLayer3 = dwLocalUserSpecLayer3;
	
					DWORD dwLocalLayer3IPI;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szLocalLayer3IPI,
											&dwLocalLayer3IPI);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwLocalLayer3IPI = dwLocalLayer3IPI;
	
					BYTE *  pbLocalSnapId = NULL;
					DWORD   cbLocalSnapId = 0;
	
					hrTmp = HrRegQueryBinaryWithAlloc(hkeyAdapterPVCId, c_szLocalSnapId,
  													&pbLocalSnapId, &cbLocalSnapId);
	
					if ( SUCCEEDED(hrTmp) &&
 						(cbLocalSnapId >0) &&
 						(cbLocalSnapId <= c_nSnapIdMaxBytes))
					{
						ConvertBinaryToHexString(pbLocalSnapId, cbLocalSnapId,
 												&(pNewPVC->m_strLocalSnapId));
						MemFree(pbLocalSnapId);
					}
	
					DWORD dwLocalHighLayerInfoType;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szLocalHighLayerInfoType,
											&dwLocalHighLayerInfoType);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwLocalHighLayerInfoType = dwLocalHighLayerInfoType;
	
					BYTE *  pbLocalHighLayerInfo = NULL;
					DWORD   cbLocalHighLayerInfo = 0;
	
					hrTmp = HrRegQueryBinaryWithAlloc(hkeyAdapterPVCId, c_szLocalHighLayerInfo,
  													&pbLocalHighLayerInfo, &cbLocalHighLayerInfo);
	
					if ( SUCCEEDED(hrTmp) &&
 						(cbLocalHighLayerInfo >0) &&
 						(cbLocalHighLayerInfo <= c_nHighLayerInfoMaxBytes))
					{
						ConvertBinaryToHexString(pbLocalHighLayerInfo, cbLocalHighLayerInfo,
 												&(pNewPVC->m_strLocalHighLayerInfo));
						MemFree(pbLocalHighLayerInfo);
					}
	
					// Destination BLLI and BHLI
					DWORD dwDestnLayer2Protocol;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szDestnLayer2Protocol,
											&dwDestnLayer2Protocol);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwDestnLayer2Protocol = dwDestnLayer2Protocol;
	
					DWORD dwDestnUserSpecLayer2;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szDestnUserSpecLayer2,
											&dwDestnUserSpecLayer2);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwDestnUserSpecLayer2 = dwDestnUserSpecLayer2;
	
					DWORD dwDestnLayer3Protocol;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szDestnLayer3Protocol,
											&dwDestnLayer3Protocol);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwDestnLayer3Protocol = dwDestnLayer3Protocol;
	
					DWORD dwDestnUserSpecLayer3;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szDestnUserSpecLayer3,
											&dwDestnUserSpecLayer3);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwDestnUserSpecLayer3 = dwDestnUserSpecLayer3;
	
					DWORD dwDestnLayer3IPI;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szDestnLayer3IPI,
											&dwDestnLayer3IPI);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwDestnLayer3IPI = dwDestnLayer3IPI;
	
					BYTE *  pbDestnSnapId = NULL;
					DWORD   cbDestnSnapId = 0;
					hrTmp = HrRegQueryBinaryWithAlloc(hkeyAdapterPVCId, c_szDestnSnapId,
  													&pbDestnSnapId, &cbDestnSnapId);
	
					if ( SUCCEEDED(hrTmp) &&
 						(cbDestnSnapId >0) &&
 						(cbDestnSnapId <= c_nSnapIdMaxBytes))
					{
						ConvertBinaryToHexString(pbDestnSnapId, cbDestnSnapId,
 												&(pNewPVC->m_strDestnSnapId));
						MemFree(pbDestnSnapId);
					}
	
					DWORD dwDestnHighLayerInfoType;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szDestnHighLayerInfoType,
											&dwDestnHighLayerInfoType);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwDestnHighLayerInfoType = dwDestnHighLayerInfoType;
	
					BYTE *  pbDestnHighLayerInfo = NULL;
					DWORD   cbDestnHighLayerInfo = 0;
	
					hrTmp = HrRegQueryBinaryWithAlloc(hkeyAdapterPVCId, c_szDestnHighLayerInfo,
  													&pbDestnHighLayerInfo, &cbDestnHighLayerInfo);
	
					if ( SUCCEEDED(hrTmp) &&
 						(cbDestnHighLayerInfo >0) &&
 						(cbDestnHighLayerInfo <= c_nHighLayerInfoMaxBytes))
					{
						ConvertBinaryToHexString(pbDestnHighLayerInfo, cbDestnHighLayerInfo,
 												&(pNewPVC->m_strDestnHighLayerInfo));
						MemFree(pbDestnHighLayerInfo);
					}
	
					// Now initialize the "Old" values
					pNewPVC->ResetOldValues();
				}
			}
            RegSafeCloseKey(hkeyAdapterPVCId);
        }
    }
    RegSafeCloseKey(hkeyAdapterPVC);

    TraceError("CAtmUniCfg::HrLoadAdapterPVCRegistry", hr);
    return hr;
}

// Save PVC specific settings to registry
HRESULT CAtmUniCfg::HrSaveAdapterPVCRegistry(HKEY hkeyAdapterParam,
                                             CUniAdapterInfo * pAdapterInfo)
{
    HRESULT hr = S_OK;

    Assert(hkeyAdapterParam);
    Assert(pAdapterInfo);

    // open the PVC subkey and enumerate the PVCs under that
    HKEY  hkeyAdapterPVC = NULL;
    DWORD dwDisposition;
    hr = HrRegCreateKeyEx(hkeyAdapterParam,
                             c_szPVC,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hkeyAdapterPVC,
                             &dwDisposition);
    if(SUCCEEDED(hr))
    {
        Assert(hkeyAdapterPVC);

        if (dwDisposition == REG_OPENED_EXISTING_KEY)
        {
            // clean up deleted PVCs
            HRESULT hrTmp = S_OK;

            // enumerate the sub keys, and create a CPvcInfo object for each PVC
            VECSTR vstrPVCIdList;
            hrTmp = HrLoadSubkeysFromRegistry(hkeyAdapterPVC, &vstrPVCIdList);
            if SUCCEEDED(hrTmp)
            {
                for (VECSTR::iterator iterPvcId = vstrPVCIdList.begin();
                     iterPvcId != vstrPVCIdList.end();
                     iterPvcId ++)
                {
                    BOOL fFound = FALSE;

                    for (PVC_INFO_LIST::iterator iterPvcInfo = pAdapterInfo->m_listPVCs.begin();
                         iterPvcInfo != pAdapterInfo->m_listPVCs.end();
                         iterPvcInfo ++)
                    {
                        if ((*iterPvcInfo)->m_fDeleted)
                            continue;

                        if (**iterPvcId == (*iterPvcInfo)->m_strPvcId)
                        {
                            fFound = TRUE;
                            break;
                        }
                    }

                    if (!fFound)
                    {
                        hrTmp = HrRegDeleteKeyTree(hkeyAdapterPVC,
                                                   (*iterPvcId)->c_str());
                    }
                }
            }
        }

        // save new or updated pvcs
        for (PVC_INFO_LIST::iterator iterPvcInfo = pAdapterInfo->m_listPVCs.begin();
             iterPvcInfo != pAdapterInfo->m_listPVCs.end();
             iterPvcInfo ++)
        {
            if ((*iterPvcInfo)->m_fDeleted)
                continue;

            HRESULT hrTmp = S_OK;

            // Create the subkey
            HKEY  hkeyAdapterPVCId = NULL;
            hrTmp = HrRegCreateKeyEx(hkeyAdapterPVC,
                                     (*iterPvcInfo)->m_strPvcId.c_str(),
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_ALL_ACCESS,
                                     NULL,
                                     &hkeyAdapterPVCId,
                                     &dwDisposition);
            if(SUCCEEDED(hrTmp))
            {
                Assert(hkeyAdapterPVCId);

                // PVC type
                hrTmp = HrRegSetDword(hkeyAdapterPVCId,
                                      c_szPVCType,
                                      (*iterPvcInfo)->m_dwPVCType);
                if SUCCEEDED(hr)
                    hr = hrTmp;

                // pvc name
                hrTmp = HrRegSetString(hkeyAdapterPVCId, c_szPVCName,
                                       (*iterPvcInfo)->m_strName);
                if SUCCEEDED(hr)
                    hr = hrTmp;

                // VPI
                hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szVpi,
                                      (*iterPvcInfo)->m_dwVpi);
                if SUCCEEDED(hr)
                    hr = hrTmp;

                // VCI
                hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szVci,
                                      (*iterPvcInfo)->m_dwVci);
                if SUCCEEDED(hr)
                    hr = hrTmp;

                // AAL Type
                hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szAALType,
                                      (*iterPvcInfo)->m_dwAAL);
                if SUCCEEDED(hr)
                    hr = hrTmp;

                // Local address
                hrTmp = HrRegSetString(hkeyAdapterPVCId, c_szCallingParty,
                                       (*iterPvcInfo)->m_strCallingAddr);
                if SUCCEEDED(hr)
                    hr = hrTmp;

                // Destination address
                hrTmp = HrRegSetString(hkeyAdapterPVCId, c_szCalledParty,
                                       (*iterPvcInfo)->m_strCalledAddr);
                if SUCCEEDED(hr)
                    hr = hrTmp;

                // Flags
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwFlags)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId, c_szFlags);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szFlags,
                                          (*iterPvcInfo)->m_dwFlags);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // Quality Info
                // TransmitPeakCellRate
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwTransmitPeakCellRate)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                             c_szTransmitPeakCellRate);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szTransmitPeakCellRate,
                                          (*iterPvcInfo)->m_dwTransmitPeakCellRate*c_iKbSize/c_iCellSize);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // TransmitAvgCellRate
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwTransmitAvgCellRate)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                             c_szTransmitAvgCellRate);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szTransmitAvgCellRate,
                                          (*iterPvcInfo)->m_dwTransmitAvgCellRate*c_iKbSize/c_iCellSize);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // TransmitByteBurstLength
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwTransmitByteBurstLength)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                             c_szTransmitByteBurstLength);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szTransmitByteBurstLength,
                                          (*iterPvcInfo)->m_dwTransmitByteBurstLength);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // TransmitMaxSduSize
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwTransmitMaxSduSize)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                             c_szTransmitMaxSduSize);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szTransmitMaxSduSize,
                                          (*iterPvcInfo)->m_dwTransmitMaxSduSize);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // TransmitServiceCategory
                hrTmp = HrRegSetDword(hkeyAdapterPVCId,
                                      c_szTransmitServiceCategory,
                                      (*iterPvcInfo)->m_dwTransmitServiceCategory);
                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // ReceivePeakCellRate
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwReceivePeakCellRate)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                             c_szReceivePeakCellRate);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szReceivePeakCellRate,
                                          (*iterPvcInfo)->m_dwReceivePeakCellRate*c_iKbSize/c_iCellSize);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // ReceiveAvgCellRate
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwReceiveAvgCellRate)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                             c_szReceiveAvgCellRate);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szReceiveAvgCellRate,
                                          (*iterPvcInfo)->m_dwReceiveAvgCellRate*c_iKbSize/c_iCellSize);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // ReceiveByteBurstLength
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwReceiveByteBurstLength)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                             c_szReceiveByteBurstLength);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szReceiveByteBurstLength,
                                          (*iterPvcInfo)->m_dwReceiveByteBurstLength);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // ReceiveMaxSduSize
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwReceiveMaxSduSize)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                             c_szReceiveMaxSduSize);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szReceiveMaxSduSize,
                                          (*iterPvcInfo)->m_dwReceiveMaxSduSize);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // ReceiveServiceCategory
                hrTmp = HrRegSetDword(hkeyAdapterPVCId,
                                      c_szReceiveServiceCategory,
                                      (*iterPvcInfo)->m_dwReceiveServiceCategory);
                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // Local BLLI & BHLI
                SetPvcDwordParam(hkeyAdapterPVCId, c_szLocalLayer2Protocol,
                                 (*iterPvcInfo)->m_dwLocalLayer2Protocol);

                SetPvcDwordParam(hkeyAdapterPVCId, c_szLocalUserSpecLayer2,
                                 (*iterPvcInfo)->m_dwLocalUserSpecLayer2);

                SetPvcDwordParam(hkeyAdapterPVCId, c_szLocalLayer3Protocol,
                                 (*iterPvcInfo)->m_dwLocalLayer3Protocol);

                SetPvcDwordParam(hkeyAdapterPVCId, c_szLocalUserSpecLayer3,
                                 (*iterPvcInfo)->m_dwLocalUserSpecLayer3);

                SetPvcDwordParam(hkeyAdapterPVCId, c_szLocalLayer3IPI,
                                 (*iterPvcInfo)->m_dwLocalLayer3IPI);

                SetPvcBinaryParamFromString(hkeyAdapterPVCId, c_szLocalSnapId,
                                            (*iterPvcInfo)->m_strLocalSnapId.c_str());

                SetPvcDwordParam(hkeyAdapterPVCId, c_szLocalHighLayerInfoType,
                                 (*iterPvcInfo)->m_dwLocalHighLayerInfoType);

                SetPvcBinaryParamFromString(hkeyAdapterPVCId, c_szLocalHighLayerInfo,
                                            (*iterPvcInfo)->m_strLocalHighLayerInfo.c_str());

                // Destination BLLI and BHLI info
                SetPvcDwordParam(hkeyAdapterPVCId, c_szDestnLayer2Protocol,
                                 (*iterPvcInfo)->m_dwDestnLayer2Protocol);

                SetPvcDwordParam(hkeyAdapterPVCId, c_szDestnUserSpecLayer2,
                                 (*iterPvcInfo)->m_dwDestnUserSpecLayer2);

                SetPvcDwordParam(hkeyAdapterPVCId, c_szDestnLayer3Protocol,
                                 (*iterPvcInfo)->m_dwDestnLayer3Protocol);

                SetPvcDwordParam(hkeyAdapterPVCId, c_szDestnUserSpecLayer3,
                                 (*iterPvcInfo)->m_dwDestnUserSpecLayer3);

                SetPvcDwordParam(hkeyAdapterPVCId, c_szDestnLayer3IPI,
                                 (*iterPvcInfo)->m_dwDestnLayer3IPI);

                SetPvcBinaryParamFromString(hkeyAdapterPVCId, c_szDestnSnapId,
                                            (*iterPvcInfo)->m_strDestnSnapId.c_str());

                SetPvcDwordParam(hkeyAdapterPVCId, c_szDestnHighLayerInfoType,
                                 (*iterPvcInfo)->m_dwDestnHighLayerInfoType);

                SetPvcBinaryParamFromString(hkeyAdapterPVCId, c_szDestnHighLayerInfo,
                                            (*iterPvcInfo)->m_strDestnHighLayerInfo.c_str());
            }
            RegSafeCloseKey(hkeyAdapterPVCId);
        }
    }
    RegSafeCloseKey(hkeyAdapterPVC);

    TraceError("CAtmUniCfg::HrSaveAdapterPVCRegistry", hr);
    return hr;
}

// load adapter PVC parameters from first memory to second memory
HRESULT CAtmUniCfg::HrLoadAdapterPVCInfo()
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_MATCH);

    delete m_pSecondMemoryAdapterInfo;
    m_pSecondMemoryAdapterInfo = NULL;

    for(UNI_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
        iterAdapter != m_listAdapters.end();
        iterAdapter++)
    {
        if (FIsSubstr(m_strGuidConn.c_str(), (*iterAdapter)->m_strBindName.c_str()))
        {
            // enabled LAN adapter
            if ((*iterAdapter)->m_BindingState == BIND_ENABLE)
            {
                m_pSecondMemoryAdapterInfo = new CUniAdapterInfo;

				if (m_pSecondMemoryAdapterInfo == NULL)
				{
					continue;
				}

                *m_pSecondMemoryAdapterInfo = **iterAdapter;
                hr = S_OK;
            }
        }
    }

    AssertSz((S_OK == hr), "Can not raise UI on a disabled or non-exist adapter !");
    TraceError("CAtmUniCfg::HrLoadAdapterInfo", hr);
    return hr;
}

// save adapter PVC parameters from second memory to first memory
HRESULT CAtmUniCfg::HrSaveAdapterPVCInfo()
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_MATCH);

    for(UNI_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
        iterAdapter != m_listAdapters.end();
        iterAdapter++)
    {
        if(m_pSecondMemoryAdapterInfo->m_strBindName == (*iterAdapter)->m_strBindName)
        {
            // The card can not get unbound while in the properties UI !
            Assert((*iterAdapter)->m_BindingState == BIND_ENABLE);
            Assert(m_pSecondMemoryAdapterInfo->m_BindingState == BIND_ENABLE);

            **iterAdapter = *m_pSecondMemoryAdapterInfo;
            hr = S_OK;
            break;
        }
    }

    AssertSz((S_OK == hr), "Adapter in second memory not found in first memory!");

    TraceError("CAtmUniCfg::HrSaveAdapterInfo", hr);
    return hr;
}

// CPvcInfo
CPvcInfo::CPvcInfo(PCWSTR pszPvcId)
{
    m_strPvcId = pszPvcId;
    m_fDeleted = FALSE;
}

CPvcInfo::~CPvcInfo()
{
}

// copy operator
CPvcInfo &  CPvcInfo::operator=(const CPvcInfo & info)
{
    Assert(this != &info);
    Assert(m_strPvcId == info.m_strPvcId);

    if (this == &info)
        return *this;

    m_fDeleted = info.m_fDeleted;

    m_dwPVCType = info.m_dwPVCType;
    m_dwOldPVCType = info.m_dwOldPVCType;

    m_strName = info.m_strName;
    m_strOldName = info.m_strOldName;

    m_dwVpi = info.m_dwVpi;
    m_dwOldVpi = info.m_dwOldVpi;

    m_dwVci = info.m_dwVci;
    m_dwOldVci = info.m_dwOldVci;

    m_dwAAL = info.m_dwAAL;
    m_dwOldAAL = info.m_dwOldAAL;

    m_strCallingAddr = info.m_strCallingAddr;
    m_strOldCallingAddr = info.m_strOldCallingAddr;

    m_strCalledAddr = info.m_strCalledAddr;
    m_strOldCalledAddr = info.m_strOldCalledAddr;

    m_dwFlags = info.m_dwFlags;

    m_dwTransmitPeakCellRate = info.m_dwTransmitPeakCellRate;
    m_dwOldTransmitPeakCellRate = info.m_dwOldTransmitPeakCellRate;

    m_dwTransmitAvgCellRate = info.m_dwTransmitAvgCellRate;
    m_dwOldTransmitAvgCellRate = info.m_dwOldTransmitAvgCellRate;

    m_dwTransmitByteBurstLength = info.m_dwTransmitByteBurstLength;
    m_dwOldTransmitByteBurstLength = info.m_dwOldTransmitByteBurstLength;

    m_dwTransmitMaxSduSize = info.m_dwTransmitMaxSduSize;
    m_dwOldTransmitMaxSduSize = info.m_dwOldTransmitMaxSduSize;

    m_dwTransmitServiceCategory = info.m_dwTransmitServiceCategory;
    m_dwOldTransmitServiceCategory = info.m_dwOldTransmitServiceCategory;

    m_dwReceivePeakCellRate = info.m_dwReceivePeakCellRate;
    m_dwOldReceivePeakCellRate = info.m_dwOldReceivePeakCellRate;

    m_dwReceiveAvgCellRate = info.m_dwReceiveAvgCellRate;
    m_dwOldReceiveAvgCellRate = info.m_dwOldReceiveAvgCellRate;

    m_dwReceiveByteBurstLength = info.m_dwReceiveByteBurstLength;
    m_dwOldReceiveByteBurstLength = info.m_dwOldReceiveByteBurstLength;

    m_dwReceiveMaxSduSize = info.m_dwReceiveMaxSduSize;
    m_dwOldReceiveMaxSduSize = info.m_dwOldReceiveMaxSduSize;

    m_dwReceiveServiceCategory = info.m_dwReceiveServiceCategory;
    m_dwOldReceiveServiceCategory = info.m_dwOldReceiveServiceCategory;

    // BLLI & BHLI
    m_dwLocalLayer2Protocol = info.m_dwLocalLayer2Protocol;
    m_dwOldLocalLayer2Protocol = info.m_dwOldLocalLayer2Protocol;

    m_dwLocalUserSpecLayer2 = info.m_dwLocalUserSpecLayer2;
    m_dwOldLocalUserSpecLayer2 = info.m_dwOldLocalUserSpecLayer2;

    m_dwLocalLayer3Protocol = info.m_dwLocalLayer3Protocol;
    m_dwOldLocalLayer3Protocol = info.m_dwOldLocalLayer3Protocol;

    m_dwLocalUserSpecLayer3 = info.m_dwLocalUserSpecLayer3;
    m_dwOldLocalUserSpecLayer3 = info.m_dwOldLocalUserSpecLayer3;

    m_dwLocalLayer3IPI = info.m_dwLocalLayer3IPI;
    m_dwOldLocalLayer3IPI = info.m_dwOldLocalLayer3IPI;

    m_strLocalSnapId    = info.m_strLocalSnapId;
    m_strOldLocalSnapId = info.m_strOldLocalSnapId;

    m_dwLocalHighLayerInfoType = info.m_dwLocalHighLayerInfoType;
    m_dwOldLocalHighLayerInfoType = info.m_dwOldLocalHighLayerInfoType;

    m_strLocalHighLayerInfo = info.m_strLocalHighLayerInfo;
    m_strOldLocalHighLayerInfo = info.m_strOldLocalHighLayerInfo;

    // Destination BLLI and BHLI info
    m_dwDestnLayer2Protocol = info.m_dwDestnLayer2Protocol;
    m_dwOldDestnLayer2Protocol = info.m_dwOldDestnLayer2Protocol;

    m_dwDestnUserSpecLayer2 = info.m_dwDestnUserSpecLayer2;
    m_dwOldDestnUserSpecLayer2 = info.m_dwOldDestnUserSpecLayer2;

    m_dwDestnLayer3Protocol = info.m_dwDestnLayer3Protocol;
    m_dwOldDestnLayer3Protocol = info.m_dwOldDestnLayer3Protocol;

    m_dwDestnUserSpecLayer3 = info.m_dwDestnUserSpecLayer3;
    m_dwOldDestnUserSpecLayer3 = info.m_dwOldDestnUserSpecLayer3;

    m_dwDestnLayer3IPI = info.m_dwDestnLayer3IPI;
    m_dwOldDestnLayer3IPI = info.m_dwOldDestnLayer3IPI;

    m_strDestnSnapId    = info.m_strDestnSnapId;
    m_strOldDestnSnapId = info.m_strOldDestnSnapId;

    m_dwDestnHighLayerInfoType = info.m_dwDestnHighLayerInfoType;
    m_dwOldDestnHighLayerInfoType = info.m_dwOldDestnHighLayerInfoType;

    m_strDestnHighLayerInfo = info.m_strDestnHighLayerInfo;
    m_strOldDestnHighLayerInfo = info.m_strOldDestnHighLayerInfo;

    return *this;
}

void CPvcInfo::SetDefaults(PVCType type)
{
    m_dwPVCType = type;
    m_fDeleted = FALSE;

    m_strName = (PWSTR) SzLoadIds(IDS_PVC_UNSPECIFIED_NAME);
    m_dwAAL = AAL_TYPE_AAL5;

    m_dwVpi = 0;
    m_dwVci = FIELD_UNSET;

    SetTypeDefaults(type);
    ResetOldValues();
}

void CPvcInfo::SetTypeDefaults(PVCType type)
{
    // set more specific defaults for each type
    m_dwPVCType = type;

    switch (m_dwPVCType)
    {
    case PVC_ATMARP:
        SetDefaultsForAtmArp();
        break;

    case PVC_PPP_ATM_CLIENT:
        SetDefaultsForPPPOut();
        break;

    case PVC_PPP_ATM_SERVER:
        SetDefaultsForPPPIn();
        break;

    case PVC_CUSTOM:
        SetDefaultsForCustom();
        break;
    }
}

void CPvcInfo::SetDefaultsForAtmArp()
{
    m_dwPVCType = PVC_ATMARP;

    // addresses
    m_strCallingAddr = c_szDefaultCallingAtmAddr;
    m_strCalledAddr  = c_szEmpty;

    // Flags
    m_dwFlags        = 2;

    // Quality Info
    m_dwTransmitPeakCellRate    = FIELD_UNSET;
    m_dwTransmitAvgCellRate     = FIELD_UNSET;
    m_dwTransmitByteBurstLength = c_dwDefTransmitByteBurstLength;
    m_dwTransmitMaxSduSize      = c_dwDefTransmitMaxSduSize;
    m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_UBR;

    m_dwReceivePeakCellRate    = FIELD_UNSET;
    m_dwReceiveAvgCellRate     = FIELD_UNSET;
    m_dwReceiveByteBurstLength = c_dwDefTransmitByteBurstLength;
    m_dwReceiveMaxSduSize      = c_dwDefTransmitMaxSduSize;
    m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_UBR;

    // Local BLLI & BHLI
    m_dwLocalLayer2Protocol = 12;
    m_dwLocalUserSpecLayer2 = 0;
    m_dwLocalLayer3Protocol = FIELD_ABSENT;
    m_dwLocalUserSpecLayer3 = 0;
    m_dwLocalLayer3IPI  = 0;
    m_strLocalSnapId = c_szEmpty;

    m_dwLocalHighLayerInfoType = FIELD_ABSENT;
    m_strLocalHighLayerInfo = c_szEmpty;

    // Destination BLLI and BHLI info
    m_dwDestnLayer2Protocol = 12;
    m_dwDestnUserSpecLayer2 = 0;
    m_dwDestnLayer3Protocol = FIELD_ABSENT;
    m_dwDestnUserSpecLayer3 = 0;
    m_dwDestnLayer3IPI = 0;
    m_strDestnSnapId = c_szEmpty;

    m_dwDestnHighLayerInfoType = FIELD_ABSENT;
    m_strDestnHighLayerInfo = c_szEmpty;
}

void CPvcInfo::SetDefaultsForPPPOut()
{
    m_dwPVCType = PVC_PPP_ATM_CLIENT;

    // addresses
    m_strCallingAddr = c_szEmpty;
    m_strCalledAddr = c_szDefaultCalledAtmAddr;

    // Flags
    m_dwFlags        = 4;

    // Quality Info
    m_dwTransmitPeakCellRate    = FIELD_UNSET;
    m_dwTransmitAvgCellRate     = FIELD_UNSET;
    m_dwTransmitByteBurstLength = FIELD_UNSET;
    m_dwTransmitMaxSduSize      = 4096;
    m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_UBR;

    m_dwReceivePeakCellRate    = FIELD_UNSET;
    m_dwReceiveAvgCellRate     = FIELD_UNSET;
    m_dwReceiveByteBurstLength = FIELD_UNSET;
    m_dwReceiveMaxSduSize      = 4096;
    m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_UBR;

    // Local BLLI & BHLI
    m_dwLocalLayer2Protocol = FIELD_ABSENT;
    m_dwLocalUserSpecLayer2 = 0;
    m_dwLocalLayer3Protocol = FIELD_ABSENT;
    m_dwLocalUserSpecLayer3 = 0;
    m_dwLocalLayer3IPI  = 0;
    m_strLocalSnapId = c_szEmpty;

    m_dwLocalHighLayerInfoType = FIELD_ABSENT;
    m_strLocalHighLayerInfo = c_szEmpty;

    // Destination BLLI and BHLI info
    m_dwDestnLayer2Protocol = FIELD_ABSENT;
    m_dwDestnUserSpecLayer2 = 0;
    m_dwDestnLayer3Protocol = 11;
    m_dwDestnUserSpecLayer3 = 0;
    m_dwDestnLayer3IPI = 207;
    m_strDestnHighLayerInfo = c_szEmpty;

    m_dwDestnHighLayerInfoType = FIELD_ABSENT;
    m_strDestnHighLayerInfo = c_szEmpty;
}

void CPvcInfo::SetDefaultsForPPPIn()
{
    m_dwPVCType = PVC_PPP_ATM_SERVER;

    // addresses
    m_strCallingAddr = c_szEmpty;
    m_strCalledAddr  = c_szEmpty;

    // Flags
    m_dwFlags        = 2;

    // Quality Info
    m_dwTransmitPeakCellRate    = FIELD_UNSET;
    m_dwTransmitAvgCellRate     = FIELD_UNSET;
    m_dwTransmitByteBurstLength = FIELD_UNSET;
    m_dwTransmitMaxSduSize      = 4096;
    m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_UBR;

    m_dwReceivePeakCellRate    = FIELD_UNSET;
    m_dwReceiveAvgCellRate     = FIELD_UNSET;
    m_dwReceiveByteBurstLength = FIELD_UNSET;
    m_dwReceiveMaxSduSize      = 4096;
    m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_UBR;

    // Local BLLI & BHLI
    m_dwLocalLayer2Protocol = FIELD_ABSENT;
    m_dwLocalUserSpecLayer2 = 0;
    m_dwLocalLayer3Protocol = 11;
    m_dwLocalUserSpecLayer3 = 0;
    m_dwLocalLayer3IPI  = 207;
    m_strLocalSnapId = c_szEmpty;

    m_dwLocalHighLayerInfoType = FIELD_ABSENT;
    m_strLocalHighLayerInfo = c_szEmpty;

    // Destination BLLI and BHLI info
    m_dwDestnLayer2Protocol = FIELD_ABSENT;
    m_dwDestnUserSpecLayer2 = 0;
    m_dwDestnLayer3Protocol = FIELD_ABSENT;
    m_dwDestnUserSpecLayer3 = 0;
    m_dwDestnLayer3IPI = 0;
    m_strDestnSnapId = c_szEmpty;

    m_dwDestnHighLayerInfoType = FIELD_ABSENT;
    m_strDestnHighLayerInfo = c_szEmpty;
}

void CPvcInfo::SetDefaultsForCustom()
{
    m_dwPVCType = PVC_CUSTOM;

    // addresses
    m_strCallingAddr = c_szEmpty;
    m_strCalledAddr  = c_szEmpty;

    // Flags
    m_dwFlags      = FIELD_UNSET;

    // Quality Info
    m_dwTransmitPeakCellRate    = FIELD_UNSET;
    m_dwTransmitAvgCellRate     = FIELD_UNSET;
    m_dwTransmitByteBurstLength = FIELD_UNSET;
    m_dwTransmitMaxSduSize      = FIELD_UNSET;
    m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_UBR;

    m_dwReceivePeakCellRate    = FIELD_UNSET;
    m_dwReceiveAvgCellRate     = FIELD_UNSET;
    m_dwReceiveByteBurstLength = FIELD_UNSET;
    m_dwReceiveMaxSduSize      = FIELD_UNSET;
    m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_UBR;

    // Local BLLI & BHLI
    m_dwLocalLayer2Protocol = FIELD_ANY;
    m_dwLocalUserSpecLayer2 = 0;
    m_dwLocalLayer3Protocol = FIELD_ANY;
    m_dwLocalUserSpecLayer3 = 0;
    m_dwLocalLayer3IPI  = 0;
    m_strLocalSnapId = c_szEmpty;

    m_dwLocalHighLayerInfoType = FIELD_ANY;
    m_strLocalHighLayerInfo = c_szEmpty;

    // Destination BLLI and BHLI info
    m_dwDestnLayer2Protocol = FIELD_ANY;
    m_dwDestnUserSpecLayer2 = 0;
    m_dwDestnLayer3Protocol = FIELD_ANY;
    m_dwDestnUserSpecLayer3 = 0;
    m_dwDestnLayer3IPI = 0;
    m_strDestnSnapId = c_szEmpty;

    m_dwDestnHighLayerInfoType = FIELD_ANY;
    m_strDestnHighLayerInfo = c_szEmpty;
}

void CPvcInfo::ResetOldValues()
{
    m_dwOldPVCType = m_dwPVCType;
    m_strOldName = m_strName;

    m_dwOldVpi = m_dwVpi;
    m_dwOldVci = m_dwVci;

    m_dwOldAAL = m_dwAAL;

    m_strOldCallingAddr = m_strCallingAddr;
    m_strOldCalledAddr  = m_strCalledAddr;

    // Quality Info
    m_dwOldTransmitPeakCellRate     = m_dwTransmitPeakCellRate;
    m_dwOldTransmitAvgCellRate      = m_dwTransmitAvgCellRate;
    m_dwOldTransmitByteBurstLength  = m_dwTransmitByteBurstLength;
    m_dwOldTransmitMaxSduSize       = m_dwTransmitMaxSduSize;
    m_dwOldTransmitServiceCategory  = m_dwTransmitServiceCategory;

    m_dwOldReceivePeakCellRate     = m_dwReceivePeakCellRate;
    m_dwOldReceiveAvgCellRate      = m_dwReceiveAvgCellRate;
    m_dwOldReceiveByteBurstLength  = m_dwReceiveByteBurstLength;
    m_dwOldReceiveMaxSduSize       = m_dwReceiveMaxSduSize;
    m_dwOldReceiveServiceCategory  = m_dwReceiveServiceCategory;

    // Local BLLI & BHLI
    m_dwOldLocalLayer2Protocol = m_dwLocalLayer2Protocol;
    m_dwOldLocalUserSpecLayer2 = m_dwLocalUserSpecLayer2;
    m_dwOldLocalLayer3Protocol = m_dwLocalLayer3Protocol;
    m_dwOldLocalUserSpecLayer3 = m_dwLocalUserSpecLayer3;
    m_dwOldLocalLayer3IPI  = m_dwLocalLayer3IPI;
    m_strOldLocalSnapId = m_strLocalSnapId;

    m_dwOldLocalHighLayerInfoType = m_dwLocalHighLayerInfoType;
    m_strOldLocalHighLayerInfo = m_strLocalHighLayerInfo;

    // Destination BLLI and BHLI info
    m_dwOldDestnLayer2Protocol = m_dwDestnLayer2Protocol;
    m_dwOldDestnUserSpecLayer2 = m_dwDestnUserSpecLayer2;
    m_dwOldDestnLayer3Protocol = m_dwDestnLayer3Protocol;
    m_dwOldDestnUserSpecLayer3 = m_dwDestnUserSpecLayer3;
    m_dwOldDestnLayer3IPI = m_dwDestnLayer3IPI;
    m_strOldDestnSnapId = m_strDestnSnapId;

    m_dwOldDestnHighLayerInfoType = m_dwDestnHighLayerInfoType;
    m_strOldDestnHighLayerInfo = m_strDestnHighLayerInfo;
}

// CUniAdapterInfo
CUniAdapterInfo &  CUniAdapterInfo::operator=(const CUniAdapterInfo & info)
{
    Assert(this != &info);

    if (this == &info)
        return *this;

    // the adapter's binding state
    m_strBindName = info.m_strBindName;
    m_BindingState = info.m_BindingState;
    m_fDeleted = info.m_fDeleted;

    FreeCollectionAndItem(m_listPVCs);

    for (PVC_INFO_LIST::iterator iterPVCInfo = info.m_listPVCs.begin();
         iterPVCInfo != info.m_listPVCs.end();
         iterPVCInfo ++)
    {
        CPvcInfo * pNewPvc = new CPvcInfo((*iterPVCInfo)->m_strPvcId.c_str());

		if (pNewPvc == NULL)
		{
			continue;
		}

        *pNewPvc = **iterPVCInfo;
        m_listPVCs.push_back(pNewPvc);
    }

    return *this;
}

void CUniAdapterInfo::SetDefaults(PCWSTR pszBindName)
{
    m_strBindName = pszBindName;
    m_BindingState = BIND_UNSET;
    FreeCollectionAndItem(m_listPVCs);

    m_fDeleted = FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\auniobj.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A U N I O B J . C P P
//
//  Contents:   CAtmUniCfg interface method function implementation
//
//  Notes:
//
//  Author:     tongl   21 Mar 1997
//
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop
#include "arpsobj.h"
#include "auniobj.h"
#include "atmutil.h"
#include "ncstl.h"

#include "aunidlg.h"
#include "netconp.h"

#include "ncpnp.h"

static const WCHAR c_szAtmuni[] = L"Atmuni";

extern const WCHAR c_szInfId_MS_RawWan[];

/////////////////////////////////////////////////////////////////////////////
//

CAtmUniCfg::CAtmUniCfg()
: m_pnc(NULL),
  m_pnccUni(NULL),
  m_pnccRwan(NULL),
  m_fSaveRegistry(FALSE),
  m_fUIParamChanged(FALSE),
  m_fSecondMemoryModified(FALSE),
  m_fPVCInfoLoaded(FALSE),
  m_strGuidConn(c_szEmpty),
  m_pUnkContext(NULL),
  m_pSecondMemoryAdapterInfo(NULL),
  m_uniPage(NULL)
{
}

CAtmUniCfg::~CAtmUniCfg()
{
    ReleaseObj(m_pnc);
    ReleaseObj(m_pnccUni);
    ReleaseObj(m_pnccRwan);
    FreeCollectionAndItem(m_listAdapters);

    // Just a safty check to make sure the context is released.
    AssertSz((m_pUnkContext == NULL), "Why is context not released ? Not a bug in ATM UNI config.");
    if (m_pUnkContext)
        ReleaseObj(m_pUnkContext) ;

    delete m_uniPage;
}


// INetCfgComponentControl
STDMETHODIMP CAtmUniCfg::Initialize (INetCfgComponent* pncc,
                                     INetCfg* pNetCfg,
                                     BOOL fInstalling )
{
    HRESULT hr = S_OK;

    Validate_INetCfgNotify_Initialize(pncc, pNetCfg, fInstalling);

    AssertSz(pNetCfg, "NetCfg pointer is NULL!");

    m_pnc = pNetCfg;
    AddRefObj(m_pnc);

    AssertSz(pncc, "Component pointer is NULL!");

    m_pnccUni = pncc;
    AddRefObj(m_pnccUni);

    // Get a copy of the ATMRwan and store in our object
    hr = m_pnc->FindComponent(c_szInfId_MS_RawWan, &m_pnccRwan);

    if (S_FALSE == hr) // RWan not found
    {
        if (!fInstalling) // Trace the error, RWan should be installed
        {
            TraceError("CAtmUniCfg::Initialize - ATMRwan has not been installed yet", hr);
        }
        else // We are ok since ATMUNI will install ATMRwan
        {
            hr = S_OK;
        }
    }

    // Construct the in memory structure (m_listAdapters) by
    // iterating through the binding path
    if (!fInstalling)
    {
        hr = HrLoadSettings();
    }

    Validate_INetCfgNotify_Initialize_Return(hr);

    TraceError("CAtmUniCfg::Initialize", hr);
    return hr;
}

STDMETHODIMP CAtmUniCfg::Validate ()
{
    return S_OK;
}

STDMETHODIMP CAtmUniCfg::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP CAtmUniCfg::ApplyRegistryChanges ()
{
    HRESULT hr = S_OK;

    if (m_fSaveRegistry)
    {
        hr = HrSaveSettings();

        if (SUCCEEDED(hr) && m_fUIParamChanged)
        {
            // send reconfig notification if parameter has changed
            for (UNI_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
                 iterAdapter != m_listAdapters.end();
                 iterAdapter ++)
            {
                if ((*iterAdapter)->m_fDeleted)
                    continue;

                if (FIsSubstr(m_strGuidConn.c_str(), (*iterAdapter)->m_strBindName.c_str()))
                {
                    HRESULT hrReconfig;

                    hrReconfig  = HrSendNdisPnpReconfig(NDIS, c_szAtmuni,
                                                        (*iterAdapter)->m_strBindName.c_str(),
                                                        NULL, 0);
                    if (FAILED(hrReconfig))
                    {
                        TraceTag(ttidAtmUni,"Notifying Atm UNI Call manager of parameter change returns failure, prompt for reboot ...");
                        hr = NETCFG_S_REBOOT;
                    }
                    break;
                }
            }
        }
    }
    else
    {
        // no change
        hr = S_FALSE;
    }

    Validate_INetCfgNotify_Apply_Return(hr);

    TraceError("CAtmUniCfg::ApplyRegistryChanges", (S_FALSE == hr)? S_OK : hr);
    return hr;
}

// INetCfgComponentSetup
STDMETHODIMP CAtmUniCfg::Install (DWORD dwSetupFlags)
{
    m_fSaveRegistry = TRUE;

    // Just in case it was installed already, we need to release
    // m_pnccRwan before we overwrite it.
    //
    ReleaseObj (m_pnccRwan);

    // Install the ATM Rawwan protocol on behalf of ATMUNI
    HRESULT hr = HrInstallComponentOboComponent( m_pnc, NULL,
                                                 GUID_DEVCLASS_NETTRANS,
                                                 c_szInfId_MS_RawWan,
                                                 m_pnccUni,
                                                 &m_pnccRwan);

    TraceError("CAtmUniCfg::Install", hr);
    return hr;
}

STDMETHODIMP CAtmUniCfg::Upgrade(DWORD dwSetupFlags,
                                 DWORD dwUpgradeFomBuildNo )
{
    return S_FALSE;
}

STDMETHODIMP CAtmUniCfg::ReadAnswerFile(PCWSTR pszAnswerFile,
                                        PCWSTR pszAnswerSection)
{
    return S_OK;
}

STDMETHODIMP CAtmUniCfg::Removing ()
{
    // Remove ATMRwan protocol
    HRESULT hr = HrRemoveComponentOboComponent(m_pnc,
                                               GUID_DEVCLASS_NETTRANS,
                                               c_szInfId_MS_RawWan,
                                               m_pnccUni);

    TraceError("CAtmUniCfg::Removing", hr);
    return hr;
}

// INetCfgBindNotify

STDMETHODIMP CAtmUniCfg::QueryBindingPath (DWORD dwChangeFlag,
                                           INetCfgBindingPath* pncbpItem )
{
    return S_OK;
}

STDMETHODIMP CAtmUniCfg::NotifyBindingPath (DWORD dwChangeFlag,
                                            INetCfgBindingPath* pncbp )
{
    Assert(!(dwChangeFlag & NCN_ADD && dwChangeFlag & NCN_REMOVE));
    Assert(!(dwChangeFlag & NCN_ENABLE && dwChangeFlag & NCN_DISABLE));

    // If we are told to add a card, we must be told at the same time whether the
    // binding is enabled or disabled
    Assert(FImplies((dwChangeFlag & NCN_ADD),
                    ((dwChangeFlag & NCN_ENABLE)||(dwChangeFlag & NCN_DISABLE))));

    // We handle NCN_ADD and NCN_REMOVE only (for Beta1):
    // NCN_ADD:     if item not on list, add a new item
    // NCN_REMOVE:  if item already on list, remove the item

    HRESULT hr = S_OK;

    Validate_INetCfgBindNotify_NotifyBindingPath (dwChangeFlag,pncbp);

    INetCfgComponent * pnccLastComponent;
    hr = HrGetLastComponentAndInterface(pncbp,
            &pnccLastComponent, NULL);

    if SUCCEEDED(hr)
    {
        GUID guidNetClass;
        hr = pnccLastComponent->GetClassGuid (&guidNetClass);

        AssertSz(IsEqualGUID(guidNetClass, GUID_DEVCLASS_NET),
            "Why the last component on the path is not an adapter?");

        // Is this a net card ?
        if (SUCCEEDED(hr) && IsEqualGUID(guidNetClass, GUID_DEVCLASS_NET))
        {
            // If we are adding/removing cards, set m_fSaveRegistry
            // so we apply the changes to registry

            if (dwChangeFlag & NCN_ADD)
            {
                hr = HrAddAdapter(pnccLastComponent);
            }

            if(dwChangeFlag & NCN_ENABLE)
            {
                hr = HrBindAdapter(pnccLastComponent);
            }

            if(dwChangeFlag & NCN_DISABLE)
            {
                hr = HrUnBindAdapter(pnccLastComponent);
            }

            if (dwChangeFlag & NCN_REMOVE)
            {
                hr = HrRemoveAdapter(pnccLastComponent);
            }
        }
        ReleaseObj (pnccLastComponent);
    }
    Validate_INetCfgBindNotify_NotifyBindingPath_Return(hr);

    TraceError("CAtmUniCfg::NotifyBindingPath", hr);
    return hr;
}

// INetCfgProperties
STDMETHODIMP CAtmUniCfg::QueryPropertyUi (IUnknown* pUnk)
{
    HRESULT hr = S_FALSE;
    if (pUnk)
    {
        // Is this a lan connection ?
        INetLanConnectionUiInfo * pLanConnUiInfo;
        hr = pUnk->QueryInterface( IID_INetLanConnectionUiInfo,
                                   reinterpret_cast<LPVOID *>(&pLanConnUiInfo));

        if(FAILED(hr))
        {
            hr = S_FALSE;
        }
    }

    TraceError("CAtmUniCfg::SetContext", hr);
    return hr;
}

STDMETHODIMP CAtmUniCfg::SetContext(IUnknown * pUnk)
{
    HRESULT hr = S_OK;

    // release previous context, if any
    if (m_pUnkContext)
        ReleaseObj(m_pUnkContext);
    m_pUnkContext = NULL;

    if (pUnk) // set the new context
    {
        m_pUnkContext = pUnk;
        m_pUnkContext->AddRef();
    }

    TraceError("CArpsCfg::SetContext", hr);
    return hr;
}

STDMETHODIMP CAtmUniCfg::MergePropPages (
    IN OUT DWORD* pdwDefPages,
    OUT LPBYTE* pahpspPrivate,
    OUT UINT* pcPages,
    IN HWND hwndParent,
    OUT PCWSTR* pszStartPage)

{
    HRESULT hr = S_OK;

    // Initialize output parameter
    HPROPSHEETPAGE *ahpsp = NULL;
    int cPages = 0;

    Validate_INetCfgProperties_MergePropPages (
        pdwDefPages, pahpspPrivate, pcPages, hwndParent, pszStartPage);

    // We don't want any default pages to be shown
    *pdwDefPages = 0;
    *pcPages = NULL;
    *pahpspPrivate = NULL;

    // get the connection context in which we are bringing up the UI
    hr = HrSetConnectionContext();

    if SUCCEEDED(hr)
    {
        // Initialize the common controls library
        INITCOMMONCONTROLSEX icc;
        icc.dwSize = sizeof(icc);
        icc.dwICC  = ICC_INTERNET_CLASSES;

        SideAssert(InitCommonControlsEx(&icc));

        hr = HrSetupPropSheets(&ahpsp, &cPages);
        if (SUCCEEDED(hr))
        {
            *pahpspPrivate = (LPBYTE)ahpsp;
            *pcPages = cPages;
        }
        else
        {
            *pcPages = 0;
            CoTaskMemFree(ahpsp);
        }
    }
    Validate_INetCfgProperties_MergePropPages_Return(hr);

    TraceError("CAtmUniCfg::MergePropPages", hr);
    return hr;
}

STDMETHODIMP CAtmUniCfg::ValidateProperties (HWND hwndSheet)
{
    // all error checking are done in the UI
    return S_OK;
}

STDMETHODIMP CAtmUniCfg::CancelProperties ()
{
    // Release second memory info
    delete m_pSecondMemoryAdapterInfo;
    m_pSecondMemoryAdapterInfo = NULL;

    return S_OK;
}

STDMETHODIMP CAtmUniCfg::ApplyProperties ()
{
    HRESULT hr = S_OK;

    if(!m_fSaveRegistry)
        m_fSaveRegistry = m_fSecondMemoryModified;

    if(!m_fUIParamChanged)
        m_fUIParamChanged = m_fSecondMemoryModified;

    // Copy info from second memory state to first memory state
    if (m_fSecondMemoryModified)
    {
        hr = HrSaveAdapterPVCInfo();
    }

    // Release second memory info
    delete m_pSecondMemoryAdapterInfo;
    m_pSecondMemoryAdapterInfo = NULL;

    Validate_INetCfgProperties_ApplyProperties_Return(hr);

    TraceError("CAtmUniCfg::ApplyProperties", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\netcfg\atmcfg\pvcdlg.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P V C D L G . C P P
//
//  Contents:   PVC main dialog message handler implementation
//
//  Notes:
//
//  Author:     tongl   23 Feb, 1998
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "auniobj.h"
#include "atmutil.h"
#include "aunidlg.h"
#include "atmcommon.h"
#include "pvcdata.h"

#include "ncatlui.h"
#include "ncstl.h"
#include "ncui.h"

#include "atmhelp.h"

CPVCMainDialog::CPVCMainDialog( CUniPage * pUniPage,
                                CPvcInfo *  pPvcInfo,
                                const DWORD* adwHelpIDs)
{
    Assert(pUniPage);
    Assert(pPvcInfo);

    m_pParentDlg = pUniPage;
    m_pPvcInfo = pPvcInfo;
    m_adwHelpIDs = adwHelpIDs;

    m_fDialogModified = FALSE;

    m_fPropShtOk = FALSE;
    m_fPropShtModified = FALSE;

    m_pQosPage    = NULL;
    m_pLocalPage  = NULL;
    m_pDestPage   = NULL;
}

CPVCMainDialog::~CPVCMainDialog()
{
    if (m_pQosPage != NULL)
	{
		delete (m_pQosPage);
	}

    if (m_pLocalPage != NULL)
	{
		delete (m_pLocalPage);
	}

    if (m_pDestPage != NULL)
	{
		delete (m_pDestPage);
	}
}

LRESULT CPVCMainDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                     LPARAM lParam, BOOL& fHandled)
{
    m_CurType = m_pPvcInfo->m_dwPVCType;

    InitInfo();
    SetInfo();
    return 0;
}

LRESULT CPVCMainDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CPVCMainDialog::OnHelp(UINT uMsg, WPARAM wParam,
                               LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CPVCMainDialog::OnOk(WORD wNotifyCode, WORD wID,
                             HWND hWndCtl, BOOL& fHandled)
{
    // load the info from the controls to memory structure
    UpdateInfo();

    // make sure vpi, vci are in their range
    if (m_pPvcInfo->m_dwVpi > MAX_VPI)
    {
        // we pop up a message box and set focus to the vpi edit box
        NcMsgBox(m_hWnd, IDS_MSFT_UNI_TEXT, IDS_INVALID_VPI,
                                MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        ::SetFocus(GetDlgItem(IDC_EDT_PVC_VPI));
        return 0;
    }

    i