(
                             PQWORD pqTic,
                             PQWORD pqFreq OPTIONAL
                             )
{

    LARGE_INTEGER TempTic, TempFreq;

    // call the NT API to do the needful and return.
    NtQueryPerformanceCounter (&TempTic, &TempFreq);
    pqTic->LowPart = TempTic.LowPart;
    pqTic->HighPart = TempTic.HighPart;
    pqFreq->LowPart = TempFreq.LowPart;
    pqFreq->HighPart = TempFreq.HighPart;

    return;
}

/*******************************************************************

     Added this routine TimerConvertTicsToUSec to return
     time in usecs. for a given elapsed tic count and freq.


     Accepts - ULONG    - Elapsed Tic Count.

               ULONG    - Frequency.

     Returns - Elapsed Time in usecs. as a ULONG.
             - Zero if input freq. is zero.

*******************************************************************/

ULONG
TimerConvertTicsToUSec (
                       ULONG ulElapsedTics,
                       ULONG ulInputFreq
                       )
{

    LARGE_INTEGER ElapsedTime;
    ULONG ulRemainder = 0L;

    // if the person gives me a zero freq, return him a zero.
    // Let him tear his hair.

    if (!ulInputFreq)
        return 0L;

    // multiply tics by a million and divide by the frequency.

    ElapsedTime = RtlEnlargedIntegerMultiply (ulElapsedTics, MICROSEC_FACTOR);

    ElapsedTime = RtlExtendedLargeIntegerDivide (ElapsedTime,
                                                 ulInputFreq,
                                                 &ulRemainder);

    ElapsedTime.LowPart += (ulRemainder > (ulInputFreq / 2L));

    return (ElapsedTime.LowPart) ; /* get the result into a ULONG */
}

/**************** ROUTINES NOT EXPORTED, FOLLOW ************************/

/*
*     Function  - CalibrateTimerForOverhead  (NOT EXPORTED)
*     Arguments - None
*     Returns   - ULONG
*
*     Calls TimerElapsedTime a few times to compute the expected
*     mean.  Calls TimerElapsedTime more number of times and
*     averages the mean out of those calls that did not exceed
*     the expected mean by 15%.
*/

ULONG
CalibrateTimerForOverhead (VOID)
{
    ULONG ulOverhead [ITER_FOR_OVERHEAD];
    ULONG ulTempTotal = 0L;
    ULONG ulExpectedValue = 0L;
    SHORT csIter;
    SHORT csNoOfSamples = ITER_FOR_OVERHEAD;
    SHORT hTimerHandle;

    if (TimerOpen (&hTimerHandle, MICROSECONDS)) /* open failed.  Return 0 */
        return (0L);

    for (csIter = 0; csIter < 5; csIter++) {
        TimerInit (hTimerHandle);
        ulOverhead [csIter] = TimerRead (hTimerHandle);
        /* if negative, make zero */
        if (((LONG) ulOverhead [csIter]) < 0)
            ulOverhead [csIter] = 0L;
    }
    /* The get elapsed time function has been called 6 times.
       The idea is to calculate the expected mean, then call
       TimerElapsedTime a bunch of times and throw away all times
       that are 15% larger than this mean.  This would give a
       really good overhead time */

    for (csIter = 0; csIter < 5; csIter++ )
        ulTempTotal += ulOverhead [csIter];

    ulExpectedValue = ulTempTotal / 5;

    for (csIter = 0; csIter < ITER_FOR_OVERHEAD; csIter++) {
        TimerInit (hTimerHandle);
        ulOverhead [csIter] = TimerRead (hTimerHandle);
        /* if negative, make zero */
        if (((LONG) ulOverhead [csIter]) < 0)
            ulOverhead [csIter] = 0L;
    }

    ulTempTotal = 0L;         /* reset this value */
    for (csIter = 0; csIter < ITER_FOR_OVERHEAD; csIter++ ) {
        if (ulOverhead [csIter] <=  (ULONG) (115L * ulExpectedValue/100L))
            /* include all samples that is < 115% of ulExpectedValue */
            ulTempTotal += ulOverhead [csIter];
        else
            /* ignore this sample and dec. sample count */
            csNoOfSamples--;
    }
    TimerClose (hTimerHandle);

    if (csNoOfSamples == 0)  /* no valid times.  Return a 0 for overhead */
        return (0L);

    return (ulTempTotal/csNoOfSamples);
}

/*
*       Function - GetTimerFreq    (NOT EXPORTED)
*
*      Arguments - None
*
*
*      Return    - 0 if successful or an error code if timer not aailable
*
*      Calls the function to return freq
*
*/
SHORT
GetTimerFreq (VOID)
{
    LARGE_INTEGER PerfCount, Freq;
    NTSTATUS NtStatus;

    NtStatus = NtQueryPerformanceCounter (&PerfCount, &Freq);

    if ((Freq.LowPart == 0L)  && (Freq.HighPart == 0L))
        /* frequency of zero implies timer not available */
        return (TIMERERR_NOT_AVAILABLE);

    PerfFreq.LowPart = Freq.LowPart;
    PerfFreq.HighPart = (LONG) Freq.HighPart;

    return 0;
}

/***************************************************

NT native dll init routine

****************************************************/
SHORT csTempCtr;    /* a counter - had to make this global..compile fails */
ULONG culTemp;      /*    - do -    */

NTSTATUS
TimerDllInitialize (
                   IN PVOID DllHandle,
                   ULONG Reason,
                   IN PCONTEXT Context OPTIONAL
                   )
{
    DllHandle, Context;     // avoid compiler warnings

    if (Reason != DLL_PROCESS_ATTACH) { // if detaching return immediately
        return TRUE;
    }

    for (csTempCtr = 0; csTempCtr < MAX_TIMERS; csTempCtr++) {
        pTimer [csTempCtr].ulLo = 0L;
        pTimer [csTempCtr].ulHi = 0L;
        pTimer [csTempCtr].TUnits = TIMER_FREE;
    }

    bTimerInit = TRUE;
    GetTimerFreq ();
    ulTimerOverhead = CalibrateTimerForOverhead ();
    /* the timer overhead will be placed in a global variable */
    bCalibrated = TRUE;
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pfmon\debug.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Main debug loop for pfmon

Author:

    Mark Lucovsky (markl) 26-Jan-1995

Revision History:

--*/

#include "pfmonp.h"

DWORD
DebugEventHandler(
    LPDEBUG_EVENT DebugEvent
    );

VOID
DebugEventLoop( VOID )
{
    DEBUG_EVENT DebugEvent;
    DWORD ContinueStatus;
    DWORD OldPriority;

    //
    // We want to process debug events quickly
    //

    OldPriority = GetPriorityClass( GetCurrentProcess() );
    SetPriorityClass( GetCurrentProcess(), HIGH_PRIORITY_CLASS );

    do {
retry_debug_wait:
        ProcessPfMonData();
        if (!WaitForDebugEvent( &DebugEvent, 500 )) {
            if ( GetLastError() == ERROR_SEM_TIMEOUT ) {
                goto retry_debug_wait;
                }
            DeclareError( PFMON_WAITDEBUGEVENT_FAILED, GetLastError() );
            ExitProcess( 1 );
            }
        ProcessPfMonData();
        if ( fVerbose ) {
            if (DebugEvent.dwDebugEventCode == EXCEPTION_DEBUG_EVENT) {
                fprintf(stderr,"Debug exception event - Code: %x  Address: %p  Info: [%u] %x %x %x %x\n",
                        DebugEvent.u.Exception.ExceptionRecord.ExceptionCode,
                        DebugEvent.u.Exception.ExceptionRecord.ExceptionAddress,
                        DebugEvent.u.Exception.ExceptionRecord.NumberParameters,
                        DebugEvent.u.Exception.ExceptionRecord.ExceptionInformation[ 0 ],
                        DebugEvent.u.Exception.ExceptionRecord.ExceptionInformation[ 1 ],
                        DebugEvent.u.Exception.ExceptionRecord.ExceptionInformation[ 2 ],
                        DebugEvent.u.Exception.ExceptionRecord.ExceptionInformation[ 3 ]
                        );
                }
            else {
                fprintf(stderr,"Debug %x event\n", DebugEvent.dwDebugEventCode);
                }
            }

        ContinueStatus = DebugEventHandler( &DebugEvent );

        if ( fVerbose ) {
            fprintf(stderr,"Continue Status %x\n", ContinueStatus);
            }

        if (!ContinueDebugEvent( DebugEvent.dwProcessId,
                                 DebugEvent.dwThreadId,
                                 ContinueStatus
                               )
           ) {
            DeclareError( PFMON_CONTDEBUGEVENT_FAILED, GetLastError() );
            ExitProcess( 1 );
            }
        }
    while (!IsListEmpty( &ProcessListHead ));


    //
    // Drop back to old priority to interact with user.
    //

    SetPriorityClass( GetCurrentProcess(), OldPriority );
}

DWORD
DebugEventHandler(
    LPDEBUG_EVENT DebugEvent
    )
{
    DWORD ContinueStatus;
    PPROCESS_INFO Process;
    PTHREAD_INFO Thread;
    CONTEXT Context;
    PCONTEXT pContext;


    ContinueStatus = (DWORD)DBG_CONTINUE;
    if (FindProcessAndThreadForEvent( DebugEvent, &Process, &Thread )) {
        switch (DebugEvent->dwDebugEventCode) {
            case CREATE_PROCESS_DEBUG_EVENT:
                //
                // Create process event includes first thread of process
                // as well.  Remember process and thread in our process tree
                //

                if (AddProcess( DebugEvent, &Process )) {
                    AddModule( DebugEvent );
                    AddThread( DebugEvent, Process, &Thread );
                    }
                break;

            case EXIT_PROCESS_DEBUG_EVENT:
                //
                // Exit process event includes last thread of process
                // as well.  Remove process and thread from our process tree
                //

                if (DeleteThread( Process, Thread )) {
                    DeleteProcess( Process );
                    }
                break;

            case CREATE_THREAD_DEBUG_EVENT:
                //
                // Create thread.  Remember thread in our process tree.
                //

                AddThread( DebugEvent, Process, &Thread );
                break;

            case EXIT_THREAD_DEBUG_EVENT:
                //
                // Exit thread.  Remove thread from our process tree.
                //

                DeleteThread( Process, Thread );
                break;

            case LOAD_DLL_DEBUG_EVENT:
                AddModule( DebugEvent );
                break;

            case UNLOAD_DLL_DEBUG_EVENT:
                break;

            case OUTPUT_DEBUG_STRING_EVENT:
            case RIP_EVENT:
                //
                // Ignore these
                //
                break;

            case EXCEPTION_DEBUG_EVENT:
                //
                // Assume we wont handle this exception
                //

                ContinueStatus = (DWORD)DBG_CONTINUE;
                switch (DebugEvent->u.Exception.ExceptionRecord.ExceptionCode) {
                    //
                    // Breakpoint exception.
                    //

                    case STATUS_BREAKPOINT:
                            Context.ContextFlags = CONTEXT_FULL;

                            if (!GetThreadContext( Thread->Handle, &Context )) {
                                fprintf(stderr,"Failed to get context for thread %x (%p) - %u\n", Thread->Id, Thread->Handle, GetLastError());
                                ExitProcess(1);
                                }
                            pContext = &Context;

                            PROGRAM_COUNTER_TO_CONTEXT(pContext, (ULONG_PTR)((PCHAR)DebugEvent->u.Exception.ExceptionRecord.ExceptionAddress + BPSKIP));

                            if (!SetThreadContext( Thread->Handle, &Context )) {
                                fprintf(stderr,"Failed to set context for thread %x (%p) - %u\n", Thread->Id, Thread->Handle, GetLastError());
                                ExitProcess(1);
                                }

                        break;

                    default:
                        ContinueStatus = (DWORD) DBG_EXCEPTION_NOT_HANDLED;
                        if ( fVerbose ) {
                            fprintf(stderr,"Unknown exception: %08x at %p\n",
                                    DebugEvent->u.Exception.ExceptionRecord.ExceptionCode,
                                    DebugEvent->u.Exception.ExceptionRecord.ExceptionAddress
                                    );
                            }
                        break;
                    }
                break;

            default:
                break;
            }
        }
    return( ContinueStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pfmon\error.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    error.c

Abstract:

    Error handle module for the pfmon program

Author:

    Mark Lucovsky (markl) 26-Jan-1995

Revision History:

--*/

#include "pfmonp.h"

VOID
__cdecl
DeclareError(
    UINT ErrorCode,
    UINT SupplementalErrorCode,
    ...
    )
{
    va_list arglist;
    HMODULE ModuleHandle;
    DWORD Flags, Size;
    UCHAR MessageBuffer[ 512 ];

    va_start( arglist, SupplementalErrorCode );

    if ((ErrorCode & 0x0FFF0000) >> 16 == FACILITY_APPLICATION) {
        ModuleHandle = PfmonModuleHandle;
        Flags = FORMAT_MESSAGE_FROM_HMODULE;
        }
    else {
        ModuleHandle = NULL;
        Flags = FORMAT_MESSAGE_FROM_SYSTEM;
        }

    Size = FormatMessage( Flags,
                          (LPCVOID)ModuleHandle,
                          ErrorCode,
                          0,
                          MessageBuffer,
                          sizeof( MessageBuffer ),
                          &arglist
                        );
    va_end( arglist );

    if (Size != 0) {
        fprintf( stderr, "PFMON: %s", MessageBuffer );
        }
    else {
        fprintf( stderr, "PFMON: Unable to get message text for %08x\n", ErrorCode );
        }

    if (ModuleHandle == PfmonModuleHandle &&
        SupplementalErrorCode != 0 &&
        SupplementalErrorCode != ERROR_GEN_FAILURE
       ) {

        ModuleHandle = NULL;
        Flags = FORMAT_MESSAGE_FROM_SYSTEM;
        Size = FormatMessage( Flags,
                              (LPCVOID)ModuleHandle,
                              SupplementalErrorCode,
                              0,
                              MessageBuffer,
                              sizeof( MessageBuffer ),
                              NULL
                            );
        if (Size != 0) {
            while (Size != 0 && MessageBuffer[ Size ] <= ' ') {
                MessageBuffer[ Size ] = '\0';
                Size -= 1;
                }

            printf( "          '%s'\n", MessageBuffer );
            }
        else {
            printf( "PFMON: Unable to get message text for %08x\n", SupplementalErrorCode );
            }
        }



    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\perftool\wait\wait.c ===
#include <windows.h>
#include <stdlib.h>

//
//  Program sleeps for desired amount of time, but at least
//  two seconds.  Beeps 5 times to warn of start.  Beeps once at end.
//


int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
	unsigned i, uSecs;

	if(argc <=1)
		return(1);

	for (i=1; i<=5; i++) {
	    Beep(360, 200);
	    Sleep(200);
	}

	uSecs = atoi(argv[1]);

    //
    // The test for 2 is because we already waited for 2 seconds,
    // above.
    //
    // The subtraction of 700 milliseconds allows for startup
    // time on my 486/33 EISA machine.  Your milage may vary.
    //


    if (uSecs > 2) {
        Sleep(1000*(uSecs-2)-700);
    }

    Beep(360, 200);
	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pfmon\module.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    module.c

Abstract:

    This module maintains the module (symbol) information for the pfmon application

Author:

    Mark Lucovsky (markl) 27-Jan-1995

Revision History:

--*/

#include "pfmonp.h"

BOOL
AddModule(
    LPDEBUG_EVENT DebugEvent
    )
{
    PMODULE_INFO Module;
    LPVOID BaseAddress;
    HANDLE Handle;
    IMAGEHLP_MODULE ModuleInfo;

    if (DebugEvent->dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) {
        Handle = DebugEvent->u.CreateProcessInfo.hFile;
        BaseAddress = DebugEvent->u.CreateProcessInfo.lpBaseOfImage;
    }
    else {
        Handle = DebugEvent->u.LoadDll.hFile;
        BaseAddress = DebugEvent->u.LoadDll.lpBaseOfDll;
    }

    Module = FindModuleContainingAddress(BaseAddress);

    if (Module) {
        DeleteModule(Module);
    }

    Module = LocalAlloc(LMEM_ZEROINIT, sizeof( *Module ) );

    if (Module == NULL) {
        return FALSE;
    }

    Module->Handle = Handle;
    Module->BaseAddress = BaseAddress;

    if (!Module->Handle) {
        LocalFree(Module);
        return FALSE;
    }

    if (!SymLoadModule (hProcess,Handle,NULL,NULL,(DWORD_PTR)BaseAddress,0)) {
        LocalFree(Module);
        return FALSE;
    }

    ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);
    if (!SymGetModuleInfo (hProcess, (DWORD_PTR)BaseAddress, &ModuleInfo)) {
        LocalFree(Module);
        return FALSE;
    }

    Module->VirtualSize = ModuleInfo.ImageSize;
    Module->ModuleName = _strdup(ModuleInfo.ModuleName);

    InsertTailList( &ModuleListHead, &Module->Entry );

    return TRUE;
}

BOOL
DeleteModule(
    PMODULE_INFO Module
    )
{
    CHAR Line[256];

    if ( Module ) {
        RemoveEntryList(&Module->Entry);

        sprintf(Line,"%16s Caused %6d faults had %6d Soft %6d Hard faulted VA's\n",
            Module->ModuleName ? Module->ModuleName : "Unknown",
            Module->NumberCausedFaults,
            Module->NumberFaultedSoftVas,
            Module->NumberFaultedHardVas
            );

        if ( !fLogOnly ) {
            fprintf(stdout,"%s",Line);
        }

        if ( LogFile ) {
            fprintf(LogFile,"%s",Line);
        }

        if (Module->ModuleName) {
            free (Module->ModuleName);
        }

        LocalFree(Module);
    }

    return TRUE;
}


PMODULE_INFO
FindModuleContainingAddress(
    LPVOID Address
    )
{
    PLIST_ENTRY Next;
    PMODULE_INFO Module;
    BOOL LazyLoadStatus;

    Next = ModuleListHead.Flink;
    while ( Next != &ModuleListHead ) {
        Module = CONTAINING_RECORD(Next,MODULE_INFO,Entry);
        if ( Address >= Module->BaseAddress &&
             Address < (LPVOID)((PUCHAR)(Module->BaseAddress)+Module->VirtualSize) ) {
            return Module;
        }
        Next = Next->Flink;
    }

    Module = NULL;

    //
    // if address is a kernel mode address and we have lazy loaded
    // kernel symbols, then try to load a kernel symbol file
    //

    if ( fKernel && (ULONG_PTR)Address >= SystemRangeStart && LazyModuleInformation ) {
        fKernel = FALSE;
        LazyLoadStatus = LazyLoad(Address);

        if ( LazyLoadStatus ) {
            Module = FindModuleContainingAddress(Address);
        }
        fKernel = TRUE;
    }


    return Module;
}

VOID
SetSymbolSearchPath(
    VOID
    )
{
    LPSTR lpSymPathEnv, lpAltSymPathEnv, lpSystemRootEnv;
    ULONG cbSymPath;
    DWORD dw;

    cbSymPath = 18;
    if (lpSymPathEnv = getenv("_NT_SYMBOL_PATH")) {
        cbSymPath += strlen(lpSymPathEnv) + 1;
    }
    if (lpAltSymPathEnv = getenv("_NT_ALT_SYMBOL_PATH")) {
        cbSymPath += strlen(lpAltSymPathEnv) + 1;
    }

    if (lpSystemRootEnv = getenv("SystemRoot")) {
        cbSymPath += strlen(lpSystemRootEnv) + 1;
    }

    SymbolSearchPath = LocalAlloc(LMEM_ZEROINIT,cbSymPath);
    if (!SymbolSearchPath) {
        return;
    }

    if (lpAltSymPathEnv) {
        dw = GetFileAttributes(lpAltSymPathEnv);
        if ( dw != 0xffffffff && dw & FILE_ATTRIBUTE_DIRECTORY ) {
            strcat(SymbolSearchPath,lpAltSymPathEnv);
            strcat(SymbolSearchPath,";");
        }
    }
    if (lpSymPathEnv) {
        dw = GetFileAttributes(lpSymPathEnv);
        if ( dw != 0xffffffff && dw & FILE_ATTRIBUTE_DIRECTORY ) {
            strcat(SymbolSearchPath,lpSymPathEnv);
            strcat(SymbolSearchPath,";");
        }
    }

    if (lpSystemRootEnv) {
        dw = GetFileAttributes(lpSystemRootEnv);
        if ( dw != 0xffffffff && dw & FILE_ATTRIBUTE_DIRECTORY ) {
            strcat(SymbolSearchPath,lpSystemRootEnv);
            strcat(SymbolSearchPath,";");
        }
    }

    strcat(SymbolSearchPath,".;");
}


LONG
AddKernelDrivers(VOID)

/************************************************************\
This function is used to load the symbol information for
the system files that are loaded so that the page faults
in the kernal can be displayed.

Setting of the environmental variables are important for
ensuring that the symbols load up correctly.

returns: The success of the function
\*************************************************************/


{

    NTSTATUS status;
    PVOID pModuleInfo;
    ULONG lDataSize;
    ULONG lRetSize;
    PRTL_PROCESS_MODULES pModuleInformation;


    //First we need to get a list of all the modules currently
    //running

    //Allocate an initial sized buffer

    lDataSize = 1024 * 12;
    pModuleInfo = (PVOID) LocalAlloc (LMEM_FIXED, lDataSize);

    if (!pModuleInfo) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //Keep querying the system and incrementing the
    //size of the buffer until we can get all the information back

    do {
        //Query for modules loaded up

        status = NtQuerySystemInformation(SystemModuleInformation,
                                          pModuleInfo,
                                          lDataSize,
                                          &lRetSize);


        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            LocalFree (pModuleInfo);
            lDataSize += 1024 * 4;
            pModuleInfo = (PVOID) LocalAlloc (LMEM_FIXED, lDataSize);
        }

        if (!pModuleInfo) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

    } while (status == STATUS_INFO_LENGTH_MISMATCH);

    LazyModuleInformation = (PRTL_PROCESS_MODULES) pModuleInfo;

    return 1;
}



BOOL
LazyLoad(
    LPVOID Address
    )
{
    PRTL_PROCESS_MODULES pModuleInformation;
    DWORD i;
    BYTE szImageFilePath[ MAX_PATH ];
    PMODULE_INFO Module;
    ULONG_PTR BaseAddress;
    HANDLE hFile;
    LPSTR szFileName;
    IMAGEHLP_MODULE ModuleInfo;

    pModuleInformation = (PRTL_PROCESS_MODULES) LazyModuleInformation;

    //Loop through all the items in the structure and
    //and add their symbols to the module structures kept by pfmon.

    for (i = 0; i < pModuleInformation->NumberOfModules; i += 1) {

        BaseAddress = (ULONG_PTR)pModuleInformation->Modules[i].ImageBase;

        //Only look at the kernel space modules

        if (BaseAddress >= SystemRangeStart) {

            if ( (ULONG_PTR)Address > BaseAddress &&
                 (ULONG_PTR)Address <= BaseAddress+pModuleInformation->Modules[i].ImageSize ) {

                szFileName = pModuleInformation->Modules[i].FullPathName +
                             pModuleInformation->Modules[i].OffsetToFileName;

                strcpy (szImageFilePath,
                        pModuleInformation->Modules[i].FullPathName);

                hFile = FindExecutableImage (szFileName,
                                             SymbolSearchPath,
                                             (PCHAR) szImageFilePath );

                if (!hFile) {
                    fprintf(stdout,"Failed to get Executable Image - ");
                    return FALSE;
                }

                //Check to make sure this hasn't already been loaded

                Module = FindModuleContainingAddress((LPVOID)BaseAddress);

                if ( Module ) {
                    fprintf(stdout,"Item has been loaded already: %s",szFileName);
                    DeleteModule(Module);
                }

                //Now create the module record and fill in its fields

                Module = LocalAlloc(LMEM_ZEROINIT, sizeof( *Module ) );

                if (Module == NULL) {
                    return FALSE;
                }

                Module->Handle = hFile;
                Module->BaseAddress = (LPVOID)BaseAddress;

                if (!SymLoadModule (hProcess, hFile, NULL, NULL, BaseAddress, 0)) {
                    LocalFree(Module);
                    fprintf(stdout, "Failed to load -- ");
                    return FALSE;
                }

                ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);
                if (!SymGetModuleInfo (hProcess, BaseAddress, &ModuleInfo)) {
                    LocalFree(Module);
                    fprintf(stdout, "Failed to load -- ");
                    return FALSE;
                }

                Module->VirtualSize = ModuleInfo.ImageSize;

                fprintf(stdout, "Loaded %s, size %u\n", szImageFilePath, Module->VirtualSize);

                InsertTailList( &ModuleListHead, &Module->Entry );

                CloseHandle(hFile);

                return TRUE;
            }
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pfmon\init.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This is the initialization module for the pfmon program.

Author:

    Mark Lucovsky (markl) 26-Jan-1995

Revision History:

--*/

#include "pfmonp.h"

BOOL
InitializePfmon( VOID )
{
    LPTSTR CommandLine;
    BOOL fShowUsage;
    DWORD Pid = 0;

    fShowUsage = FALSE;
    CommandLine = GetCommandLine();
    while (*CommandLine > ' ') {
        CommandLine += 1;
    }
    while (TRUE) {
        while (*CommandLine <= ' ') {
            if (*CommandLine == '\0') {
                break;
            } else {
                CommandLine += 1;
            }
        }

        if (!_strnicmp( CommandLine, "/v", 2 ) || !_strnicmp( CommandLine, "-v", 2 )) {
            CommandLine += 2;
            fVerbose = TRUE;
        } else if (!_strnicmp( CommandLine, "/?", 2 ) || !_strnicmp( CommandLine, "-?", 2 )) {
            CommandLine += 2;
            fShowUsage = TRUE;
            goto showusage;
        } else if (!_strnicmp( CommandLine, "/c", 2 ) || !_strnicmp( CommandLine, "-c", 2 )) {
            CommandLine += 2;
            fCodeOnly = TRUE;
        } else if (!_strnicmp( CommandLine, "/h", 2 ) || !_strnicmp( CommandLine, "-h", 2 )) {
            CommandLine += 2;
            fHardOnly = TRUE;
        } else if (!_strnicmp( CommandLine, "/n", 2 ) || !_strnicmp( CommandLine, "-n", 2 )) {
            CommandLine += 2;
            LogFile = fopen("pfmon.log","wt");
            fLogOnly = TRUE;
        } else if (!_strnicmp( CommandLine, "/l", 2 ) || !_strnicmp( CommandLine, "-l", 2 )) {
            CommandLine += 2;
            LogFile = fopen("pfmon.log","wt");
        } else if (!_strnicmp( CommandLine, "/p", 2 ) || !_strnicmp( CommandLine, "-p", 2 )) {
            CommandLine += 2;
            while (*CommandLine <= ' ') {
                if (*CommandLine == '\0') {
                    break;
                } else {
                    ++CommandLine;
                }
            }
            Pid = atoi(CommandLine);
            CommandLine = strchr(CommandLine,' ');
            if (CommandLine==NULL) {
                break;
            }
        } else if (!strncmp( CommandLine, "/k", 2 ) || !strncmp( CommandLine, "-k", 2 )) {
            CommandLine += 2;
            fKernel = TRUE;
            fKernelOnly = FALSE;
        } else if (!strncmp( CommandLine, "/K", 2 ) || !strncmp( CommandLine, "-K", 2 )) {
            CommandLine += 2;
            fKernel = TRUE;
            fKernelOnly = TRUE;
        } else if (!_strnicmp( CommandLine, "/d", 2 ) || !_strnicmp( CommandLine, "-d", 2 )) {
            CommandLine += 2;
            fDatabase = TRUE;
        } else {
            break;
        }
    }
showusage:
    if ( fShowUsage ) {
        fputs("Usage: PFMON [switches] application-command-line\n"
              "             [-?] display this message\n"
              "             [-n] don't display running faults, just log to pfmon.log\n"
              "             [-l] log faults to pfmon.log\n"
              "             [-c] only show code faults\n"
              "             [-h] only show hard faults\n"
              "             [-p pid] attach to existing process\n"
              "             [-d] Database format (tab delimited)\n"
              "                  format: pagefault number, Page Fault type (Hard or Soft),\n"
              "                  Program Counter's Module, Symbol for PC, Decimal value of PC,\n"
              "                  Decimal value of PC, Module of the virtual address accessed,\n"
              "                  Symbol for VA, value of VA\n"
              "             [-k] kernel mode page faults and user mode page faults\n"
              "             [-K] kernel mode page faults instead of user mode\n",
              stdout);
        return FALSE;
        };

    InitializeListHead( &ProcessListHead );
    InitializeListHead( &ModuleListHead );
    SetSymbolSearchPath();
    if (!NT_SUCCESS(NtQuerySystemInformation(SystemRangeStartInformation,
                                             &SystemRangeStart,
                                             sizeof(SystemRangeStart),
                                             NULL))) {
        // Assume usermode is the low half of the address space
        SystemRangeStart = (ULONG_PTR)MAXLONG_PTR;
    }

    PfmonModuleHandle = GetModuleHandle( NULL );

    if (Pid != 0) {
        return(AttachApplicationForDebug(Pid));
    } else {
        return (LoadApplicationForDebug( CommandLine ));
    }

    return TRUE;
}

BOOL
LoadApplicationForDebug(
    LPSTR CommandLine
    )
{
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;

    ZeroMemory( &StartupInfo, sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof(StartupInfo);

    if (!CreateProcess( NULL,
                        CommandLine,
                        NULL,
                        NULL,
                        FALSE,                          // No handles to inherit
                        DEBUG_PROCESS,
                        NULL,
                        NULL,
                        &StartupInfo,
                        &ProcessInformation)) {
        DeclareError( PFMON_CANT_DEBUG_PROGRAM,
                      GetLastError(),
                      CommandLine
                    );
        return FALSE;
    } else {
        hProcess = ProcessInformation.hProcess;
        SymInitialize(hProcess,NULL,FALSE);

        if (fKernel) {
            AddKernelDrivers();
            }

        return InitializeProcessForWsWatch(hProcess);
    }
}

BOOL
NtsdDebugActiveProcess (
    DWORD dwPidToDebug
    )
{
#ifdef CHICAGO
    BOOL                b;

    b = DebugActiveProcess(dwPidToDebug);

    return( b );
#else
    HANDLE              Token;
    PTOKEN_PRIVILEGES   NewPrivileges;
    BYTE                OldPriv[1024];
    PBYTE               pbOldPriv;
    ULONG               cbNeeded;
    BOOL                b;
    BOOL                fRc;
    LUID                LuidPrivilege;

    //
    // Make sure we have access to adjust and to get the old token privileges
    //
    if (!OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &Token)) {

        return( FALSE );

    }

    cbNeeded = 0;

    //
    // Initialize the privilege adjustment structure
    //

    LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &LuidPrivilege );

    NewPrivileges = (PTOKEN_PRIVILEGES)calloc(1,sizeof(TOKEN_PRIVILEGES) +
                                              (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
    if (NewPrivileges == NULL) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege
    //

    pbOldPriv = OldPriv;
    fRc = AdjustTokenPrivileges( Token,
                                 FALSE,
                                 NewPrivileges,
                                 1024,
                                 (PTOKEN_PRIVILEGES)pbOldPriv,
                                 &cbNeeded );

    if (!fRc) {

        //
        // If the stack was too small to hold the privileges
        // then allocate off the heap
        //
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            pbOldPriv = calloc(1,cbNeeded);
            if (pbOldPriv == NULL) {
                CloseHandle(Token);
                return(FALSE);
            }

            fRc = AdjustTokenPrivileges( Token,
                                         FALSE,
                                         NewPrivileges,
                                         cbNeeded,
                                         (PTOKEN_PRIVILEGES)pbOldPriv,
                                         &cbNeeded );
        }
    }

    b = DebugActiveProcess(dwPidToDebug);

    CloseHandle( Token );

    return( b );
#endif
}






BOOL
AttachApplicationForDebug(
    DWORD Pid
    )
{
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;

    if (!NtsdDebugActiveProcess(Pid)) {
        DeclareError( PFMON_CANT_DEBUG_ACTIVE_PROGRAM,
                      GetLastError(),
                      Pid );
        return FALSE;
    } else {
        hProcess = OpenProcess(PROCESS_VM_READ
                               | PROCESS_QUERY_INFORMATION
                               | PROCESS_SET_INFORMATION,
                               FALSE,
                               Pid);
        SymInitialize(hProcess,NULL,FALSE);

        if (fKernel) {
            AddKernelDrivers();
            }

        return InitializeProcessForWsWatch(hProcess);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pfmon\pfmon.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pfmon.c

Abstract:

    USAGE: pfmon [pfmon switches] command-line-of-application


Author:

    Mark Lucovsky (markl) 26-Jan-1995

--*/

#include "pfmonp.h"

#define WORKING_SET_BUFFER_ENTRYS 4096
PSAPI_WS_WATCH_INFORMATION WorkingSetBuffer[WORKING_SET_BUFFER_ENTRYS];

#define MAX_SYMNAME_SIZE  1024
CHAR PcSymBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL PcSymbol = (PIMAGEHLP_SYMBOL) PcSymBuffer;
CHAR VaSymBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL VaSymbol = (PIMAGEHLP_SYMBOL) VaSymBuffer;

#if defined (_WIN64)
#define ZERO_PTR "%016I64x"
#define ZEROD_PTR "%I64u"
#else
#define ZERO_PTR "%08x"
#define ZEROD_PTR "%u"
#endif

int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nShowCmd
    )
{
    CHAR Line[256];

    if (!InitializePfmon()) {
        ExitProcess( 1 );
        }
    else {
        DebugEventLoop();
        sprintf(Line,"\n PFMON: Total Faults %d  (KM %d UM %d Soft %d, Hard %d, Code %d, Data %d)\n",
            TotalSoftFaults + TotalHardFaults,
            TotalKernelFaults,
            TotalUserFaults,
            TotalSoftFaults,
            TotalHardFaults,
            TotalCodeFaults,
            TotalDataFaults
            );
        fprintf(stdout,"%s",Line);
        if ( LogFile ) {
            fprintf(LogFile,"%s",Line);
            fclose(LogFile);
            }
        ExitProcess( 0 );
        }

    return 0;
}

VOID
ProcessPfMonData(
    VOID
    )
{
    BOOL b;
    BOOL DidOne;
    INT i;
    PMODULE_INFO PcModule;
    PMODULE_INFO VaModule;
    ULONG_PTR PcOffset;
    DWORD_PTR VaOffset;
    CHAR PcLine[256];
    CHAR VaLine[256];
    CHAR PcModuleStr[256];
    CHAR VaModuleStr[256];
    LPVOID Pc;
    LPVOID Va;
    BOOL SoftFault;
    BOOL CodeFault;
    BOOL KillLog;
    static int cPfCnt = 0;



    PcSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
    PcSymbol->MaxNameLength = MAX_SYMNAME_SIZE;
    VaSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
    VaSymbol->MaxNameLength = MAX_SYMNAME_SIZE;

    //Get the buffer of recent page faults from the process's data structure
    b = GetWsChanges(hProcess,&WorkingSetBuffer[0],sizeof(WorkingSetBuffer));


    if ( b ) {
        DidOne = FALSE;
        i = 0;
        while (WorkingSetBuffer[i].FaultingPc) {
            if ( WorkingSetBuffer[i].FaultingVa ) {
                Pc = WorkingSetBuffer[i].FaultingPc;
                Va = WorkingSetBuffer[i].FaultingVa;


                if ( (ULONG_PTR)Pc >= SystemRangeStart ) {
                    TotalKernelFaults++;
                    if ( !fKernel ) {
                        i++;
                        continue;
                        }
                    }
                else {
                    TotalUserFaults++;
                    if ( fKernelOnly ) {
                        i++;
                        continue;
                        }
                    }

                //Check least sig bit which stores whether it was a hard
                //or soft fault

                if ( (ULONG_PTR)Va & 1 ) {
                    TotalSoftFaults++;
                    SoftFault = TRUE;
                    }
                else {
                    TotalHardFaults++;
                    SoftFault = FALSE;
                    }

                Va = (LPVOID)( (ULONG_PTR)Va & ~1);
                if ( (LPVOID)((ULONG_PTR)Pc & ~1) == Va ) {
                    CodeFault = TRUE;
                    TotalCodeFaults++;
                    }
                else {
                    TotalDataFaults++;
                    CodeFault = FALSE;
                    }


                PcModule = FindModuleContainingAddress(Pc);
                VaModule = FindModuleContainingAddress(Va);

                if ( PcModule ) {
                    PcModule->NumberCausedFaults++;
                    sprintf(PcModuleStr, "%s", PcModule->ModuleName);
                    }
                else {
                    sprintf(PcModuleStr,"not found %p",Pc);
                    PcModuleStr[0] = '\0';
                    }

                //Va was either a code reference or global
                //reference as opposed to a heap reference

                if ( VaModule ) {
                    if ( SoftFault ) {
                        VaModule->NumberFaultedSoftVas++;
                        }
                    else {
                        VaModule->NumberFaultedHardVas++;
                        }
                    sprintf(VaModuleStr, "%s", VaModule->ModuleName);
                    }
                else
                    VaModuleStr[0] = '\0';

                if (SymGetSymFromAddr(hProcess, (ULONG_PTR)Pc, &PcOffset, PcSymbol)) {
                    if ( PcOffset ) {
                        sprintf(PcLine,"%s+0x%x",PcSymbol->Name,PcOffset);
                        }
                    else {
                        sprintf(PcLine,"%s",PcSymbol->Name);
                        }
                    }
                else {
                    sprintf(PcLine,""ZERO_PTR"",Pc);
                    }

                if (SymGetSymFromAddr(hProcess, (ULONG_PTR)Va, &VaOffset, VaSymbol)) {
                    if ( VaOffset ) {
                        sprintf(VaLine,"%s+0x%p",VaSymbol->Name,VaOffset);
                        }
                    else {
                        sprintf(VaLine,"%s",VaSymbol->Name);
                        }
                    }
                else {
                    sprintf(VaLine,""ZERO_PTR"",Va);
                    }

                KillLog = FALSE;

                if ( fCodeOnly && !CodeFault ) {
                    KillLog = TRUE;
                    }
                if ( fHardOnly && SoftFault ) {
                    KillLog = TRUE;
                    }

                if ( !KillLog ) {
                    if ( !fLogOnly ) {
                        if (!fDatabase) {
                            fprintf(stdout,"%s%s : %s\n",SoftFault ? "SOFT: " : "HARD: ",PcLine,VaLine);
                            }
                        else {

                            //Addresses are printed out in decimal
                            //because most databases don't support
                            //hex formats

                            fprintf(stdout,"%8d\t%s\t%s\t%s\t"ZEROD_PTR"\t%s\t%s\t"ZEROD_PTR"\n",
                                    cPfCnt,
                                    SoftFault ? "SOFT" : "HARD",
                                    PcModuleStr,
                                    PcLine,
                                    (DWORD_PTR) Pc,
                                    VaModuleStr,
                                    VaLine,
                                    (DWORD_PTR) Va);
                            }
                        }

                    if ( LogFile ) {
                        if (!fDatabase) {
                            fprintf(LogFile,"%s%s : %s\n",SoftFault ? "SOFT: " : "HARD: ",PcLine,VaLine);
                            }
                        else {
                            fprintf(LogFile,"%8d\t%s\t%s\t%s\t"ZEROD_PTR"\t%s\t%s\t"ZEROD_PTR"\n",
                                    cPfCnt,
                                    SoftFault ? "SOFT" : "HARD",
                                    PcModuleStr,
                                    PcLine,
                                    (DWORD_PTR) Pc,
                                    VaModuleStr,
                                    VaLine,
                                    (DWORD_PTR) Va);
                            }
                        }
                    DidOne = TRUE;
                    cPfCnt++;
                    }
                }
            i++;
            }

        if ( DidOne ) {
            if ( !fLogOnly  && !fDatabase) {
                fprintf(stdout,"\n");
                }
            }

        //If the buffer overflowed then a non-zero value for
        //the Va was stored in the last record.
        if (WorkingSetBuffer[i].FaultingVa)
            fprintf(stdout,"Warning: Page fault buffer has overflowed\n");
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pfmon\pfmonp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    instaler.h

Abstract:

    Main include file for the INSTALER application.

Author:

    Steve Wood (stevewo) 09-Aug-1994

Revision History:

--*/

#ifdef RC_INVOKED
#include <windows.h>
#else

#include "nt.h"
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stddef.h>
#include <dbghelp.h>
#include <psapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "errormsg.h"

//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOL
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
// Data structures and entry points in init.c
//

DWORD TotalSoftFaults;
DWORD TotalHardFaults;
DWORD TotalCodeFaults;
DWORD TotalDataFaults;
DWORD TotalKernelFaults;
DWORD TotalUserFaults;

BOOL fCodeOnly;
BOOL fHardOnly;

ULONG_PTR SystemRangeStart;

VOID
ProcessPfMonData(
    VOID
    );

//
// Data structures and entry points in init.c
//

BOOL fVerbose;
BOOL fLogOnly;
BOOL fKernelOnly;                 //flag for displaying kernel pagefaults
BOOL fKernel;                     //flag for displaying kernel pagefaults
BOOL fDatabase;                   //flag for outputing information in a
                                  //tab-delimited database format
FILE *LogFile;

BOOL
InitializePfmon(
    VOID
    );

BOOL
LoadApplicationForDebug(
    LPSTR CommandLine
    );

BOOL
AttachApplicationForDebug(
    DWORD Pid
    );

HANDLE hProcess;

//
// Data structures and entry points in error.c
//

HANDLE PfmonModuleHandle;

VOID
__cdecl
DeclareError(
    UINT ErrorCode,
    UINT SupplementalErrorCode,
    ...
    );

//
// Data structures and entry points in DEBUG.C
//

VOID
DebugEventLoop( VOID );

//
// Data structures and entry points in process.c
//

typedef struct _PROCESS_INFO {
    LIST_ENTRY Entry;
    LIST_ENTRY ThreadListHead;
    DWORD Id;
    HANDLE Handle;
} PROCESS_INFO, *PPROCESS_INFO;

typedef struct _THREAD_INFO {
    LIST_ENTRY Entry;
    DWORD Id;
    HANDLE Handle;
    PVOID StartAddress;
} THREAD_INFO, *PTHREAD_INFO;

LIST_ENTRY ProcessListHead;

BOOL
AddProcess(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO *ReturnedProcess
    );

BOOL
DeleteProcess(
    PPROCESS_INFO Process
    );

BOOL
AddThread(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO Process,
    PTHREAD_INFO *ReturnedThread
    );

BOOL
DeleteThread(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    );

PPROCESS_INFO
FindProcessById(
    ULONG Id
    );

BOOL
FindProcessAndThreadForEvent(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO *ReturnedProcess,
    PTHREAD_INFO *ReturnedThread
    );
//
// Data structures and entry points in module.c
//

typedef struct _MODULE_INFO {
    LIST_ENTRY Entry;
    LPVOID BaseAddress;
    DWORD VirtualSize;
    DWORD NumberFaultedSoftVas;
    DWORD NumberFaultedHardVas;
    DWORD NumberCausedFaults;
    HANDLE Handle;
    LPTSTR ModuleName;
} MODULE_INFO, *PMODULE_INFO;

LPSTR SymbolSearchPath;
LIST_ENTRY ModuleListHead;

BOOL
LazyLoad(
    LPVOID Address
    );

PRTL_PROCESS_MODULES LazyModuleInformation;

BOOL
AddModule(
    LPDEBUG_EVENT DebugEvent
    );

BOOL
DeleteModule(
    PMODULE_INFO Module
    );

PMODULE_INFO
FindModuleContainingAddress(
    LPVOID Address
    );

VOID
SetSymbolSearchPath( );

LONG
AddKernelDrivers( );


#if defined(_ALPHA_) || defined(_AXP64_)
#define BPSKIP 4
#elif defined(_X86_)
#define BPSKIP 1
#elif defined(_AMD64_)
#define BPSKIP 1
#elif defined(_IA64_)
#define BPSKIP 8
#endif // _ALPHA_

#endif // defined( RC_INVOKED )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pnpinit\makefile.inc ===
$(O)\pnpinit.res: pnpinit.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pfmon\process.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    process.c

Abstract:

    This module maintains state about each process/thread created by the application
    pfmon program.

Author:

    Mark Lucovsky (markl) 26-Jan-1995

Revision History:

--*/

#include "pfmonp.h"

BOOL
AddProcess(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO *ReturnedProcess
    )
{
    PPROCESS_INFO Process;

    Process = LocalAlloc(LMEM_ZEROINIT, sizeof( *Process ) );
    if (Process == NULL) {
        return FALSE;
        }

    Process->Id = DebugEvent->dwProcessId;
    Process->Handle = DebugEvent->u.CreateProcessInfo.hProcess;
    InitializeListHead( &Process->ThreadListHead );
    InsertTailList( &ProcessListHead, &Process->Entry );
    *ReturnedProcess = Process;

    return TRUE;
}

BOOL
DeleteProcess(
    PPROCESS_INFO Process
    )
{
    PLIST_ENTRY Next, Head;
    PTHREAD_INFO Thread;
    PMODULE_INFO Module;
    CHAR Line[256];

    RemoveEntryList( &Process->Entry );

    Head = &Process->ThreadListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Thread = CONTAINING_RECORD( Next, THREAD_INFO, Entry );
        Next = Next->Flink;
        DeleteThread( Process, Thread );
        }

    LocalFree( Process );
    fprintf(stdout,"\n");

    Next = ModuleListHead.Flink;
    while ( Next != &ModuleListHead ) {
        Module = CONTAINING_RECORD(Next,MODULE_INFO,Entry);


        sprintf(Line,"%16s Caused %6d faults had %6d Soft %6d Hard faulted VA's\n",
            Module->ModuleName,
            Module->NumberCausedFaults,
            Module->NumberFaultedSoftVas,
            Module->NumberFaultedHardVas
            );
        if ( !fLogOnly ) {
            fprintf(stdout,"%s",Line);
            }
        if ( LogFile ) {
            fprintf(LogFile,"%s",Line);
            }

        Next = Next->Flink;
        }


    return TRUE;
}


BOOL
AddThread(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO Process,
    PTHREAD_INFO *ReturnedThread
    )
{
    PTHREAD_INFO Thread;

    Thread = LocalAlloc(LMEM_ZEROINIT, sizeof( *Thread ) );
    if (Thread == NULL) {
        return FALSE;
        }

    Thread->Id = DebugEvent->dwThreadId;
    if (DebugEvent->dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) {
        Thread->Handle = DebugEvent->u.CreateProcessInfo.hThread;
        Thread->StartAddress = DebugEvent->u.CreateProcessInfo.lpStartAddress;
        }
    else {
        Thread->Handle = DebugEvent->u.CreateThread.hThread;
        Thread->StartAddress = DebugEvent->u.CreateThread.lpStartAddress;
        }
    InsertTailList( &Process->ThreadListHead, &Thread->Entry );
    *ReturnedThread = Thread;
    return TRUE;
}

BOOL
DeleteThread(
    PPROCESS_INFO Process,
    PTHREAD_INFO Thread
    )
{

    RemoveEntryList( &Thread->Entry );

    LocalFree( Thread );
    return TRUE;
}


PPROCESS_INFO
FindProcessById(
    ULONG Id
    )
{
    PLIST_ENTRY Next, Head;
    PPROCESS_INFO Process;

    Head = &ProcessListHead;
    Next = Head->Flink;
    while (Next != Head) {
        Process = CONTAINING_RECORD( Next, PROCESS_INFO, Entry );
        if (Process->Id == Id) {
            return Process;
            }

        Next = Next->Flink;
        }

    return NULL;
}

BOOL
FindProcessAndThreadForEvent(
    LPDEBUG_EVENT DebugEvent,
    PPROCESS_INFO *ReturnedProcess,
    PTHREAD_INFO *ReturnedThread
    )
{
    PLIST_ENTRY Next, Head;
    PPROCESS_INFO Process;
    PTHREAD_INFO Thread;

    Head = &ProcessListHead;
    Next = Head->Flink;
    Process = NULL;
    Thread = NULL;
    while (Next != Head) {
        Process = CONTAINING_RECORD( Next, PROCESS_INFO, Entry );
        if (Process->Id == DebugEvent->dwProcessId) {
            Head = &Process->ThreadListHead;
            Next = Head->Flink;
            while (Next != Head) {
                Thread = CONTAINING_RECORD( Next, THREAD_INFO, Entry );
                if (Thread->Id == DebugEvent->dwThreadId) {
                    break;
                    }

                Thread = NULL;
                Next = Next->Flink;
                }

            break;
            }

        Process = NULL;
        Next = Next->Flink;
        }

    *ReturnedProcess = Process;
    *ReturnedThread = Thread;

    if (DebugEvent->dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) {
        if (Process != NULL) {
            DeclareError( PFMON_DUPLICATE_PROCESS_ID, 0, DebugEvent->dwProcessId );
            return FALSE;
            }
        }
    else
    if (DebugEvent->dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT) {
        if (Thread != NULL) {
            DeclareError( PFMON_DUPLICATE_THREAD_ID, 0, DebugEvent->dwThreadId, DebugEvent->dwProcessId );
            return FALSE;
            }
        if (Process == NULL) {
            DeclareError( PFMON_MISSING_PROCESS_ID, 0, DebugEvent->dwProcessId );
            return FALSE;
            }
        }
    else
    if (Process == NULL) {
        DeclareError( PFMON_MISSING_PROCESS_ID, 0, DebugEvent->dwProcessId );
        return FALSE;
        }
    else
    if (Thread == NULL) {
        DeclareError( PFMON_MISSING_THREAD_ID, 0, DebugEvent->dwThreadId, DebugEvent->dwProcessId );
        return FALSE;
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pnpinit\pnpinit.c ===
#include <windows.h>
#include <stdlib.h>

int
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    FARPROC           lpProc;
    HMODULE           hLib = NULL;
    BOOL              Result = FALSE;

    //
    // load the client-side user-mode PnP manager DLL
    //
    hLib = LoadLibrary(TEXT("cfgmgr32.dll"));
    if (hLib != NULL) {
        lpProc = GetProcAddress( hLib, "CMP_Report_LogOn" );
        if (lpProc != NULL) {
            //
            // Ping the user-mode pnp manager -
            // pass the private id as a parameter
            //
            Result = (lpProc)(0x07020420, GetCurrentProcessId()) ? TRUE : FALSE;
            }

        FreeLibrary( hLib );
        }

    if (Result)
        return 0;
    else
        return 1 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ppr\lplow.c ===
/**************************************************************************\
 * LPLow.C                                                                *
 *------------------------------------------------------------------------*
 *                                                                        *
 * PPR Support for low level network and path handling.                   *
 *                                                                        *
\**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <stdio.h>
#include <string.h>
#define INCL_NETUSE
#define INCL_NETWKSTA
#define INCL_NETERRORS
#include <windows.h>
#include "lpr.h"


extern BOOL fVerify; /* From LPR.C */


BOOL fRedir = FALSE;		/* TRUE => a redirection was used	*/

void SetupRedir()
{
    int     err;
    DWORD   wnError;
    CHAR    szRemoteName[256];
    DWORD   BufferSize = sizeof(szRemoteName)/sizeof(szRemoteName[0]);

    if (*szNet == '\0' || _strcmpi(szNet, "None") == 0)
        return;		/* don't try to make connection */

    if(szPass) {
        strcpy(szNet + strlen(szNet) + 1, szPass);
    }

    if ( WN_SUCCESS != ( wnError = WNetGetConnection ( (PTSTR) szPName,
						 szRemoteName,
						 &BufferSize ) ) ) {


	if ( (wnError != WN_NOT_CONNECTED) &&
	     (wnError != WN_CONNECTION_CLOSED) ) {

	    switch( wnError ) {

		case WN_NO_NETWORK:
		    Fatal("The network is not installed or workstation not started");
                    break;
		case WN_BAD_LOCALNAME:
		    Fatal("Invalid local name specified");
		    break;
		case WN_EXTENDED_ERROR:
		    Fatal("Extended error from WNetGetConnection" );
                    break;
		default:
		    Fatal("error from WNetGetConnection: %d",wnError );
		    break;
		}
            }
        }
    else  {	/* no error */
	if  ( !strcmp( szRemoteName, szNet ) ) {
            return;
	    }
	}

    /* no redirection, so set one up */

    if ((err = SetPrnRedir(szPName, szNet)) == 0)
        fRedir = TRUE;
    else if (err == 1)
        Fatal("redirection of %s to %s failed (%d)\nredirector is not started",
               szPName,szNet,err);
    else if (err != ERROR_ALREADY_ASSIGNED)
        Fatal("redirection of %s to %s failed (%d)",
               szPName,szNet,err);
}


void ResetRedir()
	{
	int err;

	if (fRedir)
		{
		if ((err = EndRedir(szPName)) != 0)
			Error("removal of redirection failed (%d)", err);
		fRedir = FALSE;
		}
	}





int EndRedir(szDev)
/* End redirection for szDev, return 0 if success */
/* otherwise return error number	*/
char * szDev;

{
    DWORD  wnError;

    if (WN_SUCCESS != ( wnError = WNetCancelConnection ( szDev, TRUE) ) )	{
	return ( 0 );
	}
    else  {
	return ( (int) wnError );
	}
}




int SetPrnRedir(szDev, szPath)
    char *szDev;
    char *szPath;
{
    DWORD wnError;


    /* return 0, 1 or other error */

    if ( szPass && *szPass )  {
        wnError = WNetAddConnection ( (LPTSTR) szPath, (LPTSTR) szPass, (LPTSTR) szDev );
    } else  {
        wnError = WNetAddConnection ( (LPTSTR) szPath, NULL, (LPTSTR) szDev );
    }

    if(wnError == WN_SUCCESS) {
        wnError = 0;
    } else if((wnError == WN_NO_NETWORK) || (wnError == WN_NO_NET_OR_BAD_PATH)) {
        wnError = 1;
	}
    return ( (int)wnError );
}




BOOL QueryUserName(char *szName)
{
    UCHAR		 pUserName [128];
    DWORD		 BufferSize = 128;
    BOOL                 rc;
    DWORD		 wnError;

    if (WN_SUCCESS != ( wnError = WNetGetUser ( NULL, (LPTSTR) pUserName, &BufferSize ) ) )  {
        strcpy(szName,"no name");
        rc = FALSE;
        if(fVerify) {
	    fprintf(stdout,"Warning: WNetGetUser returns %d\n", wnError );
        }
    } else {
	strcpy(szName, pUserName);
        rc =  TRUE;
    }
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ppr\lppage.c ===
/*
 *   lppage.c - page formatting
 */

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <direct.h>
#include <tools.h>
#include <time.h>
#include "lpr.h"

#define ESC '\033'

BOOL        fPageTop = TRUE;            /* TRUE => printer at top of page     */
BOOL        fFirstFile = TRUE;          /* TRUE => first file to be printed   */

/* information for formated page */
BOOL        fInit;                      /* TRUE => valid info in page         */
int         iPage;                      /* current page being processed       */
int         rowLine;                    /* row for next line                  */
int         iLine;                      /* number of current line             */
char        szFFile[MAX_PATH];         /* full path of file being displayed  */
char        szFTime[50];                /* ascii timestamp for file           */
char        szUsr[MAX_PATH];           /* name of user                       */
char        szCompany[] = COMPANY;
char        szConf[] = CONFIDENTIAL;

extern USHORT usCodePage;

/* Specifics about ctime */
#define cchDateMax 16
#define cchTimeMax 10

/* Maximum length in a short file name */
/* Shape of the banner */
#define crowBanner   30
#define ccolBanner  102



void BannerSz(szFName, cBanOut)
char    *szFName;
int cBanOut;            /* number to output; will be > 0 */
    {
#define CenterCol(sz) (col + ((ccolBanner - (strlen(sz) << 3)) >> 1))
#define cchFShort 12
#define cchPShort 28
#define cchUsrShort 12          /* length username block can be on banner */

    int     row;                /* Position of the banner */
    int     col;
    char    szDate[cchDateMax];
    char    szTime[cchTimeMax];
    char    szPath[MAX_PATH];
    char    szConfid[sizeof(szCompany) + sizeof(szConf)];
    char    szFNShort[cchFShort + 1];   /* To shorten the file name */
                                        /* only up to 12 chars. */
    char    szUsrShort[cchUsrShort + 1];/* Need to shorten the username also! */
    char    szBuffer[30];


    if (!fPostScript) {
        row = ((fLaser ? rowLJBanMax : rowMac) - crowBanner - 10)/2;
        col = ((fLaser ? colLJBanMax : colLPMax) - ccolBanner)/2;
    }

    szFNShort[cchFShort] = '\0' ;
    strncpy(szFNShort, szFName, cchFShort);
    szUsrShort[cchUsrShort] = '\0' ;
    strncpy(szUsrShort, szUsr, cchUsrShort);

    _getcwd(szPath, sizeof(szPath));
    _strupr(szPath);
    _strupr(szFNShort);

    SzDateSzTime(szDate, szTime);

    if (fPostScript) {

        int iPathLen = strlen (szFFile);
        while ((szFFile[iPathLen] != '\\') && (iPathLen>0)) {
            iPathLen--;
        }

        OutLPR("\n", 0);
        /* The 'strings' we are sending out, need to use OutLPRPS just in case
         * they contain \, (, or )...
         */

        // Assign a jobname
        OutLPR ("statusdict begin statusdict /jobname (PPR: ", 0);
        OutLPRPS (szUsr, 0);
        OutLPR (" - ", 0);
        OutLPRPS (szFNShort, 0);
        OutLPR (") put end \n", 0);

        if( fHDuplex || fVDuplex )
        {
            OutLPR( "statusdict begin ", 0 );
            OutLPR( fHDuplex ? "true" : "false", 0 );
            OutLPR( " settumble true setduplexmode end\n", 0);
        }

        // Define some of the data we will be wanting access to
        OutLPR ("/UserName (", 0); OutLPRPS (szUsr, 0); OutLPR (") def \n", 0);
        OutLPR ("/FileName (", 0); OutLPRPS (szFNShort ,0); OutLPR (") def \n", 0);
        OutLPR ("/PathName (", 0); OutLPRPS (szFFile, iPathLen); OutLPR (") def \n", 0);
        OutLPR ("/UserPath (", 0); OutLPRPS (szPath ,0);    OutLPR (") def \n", 0);
        OutLPR ("/Date (", 0);     OutLPRPS (szDate, 0);    OutLPR (") def \n", 0);
        OutLPR ("/Time (", 0);     OutLPRPS (szTime ,0);    OutLPR (") def \n", 0);
        OutLPR ("/FTime (", 0);    OutLPRPS (szFTime,0);    OutLPR (") def \n", 0);
        OutLPR ("/Label ",0);
        OutLPR ((fLabel ? "true" : "false"), 0);
        OutLPR (" def \n", 0);

        if (fConfidential) {
            OutLPR ("/MSConfidential true def\n", 0);

            OutLPR ("/Stamp (", 0);
            if (szStamp && strlen(szStamp) > 0) {
                OutLPR (szStamp, 0);
            } else {
                strcpy(szConfid, szCompany);
                strcat(szConfid, " ");
                strcat(szConfid, szConf);
                OutLPR (szConfid, 0);
            }
            OutLPR (") def \n", 0);
        }

        if (szStamp != NULL) {
            OutLPR ("/MSConfidential true def\n", 0);
            OutLPR ("/Stamp (", 0);
            OutLPRPS (szStamp, 0);
            OutLPR (") def \n", 0);
        }

        // Width of 'gutter' in characters
        sprintf (szBuffer, "/Gutter %d def \n", colGutter);
        OutLPR (szBuffer, 0);

        // The total column width in characters
        sprintf (szBuffer, "/ColWidth %d def \n", colWidth);
        OutLPR (szBuffer, 0);

        // Number of character rows per page
        sprintf (szBuffer, "/RowCount %d def \n", rowMac);
        OutLPR (szBuffer, 0);

        // The character column text should start in
        sprintf (szBuffer, "/ColText %d def \n", colText);
        OutLPR (szBuffer, 0);

        // Number of columns per page
        sprintf (szBuffer, "/Columns %d def\n", cCol);
        OutLPR (szBuffer, 0);

/* ... Ok, now lets get started! */

        if (cBanOut > 0) OutLPR ("BannerPage\n", 0);

        cBanOut--;
        /* print more banners if neccessary ?? */
        while (cBanOut-- > 0) {
            OutLPR ("BannerPage % Extra Banners??\n", 0);
        }

    } else {
        FillRectangle(' ', 0, 0, row + crowBanner, col + ccolBanner + 1);
        HorzLine('_', row, col + 1, col + ccolBanner);
        HorzLine('_', row + 5, col, col + ccolBanner);
        HorzLine('_', row + 16, col, col + ccolBanner);
        HorzLine('_', row + 29, col, col + ccolBanner);
        VertLine('|', col, row + 1, row + crowBanner);
        VertLine('|', col + ccolBanner, row + 1, row + crowBanner);

        WriteSzCoord("User:", row + 2, col + 15);
        WriteSzCoord(szUsr, row + 2, col + 30);
        WriteSzCoord("File Name:", row + 3, col + 15);
        WriteSzCoord(szFNShort, row + 3, col + 30);
        WriteSzCoord("Directory:", row + 3, col + 58);
        WriteSzCoord(szPath, row + 3, col + 73);
        WriteSzCoord("Date Printed:", row + 4, col + 15);
        WriteSzCoord("Time Printed:", row + 4, col + 58);
        WriteSzCoord(szDate, row + 4, col + 30);
        WriteSzCoord(szTime, row + 4, col + 73);

        block_flush(szUsrShort, row + 8, CenterCol(szUsrShort));
        block_flush(szFNShort, row + 20, CenterCol(szFNShort));

        if (fConfidential)
                {
                strcpy(szConfid, szCompany);
                strcat(szConfid, " ");
                strcat(szConfid, szConf);
                WriteSzCoord(szConfid, row+18, col + (ccolBanner-strlen(szConfid))/2);
                }
        if (szStamp != NULL)
                WriteSzCoord(szStamp, row+28, col + (ccolBanner-strlen(szStamp))/2);

        /* move to top of page */
        if (!fPageTop)
            OutLPR(fPostScript ? "showpage\n" : "\r\f", 0);
        if (fLaser)
            {
            if (fVDuplex || fHDuplex)
                    OutLPR(SELECTFRONTPAGE,0);
            OutLPR(BEGINBANNER, 0);
            }
        if (fPostScript)
            OutLPR("beginbanner\n", 0);

        OutRectangle(0, 0, row + crowBanner, col + ccolBanner + 1);
        cBanOut--;

        /* print more banners if neccessary */
        while (cBanOut-- > 0) {
            OutLPR(fPostScript ? "showpage\n" : "\r\f", 0);
            if (fPostScript)
                OutLPR("beginbanner\n", 0);
            OutRectangle(0, 0, row + crowBanner, col + ccolBanner + 1);
        }
    } /* End of PostScript check */

    fPageTop = FALSE;
    }


void SzDateSzTime(szDate, szTime)
/* fill sz's with date & time */
char    *szDate, *szTime;
{
    char *szt;
    char sz[26];
    time_t tT;

    time(&tT);
    szt = ctime(&tT);
    /* convert ctime format into Date & Time */
    strcpy(sz, szt);
    sz[10] = sz[19] = sz[24] = '\0';    /* break into DAY:TIME:YEAR */

    strcpy(szDate, &sz[0]);
    strcat(szDate, " ");
    strcat(szDate, &sz[20]);
    strcpy(szTime, &sz[11]);
} /* SzDateSzTime */


void FlushPage()
/*  FlushPage - dump a completed page to the printer  */
    {
    if (!fInit)
        {
        if (!fPostScript) {
            if (!fPageTop)
                OutLPR("\r\f", 0);
            else if (!fLaser && fLabel)
                OutLPR("\n\n", 0);  /* align printout on LP */
        }

        OutRectangle(0,0,rowMac,colMac);
        fPageTop = FALSE;
      }
    }


void InitPage()
/* fill in the page image with a blanks (and frame, if needed)     */
/* mark punch holes in to row for laserprinters in landscape mode, */
/* so that PlaceTop() can avoid these spots when placing strings   */
    {
    int iCol;

    fInit = TRUE;

    FillRectangle(' ', 0, 0, rowMac, colMac);

    if (!fPostScript)
    if (fBorder)
        {
        /* Draw border around page */
        HorzLine('_', 0         , 1, colMac - 1);
        HorzLine('_', rowMac - 1, 1, colMac - 1);
        VertLine('|', 0         , 1, rowMac);
        VertLine('|', colMac - 1, 1, rowMac);

        /* Fill in column separators */
        for (iCol = 0; iCol < cCol - 1; iCol++)
            VertLine('|', ColBeginIcol(iCol, colWidth) + colWidth, 1, rowMac-1);

        /* mark punch holes */
        if (fLabel && !fPortrait && (fPostScript || fLaser) )
                {
                if (fLaser)
                        {
                        HorzLine('\0', 0, 11, 19);
                        HorzLine('\0', 0, 83, 92);
                        HorzLine('\0', 0, 154, 162);
                        }
                else
                        {
                        HorzLine('\0', 0, 11, 19);
                        HorzLine('\0', 0, 77, 86);
                        HorzLine('\0', 0, 144, 152);
                        }
                }

        }
    }



void RestoreTopRow()
/* replace the zero bytes put in by InitPage() with underscores */
        {
        register char *pch;

        for (pch = &page[0][0];  pch<&page[0][colMac-1];  pch++)
                if (*pch=='\0' || (*pch==' ' && (*(pch-1)=='_' || *(pch+1)=='_')))
                        *pch = '_';
        }


void PlaceTop(szLabel, ichAim, ichMin, ichMax)
char *szLabel;
int ichAim, ichMin, ichMax;
        {
        int cchLab, cTry, dich, ichLim1, ichLim2;
        register int ich;
        register char *pch;
        BOOL fBackward;

        cchLab = strlen(szLabel);
        dich = (fBackward = ichAim<=(colMac-cchLab)/2) ? -1 : 1;

        for (cTry=0;  cTry<2;  cTry++)
                {
                if (fBackward)
                        ichLim1 = (ichLim2=ichAim) + cchLab - 1;
                else
                        ichLim2 = (ichLim1=ichAim+1) + cchLab - 1;
                for (pch= &page[0][ich=ichLim1];
                     ich<ichMax && ich>ichMin;
                     pch += dich,  ich += dich)
                        {
                        if (*pch != '_')
                                {
                                ichLim1 = ich + dich;
                                ichLim2 = ich + (fBackward ? -cchLab : cchLab);
                                }
                        else
                                {
                                if (ich==ichLim2) /* found spot, write string */
                                        {
                                        WriteSzCoord(szLabel, 0, min(ichLim1, ichLim2));
                                        return;
                                        }
                                }
                        }
                /* if no spot found, try the other direction */
                dich = -dich;
                fBackward = !fBackward;
                }
        }


void PlaceNumber(iCol)
int iCol;
        {
        int ichAim, ichMin, ichMax, cchN;
        char szN[8];

        sprintf(szN, " %d ", iPage + iCol + 1);
        ichMin = ColBeginIcol(iCol,colWidth);
        ichAim = ichMin + (colWidth - (cchN=strlen(szN)) )/2;
        ichMax = ichMin + colWidth - cchN - 1;
        PlaceTop(szN, ichAim, ichMin, ichMax);
        }


void LabelPage()
/* place page labels on page */
    {
    int col;
    char szT[11];
    char * szHeader;

    szHeader = szBanner ? szBanner : szFFile;

    if (fLabel)
        {
        if (fPortrait)
            {
            /* move top line over if gutter is being used   */
            col = colGutter;

            /* place in szFTime */
            WriteSzCoord(szFTime, 0, col);
            col += strlen(szFTime)+2;

            /* place in file name after szFTime */
            WriteSzCoord(szHeader, 0, col);
            col += (strlen(szHeader)+2);

            /* place page numbers on page */
            sprintf(szT, "Page %d", iPage + 1);
            WriteSzCoord(szT, 0, col);
            col += (strlen(szT)+2);

            /* place user name on page */
            WriteSzCoord(szUsr, 0, col);
            col += (strlen(szUsr)+4);

            if (fConfidential)
                    {
                    WriteSzCoord(szCompany, 0, col);
                    col += (strlen(szCompany)+1);
                    WriteSzCoord(szConf, 0, col);
                    }

            if (szStamp!=NULL)
                    {
                    WriteSzCoord(szStamp, 0, col);
                    col += (strlen(szStamp)+4);
                    }
            }
        else
            {
            int iCol;

            if (fConfidential)
                {
                PlaceTop(szCompany, colMac/2-strlen(szCompany)-1, 0, colMac-1);
                PlaceTop(szConf, colMac/2, 0, colMac-1);
                }

            if (szStamp!=NULL)
                PlaceTop(szStamp, colMac-strlen(szStamp)-1, 0, colMac-1);

            /* place page numbers on columns */
            for (iCol = 0; iCol < cCol; iCol++)
                PlaceNumber(iCol);

            RestoreTopRow();

            /* place in centered file name */
            WriteSzCoord(szHeader, rowMac-1, (colMac - strlen (szHeader))/2);

            /* place in right-justified szFTime */
            WriteSzCoord(szFTime, rowMac-1, colMac - 2 - strlen(szFTime));

            /* place in name in lower left hand corner */
            WriteSzCoord(szUsr,rowMac-1,2);
            }
        }
    }


void AdvancePage()
/* advance the counters to a succeeding page.  Flush if necessary.  */
    {
    if (fBorder || fLabel)
        rowLine = (fPortrait ? 3 : 1);
    else
        rowLine = 0;

    iPage++;

    /* if we have moved to a new printer page, flush and reinit */
    if ( fPostScript || ((iPage % cCol) == 0))

        {
        FlushPage();
        InitPage();
        if (!fPostScript)
            LabelPage();
        }
    }


void XoutNonPrintSz(sz)
/* replace non-printing characters in sz with dots; don't replace LF, CR, FF
   or HT.
*/
register char    *sz;
{
    if (usCodePage != 0) {
        return;
    }

    while (*sz != '\0') {
        if ( !isascii(*sz)
        || ( !isprint(*sz) &&
              *sz != LF  &&  *sz != CR  && *sz != HT  &&  *sz != FF  &&
              *sz != *sz != ' ')) {
            *sz = '.';
        }
        sz++;
    }
}


void LineOut(sz, fNewLine)
/*  LineOut - place a line of text into the page buffer.  The line is broken
 *  into pieces that are at most colWidth long and are placed into separate
 *  lines in the page.  Lines that contain form-feeds are broken into pieces
 *  also.   Form-feeds cause advance to the next page.  Handle paging. Handle
 *  flushing of the internal buffer.
 *
 *  sz          character pointer to string for output.  We modify this string
 *              during the operation, but restore it at the end.
 *
 *  fNewLine    TRUE ==> this the start of a new input line (should number it)
 */
register char *sz;
BOOL fNewLine;
    {
    register char *pch;

    /* if there is a form feed, recurse to do the part before it */
    while (*(pch = sz + strcspn(sz, "\f")) != '\0')
        {
        if (pch != sz)
            {
            *pch = '\0'; /* temporarily fix to NULL */
            LineOut(sz, fNewLine);
            fNewLine = FALSE;   /* Not a new line after a Form Feed */
            *pch = FF;   /* reset to form feed */
            }

            if (fPostScript) {
                OutLPR ("\f\n\0", 0);
            } else {
                AdvancePage();
            }
        sz = pch + 1; /* point to first char after form feed */
        }

    if (fNewLine)
        iLine++;

    /* if the current line is beyond end of page, advance to next page */
    if (rowLine == rowPage)
        AdvancePage();
    fInit = FALSE;

    if (fNewLine && fNumber) {
        char szLN[cchLNMax + 1];

        sprintf(szLN, LINUMFORMAT, iLine);
        if (fPostScript) {
            OutLPR (szLN, 0);
        } else {
            WriteSzCoord(szLN, rowLine, ColBeginIcol(iPage % cCol,colWidth)+colGutter);
        }
    }

    XoutNonPrintSz(sz);

    /* if the line can fit, drop it in */
    if (strlen(sz) <= (unsigned int)(colWidth - colText))
        if (fPostScript) {
            OutLPR (sz, 0);
            OutLPR ("\n\000",0);
        } else
            WriteSzCoord(sz, rowLine++, ColBeginIcol(iPage % cCol,colWidth) + colText);
    else
        {
        /* drop in the first part and call LineOut for the remainder */
        char ch = sz[colWidth - colText];

        sz[colWidth - colText] = '\0';
        if (fPostScript) {
            OutLPR (sz, 0);
            OutLPR ("\n\000",0);
            /*WriteSzCoord(sz, rowLine++, ColBeginIcol(0, colWidth) + colText);*/
        } else
            WriteSzCoord(sz, rowLine++, ColBeginIcol(iPage % cCol,colWidth) + colText);
        sz[colWidth - colText] = ch;

        LineOut(sz + colWidth - colText, FALSE );
        }
    }


void RawOut(szBuf, cb)
/* print line of raw output */
char * szBuf;
int cb;
        {
        fPageTop = (szBuf[cb - 1] == FF);
        OutLPR(szBuf, cb);
        }


BOOL FilenamX(szSrc, szDst)
/*  copy a filename.ext part from source to dest if present.
    return true if one is found
 */
char *szSrc, *szDst;
        {
#define  szSeps  "\\/:"

        register char *p, *p1;

        p = szSrc-1;
        while (*(p += 1+strcspn(p1=p+1, szSeps)) != '\0')
                ;
        /* p1 points after last / or at bos */
        strcpy(szDst, p1);
        return strlen(szDst) != 0;
        }


int
FileOut(szGiven)
/*  FileOut - print out an entire file.
 *
 *  szGiven         name of file to display.
 */
char *szGiven;
    {
    FILE *pfile;
    int  cDots = 0;
    long lcbStartLPR = 0l;
    char rgbLine[cchLineMax];
    char szFBase[MAX_PATH];
    char rgchBuf[2];

    /* open/secure input file */
    if (!*szGiven || !strcmp(szGiven, "-"))
        {
        pfile = stdin;
        strcpy(szFFile, szBanner ? szBanner : "<stdin>");
        strcpy(szFBase, szFFile);
        szFTime[0] = '\0';
        szGiven = NULL;
        }
    else if ((pfile = fopen(szGiven, szROBin)) != NULL)
        {
        struct _stat st;

        /* The file has been opened, now lets construct a string that
         * tells us exactly what we opened...
         */
        rootpath (szGiven, szFFile);
        _strupr(szFFile);
        FilenamX(szGiven, szFBase);
        if (_stat(szGiven, &st) == -1)
                Fatal("file status not obtainable : [%s]", szGiven, NULL);
        strcpy(szFTime, ctime(&st.st_mtime));
        *(szFTime + strlen(szFTime) - 1) = '\0';
        }
    else
        {
        Error("error opening input file %s", szGiven);
        return(FALSE);
        }

    /* need to get user name to be printed in lower left corner of each */
    /* page and on banner.                                              */
    QueryUserName(szUsr);

    if (!fSilent) {     // Print progress indicator
        fprintf(stderr, "PRINTING %s ", szFBase);
    }

    /* check to see if user forgot -r flag and this is a binary file */
    if (!fRaw && pfile != stdin)
        {
        fread((char *)rgchBuf, sizeof(char), 2, pfile);
        if (rgchBuf[0] == ESC && strchr("&(*E", rgchBuf[1]) != 0)
                {
                fprintf(stderr, "ppr: warning: file is binary; setting raw mode flag");
                fRaw = TRUE;
                }
        if (fseek(pfile, 0L, SEEK_SET) == -1) 
            fprintf(stderr, "ppr: seek failed");     /* reposition the file pointer to start of file */
        }

    if (fPostScript) {
        if (!fFirstFile) {
            OutLPR ("\034\n\000", 0); /* File Separator */
            if (cBanner < 0) /* we at least need to set up the file stuff */
                BannerSz (szBanner ? szBanner : szFBase, 0);
        }
    }

    /* print banner(s) if any */
    if (cBanner > 0)
        BannerSz(szBanner ? szBanner : szFBase, cBanner);
    else if (cBanner < 0  &&  fFirstFile)
        BannerSz(szBanner ? szBanner : szFBase, -cBanner);
    else if (cBanner==0 && fPostScript)
        BannerSz(szBanner ? szBanner : szFBase, 0);

    fFirstFile = FALSE;

    /* always start contents of file at top of page */
    if (!fPageTop)
        {
        if (!fPostScript)
          OutLPR(fPostScript ? "showpage\n" : "\r\f", 0);
        fPageTop = TRUE;
        }

    if (fLaser)
        {
        /* start output mode for laserjet */

        if (fVDuplex || fHDuplex)
            /* always start output on front page */
            OutLPR(SELECTFRONTPAGE,0);

        if (fPortrait)
            OutLPR(BEGINPORTRAIT, 0);
        else
            OutLPR(aszSymSet[usSymSet], 0);
        }

    if (fPostScript) {
        OutLPR (fPortrait ? (fPCondensed ? "QuadPage\n" : "Portrait\n") : "Landscape\n", 0);
        OutLPR ("PrintFile\n", 0);
    }

    /* for PostScript we start the mode before each page */

    lcbStartLPR = lcbOutLPR;
    cDots = 0;
    if (fRaw)
        {
        int cb;

        /* read file and write directly to printer */
        while ((cb = fread(rgbLine, 1, cchLineMax, pfile)) > 0)
            {
            RawOut(rgbLine, cb);
            if (!fSilent && cDots < (lcbOutLPR-lcbStartLPR) / 1024L)
                {
                for (; cDots < (lcbOutLPR-lcbStartLPR) / 1024L; cDots++)
                    fputc('.', stderr);
                }
            }
        }
    else
        {
        /* initialize file information */
        iLine = 0;

        /* initialize page information */
        iPage = -1;
        rowLine = rowPage;
        fInit = TRUE;

        /* read and process each line */
        while (fgetl(rgbLine, cchLineMax, pfile)) {
                LineOut(rgbLine, TRUE);
                if (!fSilent && cDots < (lcbOutLPR-lcbStartLPR) / 1024L) {
                    for (; cDots < (lcbOutLPR-lcbStartLPR) / 1024L; cDots++) {
                        fputc('.', stderr);
                    }
                }
        }

        /* flush out remainder if any */
        FlushPage();
        }

    if (!fPageTop && (fForceFF || fPostScript) && (!fPostScript || !fRaw))
       {
        if (!fPostScript)
           OutLPR(fPostScript ? "showpage\n" : "\r\f", 0);
       fPageTop = TRUE;
       }

    fclose(pfile);

    if (!fSilent)               /* finish PRINTING message with CRLF when done*/
        fprintf(stderr, "%dk\n", (lcbOutLPR-lcbStartLPR)/1024);

    if (fDelete && szGiven)
        {
        if (fSilent)
            _unlink(szGiven);
        else
            {
            fprintf(stderr, "DELETING %s...", szGiven);
            if (!_unlink(szGiven))
                fprintf(stderr, "OK\n");
            else
                fprintf(stderr, "FAILED: file not deleted\n");
            }
        }
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ppr\lpfile.c ===
/*
 *	File handling for LPR
 *
 *	Read from an init file.
 *	Read from a file, expanding tabs.
 */

#include <windef.h>
#include <stdio.h>
#include <string.h>
#include "lpr.h"


extern BOOL fVerify; /* From lpr.c - for verifying our progression */

#define cchIniMax 80		/* length of line in tools.ini file	   */
#define cchPathMax 128          /* maximum length of USER env var.	   */




/* from fgetl.c - expand tabs and return lines w/o separators */

int colTab = 8;		/* Tab stops every colTab columns */



char* __cdecl fgetl(sz, cch, fh)
/* returns line from file (no CRLFs); returns NULL if EOF */
/* Maps nulls read in into .'s */
char *sz;
int cch;
FILE *fh;
    {
    register int c;
    register char *p;

    /* remember NUL at end */
    cch--;
    p = sz;
    while (cch)
	{
        c = getc(fh);
        if (c == EOF || c == '\n')
            break;
        if (c != '\r')
            if (c != '\t')
		{
		*p++ = (char)((unsigned)c ? (unsigned)c : (unsigned)'.');
		cch--;
		}
            else
		{
                c = (int)(min(colTab - ((p-sz) % colTab), cch));
                memset(p, ' ', c);
                p += c;
                cch -= c;
                }
        }
    *p = 0;
    return (!( (c == EOF) && (p == sz) )) ? sz : NULL;
    }




char *SzFindPath(szDirlist, szFullname, szFile)
/* SzFindPath -- Creates szFullname from first entry in szDirlist and szFile.
 *		 The remaining directory list is returned.  If the directory
 *		 list is empty, NULL is returned.
 */
char *szDirlist;
char *szFullname;
char *szFile;
	{
#define chDirSep ';'	/* seperator for entries in directory list */
#define chDirDelim '\\'	/* end of directory name character	   */

	register char *pch;
	register char *szRc;		    /* returned directory list	*/

	if ((pch = strchr(szDirlist, chDirSep)) != 0)
		{
                *pch = (char)NULL; /* replace ';' with null */
		szRc = pch + 1;
		}
	else
		{
		pch  = strchr(szDirlist,'\0');
		szRc = NULL;
		}

        strcpy(szFullname,szDirlist);
        if (szRc != NULL) {
            /* We MUST restore the input string */
            *(szRc-1) = chDirSep;
        }

	/* if directory name doesn't already end with chDirDelim, append it */
	if (*(pch-1) != chDirDelim)
		{
		pch    = szFullname + strlen(szFullname);
		*pch++ = chDirDelim;
                *pch   = (char)NULL;
		}

	strcat(szFullname,szFile);

	return(szRc);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\plperf\plperf.c ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>

typedef struct _PerfDataSectionHeader {
    DWORD       dwEntriesInUse;
    DWORD       dwMaxEntries;
    DWORD       dwMissingEntries;
    DWORD       dwInitSignature;
    BYTE        reserved[112];
} PerfDataSectionHeader, *pPerfDataSectionHeader;

#define PDSH_INIT_SIG   ((DWORD)0x01234567)

#define PDSR_SERVICE_NAME_LEN   32
typedef struct _PerfDataSectionRecord {
    WCHAR       szServiceName[PDSR_SERVICE_NAME_LEN];
    LONGLONG    llElapsedTime;
    DWORD       dwCollectCount; // number of times Collect successfully called
    DWORD       dwOpenCount;    // number of Loads & opens
    DWORD       dwCloseCount;   // number of Unloads & closes
    DWORD       dwLockoutCount; // count of lock timeouts
    DWORD       dwErrorCount;   // count of errors (other than timeouts)
    DWORD       dwLastBufferSize; // size of the last buffer returned
    DWORD       dwMaxBufferSize; // size of MAX buffer returned
    DWORD       dwMaxBufferRejected; // size of largest buffer returned as too small
    BYTE        Reserved[24];     // reserved to make structure 128 bytes
} PerfDataSectionRecord, *pPerfDataSectionRecord;

// performance data block entries
TCHAR   szPerflibSectionFile[MAX_PATH];
TCHAR   szPerflibSectionName[MAX_PATH];
HANDLE  hPerflibSectionFile = NULL;
HANDLE  hPerflibSectionMap = NULL;
LPVOID  lpPerflibSectionAddr = NULL;

#define     dwPerflibSectionMaxEntries  127L
const DWORD dwPerflibSectionSize = (sizeof(PerfDataSectionHeader) + (sizeof(PerfDataSectionRecord) * dwPerflibSectionMaxEntries));

// -----------------------------------------------------------------------
// FUNCTION: _tmain
//
// The main function primarily splits off the main tasks of either
// enumerating the performance objects and object items, or dumping
// the performance data of the user specified counter.
// -----------------------------------------------------------------------

int  __cdecl _tmain(int argc, TCHAR **argv)
{
    if (argc < 2) {
        _tprintf ("Enter the process ID in decimal of the process to view");
        return 0;
    }
    

    if (hPerflibSectionFile == NULL) {
        TCHAR   szTmpFileName[MAX_PATH];
        pPerfDataSectionHeader  pHead;
        TCHAR   szPID[32];
        DWORD   dwPid;

        dwPid = _tcstoul(argv[1],NULL, 10);
        _stprintf (szPID, TEXT("%x"), dwPid);

        // create section name
        lstrcpy (szPerflibSectionName, (LPCTSTR)"Perflib_Perfdata_");
        //lstrcpy (szPID, argv[1]);
        lstrcat (szPerflibSectionName, szPID);

        // create filename
        lstrcpy (szTmpFileName, (LPCTSTR)"%windir%\\system32\\");
        lstrcat (szTmpFileName, szPerflibSectionName);
        lstrcat (szTmpFileName, (LPCTSTR)".dat");
        ExpandEnvironmentStrings (szTmpFileName, szPerflibSectionFile, MAX_PATH);

/*        hPerflibSectionFile = CreateFile (
            szPerflibSectionFile,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_TEMPORARY,
            NULL);

        if (hPerflibSectionFile != INVALID_HANDLE_VALUE) {
*/            // create file mapping object
            hPerflibSectionMap = OpenFileMapping (
                FILE_MAP_READ, FALSE,
                szPerflibSectionName);

            if (hPerflibSectionMap != NULL) {
                // map view of file
                lpPerflibSectionAddr = MapViewOfFile (
                    hPerflibSectionMap,
                    FILE_MAP_READ,
                    0,0, dwPerflibSectionSize);
                if (lpPerflibSectionAddr != NULL) {
                    // init section if not already
                    pHead = (pPerfDataSectionHeader)lpPerflibSectionAddr;
                    if (pHead->dwInitSignature != PDSH_INIT_SIG) {
                        // then not ready
                        _tprintf ((LPCTSTR)"Data Section has not been initialized.\n", GetLastError());
                        UnmapViewOfFile (lpPerflibSectionAddr);
                        lpPerflibSectionAddr = NULL;
                        CloseHandle (hPerflibSectionMap);
                        hPerflibSectionMap = NULL;
                        CloseHandle (hPerflibSectionFile);
                        hPerflibSectionFile = NULL;
                    } else {
                        // already initialized so leave it
                    }
                } else { 
                    // unable to map file so close 
                    _tprintf ((LPCTSTR)"Unable to map file for reading perf data (%d)\n", GetLastError());
                    CloseHandle (hPerflibSectionMap);
                    hPerflibSectionMap = NULL;
                    CloseHandle (hPerflibSectionFile);
                    hPerflibSectionFile = NULL;
                }
            } else {
                // unable to create file mapping so close file
                _tprintf ((LPCTSTR)"Unable to create file mapping object for reading perf data (%d)\n", GetLastError());
                CloseHandle (hPerflibSectionFile);
                hPerflibSectionFile = NULL;
            }
/*        } else {
            // unable to open file so no perf stats available
            _tprintf ((LPCTSTR)"Unable to open file for reading perf data (%d)\n", GetLastError());
            hPerflibSectionFile = NULL;
        }
*/    }
	
    if (lpPerflibSectionAddr != NULL) {
        pPerfDataSectionHeader  pHead = (pPerfDataSectionHeader)lpPerflibSectionAddr;
        pPerfDataSectionRecord  pEntry = (pPerfDataSectionRecord)lpPerflibSectionAddr;
        DWORD                   i;
        double                  dTime;
        double                  dFreq;
        LARGE_INTEGER           liTimeBase;

        QueryPerformanceFrequency (&liTimeBase);
        dFreq = (double)liTimeBase.QuadPart;

        _tprintf ((LPCTSTR)"Perflib Performance Data for process %s\n", argv[1]);
        _tprintf ((LPCTSTR)"%d/%d entries in section\n", pHead->dwEntriesInUse, pHead->dwMaxEntries);
        _tprintf ((LPCTSTR)"%d services not logged\n", pHead->dwMissingEntries);
        _tprintf ((LPCTSTR)"                        Service Name    Avg Coll. Ms    ");
        _tprintf ((LPCTSTR)"Collects  Opens Closes Lockout  Errs    Last Buf     Max Buf Max Rej Buf\n");
        // then walk the structures present
        for (i = 1; i <= pHead->dwEntriesInUse; i++) {

            // compute average collect time
            if (pEntry[i].dwCollectCount > 0) {
                dTime = (double)pEntry[i].llElapsedTime;
                dTime /= (double)pEntry[i].dwCollectCount;
                dTime /= dFreq;
                dTime *= 1000.0; // convert to mSec
            } else {
                dTime = 0.0;
            }

            _tprintf ((LPCTSTR)"    %32.32ls\t%12.6f %11d %6d %6d %6d %6d %11d %11d %11d\n",
                pEntry[i].szServiceName,
                dTime,
                pEntry[i].dwCollectCount,
                pEntry[i].dwOpenCount,
                pEntry[i].dwCloseCount,
                pEntry[i].dwLockoutCount,
                pEntry[i].dwErrorCount,
                pEntry[i].dwLastBufferSize,
                pEntry[i].dwMaxBufferSize,
                pEntry[i].dwMaxBufferRejected);
           
        }

        UnmapViewOfFile (lpPerflibSectionAddr);
        lpPerflibSectionAddr = NULL;
        CloseHandle (hPerflibSectionMap);
        hPerflibSectionMap = NULL;
//        CloseHandle (hPerflibSectionFile);
//        hPerflibSectionFile = NULL;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ppr\lpprint.c ===
/*
 *      LPPRINT.C   -   Printer handling for PPR
 *
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <io.h>
#include <fcntl.h>
#include <windows.h>
#include <tools.h>
#include "lpr.h"


char szPName[cchArgMax];        /* text of printer to open              */
char szNet[cchArgMax] = "";     /* network name of printer to open      */
char *szPDesc = NULL;           /* printer description string           */

FILE *pfileLPR = NULL;          /* file for output                      */

extern BOOL fVerify; /* From LPR.C */
extern USHORT usCodePage;


void
OutLPR(
    char *sz,
    int cb
    )
{
    if (cb == 0)
        cb = strlen(sz);
    lcbOutLPR += cb;    /* keep track of how much has been written to printer */

    if (fwrite(sz, 1, cb, pfileLPR) != (unsigned int)cb)
        Error("warning: error writing to printer");
}

/*
 *  We need to add a little cheat, since some of our forced strings might have
 *  special postscript characters in them, such as the file name for one...
 *  We will call this function instead of OutLPR anytime that the string we are
 *  outputing will be within '(...)', and might contain \, (, or ).
 *  The code was borrowed from the original version of OutEncPS.
 */
void
OutLPRPS(
/* output substring quoting all \, ( and ) */
    char *pchF,
    int cchF
    )
{
    register char *pchT;
    int cchT;
    char rgbT[1+colMax*2+5];/* enough for every character to be encoded */

    pchT = rgbT;
    cchT = 0;
    if (cchF == 0)
        cchF = strlen(pchF);
    *pchT = (char)0;

    while (cchF-- > 0) {
        switch(*pchF++) {
            default:
                *pchT++ = *(pchF-1);
                cchT++;
                break;
            case '\\':
                *pchT++ = '\\';
                *pchT++ = '\\';
                cchT += 2;
                break;
            case '(':
                *pchT++ = '\\';
                *pchT++ = '(';
                cchT += 2;
                break;
            case ')':
                *pchT++ = '\\';
                *pchT++ = ')';
                cchT += 2;
                break;
        }
    }
    OutLPR(rgbT, cchT);
}

void
DefaultPSHeader()
{
/* Don't install an error handler for now. If they need one, then they
 * should be installing one onto the printer permanently. SETERROR.PSF
 * is one they can use if they need to.
 */
//OutLPR ("errordict begin\n",0); /* join */
//OutLPR ("/handleerror {\n",0); /* join */
//OutLPR   ("$error begin\n",0); /* join */
//OutLPR     ("newerror {\n",0); /* join */
//OutLPR       ("/newerror false def\n",0); /* join */
//OutLPR       ("showpage\n",0); /* join */
//OutLPR       ("72 72 scale\n",0); /* join */
//OutLPR       ("/Helvetica findfont .2 scalefont setfont\n",0); /* join */
//OutLPR       (".25 10 moveto\n",0); /* join */
//OutLPR       ("(Error/ErrorName = ) show\n",0); /* join */
//OutLPR       ("errorname {\n",0); /* join */
//OutLPR         ("dup type\n",0); /* join */
//OutLPR         ("dup ([ ) show\n",0); /* join */
//OutLPR ("(\n",0); /* join */
//OutLPR ("neringtypeflow\n",0); /* join */
//OutLPR (")\n",0); /* join */
//OutLPR         ("cvs show ( : ) show\n",0); /* join */
//OutLPR         ("/stringtype ne {\n",0); /* join */
//OutLPR ("(\n",0); /* join */
//OutLPR ("neringtypeflow\n",0); /* join */
//OutLPR (")\n",0); /* join */
//OutLPR           ("cvs\n",0); /* join */
//OutLPR         ("} if\n",0); /* join */
//OutLPR       ("show\n",0); /* join */
//OutLPR       ("} exec\n",0); /* join */
//OutLPR       ("( ]; Error/Command = ) show\n",0); /* join */
//OutLPR       ("/command load {\n",0); /* join */
//OutLPR         ("dup type /stringtype ne {\n",0); /* join */
//OutLPR ("(\n",0); /* join */
//OutLPR ("neringtypeflow\n",0); /* join */
//OutLPR (")\n",0); /* join */
//OutLPR           ("cvs\n",0); /* join */
//OutLPR         ("} if show\n",0); /* join */
//OutLPR       ("} exec\n",0); /* join */
//OutLPR       ("( %%) {\n",0); /* join */
//OutLPR         ("{\n",0); /* join */
//OutLPR           ("dup type /stringtype ne {\n",0); /* join */
//OutLPR ("(\n",0); /* join */
//OutLPR ("neringtypeflow\n",0); /* join */
//OutLPR (")\n",0); /* join */
//OutLPR             ("cvs\n",0); /* join */
//OutLPR           ("} if\n",0); /* join */
//OutLPR           ("show\n",0); /* join */
//OutLPR         ("} exec (\n",0); /* join */
//OutLPR (") show\n",0); /* join */
//OutLPR       ("} exec\n",0); /* join */
//OutLPR       ("/x .25 def\n",0); /* join */
//OutLPR       ("/y 10 def\n",0); /* join */
//OutLPR ("\n",0); /* join */
//OutLPR       ("/y y .2 sub def\n",0); /* join */
//OutLPR       ("x y moveto\n",0); /* join */
//OutLPR       ("(Stack =) show\n",0); /* join */
//OutLPR       ("ostack {\n",0); /* join */
//OutLPR         ("/y y .2 sub def x 1 add y moveto\n",0); /* join */
//OutLPR         ("dup type /stringtype ne {\n",0); /* join */
//OutLPR ("(\n",0); /* join */
//OutLPR ("neringtypeflow\n",0); /* join */
//OutLPR (")\n",0); /* join */
//OutLPR           ("cvs\n",0); /* join */
//OutLPR         ("} if\n",0); /* join */
//OutLPR         ("show\n",0); /* join */
//OutLPR       ("} forall\n",0); /* join */
//OutLPR ("\n",0); /* join */
//OutLPR       ("showpage\n",0); /* join */
//OutLPR     ("} if % if (newerror)\n",0);
//OutLPR   ("end\n",0); /* join */
//OutLPR ("} def\n",0); /* join */
//OutLPR ("end\n",0); /* join */
//OutLPR ("\n",0); /* join */
/* End of error handler */

OutLPR ("/inch {72 mul} def\n",0); /* join */
OutLPR ("/White 1 def\n",0); /* join */
OutLPR ("/Black 0 def\n",0); /* join */
OutLPR ("/Gray .9 def\n",0); /* join */
OutLPR ("newpath clippath closepath pathbbox\n",0); /* join */
OutLPR ("/ury exch def\n",0); /* join */
OutLPR ("/urx exch def\n",0); /* join */
OutLPR ("/lly exch def\n",0); /* join */
OutLPR ("/llx exch def\n",0); /* join */
OutLPR ("/PrintWidth urx llx sub def\n",0); /* join */
OutLPR ("/PrintHeight ury lly sub def\n",0); /* join */
OutLPR ("/Mode 0 def\n",0); /* join */
OutLPR ("/doBanner false def\n",0); /* join */
OutLPR ("/MSConfidential false def\n",0); /* join */
OutLPR ("/HeaderHeight 12 def\n",0); /* join */
OutLPR ("/FooterHeight 12 def\n",0); /* join */
OutLPR ("/FontHeight 12 def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/szLine 256 string def\n",0); /* join */
OutLPR ("/Font1 (Courier-Bold) def\n",0); /* join */
OutLPR ("/Font2 (Times-Roman) def\n",0); /* join */
OutLPR ("/Font3 (Helvetica-Bold) def\n",0); /* join */
OutLPR ("Font1 cvn findfont setfont\n",0); /* join */
OutLPR ("/LinesPerPage 62 def\n",0); /* join */
OutLPR ("/AveCharWidth (0) stringwidth pop def\n",0); /* join */
OutLPR ("/CharsPerLine AveCharWidth 86 mul def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/sw { % Add Widths of mulitple strings\n",0);
OutLPR     ("stringwidth pop add\n",0); /* join */
OutLPR ("} bind def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/CenterString {\n",0); /* join */
OutLPR     ("/str exch def /width exch def\n",0); /* join */
OutLPR     ("width str stringwidth pop sub 2 div 0 rmoveto\n",0); /* join */
OutLPR     ("str\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/Box { % put a 'box' path into current path using width and height\n",0);
OutLPR     ("/h exch def\n",0); /* join */
OutLPR     ("/w exch def\n",0); /* join */
OutLPR     ("currentpoint\n",0); /* join */
OutLPR     ("/y exch def\n",0); /* join */
OutLPR     ("/x exch def\n",0); /* join */
OutLPR     ("x w add y lineto\n",0); /* join */
OutLPR     ("x w add y h add lineto\n",0); /* join */
OutLPR     ("x y h add lineto\n",0); /* join */
OutLPR     ("x y lineto\n",0); /* join */
OutLPR ("} bind def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/DoBannerPage {\n",0); /* join */
OutLPR     ("/doBanner false def\n",0); /* join */
OutLPR     ("Mode 1 eq {8.5 inch 0 inch translate 90 rotate} if\n",0); /* join */
OutLPR     ("2 setlinewidth 2 setmiterlimit\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR     ("% Banner Piece #1\n",0);
OutLPR     ("newpath\n",0); /* join */
OutLPR       ("0 PrintHeight moveto\n",0); /* join */
OutLPR       ("llx .5 inch add -1 inch rmoveto\n",0); /* join */
OutLPR       ("PrintWidth 1 inch sub .75 inch Box\n",0); /* join */
OutLPR     ("closepath stroke\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR     ("/XUnit PrintWidth 8 div def\n",0); /* join */
OutLPR     ("/XPos XUnit def\n",0); /* join */
OutLPR     ("/YPos PrintHeight .5 inch sub def\n",0); /* join */
OutLPR     ("/YInc .15 inch def\n",0); /* join */
OutLPR     ("Font2 cvn findfont YInc scalefont setfont\n",0); /* join */
OutLPR     ("XPos YPos moveto (User:) show /YPos YPos YInc sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto (File Name:) show /YPos YPos YInc sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto (Date Printed:) show /YPos YPos YInc sub def\n",0); /* join */
OutLPR     ("/XPos XUnit 4 mul def\n",0); /* join */
OutLPR     ("/YPos PrintHeight .5 inch sub YInc sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto (Directory:) show /YPos YPos YInc sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto (Time Printed:) show /YPos YPos YInc sub def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR     ("Font1 cvn findfont YInc scalefont setfont\n",0); /* join */
OutLPR     ("/XPos XUnit 2 mul def\n",0); /* join */
OutLPR     ("/YPos PrintHeight .5 inch sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto UserName show /YPos YPos YInc sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto FileName show /YPos YPos YInc sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto Date show /YPos YPos YInc sub def\n",0); /* join */
OutLPR     ("/XPos XUnit 5 mul def\n",0); /* join */
OutLPR     ("/YPos PrintHeight .5 inch sub YInc sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto PathName show /YPos YPos YInc sub def\n",0); /* join */
OutLPR     ("XPos YPos moveto Time show\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR     ("% Banner Piece #2\n",0);
OutLPR     ("Font3 cvn findfont 1 inch scalefont setfont\n",0); /* join */
OutLPR     ("newpath\n",0); /* join */
OutLPR       ("llx PrintHeight 3 inch sub moveto\n",0); /* join */
OutLPR       ("PrintWidth UserName CenterString true charpath\n",0); /* join */
OutLPR       ("llx PrintHeight 5 inch sub moveto\n",0); /* join */
OutLPR       ("PrintWidth FileName CenterString true charpath\n",0); /* join */
OutLPR     ("closepath\n",0); /* join */
OutLPR     ("gsave\n",0); /* join */
OutLPR       ("Gray setgray fill\n",0); /* join */
OutLPR     ("grestore\n",0); /* join */
OutLPR     ("stroke\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR     ("MSConfidential {\n",0); /* join */
OutLPR       ("Font2 cvn findfont .5 inch scalefont setfont\n",0); /* join */
OutLPR       ("newpath\n",0); /* join */
OutLPR         ("llx PrintHeight 7 inch sub moveto\n",0); /* join */
OutLPR         ("PrintWidth Stamp CenterString show\n",0); /* join */
OutLPR       ("closepath\n",0); /* join */
OutLPR     ("} if\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR     ("showpage\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/BannerPage {\n",0); /* join */
OutLPR     ("/doBanner true def\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/Portrait {\n",0); /* join */
OutLPR     ("/LinesPerPage 66 def\n",0); /* join */
OutLPR     ("/CharsPerLine CharsPerLine Columns div def\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/QuadPage {\n",0); /* join */
OutLPR     ("/LinesPerPage 132 def\n",0); /* join */
OutLPR     ("/CharsPerLine CharsPerLine Columns 2 div div def\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/Landscape {\n",0); /* join */
OutLPR     ("/PrintHeight urx llx sub def\n",0); /* join */
OutLPR     ("/PrintWidth ury lly sub def\n",0); /* join */
OutLPR     ("/Mode 1 def\n",0); /* join */
OutLPR     ("/LinesPerPage 62 def\n",0); /* join */
OutLPR     ("/CharsPerLine CharsPerLine Columns 2 div div def\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/Init {\n",0); /* join */
OutLPR     ("100 0 {dup mul exch dup mul add 1 exch sub} setscreen\n",0); /* join */
OutLPR     ("PrintWidth Columns div .02 mul\n",0); /* join */
OutLPR     ("/BorderX exch def\n",0); /* join */
OutLPR     ("PrintWidth BorderX sub Columns div BorderX sub\n",0); /* join */
OutLPR     ("/PageWidth exch def\n",0); /* join */
OutLPR     ("PrintHeight HeaderHeight FooterHeight add sub\n",0); /* join */
OutLPR     ("/PageHeight exch def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR     ("/FontHeight PageHeight LinesPerPage div def\n",0); /* join */
OutLPR     ("/FontWidth PageWidth CharsPerLine div def\n",0); /* join */
OutLPR     ("/PageNumber 1 def\n",0); /* join */
OutLPR     ("PageHeight FooterHeight add FontHeight sub\n",0); /* join */
OutLPR     ("/topY exch def\n",0); /* join */
OutLPR     ("/currentY topY def\n",0); /* join */
OutLPR     ("FooterHeight FontHeight add\n",0); /* join */
OutLPR     ("/bottomY exch def\n",0); /* join */
OutLPR     ("BorderX 1.25 mul\n",0); /* join */
OutLPR     ("/currentX exch def\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/PageBorder {\n",0); /* join */
OutLPR     ("% Gray backgound\n",0);
OutLPR     ("currentgray\n",0); /* join */
OutLPR     ("newpath clippath closepath Gray setgray fill\n",0); /* join */
OutLPR     ("setgray\n",0); /* join */
OutLPR     ("Label {\n", 0); /* join */
OutLPR         ("Font2 cvn findfont FooterHeight scalefont setfont\n",0); /* join */
OutLPR         ("% Left Justify UserName\n",0);
OutLPR         ("BorderX 2 moveto\n",0); /* join */
OutLPR         ("UserName show\n",0); /* join */
OutLPR         ("PrintWidth 2 div 2 moveto\n",0); /* join */
OutLPR         ("% Center File Name\n",0);
OutLPR         ("0 PathName sw (\\\\) sw FileName sw 2 div neg 0 rmoveto\n",0); /* join */
OutLPR         ("PathName show (\\\\) show FileName show\n",0); /* join */
OutLPR         ("% Right Justify Date\n",0);
OutLPR         ("PrintWidth BorderX sub 2 moveto\n",0); /* join */
OutLPR         ("FTime stringwidth pop neg 0 rmoveto FTime show\n",0); /* join */
OutLPR     ("} if\n", 0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/Confidential {\n",0); /* join */
OutLPR   ("MSConfidential {\n",0); /* join */
OutLPR     ("gsave\n",0); /* join */
OutLPR       ("PageWidth 2 div PageHeight 2 div moveto Font2 cvn findfont\n",0); /* join */
OutLPR       ("setfont Stamp stringwidth pop PageWidth exch div dup 30\n",0); /* join */
OutLPR       ("rotate PageWidth 2 div neg 0 rmoveto scale\n",0); /* join */
OutLPR       ("Stamp true charpath closepath gsave Gray setgray fill\n", 0);
OutLPR       ("grestore 0 setlinewidth stroke\n",0);
OutLPR     ("grestore\n",0); /* join */
OutLPR   ("} if\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/NewPage {\n",0); /* join */
OutLPR     ("/currentY topY def\n",0); /* join */
OutLPR     ("Columns 1 gt PageNumber 1 sub Columns mod 0 ne and {\n",0); /* join */
OutLPR         ("% Don't do this on first column of page\n",0);
OutLPR         ("PageWidth BorderX add 0 translate\n",0); /* join */
OutLPR     ("} {\n",0); /* join */
OutLPR         ("% Do this only for first column of page\n",0);
OutLPR         ("llx lly translate\n",0); /* join */
OutLPR         ("Mode 1 eq { PrintHeight 0 translate 90 rotate } if\n",0); /* join */
OutLPR         ("PageBorder\n",0); /* join */
OutLPR     ("} ifelse\n",0); /* join */
OutLPR     ("newpath % Frame the page\n",0);
OutLPR         ("BorderX FooterHeight moveto\n",0); /* join */
OutLPR         ("PageWidth PageHeight Box\n",0); /* join */
OutLPR     ("closepath\n",0); /* join */
OutLPR     ("gsave\n",0); /* join */
OutLPR         ("White setgray fill\n",0); /* join */
OutLPR     ("grestore\n",0); /* join */
OutLPR     ("Black setgray stroke\n",0); /* join */
OutLPR     ("Confidential\n",0);
OutLPR     ("Font2 cvn findfont HeaderHeight scalefont setfont\n",0); /* join */
OutLPR     ("BorderX PageWidth 2 div add FooterHeight PageHeight add 2 add moveto\n",0); /* join */
OutLPR     ("Label {\n", 0); /* join */
OutLPR         ("PageNumber szLine cvs show\n",0); /* join */
OutLPR     ("} if\n", 0);
OutLPR     ("Font1 cvn findfont [FontWidth 0 0 FontHeight 0 0] makefont setfont\n",0); /* join */
OutLPR     ("/PageNumber PageNumber 1 add def\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/EndPage {\n",0); /* join */
OutLPR     ("Columns 1 eq PageNumber 1 sub Columns mod 0 eq or { showpage } if\n",0); /* join */
OutLPR     ("NewPage\n",0); /* join */
OutLPR ("} def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/PrintLine {\n",0); /* join */
OutLPR     ("dup dup length 0 gt {\n",0); /* join */
OutLPR         ("% Something there\n",0);
OutLPR         ("0 get 12 eq {\n",0); /* join */
OutLPR             ("% Form Feed\n",0);
OutLPR             ("EndPage\n",0); /* join */
OutLPR         ("}{\n",0); /* join */
OutLPR             ("currentX currentY moveto show\n",0); /* join */
OutLPR             ("/currentY currentY FontHeight sub def\n",0); /* join */
OutLPR             ("currentY bottomY le { EndPage } if\n",0); /* join */
OutLPR         ("} ifelse\n",0); /* join */
OutLPR     ("}{\n",0); /* join */
OutLPR         ("% Blank Line\n",0);
OutLPR         ("pop pop pop\n",0); /* join */
OutLPR         ("/currentY currentY FontHeight sub def\n",0); /* join */
OutLPR         ("currentY bottomY le { EndPage } if\n",0); /* join */
OutLPR     ("} ifelse\n",0); /* join */
OutLPR ("}bind def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/DebugOut {\n",0); /* join */
OutLPR     ("/num exch def\n",0); /* join */
OutLPR     ("/str exch def\n",0); /* join */
OutLPR     ("currentpoint\n",0); /* join */
OutLPR     ("str show\n",0); /* join */
OutLPR     ("num szLine cvs show\n",0); /* join */
OutLPR     ("moveto\n",0); /* join */
OutLPR     ("0 -11 rmoveto\n",0); /* join */
OutLPR ("}bind def\n",0); /* join */
OutLPR ("\n",0); /* join */
OutLPR ("/PrintFile {\n",0); /* join */
OutLPR     ("Init % Initialize some values\n",0);
OutLPR     ("doBanner { DoBannerPage } if\n",0); /* join */
OutLPR     ("NewPage\n",0); /* join */
OutLPR     ("{\n",0); /* join */
OutLPR         ("currentfile szLine readline not {exit} if\n",0); /* join */
OutLPR         ("dup dup length 0 gt { 0 get 28 eq {exit} if } if\n",0); /* join */
OutLPR         ("PrintLine\n",0); /* join */
OutLPR     ("} loop\n",0); /* join */
OutLPR     ("showpage % Will this *ever* produce an unwanted blank page?\n",0);
OutLPR ("} bind def\n",0); /* join */
} /* DefaultPSHeader */


void
InitPrinter()
{
    char *szHeader;
    char *szDirlist;
    char szFullname[MAX_PATH];
    BOOL fConcat = FALSE;
    FILE *psfFile;

    register char *pch;

    if (fLaser) {
        OutLPR(RESETPRINTER, 0);
        if (fVDuplex) {
                OutLPR(BEGINDUPLEXVERT,0);
        } else if (fHDuplex)
                OutLPR(BEGINDUPLEXHOR,0);
    } else if (fPostScript) {
        /* write the job setup for postscript */
        OutLPR("\n\004\n% ppr job\n", 0); /* ^D to flush previous job */
        if (!fPSF) {
            DefaultPSHeader();
        } else {
            szHeader = szPSF;
            if (*szHeader == '+') {
                szHeader++; // step over the '+'
                fConcat = TRUE;
                DefaultPSHeader();
            }

/* Lets make an attempt to use environment variables... */
            if ((*szHeader == '$') && ((pch = strchr(++szHeader,':')) != NULL)) {
                    *pch      = (char)NULL;
                    _strupr(szHeader);
                    szDirlist = getenvOem(szHeader);
//                    szDirlist = getenv(szHeader);
                    *pch      = ':';
                    szHeader  = ++pch;
            } else {
                    szDirlist = NULL;
            }

            while (szDirlist) {
                    szDirlist = SzFindPath(szDirlist,szFullname,szHeader);
                    szHeader = szFullname;
            }
/* ...end of attempt */

            if ((psfFile = fopen(szHeader, szROBin)) != NULL) {
                int cb;
                char psfLine[cchLineMax];
                char szFFile[MAX_PATH];

                rootpath (szHeader, szFFile);
                _strupr(szFFile);
                fprintf (stdout, "\nUsing PSF File: %s\n", szFFile);
                while ((cb = fread(psfLine, 1, cchLineMax, psfFile)) > 0)
                    RawOut(psfLine, cb);
            } else {
                fprintf (stdout, "Error opening PSF file %s\n", szPSF);
                if (!fConcat) {
                    fprintf (stdout, "Continuing with default header...\n");
                    DefaultPSHeader();
                }
            }
        }
    }
}



void
MyOpenPrinter()
{
    if (strcmp(szPName, "-") == 0) {
        pfileLPR = stdout;
        _setmode((int)_fileno(pfileLPR), (int)O_BINARY);
    } else {
        if ((pfileLPR = fopen(szPName, szWOBin)) == NULL)
            Fatal("Error opening output file %s", szPName);
    }
    InitPrinter();
}


void
FlushPrinter()
{
    /* A FormFeed is sent before each page.  For fForceFF, we also send
       one after the last page.  For !fForceFF we move to the top of
       the page so that when the network software outputs \r\n\f, we do
       not get a blank page.

       NOTE: for !fForceFF we don't reset the printer or change modes back
       to portrait since that causes any unfinished page to be ejected.
    */
    if (fLaser) {
        if (fVDuplex || fHDuplex)
            OutLPR(BEGINSIMPLEX,0);
        else
            if (fForceFF)
                OutLPR(RESETPRINTER, 0);
            else
                OutLPR(MOVETOTOP, 0);
    }
    else if (fPostScript)
        OutLPR("\n\004\n", 0); /* ^D to flush */
    else
        OutLPR("\n\n",0);       /* force last line on LP */
}



void
MyClosePrinter()
{
    if (pfileLPR == 0)
        return;         /* already closed */

    FlushPrinter();
    if (pfileLPR != stdout)
        fclose(pfileLPR);
    pfileLPR = NULL;
}



/* Fill szBuf with first non-blank substring found in sz;  return pointer
   to following non-blank.  Note: ',' is considered a separator as are ' '
   and '\t' however, ',' is also considered a non-blank.
*/
char *
SzGetSzSz(
    char * sz,
    char * szBuf
    )
{
    int cch;

    sz += strspn(sz, " \t");
    cch = strcspn(sz, " \t,");
    szBuf[0] = '\0';
    if (cch)        /* count of 0 causes error on Xenix 286 */
        strncat(szBuf, sz, cch);
    sz += cch;
    sz += strspn(sz, " \t");
    return sz;
}




char *
SzGetPrnName(
    char *sz,
    char *szBuf
    )
{
    register char  *pch;

    sz = SzGetSzSz(sz, szBuf);
    if (*(pch = szBuf+strlen(szBuf)-1) == ':')
        *pch = '\0';    /* Remove colon from end of printer name */
    return (sz);
}




/*   get printer name and net redirection from a string
 *
 *      Entry:  sz - string to parse;
 *              szPName contains printer name that user requested to use
 *
 *      Return Value:   TRUE  if printer name found matches and thus
 *                      the rest of the string was processed;
 *                      FALSE  if no match and thus string is ignored
 *
 *      Global Variables Set:
 *
 *      szPName - Physical printer port to use, or output file name
 *      szNet   - Network redirection name
 *      szPass  - Network password
 *
 *      printer desc:
 *        (DOS)   [<name> [none | \\<machine>\<shortname> [<password>]]] [,<options>]
 *        (Xenix) [ ( [ net[#] | lpr[#] | xenix[#] | alias[#] ] [<name>] )  |
 *                  ( dos[#] [<server> <shortname> [<password>] ) ]  [,<options>]
 *
 *      The optional network password must be separated from the network name
 *      by some space (it may not contain space, TAB or comma).
 */
BOOL
FParseSz(
    char *sz
    )
{
    char szT[cchArgMax];

    sz = SzGetPrnName(sz, szT); // Get first 'word', remove colon
    if (strcmpx(szT, szPName)) {
        // first word is not the printer name the user requested
        return (FALSE);
    }

    if (*sz != ',') {
        sz = SzGetSzSz(sz, szT); // Get next 'word'

        if (szT[strlen(szT)-1] == ':') {
            // Possible physical 'port'
            SzGetPrnName (szT, szPName);
            sz = SzGetSzSz(sz, szT);
        }

        if (*szT)
            strcpy(szNet, szT);     // Network redirection name

        if (*sz != ',') {
            sz= SzGetSzSz(sz, szT);
            if (*szT)
                strcpy(szPass, szT); // Network Password
        }
    }

    /* We are setting printer info, display it if we were asked to */
    if (fVerify) {
        fprintf (stdout, "Local printer name : %s\n", szPName);
        fprintf (stdout, "Options specified  : %s\n", sz);
        fprintf (stdout, "Remote printer name: %s\n", szNet);
    }

    DoOptSz(sz); // Now read any options that followed
    return (TRUE);
}



void
SetupPrinter()
/* determine printer name and options */
{
    char rgbSW[cchArgMax];
    char szEName[cchArgMax];                /* name of printer in $PRINTER*/
    char *szT;
    FILE *pfile;
    BOOL fNoDest = TRUE;

    /* determine name of printer in $PRINTER (if one) */
    szEName[0] = '\0';
    if ((szT=getenvOem("PRINTER")) != NULL) {
        if (fVerify) {
            fprintf (stdout, "Using 'PRINTER' environment string:\n");
        }
        fNoDest = FALSE;
        SzGetPrnName(szT, szEName);
    }

    /* determine actual printer name to use; one of -p, $PRINTER, default */
    if (szPDesc != NULL) {
        fNoDest = FALSE;
        SzGetPrnName(szPDesc, szPName);
    } else {
        if (*szEName) {
            strcpy(szPName, szEName);
        } else {
            strcpy(szPName, PRINTER);
        }
    }

    /* if printer to use is the same as the one in $PRINTER, set up the
       options from $PRINTER (options from szPDesc below).
    */
    if (strcmpx(szPName, szEName) == 0) {
        if (szT)
            FParseSz(szT);
    } else {
        /* search parameter file */
        if ((pfile = swopen("$INIT:Tools.INI", "ppr")) != NULL) {
            /* 'PPR' tag found in '$INIT:TOOLS.INI' */
            while (swread(rgbSW, cchArgMax, pfile) != 0) {
                /* a switch line was read... */
                fNoDest = FALSE;
                szT = rgbSW + strspn(rgbSW, " \t"); // skip spaces, tabs

                /* a line "default=<printer>" sets szPName **
                ** if there is no environment setting      **
                ** and no command line parameter -p        */
                if (_strnicmp(szT, DEFAULT, strlen(DEFAULT))==0 &&
                    szPDesc==NULL && *szEName == 0)
                {
                    if ((szT = strchr(szT,'=')) != NULL) {
                        SzGetSzSz(szT+1, szPName);
                        FParseSz(szT+1);
                    } else {
                        fprintf(stderr, "ppr: warning: "
                            "default setting in setup file incomplete\n");
                    }
                } else {
                    if (FParseSz(szT)) {
                        break;
                    }
                }
            }
            swclose(pfile);
        }
    }

    /* command line printer description overrides other settings */
    if (szPDesc != NULL)
        FParseSz(szPDesc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ppr\lpr.h ===
/*=========================================================================
 *
 * LPR.H : Master Header file for PPR
 *
 *-------------------------------------------------------------------------
 *
 * Possible defines (differences mostly in network connections):
 *
 *       DOS - DOS 3.x
 *       OS2 - OS/2
 *       X86 - 286 Xenix
 *       (default) - SUN Xenix
 *
 *  Normal combinations:
 *
 *       if DOS || OS2 || X86
 *               non-68k
 *       else
 *               68k
 *       endif
 *
 *       if DOS || OS2
 *               non-Xenix
 *       else
 *               Xenix
 *       endif
 *
 * Currenently active code, is only being compiled for DOS and OS/2.
 * Support for other platforms is untested.
 *
 **************************************************************************/

#define VERSION  "2.3a"     // Current Version number of PPR
#define ANALYST  "RobertH"  // Current responsible (sic.) programmer




#define COMPANY  "Microsoft"
#define CONFIDENTIAL "CONFIDENTIAL"


#define cchArgMax  128

#define cchLineMax 256

#  define PRINTER  "lpt1"
#  define strnxcmp _strnicmp
#  define strcmpx  _strcmpi
#  define SILENT   " >NUL"
#  define szROBin "rb"
#  define szWOBin "wb"

#define DEFAULT       "default"
#define OPTS          "opts"
#define RESETPRINTER  "\033E"

/* [01]o - landscape/portrait (0 - portrait)
   #D - lines per inch (8 or 6)
   #C - vertical motion index (# 1/48in)
   0p - fixed pitch
   #h - pitch
   #v point size
   #t - type face (0 - line printer; 3 - courier)

   These sequences assume that the printer has been reset once before hand.
*/

#define BEGINBANNER             "\033&l1o6D\033(8U\033(s0p10h12v3T"
#define BEGINPORTRAIT           "\033&l0o7.7C\033(8U\033(s0p10h12v3T"
#define SELECTFRONTPAGE         "\033&a1G"
#define SELECTNEXTPAGE          "\033&a0G"
#define BEGINDUPLEXVERT         "\033&l1S"
#define BEGINDUPLEXHOR          "\033&l2S"
#define BEGINSIMPLEX            "\033&l0S"

#define MOVETOTOP       "\033&a1R"

#define rowLJMax 62                     /* lines per page on laser jet        */
#define colLJMax 175                    /* columns per page on laser jet      */
#define colLJPortMax 80                 /* columns per page in portrait mode  */
#define rowLJBanMax 50                  /* rows on banner page                */
#define colLJBanMax 105                 /* columns on banner page             */

#define rowLPMax 66                     /* lines per page on line printer     */
#define colLPMax 132                    /* columns per page on line printer   */

#define rowPSMax 62                     /* lines per page on laserwriter      */
#define colPSMax 170                    /* columns per page on laserwriter    */
#define colPSPortMax 85                 /* columns per page in portrait mode  */
#define rowPSBanMax 48                  /* rows on banner page                */
#define colPSBanMax 115                 /* columns on banner page             */

/*      Note: The following must be at least the maximum
 *      of all the possible printer values.  */
#define rowMax  100                     /* number of lines in page image      */
#define colMax  200                     /* number of columns in page image    */

#define cchLNMax  6                     /* number of columns for line number  */
#define LINUMFORMAT "%5d "              /* format to print line number in     */

#define colGutDef  5                    /* default column of gutter           */

#define HT      ((char) 9)
#define LF      ((char) 10)
#define FF      ((char) 12)
#define CR      ((char) 13)
#define BS      ((char) '\b')

// supported Laserjet symbol sets - used by aszSymSet

#define BEGINLANDUSASCII        0x0000
#define BEGINLANDROMAN8         0x0001
#define BEGINLANDIBMPC          0x0002  // Not available on early models ?

#if !defined (ERROR_ALREADY_ASSIGNED)
#define ERROR_ALREADY_ASSIGNED 85
#endif

/* return index of beginning col of column icol for columns col wide */
#define ColBeginIcol(iCol,col)  ((fBorder ? 1 : 0) + (iCol)*(col+1) )

extern int  colTab;                     /* expand tabs every colTab columns   */
extern long lcbOutLPR;
extern char szPName[];
extern char szNet[];
extern char szPass[];
extern char *szPDesc;
extern int cCol;
extern int cCopies;
extern int colGutter;
extern int colText;
extern int colWidth;
extern int colMac;
extern int rowMac;
extern int rowPage;
extern USHORT usSymSet;
extern char *aszSymSet[];
extern char page[rowMax][colMax+1];
extern BOOL fNumber;
extern BOOL fDelete;
extern BOOL fRaw;
extern BOOL fBorder;
extern BOOL fLabel;
extern BOOL fLaser;
extern BOOL fPostScript;

extern BOOL fPSF;
extern char szPSF[];
extern BOOL fPCondensed;

extern BOOL fConfidential;
extern BOOL fVDuplex;
extern BOOL fHDuplex;
extern BOOL fSilent;
extern int  cBanner;
extern char chBanner;
extern char *szBanner;
extern char *szStamp;
extern BOOL fForceFF;
extern BOOL fPortrait;
extern BOOL fFirstFile;


/* VARARGS */
void __cdecl Fatal(char *,...);
void __cdecl Error(char *,...);
void PrinterDoOptSz(char *);
char * SzGetSzSz(char *, char *);


/* from lpfile.c */


BOOL FRootPath(char *, char *);
char* __cdecl fgetl(char *, int, FILE *);
FILE * PfileOpen(char *, char *);
char *SzFindPath(char *, char *, char *);

/* from lplow.c*/

void SetupRedir(void);
void ResetRedir(void);
BOOL QueryUserName(char *);



int EndRedir(char *);
int SetPrnRedir(char *, char *);



/* from lpprint.c */

void OutLPR(char *, int);
void OutLPRPS(char *, int);
void OutLPRPS7(char *, int);
BOOL FKeyword(char *);
void InitPrinter(void);
void MyOpenPrinter(void);
void FlushPrinter(void);
void MyClosePrinter(void);
char *SzGetSzSz(char *, char *);
char *SzGetPrnName(char *, char *);
BOOL FParseSz(char *);
void SetupPrinter(void);


/* from lppage.c  */

void BannerSz(char *, int);
void SzDateSzTime(char *, char *) ;
void FlushPage(void);
void InitPage(void);
void RestoreTopRow(void);
void PlaceTop(char *, int, int, int);
void PlaceNumber(int);
void LabelPage(void);
BOOL FilenamX(char *, char *);
void AdvancePage(void);
void XoutNonPrintSz(char * );
void LineOut(char *, BOOL);
void RawOut(char *, int);
int FileOut(char *);



/* from lpr.c  */


void Abort(void);
char * SzGetArg(char ** , int *, char **[] );
int WGetArg(char **, int *, char **[] , int, char *);
void DoOptSz(char * );
void DoIniOptions();

/* from pspage.c */

void block_flush(char [], int, int);
void VertLine(char, int, int, int);
void HorzLine(char, int, int, int);
void FillRectangle(char, int, int, int, int);
void WriteSzCoord(char *, int, int);
void OutCmpLJ(char * ,int );
void OutEncPS(char *, int);
void OutCmpPS(char *,int );
int CchNoTrail(char [],int);
void OutRectangle(int, int, int, int);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\library\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

procconlibmsg.h procconlibmsg.rc msg00001.bin: procconlibmsg.mc
    mc -v -c procconlibmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\clitool\clitool.cpp ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998, 1999 Sequent Computer Systems, Incorporated.  All rights reserved. //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|   Windows 2000 Process Control command line utility                                   //
|                                                                                       //
|Created:                                                                               //
|                                                                                       //
|   Jarl McDonald 07-98                                                                 //
|                                                                                       //
|Revision History:                                                                      //
|                                                                                       //
|   Jarl McDonald Spring, 1999  Completed version 1.0 changes                           //
|                                                                                       //
|=======================================================================================*/
#include <windows.h>
#include <stdio.h>
#include <stddef.h>
#include <tchar.h>
#include <shellapi.h>
#include "resource.h"

#include "..\Library\ProcConAPI.h"

//=======================================================================================
// Macros...
//=======================================================================================
#define ENTRY_COUNT(x) (int)((sizeof(x) / sizeof(x[0])))
#define SPACE  TEXT(' ')

//=======================================================================================
// enums, typedefs, etc....
//=======================================================================================
enum _HELP_FLAGS {
   HELP_LIST  = 0x01,
   HELP_MGMT  = 0x02, 
   HELP_ALIAS = 0x04, 
} HELP_FLAGS;

typedef enum _switches {             // Do not localize these...
   COMPUTER_NAME  = TEXT('c'),
   BUFFER_SIZE    = TEXT('b'),
   INTERACTIVE    = TEXT('i'),
   FILE_INPUT     = TEXT('f'),
   ADMIN_DUMPREST = TEXT('x'),
   OP_ADD         = TEXT('a'),
   OP_REP         = TEXT('r'),
   OP_DEL         = TEXT('d'),
   OP_SWAP        = TEXT('s'),
   OP_LIST        = TEXT('l'),
   OP_UPDATE      = TEXT('u'),
   OP_COMMENT     = TEXT('*'),
   OP_KILL        = TEXT('k'),
   OP_HELP        = TEXT('?'),
   OP_HELP2       = TEXT('h'),
   DATA_GROUP     = TEXT('g'),
   DATA_PROC      = TEXT('p'),
   DATA_NAME      = TEXT('n'),
   DATA_DUMPREST  = TEXT(';'),
   DATA_SERVICE   = TEXT('v'),
   DATA_MEDIATOR  = TEXT('m'),
   SUB_DEFS       = TEXT('d'),
   SUB_SUMMARY    = TEXT('s'),
   SUB_LIST       = TEXT('l'),
   SUB_FULLNAMES  = TEXT('f'),
   SUB_RUNNING    = TEXT('r'),
   SUB_ONLY       = TEXT('o'),
};

typedef enum _defSwitches {         // Do not localize these...
   DEF_FLAGS         = TEXT('f'),
   DEF_PRIO          = TEXT('p'),
   DEF_AFF           = TEXT('a'),
   DEF_WS            = TEXT('w'),
   DEF_SCHED         = TEXT('s'),
   DEF_DESC          = TEXT('d'),
   DEF_PROCTIME      = TEXT('t'),
   DEF_GROUPTIME     = TEXT('u'),
   DEF_GROUPMEM      = TEXT('n'),
   DEF_PROCMEM       = TEXT('m'),
   DEF_PROCCOUNT     = TEXT('c'),
   DEF_BRKAWAY       = TEXT('b'),
   DEF_SILENTBRKAWAY = TEXT('q'),
   DEF_DIEONUHEX     = TEXT('x'),
   DEF_CLOSEONEMPTY  = TEXT('y'),
   DEF_MSGONGRPTIME  = TEXT('z'),
   DEF_GROUP         = TEXT('g'),
   DEF_VARDATA       = TEXT('v'),
   DEF_PROF          = TEXT('r'),
};

typedef enum _groupListSwitches {   // Do not localize these...
   GL_ALL            = TEXT('a'),
   GL_BASE           = TEXT('b'),
   GL_IO             = TEXT('i'),
   GL_MEMORY         = TEXT('m'),
   GL_PROCESS        = TEXT('p'),
   GL_TIME           = TEXT('t'),
};

typedef enum _colJustify { 
   PCCOL_JUST_CENTER = 1,
   PCCOL_JUST_LEFT,
   PCCOL_JUST_RIGHT
};

typedef struct _PCTableDef {
   PCULONG32 longStringID,   shortStringID;
   PCULONG32 longMinLen,     shortMinLen;
   PCULONG32 justification;
   TCHAR     rowFmt[32];
} PCTableDef;

//=======================================================================================
// Global data...
//=======================================================================================
static TCHAR SUB_DefSummaryList[] = { SUB_DEFS, SUB_SUMMARY, SUB_LIST, 0 };  
static int   pCode[]              = { PCPrioIdle, PCPrioIdle, PCPrioNormal, PCPrioHigh, 
                                      PCPrioRealTime, PCPrioAboveNormal, PCPrioBelowNormal };

// L ("Low") is a synonym for idle prio class.  Do not localize these...
static TCHAR pNames[]             = TEXT("LINHRAB");  

   TCHAR  oldTarget[MAX_PATH] = TEXT("\0");
   TCHAR  target[MAX_PATH]    = TEXT(".");
   PCid   targId              = 0;

   PCINT32  oldBuffer         = 0;
   PCINT32  buffer            = 64500;
   BOOL     convertError      = FALSE;
   BOOL     interact          = FALSE;

   FILE  *inFile              = NULL;
   TCHAR  inFileName[MAX_PATH];

   FILE  *adminFile           = NULL;
   TCHAR  adminFileName[MAX_PATH];

   PCNameRule   nameRules[PC_MAX_BUF_SIZE / sizeof(PCNameRule)];
   PCSystemInfo sysInfo;

   HMODULE moduleUs = GetModuleHandle( NULL );
   TCHAR   cmdPrompt[32];

   BOOL gListShowBase, gListShowIO, gListShowMem, gListShowProc, gListShowTime, gShowFmtProcTime, gShowFullNames; 

   PCULONG32 colWidth[32], colOffset[32], tableWidth;
   TCHAR colHead[2048];
   TCHAR colDash[2048];
   TCHAR rowData[2048];
   TCHAR sepChar = 0;

//=======================================================================================
// function prototypes....
//=======================================================================================
static int    GetNextCommand   ( FILE *readMe, TCHAR **list );
static int    DoCommands       ( int argct, TCHAR **argList );
static int    DoDumpRestore    ( FILE *adminFile, BOOL dump );
static int    cFileError       ( BOOL dump );
static void   DispDumpComment  ( FILE *adminFile, PCULONG32 msgID, PCINT32 count = 0 );
static void   DumpMgmtParms    ( MGMT_PARMS &mgt, PCINT16 len, TCHAR *data );
static void   DoMediatorControl( TCHAR **pArgs, PCUINT32 pArgCt );

static TCHAR *GetOpName        ( TCHAR code );
static TCHAR *GetDataName      ( TCHAR code, TCHAR subCode );
static TCHAR *GetDataSubName   ( TCHAR code );

static PC_MGMT_FLAGS GetMgtFlags( TCHAR *txt );
static void          PrintHelp  ( PCUINT32 flags, BOOL isGrp = TRUE, PCUINT32 msgId = 0 );
static void          PrintLine  ( TCHAR *data,    PCUINT32 nlCount );

static void ShowNameRules      ( PCNameRule     *rule,     PCINT32 count, PCINT32 index = 0 );
static void ShowGrpDetail      ( PCJobDetail    &grpDetail               );
static void ShowProcDetail     ( PCProcDetail   &procDetail              );
static void ShowGrpSummary     ( PCJobSummary   *list,     PCINT32 count, BOOL isFirst = TRUE, int totcnt = 0 );
static void ShowProcSummary    ( PCProcSummary  *list,     PCINT32 count, BOOL isFirst = TRUE, int totcnt = 0 );
static void ShowGrpList        ( PCJobListItem  *list,     PCINT32 count, BOOL isFirst = TRUE, int totcnt = 0 );
static void ShowProcList       ( PCProcListItem *list,     PCINT32 count, BOOL isFirst = TRUE, int totcnt = 0 );
static void ShowGrpListWithBase( PCJobListItem  *list,     PCINT32 count, BOOL isFirst );
static void ShowGrpListWithIo  ( PCJobListItem  *list,     PCINT32 count, BOOL isFirst );
static void ShowGrpListWithMem ( PCJobListItem  *list,     PCINT32 count, BOOL isFirst );
static void ShowGrpListWithProc( PCJobListItem  *list,     PCINT32 count, BOOL isFirst );
static void ShowGrpListWithTime( PCJobListItem  *list,     PCINT32 count, BOOL isFirst );
static void ShowMgmtParms      ( MGMT_PARMS     &parm,     BOOL    isGrp );
static void ShowMgmtParmsAsList( PCTableDef *table, PCULONG32 entries, PCULONG32 first, MGMT_PARMS &parm, BOOL isGrp );
static void ShowVariableData   ( short           len,      TCHAR *data   );
static void ShowListFlags      ( PC_LIST_FLAGS   flags,    TCHAR out[8]  );
static void ShowMgmtFlags      ( TCHAR           flags[16], PC_MGMT_FLAGS mFlags, BOOL compact = FALSE );
static void ShowSysInfo        ( PCSystemInfo  &sysInfo, BOOL versionOnly = TRUE );
static void ShowSysParms       ( PCSystemParms &sysParms );

static int  ShowHelp           ( TCHAR **pArgs, PCUINT32 pArgCt );
static void ShowCLIHelp        ( void );
static void ShowDetailHelp     ( TCHAR **pArgs, PCUINT32 pArgCt );

static void BuildSystemParms   ( PCSystemParms  &newParms,    TCHAR **pArgs, PCUINT32 pArgCt );
static void BuildNameRule      ( PCNameRule     &newRule,     TCHAR **pArgs, PCUINT32 pArgCt );
static void BuildGrpDetail     ( PCJobDetail    &newDetail,   TCHAR **pArgs, PCUINT32 pArgCt );
static void BuildProcDetail    ( PCProcDetail   &newDetail,   TCHAR **pArgs, PCUINT32 pArgCt );
static void BuildGrpSummary    ( PCJobSummary   &newSummary,  TCHAR **pArgs, PCUINT32 pArgCt, PCUINT32 *listFlags );
static void BuildProcSummary   ( PCProcSummary  &newSummary,  TCHAR **pArgs, PCUINT32 pArgCt, PCUINT32 *listFlags );
static void BuildGrpListItem   ( PCJobListItem  &newListItem, TCHAR **pArgs, PCUINT32 pArgCt, PCUINT32 *listFlags );
static void BuildProcListItem  ( PCProcListItem &newListItem, TCHAR **pArgs, PCUINT32 pArgCt, PCUINT32 *listFlags );
static void BuildMgmtParms     ( MGMT_PARMS     &parm,        TCHAR **pArgs, PCUINT32 pArgCt, 
                                 JOB_NAME       grpHere = NULL, PCINT16 *len = NULL, TCHAR *var = NULL );

static void BuildTableHeader   ( PCTableDef    *table, PCULONG32 entries, BOOL   printIt = TRUE );
static void InsertTableData    ( PCTableDef    *table, PCULONG32 index,   TCHAR *dataItem, BOOL printIt );

static void MergeGroupDetail   ( PCJobDetail  &newDet, PCJobDetail  &oldDet );
static void MergeProcDetail    ( PCProcDetail &newDet, PCProcDetail &oldDet );

//=======================================================================================
// Simple functions....
//=======================================================================================
#define TOOLMSG_ERR_BUFF_SIZE 4096
static LPTSTR GetErrorText( PCUINT32 error, LPTSTR buf, PCUINT32 size )
{
   static TCHAR *errBuf; 
   PCUINT32 dwRet = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE + FORMAT_MESSAGE_FROM_SYSTEM + 
                                   FORMAT_MESSAGE_IGNORE_INSERTS + FORMAT_MESSAGE_ALLOCATE_BUFFER, 
                                   NULL, error, 0, (TCHAR *) &errBuf, 0, NULL );

   if ( !dwRet )
      _sntprintf( buf, size, TEXT("No message text for error 0x%lx, format error 0x%lx"), error, GetLastError());
   else {
      _tcsncpy( buf, errBuf, size );
      LocalFree( errBuf );
      while ( --dwRet && (buf[dwRet] == TEXT('\n') || buf[dwRet] == TEXT('\r') || buf[dwRet] == TEXT('.')) ) 
      buf[dwRet] = TEXT('\0');
   }

   return buf;
}

static int  ToolMsg( PCUINT32 msgId, VOID *arg1 = NULL, PCINT32 err = ERROR_SUCCESS,
                     VOID *arg2 = NULL, VOID *arg3 = NULL, VOID *arg4 = NULL,
                     VOID *arg5 = NULL, VOID *arg6 = NULL, VOID *arg7 = NULL,
                     VOID *arg8 = NULL, VOID *arg9 = NULL, VOID *arg10 = NULL,
                     VOID *arg11 = NULL ) {
   PCUINT32 nlCt = err == ERROR_SUCCESS? 1 : 0;
   TCHAR *mBuf;
   TCHAR eBuf[TOOLMSG_ERR_BUFF_SIZE], errBuf[TOOLMSG_ERR_BUFF_SIZE];
   char *ptrs[16];
   ptrs[0]  = (char *) arg1;
   ptrs[1]  = (char *) arg2;
   ptrs[2]  = (char *) arg3;
   ptrs[3]  = (char *) arg4;
   ptrs[4]  = (char *) arg5;
   ptrs[5]  = (char *) arg6;
   ptrs[6]  = (char *) arg7;
   ptrs[7]  = (char *) arg8;
   ptrs[8]  = (char *) arg9;
   ptrs[9]  = (char *) arg10;
   ptrs[10] = (char *) arg11;
   PCUINT32 dwRet = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE + FORMAT_MESSAGE_ARGUMENT_ARRAY + 
                                   FORMAT_MESSAGE_ALLOCATE_BUFFER, 
                                   NULL, msgId, 0, (TCHAR *) &mBuf, 0, ptrs );
   if ( !dwRet ) {
      PCUINT32 msgErr = GetLastError();
      _stprintf( eBuf, TEXT("Message 0x%lx not found, message error is: %s."), 
                msgId, GetErrorText( msgErr, errBuf, TOOLMSG_ERR_BUFF_SIZE ));
      PrintLine( eBuf, nlCt );
   }
   else {
      while ( --dwRet && (mBuf[dwRet] == TEXT('\n') || mBuf[dwRet] == TEXT('\r')) ) 
         mBuf[dwRet] = TEXT('\0');
      if ( err != ERROR_SUCCESS && dwRet && mBuf[dwRet] == TEXT('.') )
         mBuf[dwRet] = TEXT('\0');
      PrintLine( mBuf, nlCt );
      LocalFree( mBuf );
   }

   if ( err != ERROR_SUCCESS ) {
      _stprintf( eBuf, TEXT(": %s (0x%lx)."), GetErrorText( err, errBuf, TOOLMSG_ERR_BUFF_SIZE ), err );
      PrintLine( eBuf, 1 );
   }

   return err != ERROR_SUCCESS? err : ERROR_INVALID_PARAMETER;
}

static int  ToolMsg( PCUINT32 msgId, int arg1 ) {
   return ToolMsg( msgId, IntToPtr(arg1) );
}

static unsigned __int64 GetValue( TCHAR *data, unsigned __int64 limitValue ) {
   BOOL hex = *data == TEXT('0') && _totlower(*(data + 1)) == TEXT('x');
   if ( hex ) data += 2;
   unsigned __int64 factor, result = 0, mult = 1;
   ULONG digitMult = hex? 16 : 10;

   for ( __int64 len = (__int64) _tcslen( data ) - 1; len >= 0; --len ) {
      TCHAR c = _totlower( *(data + len) );
      if ( hex && (c >= TEXT('a') && c <= TEXT('f')) )
         factor = mult * (c - TEXT('a') + 10);
      else if ( c >= TEXT('0') && c <= TEXT('9') ) 
         factor = mult * (c - TEXT('0'));
      else {
         ToolMsg( hex? PCCLIMSG_INVALID_HEX_DIGIT : PCCLIMSG_INVALID_DEC_DIGIT, data + len );
         convertError = TRUE;
         continue;
         }

      if ( limitValue - result < factor ) {
         ToolMsg( PCCLIMSG_NUM_TOO_LARGE, data );
         convertError = TRUE;
         return limitValue;
      }
      else {
         result += factor;
         mult   *= digitMult;
      }
   }

   return result;
}

static int GetInteger( TCHAR *data ) {
   return (int) GetValue( data, 0x000000007fffffff );
}

static __int64 GetInteger64( TCHAR *data ) {
   return (__int64) GetValue( data, 0x7fffffffffffffff );
}

static unsigned __int64 GetUInteger64( TCHAR *data ) {
   return GetValue( data, 0xffffffffffffffff );
}

static int GetPriority( TCHAR *data ) {
   TCHAR *c = _tcschr( pNames, _totupper( *data ) );
   if ( c ) return pCode[ c - pNames ];
   else return 0;
}

static TCHAR ShowPriority( int data ) {
   for ( int i = 0; i < ENTRY_COUNT(pCode); ++i )
      if ( data == pCode[i] ) return pNames[i];
   return TEXT(' ');
}

static BOOL IsSwitch( TCHAR c ) {
   return c == TEXT('-') || c == TEXT('/'); 
}

//=======================================================================================
// Main...
//=======================================================================================
int _cdecl main( void ) {

   int argct, retCode = 0;

   BOOL haveCmd = TRUE, firstPass = TRUE;
   for ( TCHAR *cmdLine = GetCommandLineW(); haveCmd; haveCmd = GetNextCommand( inFile, &cmdLine ) ) {
      TCHAR **argList = CommandLineToArgvW( cmdLine, &argct );
      if (argList) {
          if ( firstPass || !**argList ) retCode = DoCommands( argct - 1, argList + 1 );
          else                           retCode = DoCommands( argct, argList );
          GlobalFree( argList );
      }
      firstPass = FALSE;
   }
   if ( targId ) PCClose( targId );
   if ( inFile ) fclose( inFile );

   return retCode;
}

//=======================================================================================
// Processing functions...
//=======================================================================================
int GetNextCommand( FILE *readMe, TCHAR **cmd ) {
   static TCHAR cmdLine[1024];
   char cmdBuf[1024];
   TCHAR *p = NULL;
   if ( interact ) {
      PrintLine( cmdPrompt, 0 );
      if ( gets( cmdBuf ) ) {
         OemToChar( cmdBuf, cmdLine );
         p = *cmdLine? cmdLine : NULL;
      }
   }
   else if ( readMe ) {
      for ( ;; ) {
         p = _fgetts( cmdLine, ENTRY_COUNT(cmdLine), readMe ); 
         if ( !p ) break;
         // MS RAID: #375579 - last character dropped when reading from file
         size_t l = _tcscspn(p,TEXT("\r\n"));
         *(p + l) = 0;
         if ( *p ) break;
      }
   }

   *cmd = p;
   return p != NULL;
}

int DoCommands( int argct, TCHAR **argList ) {

   PCINT32    numRules, updateCtr;

   TCHAR      opCode     = OP_LIST;
   TCHAR      dataObj    = 0;
   TCHAR      dataSubObj = 0;
   PCINT32    index      = 0;
   
   TCHAR    **pArgs      = NULL;
   PCUINT32   pArgCt     = 0;

   BOOL       restIsData = FALSE, getListData = FALSE, 
              doDump = FALSE, doRestore = FALSE;
   PCUINT32   listFlags = 0;
   TCHAR      sub;

   gShowFullNames = convertError = FALSE;

   // Process parameters until end of parameters...
   for ( int i = 0; i < argct; ++i ) {
      TCHAR *arg = *argList++;
      if ( *arg == 0xfeff || *arg == 0xfffe ) ++arg;    // ignore 'This is Unicode' prefix
      if ( !IsSwitch( *arg ) ) 
         return ToolMsg( PCCLIMSG_SWITCH_EXPECTED, arg );

      TCHAR swChar = *++arg;
      switch ( swChar ) {
      case COMPUTER_NAME:
         if ( *(arg + 1) ) return ToolMsg( PCCLIMSG_SWITCH_UNKNOWN, --arg );
         if ( ++i >= argct )
            return ToolMsg( PCCLIMSG_ARG_MISSING, --arg );
         _tcscpy( target, *argList++);
         break;
      case BUFFER_SIZE:
         if ( *(arg + 1) ) return ToolMsg( PCCLIMSG_SWITCH_UNKNOWN, --arg );
         if ( ++i >= argct )
            return ToolMsg( PCCLIMSG_ARG_MISSING, --arg );
         buffer = 1024 * GetInteger( *argList++ );
         if ( convertError )
            return ToolMsg( PCCLIMSG_BUF_SIZE, --arg, PCERROR_INVALID_PARAMETER );
         break;
      case INTERACTIVE:
         if ( *(arg + 1) ) return ToolMsg( PCCLIMSG_SWITCH_UNKNOWN, --arg );
         if ( inFile ) {
            fclose( inFile );
            ToolMsg( PCCLIMSG_CMD_FILE_CLOSED, inFileName );
         }
         if ( !LoadString( moduleUs, CLI_PROMPT, cmdPrompt, ENTRY_COUNT(cmdPrompt) ) )
            _tcscpy( cmdPrompt, TEXT(">: ") );
         inFile   = NULL;
         interact = TRUE;
         return 0;
         break;
      case FILE_INPUT:
         if ( *(arg + 1) ) return ToolMsg( PCCLIMSG_SWITCH_UNKNOWN, --arg );
         if ( ++i >= argct )
            return ToolMsg( PCCLIMSG_ARG_MISSING, --arg );
         if ( inFile ) {
            fclose( inFile );
            ToolMsg( PCCLIMSG_CMD_FILE_CLOSED, inFileName );
         }
         _tcscpy( inFileName, *argList++);
         inFile = _tfopen( inFileName, TEXT("rb") );
         if ( !inFile ) 
            return ToolMsg( PCCLIMSG_CMD_FILE_OPEN_FAIL, inFileName );
         else {
            char buf[1024];
            TCHAR *opType;
            int rdct = (int) fread( buf, sizeof(char), sizeof(buf), inFile );
            if ( IsTextUnicode( buf, rdct, NULL ) ) opType = TEXT("rb");
            else opType = TEXT("r");
            fclose( inFile );
            inFile = _tfopen( inFileName, opType );
            if ( !inFile ) 
               return ToolMsg( PCCLIMSG_CMD_FILE_OPEN_FAIL, inFileName );
         }
         ToolMsg( PCCLIMSG_CMD_FILE_OPEN_SUCCESS, inFileName );
         interact = FALSE;
         return 0;
         break;
      case ADMIN_DUMPREST:
         if      ( *(arg + 1) == TEXT('d') ) doDump    = TRUE;
         else if ( *(arg + 1) == TEXT('r') ) doRestore = TRUE;
         else return ToolMsg( PCCLIMSG_ADMIN_OP_UNKNOWN, --arg );

         if ( ++i >= argct )
            return ToolMsg( PCCLIMSG_ARG_MISSING, --arg );
         _tcscpy( adminFileName, *argList++);

         adminFile = _tfopen( adminFileName, doDump? TEXT("wb") : TEXT("rb") );
         if ( !adminFile ) 
            return ToolMsg( doDump? PCCLIMSG_DUMP_FILE_OPEN_FAIL : PCCLIMSG_REST_FILE_OPEN_FAIL, adminFileName );
         ToolMsg( doDump? PCCLIMSG_DUMP_FILE_OPEN_SUCCESS : PCCLIMSG_REST_FILE_OPEN_SUCCESS, adminFileName );
         restIsData = TRUE;
         dataObj = dataSubObj = DATA_DUMPREST;
         opCode  = doDump? TEXT(';') : TEXT(':');
         break;
      case OP_ADD:
      case OP_REP:
      case OP_DEL:
      case OP_SWAP:
      case OP_LIST:
      case OP_UPDATE:
      case OP_KILL: {
         for ( int i = 1; *(arg + i); ++i ) {
             if      ( *(arg + i) == SUB_LIST )      getListData    = TRUE;
             else if ( *(arg + i) == SUB_FULLNAMES ) gShowFullNames = TRUE;
             else return ToolMsg( PCCLIMSG_SWITCH_UNKNOWN, --arg );
         }
         if ( opCode != OP_LIST && opCode != swChar )
            return ToolMsg( PCCLIMSG_OPERATION_CONFLICT, --arg );
         opCode = swChar;
         break;
      }
      case OP_COMMENT:
         return 0;
         break;
      case OP_HELP:
      case OP_HELP2:
         if ( *(arg + 1) ) return ToolMsg( PCCLIMSG_SWITCH_UNKNOWN, --arg );
         opCode = OP_HELP;
         restIsData = TRUE;
         break;
      case DATA_GROUP:
         dataObj = swChar;
         sub = *(arg + 1);
         if ( !sub ) sub = SUB_LIST;
         else for ( int i = 2; *(arg + i); ++i ) {
            if      ( *(arg + i) == SUB_RUNNING   ) listFlags |= PC_LIST_ONLY_RUNNING;
            else if ( *(arg + i) == SUB_ONLY      ) listFlags |= PC_LIST_MATCH_ONLY;
            else if ( *(arg + i) == SUB_FULLNAMES ) gShowFullNames = TRUE;
            else return ToolMsg( PCCLIMSG_SWITCH_SUFFIX_UNKNOWN, (void *) *(arg + i) );
         }
         if ( _tcschr( SUB_DefSummaryList, sub ) )
            dataSubObj = sub;
         else return ToolMsg( PCCLIMSG_SWITCH_UNKNOWN, --arg );

         restIsData = TRUE;
         break;
      case DATA_PROC:
         dataObj = swChar;
         sub = *(arg + 1);

         if ( !sub ) sub = SUB_LIST;
         else for ( int i = 2; *(arg + i); ++i ) {
            if      ( *(arg + i) == SUB_RUNNING   ) listFlags |= PC_LIST_ONLY_RUNNING;
            else if ( *(arg + i) == SUB_ONLY      ) listFlags |= PC_LIST_MATCH_ONLY;
            else if ( *(arg + i) == SUB_FULLNAMES ) gShowFullNames = TRUE;
            else return ToolMsg( PCCLIMSG_SWITCH_SUFFIX_UNKNOWN, (void *) *(arg + i) );
         }
         if ( _tcschr( SUB_DefSummaryList, sub ) )
            dataSubObj = sub;
         else return ToolMsg( PCCLIMSG_SWITCH_UNKNOWN, --arg );

         restIsData = TRUE;
         break;
      case DATA_NAME:
         dataObj = swChar;
         if ( ++i < argct ) {
            index = GetInteger( *argList++ );
            if ( convertError ) 
               return ToolMsg( PCCLIMSG_INVALID_ALIAS_INDEX, *--argList );
         }
         restIsData = TRUE;
         break;
      case DATA_SERVICE:
      case DATA_MEDIATOR:
         dataObj = swChar;
         restIsData = TRUE;
         break;
      default:
         return ToolMsg( PCCLIMSG_SWITCH_UNKNOWN, --arg );
         break;
      }  // end switch
      if ( restIsData ) {
         pArgs  = argList;
         pArgCt = (argct > i) ? argct - i - 1 : 0;
         break;
      }
   }

   //-------------------------------------------------------------------------------------------//
   // Short circuit remainder of processing if help requested...
   if ( opCode == OP_HELP )
      return ShowHelp( pArgs, pArgCt );

   //-------------------------------------------------------------------------------------------//
   // Perform correctness checks on supplied data...
   if ( !dataObj ) 
      return ToolMsg( PCCLIMSG_NO_OBJECT_NAME );
   if ( opCode == OP_SWAP && dataObj != DATA_NAME )
      return ToolMsg( PCCLIMSG_SWAP_NOT_ACCEPTABLE );
   if ( dataObj != DATA_NAME && dataSubObj == SUB_SUMMARY && opCode != OP_LIST )
      return ToolMsg( PCCLIMSG_SUMMARY_LIST_NOT_SPECIFIED, GetOpName(opCode) );
   if ( dataObj != DATA_NAME && dataSubObj == SUB_LIST && opCode != OP_LIST && opCode != OP_KILL )
      return ToolMsg( PCCLIMSG_LIST_LIST_NOT_SPECIFIED, GetOpName(opCode) );
   if ( dataObj == DATA_NAME && opCode == OP_UPDATE )
      return ToolMsg( PCCLIMSG_ALIAS_VERB_CONFLICT, GetOpName(opCode) );
   if ( dataObj == DATA_SERVICE && opCode != OP_LIST && opCode != OP_REP )
      return ToolMsg( PCCLIMSG_CONTROL_VERB_CONFLICT, GetOpName(opCode) );
   if ( dataObj == DATA_MEDIATOR && opCode != OP_LIST )
      return ToolMsg( PCCLIMSG_MEDIATOR_VERB_CONFLICT, GetOpName(opCode) );

   //-------------------------------------------------------------------------------------------//
   // Connect to the target and quit if fails, else give action description...
   if ( _tcscmp( target, oldTarget ) || buffer != oldBuffer ) {
      if ( *oldTarget ) PCClose( targId );
      ToolMsg( PCCLIMSG_CONNECTING, target, ERROR_SUCCESS, IntToPtr(buffer), IntToPtr(buffer) );
      targId = PCOpen( target, NULL, buffer );
      if ( !targId ) {
         *oldTarget = 0;
         oldBuffer  = 0;
         return ToolMsg( PCCLIMSG_CONNECT_FAILED, target, PCGetLastError( targId ) );
      }
      ToolMsg( PCCLIMSG_CONNECT_SUCCESS, target );
      _tcscpy( oldTarget, target );
      oldBuffer = buffer;
      if ( PCGetServiceInfo( targId, &sysInfo, sizeof(sysInfo) ) ) 
         ShowSysInfo( sysInfo );
      else
         ToolMsg( PCCLIMSG_SERVICE_QUERY_FAILED, target, PCGetLastError( targId ) );
   }

   if ( dataObj == DATA_NAME )
      ToolMsg( PCCLIMSG_PERFORMING_ALIAS_OP, GetOpName(opCode), ERROR_SUCCESS, 
               GetDataName(dataObj, dataSubObj), IntToPtr(index) );
   else if ( dataObj == DATA_MEDIATOR )
      ToolMsg( PCCLIMSG_PERFORMING_MEDIATOR_OP, pArgCt? *pArgs : TEXT("???") ); 
   else if ( dataObj != DATA_DUMPREST )
      ToolMsg( PCCLIMSG_PERFORMING_OTHER_OP, GetOpName(opCode), ERROR_SUCCESS, 
               GetDataName(dataObj, dataSubObj) );
   //-------------------------------------------------------------------------------------------//
   // Prepare and perform the requested action...
   BOOL rc;

   if ( !sepChar ) {
      TCHAR sepCharBuf[256];
      if ( !LoadString( moduleUs, COLHEAD_SEPARATOR_CHAR, sepCharBuf, ENTRY_COUNT(sepCharBuf) ) )
         sepChar = TEXT('-');
      else sepChar = sepCharBuf[0];
   }

   switch ( dataObj ) {
   case DATA_GROUP: {
      if ( dataSubObj == SUB_DEFS ) {
         PCJobSummary grpSummaryEntry;
         TCHAR  detail[2000], detail2[2000];       // space for detail with variable data too
         PCJobDetail *grpDetail = (PCJobDetail *) detail;
         grpDetail->vLength = sizeof(detail) - offsetof( PCJobDetail, vLength );
         BuildGrpDetail( *grpDetail, pArgs, pArgCt ); 
         if ( !convertError ) switch ( opCode ) {
         case OP_REP:
         case OP_UPDATE:
            memcpy( detail2, detail, sizeof (PCProcDetail) );
            if ( PCGetJobDetail(  targId, (PCJobDetail *) detail2, sizeof(detail2), &updateCtr ) ) {
               if ( opCode == OP_UPDATE ) MergeGroupDetail( *grpDetail, (PCJobDetail &) detail2 );
               rc = PCReplJobDetail( targId, grpDetail, updateCtr, getListData? &grpSummaryEntry : NULL );
               if ( rc && getListData ) ShowGrpSummary( &grpSummaryEntry, 1 );
            }
            break;

         case OP_ADD:
            rc = PCAddJobDetail( targId, grpDetail, getListData? &grpSummaryEntry : NULL );
            if ( rc && getListData ) ShowGrpSummary( &grpSummaryEntry, 1 );
            break;

         case OP_DEL:
            PCDeleteJobDetail( targId, grpDetail );
            break;

         case OP_LIST:
            grpDetail->vLength = sizeof(detail) - offsetof( PCJobDetail, vLength );
            if ( PCGetJobDetail( targId, grpDetail, sizeof(detail), &updateCtr ) )
               ShowGrpDetail( *grpDetail );
            break;

         }  // end switch op code within group data
         break;
      }
      else if ( dataSubObj == SUB_SUMMARY ) {
         PCUINT32 totCount = 0, entryCount = buffer / sizeof(PCJobSummary);
         PCJobSummary *grpSummary = new PCJobSummary[entryCount];
         if ( !grpSummary ) 
            return ToolMsg( PCCLIMSG_NOT_ENOUGH_MEMORY ); 
         BuildGrpSummary( *grpSummary, pArgs, pArgCt, &listFlags );
         if ( !convertError ) for ( BOOL moreData = TRUE, isFirst = TRUE; moreData; isFirst = FALSE ) {
            PCINT32 count = PCGetJobSummary( targId, grpSummary, entryCount * sizeof(PCJobSummary), listFlags );
            moreData = PCGetLastError( targId ) == PCERROR_MORE_DATA;
            totCount += count;
            if ( count >= 0 ) ShowGrpSummary( grpSummary, count, isFirst, moreData? -1 : totCount );
            if ( count > 0 ) _tcsncpy( grpSummary[0].jobName, grpSummary[count - 1].jobName, JOB_NAME_LEN );
         }
         delete [] grpSummary;
      }
      // Not an operation on definition or summary so is either kill or list...
      else {
         if ( opCode == OP_KILL ) {
            JOB_NAME groupName;
            memset( groupName, 0, sizeof(groupName) );
            if ( pArgCt ) _tcsncpy( groupName, *pArgs, JOB_NAME_LEN );
            PCKillJob( targId, groupName );
         }
         // Must be list...
         else {
            PCUINT32 totCount = 0, entryCount = buffer / sizeof(PCJobListItem);
            PCJobListItem *grpListItem = new PCJobListItem[entryCount];
            if ( !grpListItem ) 
               return ToolMsg( PCCLIMSG_NOT_ENOUGH_MEMORY ); 
            BuildGrpListItem( *grpListItem, pArgs, pArgCt, &listFlags );
            if ( !convertError ) for ( BOOL moreData = TRUE, isFirst = TRUE; moreData; isFirst = FALSE ) {
               PCINT32 count = PCGetJobList( targId, grpListItem, entryCount * sizeof(PCJobListItem), listFlags );
               moreData = PCGetLastError( targId ) == PCERROR_MORE_DATA;
               totCount += count;
               if ( count >= 0 ) ShowGrpList( grpListItem, count, isFirst, moreData? -1 : totCount );
               if ( count > 0 )  _tcsncpy( grpListItem[0].jobName, grpListItem[--count].jobName, JOB_NAME_LEN );
            }
            delete [] grpListItem;
         }
      }
      break;
   }

   //-------------------------------------------------------------------------------------------//
   case DATA_PROC: {
      if ( dataSubObj == SUB_DEFS ) {
         PCProcSummary procSummaryEntry;
         TCHAR  detail[2000], detail2[2000];       // space for detail with variable data too
         PCProcDetail *procDetail = (PCProcDetail *) detail;
         procDetail->vLength = sizeof(detail) - offsetof( PCProcDetail, vLength );
         BuildProcDetail( *procDetail, pArgs, pArgCt ); 
         if ( !convertError ) switch ( opCode ) {
         case OP_REP:
         case OP_UPDATE:
            memcpy( detail2, detail, sizeof (PCProcDetail) );
            if ( PCGetProcDetail(  targId, (PCProcDetail *) detail2, sizeof(detail2), &updateCtr ) ) {
               if ( opCode == OP_UPDATE ) MergeProcDetail( *procDetail, (PCProcDetail &) detail2 );
               BOOL rc = PCReplProcDetail( targId, procDetail, updateCtr, getListData? &procSummaryEntry : NULL );
               if ( rc && getListData )
                  ShowProcSummary( &procSummaryEntry, 1 );
            }
            break;

         case OP_ADD:
            if ( getListData )
               ShowProcSummary( &procSummaryEntry, PCAddProcDetail( targId, procDetail, &procSummaryEntry ) );
            else
               PCAddProcDetail( targId, procDetail );
            break;

         case OP_DEL:
            PCDeleteProcDetail( targId, procDetail );
            break;

         case OP_LIST:
            procDetail->vLength = sizeof(detail) - offsetof( PCProcDetail, vLength );
            if ( PCGetProcDetail( targId, procDetail, sizeof(detail), &updateCtr ) )
               ShowProcDetail( *procDetail );
            break;

         }  // end switch op code within proc data
         break;
      }
      else if ( dataSubObj == SUB_SUMMARY ) {
         PCUINT32 totCount = 0, entryCount = buffer / sizeof(PCProcSummary);
         PCProcSummary *procSummary = new PCProcSummary[entryCount];
         if ( !procSummary ) 
            return ToolMsg( PCCLIMSG_NOT_ENOUGH_MEMORY ); 
         BuildProcSummary( *procSummary, pArgs, pArgCt, &listFlags );
         if ( !convertError ) for ( BOOL moreData = TRUE, isFirst = TRUE; moreData; isFirst = FALSE ) {
            PCINT32 count = PCGetProcSummary( targId, procSummary, entryCount * sizeof(PCProcSummary), listFlags );
            moreData = PCGetLastError( targId ) == PCERROR_MORE_DATA;
            totCount += count;
            if ( count >= 0 ) ShowProcSummary( procSummary, count, isFirst, moreData? -1 : totCount );
            if ( count > 0 )  _tcsncpy( procSummary[0].procName, procSummary[--count].procName, PROC_NAME_LEN );
         }
         delete [] procSummary;
      }
      else {
         if ( opCode == OP_KILL ) {
            PID_VALUE  pid    = 0;
            TIME_VALUE create = 0x777deadfeeb1e777;
            if ( pArgCt > 0 ) pid    = GetUInteger64( *pArgs++ );
            if ( pArgCt > 1 ) create = GetInteger64( *pArgs );
            if ( !convertError )
               PCKillProcess( targId, pid, create );
         }
         else {
            PCUINT32 totCount = 0, entryCount = buffer / sizeof(PCProcListItem);
            PCProcListItem *procListItem = new PCProcListItem[entryCount];
            if ( !procListItem ) 
               return ToolMsg( PCCLIMSG_NOT_ENOUGH_MEMORY ); 
            BuildProcListItem( *procListItem, pArgs, pArgCt, &listFlags );
            if ( !convertError )  for ( BOOL moreData = TRUE, isFirst = TRUE; moreData; isFirst = FALSE ) {
               PCINT32 count = PCGetProcList( targId, procListItem, entryCount * sizeof(PCProcListItem), listFlags );
               moreData = PCGetLastError( targId ) == PCERROR_MORE_DATA;
               totCount += count;
               if ( count >= 0 ) ShowProcList( procListItem, count, isFirst, moreData? -1 : totCount );
               if ( count > 0 ) {
                  _tcsncpy( procListItem[0].procName, procListItem[--count].procName, PROC_NAME_LEN );
                  procListItem[0].procStats.pid = procListItem[count].procStats.pid;
               }
            }
            delete [] procListItem;
         }
      }
      break;
   }

   //-------------------------------------------------------------------------------------------//
   case DATA_NAME:
      // Prime update counter and get buffer full of names, then execute verb...
      numRules = PCGetNameRules( targId, nameRules, sizeof(nameRules), 
                                 opCode == OP_LIST? index : 0, &updateCtr );
      switch ( opCode ) {
      case OP_ADD:
      case OP_REP: {
         PCNameRule newRule;
         BuildNameRule( newRule, pArgs, pArgCt );
         if ( convertError ) break; 
         if ( getListData ) {
            numRules = (opCode == OP_ADD)? 
               PCAddNameRule( targId, &newRule, index, updateCtr, nameRules, sizeof(nameRules), 0 ) :
               PCReplNameRule( targId, &newRule, index, updateCtr, nameRules, sizeof(nameRules), 0 );
            ShowNameRules( nameRules, numRules );
         }
         else
            numRules = (opCode == OP_ADD)? 
               PCAddNameRule( targId, &newRule, index, updateCtr ) :
               PCReplNameRule( targId, &newRule, index, updateCtr );
         break;
      }

      case OP_DEL:
         if ( getListData ) {
            numRules = PCDeleteNameRule( targId, index, updateCtr, nameRules, sizeof(nameRules), 0 );
            ShowNameRules( nameRules, numRules );
         }
         else
            PCDeleteNameRule( targId, index, updateCtr );
         break;

      case OP_LIST:
         ShowNameRules( nameRules, numRules, index );
         break;

      case OP_SWAP:
         if ( getListData ) {
            numRules = PCSwapNameRules( targId, index, updateCtr, nameRules, sizeof(nameRules), 0 );
            ShowNameRules( nameRules, numRules );
         }
         else
            PCSwapNameRules( targId, index, updateCtr );
         break;
      }  // end switch op code for data names
      break;

   //-------------------------------------------------------------------------------------------//
   case DATA_SERVICE:
      switch ( opCode ) {
      case OP_REP:
         PCSystemParms sysParms;
         BuildSystemParms( sysParms, pArgs, pArgCt ); 
         if ( !convertError )
            PCSetServiceParms( targId, &sysParms, sizeof(sysInfo) ); 
         break;

      case OP_LIST:
         if ( PCGetServiceInfo( targId, &sysInfo, sizeof(sysInfo) ) ) 
            ShowSysInfo( sysInfo, FALSE );
         break;

      }  // end switch op code for data names
      break;
   //-------------------------------------------------------------------------------------------//
   case DATA_MEDIATOR:
      DoMediatorControl( pArgs, pArgCt ); 
      break;

   //-------------------------------------------------------------------------------------------//
   case DATA_DUMPREST:       // Perform complete dump or restore of data base
      int err = DoDumpRestore( adminFile, doDump );          // file already open
      fflush( adminFile );                                   // flush data
      if ( !err && ferror( adminFile ) ) 
         err = cFileError( doDump );                         // show stream was errored out
      fclose( adminFile );                                   // done with file
      if ( err ) {
         ToolMsg( PCCLIMSG_DUMP_RESTORE_FAILED );
         return err;
      }
      break;
   }  // end switch data obj

   PCINT32 err = convertError? PCERROR_INVALID_PARAMETER : PCGetLastError( targId );
   if ( err )
      ToolMsg( PCCLIMSG_REQUEST_FAILED, NULL, err );
   else
      ToolMsg( PCCLIMSG_REQUEST_SUCCESSFUL );

   return err;
}

//-------------------------------------------------------------------------------------------//
static void DoMediatorControl( TCHAR **pArgs, PCUINT32 pArgCt ) {

   PCINT32 ctlCmd = PCCFLAG_SIGNATURE;

   if ( pArgCt > 0 ) {
      if      ( !_tcsicmp( *pArgs, TEXT("stop")    ) ) ctlCmd |= PCCFLAG_STOP_MEDIATOR;   // do not localize
      else if ( !_tcsicmp( *pArgs, TEXT("start")   ) ) ctlCmd |= PCCFLAG_START_MEDIATOR;  // do not localize
      else if (  _tcsicmp( *pArgs, TEXT("restart") ) ) {                                  // do not localize
         ToolMsg( PCCLIMSG_MEDIATOR_ACTION_UNKNOWN, *pArgs );
         return;
      }
   }
   else {
      ToolMsg( PCCLIMSG_MEDIATOR_ACTION_MISSING );
      return;
   }

   if ( pArgCt > 1 ) 
      ToolMsg( PCCLIMSG_MEDIATOR_ACTION_IGNORED, *pArgs );
 
   if ( !_tcsicmp( *pArgs, TEXT("restart") ) ) {
      if ( !PCControlFunction( targId, ctlCmd | PCCFLAG_STOP_MEDIATOR ) )
         ToolMsg( PCCLIMSG_MEDIATOR_CONTROL_ERROR, NULL, PCGetLastError( targId ) );
      else {
         Sleep( 100 );
         if ( !PCControlFunction( targId, ctlCmd | PCCFLAG_START_MEDIATOR ) )
            ToolMsg( PCCLIMSG_MEDIATOR_CONTROL_ERROR, NULL, PCGetLastError( targId ) );
      }
   }

   else if ( !PCControlFunction( targId, ctlCmd ) )
      ToolMsg( PCCLIMSG_MEDIATOR_CONTROL_ERROR, NULL, PCGetLastError( targId ) );
}

//-------------------------------------------------------------------------------------------//
static void DispDumpComment( FILE *adminFile, PCULONG32 msgID, PCINT32 count ) {
   TCHAR *fileCmnt;
   if ( !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE + FORMAT_MESSAGE_ARGUMENT_ARRAY + 
                        FORMAT_MESSAGE_ALLOCATE_BUFFER, 
                        NULL, msgID, 0, (TCHAR *) &fileCmnt, 0, (char **) &count ) )
      _ftprintf( adminFile, TEXT("-%c <message formatting failed>...\n"), OP_COMMENT );
   else {
      _ftprintf( adminFile, TEXT("-%c%s"), OP_COMMENT, fileCmnt );
      LocalFree( fileCmnt );
   }
}

static int cFileError( BOOL dump ) {
   _tperror( dump? TEXT("dump file error") : TEXT("restore file error") );
   return PCCLIMSG_REQUEST_FAILED;
}

static int DoDumpRestore( FILE *adminFile, BOOL dump ) {
   PCNameRule    nameRules[100];
   PCProcSummary procRules[100];
   PCJobSummary  grpRules[100];
   char          detail[8192];           // detail buffer
   // Dump operation...
   if ( dump ) {

      // Dump process alias rules...
      DispDumpComment( adminFile, PCCLIMSG_DUMPCOMMENT_BEGIN_ALIASES );
      BOOL moreRules = TRUE;
      PCINT32 totalRules = 0;
      for ( PCINT32 index = 0, numRules; moreRules; index += numRules ) {
         numRules = PCGetNameRules( targId, nameRules, sizeof(nameRules), index );
         if ( numRules < 0 ) return PCGetLastError( targId );
         moreRules = PCGetLastError( targId ) == PCERROR_MORE_DATA;
         totalRules += numRules;
         for ( PCINT32 i = 0; i < (moreRules? numRules : numRules - 1); ++i ) {
            _ftprintf( adminFile, TEXT("   -%c -%c %ld %c \"%s\" \"%s\" \"%s\"\n"), 
                       OP_ADD, DATA_NAME, index + i, 
                       nameRules[i].matchType, nameRules[i].matchString, 
                       nameRules[i].procName, nameRules[i].description );
         }
      }
      DispDumpComment( adminFile, PCCLIMSG_DUMPCOMMENT_END_ALIASES, totalRules - 1 );
      if ( ferror( adminFile ) ) return cFileError( dump );   // see if stream was errored out

      // Dump group rules...
      DispDumpComment( adminFile, PCCLIMSG_DUMPCOMMENT_BEGIN_GROUPS );
      moreRules = TRUE;
      totalRules = 0;
      memset( grpRules, 0, sizeof(grpRules) );
      PCJobDetail *grpDet = (PCJobDetail *) detail;
      while ( moreRules ) {
         memcpy( &grpRules[0], &grpRules[ENTRY_COUNT(grpRules) - 1], sizeof(grpRules[0]) );
         numRules = PCGetJobSummary( targId, grpRules, sizeof(grpRules) );
         if ( numRules < 0 ) return PCGetLastError( targId );
         totalRules += numRules;
         moreRules = PCGetLastError( targId ) == PCERROR_MORE_DATA;
         for ( PCINT32 i = 0; i < numRules; ++i ) {
            memcpy( grpDet, &grpRules[i], sizeof(grpRules[i] ) );
            if ( PCGetJobDetail( targId, grpDet, sizeof(detail) ) ) {
               _ftprintf( adminFile, TEXT("   -%c -%c%c \"%s\""), 
                          OP_ADD, DATA_GROUP, SUB_DEFS, grpDet->base.jobName );
               DumpMgmtParms( grpDet->base.mgmtParms, grpDet->vLength, grpDet->vData );
            }
            else return PCGetLastError( targId );
         }
      }
      DispDumpComment( adminFile, PCCLIMSG_DUMPCOMMENT_END_GROUPS, totalRules );
      if ( ferror( adminFile ) ) return cFileError( dump );   // see if stream was errored out

      // Dump process rules...
      DispDumpComment( adminFile, PCCLIMSG_DUMPCOMMENT_BEGIN_PROCESSES );
      moreRules = TRUE;
      totalRules = 0;
      memset( procRules, 0, sizeof(procRules) );
      PCProcDetail *procDet = (PCProcDetail *) detail;
      while ( moreRules ) {
         memcpy( &procRules[0], &procRules[ENTRY_COUNT(procRules) - 1], sizeof(procRules[0]) );
         numRules = PCGetProcSummary( targId, procRules, sizeof(procRules) );
         if ( numRules < 0 ) return PCGetLastError( targId );
         totalRules += numRules;
         moreRules = PCGetLastError( targId ) == PCERROR_MORE_DATA;
         for ( PCINT32 i = 0; i < numRules; ++i ) {
            memcpy( procDet, &procRules[i], sizeof(procRules[i] ) );
            if ( PCGetProcDetail( targId, procDet, sizeof(detail) ) ) {
               _ftprintf( adminFile, TEXT("   -%c -%c%c \"%s\""), 
                          OP_ADD, DATA_PROC, SUB_DEFS, procDet->base.procName );
               if ( *procDet->base.memberOfJobName )
                  _ftprintf( adminFile, TEXT(" -%c \"%s\""), DATA_GROUP, procDet->base.memberOfJobName );
               DumpMgmtParms( procDet->base.mgmtParms, procDet->vLength, procDet->vData );
            }
            else return PCGetLastError( targId );
         }
      }
      DispDumpComment( adminFile, PCCLIMSG_DUMPCOMMENT_END_PROCESSES, totalRules );
      if ( ferror( adminFile ) ) return cFileError( dump );   // see if stream was errored out
   }
   else {
      int    argct;
      BOOL   haveCmd;
      TCHAR *cmdLine;
      PCINT32  ctlCmd = PCCFLAG_SIGNATURE +
                      PCCFLAG_DELALL_NAME_RULES + PCCFLAG_DELALL_PROC_DEFS + PCCFLAG_DELALL_JOB_DEFS;
                      
      if ( !PCControlFunction( targId, ctlCmd ) )
         return ToolMsg( PCCLIMSG_RESTORE_CLEAR_ERROR, NULL, PCGetLastError( targId ) );
      else {
         BOOL saveInteract = interact;
         interact = FALSE;
         int retCode;

         for ( haveCmd = GetNextCommand( adminFile, &cmdLine ); 
               haveCmd; 
               haveCmd = GetNextCommand( adminFile, &cmdLine ) ) {
            if ( ferror( adminFile ) ) return cFileError( dump );
            TCHAR **argList = CommandLineToArgvW( cmdLine, &argct );
            if ( !**argList ) retCode = DoCommands( argct - 1, argList + 1 );
            else              retCode = DoCommands( argct, argList );
            GlobalFree( argList );
         }
         interact = saveInteract;
      }
   }
   
   return ERROR_SUCCESS;
}

static void DumpMgmtParms( MGMT_PARMS &mgt, PCINT16 len, TCHAR *data ) {
   TCHAR flags[16];
   ShowMgmtFlags( flags, mgt.mFlags, TRUE );
   if ( *flags )                 
      _ftprintf( adminFile, TEXT(" -%c %s"),              DEF_FLAGS,     flags );
   if ( mgt.affinity )           
      _ftprintf( adminFile, TEXT(" -%c 0x%I64x"),         DEF_AFF,       mgt.affinity );
   if ( mgt.priority )           
      _ftprintf( adminFile, TEXT(" -%c %c"),              DEF_PRIO,      ShowPriority( mgt.priority ) );
   if ( mgt.minWS || mgt.maxWS ) 
      _ftprintf( adminFile, TEXT(" -%c %I64u %I64u"),     DEF_WS,        mgt.minWS / 1024, mgt.maxWS / 1024 );
   if ( mgt.schedClass )         
      _ftprintf( adminFile, TEXT(" -%c %lu"),             DEF_SCHED,     mgt.schedClass );
   if ( mgt.jobMemoryLimit )     
      _ftprintf( adminFile, TEXT(" -%c %I64u"),           DEF_GROUPMEM,  mgt.jobMemoryLimit / 1024 );
   if ( mgt.procMemoryLimit )    
      _ftprintf( adminFile, TEXT(" -%c %I64u"),           DEF_PROCMEM,   mgt.procMemoryLimit / 1024 );
   if ( mgt.jobTimeLimitCNS )    
      _ftprintf( adminFile, TEXT(" -%c %I64u"),           DEF_GROUPTIME, mgt.jobTimeLimitCNS / 10000 );
   if ( mgt.procTimeLimitCNS )   
      _ftprintf( adminFile, TEXT(" -%c %I64u"),           DEF_PROCTIME,  mgt.procTimeLimitCNS / 10000 );
   if ( mgt.procCountLimit )     
      _ftprintf( adminFile, TEXT(" -%c %lu"),             DEF_PROCCOUNT, mgt.procCountLimit );
   if ( *mgt.description )     
      _ftprintf( adminFile, TEXT(" -%c \"%s\""),          DEF_DESC,      mgt.description );
   if ( len ) 
      _ftprintf( adminFile, TEXT(" -%c \"%*s\""),         DEF_VARDATA,   len / sizeof(TCHAR) - 1, data );
   _ftprintf( adminFile, TEXT("\n") );
}

static void InsertTableData( PCTableDef *table, PCULONG32 index, TCHAR *dataItem, BOOL printIt ) {
   PCULONG32 leftSkip = 0, dataLen = min( _tcslen( dataItem ), colWidth[index] );
   switch ( table[index].justification ) {
      case PCCOL_JUST_RIGHT:  leftSkip = colWidth[index] - dataLen;       break;
      case PCCOL_JUST_LEFT:   leftSkip = 0;                               break;
      case PCCOL_JUST_CENTER: leftSkip = (colWidth[index] - dataLen) / 2; break;
   }
   _tcsncpy( rowData + colOffset[index] + leftSkip, dataItem, dataLen );

   if ( printIt ) {
      rowData[tableWidth] = 0;
      PrintLine( rowData, 1 );
   }
}

static void BuildTableHeader( PCTableDef *table, PCULONG32 entries, BOOL printIt ) {

   PCULONG32 leftSkip = 0, widthCol, widthHead, offset = 0;

   wmemset( colHead, SPACE, ENTRY_COUNT(colHead) );
   wmemset( colDash, SPACE, ENTRY_COUNT(colDash) );

   for ( PCULONG32 i = 0; i < entries; ++i ) {
      TCHAR head[512];
      if ( !LoadString( moduleUs, 
                        gShowFullNames? table[i].longStringID : table[i].shortStringID, 
                        head, ENTRY_COUNT(head) ) 
         )
         _tcscpy( head, TEXT("(load-fail)") );
      widthHead = (PCULONG32) _tcslen( head );
      widthCol  = max( widthHead, gShowFullNames? table[i].longMinLen : table[i].shortMinLen );
      switch ( table[i].justification ) {
      case PCCOL_JUST_RIGHT:  leftSkip = widthCol - widthHead;       break;
      case PCCOL_JUST_LEFT:   leftSkip = 0;                          break;
      case PCCOL_JUST_CENTER: leftSkip = (widthCol - widthHead) / 2; break;
      }
      _tcsncpy( colHead + offset + leftSkip, head,    widthHead );
      _tcsnset( colDash + offset,            sepChar, widthCol );
      colWidth[i]   = widthCol;
      colOffset[i]  = offset;
      offset       += widthCol + 1;
   }
 
   tableWidth = offset;
   colHead[tableWidth] = 0;
   colDash[tableWidth] = 0;
   if ( printIt ) {
      PrintLine( colHead, 1 );
      PrintLine( colDash, 1 );
   }
}

static void ShowNameRules( PCNameRule *rule, PCINT32 count, PCINT32 index ) {

   static PCTableDef aliasTable[] = {
      { COLHEAD_ALIAS_RULE_NUMBER,     COLHEAD_ALIAS_RULE_NUMBER,                          4,  4, PCCOL_JUST_RIGHT,  TEXT("%ld") },
      { COLHEAD_ALIAS_MATCH_TYPE,      COLHEAD_ALIAS_MATCH_TYPE,                          10, 10, PCCOL_JUST_CENTER, TEXT("%c") },
      { COLHEAD_ALIAS_MATCH_DATA_LONG, COLHEAD_ALIAS_MATCH_DATA_SHORT,      MATCH_STRING_LEN, 24, PCCOL_JUST_LEFT,   TEXT("%s") },
      { COLHEAD_ALIAS_NAME_LONG,       COLHEAD_ALIAS_NAME_SHORT,               PROC_NAME_LEN, 21, PCCOL_JUST_LEFT,   TEXT("%s") },
      { COLHEAD_ALIAS_DESCRIPTION_LONG,COLHEAD_ALIAS_DESCRIPTION_SHORT, NAME_DESCRIPTION_LEN, 55, PCCOL_JUST_LEFT,   TEXT("%s") }         
   };

   if ( count < 0 ) return;

   // Build and display table headers (and set global table parameters)...
   BuildTableHeader( aliasTable, ENTRY_COUNT(aliasTable) );

   // Build and display each data row...
   PCINT32 TotRules = 0;
   for ( ;; ) {
      TotRules += count;
      for ( PCINT32 i = 0; i < count; ++i, ++rule ) {
         wmemset( rowData, SPACE, ENTRY_COUNT(rowData) );

         // Insert each data item into row...
         for ( PCINT32 j = 0; j < ENTRY_COUNT(aliasTable); ++j ) {
            TCHAR dataItem[256];
            // Get formatted data...
            switch ( j ) {
               case 0: _stprintf( dataItem, aliasTable[j].rowFmt, index + i );         break;
               case 1: _stprintf( dataItem, aliasTable[j].rowFmt, rule->matchType );   break;
               case 2: _stprintf( dataItem, aliasTable[j].rowFmt, rule->matchString ); break;
               case 3: _stprintf( dataItem, aliasTable[j].rowFmt, rule->procName );    break;
               case 4: _stprintf( dataItem, aliasTable[j].rowFmt, rule->description ); break;
            }

            // Insert data into row, print if last item...
            InsertTableData( aliasTable, j, dataItem, j == ENTRY_COUNT(aliasTable) - 1 );
         }
      }
      if ( PCGetLastError( targId ) == PCERROR_MORE_DATA ) {
         index += count;
         rule  = nameRules;
         count = PCGetNameRules( targId, nameRules, sizeof(nameRules), index );
      }
      else break;
   } 

   // Display table suffix...
   PrintLine( colDash, 1 );
   PrintHelp( HELP_ALIAS, FALSE );

   // Show count of rules retrieved...
   ToolMsg( PCCLIMSG_RETRIEVED_ALIAS_RULES_LIST, TotRules );
}

static TCHAR *GetOpName( TCHAR code ) {
   static TCHAR result[128];
   static struct { TCHAR op; PCULONG32 strID; } opNames[] = {
      { OP_ADD,    VERB_NAME_ADD      },
      { OP_REP,    VERB_NAME_REPLACE  },
      { OP_DEL,    VERB_NAME_DELETE   },
      { OP_SWAP,   VERB_NAME_SWAP     },
      { OP_LIST,   VERB_NAME_LIST     },
      { OP_UPDATE, VERB_NAME_UPDATE   },
      { OP_KILL,   VERB_NAME_KILL     },
      { TEXT(';'), VERB_NAME_DUMP     },
      { TEXT(':'), VERB_NAME_RESTORE  },
   };
   for ( PCUINT32 i = 0; i < ENTRY_COUNT(opNames) && code != opNames[i].op; ++i ) ;

   if ( i >= ENTRY_COUNT(opNames) || !LoadString( moduleUs, opNames[i].strID, result, ENTRY_COUNT(result) ) )
      _tcscpy( result, TEXT("<err>") );
    
   return result;
}

static TCHAR *GetDataName( TCHAR code, TCHAR subCode ) {
   static TCHAR result[128];
   static struct { TCHAR op; PCULONG32 strID; } dNames[] = {
      { DATA_NAME,    DATA_NAME_ALIAS    },
      { DATA_GROUP,   DATA_NAME_GROUP    },
      { DATA_PROC,    DATA_NAME_PROCESS  },
      { DATA_SERVICE, DATA_NAME_VERSION  },
      { DATA_MEDIATOR,DATA_NAME_MEDIATOR },
      { TEXT(';'),    DATA_NAME_PROCCON  },
   };
   for ( PCUINT32 i = 0; i < ENTRY_COUNT(dNames) && code != dNames[i].op; ++i ) ;

   if ( i >= ENTRY_COUNT(dNames) || !LoadString( moduleUs, dNames[i].strID, result, ENTRY_COUNT(result) ) )
      _tcscpy( result, TEXT("<err>") );
   else {
      _tcscat( result, TEXT(" ") );
      _tcscat( result, GetDataSubName( subCode ) );
   }

   return result;
}

static TCHAR *GetDataSubName( TCHAR code ) {
   static TCHAR result[128];
   static struct { TCHAR op; PCULONG32 strID; } sNames[] = {
      { SUB_DEFS,    SUBDATA_NAME_DEFINITION   },
      { SUB_SUMMARY, SUBDATA_NAME_SUMMARY      },
      { SUB_LIST,    SUBDATA_NAME_LIST         },
      { TEXT(';'),   SUBDATA_NAME_PROCCON_DATA },
   };
   for ( PCUINT32 i = 0; i < ENTRY_COUNT(sNames) && code != sNames[i].op; ++i ) ;

   if ( i >= ENTRY_COUNT(sNames) )
      _tcscpy( result, TEXT("") );
   else if ( !LoadString( moduleUs, sNames[i].strID, result, ENTRY_COUNT(result) ) )
      _tcscpy( result, TEXT("<err>") );
    
   return result;
}

static void ShowListFlags( PC_LIST_FLAGS flags, TCHAR out[8] ) {
   for ( PCUINT32 i = 0; i < 6; ++i ) out[i] = TEXT('.');
   out[6] = 0;
   if ( flags & PCLFLAG_IS_RUNNING        ) out[0] = TEXT('R');
   if ( flags & PCLFLAG_IS_DEFINED        ) out[1] = TEXT('D');
   if ( flags & PCLFLAG_IS_MANAGED        ) out[2] = TEXT('M');
   if ( flags & PCLFLAG_HAS_NAME_RULE     ) out[3] = TEXT('N');
   if ( flags & PCLFLAG_HAS_MEMBER_OF_JOB ) out[4] = TEXT('G');
   if ( flags & PCLFLAG_IS_IN_A_JOB       ) out[5] = TEXT('I');
}

static void FormatTime( TCHAR *str, int strLen, TIME_VALUE time )
{
  SYSTEMTIME systime, localsystime;

  if ( FileTimeToSystemTime( (FILETIME *) &time, &systime ) &&
       SystemTimeToTzSpecificLocalTime( NULL, &systime, &localsystime ) ) {
     int len = GetDateFormat( LOCALE_USER_DEFAULT, 0, &localsystime, NULL, str, strLen - 1 );
     if ( len ) {
        str[len - 1 ] = SPACE;
        GetTimeFormat( LOCALE_USER_DEFAULT, 0, &localsystime, NULL, &str[len],  strLen - len - 1);
     }
  }
  else 
     str[0] = 0;
}

static void ShowProcList( PCProcListItem *list, PCINT32 count, BOOL isFirst, int totcnt ) {

   static PCTableDef procTable[] = {
      { COLHEAD_PROCLIST_FLAGS,               COLHEAD_PROCLIST_FLAGS,                              6,  6, PCCOL_JUST_LEFT,  TEXT("%s") },
      { COLHEAD_PROCLIST_PID,                 COLHEAD_PROCLIST_PID,                                5,  5, PCCOL_JUST_RIGHT, TEXT("%.0I64u") },
      { COLHEAD_PROCLIST_PROCESS_ALIAS_LONG,  COLHEAD_PROCLIST_PROCESS_ALIAS_SHORT,    PROC_NAME_LEN, 20, PCCOL_JUST_LEFT,  TEXT("%s") },
      { COLHEAD_PROCLIST_IMAGE_NAME_LONG,     COLHEAD_PROCLIST_IMAGE_NAME_SHORT,      IMAGE_NAME_LEN, 16, PCCOL_JUST_LEFT,  TEXT("%s") },
      { COLHEAD_PROCLIST_MEMBER_OF_GROUP_LONG,COLHEAD_PROCLIST_MEMBER_OF_GROUP_SHORT,   JOB_NAME_LEN, 16, PCCOL_JUST_LEFT,  TEXT("%s") },        
      { COLHEAD_PROCLIST_PRIORITY,            COLHEAD_PROCLIST_PRIORITY,                           3,  3, PCCOL_JUST_CENTER,TEXT("%c") },
      { COLHEAD_PROCLIST_AFFINITY,            COLHEAD_PROCLIST_AFFINITY,                          18, 18, PCCOL_JUST_CENTER,TEXT("0x%016I64x") },
      { COLHEAD_PROCLIST_USER_TIME,           COLHEAD_PROCLIST_USER_TIME,                          9,  9, PCCOL_JUST_RIGHT, TEXT("%I64d") },
      { COLHEAD_PROCLIST_KERNEL_TIME,         COLHEAD_PROCLIST_KERNEL_TIME,                        9,  9, PCCOL_JUST_RIGHT, TEXT("%I64d") },
      { COLHEAD_PROCLIST_CREATE_TIME,         COLHEAD_PROCLIST_CREATE_TIME,                       23, 23, PCCOL_JUST_LEFT,  TEXT("%s") },
   };

   if ( count < 0 ) return;

   if ( isFirst )
      BuildTableHeader( procTable, ENTRY_COUNT(procTable) );

   TCHAR flags[8], fmtCreateTime[512];
   for ( PCINT32 i = 0; i < count; ++i, ++list ) {
      wmemset( rowData, SPACE, ENTRY_COUNT(rowData) );

      if ( gShowFmtProcTime && list->procStats.createTime )
         FormatTime( fmtCreateTime, ENTRY_COUNT(fmtCreateTime), list->procStats.createTime );
      else if ( list->procStats.createTime )
         _stprintf( fmtCreateTime, TEXT("%I64d"), list->procStats.createTime );
      else
         _stprintf( fmtCreateTime, TEXT(" ") );


      ShowListFlags( list->lFlags, flags );

      // Insert each data item into row...
      PCINT32 lastRow = (list->lFlags & PCLFLAG_IS_RUNNING) ? ENTRY_COUNT(procTable) : 3;
      for ( PCINT32 j = 0; j < lastRow; ++j ) {
         TCHAR dataItem[256];
         // Get formatted data...
         switch ( j ) {
            case 0: _stprintf( dataItem, procTable[j].rowFmt, flags );                                   break;
            case 1: _stprintf( dataItem, procTable[j].rowFmt, list->procStats.pid );                     break;
            case 2: _stprintf( dataItem, procTable[j].rowFmt, list->procName );                          break;
            case 3: _stprintf( dataItem, procTable[j].rowFmt, list->imageName );                         break;
            case 4: _stprintf( dataItem, procTable[j].rowFmt, list->jobName );                           break;
            case 5: _stprintf( dataItem, procTable[j].rowFmt, ShowPriority( list->actualPriority ) );    break;
            case 6: _stprintf( dataItem, procTable[j].rowFmt, list->actualAffinity );                    break;
            case 7: _stprintf( dataItem, procTable[j].rowFmt, list->procStats.TotalUserTime / 10000 );   break;
            case 8: _stprintf( dataItem, procTable[j].rowFmt, list->procStats.TotalKernelTime / 10000 ); break;
            case 9: _stprintf( dataItem, procTable[j].rowFmt, fmtCreateTime );                           break;
         }

         // Insert data into row, print if last item...
         InsertTableData( procTable, j, dataItem, j == lastRow - 1 );
      }
   }

   // Display table suffix...
   if ( totcnt >= 0 ) {
      PrintLine( colDash, 1 );
      PrintHelp( HELP_LIST, FALSE );
      ToolMsg( PCCLIMSG_RETRIEVED_PROCESS_LIST, totcnt );
   }
}

static void ShowGrpList( PCJobListItem *list, PCINT32 count, BOOL isFirst, int totcnt ) {

   if ( count < 0 ) return;

   if ( gListShowBase ) {
      PrintLine( NULL, 1 );
      ShowGrpListWithBase( list, count, isFirst );
      if ( totcnt >= 0 ) PrintLine( colDash, 1 );
   }
   if ( gListShowIO ) {
      PrintLine( NULL, 1 );
      ShowGrpListWithIo( list, count, isFirst );
      if ( totcnt >= 0 ) PrintLine( colDash, 1 );
   }
   if ( gListShowMem ) {
      PrintLine( NULL, 1 );
      ShowGrpListWithMem( list, count, isFirst );
      if ( totcnt >= 0 ) PrintLine( colDash, 1 );
   }
   if ( gListShowProc ) {
      PrintLine( NULL, 1 );
      ShowGrpListWithProc( list, count, isFirst );
      if ( totcnt >= 0 ) PrintLine( colDash, 1 );
   }
   if ( gListShowTime ) {
      PrintLine( NULL, 1 );
      ShowGrpListWithTime( list, count, isFirst );
      if ( totcnt >= 0 ) PrintLine( colDash, 1 );
   }

   if ( totcnt >= 0 ) {
      PrintHelp( HELP_LIST );
      ToolMsg( PCCLIMSG_RETRIEVED_GROUP_LIST, totcnt );
   }
}

static void ShowGrpListWithBase( PCJobListItem *list, PCINT32 count, BOOL isFirst ) {

   static PCTableDef baseProcTable[] = {
      { COLHEAD_BASEPROCDATA_FLAGS,               COLHEAD_BASEPROCDATA_FLAGS,                       8,  8, PCCOL_JUST_LEFT,  TEXT("%s") },
      { COLHEAD_BASEPROCDATA_GROUP_NAME_LONG,     COLHEAD_BASEPROCDATA_GROUP_NAME_SHORT, JOB_NAME_LEN, 34, PCCOL_JUST_LEFT,  TEXT("%s") },        
      { COLHEAD_BASEPROCDATA_PRIORITY,            COLHEAD_BASEPROCDATA_PRIORITY,                    8,  8, PCCOL_JUST_CENTER,TEXT("%c") },
      { COLHEAD_BASEPROCDATA_AFFINITY,            COLHEAD_BASEPROCDATA_AFFINITY,                   18, 18, PCCOL_JUST_CENTER,TEXT("0x%016I64x") },
      { COLHEAD_BASEPROCDATA_SCHED_CLASS,         COLHEAD_BASEPROCDATA_SCHED_CLASS,                 9,  9, PCCOL_JUST_CENTER,TEXT("%lu") },
   };

   if ( isFirst )
      BuildTableHeader( baseProcTable, ENTRY_COUNT(baseProcTable) );

   TCHAR flags[8];
   for ( PCINT32 i = 0; i < count; ++i, ++list ) {
      wmemset( rowData, SPACE, ENTRY_COUNT(rowData) );

      ShowListFlags( list->lFlags, flags );

      // Insert each data item into row...
      PCINT32 lastRow = (list->lFlags & PCLFLAG_IS_RUNNING) ? ENTRY_COUNT(baseProcTable) : 2;
      for ( PCINT32 j = 0; j < lastRow; ++j ) {
         TCHAR dataItem[256];
         // Get formatted data...
         switch ( j ) {
            case 0: _stprintf( dataItem, baseProcTable[j].rowFmt, flags );                                 break;
            case 1: _stprintf( dataItem, baseProcTable[j].rowFmt, list->jobName );                         break;
            case 2: _stprintf( dataItem, baseProcTable[j].rowFmt, ShowPriority( list->actualPriority ) );  break;
            case 3: _stprintf( dataItem, baseProcTable[j].rowFmt, list->actualAffinity );                  break;
            case 4: _stprintf( dataItem, baseProcTable[j].rowFmt, list->actualSchedClass );                break;
         }

         // Insert data into row, print if last item...
         InsertTableData( baseProcTable, j, dataItem, j == lastRow - 1 );
      }
   }
}

static void ShowGrpListWithIo( PCJobListItem *list, PCINT32 count, BOOL isFirst ) {

   static PCTableDef ioProcTable[] = {
      { COLHEAD_BASEPROCDATA_FLAGS,               COLHEAD_BASEPROCDATA_FLAGS,                       8,  8, PCCOL_JUST_LEFT,  TEXT("%s") },
      { COLHEAD_BASEPROCDATA_GROUP_NAME_LONG,     COLHEAD_BASEPROCDATA_GROUP_NAME_SHORT, JOB_NAME_LEN, 34, PCCOL_JUST_LEFT,  TEXT("%s") },        
      { COLHEAD_IO_PROCDATA_READ_OPS,             COLHEAD_IO_PROCDATA_READ_OPS,                     8,  8, PCCOL_JUST_RIGHT, TEXT("%I64u") },
      { COLHEAD_IO_PROCDATA_WRITE_OPS,            COLHEAD_IO_PROCDATA_WRITE_OPS,                    8,  8, PCCOL_JUST_RIGHT, TEXT("%I64u") },
      { COLHEAD_IO_PROCDATA_OTHER_OPS,            COLHEAD_IO_PROCDATA_OTHER_OPS,                    8,  8, PCCOL_JUST_RIGHT, TEXT("%I64u") },
      { COLHEAD_IO_PROCDATA_READ_BYTES,           COLHEAD_IO_PROCDATA_READ_BYTES,                  10, 10, PCCOL_JUST_RIGHT, TEXT("%I64u") },
      { COLHEAD_IO_PROCDATA_WRITE_BYTES,          COLHEAD_IO_PROCDATA_WRITE_BYTES,                 10, 10, PCCOL_JUST_RIGHT, TEXT("%I64u") },
      { COLHEAD_IO_PROCDATA_OTHER_BYTES,          COLHEAD_IO_PROCDATA_OTHER_BYTES,                 10, 10, PCCOL_JUST_RIGHT, TEXT("%I64u") },
   };

   if ( isFirst )
      BuildTableHeader( ioProcTable, ENTRY_COUNT(ioProcTable) );

   TCHAR flags[8];
   for ( PCINT32 i = 0; i < count; ++i, ++list ) {
      wmemset( rowData, SPACE, ENTRY_COUNT(rowData) );

      ShowListFlags( list->lFlags, flags );

      // Insert each data item into row...
      PCINT32 lastRow = (list->lFlags & PCLFLAG_IS_RUNNING) ? ENTRY_COUNT(ioProcTable) : 2;
      for ( PCINT32 j = 0; j < lastRow; ++j ) {
         TCHAR dataItem[256];
         // Get formatted data...
         switch ( j ) {
            case 0: _stprintf( dataItem, ioProcTable[j].rowFmt, flags );                              break;
            case 1: _stprintf( dataItem, ioProcTable[j].rowFmt, list->jobName );                      break;
            case 2: _stprintf( dataItem, ioProcTable[j].rowFmt, list->jobStats.ReadOperationCount );  break;
            case 3: _stprintf( dataItem, ioProcTable[j].rowFmt, list->jobStats.WriteOperationCount ); break;
            case 4: _stprintf( dataItem, ioProcTable[j].rowFmt, list->jobStats.OtherOperationCount ); break;
            case 5: _stprintf( dataItem, ioProcTable[j].rowFmt, list->jobStats.ReadTransferCount );   break;
            case 6: _stprintf( dataItem, ioProcTable[j].rowFmt, list->jobStats.WriteTransferCount );  break;
            case 7: _stprintf( dataItem, ioProcTable[j].rowFmt, list->jobStats.OtherTransferCount );  break;
         }

         // Insert data into row, print if last item...
         InsertTableData( ioProcTable, j, dataItem, j == lastRow - 1 );
      }
   }
}

static void ShowGrpListWithMem( PCJobListItem *list, PCINT32 count, BOOL isFirst ) {

   static PCTableDef memProcTable[] = {
      { COLHEAD_BASEPROCDATA_FLAGS,               COLHEAD_BASEPROCDATA_FLAGS,                       8,  8, PCCOL_JUST_LEFT,  TEXT("%s") },
      { COLHEAD_BASEPROCDATA_GROUP_NAME_LONG,     COLHEAD_BASEPROCDATA_GROUP_NAME_SHORT, JOB_NAME_LEN, 34, PCCOL_JUST_LEFT,  TEXT("%s") },        
      { COLHEAD_MEM_PROCDATA_PAGE_FAULTS,         COLHEAD_MEM_PROCDATA_PAGE_FAULTS,                12, 12, PCCOL_JUST_RIGHT, TEXT("%lu") },
      { COLHEAD_MEM_PROCDATA_PEAK_PROC,           COLHEAD_MEM_PROCDATA_PEAK_PROC,                  18, 18, PCCOL_JUST_RIGHT, TEXT("%I64uK") },
      { COLHEAD_MEM_PROCDATA_PEAK_GROUP,          COLHEAD_MEM_PROCDATA_PEAK_GROUP,                 18, 18, PCCOL_JUST_RIGHT, TEXT("%I64uK") },
   };

   if ( isFirst )
      BuildTableHeader( memProcTable, ENTRY_COUNT(memProcTable) );

   TCHAR flags[8];
   for ( PCINT32 i = 0; i < count; ++i, ++list ) {
      wmemset( rowData, SPACE, ENTRY_COUNT(rowData) );

      ShowListFlags( list->lFlags, flags );

      // Insert each data item into row...
      PCINT32 lastRow = (list->lFlags & PCLFLAG_IS_RUNNING) ? ENTRY_COUNT(memProcTable) : 2;
      for ( PCINT32 j = 0; j < lastRow; ++j ) {
         TCHAR dataItem[256];
         // Get formatted data...
         switch ( j ) {
            case 0: _stprintf( dataItem, memProcTable[j].rowFmt, flags );                              break;
            case 1: _stprintf( dataItem, memProcTable[j].rowFmt, list->jobName );                      break;
            case 2: _stprintf( dataItem, memProcTable[j].rowFmt, list->jobStats.ReadOperationCount );  break;
            case 3: _stprintf( dataItem, memProcTable[j].rowFmt, list->jobStats.WriteOperationCount ); break;
            case 4: _stprintf( dataItem, memProcTable[j].rowFmt, list->jobStats.OtherOperationCount ); break;
         }

         // Insert data into row, print if last item...
         InsertTableData( memProcTable, j, dataItem, j == lastRow - 1 );
      }
   }
}

static void ShowGrpListWithProc( PCJobListItem *list, PCINT32 count, BOOL isFirst ) {

   static PCTableDef procProcTable[] = {
      { COLHEAD_BASEPROCDATA_FLAGS,               COLHEAD_BASEPROCDATA_FLAGS,                       8,  8, PCCOL_JUST_LEFT,  TEXT("%s") },
      { COLHEAD_BASEPROCDATA_GROUP_NAME_LONG,     COLHEAD_BASEPROCDATA_GROUP_NAME_SHORT, JOB_NAME_LEN, 34, PCCOL_JUST_LEFT,  TEXT("%s") },        
      { COLHEAD_PROC_PROCDATA_CURR_PROCS,         COLHEAD_PROC_PROCDATA_CURR_PROCS,                12, 12, PCCOL_JUST_RIGHT, TEXT("%lu") },
      { COLHEAD_PROC_PROCDATA_TERM_PROCS,         COLHEAD_PROC_PROCDATA_TERM_PROCS,                12, 12, PCCOL_JUST_RIGHT, TEXT("%lu") },
      { COLHEAD_PROC_PROCDATA_TOTAL_PROCS,        COLHEAD_PROC_PROCDATA_TOTAL_PROCS,               12, 12, PCCOL_JUST_RIGHT, TEXT("%lu") },
   };

   if ( isFirst )
      BuildTableHeader( procProcTable, ENTRY_COUNT(procProcTable) );

   TCHAR flags[8];
   for ( PCINT32 i = 0; i < count; ++i, ++list ) {
      wmemset( rowData, SPACE, ENTRY_COUNT(rowData) );

      ShowListFlags( list->lFlags, flags );

      // Insert each data item into row...
      PCINT32 lastRow = (list->lFlags & PCLFLAG_IS_RUNNING) ? ENTRY_COUNT(procProcTable) : 2;
      for ( PCINT32 j = 0; j < lastRow; ++j ) {
         TCHAR dataItem[256];
         // Get formatted data...
         switch ( j ) {
            case 0: _stprintf( dataItem, procProcTable[j].rowFmt, flags );                                   break;
            case 1: _stprintf( dataItem, procProcTable[j].rowFmt, list->jobName );                           break;
            case 2: _stprintf( dataItem, procProcTable[j].rowFmt, list->jobStats.ActiveProcesses );          break;
            case 3: _stprintf( dataItem, procProcTable[j].rowFmt, list->jobStats.TotalTerminatedProcesses ); break;
            case 4: _stprintf( dataItem, procProcTable[j].rowFmt, list->jobStats.TotalProcesses );           break;
         }

         // Insert data into row, print if last item...
         InsertTableData( procProcTable, j, dataItem, j == lastRow - 1 );
      }
   }
}

static void ShowGrpListWithTime( PCJobListItem *list, PCINT32 count, BOOL isFirst ) {

   static PCTableDef timeProcTable[] = {
      { COLHEAD_BASEPROCDATA_FLAGS,           COLHEAD_BASEPROCDATA_FLAGS,                       8,  8, PCCOL_JUST_LEFT,  TEXT("%s") },
      { COLHEAD_BASEPROCDATA_GROUP_NAME_LONG, COLHEAD_BASEPROCDATA_GROUP_NAME_SHORT, JOB_NAME_LEN, 34, PCCOL_JUST_LEFT,  TEXT("%s") },        
      { COLHEAD_TIME_PROCDATA_USER_TIME,      COLHEAD_TIME_PROCDATA_USER_TIME,                 12, 12, PCCOL_JUST_RIGHT, TEXT("%I64d") },
      { COLHEAD_TIME_PROCDATA_KERNEL_TIME,    COLHEAD_TIME_PROCDATA_KERNEL_TIME,               12, 12, PCCOL_JUST_RIGHT, TEXT("%I64d") },
      { COLHEAD_TIME_PROCDATA_USER_INTVL,     COLHEAD_TIME_PROCDATA_USER_INTVL,                12, 12, PCCOL_JUST_RIGHT, TEXT("%I64d") },
      { COLHEAD_TIME_PROCDATA_KERNEL_INTVL,   COLHEAD_TIME_PROCDATA_KERNEL_INTVL,              12, 12, PCCOL_JUST_RIGHT, TEXT("%I64d") },
   };

   if ( isFirst )
      BuildTableHeader( timeProcTable, ENTRY_COUNT(timeProcTable) );

   TCHAR flags[8];
   for ( PCINT32 i = 0; i < count; ++i, ++list ) {
      wmemset( rowData, SPACE, ENTRY_COUNT(rowData) );

      ShowListFlags( list->lFlags, flags );

      // Insert each data item into row...
      PCINT32 lastRow = (list->lFlags & PCLFLAG_IS_RUNNING) ? ENTRY_COUNT(timeProcTable) : 2;
      for ( PCINT32 j = 0; j < lastRow; ++j ) {
         TCHAR dataItem[256];
         // Get formatted data...
         switch ( j ) {
            case 0: _stprintf( dataItem, timeProcTable[j].rowFmt, flags );                                            break;
            case 1: _stprintf( dataItem, timeProcTable[j].rowFmt, list->jobName );                                    break;
            case 2: _stprintf( dataItem, timeProcTable[j].rowFmt, list->jobStats.TotalUserTime / 10000 );             break;
            case 3: _stprintf( dataItem, timeProcTable[j].rowFmt, list->jobStats.TotalKernelTime / 10000 );           break;
            case 4: _stprintf( dataItem, timeProcTable[j].rowFmt, list->jobStats.ThisPeriodTotalUserTime / 10000 );   break;
            case 5: _stprintf( dataItem, timeProcTable[j].rowFmt, list->jobStats.ThisPeriodTotalKernelTime / 10000 ); break;
         }

         // Insert data into row, print if last item...
         InsertTableData( timeProcTable, j, dataItem, j == lastRow - 1 );
      }
   }
}

static void ShowGrpSummary( PCJobSummary *list, PCINT32 count, BOOL isFirst, int totcnt ) {

   static PCTableDef grpSummTable[] = {
      { COLHEAD_GRPSUMMARY_GRPNAME_LONG,   COLHEAD_GRPSUMMARY_GRPNAME_SHORT, JOB_NAME_LEN, 20, PCCOL_JUST_LEFT,   TEXT("%s") },        
      { COLHEAD_GRPSUMMARY_FLAGS,          COLHEAD_GRPSUMMARY_FLAGS,                   15, 15, PCCOL_JUST_LEFT,   TEXT("%s") },
      { COLHEAD_GRPSUMMARY_AFFINITY,       COLHEAD_GRPSUMMARY_AFFINITY,                18, 18, PCCOL_JUST_CENTER, TEXT("0x%016I64x") },
      { COLHEAD_GRPSUMMARY_PRIORITY,       COLHEAD_GRPSUMMARY_PRIORITY,                 3,  3, PCCOL_JUST_CENTER, TEXT("%c") },
      { COLHEAD_GRPSUMMARY_SCHDCLASS,      COLHEAD_GRPSUMMARY_SCHDCLASS,                4,  4, PCCOL_JUST_CENTER, TEXT("%lu") },
      { COLHEAD_GRPSUMMARY_PROCESS_MEMORY, COLHEAD_GRPSUMMARY_PROCESS_MEMORY,           9,  9, PCCOL_JUST_RIGHT,  TEXT("%I64uK") },
      { COLHEAD_GRPSUMMARY_GROUP_MEMORY,   COLHEAD_GRPSUMMARY_GROUP_MEMORY,             9,  9, PCCOL_JUST_RIGHT,  TEXT("%I64uK") },
      { COLHEAD_GRPSUMMARY_PROCESS_TIME,   COLHEAD_GRPSUMMARY_PROCESS_TIME,            11, 11, PCCOL_JUST_RIGHT,  TEXT("%I64u") },
      { COLHEAD_GRPSUMMARY_GROUP_TIME,     COLHEAD_GRPSUMMARY_GROUP_TIME,              11, 11, PCCOL_JUST_RIGHT,  TEXT("%I64u") },
      { COLHEAD_GRPSUMMARY_PROCESS_COUNT,  COLHEAD_GRPSUMMARY_PROCESS_COUNT,           12, 12, PCCOL_JUST_RIGHT,  TEXT("%u") },
      { COLHEAD_GRPSUMMARY_WORKSET_MIN,    COLHEAD_GRPSUMMARY_WORKSET_MIN,              7,  7, PCCOL_JUST_RIGHT,  TEXT("%I64uK") },
      { COLHEAD_GRPSUMMARY_WORKSET_MAX,    COLHEAD_GRPSUMMARY_WORKSET_MAX,              7,  7, PCCOL_JUST_RIGHT,  TEXT("%I64uK") },
   };

   if ( count < 0 ) return;

   if ( isFirst )
      BuildTableHeader( grpSummTable, ENTRY_COUNT(grpSummTable) );

   for ( PCINT32 i = 0; i < count; ++i, ++list ) {
      // Clear and insert group name into row...
      wmemset( rowData, SPACE, ENTRY_COUNT(rowData) );
      InsertTableData( grpSummTable, 0, list->jobName, FALSE );

      // Add remining group summary data items...
      ShowMgmtParmsAsList( grpSummTable, ENTRY_COUNT(grpSummTable), 1, list->mgmtParms, TRUE );
   }

   if ( totcnt >= 0 ) {
      PrintLine( colDash, 1 );
      PrintHelp( HELP_MGMT );
      ToolMsg( PCCLIMSG_RETRIEVED_GROUP_SUMMARY_LIST, totcnt );
   }
}

static void ShowProcSummary( PCProcSummary *list, PCINT32 count, BOOL isFirst, int totcnt ) {

   static PCTableDef procSummTable[] = {
      { COLHEAD_PROCSUMMARY_PROCNAME_LONG, COLHEAD_PROCSUMMARY_PROCNAME_SHORT, PROC_NAME_LEN, 21, PCCOL_JUST_LEFT,   TEXT("%s") },        
      { COLHEAD_PROCSUMMARY_GRPNAME_LONG,  COLHEAD_PROCSUMMARY_GRPNAME_SHORT,   JOB_NAME_LEN, 20, PCCOL_JUST_LEFT,   TEXT("%s") },        
      { COLHEAD_PROCSUMMARY_FLAGS,         COLHEAD_PROCSUMMARY_FLAGS,                     15, 15, PCCOL_JUST_LEFT,   TEXT("%s") },
      { COLHEAD_PROCSUMMARY_AFFINITY,      COLHEAD_PROCSUMMARY_AFFINITY,                  18, 18, PCCOL_JUST_CENTER, TEXT("0x%016I64x") },
      { COLHEAD_PROCSUMMARY_PRIORITY,      COLHEAD_PROCSUMMARY_PRIORITY,                   3,  3, PCCOL_JUST_CENTER, TEXT("%c") },
      { COLHEAD_PROCSUMMARY_WORKSET_MIN,   COLHEAD_PROCSUMMARY_WORKSET_MIN,                7,  7, PCCOL_JUST_RIGHT,  TEXT("%I64uK") },
      { COLHEAD_PROCSUMMARY_WORKSET_MAX,   COLHEAD_PROCSUMMARY_WORKSET_MAX,                7,  7, PCCOL_JUST_RIGHT,  TEXT("%I64uK") },
   };

   if ( count < 0 ) return;

   if ( isFirst )
      BuildTableHeader( procSummTable, ENTRY_COUNT(procSummTable) );

   for ( PCINT32 i = 0; i < count; ++i, ++list ) {
      // Clear and insert process and group names into row...
      wmemset( rowData, SPACE, ENTRY_COUNT(rowData) );
      InsertTableData( procSummTable, 0, list->procName, FALSE );
      InsertTableData( procSummTable, 1, list->memberOfJobName, FALSE );

      // Add remining group summary data items...
      ShowMgmtParmsAsList( procSummTable, ENTRY_COUNT(procSummTable), 2, list->mgmtParms, FALSE );
   }

   if ( totcnt >= 0 ) {
      PrintLine( colDash, 1 );
      PrintHelp( HELP_MGMT, FALSE, PCCLIMSG_NOTE_PROCESS_RULES_MAY_NOT_APPLY );
      ToolMsg( PCCLIMSG_RETRIEVED_PROCESS_SUMMARY_LIST, totcnt );
   }
}

static void ShowMgmtParmsAsList( PCTableDef *table, 
                                 PCULONG32 entries, 
                                 PCULONG32 first, 
                                 MGMT_PARMS &parm, 
                                 BOOL isGrp ) {
   TCHAR flags[16], dataItem[256];

   ShowMgmtFlags( flags, parm.mFlags );

   for ( PCULONG32 j = first; j < entries; ++j ) {
      // Get formatted data...
      if ( isGrp ) switch ( j ) {
         case 1: _stprintf( dataItem, table[j].rowFmt, flags );                         break;
         case 2: _stprintf( dataItem, table[j].rowFmt, parm.affinity );                 break;
         case 3: _stprintf( dataItem, table[j].rowFmt, ShowPriority( parm.priority ) ); break;
         case 4: _stprintf( dataItem, table[j].rowFmt, parm.schedClass );               break;
         case 5: _stprintf( dataItem, table[j].rowFmt, parm.procMemoryLimit / 1024 );   break;
         case 6: _stprintf( dataItem, table[j].rowFmt, parm.jobMemoryLimit / 1024 );    break;
         case 7: _stprintf( dataItem, table[j].rowFmt, parm.procTimeLimitCNS / 10000 ); break;
         case 8: _stprintf( dataItem, table[j].rowFmt, parm.jobTimeLimitCNS / 10000 );  break;
         case 9: _stprintf( dataItem, table[j].rowFmt, parm.procCountLimit );           break;
         case 10:_stprintf( dataItem, table[j].rowFmt, parm.minWS / 1024 );             break;
         case 11:_stprintf( dataItem, table[j].rowFmt, parm.maxWS / 1024 );             break;
      }
      else switch (j ) {
         case 2: _stprintf( dataItem, table[j].rowFmt, flags );                         break;
         case 3: _stprintf( dataItem, table[j].rowFmt, parm.affinity );                 break;
         case 4: _stprintf( dataItem, table[j].rowFmt, ShowPriority( parm.priority ) ); break;
         case 5: _stprintf( dataItem, table[j].rowFmt, parm.minWS / 1024 );             break;
         case 6: _stprintf( dataItem, table[j].rowFmt, parm.maxWS / 1024 );             break;
      }

      // Insert data into row, print if last item...
      InsertTableData( table, j, dataItem, j == entries - 1 );
   }
}

static void ShowGrpDetail( PCJobDetail &grpDetail ) {
   ToolMsg( PCCLIMSG_GROUP_DETAIL_HEADER, grpDetail.base.jobName );
   ShowMgmtParms( grpDetail.base.mgmtParms, TRUE );
   ShowVariableData( grpDetail.vLength, grpDetail.vData );
   PrintHelp( HELP_MGMT );
}

static void ShowProcDetail( PCProcDetail &procDetail ) {
   ToolMsg( PCCLIMSG_PROCESS_DETAIL_HEADER, procDetail.base.procName, ERROR_SUCCESS, 
            procDetail.base.memberOfJobName );
   ShowMgmtParms( procDetail.base.mgmtParms, FALSE );
   ShowVariableData( procDetail.vLength, procDetail.vData );
   PrintHelp( HELP_MGMT, FALSE );
}

static void PrintLine( TCHAR *data, PCUINT32 nlCount ) {
   DWORD numWritten;
   static HANDLE stdOut = INVALID_HANDLE_VALUE;

   if (stdOut == INVALID_HANDLE_VALUE) {
       stdOut = GetStdHandle(STD_OUTPUT_HANDLE);
   }
   if ( data ) {
       DWORD len = _tcslen(data);
       if (! WriteConsole(stdOut,
                          data,
                          len,
                          &numWritten,
                          0)) {
           WriteFile(stdOut,
                     data,
                     len * sizeof(TCHAR),
                     &numWritten,
                     NULL);
       }
   }
   if ( nlCount ) {
      for ( PCUINT32 i = 0; i < nlCount; ++i )
          if (! WriteConsole(stdOut,
                             TEXT("\n"),
                             1,
                             &numWritten,
                             0)) {
              WriteFile(stdOut,
                        TEXT("\n"),
                        sizeof(TCHAR),
                        &numWritten,
                        NULL);
          }
   }
}

static void PrintHelp( PCUINT32 flags, BOOL isGrp, PCUINT32 msgId ) {
   if ( flags & HELP_LIST )        ToolMsg( PCCLIMSG_LIST_FLAGS_EXPLAIN );
   else if ( flags & HELP_ALIAS )  ToolMsg( PCCLIMSG_ALIAS_FLAGS_EXPLAIN );
   else if ( flags & HELP_MGMT )   ToolMsg( isGrp? PCCLIMSG_GROUP_FLAGS_EXPLAIN : 
                                                   PCCLIMSG_PROCESS_FLAGS_EXPLAIN );
   if ( msgId ) ToolMsg( msgId );
}

static void BuildSystemParms( PCSystemParms  &newParms, TCHAR **pArgs, PCUINT32 pArgCt ) {
   memset( &newParms, 0, sizeof(newParms) );
   if ( pArgCt > 0 ) newParms.manageIntervalSeconds = GetInteger( *pArgs++ );
   if ( pArgCt > 1 ) newParms.timeoutValueMs        = GetInteger( *pArgs++ );
}

static void BuildNameRule( PCNameRule &newRule, TCHAR **pArgs, PCUINT32 pArgCt ) {
   memset( &newRule, 0, sizeof(newRule) );
   if ( pArgCt > 0 ) newRule.matchType = **pArgs++;
   if ( pArgCt > 1 ) _tcsncpy( newRule.matchString, *pArgs++, MATCH_STRING_LEN ); 
   if ( pArgCt > 2 ) _tcsncpy( newRule.procName,    *pArgs++, PROC_NAME_LEN ); 
   if ( pArgCt > 3 ) _tcsncpy( newRule.description, *pArgs,   NAME_DESCRIPTION_LEN );
}

static void MergeManagmentParms( MGMT_PARMS &newParms, MGMT_PARMS &oldParms ) {
   newParms.mFlags |= oldParms.mFlags;

   if ( !newParms.affinity                 ) newParms.affinity         = oldParms.affinity;
   if ( !newParms.jobMemoryLimit           ) newParms.jobMemoryLimit   = oldParms.jobMemoryLimit;
   if ( !newParms.jobTimeLimitCNS          ) newParms.jobTimeLimitCNS  = oldParms.jobTimeLimitCNS;
   if ( !newParms.maxWS                    ) newParms.maxWS            = oldParms.maxWS;
   if ( !newParms.minWS                    ) newParms.minWS            = oldParms.minWS;
   if ( !newParms.priority                 ) newParms.priority         = oldParms.priority;
   if ( !newParms.procCountLimit           ) newParms.procCountLimit   = oldParms.procCountLimit;
   if ( !newParms.procMemoryLimit          ) newParms.procMemoryLimit  = oldParms.procMemoryLimit;
   if ( !newParms.procTimeLimitCNS         ) newParms.procTimeLimitCNS = oldParms.procTimeLimitCNS;
   if ( newParms.schedClass > 9            ) newParms.schedClass       = oldParms.schedClass;

   if ( !*newParms.description ) memcpy( newParms.description, oldParms.description, sizeof(newParms.description) );
   if ( !*newParms.profileName ) memcpy( newParms.profileName, oldParms.profileName, sizeof(newParms.profileName) );
}

static void MergeGroupDetail( PCJobDetail &newDet, PCJobDetail &oldDet ) {
   if ( !newDet.vLength && oldDet.vLength ) {
      newDet.vLength = oldDet.vLength;
      memcpy( newDet.vData, oldDet.vData, newDet.vLength );
   }
   MergeManagmentParms( newDet.base.mgmtParms, oldDet.base.mgmtParms );
}

static void MergeProcDetail( PCProcDetail &newDet, PCProcDetail &oldDet ) {
   if ( !newDet.vLength && oldDet.vLength ) {
      newDet.vLength = oldDet.vLength;
      memcpy( newDet.vData, oldDet.vData, newDet.vLength );
   }
   if ( !*newDet.base.memberOfJobName ) 
      memcpy( newDet.base.memberOfJobName, oldDet.base.memberOfJobName, sizeof(newDet.base.memberOfJobName) );
   MergeManagmentParms( newDet.base.mgmtParms, oldDet.base.mgmtParms );
}

static void BuildGrpDetail( PCJobDetail &newDetail, TCHAR **pArgs, PCUINT32 pArgCt ) {
   memset( &newDetail, 0, offsetof(PCJobDetail, vLength) );
   if ( pArgCt > 0 ) _tcsncpy( newDetail.base.jobName, *pArgs, JOB_NAME_LEN );
   if ( pArgCt > 1 ) BuildMgmtParms( newDetail.base.mgmtParms, pArgs + 1, pArgCt - 1, NULL,
                                     &newDetail.vLength, newDetail.vData );
   else newDetail.vLength = 0;
}

static void BuildProcDetail( PCProcDetail &newDetail, TCHAR **pArgs, PCUINT32 pArgCt ) {
   memset( &newDetail, 0, offsetof(PCProcDetail, vLength) );
   if ( pArgCt > 0 ) _tcsncpy( newDetail.base.procName, *pArgs++, PROC_NAME_LEN );
   if ( pArgCt > 1 ) BuildMgmtParms( newDetail.base.mgmtParms, pArgs, pArgCt - 1, 
                                     newDetail.base.memberOfJobName, &newDetail.vLength, newDetail.vData );
   else newDetail.vLength = 0;
}

static void BuildGrpSummary( PCJobSummary &newSummary, TCHAR **pArgs, PCUINT32 pArgCt, PCUINT32 *listFlags ) {
   memset( &newSummary, 0, sizeof(newSummary) );
   if ( pArgCt > 0 ) {
      _tcsncpy( newSummary.jobName, *pArgs++, JOB_NAME_LEN );
      *listFlags |= PC_LIST_STARTING_WITH;
   }
   if ( pArgCt > 1 ) BuildMgmtParms( newSummary.mgmtParms, pArgs, pArgCt - 1 );
}

static void BuildProcSummary( PCProcSummary &newSummary, TCHAR **pArgs, PCUINT32 pArgCt, PCUINT32 *listFlags ) {
   memset( &newSummary, 0, sizeof(newSummary) );
   if ( pArgCt > 0 ) {
      _tcsncpy( newSummary.procName,        *pArgs++, PROC_NAME_LEN );
      *listFlags |= PC_LIST_STARTING_WITH;
   }
   if ( pArgCt > 1 ) BuildMgmtParms( newSummary.mgmtParms,  pArgs, pArgCt - 1, newSummary.memberOfJobName );
}

static void BuildGrpListItem( PCJobListItem &newListItem, TCHAR **pArgs, PCUINT32 pArgCt, PCUINT32 *listFlags ) {
   memset( &newListItem, 0, sizeof(newListItem) );
   gListShowBase = gListShowIO = gListShowMem = gListShowProc = gListShowTime = FALSE;
   for ( PCUINT32 i = 0; i < pArgCt; ++i, ++pArgs ) {
      if ( !IsSwitch( **pArgs ) ) {
         _tcsncpy( newListItem.jobName, *pArgs, JOB_NAME_LEN );
         *listFlags |= PC_LIST_STARTING_WITH;
      }
      else switch ( (*pArgs)[1] ) {
         case GL_ALL:  
            gListShowTime = gListShowBase = gListShowIO = gListShowMem = gListShowProc = TRUE;  break; 
         case GL_BASE:    gListShowBase  = TRUE;  break;
         case GL_IO:      gListShowIO    = TRUE;  break;
         case GL_MEMORY:  gListShowMem   = TRUE;  break; 
         case GL_PROCESS: gListShowProc  = TRUE;  break; 
         case GL_TIME:    gListShowTime  = TRUE;  break;
         default:
            ToolMsg( PCCLIMSG_GROUP_LIST_FLAG_UNKNOWN, *pArgs );  
      }
   }
   if ( !gListShowIO && !gListShowMem && !gListShowProc && !gListShowTime ) 
      gListShowBase = TRUE;
}

static void BuildProcListItem( PCProcListItem &newListItem, TCHAR **pArgs, PCUINT32 pArgCt, PCUINT32 *listFlags ) {
   memset( &newListItem, 0, sizeof(newListItem) );
   gShowFmtProcTime = FALSE;
   while ( pArgCt > 0 ) {
      if ( IsSwitch( **pArgs) ) {
         if ( *(*pArgs + 1) == DATA_GROUP && pArgCt > 1 ) {
            _tcsncpy( newListItem.jobName, *++pArgs, JOB_NAME_LEN );
            ++pArgs;
            pArgCt -= 2;
            *listFlags |= PC_LIST_MEMBERS_OF;
         }
         else if ( *(*pArgs + 1) == TEXT('t') ) {
            gShowFmtProcTime = TRUE;
            ++pArgs;
            --pArgCt;
         }
         else {
            ToolMsg( PCCLIMSG_PROCESS_LIST_FLAG_UNKNOWN, *pArgs );
            break;
         }
      }
      else {
         _tcsncpy( newListItem.procName, *pArgs++, PROC_NAME_LEN );
         --pArgCt;
         if ( pArgCt > 0 && !IsSwitch( **pArgs) ) {
            newListItem.procStats.pid = GetUInteger64( *pArgs++ );
            --pArgCt;
         }
         *listFlags |= PC_LIST_STARTING_WITH;
      }
   }
   if ( pArgCt ) ToolMsg( PCCLIMSG_PROCESS_LIST_FLAG_IGNORED, *pArgs );

}

static void BuildMgmtParms( MGMT_PARMS  &parm, 
                            TCHAR      **pArgs, 
                            PCUINT32     pArgCt, 
                            JOB_NAME     grpHere,
                            PCINT16     *len, 
                            TCHAR       *var ) {
   PCUINT32 inLen = len? *len : 0;
   if ( len ) *len = 0;

   parm.schedClass = 99;                   // set 'net set' value.  Needed because 0 is a valid setting.

   for ( ; pArgCt > 1; pArgCt -= 2 ) {
      if ( !IsSwitch( **pArgs ) ) {
         ToolMsg( PCCLIMSG_UNKNOWN_DEF_SWITCH_IGNORED, *pArgs );
         return;
      }
      if ( IsSwitch( **(pArgs + 1) ) ) {
         ToolMsg( PCCLIMSG_ARG_MISSING_WITH_IGNORE, *pArgs );
         return;
      }
      switch ( *(*pArgs++ + 1) ) {
      case DEF_PRIO:
         parm.priority = GetPriority( *pArgs++ );
         if ( !parm.priority )
            ToolMsg( PCCLIMSG_UNKNOWN_PRIORITY_IGNORED, *(pArgs - 1) );
         break;
      case DEF_AFF:
         parm.affinity = GetUInteger64( *pArgs++ );
         break;
      case DEF_WS:
         if ( pArgCt > 2 ) {
            parm.minWS = GetValue( *pArgs++, MAXLONG - 1 ) * 1024;     // Limit to match snap-in's limit
            if ( !IsSwitch( **pArgs ) )
               parm.maxWS = GetValue( *pArgs++, MAXLONG - 1 ) * 1024;     // Limit to match snap-in's limit
            else {
               parm.minWS = 0;
               ToolMsg( PCCLIMSG_WS_MAX_MISSING, *(pArgs - 1) );
               return;
            }
            --pArgCt;
         }
         break;
      case DEF_SCHED:
         parm.schedClass = GetInteger( *pArgs++ );
         break;
      case DEF_FLAGS:
         parm.mFlags = GetMgtFlags( *pArgs++ );
         break;
      case DEF_PROCTIME:
         parm.procTimeLimitCNS = GetInteger64( *pArgs++ ) * 10000;
         break;
      case DEF_GROUP:
         if ( grpHere ) _tcsncpy( grpHere, *pArgs++, JOB_NAME_LEN );
         else
            ToolMsg( PCCLIMSG_GROUP_NAME_NOT_APPLICABLE );
         break;
      case DEF_GROUPTIME:
         parm.jobTimeLimitCNS = GetInteger64( *pArgs++ ) * 10000;
         break;
      case DEF_GROUPMEM:
         parm.jobMemoryLimit = GetValue( *pArgs++, MAXLONG - 1 ) * 1024;     // Limit to match snap-in's limit
         break;
      case DEF_PROCMEM:
         parm.procMemoryLimit = GetValue( *pArgs++, MAXLONG - 1 ) * 1024;     // Limit to match snap-in's limit
         break;
      case DEF_PROCCOUNT:
         parm.procCountLimit = (ULONG) GetValue( *pArgs++, MAXLONG - 1 );     // Limit to match snap-in's limit 
         break;
      case DEF_BRKAWAY:
         parm.mFlags |= PCMFLAG_SET_PROC_BREAKAWAY_OK;
         break;
      case DEF_SILENTBRKAWAY:
         parm.mFlags |= PCMFLAG_SET_SILENT_BREAKAWAY;
         break;
      case DEF_DIEONUHEX:
         parm.mFlags |= PCMFLAG_SET_DIE_ON_UH_EXCEPTION;
         break;
      case DEF_CLOSEONEMPTY:
         parm.mFlags |= PCMFLAG_END_JOB_WHEN_EMPTY;
         break;
      case DEF_MSGONGRPTIME:
         parm.mFlags |= PCMFLAG_MSG_ON_JOB_TIME_LIMIT_HIT;
         break;
      case DEF_PROF:
         _tcsncpy( parm.profileName, *pArgs++, PROFILE_NAME_LEN );
         break;
      case DEF_DESC:
         _tcsncpy( parm.description, *pArgs++, RULE_DESCRIPTION_LEN );
         break;
      case DEF_VARDATA:
         if ( inLen ) {
            *len = (PCINT16) min( (_tcslen( *pArgs ) + 1), inLen / sizeof(TCHAR) );
            if ( *len ) _tcsncpy( var, *pArgs, *len );
            *len *= sizeof(TCHAR);                      // convert to bytes as per definition of field 
         }
         *pArgs++;
         break;
      default:
         ToolMsg( PCCLIMSG_UNKNOWN_DEF_SWITCH_IGNORED, *--pArgs );
         return;
         break;
      }
   }
  if ( pArgCt )
     ToolMsg( PCCLIMSG_INCOMPLETE_DEFINITION_IGNORED, *pArgs );
}

static PC_MGMT_FLAGS GetMgtFlags( TCHAR *txt ) {
   PC_MGMT_FLAGS flgs = 0;
   for ( TCHAR *d = txt; *d; ++d ) {
      TCHAR c = _totlower( *d );
      if      ( c == DEF_GROUP         ) flgs |= PCMFLAG_APPLY_JOB_MEMBERSHIP; 
      else if ( c == DEF_AFF           ) flgs |= PCMFLAG_APPLY_AFFINITY; 
      else if ( c == DEF_PRIO          ) flgs |= PCMFLAG_APPLY_PRIORITY; 
      else if ( c == DEF_WS            ) flgs |= PCMFLAG_APPLY_WS_MINMAX; 
      else if ( c == DEF_SCHED         ) flgs |= PCMFLAG_APPLY_SCHEDULING_CLASS; 
      else if ( c == DEF_PROCTIME      ) flgs |= PCMFLAG_APPLY_PROC_TIME_LIMIT;
      else if ( c == DEF_GROUPTIME     ) flgs |= PCMFLAG_APPLY_JOB_TIME_LIMIT;
      else if ( c == DEF_GROUPMEM      ) flgs |= PCMFLAG_APPLY_JOB_MEMORY_LIMIT;
      else if ( c == DEF_PROCMEM       ) flgs |= PCMFLAG_APPLY_PROC_MEMORY_LIMIT;
      else if ( c == DEF_PROCCOUNT     ) flgs |= PCMFLAG_APPLY_PROC_COUNT_LIMIT;
      else if ( c == DEF_BRKAWAY       ) flgs |= PCMFLAG_SET_PROC_BREAKAWAY_OK;
      else if ( c == DEF_SILENTBRKAWAY ) flgs |= PCMFLAG_SET_SILENT_BREAKAWAY;
      else if ( c == DEF_DIEONUHEX     ) flgs |= PCMFLAG_SET_DIE_ON_UH_EXCEPTION;
      else if ( c == DEF_CLOSEONEMPTY  ) flgs |= PCMFLAG_END_JOB_WHEN_EMPTY;
      else if ( c == DEF_MSGONGRPTIME  ) flgs |= PCMFLAG_MSG_ON_JOB_TIME_LIMIT_HIT;
   }
   return flgs;
}

static void ShowMgmtParms( MGMT_PARMS &parm, BOOL isGrp ) {
   TCHAR flags[16];
   ShowMgmtFlags( flags, parm.mFlags );
   if ( isGrp ) 
      ToolMsg( PCCLIMSG_GROUP_DETAIL_PARAMETERS, flags, ERROR_SUCCESS,
               (VOID *) parm.affinity, (VOID *) ShowPriority( parm.priority ), 
               IntToPtr(parm.schedClass), 
               (VOID *) (parm.procMemoryLimit / 1024), (VOID *) (parm.jobMemoryLimit / 1024), 
               (VOID *) (parm.procTimeLimitCNS / 10000), (VOID *) (parm.jobTimeLimitCNS / 10000),
               IntToPtr(parm.procCountLimit), 
               (VOID *) (parm.minWS / 1024), (VOID *) (parm.maxWS / 1024) );
   else
      ToolMsg( PCCLIMSG_PROCESS_DETAIL_PARAMETERS, flags, ERROR_SUCCESS,
               (VOID *) parm.affinity, (VOID *) ShowPriority( parm.priority ), 
               (VOID *) (parm.minWS / 1024), (VOID *) (parm.maxWS / 1024) );
   if ( *parm.description )
      ToolMsg( PCCLIMSG_DETAIL_DESCRIPTION_TEXT, parm.description );
}

static void ShowVariableData( short len, TCHAR *data ) {
   if ( len )
      ToolMsg( PCCLIMSG_DETAIL_VARIABLE_TEXT, IntToPtr(len), ERROR_SUCCESS, IntToPtr(len / 2), data );
}

static void ShowMgmtFlags( TCHAR flags[16], PC_MGMT_FLAGS mFlags, BOOL compact ) {
   for ( PCUINT32 i = 0; i < 16; ++i ) flags[i] = TEXT('.');
   flags[15] = 0;
   if ( mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP      ) flags[0]  = _totupper(DEF_GROUP);
   if ( mFlags & PCMFLAG_APPLY_PRIORITY            ) flags[1]  = _totupper(DEF_PRIO);
   if ( mFlags & PCMFLAG_APPLY_AFFINITY            ) flags[2]  = _totupper(DEF_AFF);
   if ( mFlags & PCMFLAG_APPLY_SCHEDULING_CLASS    ) flags[3]  = _totupper(DEF_SCHED);
   if ( mFlags & PCMFLAG_APPLY_WS_MINMAX           ) flags[4]  = _totupper(DEF_WS);
   if ( mFlags & PCMFLAG_SET_PROC_BREAKAWAY_OK     ) flags[5]  = _totupper(DEF_BRKAWAY);
   if ( mFlags & PCMFLAG_SET_SILENT_BREAKAWAY      ) flags[6]  = _totupper(DEF_SILENTBRKAWAY);
   if ( mFlags & PCMFLAG_SET_DIE_ON_UH_EXCEPTION   ) flags[7]  = _totupper(DEF_DIEONUHEX);
   if ( mFlags & PCMFLAG_END_JOB_WHEN_EMPTY        ) flags[8]  = _totupper(DEF_CLOSEONEMPTY);
   if ( mFlags & PCMFLAG_MSG_ON_JOB_TIME_LIMIT_HIT ) flags[9]  = _totupper(DEF_MSGONGRPTIME);
   if ( mFlags & PCMFLAG_APPLY_PROC_MEMORY_LIMIT   ) flags[10] = _totupper(DEF_PROCMEM);
   if ( mFlags & PCMFLAG_APPLY_JOB_MEMORY_LIMIT    ) flags[11] = _totupper(DEF_GROUPMEM);
   if ( mFlags & PCMFLAG_APPLY_JOB_TIME_LIMIT      ) flags[12] = _totupper(DEF_GROUPTIME);
   if ( mFlags & PCMFLAG_APPLY_PROC_TIME_LIMIT     ) flags[13] = _totupper(DEF_PROCTIME);
   if ( mFlags & PCMFLAG_APPLY_PROC_COUNT_LIMIT    ) flags[14] = _totupper(DEF_PROCCOUNT);

   if ( compact ) {
      for ( PCUINT32 j = 0, i = 0; i < 15; ++i )
         if ( flags[i] != TEXT('.') ) flags[j++] = flags[i];
      flags[j] = 0;
   }
}

static void ShowSysInfo( PCSystemInfo &sysInfo, BOOL versionOnly ) {
   if ( versionOnly ) 
      ToolMsg( PCCLIMSG_SERVICE_VERSION_SHORT, sysInfo.productVersion, ERROR_SUCCESS, 
               sysInfo.fileVersion, sysInfo.fileFlags );
   else {
      ToolMsg( PCCLIMSG_SERVICE_VERSION_LONG, sysInfo.productVersion, ERROR_SUCCESS, 
               sysInfo.fileVersion, sysInfo.fileFlags, IntToPtr(sysInfo.fixedSignature) );
      ToolMsg( PCCLIMSG_SERVICE_VERSION_BINARY, IntToPtr(sysInfo.fixedFileVersionMS), 
               ERROR_SUCCESS, IntToPtr(sysInfo.fixedFileVersionLS),
               IntToPtr(sysInfo.fixedProductVersionMS), IntToPtr(sysInfo.fixedProductVersionLS),
               IntToPtr(sysInfo.fixedFileOS), 
               IntToPtr(sysInfo.fixedFileType), IntToPtr(sysInfo.fixedFileSubtype) ); 
      ToolMsg( PCCLIMSG_MEDIATOR_VERSION_LONG, sysInfo.medProductVersion, ERROR_SUCCESS, 
               sysInfo.medFileVersion, sysInfo.medFileFlags );     
      ShowSysParms( sysInfo.sysParms );
   }
}

static void ShowSysParms( PCSystemParms &sysParms ) {
   ToolMsg( PCCLIMSG_SYSTEM_PARAMETERS, IntToPtr(sysParms.numberOfProcessors), ERROR_SUCCESS, 
            (VOID *) sysParms.processorMask,          IntToPtr(sysParms.memoryPageSize), 
            IntToPtr(sysParms.manageIntervalSeconds), IntToPtr(sysParms.timeoutValueMs) );
}

static int  ShowHelp( TCHAR **pArgs, PCUINT32 pArgCt ) {
   if ( !pArgCt ) ShowCLIHelp();
   else ShowDetailHelp( pArgs, pArgCt );

   return 0;
}

static void ShowCLIHelp( void ) {
   ToolMsg( PCCLIMSG_COMMAND_HELP, (VOID *) (PC_MIN_BUF_SIZE / 1024), ERROR_SUCCESS, 
            (VOID *) (PC_MAX_BUF_SIZE / 1024) );
}

static void ShowDetailHelp( TCHAR **pArgs, PCUINT32 pArgCt ) {
   for ( ; pArgCt > 0; --pArgCt, ++pArgs ) {
      int i = 0;
      TCHAR code = (*pArgs)[i++];
      if ( IsSwitch( code ) && (*pArgs)[i] ) code = (*pArgs)[i++];
      TCHAR subCode = (*pArgs)[i++];

      switch ( code ) {
      case BUFFER_SIZE:
         ToolMsg( PCCLIMSG_SWITCH_b_HELP, (VOID *) (PC_MIN_BUF_SIZE / 1024), ERROR_SUCCESS, 
                  (VOID *) (PC_MAX_BUF_SIZE / 1024) );
         break;
      case COMPUTER_NAME: ToolMsg( PCCLIMSG_SWITCH_c_HELP );       break;
      case INTERACTIVE:   ToolMsg( PCCLIMSG_SWITCH_i_HELP );       break;
      case FILE_INPUT:    ToolMsg( PCCLIMSG_SWITCH_f_HELP );       break;
      case ADMIN_DUMPREST:ToolMsg( PCCLIMSG_SWITCH_x_HELP );       break;
      case OP_ADD:        ToolMsg( PCCLIMSG_SWITCH_a_HELP );       break;
      case OP_REP:        ToolMsg( PCCLIMSG_SWITCH_r_HELP );       break;
      case OP_UPDATE:     ToolMsg( PCCLIMSG_SWITCH_u_HELP );       break;
      case OP_DEL:        ToolMsg( PCCLIMSG_SWITCH_d_HELP );       break;
      case OP_SWAP:       ToolMsg( PCCLIMSG_SWITCH_s_HELP );       break;
      case OP_LIST:       ToolMsg( PCCLIMSG_SWITCH_l_HELP );       break;
      case OP_KILL:       ToolMsg( PCCLIMSG_SWITCH_k_HELP );       break;
      case OP_COMMENT:    ToolMsg( PCCLIMSG_SWITCH_COMMENT_HELP ); break;
      case OP_HELP:       ToolMsg( PCCLIMSG_SWITCH_HELP_HELP );    break;
      case DATA_GROUP:
         switch ( subCode ) {
         case SUB_LIST:
         case 0:           ToolMsg( PCCLIMSG_SWITCH_gl_HELP ); break;
         case SUB_SUMMARY: ToolMsg( PCCLIMSG_SWITCH_gs_HELP ); break;
         case SUB_DEFS:    ToolMsg( PCCLIMSG_SWITCH_gd_HELP ); break;
         default:
            ToolMsg( PCCLIMSG_GROUP_SUBLIST_HELP_UNKNOWN, (VOID *) subCode, ERROR_SUCCESS, 
                     (VOID *) SUB_DEFS, (VOID *) SUB_SUMMARY, (VOID *) SUB_LIST ); 
            break;
         }
         break;
      case DATA_PROC:
         switch ( subCode ) {
         case SUB_LIST:
         case 0:           ToolMsg( PCCLIMSG_SWITCH_pl_HELP ); break;
         case SUB_SUMMARY: ToolMsg( PCCLIMSG_SWITCH_ps_HELP ); break;
         case SUB_DEFS:    ToolMsg( PCCLIMSG_SWITCH_pd_HELP ); break;
         default:
            ToolMsg( PCCLIMSG_PROCESS_SUBLIST_HELP_UNKNOWN, (VOID *) subCode, ERROR_SUCCESS, 
                     (VOID *) SUB_DEFS, (VOID *) SUB_SUMMARY, (VOID *) SUB_LIST ); 
            break;
         }
         break;
      case DATA_NAME:     ToolMsg( PCCLIMSG_SWITCH_n_HELP ); break;
      case DATA_SERVICE:  ToolMsg( PCCLIMSG_SWITCH_v_HELP ); break;
      case DATA_MEDIATOR: ToolMsg( PCCLIMSG_SWITCH_m_HELP ); break;
      default:            
         ToolMsg( PCCLIMSG_HELP_UNKNOWN, (VOID *) code ); 
         return;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ppr\pspage.c ===
/* PSPage.C
 *
 *      Title:          PSPAGE
 *                      Henry Burgess
 *                      Copyright Microsoft Corp, 1985
 *                      July 4, 1985
 *
 *      Description:
 *                      This module contains the font table and the routine
 *                      that accesses it.  It might also be OEM configurable.
 *
 *==========================================================================
 * Modification History:
 *--------------------------------------------------------------------------
 *      9/11/85                 Modified to adopt to the banner program.
 *
 *      4/20/86 MJH             Adapt to lpr, page handling module.
 *
 *      3/3/89 Robert Hess      Version 2.9
 *                              Completely re-wrote PostScript support.
 *
 */



#include <windef.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include "lpr.h"


char        page[rowMax][colMax+1];    /* image of one printer page          */


/*
 * the following defines the bits in the character font
 */
unsigned char Font_Bits[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,         /* 00  */
0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,         /* 01  */
0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,         /* 02  */
0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,         /* 03  */
0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,         /* 04  */
0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,         /* 05  */
0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,         /* 06  */
0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,         /* 07  */
0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,         /* 08  */
0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,         /* 09  */
0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,         /* 0a  */
0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,         /* 0b  */
0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,         /* 0c  */
0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,         /* 0d  */
0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,         /* 0e  */
0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,         /* 0f  */
0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,         /* 10  */
0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,         /* 11  */
0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,         /* 12  */
0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,         /* 13  */
0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,         /* 14  */
0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,         /* 15  */
0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,         /* 16  */
0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,         /* 17  */
0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,         /* 18  */
0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,         /* 19  */
0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,         /* 1a  */
0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,         /* 1b  */
0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,         /* 1c  */
0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,         /* 1d  */
0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,         /* 1e  */
0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,         /* 1f  */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,         /* 20  */
0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,         /* 21 ! */
0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,         /* 22 " */
0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,         /* 23 # */
0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,         /* 24 $ */
0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,         /* 25 % */
0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,         /* 26 & */
0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,         /* 27 ' */
0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,         /* 28 ( */
0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,         /* 29 ) */
0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,         /* 2a * */
0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,         /* 2b + */
0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,         /* 2c , */
0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,         /* 2d - */
0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,         /* 2e . */
0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,         /* 2f / */
0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,         /* 30 0 */
0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,         /* 31 1 */
0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,         /* 32 2 */
0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,         /* 33 3 */
0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,         /* 34 4 */
0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,         /* 35 5 */
0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,         /* 36 6 */
0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,         /* 37 7 */
0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,         /* 38 8 */
0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,         /* 39 9 */
0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,         /* 3a : */
0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,         /* 3b ; */
0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,         /* 3c < */
0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,         /* 3d = */
0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,         /* 3e > */
0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,         /* 3f ? */
0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,         /* 40 @ */
0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,         /* 41 A */
0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,         /* 42 B */
0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,         /* 43 C */
0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,         /* 44 D */
0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,         /* 45 E */
0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,         /* 46 F */
0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,         /* 47 G */
0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,         /* 48 H */
0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,         /* 49 I */
0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,         /* 4a J */
0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,         /* 4b K */
0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,         /* 4c L */
0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,         /* 4d M */
0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,         /* 4e N */
0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,         /* 4f O */
0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,         /* 50 P */
0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,         /* 51 Q */
0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,         /* 52 R */
0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,         /* 53 S */
0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,         /* 54 T */
0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x00,         /* 55 U */
0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,         /* 56 V */
0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,         /* 57 W */
0xc6, 0x6c, 0x38, 0x10, 0x38, 0x6c, 0xc6, 0x00,         /* 58 X */
0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,         /* 59 Y */
0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,         /* 5a Z */
0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,         /* 5b [ */
0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,         /* 5c \ */
0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,         /* 5d ] */
0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,         /* 5e ^ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,         /* 5f _ */
0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,         /* 60 ` */
0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,         /* 61 a */
0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,         /* 62 b */
0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,         /* 63 c */
0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,         /* 64 d */
0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,         /* 65 e */
0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,         /* 66 f */
0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,         /* 67 g */
0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,         /* 68 h */
0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,         /* 69 i */
0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,         /* 6a j */
0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,         /* 6b k */
0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,         /* 6c l */
0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,         /* 6d m */
0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,         /* 6e n */
0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,         /* 6f o */
0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,         /* 70 p */
0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,         /* 71 q */
0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,         /* 72 r */
0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,         /* 73 s */
0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,         /* 74 t */
0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,         /* 75 u */
0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,         /* 76 v */
0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,         /* 77 w */
0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,         /* 78 x */
0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,         /* 79 y */
0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,         /* 7a z */
0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,         /* 7b { */
0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,         /* 7c | */
0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,         /* 7d } */
0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,         /* 7e ~ */
0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00          /* 7f   */
};



void block_flush(sz, rowTopLeft, colTopLeft)
/*** do the actual block printing of sz to the page. */
char        sz[];
int         rowTopLeft, colTopLeft;
    {
    int      row, col, ich;
    register unsigned char c;
    char     chFill;

    if ((sz == NULL) || (sz[0] == '\0'))
	    return;

    for (row =0; row < 8; row++)
	{                      /* 8 lines */
	for (ich = 0; sz[ich] != '\0'; ich++)
	    {         /* characters in string */
	    /*
	    * find this character in the font table
	    * and byte for this row  ( + i )
	    */
	    c = Font_Bits[((unsigned)sz[ich] << 3) + row];

	    if (chBanner<=' ')
		if (isprint(sz[ich]))
	  	    chFill = sz[ich];
		else chFill = 'X';
	    else
		chFill = chBanner;

	    for (col = 0; col < 8; col++)
		{      /* bits in a byte */
		page[rowTopLeft + row][colTopLeft + (ich << 3) + col] =
                      (char)(((int)c & 0x80) ? chFill : ' ');
                c = (unsigned char)((int)c << 1);
		}
	    }
	}
    }




void VertLine(char ch, int colAt, int rowMin, int rowMac)
    {
    register int row;

    for (row = rowMin; row < rowMac; page[row++][colAt] = ch)
	;
    }




void HorzLine(char ch, int rowAt, int colMin, int colMac)
    {
    register int  col;

    for (col = colMin; col < colMac; page[rowAt][col++] = ch)
	;
    }




void FillRectangle(char ch, int rowTopLeft, int colTopLeft, int rowBotRight, int colBotRight)
    {
    register int  col, row;

    for (row = rowTopLeft; row < rowBotRight; row++)
	{
        for (col = colTopLeft; col < colBotRight; col++)
            page[row][col] = ch;
        }
    }




void WriteSzCoord(sz, row, col)
register char *sz;
int   row, col;
    {
    register char *pch;

    for (pch = &page[row][col]; *sz != '\0'; *pch++ = *sz++)
	;
    }




void OutCmpLJ(szO,cchO)
/*  Accept a string, szO, of length cchO and remove runs of seven or
    more spaces by replacing them with a control sequence to move the
    printer head on the HP Laser Jet.

    ESC&a+#C   moves the head # places to the right.

    NOTE: this is very similar to OutCmpPS().
*/
char *szO;
int cchO;
    {
    register int cchB;
    char chO;
    register char *pchB;
    char szMove[10];

    chO = szO[cchO];		/* save for later restore */
    szO[cchO] = '\0';		/* Make sure 0 terminated string. */

    while (*szO != '\0')
        {
	pchB = szO;
	while ((pchB=strchr(pchB, ' ')) != 0 && (cchB=strspn(pchB, " ")) < 7)
		pchB += cchB;

	if (pchB != 0)
		{
		/* found a run of blanks of 7 or more */
		if (szO != pchB)
			{
			/* output other stuff until pchB */
			OutLPR(szO, (int)(pchB-szO));
			szO = pchB;
			}
		
		/* output run of blanks as ESC&a+#C */
		sprintf(szMove, "\033&a+%dC", cchB);
		OutLPR(szMove, 0);
		szO += cchB;
		}
	else
		{
		/* no run of blanks; output all and terminate loop */

		cchB = strlen(szO);		/* not really blanks (!) */
		OutLPR(szO, cchB);
		szO += cchB;
		}
	}
    *szO = chO;		/* restore */
    }



void OutEncPS(pchF, cchF)
/* output PostScript substring quoting *nothing* */
register char *pchF;
int cchF;
{
    register char *pchT;
    int cchT;
    char rgbT[1+colMax*2+5];/* enough for every character to be encoded */

    pchT = rgbT;
    cchT = 0;
    while (cchF-- > 0) {
	switch(*pchF++) {
	    default:
		*pchT++ = *(pchF-1);
		cchT++;
		break;
	}
    }
    *pchT = '\n'; cchT++;	   /* end of PostScript string */

    OutLPR(rgbT, cchT);
}


void OutCmpPS(szO,cchO)
/*  Accept a string, szO, of length cchO.

    # sp   moves the head # places to the right (local definition).

    NOTE: this is VERY similar to OutCmpPS().
*/
char *szO;
int cchO;
    {
    register int cchB;
    char chO;
    register char *pchB;

    chO = szO[cchO];		/* save for later restore */
    szO[cchO] = '\0';		/* Make sure 0 terminated string. */
    while (*szO != '\0') {
	pchB = szO;
	cchB = strlen(szO);		/* not really blanks (!) */
	OutEncPS (szO, cchB);
	szO += cchB;
    }
    *szO = chO;		/* restore */
}




int CchNoTrail(rgch,cch)
/* returns the number of characters in a line of text without counting
   trailing blanks*/
char rgch[];
int cch;
    {
    register char *pch;

    for (pch = rgch + cch - 1; pch >= rgch && *pch==' ';pch--)
         ;
    return ((int)((pch + 1) - rgch));
    }




void OutRectangle(rowMin, colMin, rowLim, colLim)
/* output rectangle of page triming blank lines and blanks from the ends of
   lines
*/
int rowMin, colMin, rowLim, colLim;
    {
    int row;
    int ccol = colLim - colMin;

    while (rowLim > rowMin && CchNoTrail(&page[rowLim-1][colMin], ccol) == 0)
	rowLim--;

    for (row = rowMin; row < rowLim; row++)
	{
	register char *pch = &page[row][colMin];
	int cch = CchNoTrail(pch, ccol);

	if (cch != 0)
	    {
	    if (fLaser)
		OutCmpLJ(pch, cch);
	    else if (fPostScript) {
		OutCmpPS(pch, cch);
	    } else
		OutLPR(pch, cch);
	    }
        else if (fPostScript) {
	    OutCmpPS (" ", 1);
	}
        if (!fPostScript)
	    OutLPR(row==rowLim - 1 ? "\r" : "\r\n", 0);
	}
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\mediate\procconmd8.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pretty\pretty.c ===
// Tweak the CABINETSTATE to disable name pretification by Diz

// Syntax: pretty.exe [option]
//                     on       enables name prettification
//                     off      disables name pretification
//                     help, ?  display help text
//                     [none]   displays the current state

#include "windows.h"
#include "windowsx.h"
#include "winuserp.h"
#include "shlobj.h"
#include "shellapi.h"
#include "shlobjp.h"
#include "stdio.h"

int _cdecl main(int iArgC, LPTSTR pArgs[])
{
    CABINETSTATE cs;
    LPTSTR pArg = pArg=pArgs[1];
    BOOL fOldDontPrettyNames;

    ReadCabinetState(&cs, sizeof(cs));

    fOldDontPrettyNames = cs.fDontPrettyNames;
    if (iArgC > 1)
    {
        if (*pArg==TEXT('-') || *pArg==TEXT('/'))
            pArg++;

        if (lstrcmpi(pArg, TEXT("on"))==0)
        {
            cs.fDontPrettyNames = FALSE;
        }
        else if (lstrcmpi(pArg, TEXT("off"))==0)
        {
            cs.fDontPrettyNames = TRUE;
        }
        else if (*pArg==TEXT('?') || lstrcmpi(pArg, TEXT("help"))==0)
        {
            printf(TEXT("Syntax: pretty.exe [on/off]\n"));
            return 0;
        }

        if (cs.fDontPrettyNames != fOldDontPrettyNames)
            WriteCabinetState(&cs);
    }

    printf(TEXT("Explorer name formatting is %s\n(Any change only become effective after next login)\n"),
                        cs.fDontPrettyNames ? TEXT("off"):TEXT("on"));

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ppr\ppr.c ===
/*  lpr.c - fancy paginator for laserprinters
 *
 *  Author: Mark Taylor
 *
 *  Modifications:
 *
 *      12/85   Mark Zbikowski  rewrite to work cleaner
 *      4/3/86  MZ              Single print jobs will advance page
 *      4/3/86  MZ              use tools.ini for default printer setup
 *      4/20/86 Mike Hanson     add banner, etc (add features to make like
 *                              lpr from PS, extensively reorganized, etc)
 *      6/6/86  Jay Sipelstein  added S and L options to printer desc.
 *                              Trim trailing blanks and blank lines.
 *                              Set mode before raw printing.
 *      7/8/86  Byron Bishop    Add -q to cause print queue to be printed.
 *                              Fixed bug so -# and -e flags take priority
 *                              over default settings.  Runs of blanks
 *                              replaced by escape sequences to reduce
 *                              file size.
 *      8/31/86 Craig Wittenberg Added support for PostScript.  Used the VMI
 *                              on the LaserJet instead of line/inch to get 62
 *                              lines on one page (two for header).  Cleaned
 *                              up iLine (now rowLine) and indentation.
 *      10/10/86 John Rae-Grant Added -g flag to allow gutter in portrait mode.
 *                              $USER can now be a list of directories to
 *                              search for tools.ini in. Default printer can
 *                              be specified in tools.ini file.  Modified
 *                              landscape mode page numbering to avoid three
 *                              hole punch obliteration.
 *      1/27/87 Craig Wittenberg Cleaned up whole program; no change in
 *                              functionality.
 *      1/28/87 Thom Landsberger  Added CB and CZ (=default) flags to the LJ
 *                              printer description to support the 'Z' font
 *                              cartridge in landscape mode
 *      3/23/87 Thom Landsberger  Port to Xenix 286 and 68k;  environment
 *                              setting of parameters accepted as default
 *                              and with higher priority than tools.ini/.pprrc;
 *                              implemented -m, -M, -c command switches;
 *                              restructured command interpretation.
 *      4/10/87 Craig Wittenberg  interrupt signal ignored if that is the
 *                              status when ppr is started
 *      4/14/87 Thom Landsberger  only pure digit strings accepted as
 *                              numeric command line arguments
 *      6/05/87 Thom Landsberger  double sided printing on HP LJ 2000;
 *                              '/' no switch character on Xenix;
 *                              'ppr -q -' now does print from stdin.
 *      7/5/87  Craig Wittenberg changed fDuplex? names to f?Duplex so they
 *                              compile in 68k Xenix.  Invoked ftp with command
 *                              line arguments rather than printing the commands
 *                              to stdin.  -t now removes label (used to require
 *                              -m "").
 *
 *                              Ppr reads /etc/default/ppr if there is not
 *                              $HOME/.pprrc.  Duplex printing now does not
 *                              print on the back of the banner page (even if
 *                              not raw).  Added -s flag: disables messages
 *                              which indicate ppr's progress.  Changed the PS
 *                              setup to avoid VMErrors.  Allowed the default
 *                              printer in the tools.ini/.pprrc file to have
 *                              options (e.g. default=lpt1, LJ L).  Changed the
 *                              default printer on Xenix from net9 to net.
 *
 *      ~8/1/87 Ralph Ryan      Ported to OS/2 LanManager
 *
 *     11/24/87 Craig Wittenberg Rearranged sources - mostly to isloate the OS
 *                              specific network routines in lplow.c
 *                              Ppr now uses clem as the transfer machine for
 *                              DOS print jobs when /usr/eu/bin/ppr is not
 *                              present (indicating a machine in another
 *                              division).
 *
 *      12/2/87 Alan Bauer      Version 2.5
 *                              Final porting to OS/2 LAN Manager.  Mainly
 *                              polished up network routines to work properly
 *                              Released to OS/2 people, DOSENV, NEWENV, and
 *                              new 68K version.
 *
 *      3/17/88 Alan Bauer      Version 2.6
 *                              Fixed so that the username is still printed in
 *                              lower left corner of the file listing when the
 *                              "no banner" option is specified (ppr -b0).
 *                              Ppr -? now prints to stdout rather than stderr.
 *                              Now supports ppr -q for OS/2.
 *
 *      4/04/88 Alan Bauer      Version 2.7
 *                              Added -c<n> option to print <n> copies of the
 *                              specified files.
 *                              Seperates large print jobs into roughly 100K
 *                              amounts.
 *                              Better feed back on PRINTING progress.
 *                              Fixed so that an empty password is now passed to
 *                              mkalias correctly (Xenix 386 version).
 *                              Now map ppr -p "xenix name" to
 *                                    "mkalias name name printing [password]".
 *                              Errors opening input files no longer abort; just
 *                              go on to the next file.
 *
 *      4/05/88 Alan Bauer      Version 2.71
 *                              Fixed problem with last file to be printed
 *                              putting the current print job over 100K,
 *                              therefore causing new print job to be performed
 *                              (with no more files to be printed).
 *
 *      4/13/88 Alan Bauer      Version 2.8
 *                              Added ability to specify options in TOOLS.INI
 *                              file.
 *
 *      5/19/88 Alan Bauer      Version 2.81
 *                              Fixed General Protection Fault in OS/2 dealing
 *                              with login usernames which are more than 12
 *                              characters long.
 *
 *      6/20/88 Alan Bauer      Version 2.82
 *                              Fixed LANMAN error message handling problems
 *                              and a bug where ppr failed if redirection to
 *                              the same printer as established in the environ-
 *                              ment variable was already set up.
 *
 *      3/3/89 Robert Hess      Version 2.9
 *                              Completely changed PostScript support.
 *                              Added 'PC' (Portrait Condensed) and 'PSF'
 *                              (PostScriptFile) printer specific switches.
 *
 *      3/22/89 Robert Hess     Version 2.10
 *                              Modifications to how 'FormFeed' was handled
 *                              for PostScript usage.
 *
 *      7/12/89 Robert Hess     Version 2.11
 *                              Fixed a bug that prevented lengthy Postscript
 *                              files to be printed.
 *
 *      9/14/89 Robert Hess     Version 2.12
 *                              Fixed -M option in PostScript code.
 *                              Fixed the 'opts=<option>' parsing from
 *                              TOOLS.INI (wasn't allowing leading spaces)
 *
 *      10/6/89 Robert Hess     Version 2.12b
 *                              Minor fix, repaired linking to include
 *                              SetArgV.OBJ (to automatically expand
 *                              wildcards in filenames - ooops!), and
 *                              added error handling to the '-q' command.
 *
 *      10/20/89 Robert Hess    Version 2.13
 *                              Date and time of *FILE* is now printed at
 *                              the bottom of the page for PostScript.
 *                              (...ooops...)
 *
 *      12/06/89 Robert Hess    Version 2.14
 *                              Added switches -v (verify, for debugging),
 *                              and -w (column width).
 *
 *      4/9/90 Scott Means      Version 2.15
 *                              Support of non-printable IBM characters and
 *                              added progress indicator.
 *
 *      4/18/90 Robert Hess     Version 2.2
 *                              Re-Wrote postscript header code to allow
 *                              full sensing of actual printer area, and
 *                              corrected several bugs in old header.
 *                              Fixed 'pathname' for network drives
 *                              Fixed '-t' switch for Postscript mode
 *                              Added 'psuedo' printer name support.
 *
 *      6/15/90 Robert Hess     Version 2.3
 *                              Added better implementation of 'extended
 *                              ascii' mode. Added more debugging code
 *                              for network usage. Added R and C printer
 *                              switches to better support odd sized paper.
 *                              Improved 'usage' text.
 *                              Switched to using some TOOLSVR api calls.
 *                              General cleanup and bug fixes.
 *                              Enlisted into \\ToolSvr\Build project.
 *
 *      7/26/90 Robert Hess     Version 2.3a
 *                              Fixed a couple bugs. Added '-l' option for
 *                              listing out contents of TOOLS.INI. Final
 *                              cleanup prior to general release.
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <process.h>
#include <signal.h>
#include <ctype.h>
#include <windows.h>
#include <tools.h>
#include "lpr.h"


/* 175 columns:
 *                        0   1                    174
 *  single page:        <bar> 173 columns of text <bar>
 *                        0   1               86   87  88              173 174
 *  double page:        <bar> 86 columns of text <bar> 86 columns of text <bar>
 */

long        lcbOutLPR = 0l;             //  total amount printed in this job
int         cCol = 0;                   //  number of columns being displayed
int         cColCom = 0;                /* number of columns as specified in
                                           command line.                      */
int         colTabCom = 0;              /* number of spaces per tab specified
                                           in command line.   Number of spaces
                                           per tab, colTab, is declared in
                                           lpfile.c                           */
int         colGutter = 0;              //  number of spaces in gutter
int         colText   = 0;              //  column where text starts
int         cCopies = 1;                //  number of copies to print
int         colWidth;                   //  printable spaces in each column

int         defWidth = 0; //  <- NEW... to override colWidth calculation

int         colMac = colLJMax;          //  maximum columns on a page
int         rowMac = rowLJMax;          //  maximum rows on a page
int         rowPage;                    /* number of printable lines per page
                                           including header on top            */

char *aszSymSet[] = {   // supported Laserjet symbol sets
    "\033&l1o5.8C\033(0U\033(s0p16.67h8.5v0T",
    "\033&l1o5.8C\033(8U\033(s0p16.67h8.5v0T",
    "\033&l1o5.8C\033(10U\033(s0p16.67h8.5v0T"
};

BOOL        fNumber = FALSE;            //  TRUE => show line numbers
BOOL        fDelete = FALSE;            //  TRUE => delete file after printing
BOOL        fRaw = FALSE;               //  TRUE => print in raw mode
BOOL        fBorder = TRUE;             //  TRUE => print borders
BOOL        fLabel = TRUE;              //  TRUE => print page heading
BOOL        fLaser = TRUE;              //  TRUE => print on an HP LaserJet
BOOL        fPostScript = FALSE;        //  TRUE => print on postscript printer

BOOL        fPSF = FALSE;               //  TRUE => Use alternate PS Header
char        szPSF[MAX_PATH] = "";      //  pathname of alternate PS Header
BOOL        fPCondensed = FALSE;        //  TRUE => Condensed portrait mode PS

BOOL        fConfidential = FALSE;      //  TRUE => stamp pages and banner
BOOL        fVDuplex = FALSE;           //  TRUE => double sided, vertical bind
BOOL        fHDuplex = FALSE;           //  TRUE => ditto, but horizontal bind
BOOL        fSilent = FALSE;            //  TRUE => no messages
int         cBanner = -1;               //  # of banners; <0 only 1 group
char        chBanner = ' ';             //  used to form banner characters
char        *szBanner = NULL;           //  banner string, use fname if NULL
char        *szStamp = NULL;            //  additional label put on each page
BOOL        fForceFF = TRUE;            //  TRUE => end at top of page
BOOL        fPortrait = FALSE;          //  TRUE => print in portrait mode
BOOL        fQueue = FALSE;             //  TRUE => list print queue
USHORT      usSymSet = 0;               //  symbol set to use on Laserjet
                                        //  FALSE => select Roman-8 symbol set
USHORT      usCodePage = 0;             //  0 = convert extended ascii to '.'
BOOL        fVerify = FALSE; //  TRUE => dump out data on what we are doing
BOOL        fList   = FALSE; //  TRUE => use with fVerify to prevent printing

char        szPass[cchArgMax] = "";

static void Usage(void);
static void DoArgs(int *, char **[]);
void Abort(void);
void DoIniOptions(void);


int __cdecl main(argc, argv)
int argc;
char **argv;
    {
    intptr_t err;
    int iCopies;

#ifdef notdefined
    if (signal(SIGINT, SIG_IGN) != SIG_IGN)
        //  if not ignored upon startup, set our abort handler
        signal(SIGINT, (void (_cdecl *)(int))Abort);
#endif

//  hack to get verify and list to work *before* command line is parsed
    ConvertAppToOem( argc, argv );
    if( argc > 1 ) {
        if (argv[1][1] == 'v') {
            fVerify = TRUE;
        }
        if (argv[1][1] == 'l') {
            fList   = TRUE;
        }
        if (fVerify) {
            fprintf (stdout, "\n");
        }
    }

    DoIniOptions();

    if (fVerify) {
        fprintf (stdout, "Seen on Command Line:\n");
    }

    DoArgs(&argc, &argv);
    SetupPrinter();
    SetupRedir();

    //  -------------- modifications to switches and precalculated values

    //  don't allow guttering in landscape mode
    if (!fPortrait)
        colGutter = 0;

    //  set global for start of text
    colText = colGutter + (fNumber ? cchLNMax : 0);

    //  set # columns if set in command line.
    if (cColCom)
        cCol = cColCom;
    else if (cCol == 0)
        cCol = fPortrait ? 1 : 2;

    //  set # of spaces per tab if set in command line.
    if (colTabCom)
        colTab = colTabCom;

    colWidth = colMac;
    if (fPostScript && fPCondensed) {
        colWidth = colMac *= 2;
    }

    if (defWidth > 0) colWidth = defWidth;

    if (fLaser && usCodePage == 850) {
        usSymSet = BEGINLANDIBMPC; // for the LaserJet
    }

    if (cCol != 1) {
        //  more than one column: divide into separate columns with divider
        colWidth = (colMac-1) / cCol - 1;
        if (defWidth > 0) colWidth = defWidth;
        colMac = (colWidth + 1) * cCol + 1;
    }

    //  rowPage includes border line(s) at top of page
    rowPage = rowMac;
    if (fBorder || fLabel) {
        if (!fLaser && !fPostScript && fPortrait) {
            //  same bottom margin as old Xenix ppr
            rowPage -= 5;
        } else {
            //  don't print on bottom line
            rowPage -= 1;
        }
    }

    if (!fLaser && !fPostScript && cBanner == -1) {
        //  line printer for which the default banner setup is required
        cBanner = -2;
    }

    //  ----------------- end modification of switches

    if (fVerify) fprintf (stdout, "\n"); //  just to clean things up a little
    fprintf(stdout, "PPR version: "VERSION"\n");
    fprintf(stdout, "----------------------------------------------------------------------------\n");

    if (argc == 0) {
        /* No file names were listed... assume user wants <stdin> */
        if (!fQueue && !fList) {
            //  print stdin
            fprintf (stdout, "Printing from: <stdin> Press <Ctrl-Z> to end.\n");
            MyOpenPrinter();
            FileOut("");
            MyClosePrinter();
        }
    } else {
        //  print file(s)
        MyOpenPrinter();
        while (argc) {
            //  print more copies if wanted
            for(iCopies = 1; iCopies <= cCopies; iCopies++) {
                FileOut(*argv);

                //  end this print job if more than 100K has been printed
                //  thus far.  Then start next print job.
                if (lcbOutLPR > 100000 && argc != 1) {
                    lcbOutLPR = 0l;
                    MyClosePrinter();
                    fFirstFile = TRUE;
                    MyOpenPrinter();          //  ready to start next job
                }
            }
            argc--;
            argv++;
        }
        MyClosePrinter();
    }

    /* if user wants to print queue, spawn a process to do the printing.
       The process will inherit the current environment including the
       redirection of szPName.
    */
    if (fQueue) {
        fprintf (stdout, "[Net Print %s]:\n", szNet);
        err = _spawnlp(P_WAIT,"net","net","print",szNet,NULL);
        if (err)
            if (err == -1)
                fprintf (stdout, "- Error : Unable to Spawn Queue Status Request -\n");
            else
                fprintf (stdout, "- Error Returned from Queue Status Request: %d - \n", err);
    }
    ResetRedir();
    return 0;
} /* main */




void Abort()
/*  SIGINT handler to abort printing gracefully
 *
 *      Warning: Never returns (exits via Fatal).
 */
{
    Fatal("terminated by user", NULL);
} /* Abort */




static void Usage()
{
    fprintf(stdout, "PPR version: "VERSION"   by: "ANALYST"\n");
    fprintf(stdout, "Usage: ppr [-switches] files(s)\n");
    fprintf(stdout, "-<digit>   :Print in columns (1-9)    -n         : Print line numbers\n");
    fprintf(stdout, "-b <n>     :Print <n> banners         -o <n>     : Offset <n> for gutter\n");
    fprintf(stdout, "-c <n>     :Print <n> copies          -q         : List print queue status\n");
    fprintf(stdout, "-D         :Delete file after print   -s         : Supress progress message\n");
    fprintf(stdout, "-e <n>     :Expand tabs to <n>        -t         : Supress page headers\n");
    fprintf(stdout, "-f         :NO formfeed at end        -r         : Print in raw mode\n");
    fprintf(stdout, "-h <string>:Use <string> for header   -v         : Verbose (for debugging)\n");
    fprintf(stdout, "-m <string>:Stamp <string> on page    -w <n>     : Page width in characters\n");
    fprintf(stdout, "-M         :\"Microsoft Confidential\"  -p <string>: Printer description\n");
    fprintf(stdout, "\n");
    fprintf(stdout, "Printer Description: ppr -p \"<port>,<type> <options>,<columns>,<tabstops>\"\n");
    fprintf(stdout, "Types & Options:\n");
    fprintf(stdout, "LP        : Line Printer              DV        : Duplex printing vert.\n");
    fprintf(stdout, "LJ        : HPLaserJet                DH        : Duplex printing horz.\n");
    fprintf(stdout, "PS        : PostScript                F         : No force form feed\n");
    fprintf(stdout, "PSF <file>: PostScript w/header       L         : Landscape\n");
    fprintf(stdout, "CZ        : 'Z' Cartridge             P         : Portrait\n");
    fprintf(stdout, "CB        : 'B' Cartridge             PC        : Portrait Condensed\n");
    fprintf(stdout, "CP <n>    : Set CodePage              S         : Force form feed\n");
    fprintf(stdout, "EA        : Set CodePage to 850       #         : Number of rows\n");
    fprintf(stdout, "See PPR.HLP for further information and usage descriptions.\n");

    exit(1);
}



//  VARARGS
void __cdecl Fatal(char *sz, ...)
{
    va_list args;

    va_start(args, sz);
    fprintf(stderr, "ppr: ");
    vfprintf(stderr, sz, args);
    fprintf(stderr, "\n");
    va_end(args);
    MyClosePrinter();
    ResetRedir();
    exit(1);
}


void __cdecl Error(char *sz, ...)
{
    va_list args;

    va_start(args, sz);
    fprintf(stderr, "ppr: ");
    vfprintf(stderr, sz, args);
    fprintf(stderr, "\n");
    va_end(args);
}


char * SzGetArg(ppch, pargc, pargv)
char **ppch;
int *pargc;
char **pargv[];
//  return the string following the current switch; no whitespace required
        {
        char *tmp;
        if (*(*ppch+1))
                {
                (*ppch)++;
                tmp = *ppch;
                *ppch += strlen(*ppch) - 1;
                //  return(*ppch);
                return( tmp );
                }
        else
                {
                (*pargv)++;
                if (--*pargc)
                        return((*pargv)[0]);
                else
                        return(NULL);
                }
        }




int WGetArg(ppch, pargc, pargv, nDefault, szXpl)
//  return the number following the current switch; no whitespace required
char **ppch;
int *pargc;
char **pargv[];
int nDefault;
char * szXpl;
        {
        int nRet;
        char chSwitch;

        chSwitch = **ppch;
        if (*(*ppch+1))
                {
                nRet = atoi(++*ppch);
                *ppch += strlen(*ppch) - 1;
                }
        else
                {
                if ((*pargc>1) &&
                    strlen((*pargv)[1]) == strspn((*pargv)[1], "0123456789") )
                        {
                        (*pargc)--;
                        nRet = atoi((++*pargv)[0]);
                        }
                else
                        nRet = nDefault;
                }

        if (nRet<0)
                {
                Fatal("negative %s (switch %c)", szXpl, chSwitch);
                return 0;
                }
        else
                return(nRet);
        }


void DoIniOptions() //  Get any options from the TOOLS.INI file (OPTS=...)
        {
#define cargsMax 25
    FILE *pfile;
    char *szT;
    char rgbSW[cchArgMax];
    int argc;
    char *pchSp;
    char *argvT[cargsMax];          //  structure to build to be like argv
    char **pargvT = argvT;

//    if ((pfile = swopen()) != NULL) {
    if ((pfile = swopen("$INIT:Tools.INI", "ppr")) != NULL) {
        /* 'PPR' tag was found in 'TOOLS.INI' */
        if (fVerify || fList) {
            fprintf (stdout, "TOOLS.INI contains the following entries:\n");
            fprintf (stdout, "[ppr]\n");
        }
        while (swread(rgbSW, cchArgMax, pfile) != 0) {
            /* a 'switch line' was found in the file */
            szT = rgbSW + strspn(rgbSW, " \t"); // skip spaces and tabs
            if (fVerify || fList) {
                fprintf (stdout, "    %s \n", szT);
            }
            //  an entry "opts=<options>" will cause the options
            //  to be set from the parameter file.
            if (_strnicmp(szT, OPTS, strlen(OPTS)) == 0) {

                if ((szT = strchr(szT, '=')) != NULL) {

                    szT++;  //  advance past '='
                    while (szT[0] == ' ') szT++; //  advance past beginning spaces
                    if(*szT) {
                        argvT[0] = 0;
                        for (argc = 1; argc < cargsMax && szT[0] != '\0'; argc++)
                                {
                            argvT[argc] = szT;
                            pchSp = strchr(szT, ' ');
                            if (pchSp == '\0')
                                    break;
                            *pchSp = 0;
                            szT = pchSp + 1;
                            while (szT[0] == ' ') {
                                    szT++;
                            }
                        }
                        argc++;
                        argvT[argc] = '\0';
                        DoArgs(&argc, &pargvT);
                    }
                }
            }
        }
        swclose(pfile);
    }
}


static void DoArgs(pargc, pargv) //  Parse the argument string.
int * pargc;
char **pargv[];
    {
    int argc, vArgc; //  vArgc - for verify mode
    char **argv, **vArgv;
    char *p;

    argc = vArgc = *pargc;
    argv = vArgv = *pargv;

    argc--;
    argv++;
    p = argv[0];

    while (argc && (*p == '/' || (*p=='-' && *(p+1)!='\0')))
        {
        while (*++p)
            {
            switch (tolower(*p))
                {

                case 'a':
                    chBanner = *++p;
                    break;

                case 'b':
                    cBanner = WGetArg(&p, &argc, &argv, 1, "number of banners");
                    break;

                case 'c':
                    cCopies= WGetArg(&p, &argc, &argv, 1, "number of copies");
                    break;

                case 'd':
                case 'D':
                    if (*p=='D')  // <-- since we did a 'tolower'
                        fDelete = TRUE;
                    break;

                case 'e':
                    colTabCom = WGetArg(&p, &argc, &argv, 8, "tabs");
                    break;

                case 'f':
                    fForceFF = FALSE;
                    break;

                case 'g':
                case 'o':
                    colGutter = WGetArg(&p, &argc, &argv, colGutDef, "offset");
                    break;

                case 'h':
                    szBanner = SzGetArg(&p, &argc, &argv);
                    break;

                case 'l':
                    fList = TRUE;
                    break;

                case 'm':
                case 'M':
                    fBorder = TRUE;
                    fLabel = TRUE;
                    if (*p=='M') // <-- since we did a 'tolower'
                        fConfidential = TRUE;
                    else
                        szStamp = SzGetArg(&p, &argc, &argv);
                    break;

                case 'n':
                    fNumber = TRUE;
                    break;

                case 'p':
                    szPDesc = SzGetArg(&p, &argc, &argv);
                    break;

                case 'q':     //  Enable print of queue
                    fQueue = TRUE;
                    break;
                case 'r':

                    fRaw = TRUE;
                    break;

                case 's':
                    fSilent = TRUE;
                    break;

                case 't':
                    if (!fConfidential && szStamp==NULL)
                        {
                        fBorder = FALSE;
                        fLabel  = FALSE;
                        }
                    break;

                case 'v':
                    fVerify = TRUE;
                    break;

                case 'w':
                    defWidth = WGetArg(&p, &argc, &argv, 80, "Width of column");
                    break;

                case 'x':
                    usCodePage = 850;
                    break;

                case '1': case '2':
                case '3': case '4':
                case '5': case '6':
                case '7': case '8':
                case '9':
                    cColCom = *p - '0';
                    break;

                default :
                    Error("invalid switch: %s\n", p);
                case '?':
                case 'z':
                    Usage();
                    break;
                }
            }
        argc--;
        argv++;
        p = argv[0];
        }

    if (fVerify) {
        vArgv++; //  skip over program name, or null entry
        while (--vArgc) fprintf (stdout, "%s ", *(vArgv++));
        fprintf (stdout, "\n\n");
    }

    *pargv = argv;
    *pargc = argc;
    }



void DoOptSz(szOpt)
/*   scan and handle printer options
 *
 *   Entry:     szOpt - string containing printer options
 *
 *   Exit:      global flags set according to printer options
 *
 *   An option string has the format:
 *     [, [(LJ [P] [L] [CB|CZ] [D|DV|DH]) | (LP [# lines]) | (PS [P] [L])] [F] [S] [, [tabstop] [, [# columns]]]]
 *
 *   Note: Although this is called by the lpprint module,
 *         It is here because it deals with command line arguments
 *         and setting the global print control flags.
 */
register char * szOpt;
    {
    char szBuf[cchArgMax];
    BOOL fLJ = FALSE;
    BOOL fLP = FALSE;
    BOOL fPS = FALSE;

    if (*szOpt++ == ',')
        {
        while (*szOpt != ',' && *szOpt)
            {
            szOpt = SzGetSzSz(szOpt, szBuf);

/* First the different printer types*/

            // Laser Jet
            if (_strcmpi(szBuf, "lj") == 0 && !fLP && !fPS)
                {
                fLJ       = TRUE;
                fLaser    = TRUE;
                fPostScript = FALSE;
                //  don't set border here so -t works
                fPortrait = FALSE;
                colMac    = colLJMax;
                rowMac    = rowLJMax;
                }

            // Line Printer
            else if (_strcmpi(szBuf, "lp") == 0 && !fLJ && !fPS)
                {
                fLP       = TRUE;
                fLaser    = FALSE;
                fPostScript = FALSE;
                fBorder   = FALSE;
                fPortrait = TRUE;
                colMac    = colLPMax;
                rowMac    = rowLPMax;
                }

            // PostScript with custom header
            else if (_strcmpi(szBuf, "psf") == 0 && !fLP && !fLJ)
                {
                fPS       = TRUE;
                fLaser    = FALSE;
                fPostScript = TRUE;
                fPortrait = FALSE;
                fPCondensed = FALSE;
                colMac    = colPSMax;
                rowMac    = rowPSMax;
                fPSF  = TRUE;
                szOpt = SzGetSzSz(szOpt, szPSF);
                }

            // PostScript
            else if (_strcmpi(szBuf, "ps") == 0 && !fLP && !fLJ)
                {
                fPS       = TRUE;
                fLaser    = FALSE;
                fPostScript = TRUE;
                //  don't set border here so -t works
                fPortrait = FALSE;
                fPCondensed = FALSE;
                colMac    = colPSMax;
                rowMac    = rowPSMax;
                }

/* Now the modifiers */

            // Column width to print in
            else if (_strcmpi(szBuf, "c") == 0) {
                szOpt = SzGetSzSz(szOpt, szBuf);
                if (atoi(szBuf) != 0) {
                    defWidth = atoi(szBuf);
                } else {
                        Fatal ("Non-Numeric Columns specified.");
                }
            }

            // LaserJet with the 'B' cartridge
            else if (_strcmpi(szBuf, "cb") == 0 && fLJ)
                usSymSet = BEGINLANDROMAN8;

            // LaserJet emulation of 'IBM' text
            else if (_strcmpi(szBuf, "ci") == 0 && fLJ) {
                usSymSet = BEGINLANDIBMPC; // for the LaserJet
                usCodePage = 850;
            }

            // Code Page specification
            else if (_strcmpi(szBuf, "cp") == 0) {
                szOpt = SzGetSzSz(szOpt, szBuf);
                if (atoi(szBuf) != 0) {
                    usCodePage = (USHORT)atoi(szBuf);
                } else {
                        Fatal ("Non-Numeric CodePage specified.");
                }

            }

            // LaserJet with the 'Z' cartridge
            else if (_strcmpi(szBuf, "cz") == 0 && fLJ)
                usSymSet = BEGINLANDUSASCII;

            // Prep for double sided printing, binding on long edge
            else if ((_strcmpi(szBuf, "d") == 0 || _strcmpi(szBuf, "dv") == 0))
                fVDuplex  = TRUE;

            // Prep for double sided printing, binding on short edge
            else if (_strcmpi(szBuf, "dh") == 0)
                fHDuplex  = TRUE;

            // Extended Ascii printing - shortcut to CP 850
            else if (_strcmpi(szBuf, "ea") == 0) {
                usCodePage = 850;
            }

            // Turn off forced form feed
            else if (_strcmpi(szBuf, "f") == 0)
                fForceFF  = FALSE;

            // Landscape
            else if (_strcmpi(szBuf, "l") == 0 && (fLJ || fPS))
                {
                fPortrait = FALSE;
                colMac    = fLJ ? colLJMax : colPSMax;
                }

            // Portrait
            else if (_strcmpi(szBuf, "p") == 0 && (fLJ || fPS))
                {
                fPortrait = TRUE;
                fBorder   = FALSE;
                colMac    = fLJ ? colLJPortMax : colPSPortMax;
                }

            // Portrait Condensed
            else if (_strcmpi(szBuf, "pc") == 0 && (fLJ || fPS))
                {
                fPortrait = TRUE;
                fPCondensed = TRUE;
                fBorder   = TRUE;
                colMac    = fLJ ? colLJPortMax : colPSPortMax;
                if (cColCom == 0) cColCom   = 2;
                }

            // Number of rows (same as just # by itself, but more descriptive)
            else if (_strcmpi(szBuf, "r") == 0) {
                szOpt = SzGetSzSz(szOpt, szBuf);
                if (atoi(szBuf) != 0) {
                    rowMac = atoi(szBuf);
                    if (rowMac > rowMax)
                        Fatal ("Too many rows (%d) specified.", rowMac);
                } else {
                        Fatal ("Non-Numeric Rows specified.");
                }
            }

            // Force Form Feed
            else if (_strcmpi(szBuf, "s") == 0)
                fForceFF  = TRUE;

            // Number of rows
            else if (isdigit(szBuf[0]) && fLP) {
                rowMac    = atoi(szBuf);
                if (rowMac > rowMax)
                        Fatal("page size %d to long", rowMac);
            }

            else if (_strcmpi(szBuf, "") == 0)
                //  empty string
                ;
            else
                Fatal("unrecognized printer type option %s", szBuf);
            }

/* After the first comma - Tab stop specification */

        if (*szOpt++ == ',')
            {                   //  tabstop
            szOpt = SzGetSzSz(szOpt, szBuf);

            if (isdigit(szBuf[0]))
                colTab = atoi(szBuf);
            else if (szBuf[0] != '\0')
                Fatal("tabstop %s is not a number", szBuf);

/* After the second comma - Column specification (1-9) */

            if (*szOpt++ == ',')
                {               //  # columns (1 - 9)
                szOpt = SzGetSzSz(szOpt, szBuf);

                if (isdigit(szBuf[0]))          //  0 means default # col
                    cCol = szBuf[0] - '0';
                else if (szBuf[0] != '\0')
                    Fatal("number columns (%s) must be digit 1-9",szBuf);
                }
            }
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\library\procconapi.h ===
/*======================================================================================//
|  Windows 2000 Process Control                                                         //
|                                                                                       //
|Copyright (c) 1998, 1999 Sequent Computer Systems, Incorporated.  All rights reserved  //
|                                                                                       //
|File Name:    ProcConAPI.h                                                             //
|                                                                                       //
|Description:  This is the ProcCon header file used by both clients and servers         //
|                                                                                       //
|Created:      Jarl McDonald 07-98                                                      //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/
#ifndef _PROCCONAPI_H_

#define _PROCCONAPI_H_

#include "ProcConLibMsg.h"                 // ProcCon error codes
#define  PCERROR_SUCCESS   ERROR_SUCCESS   // ProcCon non-error error code

//--------------------------------------------------------------------------------------//
//  Consts, typedefs, enums, etc.                                                       //
//--------------------------------------------------------------------------------------//
#define PC_MIN_BUF_SIZE    2048
#define PC_MAX_BUF_SIZE    65536
#define PC_MAX_RETRIES     5        // max retries on communications error

#define PC_MIN_POLL_DELAY 2         // seconds 
#define PC_MAX_POLL_DELAY 900       // seconds 
#define PC_MIN_TIMEOUT    100       // milliseconds: 100 = one-tenth second 
#define PC_MAX_TIMEOUT    120000    // milliseconds: 120000 = 120 seconds == 2 minutes 
#define PC_MIN_TIME_LIMIT 10000000  // CNS - hundred nano-seconds: 10,000,000 = 1 second

//--------------------------------------------------------------------------------------//
// These are the types of name rule matches allowed.                                    //
// These values appear in the match type field of a name rule and may be either case.   //
//--------------------------------------------------------------------------------------//
const WCHAR MATCH_PGM = TEXT('P');
const WCHAR MATCH_DIR = TEXT('D');
const WCHAR MATCH_ANY = TEXT('A');

//--------------------------------------------------------------------------------------//
// These strings are patterns that may appear in the process name field of a name rule. //
// Example: match type is 'D', match string is 'system32', proc name is 'S32:<p>'...    //
//          For program mmc.exe, which has \system32\ in its exe path, will be listed   //
//          in ProcCon with a process name of S32:mmc                                   //
// Example: match type is 'A', match string is '%systemroot%', proc name is '<H>'...    //
//          Any program which has the system root directory as part of its path name    //
//          will not appear (is hidden) in ProcCon process lists.                       //
//--------------------------------------------------------------------------------------//
#define COPY_PGM_NAME   TEXT("<P>")   // replace this pattern with the exe name (all match types)
#define COPY_DIR_NAME   TEXT("<D>")   // replace this patter with the node name (DIR match only)
#define HIDE_THIS_PROC  TEXT("<H>")   // hide this process -- useful to hide std Win2000 procs.

const int PROC_NAME_LEN        = 63;             // does not include terminating NULL
const int PROFILE_NAME_LEN     = 15;             // does not include terminating NULL
const int JOB_NAME_LEN         = 63;             // does not include terminating NULL
const int MATCH_STRING_LEN     = 63;             // does not include terminating NULL
const int NAME_DESCRIPTION_LEN = 63;             // does not include terminating NULL
const int RULE_DESCRIPTION_LEN = 63;             // does not include terminating NULL
const int IMAGE_NAME_LEN       = 63;             // does not include terminating NULL
const int VERSION_STRING_LEN   = 23;             // does not include terminating NULL

typedef unsigned char    BYTE;
typedef unsigned __int16 PCUSHORT16;
typedef unsigned __int32 PCUINT32;
typedef unsigned long    PCULONG32;
typedef unsigned __int64 PCUINT64;
typedef __int16          PCINT16;
typedef __int32          PCINT32;
typedef __int64          PCINT64;
typedef unsigned __int32 PC_MGMT_FLAGS;
typedef unsigned __int32 PC_LIST_FLAGS;
typedef unsigned __int64 AFFINITY;               // Rightmost (least significant) bit = proc 0
typedef unsigned __int32 PRIORITY;               // Valid values are shown in PCPriorities enum below
typedef unsigned __int32 SCHEDULING_CLASS;       // Valid values are 0-9
typedef unsigned __int32 PROC_COUNT;       
typedef unsigned __int64 MEMORY_VALUE;
typedef unsigned __int64 PID_VALUE;
typedef unsigned __int16 MATCH_TYPE;
typedef __int64          TIME_VALUE;
typedef __int32          PCid;
typedef WCHAR            MATCH_STRING[MATCH_STRING_LEN + 1];
typedef WCHAR            PROC_NAME[PROC_NAME_LEN + 1];
typedef WCHAR            PROFILE_NAME[PROFILE_NAME_LEN + 1];
typedef WCHAR            JOB_NAME[JOB_NAME_LEN + 1];
typedef WCHAR            IMAGE_NAME[IMAGE_NAME_LEN + 1];
typedef WCHAR            NAME_DESCRIPTION[NAME_DESCRIPTION_LEN + 1];
typedef WCHAR            RULE_DESCRIPTION[RULE_DESCRIPTION_LEN + 1];
typedef WCHAR            VERSION_STRING[VERSION_STRING_LEN + 1];

typedef struct _PCSystemParms {
    PCINT32        manageIntervalSeconds;        // ProcCon process scan interval in seconds (Read and Write)
    PCINT32        numberOfProcessors;           // System number of processors (Read only)
    PCINT32        memoryPageSize;               // System memory page size (Read only)
    PCINT32        timeoutValueMs;               // Connect and request time out in milliseconds (Read and Write)
    AFFINITY       processorMask;                // System processor mask (Read only)
    PCINT32        future[16];
} PCSystemParms; 
 
typedef struct _PCSystemInfo {
    PCINT32        fixedSignature;     
    PCINT32        fixedFileVersionMS; 
    PCINT32        fixedFileVersionLS;     
    PCINT32        fixedProductVersionMS; 
    PCINT32        fixedProductVersionLS;     
    PCINT32        fixedFileFlags; 
    PCINT32        fixedFileOS;     
    PCINT32        fixedFileType;     
    PCINT32        fixedFileSubtype; 
    PCINT32        fixedFileDateMS;     
    PCINT32        fixedFileDateLS;
    VERSION_STRING productVersion;              // Service product version
    VERSION_STRING fileVersion;                 // Service file version
    VERSION_STRING fileFlags;                   // Service file flags
    VERSION_STRING medProductVersion;           // Mediator product version
    VERSION_STRING medFileVersion;              // Mediator file version
    VERSION_STRING medFileFlags;                // Mediator file flags
    PCINT32        future[32];
    PCSystemParms  sysParms;
} PCSystemInfo;

//--------------------------------------------------------------------------//
// A name table entry that defines a process name.
// Names are derived by matching against a processes path name or exe name.
//
// Match type denotes the method used to test for a match:
//   MATCH_PGM matches against the program (or exe) name excluding the suffix.
//   Program name matches always start at the first character of the program name and
//   are equvalent to 'matches full program name' matching.
//
//   MATCH_DIR matches against the directory (path) node names.
//   A 'path node name' is any name before a backslash ('\') in the full path name.   
//   Directory name matches always start at the first character of a path node name and
//   are equvalent to 'matches a full path node name' matching.
//
//   MATCH_ANY matches against any part of the full name including the path and exe name.
//   This form of matching is a string match against any position in the name and is   
//   equivalent to 'path name contains' matching.
//
// A matchString may contain wildcard characters as follows:
//   ? to match any single character,
//   * to match any number of trailing characters.
// ProcCon does NOT support embedded * wildcards -- they will be treated literally.
//
// A procName may contain one of the patterns shown above such as <P> or <h>.
//
typedef struct _PCNameRule {
#pragma pack(1)
   MATCH_STRING     matchString;     // match string may include * and ? wildcard characters.
   PROC_NAME        procName;        // process name to use when match succeeds.
   NAME_DESCRIPTION description;     // short description with NULL terminator
   MATCH_TYPE       matchType;       // value is MATCH_PGM, MATCH_DIR, or MATCH_ANY.
   BYTE             fill[2];         // Improve alignment of entire structure
#pragma pack()
} PCNameRule;

//--------------------------------------------------------------------------//
// The parameters that defined process group or process behavior and that can be changed by ProcCon.
// Profile refers to a profile defined in ProcCon as a time of day/week/month/etc.
typedef struct _MGMT_PARMS {
#pragma pack(1)
   PROFILE_NAME     profileName;      // Definition is for this profile or, if null, default profile
   RULE_DESCRIPTION description;      // Description text for this rule
   PC_MGMT_FLAGS    mFlags;           // Flags indicating which mgmt data to actually apply, etc.
   AFFINITY         affinity;         // processor affinity to apply (0 => not changed)
   PRIORITY         priority;         // Windows 2000 priority to apply (0 => not changed)
   MEMORY_VALUE     minWS;            // Minimum working set to apply (0 => not changed)
   MEMORY_VALUE     maxWS;            // Maximum working set to apply (0 => not changed)
   SCHEDULING_CLASS schedClass;       // Scheduling class to apply (groups only, not procs)
   PROC_COUNT       procCountLimit;   // Number of processes in the process group (groups only).
   TIME_VALUE       procTimeLimitCNS; // Per process time limit in 100ns (CNS) units or 0.
   TIME_VALUE       jobTimeLimitCNS;  // Per process group time limit in 100ns (CNS) units or 0.
   MEMORY_VALUE     procMemoryLimit;  // Hard memory commit limit per process (groups only).
   MEMORY_VALUE     jobMemoryLimit;   // Hard memory commit limit per process group (groups only).
   BYTE             future[64];
#pragma pack()
} MGMT_PARMS;

//--------------------------------------------------------------------------//
// The statistics associated with a process group.  These are read-only values.
// All these statistics are maintained by Windows 2000 and are part of process group object accounting.
typedef struct _JOB_STATISTICS {
#pragma pack(1)
   TIME_VALUE    TotalUserTime;              // User time for all procs ever run in the process group
   TIME_VALUE    TotalKernelTime;            // Kernel time for all procs ever run in the process group 
   TIME_VALUE    ThisPeriodTotalUserTime;    // User time for all procs ever run in the process group since limit last set
   TIME_VALUE    ThisPeriodTotalKernelTime;  // Kernel time for all procs ever run in the process group since limit last set
   PCUINT32      TotalPageFaultCount;        // Page fault count for all procs ever run in the process group
   PROC_COUNT    TotalProcesses;             // Number of processes ever run or attempted in this process group
   PROC_COUNT    ActiveProcesses;            // Number of processes currently running in this process group (may be 0)
   PROC_COUNT    TotalTerminatedProcesses;   // Number of processes terminated for a limit violation
   PCUINT64      ReadOperationCount;         // Read count for all procs ever in the process group
   PCUINT64      WriteOperationCount;        // Write count for all procs ever in the process group
   PCUINT64      OtherOperationCount;        // Other I/O count for all procs ever in the process group
   PCUINT64      ReadTransferCount;          // Read byte count for all procs ever in the process group
   PCUINT64      WriteTransferCount;         // Write byte count for all procs ever in the process group
   PCUINT64      OtherTransferCount;         // Other I/O byte count for all procs ever in the process group
   MEMORY_VALUE  PeakProcessMemoryUsed;      // Largest process memory used by any process ever in the process group
   MEMORY_VALUE  PeakJobMemoryUsed;          // Largest process group memory ever used
#pragma pack()
} JOB_STATISTICS;

//--------------------------------------------------------------------------//
// The statistics associated with a process.  These are read-only values.
// Additional stats could be obtained via the PerfMon interface but that is
// currently beyond the scope of ProcCon.
// Identifying a particular process within ProcCon is done via both the pid and create time.
typedef struct _PROC_STATISTICS {
#pragma pack(1)
   PID_VALUE     pid;              // process PID (or 0 if not running)
   TIME_VALUE    createTime;       // to uniquely identify with pid (if running)
   TIME_VALUE    TotalUserTime;    // Total user time assigned to the proc
   TIME_VALUE    TotalKernelTime;  // Total kernel time assigned to the proc
#pragma pack()
} PROC_STATISTICS;

//--------------------------------------------------------------------------//
// Summary data about a process definition.
// Summary data includes the name, process group membership, and process management rules.
typedef struct _PCProcSummary {
#pragma pack(1)
   PROC_NAME       procName;              
   JOB_NAME        memberOfJobName;       // member of this process group or null
   MGMT_PARMS      mgmtParms;
   BYTE            future[16];
#pragma pack()
} PCProcSummary;

//--------------------------------------------------------------------------//
// Summary data about a process group definition.
// Summary data includes the name and process group management rules.
typedef struct _PCJobSummary {
#pragma pack(1)
   JOB_NAME        jobName;      
   MGMT_PARMS      mgmtParms;
   BYTE            future[16];
#pragma pack()
} PCJobSummary;

//--------------------------------------------------------------------------//
// Detail data about a process definition.
// Detail data consists of the summary data and a block of variable length character data.
typedef struct _PCProcDetail {
#pragma pack(1)
   PCProcSummary   base;
   WCHAR           future[64];
   PCINT16         vLength;      // length of the variable portion which follows, in bytes
   WCHAR           vData[2];     // variable length portion
#pragma pack()
} PCProcDetail;

//--------------------------------------------------------------------------//
// Detail data about a process group definition.
// Detail data consists of the summary data and a block of variable length character data.
typedef struct _PCJobDetail {
#pragma pack(1)
   PCJobSummary    base;
   WCHAR           future[64];
   PCINT16         vLength;      // length of the variable portion which follows, in bytes
   WCHAR           vData[2];     // variable length portion
#pragma pack()
} PCJobDetail;

//--------------------------------------------------------------------------//
// A process group list entry.
// The process group list consists of all groups that are currently defined, named in a 
// process definition, or are running. (Any process group that has or may need a definition).
typedef struct _PCJobListItem {
#pragma pack(1)
   JOB_NAME         jobName;
   PC_LIST_FLAGS    lFlags;           // shows where found, running or not, etc.
   PRIORITY         actualPriority;   // actual base priority (if running)
   AFFINITY         actualAffinity;   // actual affinity mask (if running)
   SCHEDULING_CLASS actualSchedClass; // actual scheduling class (if running)
   JOB_STATISTICS   jobStats;         // process group statistics (if running)
#pragma pack()
} PCJobListItem;

//--------------------------------------------------------------------------//
// A process list entry.
// The process list consists of all processes that are currently defined, named in a 
// name rule, or are running. (Any process that has or may need a definition).
typedef struct _PCProcListItem {
#pragma pack(1)
   PROC_NAME        procName;         // PC assigned process name
   PC_LIST_FLAGS    lFlags;           // shows where found, running or not, etc.
   PRIORITY         actualPriority;   // actual base priority (if running)
   AFFINITY         actualAffinity;   // actual affinity mask (if running)
   PROC_STATISTICS  procStats;        // process statistics (if running)
   IMAGE_NAME       imageName;        // Windows 2000 'image' (exe) name (if running)
   JOB_NAME         jobName;          // If 'in a process group' flagged, name of group
#pragma pack()
} PCProcListItem;

//--------------------------------------------------------------------------//
typedef enum _PCPriorities {
   PCPrioRealTime    = 24,
   PCPrioHigh        = 13,
   PCPrioAboveNormal = 10,
   PCPrioNormal      =  8,
   PCPrioBelowNormal =  6,
   PCPrioIdle        =  4,
} PCPriorities;

// List response flags -- present in lists only -- not stored as part of any data.  
typedef enum _PCListRspFlags {
   PCLFLAG_IS_RUNNING           = 0x00800000, // Name (process group or process) is currently running.
   PCLFLAG_IS_DEFINED           = 0x00400000, // Name has a definition in ProcCon (but may not request mgmt).
   PCLFLAG_IS_MANAGED           = 0x00200000, // Name has at least one management behavior requested.
   PCLFLAG_IS_IN_A_JOB          = 0x00100000, // Process is assigned to a process group.
   PCLFLAG_HAS_NAME_RULE        = 0x00080000, // Name appears in a name rule as process name.
   PCLFLAG_HAS_MEMBER_OF_JOB    = 0x00040000, // Name appears in a process def as "member of process group".
} PCListRspFlags;

// List request flags -- used with flags argument to PCGetProcList and PCGetJobList.  
typedef enum _PCListReqFlags {
   PC_LIST_ONLY_RUNNING         = 0x00000001, // restrict list to only procs or groups that are running
   PC_LIST_STARTING_WITH        = 0x00000002, // ON = start list with supplied entry or higher (grpname or procname+pid), 
                                              // OFF = start with following entry (used for list continuation)
   PC_LIST_MEMBERS_OF           = 0x00000004, // ON = list only processes that are members of named group, 
                                              //      (other flags still apply).
                                              // OFF = list all items (subject to other flags).
   PC_LIST_MATCH_ONLY           = 0x00000008, // ON = list matching entries only (grp name or proc name+pid). 
} PCListReqFlags;

// Management flags -- part of MGMT_PARMS, stored with process/profile data.  
//   The 'no rules' and 'bad rules' bits will only be set if there are database errors (missing
//   or invalid data).  Not stored with data but set if data cannot be read or decoded.
//
//   The 'apply' bits are set or cleared by clients to control the use of the related management 
//   setting.  This way the management setting can be left intact even when not being used.
//
//   Note that the process group name is not part of the MGMT_PARMS structure while the 'apply' flag for it 
//   DOES appears in MGMT_PARMS.  This is a reflection of the fact that while process group name IS part of 
//   the management data, it cannot be varied by profile since Windows 2000 does not support changes to 
//   process group membership on the fly at present.  So the process group name is moved out of the 
//   management parms to show that it is not part of the profile-dependent data.
typedef enum _PCMgmtFlags {
   PCMFLAG_NORULES                   = 0x80000000,  // No profile or default rules found (not managed)
   PCMFLAG_BADRULES                  = 0x40000000,  // Rules found but could not be used (bad data)
   PCMFLAG_PROC_HAS_JOB_REFERENCE    = 0x08000000,  // Process definition includes a process group name
   PCMFLAG_SET_PROC_BREAKAWAY_OK     = 0x00080000,  // Procs can be created outside process group if requested (groups only).
   PCMFLAG_SET_SILENT_BREAKAWAY      = 0x00040000,  // All procs are created outside process group (groups only)
   PCMFLAG_SET_DIE_ON_UH_EXCEPTION   = 0x00020000,  // Die on unhandled exception flag = no GPF msg box (groups only)
   PCMFLAG_MSG_ON_JOB_TIME_LIMIT_HIT = 0x00008000,  // Hitting process group time limit = logmsg, else fail group (groups only)
   PCMFLAG_END_JOB_WHEN_EMPTY        = 0x00004000,  // Process group is terminated (closed) when empty (groups only)
   PCMFLAG_APPLY_JOB_MEMBERSHIP      = 0x00000800,  // Apply 'member of process group' attribute if supplied
   PCMFLAG_APPLY_PROC_MEMORY_LIMIT   = 0x00000200,  // Apply hard per-proc memory limit (groups only)
   PCMFLAG_APPLY_JOB_MEMORY_LIMIT    = 0x00000100,  // Apply hard per-group memory limit (groups only)
   PCMFLAG_APPLY_AFFINITY            = 0x00000080,  // Apply affinity settings if supplied
   PCMFLAG_APPLY_PRIORITY            = 0x00000040,  // Apply priority settings if supplied
   PCMFLAG_APPLY_WS_MINMAX           = 0x00000020,  // Apply working set min & max if supplied
   PCMFLAG_APPLY_SCHEDULING_CLASS    = 0x00000010,  // Apply scheduling class if supplied (groups only)
   PCMFLAG_APPLY_JOB_TIME_LIMIT      = 0x00000008,  // Apply process group time limit if supplied (groups only)
   PCMFLAG_APPLY_PROC_TIME_LIMIT     = 0x00000004,  // Apply proc time limit if supplied (groups only)
   PCMFLAG_APPLY_PROC_COUNT_LIMIT    = 0x00000002,  // Apply proc count limit if supplied (groups only)
   PCMFLAG_APPLY_ANY_RULE            = 0x00000bfe,  // Apply at least one management rule
   PCMFLAG_SAVEABLE_BITS             = 0x000ecbfe,  // Bits that can be stored in the database (avoid undefined bits)
} PCMgmtFlags;

// Control flags -- use with caution!  Input to PCControlFunction.  
//   These flags are for high-level (non user oriented) control operations.
typedef enum _PCCtlFlags {
   PCCFLAG_START_MEDIATOR         = 0x40000000,  // Attempt to start the mediator process
   PCCFLAG_STOP_MEDIATOR          = 0x20000000,  // Attempt to stop the mediator process
   PCCFLAG_DELALL_NAME_RULES      = 0x00400000,  // Delete all name rules from DB
   PCCFLAG_DELALL_PROC_DEFS       = 0x00200000,  // Delete all process definitions from DB
   PCCFLAG_DELALL_JOB_DEFS        = 0x00100000,  // Delete all process group definitions from DB
   PCCFLAG_SIGNATURE              = 0x80070002,  // These bits must be on in all valid flags
   PCCFLAG_ANTI_SIGNATURE         = 0x0c0000c0,  // These bits must be off in all valid flags
} PCCtlFlags;

//--------------------------------------------------------------------------------------//
//  API function prototypes                                                             //
//--------------------------------------------------------------------------------------//

//--------------------------------------------------------------------------------------
// Infrastructure and Utility Functions...

// PCOpen -- establish connection to PC on named machine.
// Returns:   PCid to use with future PC calls or 0 on error (use PCGetLastError).
// Arguments: 0) pointer to target computer name,
//            1) buffer to be used in server communication or NULL (library allocates).
//            2) size of buffer supplied or to be allocated in bytes. 
PCid PCOpen( const WCHAR *targetComputer, char *buffer, PCUINT32 bufSize );     

// PCClose -- break connection to PC on previously connected machine.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen, 
BOOL PCClose( PCid target );     

// PCGetLastError -- return last error reported for a target
// Returns:   last PC API error for this client.
// Arguments: 0) PCid from PCOpen, 
PCULONG32 PCGetLastError( PCid target );     

// PCGetServiceInfo -- get ProcCon Service indentification and parameters.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) pointer to area to receive system information, 
//            2) size of this area in bytes,
BOOL PCGetServiceInfo( PCid target, PCSystemInfo *sysInfo, PCINT32 nByteCount ); 

// PCSetServiceParms -- set ProcCon Service parameters.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) pointer to area containing new system parameters, 
//            2) size of this area in bytes,
BOOL PCSetServiceParms( PCid target, PCSystemParms *sysParms, PCINT32 nByteCount ); 

// PCControlFunction -- various ProcCon control functions to support restore, etc.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) control flags to describe desired control functions, 
//            2) [optional] data that modifies control function.
BOOL PCControlFunction( PCid target, PCINT32 ctlFlags, PCINT32 ctlData = 0 ); 

// PCKillProcess -- kill the specified process
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) Pid of the process to kill from PCGetProcList statistics, 
//            2) Create time of the process to kill from PCGetProcList statistics.
BOOL PCKillProcess( PCid target, PID_VALUE processPid, TIME_VALUE createTime ); 

// PCKillJob -- kill the specified process group (job)
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) Name of the process group to kill. 
BOOL PCKillJob( PCid target, JOB_NAME jobName ); 

//--------------------------------------------------------------------------------------
// General Retrieval Functions...

// PCGetNameRules -- get fixed-format table containing name rules, one entry per rule.
// Returns:    1 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) pointer to table to receive name rule list, 
//            2) size of this table in bytes,
//            3) [optional, default is 0] index of first entry to return (0-relative),
//            4) [optional] location to store update counter to be supplied on update.
// Notes:     If PCGetLastError returns PCERROR_MORE_DATA, there is more data to retrieve.
//            Name rule order is significant: rules are executed from top to bottom.
PCINT32 PCGetNameRules( PCid target, PCNameRule *pRuleList, PCINT32 nByteCount, 
                        PCINT32 nFirst = 0, PCINT32 *nUpdateCtr = NULL ); 

// PCGetProcSummary -- get fixed-format table summarizing all defined processes.
// Returns:    0 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) pointer to table to receive rule summary list, first entry indicates start point, 
//            2) size of this table in bytes.
//            3) a set of flags used to further specify or limit list operation.
// Notes:     If PCGetLastError returns PCERROR_MORE_DATA, there is more data to retrieve.
//            List entries are in alphabetic order by process name.
PCINT32 PCGetProcSummary( PCid target, PCProcSummary *pProcList, PCINT32 nByteCount, 
                          PCUINT32 listFlags = 0 ); 
 
// PCGetJobSummary -- get fixed-format table summarizing all defined process groups.
// Returns:    0 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) pointer to table to receive rule summary list, first entry indicates start point, 
//            2) size of this table in bytes.
//            3) a set of flags used to further specify or limit list operation.
// Notes:     If PCGetLastError returns PCERROR_MORE_DATA, there is more data to retrieve.
//            List entries are in alphabetic order by process group name.
PCINT32 PCGetJobSummary( PCid target, PCJobSummary *pJobList, PCINT32 nByteCount, 
                         PCUINT32 listFlags = 0 ); 
 
// PCGetJobList -- get list of all defined process groups, both running and not.
// Returns:    0 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) pointer to structure to receive process group list, 
//            2) size of this structure in bytes.
//            3) a set of flags used to further specify or limit list operation.
// Notes:     If PCGetLastError returns PCERROR_MORE_DATA, there is more data to retrieve.
//            List entries are in alphabetic order by process group name.
PCINT32 PCGetJobList( PCid target, PCJobListItem *pJobList, PCINT32 nByteCount, 
                      PCUINT32 listFlags = 0 ); 

// PCGetProcList -- get list of all defined process names, both running and not.
// Returns:    0 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) pointer to structure to receive process list, 
//            2) size of this structure in bytes.
//            3) a set of flags used to further specify or limit list operation.
// Notes:     If PCGetLastError returns PCERROR_MORE_DATA, there is more data to retrieve.
//            List entries are in alphabetic order by process name.
PCINT32 PCGetProcList( PCid target, PCProcListItem *pProcList, PCINT32 nByteCount, 
                       PCUINT32 listFlags = 0 ); 

// PCGetProcDetail -- get full management and descriptive data associated with a process name.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to structure to receive process data, 
//            2) size of this structure in bytes,
//            3) [optional] location to store update counter to be supplied on update.
// Note:      If the process is a member of a process group, the group's management rules will be
//            used instead of the process rules unless the process group definition is missing.
BOOL PCGetProcDetail( PCid target, PCProcDetail *pProcDetail, PCINT32 nByteCount, PCINT32 *nUpdateCtr = NULL ); 

// PCGetJobDetail -- get full management and descriptive data associated with a process group name.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to structure to receive process group data, 
//            2) size of this structure in bytes,
//            3) [optional] location to store update counter to be supplied on update.
BOOL PCGetJobDetail( PCid target, PCJobDetail *pJobDetail, PCINT32 nByteCount, PCINT32 *nUpdateCtr = NULL );


//--------------------------------------------------------------------------------------
// Name Rule Update Functions...

// PCAddNameRule -- add a name rule to the name rule table.
// Returns:    0 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to name rule to add, 
//            2) index of name rule line BEFORE which this addition is to occur (0-based), 
//            3) update counter returned from PCGetNameRules,
//            4-7) [optional] same args as PCGetNameRules to return updated name rule table.
// Note:      If also retrieving list, PCGetLastError returns PCERROR_MORE_DATA if there is 
//            more data to retrieve.  List entries are in alphabetic order by process name.
PCINT32 PCAddNameRule( PCid target, PCNameRule *pRule, PCINT32 nIndex, PCINT32 nUpdateCtr,
                       PCNameRule *pRuleList = NULL, PCINT32 nByteCount = 0, 
                       PCINT32 nFirst = 0, PCINT32 *nNewUpdateCtr = NULL ); 

// PCReplNameRule -- Replace a name rule in the name rule table.
// Returns:    0 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to name rule replacement data, 
//            2) index of name rule line to replace (0-based), 
//            3) update counter returned from PCGetNameRules,
//            4-7) [optional] same args as PCGetNameRules to return updated name rule table.
// Note:      If also retrieving list, PCGetLastError returns PCERROR_MORE_DATA if there is 
//            more data to retrieve.  List entries are in alphabetic order by process name.
PCINT32 PCReplNameRule( PCid target, PCNameRule *pRule, PCINT32 nIndex, PCINT32 nUpdateCtr,
                        PCNameRule *pRuleList = NULL, PCINT32 nByteCount = 0, 
                        PCINT32 nFirst = 0, PCINT32 *nNewUpdateCtr = NULL ); 

// PCDeleteNameRule -- Delete a name rule from the name rule table.
// Returns:    0 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) index of name rule line to delete (0-based), 
//            2) update counter returned from PCGetNameRules,
//            3-6) [optional] same args as PCGetNameRules to return updated name rule table.
// Note:      If also retrieving list, PCGetLastError returns PCERROR_MORE_DATA if there is 
//            more data to retrieve.  List entries are in alphabetic order by process name.
PCINT32 PCDeleteNameRule( PCid target, PCINT32 nIndex, PCINT32 nUpdateCtr,
                          PCNameRule *pRuleList = NULL, PCINT32 nByteCount = 0, 
                          PCINT32 nFirst = 0, PCINT32 *nNewUpdateCtr = NULL ); 

// PCSwapNameRules -- Swap the order of two adjacent entries in the name rule table.  
// Note:      This API is needed because the order of entires in the table is significant.
// Returns:    0 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) index of name rule line to swap with line index+1 (0-based), 
//            2) update counter returned from PCGetNameRules,
//            3-5) [optional] same args as PCGetNameRules to return updated name rule table.
// Note:      If also retrieving list, PCGetLastError returns PCERROR_MORE_DATA if there is 
//            more data to retrieve.  List entries are in alphabetic order by process name.
PCINT32 PCSwapNameRules( PCid target, PCINT32 nIndex, PCINT32 nUpdateCtr,
                         PCNameRule *pRuleList = NULL, PCINT32 nByteCount = 0, 
                         PCINT32 nFirst = 0, PCINT32 *nNewUpdateCtr = NULL ); 


//--------------------------------------------------------------------------------------
// Process data Update Functions...

// PCAddProcDetail -- add a new process definition to the process management database.
// Returns:   1 on success (treat as TRUE or as a count if summary item requested).
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to process detail to add, name must not exist.
//            2) [optional] pointer to buffer to retrieve updated proc summary for this entry.
// Note:      No update counter is needed for adding since add fails if the name 
//            exists.
BOOL PCAddProcDetail( PCid target, PCProcDetail *pProcDetail, PCProcSummary *pProcList = NULL ); 

// PCDeleteProcDetail -- Delete a process definition from the process management database.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to process detail to Delete, name must exist,
// Notes:     1) No update counter is needed for deleting since delete fails if the name 
//            doesn't exist.
//            2) Since this is a delete operation, a complete PCProcDetail is not necessary.
//            The pointer may also point to a PCProcSummary item.
BOOL PCDeleteProcDetail( PCid target, PCProcDetail *pProcDetail ); 

// PCReplProcDetail -- Replace a process definition in the process management database.
// Returns:   1 on success (treat as TRUE or as a count if summary item requested).
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to process detail to replace, name must exist,
//            2) update counter from PCGetProcDetail.
//            3) [optional] pointer to buffer to retrieve updated proc summary for this entry.
BOOL PCReplProcDetail( PCid target, PCProcDetail *pProcDetail, PCINT32 nUpdateCtr, 
                       PCProcSummary *pProcList = NULL ); 


//--------------------------------------------------------------------------------------
// Process Group (Job) data Update Functions...

// PCAddJobDetail -- add a new process group definition to the process group management database.
// Returns:   1 on success (treat as TRUE or as a count if summary item requested).
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to process group detail to add, name must not exist,
//            2) [optional] pointer to buffer to retrieve updated process group summary for this entry.
// Note:      No update counter is needed for adding since add fails if the name 
//            exists.
BOOL PCAddJobDetail( PCid target, PCJobDetail *pJobDetail, PCJobSummary *pJobList = NULL ); 

// PCDeleteJobDetail -- Delete a process group definition from the process group management database.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to process group detail to Delete, name must exist,
// Notes:     1) No update counter is needed for deleting since delete fails if the name 
//            doesn't exist.
//            2) Since this is a delete operation, a complete PCJobDetail is not necessary.
//            The pointer may also point to a PCJobSummary item.
BOOL PCDeleteJobDetail( PCid target, PCJobDetail *pJobDetail ); 

// PCReplJobDetail -- Replace a process group definition in the process group management database.
// Returns:   1 on success (treat as TRUE or as a count if summary item requested).
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to process group detail to replace, name must exist,
//            2) update counter from PCGetJobDetail.
//            3) [optional] pointer to buffer to retrieve updated process group summary for this entry.
BOOL PCReplJobDetail( PCid target, PCJobDetail *pJobDetail, PCINT32 nUpdateCtr,
                      PCJobSummary *pJobList = NULL ); 

#endif  // _PROCCONAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\clitool\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CLITOOL.rc
//
#define IDS_PATCHED                     100
#define IDS_DEBUG                       101
#define IDS_BETA                        102
#define IDI_CLI_TOOL                    102
#define CLI_PROMPT                      103
#define COLHEAD_ALIAS_RULE_NUMBER       104
#define COLHEAD_ALIAS_MATCH_TYPE        105
#define COLHEAD_ALIAS_MATCH_DATA_SHORT  106
#define COLHEAD_ALIAS_MATCH_DATA_LONG   107
#define COLHEAD_ALIAS_NAME_LONG         108
#define COLHEAD_ALIAS_NAME_SHORT        109
#define COLHEAD_ALIAS_DESCRIPTION_LONG  110
#define COLHEAD_ALIAS_DESCRIPTION_SHORT 111
#define COLHEAD_PROCLIST_FLAGS          112
#define COLHEAD_PROCLIST_PID            113
#define COLHEAD_PROCLIST_PROCESS_ALIAS_LONG 114
#define COLHEAD_PROCLIST_PROCESS_ALIAS_SHORT 115
#define COLHEAD_PROCLIST_IMAGE_NAME_LONG 116
#define COLHEAD_PROCLIST_IMAGE_NAME_SHORT 117
#define COLHEAD_PROCLIST_MEMBER_OF_GROUP_LONG 118
#define COLHEAD_PROCLIST_MEMBER_OF_GROUP_SHORT 119
#define COLHEAD_PROCLIST_PRIORITY       120
#define COLHEAD_PROCLIST_AFFINITY       121
#define COLHEAD_PROCLIST_USER_TIME      122
#define COLHEAD_PROCLIST_KERNEL_TIME    123
#define COLHEAD_PROCLIST_CREATE_TIME    124
#define COLHEAD_BASEPROCDATA_FLAGS      125
#define COLHEAD_BASEPROCDATA_GROUP_NAME_LONG 126
#define COLHEAD_BASEPROCDATA_GROUP_NAME_SHORT 127
#define COLHEAD_BASEPROCDATA_PRIORITY   128
#define COLHEAD_BASEPROCDATA_AFFINITY   129
#define COLHEAD_BASEPROCDATA_SCHED_CLASS 130
#define COLHEAD_IO_PROCDATA_READ_OPS    131
#define COLHEAD_IO_PROCDATA_WRITE_OPS   132
#define COLHEAD_IO_PROCDATA_OTHER_OPS   133
#define COLHEAD_IO_PROCDATA_READ_BYTES  134
#define COLHEAD_IO_PROCDATA_WRITE_BYTES 135
#define COLHEAD_IO_PROCDATA_OTHER_BYTES 136
#define COLHEAD_MEM_PROCDATA_PAGE_FAULTS 137
#define COLHEAD_MEM_PROCDATA_PEAK_PROC  138
#define COLHEAD_MEM_PROCDATA_PEAK_GROUP 139
#define COLHEAD_PROC_PROCDATA_CURR_PROCS 140
#define COLHEAD_PROC_PROCDATA_TERM_PROCS 141
#define COLHEAD_PROC_PROCDATA_TOTAL_PROCS 142
#define COLHEAD_TIME_PROCDATA_USER_TIME 143
#define COLHEAD_TIME_PROCDATA_KERNEL_TIME 144
#define COLHEAD_TIME_PROCDATA_USER_INTVL 145
#define COLHEAD_TIME_PROCDATA_KERNEL_INTVL 146
#define COLHEAD_GRPSUMMARY_GRPNAME_LONG 147
#define COLHEAD_GRPSUMMARY_GRPNAME_SHORT 148
#define COLHEAD_GRPSUMMARY_FLAGS        149
#define COLHEAD_GRPSUMMARY_AFFINITY     150
#define COLHEAD_GRPSUMMARY_PRIORITY     151
#define COLHEAD_GRPSUMMARY_SCHDCLASS    152
#define COLHEAD_GRPSUMMARY_PROCESS_MEMORY 153
#define COLHEAD_GRPSUMMARY_GROUP_MEMORY 154
#define COLHEAD_GRPSUMMARY_PROCESS_TIME 155
#define COLHEAD_GRPSUMMARY_GROUP_TIME   156
#define COLHEAD_GRPSUMMARY_PROCESS_COUNT 157
#define COLHEAD_GRPSUMMARY_WORKSET_MIN  158
#define COLHEAD_GRPSUMMARY_WORKSET_MAX  159
#define COLHEAD_PROCSUMMARY_PROCNAME_LONG 160
#define COLHEAD_PROCSUMMARY_PROCNAME_SHORT 161
#define COLHEAD_PROCSUMMARY_GRPNAME_LONG 162
#define COLHEAD_PROCSUMMARY_GRPNAME_SHORT 163
#define COLHEAD_PROCSUMMARY_FLAGS       164
#define COLHEAD_PROCSUMMARY_AFFINITY    165
#define COLHEAD_PROCSUMMARY_PRIORITY    166
#define COLHEAD_PROCSUMMARY_WORKSET_MIN 167
#define COLHEAD_PROCSUMMARY_WORKSET_MAX 168
#define COLHEAD_SEPARATOR_CHAR          169
#define VERB_NAME_ADD                   170
#define VERB_NAME_REPLACE               171
#define VERB_NAME_DELETE                172
#define VERB_NAME_SWAP                  173
#define VERB_NAME_LIST                  174
#define VERB_NAME_UPDATE                175
#define VERB_NAME_KILL                  176
#define VERB_NAME_DUMP                  177
#define VERB_NAME_RESTORE               178
#define DATA_NAME_ALIAS                 179
#define DATA_NAME_GROUP                 180
#define DATA_NAME_PROCESS               181
#define DATA_NAME_VERSION               182
#define DATA_NAME_MEDIATOR              183
#define DATA_NAME_PROCCON               184
#define SUBDATA_NAME_DEFINITION         185
#define SUBDATA_NAME_SUMMARY            186
#define SUBDATA_NAME_LIST               187
#define SUBDATA_NAME_PROCCON_DATA       188

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\library\procconclnt.h ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998, 1999  Sequent Computer Systems, Incorporated                       //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|---------------------------------------------------------------------------------------//            
|  This file is the ProcCon header file showing 'on the wire' data for clients/service  //
|---------------------------------------------------------------------------------------//            
|                                                                                       //
|Created:                                                                               //
|                                                                                       //
|   Jarl McDonald 07-98                                                                 //
|                                                                                       //
|Revision History:                                                                      //
|                                                                                       //
|=======================================================================================*/

// Requests flow from clients to the service.  They contain at most one API data item.
typedef struct _PCRequest {
#pragma pack(1)
   PCINT32 reqSignature;       // sanity check signature
   PCINT32 reqSeq;             // requestor sequence number
   BYTE    reqOp;              // requested operation: list, add, replace, delete, etc.
   BYTE    reqType;            // requested data type: name rule, mgmt rule, mgmt detail, etc.
   BYTE    reqVersion;         // expected data version code: to support structure changes over time
   BYTE    future[5];          // fill to 8-byte bdry
   PCINT32 reqFlags;           // flags for additional information
   PCINT32 reqUpdCtr;          // requestor's update counter from prior retrieval operation.
   PCINT64 reqIndex;           // requestor's insertion point, etc.
   PCINT32 reqCount;           // requestor's returned data item maximum count
   PCINT32 reqFirst;           // requestor's first data item retrieval index
   PCINT32 maxReply;           // max user data in reply (excludes reply header)
   PCINT16 reqDataLen;         // length of the single data item that follows or 0 if none.  In bytes.
   BYTE    reqFuture[32];
   BYTE    reqData[2];         // data item -- one of the API structures
#pragma pack()
} PCRequest;

// Responses flow from the service to clients.  They may contain many data items.
typedef struct _PCResponse {
#pragma pack(1)
   PCINT32 rspReqSignature;    // echo of sanity check signature
   PCINT32 rspReqSeq;          // echo of requestor sequence number
   BYTE    rspReqOp;           // echo of original request operation
   BYTE    rspReqType;         // echo of original request data type
   BYTE    rspReqVersion;      // echo of original data version code
   BYTE    rspVersion;         // response version: indicates version of data items returned
   BYTE    rspResult;          // operation result: success, failure, addl info, etc.
   BYTE    future[3];          // fill to 8-byte bdry
   PCINT32 rspFlags;           // flags for additional information
   PCINT32 rspError;           // NT or PC error resulting from the request if rspResult shows error
   PCINT32 rspTimeStamp;       // time stamp associated with the data returned
   PCINT32 rspUpdCtr;          // Update counter to use on future related operations.
   PCINT16 rspDataItemCount;   // number of data items that follow or 0.
   PCINT16 rspDataItemLen;     // length of each data item that follows or 0.  In bytes.
   BYTE    rspFuture[32];
   BYTE    rspData[2];         // data items -- an array of one of the API structures
#pragma pack()
} PCResponse;

typedef enum _PCReqOp {
   PCOP_GET    = 1,
   PCOP_ADD    = 2,
   PCOP_REP    = 3,
   PCOP_DEL    = 4,
   PCOP_ORD    = 5,
   PCOP_CTL    = 6,          
   PCOP_KILL   = 7,          
} PCReqOp;

typedef enum _PCReqRspType {
   PCTYPE_NAMERULE    = 1,
   PCTYPE_JOBSUMMARY  = 2,
   PCTYPE_PROCSUMMARY = 3,
   PCTYPE_PROCLIST    = 4,
   PCTYPE_JOBLIST     = 5,
   PCTYPE_PROCDETAIL  = 6,
   PCTYPE_JOBDETAIL   = 7,
   PCTYPE_SERVERINFO  = 8,
   PCTYPE_SERVERPARMS = 9,
   PCTYPE_CONTROL     = 77,
} PCReqRspType;

typedef enum _PCRspResult {
   PCRESULT_SUCCESS  = 0,
   PCRESULT_NTERROR  = 1,
   PCRESULT_PCERROR  = 2,
} PCRspResult;

typedef enum _PCReqFlags {
   PCREQFLAG_DOLIST  = 0x00000001,                 // perform a list op (based on data) after doing op
} PCReqFlags;

typedef enum _PCRspFlags {
   PCRSPFLAG_MOREDATA  = 0x00000001,               // more data exists
} PCRspFlags;

// End of ProcConClnt.h
//============================================================================J McDonald fecit====//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\mediate\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MEDIATE.rc
//
#define IDS_PATCHED                     100
#define IDS_DEBUG                       101
#define IDS_BETA                        102
#define IDI_CLI_TOOL                    102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\mediate\pcmediate.cpp ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998, 1999 Sequent Computer Systems, Incorporated.  All rights reserved. //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|   Windows 2000 Process Control 'mediator' process.  Holds handles and completion port //
|   for created jobs so that their names are not lost if the ProcCon service is stopped // 
|   or goes away.                                                                       //
|                                                                                       //
|Created:                                                                               //
|                                                                                       //
|   Jarl McDonald 04-99                                                                 //
|                                                                                       //
|Revision History:                                                                      //
|                                                                                       //
|=======================================================================================*/
#include "..\SERVICE\ProcConSvc.h"

//=======================================================================================
// Main...
//=======================================================================================
int _cdecl main( void ) {

   // Load our strings so we have proper reporting, etc.
   PCLoadStrings();
   CVersion *versionInfo = new CVersion( GetModuleHandle( NULL ) );

   static const TCHAR * const msgs[] = { PROCCON_MEDIATOR_DISP_NAME, PROCCON_SVC_DISP_NAME };

   // Make sure we're not already running and set up mutual exclusion...
   if ( !PCSetIsRunning( PC_MEDIATOR_EXCLUSION, PROCCON_MEDIATOR_DISP_NAME ) ) 
      return 1;

   // Get our event -- it must already exist (created by the service) or we quit...
   HANDLE hSvcEvent = CreateEvent( NULL, FALSE, FALSE, PC_MEDIATOR_EVENT );
   if ( !hSvcEvent ) {
      PCLogUnExError( PC_MEDIATOR_EVENT, TEXT("MediatorCreateEvent") );
      return 1;
   }
   else if ( GetLastError() != ERROR_ALREADY_EXISTS ) {
      PCLogMessage( PC_MEDIATE_SVC_NEVER_STARTED, EVENTLOG_ERROR_TYPE, ENTRY_COUNT(msgs), msgs );
      CloseHandle( hSvcEvent );
      return 1;
   }

   // Get our file mapping object -- it must already exist (created by the service) or we quit...
   HANDLE hSvcJobMap = CreateFileMapping( HANDLE_FF_64, NULL, PAGE_READWRITE, 
                                          0, sizeof(PCMediateHdr), PC_MEDIATOR_FILEMAP );
   if ( !hSvcJobMap ) {
      PCLogUnExError( PC_MEDIATOR_FILEMAP, TEXT("MediatorCreateMapping") );
      CloseHandle( hSvcEvent );
      return 1;
   }
   else if ( GetLastError() != ERROR_ALREADY_EXISTS ) {
      PCLogMessage( PC_MEDIATE_SVC_NEVER_STARTED, EVENTLOG_ERROR_TYPE, ENTRY_COUNT(msgs), msgs );
      CloseHandle( hSvcJobMap );
      CloseHandle( hSvcEvent );
      return 1;
   }

   // Get our data pointer -- quit if we can't since we'd have nothing to do.
   PCMediateHdr *jobData = (PCMediateHdr *) MapViewOfFile( hSvcJobMap, FILE_MAP_WRITE, 0, 0, 0 );
   if ( !jobData ) {
      PCLogUnExError( PC_MEDIATOR_FILEMAP, TEXT("MediatorMapJobData") );
      CloseHandle( hSvcJobMap );
      CloseHandle( hSvcEvent );
      return 1;
   }

   // Update data about us in case we restarted...
   jobData->medProcessInfo.dwProcessId = GetCurrentProcessId();
   jobData->medProcessInfo.dwThreadId  = GetCurrentThreadId();

   _tcsncpy( jobData->medFileVersion,    versionInfo->GetFileVersion(),    VERSION_STRING_LEN );
   _tcsncpy( jobData->medProductVersion, versionInfo->GetProductVersion(), VERSION_STRING_LEN );
   _tcsncpy( jobData->medFileFlags,      versionInfo->GetFileFlags(),      VERSION_STRING_LEN );

   // Duplicate ProcCon's completion port handle here to preserve it...
   HANDLE hServiceProc = OpenProcess( PROCESS_DUP_HANDLE, FALSE, (DWORD) jobData->svcPID );  // truncation of PID to 32-bit
   if ( !hServiceProc ) {
      PCLogUnExError( jobData->svcPID, TEXT("MediatorOpenSvcPID") );
      CloseHandle( hSvcJobMap );
      CloseHandle( hSvcEvent );
      return 1;
   }

   if ( !DuplicateHandle( hServiceProc,
                          jobData->svcPortHandle,
                          GetCurrentProcess(),
                          &jobData->medPortHandle,
                          NULL,
                          FALSE,
                          DUPLICATE_SAME_ACCESS ) )
      PCLogUnExError( TEXT("ComplPort"), TEXT("MediatorDupHandle") );

   CloseHandle( hServiceProc );

   // We're ready to run.  On the first pass we'll open all jobs.  Otherwise just the new jobs.
   ResetEvent( hSvcEvent );                              // don't need to be signalled for first pass 
   for ( BOOL firstPass = TRUE; ; firstPass = FALSE ) {
      // duplicate all chained block handles as needed...
      jobData->MedChainBlocks( firstPass );
      // duplicate all job object handles in chain as needed...
      for ( PCMediateBlock *blk = &jobData->groupBlock; blk; blk = jobData->NextBlock( blk ) ) {
         for ( PCULONG32 grp = 0; grp < blk->groupCount; ++grp ) {
            if ( firstPass && !(blk->group[grp].groupFlags & PCMEDIATE_CLOSE_ME) ) {
               blk->group[grp].mediatorHandle = 
                  OpenJobObject( JOB_OBJECT_QUERY, FALSE, blk->group[grp].groupName );
               if ( !blk->group[grp].mediatorHandle )
                  PCLogUnExError( blk->group[grp].groupName, TEXT("MediatorOpenJob1") );
            }
            else if ( blk->group[grp].groupFlags & PCMEDIATE_CLOSE_ME ) {
               if ( blk->group[grp].mediatorHandle && !CloseHandle( blk->group[grp].mediatorHandle ) )
                  PCLogUnExError( blk->group[grp].groupName, TEXT("MediatorCloseJob") );
               blk->group[grp].mediatorHandle = NULL;
            }
            else if ( !blk->group[grp].mediatorHandle ) {
               blk->group[grp].mediatorHandle = 
                  OpenJobObject( JOB_OBJECT_QUERY, FALSE, blk->group[grp].groupName );
               if ( !blk->group[grp].mediatorHandle )
                  PCLogUnExError( blk->group[grp].groupName, TEXT("MediatorOpenJob2") );
            }
         }
      }
      // Wait for signal that a new job exists.
      // If the wait fails, just exit, else we reprocess job list...
      if ( WAIT_OBJECT_0 != WaitForSingleObject( hSvcEvent, INFINITE ) )
         break;
   }

   CloseHandle( hSvcJobMap );
   CloseHandle( hSvcEvent );
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\service\cprocconclient.cpp ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated                             //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|---------------------------------------------------------------------------------------//            
|    This file implements the CProcConClient class methods defined in ProcConSvc.h      //
|---------------------------------------------------------------------------------------//            
|                                                                                       //
|Created:                                                                               //
|                                                                                       //
|   Jarl McDonald 07-98                                                                 //
|                                                                                       //
|Revision History:                                                                      //
|                                                                                       //
|=======================================================================================*/
#include "ProcConSvc.h"

const  PCINT32  SIGNATURE = 0xd06eface;

// CProcConClient Constructor...
CProcConClient::CProcConClient( ClientContext *ctxt ) :     m_impersonating( FALSE ),
                          m_cPC( *ctxt->cPC ),              m_cDB( *ctxt->cDB ), 
                          m_cUser( *ctxt->cUser ), 
                          m_hPipe( ctxt->hPipe),            m_clientNo( ctxt->clientNo ),
                          m_inBufChars( ctxt->inBufChars ), m_outBufChars( ctxt->outBufChars )
{
   delete ctxt;            // we're done with this

   m_inBuf = (TCHAR *) new char[m_inBufChars];
   if ( !m_inBuf ) PCLogNoMemory( TEXT("AllocInBuffer"), m_inBufChars );

   m_outBuf = (TCHAR *) new char[m_outBufChars];
   if ( !m_outBuf ) PCLogNoMemory( TEXT("AllocOutBuffer"), m_outBufChars );

   m_hReadEvent  = CreateEvent( NULL, TRUE, FALSE, NULL );
   if ( !m_hReadEvent ) 
      PCLogUnExError( TEXT("PipeRead"), TEXT("CreateEvent") );

   m_hWriteEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
   if ( !m_hWriteEvent ) 
      PCLogUnExError( TEXT("PipeWrite"), TEXT("CreateEvent") );

   memset( &m_olRead,  0, sizeof(m_olRead )  );
   memset( &m_olWrite, 0, sizeof(m_olWrite ) );
   m_olRead.hEvent  = m_hReadEvent;
   m_olWrite.hEvent = m_hWriteEvent;

}

// CProcConClient Destructor...
CProcConClient::~CProcConClient( void ) 
{
   if ( m_hPipe ) {
      FlushFileBuffers( m_hPipe ); 
      DisconnectNamedPipe( m_hPipe ); 
      CloseHandle( m_hPipe );
      m_hPipe = NULL;
      if ( m_impersonating && !RevertToSelf() )
         PCLogUnExError( TEXT("PCClient"), TEXT("RevertToSelf") );
   }

   if ( m_hReadEvent  ) CloseHandle( m_hReadEvent );
   if ( m_hWriteEvent ) CloseHandle( m_hWriteEvent );
   if ( m_inBuf       ) delete [] ((char *) m_inBuf);
   if ( m_outBuf      ) delete [] ((char *) m_outBuf);
   m_hReadEvent = m_hWriteEvent = m_inBuf = m_outBuf = NULL;
}
 
//--------------------------------------------------------------------------------------------//
// Function to determine if all CProcConClient initial conditions have been met               //
// Input:    None                                                                             //
// Returns:  TRUE if ready, FALSE if not                                                      //
//--------------------------------------------------------------------------------------------//
BOOL CProcConClient::ReadyToRun( void ) {
   return m_hPipe && m_hReadEvent && m_hWriteEvent && m_inBuf && m_outBuf;
}

//--------------------------------------------------------------------------------------------//
// CProcConClient thread function -- this function runs in its own thread                     //
// This function handles all pipe reads, writes and processing for a single connection.       //
// Input:    None                                                                             //
// Returns:  0                                                                                //
// Note:     This thread owns the pipe that it is constructed with and terminates             // 
//           when the pipe is closed by the client.                                           //
//--------------------------------------------------------------------------------------------//
PCULONG32 CProcConClient::Run( void ) 
{ 
   PCULONG32 bytesDone, bytesToWrite, rc;
   HANDLE    waitList[] = { m_olRead.hEvent, m_olWrite.hEvent, m_cPC.GetShutEvent() };
   BOOL      inBufEmpty = TRUE, outBufEmpty = TRUE, reading = FALSE, writing = FALSE;

   for ( BOOL quit = FALSE; !quit && !m_cPC.GotShutdown(); ) {
      
      // Initiate pipe read if needed...
      if ( !reading && inBufEmpty ) {
         rc = ReadFile( m_hPipe, m_inBuf, m_inBufChars, &bytesDone, &m_olRead );
         if ( !rc && GetLastError() != ERROR_IO_PENDING ) {
            if ( GetLastError() != ERROR_BROKEN_PIPE )
               PCLogUnExError( TEXT("PCClient"), TEXT("ReadPipe") );
            quit = TRUE;
         }
         else reading = TRUE;
      }

      // Process any pending data...
      if ( !writing && outBufEmpty && !inBufEmpty ) {
         inBufEmpty = TRUE;
         if ( ProcessRequest( bytesDone, &bytesToWrite ) )
            outBufEmpty = FALSE;
      }

      // Initiate pipe write if needed...
      if ( !writing && !outBufEmpty ) {
         rc = WriteFile( m_hPipe, m_outBuf, bytesToWrite, &bytesDone, &m_olWrite );
         if ( !rc  && GetLastError() != ERROR_IO_PENDING ) {
            if ( GetLastError() != ERROR_BROKEN_PIPE && GetLastError() != ERROR_NO_DATA )
               PCLogUnExError( TEXT("PCClient"), TEXT("WritePipe") );
            quit = TRUE;
         }
         else writing = TRUE;
      }

      // If we're quitting, don't enter wait...
      if ( quit || m_cPC.GotShutdown() ) continue;

      // Wait for something to happen...
      rc = WaitForMultipleObjects( ENTRY_COUNT( waitList ), waitList, FALSE, INFINITE );
      if ( rc == WAIT_FAILED ) {
         PCLogUnExError( TEXT("PCClient"), TEXT("Wait") );
         break;
      }

      // Process wait completion...
      switch ( rc - WAIT_OBJECT_0 ) {
      case 0:   // read completed
         reading = inBufEmpty = FALSE;
         if ( !GetOverlappedResult( m_hPipe, &m_olRead, &bytesDone, TRUE ) ) {
            if ( GetLastError() != ERROR_BROKEN_PIPE && GetLastError() != ERROR_NO_DATA )
               PCLogUnExError( TEXT("PCClient"), TEXT("ReadResult") );
            quit = TRUE;
         }
         ResetEvent( m_olRead.hEvent );
         break;
      case 1:   // write completed
         writing = FALSE;
         outBufEmpty = TRUE;
         if ( !GetOverlappedResult( m_hPipe, &m_olWrite, &bytesDone, TRUE ) || bytesToWrite != bytesDone ) {
            if ( GetLastError() != ERROR_BROKEN_PIPE && GetLastError() != ERROR_NO_DATA )
               PCLogUnExError( TEXT("PCClient"), TEXT("WriteResult") );
            quit = TRUE;
         }
         ResetEvent( m_olWrite.hEvent );
         break;
      case 2:   // quit requested
         break;
      } // end switch

   }
   return 0;
} 

//--------------------------------------------------------------------------------------------//
// Function to handle impersonation on a request by request basis.  All decisions about which //
// types of requests require client impersonation are made in this function.                  //
// Input:    request                                                                          //
// Returns:  TRUE if impersonation was properly set, FALSE otherwise                          //
//--------------------------------------------------------------------------------------------//
BOOL CProcConClient::Impersonate( PCRequest *req ) {
   switch (req->reqType) {
   case PCTYPE_PROCLIST:               // impersonation not required
       break;

   case PCTYPE_NAMERULE:               // impersonation required
   case PCTYPE_JOBSUMMARY:
   case PCTYPE_PROCSUMMARY:
   case PCTYPE_JOBLIST:
   case PCTYPE_PROCDETAIL:
   case PCTYPE_JOBDETAIL:
   case PCTYPE_SERVERINFO:
   case PCTYPE_SERVERPARMS:
   case PCTYPE_CONTROL:
       if ( !ImpersonateNamedPipeClient( m_hPipe ) ) {
          PCLogUnExError( TEXT("PCClient"), TEXT("Impersonate") );
          return FALSE;
       }
       m_impersonating = TRUE;
       break;

   default:
       SetLastError( PCERROR_INVALID_REQUEST );
       return FALSE;
   }

   return TRUE;
}

//--------------------------------------------------------------------------------------------//
// Function to deactivate client impersonation on a request by request basis.  This function  //
// just uses the m_impersonation flag to determine if impersonation is currently in effect.   //
// Input:    request                                                                          //
// Returns:                                                                                   //
//--------------------------------------------------------------------------------------------//
void CProcConClient::UnImpersonate( PCRequest *req ) {
    if (m_impersonating && !RevertToSelf()) {
       PCLogUnExError( TEXT("PCClient"), TEXT("RevertToSelf") );
    }
}

//--------------------------------------------------------------------------------------------//
// Function to process a request in the input buffer and build a response in the output buffer//
// Input:    Number of bytes in the input buffer, location to store output buffer length      //
// Returns:  TRUE if output is to be written, else FALSE                                      //
//--------------------------------------------------------------------------------------------//
BOOL CProcConClient::ProcessRequest( PCULONG32 inLen, PCULONG32 *outLen ) {

   PCRequest  *req = (PCRequest *)  m_inBuf;
   PCResponse *rsp = (PCResponse *) m_outBuf;
   PrimeResponse( rsp, req );

   // Perform cursory checks on incoming request length and contents...
   PCULONG32 hdrBytesExpected = sizeof(PCRequest) - sizeof(req->reqData);
   if ( inLen < hdrBytesExpected       || 
        req->reqSignature != SIGNATURE ||
        inLen < hdrBytesExpected + req->reqDataLen ) {
      return ErrorResponse( PCERROR_INVALID_REQUEST, rsp, outLen );
   }

   if (!Impersonate( req )) {
       PCLogUnExError( TEXT("PCClient"), TEXT("Impersonate") );
       return ErrorResponse( GetLastError(), rsp, outLen ); 
   }

   ULONG rc = 0;

   // Switch on requested data type to process it...
   switch ( req->reqType ) {
   case PCTYPE_NAMERULE:
      rc = DoNameRules( req, rsp, outLen );
      break;

   case PCTYPE_JOBSUMMARY:
      rc = DoJobSummary( req, rsp, outLen );
      break;

   case PCTYPE_PROCSUMMARY:
      rc = DoProcSummary( req, rsp, outLen );
      break;

   case PCTYPE_PROCDETAIL:
      rc = DoProcDetail( req, rsp, outLen );
      break;

   case PCTYPE_JOBDETAIL:
      rc = DoJobDetail( req, rsp, outLen );
      break;

   case PCTYPE_PROCLIST:
      rc = DoProcList( req, rsp, outLen );
      break;

   case PCTYPE_JOBLIST:
      rc = DoJobList( req, rsp, outLen );
      break;

   case PCTYPE_SERVERINFO:
      rc = DoServerInfo( req, rsp, outLen );
      break;

   case PCTYPE_SERVERPARMS:
      rc = DoServerParms( req, rsp, outLen );
      break;

   case PCTYPE_CONTROL:
      rc = DoControl( req, rsp, outLen );
      break;

   default:
      rc = ErrorResponse( PCERROR_INVALID_REQUEST, rsp, outLen );
   }  // end switch

   UnImpersonate( req );
   return rc;
}

//--------------------------------------------------------------------------------------------//
// Function to prime a response structure with local data and request data                    //
// Input:    pointers to request and response structures                                      //
//--------------------------------------------------------------------------------------------//
void CProcConClient::PrimeResponse( PCResponse *rsp, PCRequest *req ) {

   memset( rsp, 0, sizeof(*rsp) );
   
   rsp->rspReqSignature = SIGNATURE;            // sanity check signature
   rsp->rspReqSeq       = req->reqSeq;          // echo of requestor sequence number
   rsp->rspReqOp        = req->reqOp;           // echo of original request operation
   rsp->rspReqType      = req->reqType;         // echo of original request data type
   rsp->rspReqVersion   = req->reqVersion;      // echo of original request data version
   rsp->rspVersion      = 1;                    // 1 for base version
   rsp->rspTimeStamp    = (PCINT32) time( NULL );  // $$  // time stamp associated with the data returned
}

//--------------------------------------------------------------------------------------------//
// Function to build an error response in the output buffer                                   //
// Input:    Error code, request pointer, location to store output buffer length              //
// Returns:  TRUE if output is to be written, else FALSE                                      //
//--------------------------------------------------------------------------------------------//
BOOL CProcConClient::ErrorResponse( PCULONG32 errCode, PCResponse *rsp, PCULONG32 *outLen ) {

   rsp->rspResult        = (BYTE) (errCode & 0xf0000000 ? PCRESULT_PCERROR: PCRESULT_NTERROR);
   rsp->rspError         = errCode;              // NT or PC error
   rsp->rspDataItemCount = 0;                    // no data returned on error
   rsp->rspDataItemLen   = 0;                    // no data returned on error
 
   *outLen = sizeof( *rsp ) - sizeof( rsp->rspData );

   return TRUE;
}

//--------------------------------------------------------------------------------------------//
// Function to process a name rules request and build a response in the output buffer         //
// Input:    Request pointer, location to store output buffer length                          //
// Returns:  TRUE if output is to be written, else FALSE                                      //
//--------------------------------------------------------------------------------------------//
BOOL CProcConClient::DoNameRules( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen ) {

   PCULONG32 err = PCERROR_SUCCESS;
   PCNameRule *rule = (PCNameRule *) req->reqData;
   rule->matchType = _totupper( rule->matchType );

   switch ( req->reqOp ) {
   case PCOP_GET:
      req->reqFlags |= PCREQFLAG_DOLIST;              // just treat as list flag set
      break;
   case PCOP_ADD:
      if ( !PCValidName( rule->procName, ENTRY_COUNT(rule->procName) ) )
         return ErrorResponse( PCERROR_INVALID_NAME, rsp, outLen );
      if ( !PCValidMatchType( rule->matchType ) )
         return ErrorResponse( PCERROR_INVALID_PARAMETER, rsp, outLen );
      err = m_cDB.AddNameRule( rule, req->reqVersion, (PCULONG32) req->reqIndex, req->reqUpdCtr );
      break;
   case PCOP_REP:
      if ( !PCValidName( rule->procName, ENTRY_COUNT(rule->procName) ) )
         return ErrorResponse( PCERROR_INVALID_NAME, rsp, outLen );
      if ( !PCValidMatchType( rule->matchType ) )
         return ErrorResponse( PCERROR_INVALID_PARAMETER, rsp, outLen );
      err = m_cDB.ReplNameRule( rule, req->reqVersion, (PCULONG32) req->reqIndex, req->reqUpdCtr );
      break;
   case PCOP_DEL:
      err = m_cDB.DelNameRule( (PCULONG32) req->reqIndex, req->reqUpdCtr );
      break;
   case PCOP_ORD:
      err = m_cDB.SwapNameRule( (PCULONG32) req->reqIndex, req->reqUpdCtr );
      break;
   default:
      err = PCERROR_INVALID_REQUEST;
      break;
   }  // end switch operation

   if ( err != PCERROR_SUCCESS ) 
      return ErrorResponse( err, rsp, outLen );

   if ( req->reqFlags & PCREQFLAG_DOLIST ) {
      if ( m_cDB.GetNameRules( req->reqFirst,                                 // start from here
                               (PCNameRule *) rsp->rspData, req->reqCount,    // put data here with max count
                               &rsp->rspDataItemLen, &rsp->rspDataItemCount,  // put item len and count here
                               &rsp->rspUpdCtr ) )                            // put updctr here
         rsp->rspFlags |= PCRSPFLAG_MOREDATA;
   }

   *outLen = offsetof(PCResponse, rspData) + rsp->rspDataItemCount * rsp->rspDataItemLen;
   return TRUE;
}

//--------------------------------------------------------------------------------------------//
// Function to handle a process list request and build a response in the output buffer        //
// Input:    Request pointer, location to store output buffer length                          //
// Returns:  TRUE if output is to be written, else FALSE                                      //
// Note:     A process list consists of the names of all processes know to ProcCon:           //
//           1) Process names appearing in name rules,                                        //
//           2) Process names defined in ProcCon's database,                                  //
//           3) Any processes currently running and visible to ProcCon.                       //
//--------------------------------------------------------------------------------------------//
BOOL CProcConClient::DoProcList( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen ) {

   INT32 err = PCERROR_SUCCESS;

   PCProcListItem *start = (PCProcListItem *) req->reqData;

   switch ( req->reqOp ) {
   case PCOP_GET:
      if ( !PCValidName( start->procName, ENTRY_COUNT(start->procName), TRUE ) )
         return ErrorResponse( PCERROR_INVALID_NAME, rsp, outLen );

      if ( m_cDB.GetProcList( start, (PCULONG32) req->reqIndex,                 // starting here with these flags
                              (PCProcListItem *) rsp->rspData, req->reqCount,   // put data here with max count
                              &rsp->rspDataItemLen, &rsp->rspDataItemCount ) )  // put item len and count here
         rsp->rspFlags |= PCRSPFLAG_MOREDATA;
      break;
   case PCOP_KILL:
      err = m_cPC.GetPCMgr()->KillProcess( (ULONG_PTR) req->reqIndex, *((TIME_VALUE *) req->reqData) );
      break;
   default:
      err = PCERROR_INVALID_REQUEST;
      break;
   }  // end switch operation

   if ( err != PCERROR_SUCCESS ) return ErrorResponse( err, rsp, outLen );

   *outLen = offsetof(PCResponse, rspData) + rsp->rspDataItemCount * rsp->rspDataItemLen;

   return TRUE;
}

//--------------------------------------------------------------------------------------------//
// Function to handle a job list request and build a response in the output buffer            //
// Input:    Request pointer, location to store output buffer length                          //
// Returns:  TRUE if output is to be written, else FALSE                                      //
// Note:     A job list consists of the names of all jobs know to ProcCon:                    //
//           1) Job names appearing in process definitions as "member of group",              //
//           2) Job names defined in ProcCon's database,                                      //
//           3) Any jobs currently running and visible to ProcCon.                            //
//--------------------------------------------------------------------------------------------//
BOOL CProcConClient::DoJobList( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen ) {

   INT32 err = PCERROR_SUCCESS;

   PCJobListItem *start = (PCJobListItem *) req->reqData;

   switch ( req->reqOp ) {
   case PCOP_GET:
      if ( !PCValidName( start->jobName, ENTRY_COUNT(start->jobName), TRUE ) )
         return ErrorResponse( PCERROR_INVALID_NAME, rsp, outLen );
      if ( m_cDB.GetJobList( start, (PCULONG32) req->reqIndex,                 // starting here with these flags
                             (PCJobListItem *) rsp->rspData, req->reqCount,    // put data here with max count
                             &rsp->rspDataItemLen, &rsp->rspDataItemCount ) )  // put item len and count here
         rsp->rspFlags |= PCRSPFLAG_MOREDATA;
      break;
   case PCOP_KILL:
      err = m_cPC.GetPCMgr()->KillJob( *((JOB_NAME *) req->reqData) );
      break;
   default:
      err = PCERROR_INVALID_REQUEST;
      break;
   }  // end switch operation

   if ( err != PCERROR_SUCCESS ) return ErrorResponse( err, rsp, outLen );

   *outLen = offsetof(PCResponse, rspData) + rsp->rspDataItemCount * rsp->rspDataItemLen;

   return TRUE;
}

//--------------------------------------------------------------------------------------------//
// Function to handle a process summary data request and build a response in the output buffer//
// Input:    Request pointer, location to store output buffer length                          //
// Returns:  TRUE if output is to be written, else FALSE                                      //
//--------------------------------------------------------------------------------------------//
BOOL CProcConClient::DoProcSummary( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen ) {

   INT32 err = PCERROR_SUCCESS;

   PCProcSummary *start = (PCProcSummary *) req->reqData;

   switch ( req->reqOp ) {
   case PCOP_GET:
      if ( !PCValidName( start->procName, ENTRY_COUNT(start->procName), TRUE ) )
         return ErrorResponse( PCERROR_INVALID_NAME, rsp, outLen );
      if ( m_cDB.GetProcSummary( start, (PCULONG32) req->reqIndex,                 // starting here with these flags
                                 (PCProcSummary *) rsp->rspData, req->reqCount,    // put data here with max count
                                 &rsp->rspDataItemLen, &rsp->rspDataItemCount ) )  // put item len and count here
         rsp->rspFlags |= PCRSPFLAG_MOREDATA;
      break;
   default:
      err = PCERROR_INVALID_REQUEST;
      break;
   }  // end switch operation

   if ( err != PCERROR_SUCCESS ) return ErrorResponse( err, rsp, outLen );

   *outLen = offsetof(PCResponse, rspData) + rsp->rspDataItemCount * rsp->rspDataItemLen;
   return TRUE;
}

//--------------------------------------------------------------------------------------------//
// Function to handle a job summary data request and build a response in the output buffer    //
// Input:    Request pointer, location to store output buffer length                          //
// Returns:  TRUE if output is to be written, else FALSE                                      //
//--------------------------------------------------------------------------------------------//
BOOL CProcConClient::DoJobSummary( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen ) {

   INT32 err = PCERROR_SUCCESS;

   PCJobSummary *start = (PCJobSummary *) req->reqData;

   switch ( req->reqOp ) {
   case PCOP_GET:
      if ( !PCValidName( start->jobName, ENTRY_COUNT(start->jobName), TRUE ) )
         return ErrorResponse( PCERROR_INVALID_NAME, rsp, outLen );
      if ( m_cDB.GetJobSummary( start, (PCULONG32) req->reqIndex,                 // starting here with these flags
                                (PCJobSummary *) rsp->rspData, req->reqCount,     // put data here with max count
                                &rsp->rspDataItemLen, &rsp->rspDataItemCount ) )  // put item len and count here
         rsp->rspFlags |= PCRSPFLAG_MOREDATA;
      break;
   default:
      err = PCERROR_INVALID_REQUEST;
      break;
   }  // end switch operation

   if ( err != PCERROR_SUCCESS ) return ErrorResponse( err, rsp, outLen );

   *outLen = offsetof(PCResponse, rspData) + rsp->rspDataItemCount * rsp->rspDataItemLen;
   return TRUE;
}

//--------------------------------------------------------------------------------------------//
// Function to process a process detail data request and build a response in the output buf   //
// Input:    Request pointer, location to store output buffer and length                      //
// Returns:  TRUE if output is to be written, else FALSE                                      //
//--------------------------------------------------------------------------------------------//
BOOL CProcConClient::DoProcDetail( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen ) {

   INT32 err = PCERROR_SUCCESS;

   PCProcDetail *reqDetail = (PCProcDetail *) req->reqData;
   PCProcDetail *rspDetail = (PCProcDetail *) rsp->rspData;

   if ( !PCValidName( reqDetail->base.procName, ENTRY_COUNT(reqDetail->base.procName) ) )
      return ErrorResponse( PCERROR_INVALID_NAME, rsp, outLen );

   switch ( req->reqOp ) {
   case PCOP_GET: {
      // Set max length of variable data.
      int maxVLen = req->maxReply - offsetof(PCProcDetail, vData);
      reqDetail->vLength = (PCINT16) max( 0, maxVLen );
      // Get detail data and set number (always only 1) and length of returned item.
      err = m_cDB.GetProcDetail( reqDetail, rspDetail, req->reqVersion, &rsp->rspUpdCtr );
      rsp->rspDataItemCount = 1; 
      rsp->rspDataItemLen   = (PCINT16) (offsetof(PCProcDetail, vData) + rspDetail->vLength);
      break;
   }
   case PCOP_ADD:
      if ( !PCValidName( reqDetail->base.memberOfJobName, ENTRY_COUNT(reqDetail->base.memberOfJobName), TRUE ) )
         return ErrorResponse( PCERROR_INVALID_NAME, rsp, outLen );
      err = m_cDB.AddProcDetail( reqDetail, req->reqVersion);
      if ( err == PCERROR_SUCCESS || err == PCERROR_EXISTS ) 
         GenerateJobDetail( reqDetail );
      break;
   case PCOP_REP:
      if ( !PCValidName( reqDetail->base.memberOfJobName, ENTRY_COUNT(reqDetail->base.memberOfJobName), TRUE ) )
         return ErrorResponse( PCERROR_INVALID_NAME, rsp, outLen );
      err = m_cDB.ReplProcDetail( reqDetail, req->reqVersion, req->reqUpdCtr );
      if ( err == PCERROR_SUCCESS || err == ERROR_FILE_NOT_FOUND ) 
         GenerateJobDetail( reqDetail );
      break;
   case PCOP_DEL:
      err = m_cDB.DelProcDetail( &reqDetail->base, req->reqVersion);
      break;
   default:
      err = PCERROR_INVALID_REQUEST;
      break;
   }  // end switch operation

   if ( err == ERROR_MORE_DATA )
      rsp->rspFlags |= PCRSPFLAG_MOREDATA;
   else if ( err != PCERROR_SUCCESS ) 
      return ErrorResponse( err, rsp, outLen );

   if ( req->reqFlags & PCREQFLAG_DOLIST ) 
      m_cDB.GetProcSummary( (PCProcSummary *) req->reqData, PC_LIST_STARTING_WITH, // starting here
                            (PCProcSummary *) rsp->rspData, 1,                // put data here with count = 1
                            &rsp->rspDataItemLen, &rsp->rspDataItemCount );   // put item len and count here

   *outLen = offsetof(PCResponse, rspData) + rsp->rspDataItemCount * rsp->rspDataItemLen;
   return TRUE;
}

//--------------------------------------------------------------------------------------------//
// Function to generate job detail if needed and it doesn't exist                             //
// Input:    Process detail that may refer to a job                                           //
// Returns:  nothing                                                                          //
//--------------------------------------------------------------------------------------------//
void CProcConClient::GenerateJobDetail( PCProcDetail *reqDetail ) {
   if ( *reqDetail->base.memberOfJobName ) {
      PCJobDetail jobDetail;
      memset( &jobDetail, 0, sizeof(jobDetail) );

      memcpy( jobDetail.base.jobName, reqDetail->base.memberOfJobName, sizeof(jobDetail.base.jobName) );
      jobDetail.base.mgmtParms.priority   = reqDetail->base.mgmtParms.priority;
      jobDetail.base.mgmtParms.affinity   = reqDetail->base.mgmtParms.affinity;
      jobDetail.base.mgmtParms.schedClass = 5;

      m_cDB.AddJobDetail( &jobDetail, 1 );
   }
}

//--------------------------------------------------------------------------------------------//
// Function to process a job detail request and build a response in the output buffer         //
// Input:    Request pointer, location to store output buffer length                          //
// Returns:  TRUE if output is to be written, else FALSE                                      //
//--------------------------------------------------------------------------------------------//
BOOL CProcConClient::DoJobDetail( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen ) {

   INT32 err = PCERROR_SUCCESS;

   PCJobDetail *reqDetail = (PCJobDetail *) req->reqData;
   PCJobDetail *rspDetail = (PCJobDetail *) rsp->rspData;

   if ( !PCValidName( reqDetail->base.jobName, ENTRY_COUNT(reqDetail->base.jobName) ) )
      return ErrorResponse( PCERROR_INVALID_NAME, rsp, outLen );

   switch ( req->reqOp ) {
   case PCOP_GET: {
      // Set max length of variable data.
      int maxVLen = req->maxReply - offsetof(PCJobDetail, vData);
      rspDetail->vLength = (PCINT16) max( 0, maxVLen );
      // Get detail data and set number (always only 1) and length of returned item.
      err = m_cDB.GetJobDetail( reqDetail, rspDetail, req->reqVersion, &rsp->rspUpdCtr );
      rsp->rspDataItemCount = 1; 
      rsp->rspDataItemLen   = (PCINT16) (offsetof(PCJobDetail, vData) + rspDetail->vLength);
      break;
   }
   case PCOP_ADD:
      err = m_cDB.AddJobDetail( reqDetail, req->reqVersion);
      break;
   case PCOP_REP:
      err = m_cDB.ReplJobDetail( reqDetail, req->reqVersion, req->reqUpdCtr );
      break;
   case PCOP_DEL:
      err = m_cDB.DelJobDetail( &reqDetail->base, req->reqVersion);
      break;
   default:
      err = PCERROR_INVALID_REQUEST;
      break;
   }  // end switch operation

   if ( err == ERROR_MORE_DATA )
      rsp->rspFlags |= PCRSPFLAG_MOREDATA;
   else if ( err != PCERROR_SUCCESS ) 
      return ErrorResponse( err, rsp, outLen );

   if ( req->reqFlags & PCREQFLAG_DOLIST )
      m_cDB.GetJobSummary( (PCJobSummary *) req->reqData, PC_LIST_STARTING_WITH,  // starting here
                           (PCJobSummary *) rsp->rspData, 1,                 // put data here with count = 1
                           &rsp->rspDataItemLen, &rsp->rspDataItemCount );   // put item len and count here

   *outLen = offsetof(PCResponse, rspData) + rsp->rspDataItemCount * rsp->rspDataItemLen;
   return TRUE;
}

//--------------------------------------------------------------------------------------------//
// Function to handle a server information request and build a response in the output buffer  //
// Input:    Request and response pointers, location to store output buffer length            //
// Returns:  TRUE if output is to be written, else FALSE                                      //
// Note:     Server info consists of version info and system parameters.                      //
//--------------------------------------------------------------------------------------------//
BOOL CProcConClient::DoServerInfo( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen ) {

   INT32 err = PCERROR_SUCCESS;

   switch ( req->reqOp ) {
   case PCOP_GET:
      m_cPC.GetPCSystemInfo( (PCSystemInfo *) rsp->rspData,                   // put data here
                             &rsp->rspDataItemLen, &rsp->rspDataItemCount );  // put item len and count here
      break;
   default:
      err = PCERROR_INVALID_REQUEST;
      break;
   }  // end switch operation

   if ( err != PCERROR_SUCCESS ) return ErrorResponse( err, rsp, outLen );

   *outLen = offsetof(PCResponse, rspData) + rsp->rspDataItemCount * rsp->rspDataItemLen;

   return TRUE;
}

//--------------------------------------------------------------------------------------------//
// Function to handle a server parameter request and build a response in the output buffer    //
// Input:    Request pointer, location to store output buffer length                          //
// Returns:  TRUE if output is to be written, else FALSE                                      //
// Note:     Server info consists of version info and system parameters.                      //
//--------------------------------------------------------------------------------------------//
BOOL CProcConClient::DoServerParms( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen ) {

   INT32 err = PCERROR_SUCCESS;

   switch ( req->reqOp ) {
   case PCOP_REP:
      err = m_cDB.SetPollDelaySeconds( (PCUINT32) (((PCSystemParms *) req->reqData)->manageIntervalSeconds) );
      if ( err == PCERROR_SUCCESS ) 
         err = m_cUser.SetTimeout( (PCUINT32) (((PCSystemParms *) req->reqData)->timeoutValueMs) );
      break;
   default:
      err = PCERROR_INVALID_REQUEST;
      break;
   }  // end switch operation

   if ( err != PCERROR_SUCCESS ) return ErrorResponse( err, rsp, outLen );

   *outLen = offsetof(PCResponse, rspData);

   return TRUE;
}

//--------------------------------------------------------------------------------------------//
// Function to handle a server control request and build a response in the output buffer      //
// Input:    Request pointer, location to store output buffer length                          //
// Returns:  TRUE if output is to be written, else FALSE                                      //
// Note:     Server control consists of a series of bit commands and one piece of data.       //
//--------------------------------------------------------------------------------------------//
BOOL CProcConClient::DoControl( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen ) {

   INT32 err = PCERROR_SUCCESS;

   if ( req->reqOp != PCOP_CTL || 
        (req->reqIndex & PCCFLAG_SIGNATURE) != PCCFLAG_SIGNATURE ||
        req->reqIndex & PCCFLAG_ANTI_SIGNATURE )
      err = PCERROR_INVALID_REQUEST;
   else {
      if ( req->reqIndex & PCCFLAG_STOP_MEDIATOR )
         err = m_cPC.StopMediator();
      if ( err == PCERROR_SUCCESS && req->reqIndex & PCCFLAG_START_MEDIATOR )
         err = m_cPC.StartMediator();
      if ( err == PCERROR_SUCCESS && req->reqIndex & PCCFLAG_DELALL_NAME_RULES )
         err = m_cDB.DeleteAllNameRules();
      if ( err == PCERROR_SUCCESS && req->reqIndex & PCCFLAG_DELALL_PROC_DEFS )
         err = m_cDB.DeleteAllProcDefs();
      if ( err == PCERROR_SUCCESS && req->reqIndex & PCCFLAG_DELALL_JOB_DEFS )
         err = m_cDB.DeleteAllJobDefs();
   }

   if ( err != PCERROR_SUCCESS ) return ErrorResponse( err, rsp, outLen );

   *outLen = offsetof(PCResponse, rspData);

   return TRUE;
}

// End of CProcClient.cpp
//============================================================================J McDonald fecit====//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\service\cproccon.cpp ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998, 1999 Sequent Computer Systems, Incorporated.  All rights reserved. //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|---------------------------------------------------------------------------------------//            
|   This file implements the CProcCon class methods defined in ProcConSvc.h             //
|---------------------------------------------------------------------------------------//            
|                                                                                       //
|Created:                                                                               //
|                                                                                       //
|   Jarl McDonald 07-98                                                                 //
|                                                                                       //
|Revision History:                                                                      //
|                                                                                       //
|=======================================================================================*/
#include "ProcConSvc.h"

// CProcCon Constructor
// Note: this function runs as part of service start so keep it quick!
CProcCon::CProcCon( void ) : m_ready( FALSE ), m_shutEvent( NULL ), m_versionInfo( NULL ),
                             m_endEvent ( NULL ),
                             m_shutDown( FALSE )
{
   memset( &m_context, 0, sizeof(m_context) );

   m_hThread[USER_SERVER] = m_hThread[PROC_SERVER] = NULL;
   SYSTEM_INFO si;
   GetSystemInfo( &si );
   m_NumberOfProcessors = si.dwNumberOfProcessors;
   m_PageSize           = si.dwPageSize;

   m_versionInfo = new CVersion( GetModuleHandle( NULL ) );

   PCBuildAdminSecAttr( m_secAttr ); 

   m_context.cDB = new CProcConDB( m_PageSize );

   if ( !m_context.cDB || !m_context.cDB->ReadyToRun() || 
        !m_versionInfo || !m_secAttr.lpSecurityDescriptor ) {
      PCLogMessage( PC_STARTUP_FAILED, EVENTLOG_ERROR_TYPE, 1, PROCCON_SVC_DISP_NAME );
      return;
   }

   m_shutEvent             = CreateEvent( NULL,       TRUE,  FALSE, NULL );
   m_endEvent              = CreateEvent( NULL,       TRUE,  FALSE, NULL );
   m_context.mgrDoneEvent  = CreateEvent( NULL,       TRUE,  FALSE, NULL );
   m_context.userDoneEvent = CreateEvent( NULL,       TRUE,  FALSE, NULL );
   m_context.mediatorEvent = CreateEvent( &m_secAttr, FALSE, FALSE, PC_MEDIATOR_EVENT );
   if ( !m_shutEvent || !m_endEvent || !m_context.mgrDoneEvent || !m_context.userDoneEvent || !m_context.mediatorEvent ) {
      PCLogUnExError( m_context.mediatorEvent? TEXT("PCEvent") : PC_MEDIATOR_EVENT, TEXT("CreateEvent") );
      return;
   }

   // Allocate shared memory for mediator view of jobs...
   m_context.mediatorTableHandle = CreateFileMapping( HANDLE_FF_64, &m_secAttr, PAGE_READWRITE, 
                                                      0, sizeof(PCMediateHdr), PC_MEDIATOR_FILEMAP );
   if ( !m_context.mediatorTableHandle ) {
      PCLogUnExError( PC_MEDIATOR_FILEMAP, TEXT("CreateMediatorMapping") );
      return;
   }
   m_context.mediatorTable = (PCMediateHdr *) MapViewOfFile( m_context.mediatorTableHandle, 
                                                             FILE_MAP_WRITE, 0, 0, 0 );
   if ( !m_context.mediatorTable ) {
      CloseHandle( m_context.mediatorTableHandle );
      m_context.mediatorTableHandle = NULL;
      PCLogUnExError( PC_MEDIATOR_FILEMAP, TEXT("MapMediatorJobData") );
      return;
   }

   m_context.mediatorTable->svcEventHandle = m_context.mediatorEvent;
   m_context.mediatorTable->svcPID         = GetCurrentProcessId();

   // If mediator is not running, init shared memory, set up completion port, and start mediator...
   if ( !PCTestIsRunning( PC_MEDIATOR_EXCLUSION ) ) {
      memset( &m_context.mediatorTable->groupBlock, 0, sizeof(m_context.mediatorTable->groupBlock) );
      m_context.mediatorTable->lastCompKey = 0;
      m_context.completionPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE, NULL, NULL, 0 );
      if ( !m_context.completionPort )
         PCLogUnExError( TEXT("PCInit"), TEXT("CreateIoCompletionPort") );

      m_context.mediatorTable->svcPortHandle = m_context.completionPort;

      StartMediator();
   }
   // If mediator is already running... 
   // recover our completion port by duplicating the handle... 
   else {
      // Open mediator process so we can duplicate handles... 
      m_context.mediatorTable->medProcessInfo.hProcess = 
         OpenProcess( PROCESS_DUP_HANDLE, FALSE, m_context.mediatorTable->medProcessInfo.dwProcessId );
      // Recover our completion port by duplicating the handle... 
      if ( !DuplicateHandle( m_context.mediatorTable->medProcessInfo.hProcess,
                             m_context.mediatorTable->medPortHandle,
                             GetCurrentProcess(),
                             &m_context.mediatorTable->svcPortHandle,
                             NULL,
                             FALSE,
                             DUPLICATE_SAME_ACCESS ) )
         PCLogUnExError( TEXT("PCInit"), TEXT("DupMediatorPortHandle") );
      m_context.completionPort = m_context.mediatorTable->svcPortHandle;
      // Map all job table blocks by duplicating the handles...
      m_context.mediatorTable->SvcChainBlocks();
   }

   CloseHandle( m_context.mediatorTable->medProcessInfo.hProcess );

   m_context.cPC = this;
   LaunchProcServer();
   LaunchUserServer();

   if (!ReadyToRun() )
      HardStop();
}

// CProcCon Destructor
CProcCon::~CProcCon( void ) 
{
   if ( m_context.cUser )  { 
      WaitForSingleObject( m_context.userDoneEvent, 5000 );
      delete m_context.cUser;
      m_context.cUser = NULL; 
   }
   if ( m_context.cMgr  )  { 
      WaitForSingleObject( m_context.mgrDoneEvent, 5000 );
      delete m_context.cMgr;      
      m_context.cMgr  = NULL; 
   }
   if ( m_context.cDB   )  { 
      delete m_context.cDB;       
      m_context.cDB   = NULL; 
   }
   if ( m_shutEvent )      { 
      CloseHandle( m_shutEvent ); 
      m_shutEvent     = NULL; 
   }
   if ( m_endEvent )      { 
      CloseHandle( m_endEvent ); 
      m_endEvent      = NULL; 
   }
   if ( m_versionInfo )    { 
      delete m_versionInfo; 
      m_versionInfo   = NULL; 
   }

   CloseHandle( m_context.mgrDoneEvent        );
   CloseHandle( m_context.userDoneEvent       );
   CloseHandle( m_context.mediatorEvent       );
   CloseHandle( m_context.mediatorTableHandle );

   PCFreeSecAttr( m_secAttr );
}

//--------------------------------------------------------------------------------------------//
// Function to determine if all CProcCon initial conditions have been met                     //
// Input:    None                                                                             //
// Returns:  TRUE if ready, FALSE if not                                                      //
//--------------------------------------------------------------------------------------------//
BOOL CProcCon::ReadyToRun( void ) 
{ 
   return m_context.cDB          && 
          m_hThread[PROC_SERVER] && 
          m_hThread[USER_SERVER] && 
          m_secAttr.lpSecurityDescriptor; 
}

//--------------------------------------------------------------------------------------------//
// Function to start the ProcCon Mediator Process                                             //
// Input:    None                                                                             //
// Returns:  NT or ProcCon Error code                                                         //
//--------------------------------------------------------------------------------------------//
PCULONG32 CProcCon::StartMediator( void )
{
      // Don't start if already running...
      if ( PCTestIsRunning( PC_MEDIATOR_EXCLUSION ) )
         return PCERROR_MEDIATOR_ALREADY_RUNNING;

      // Get our module name then replace base name with mediator base name...
      // (Thus mediator exe must be in the same location as the service exe).
      TCHAR path[MAX_PATH];
      if ( !GetModuleFileName( NULL, path, MAX_PATH ) ) {
         PCLogUnExError( TEXT("PCMediator"), TEXT("GetMediatorPath") );
         path[0] = 0;
      }
      for ( int i = _tcslen( path ); i; --i ) {
         if ( path[i] == TEXT('\\') ) {  path[i + 1] = 0;  break;  }
      }
      _tcscat( path, PC_MEDIATOR_BASE_NAME );

      // Start mediator process -- don't quit if this fails...
      STARTUPINFO strtInfo;
      memset( &strtInfo, 0, sizeof(strtInfo) );
      strtInfo.cb = sizeof(strtInfo);
      if ( !CreateProcess( path, NULL, &m_secAttr, &m_secAttr, FALSE, 
                           CREATE_NEW_PROCESS_GROUP + CREATE_NO_WINDOW, 
                           NULL, NULL, &strtInfo, &m_context.mediatorTable->medProcessInfo ) ) {
         DWORD rc = GetLastError();
         PCLogUnExError( TEXT("PCMediator"), TEXT("CreateMediator") );
         return rc;
      }

      return ERROR_SUCCESS;
}

//--------------------------------------------------------------------------------------------//
// Function to stop (kill) the ProcCon Mediator Process                                       //
// Input:    None                                                                             //
// Returns:  NT or ProcCon Error code                                                         //
//--------------------------------------------------------------------------------------------//
PCULONG32 CProcCon::StopMediator ( void )
{
   DWORD  rc    = ERROR_SUCCESS;
   HANDLE hProc = OpenProcess( PROCESS_TERMINATE, FALSE, m_context.mediatorTable->medProcessInfo.dwProcessId );

   m_context.mediatorTable->medProcessInfo.hProcess = hProc;
         
   if ( !hProc ) {
      rc = GetLastError();
      if (rc == ERROR_INVALID_PARAMETER) rc = PCERROR_MEDIATOR_NOT_RUNNING;
   }
   else if ( !TerminateProcess( m_context.mediatorTable->medProcessInfo.hProcess, PCERROR_KILLED_BY_REQUEST ) )
      rc = GetLastError();

   if ( hProc )
      CloseHandle( hProc );

   return rc;
}

//--------------------------------------------------------------------------------------------//
// Function to return system information                                                      //
// Input:    Buffer for information, locations for size and count (always 1)                  //
// Returns:  TRUE if shutdown requested, FALSE if not                                         //
//--------------------------------------------------------------------------------------------//
void CProcCon::GetPCSystemInfo( PCSystemInfo *data, PCINT16 *itemLen, PCINT16 *itemCount )
{
   *itemLen   = sizeof(PCSystemInfo);
   *itemCount = 1;
   memset( data, 0, *itemLen );

   _tcsncpy( data->fileVersion,       m_versionInfo->GetFileVersion(),    VERSION_STRING_LEN );
   _tcsncpy( data->productVersion,    m_versionInfo->GetProductVersion(), VERSION_STRING_LEN );
   _tcsncpy( data->fileFlags,         m_versionInfo->GetFileFlags(),      VERSION_STRING_LEN );

   _tcsncpy( data->medFileVersion,    m_context.mediatorTable->medFileVersion,    VERSION_STRING_LEN );
   _tcsncpy( data->medProductVersion, m_context.mediatorTable->medProductVersion, VERSION_STRING_LEN );
   _tcsncpy( data->medFileFlags,      m_context.mediatorTable->medFileFlags,      VERSION_STRING_LEN );

   data->fixedSignature        = m_versionInfo->GetFixedSignature();     
   data->fixedFileVersionMS    = m_versionInfo->GetFixedFileVersionMS(); 
   data->fixedFileVersionLS    = m_versionInfo->GetFixedFileVersionLS();     
   data->fixedProductVersionMS = m_versionInfo->GetFixedProductVersionMS(); 
   data->fixedProductVersionLS = m_versionInfo->GetFixedProductVersionLS();     
   data->fixedFileFlags        = m_versionInfo->GetFixedFileFlags(); 
   data->fixedFileOS           = m_versionInfo->GetFixedFileOS();     
   data->fixedFileType         = m_versionInfo->GetFixedFileType();     
   data->fixedFileSubtype      = m_versionInfo->GetFixedFileSubtype(); 
   data->fixedFileDateMS       = m_versionInfo->GetFixedFileDateMS();     
   data->fixedFileDateLS       = m_versionInfo->GetFixedFileDateLS();

   data->sysParms.manageIntervalSeconds = m_context.cDB->GetPollDelaySeconds();
   data->sysParms.timeoutValueMs        = m_context.cUser->GetTimeout();
   data->sysParms.numberOfProcessors    = m_NumberOfProcessors;
   data->sysParms.memoryPageSize        = m_PageSize;
   data->sysParms.processorMask         = m_context.cMgr->GetSystemMask();
}

//--------------------------------------------------------------------------------------------//
// CProcCon thread function -- this function runs in its own thread                           //
// Input:    None                                                                             //
// Returns:  Nothing                                                                          //
// Note:     All ProcCon work is done in the user communication and process management        //
//           threads so this fcn has only an oversight role.                                  //
//--------------------------------------------------------------------------------------------//
void CProcCon::Run( void ) 
{
  ResumeThread(m_hThread[USER_SERVER] );
  ResumeThread(m_hThread[PROC_SERVER] );

  WaitForSingleObject( m_endEvent, INFINITE );
}

//--------------------------------------------------------------------------------------------//
// CProcCon function to handle 'hard' stop: failure before threads are released               //
// Input:    Optional Thread Exit Code                                                        //
// Returns:  Nothing                                                                          //
// Note:     This function forcefully close the user communication and process management     //
//           threads.                                                                         //
//--------------------------------------------------------------------------------------------//
void CProcCon::HardStop( PCULONG32 ExitCode ) 
{
  if ( m_hThread[USER_SERVER] ) {
    TerminateThread(m_hThread[USER_SERVER], ExitCode );
    m_hThread[USER_SERVER] = NULL;
  }
  if ( m_hThread[PROC_SERVER] ) { 
    TerminateThread(m_hThread[PROC_SERVER], ExitCode );
    m_hThread[PROC_SERVER] = NULL;
  }
}

//--------------------------------------------------------------------------------------------//
// Function called by service stop when stop requested                                        //
// Input:    None                                                                             //
// Returns:  Nothing                                                                          //
// Note:     this function runs as part of service stop                                       //
//--------------------------------------------------------------------------------------------//
void CProcCon::Stop( void ) 
{
   if ( m_shutEvent ) {
      m_shutDown = TRUE;
      SetEvent( m_shutEvent );
      WaitForMultipleObjects( ENTRY_COUNT(m_hThread), m_hThread, TRUE, 30000 );
      SetEvent( m_endEvent );
   }
}

//--------------------------------------------------------------------------------------------//
// Function to start the Process Management thread                                            //
// Input:    None                                                                             //
// Returns:  Nothing                                                                          //
// Note:     this function runs as part of service start so it must be quick.                 //
//--------------------------------------------------------------------------------------------//
void CProcCon::LaunchProcServer( void )                     
{
   m_hThread[PROC_SERVER] = CreateThread( NULL, 0, &PCProcServer, &m_context, CREATE_SUSPENDED, NULL );
   if ( !m_hThread[PROC_SERVER] )
      PCLogUnExError( TEXT("PCProcServer"), TEXT("CreateThread") );
}

//--------------------------------------------------------------------------------------------//
// Function to start the User Communication thread                                            //
// Input:    None                                                                             //
// Returns:  Nothing                                                                          //
// Note:     this function runs as part of service start so it must be quick.                 //
//--------------------------------------------------------------------------------------------//
void CProcCon::LaunchUserServer( void )                     
{
   m_hThread[USER_SERVER] = CreateThread( NULL, 0, &PCUserServer, &m_context, CREATE_SUSPENDED, NULL );
   if ( !m_hThread[USER_SERVER] )
      PCLogUnExError( TEXT("PCUserServer"), TEXT("CreateThread") );
}

// End of CProcCon.cpp
//============================================================================J McDonald fecit====//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\library\procconlib.cpp ===
/*======================================================================================//
|  Windows 2000 Process Control                                                         //
|                                                                                       //
|Copyright (c) 1998, 1999  Sequent Computer Systems, Incorporated.  All rights reserved //
|                                                                                       //
|File Name:    ProcConLib.cpp                                                           //
|                                                                                       //
|Description:  This implements the ProcCon client side API in a static library          //
|                                                                                       //
|Created:      Jarl McDonald 08-98                                                      //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/
#include <windows.h>
#include <stddef.h>
#include <stdlib.h>
#include <tchar.h>
#include <time.h>
#include "ProcConAPI.h"
#include "ProcConClnt.h"

#define ENTRY_COUNT(x) (sizeof(x) / sizeof(x[0]))

typedef struct _PCConnection {
   TCHAR      name[MAX_PATH];
   HANDLE     handle;
   PCUINT32   connCount;
   time_t     connTime;
   PCUINT32   flags;
   PCUINT32   lastError;
   PCINT32    reqSeq;
   char      *buffer;
   PCINT32    bufSize;
   DWORD      timeout;
   OVERLAPPED overlap;
} PCConnection;

typedef enum _PCConnFlags {
   PCAPIFLAG_FREEBUFFER = 0x01000000,
};

const  PCINT32 SIGNATURE = 0xd06eface;
const  TCHAR *PIPENAME   = TEXT("\\pipe\\ProcConPip");

static PCConnection connTbl[128];
static PCid         nextId  = 0;

//======================================================================================//
// Library internal functions
//======================================================================================//
static PCINT32 PCMaxItemCount( PCid      target, 
                               PCINT32   bufSize, 
                               PCINT32   itemSize ) 
{
   PCINT32 maxUsrBuf = bufSize / itemSize;
   PCINT32 maxIOBuf  = (connTbl[target].bufSize - offsetof(PCResponse, rspData)) / itemSize;

   return min(maxUsrBuf, maxIOBuf);  
}

static BOOL PCIsValidPCId( PCid target )
{ 
   if ( target <= 0 || target >= ENTRY_COUNT(connTbl) )
      connTbl[0].lastError = PCERROR_INVALID_PCID;
   else if ( !connTbl[target].handle )
      connTbl[target].lastError = PCERROR_INVALID_PCID;
   else return TRUE;
   return FALSE;
}

static void PCBuildReq( PCid         target,
                        BYTE         op, 
                        BYTE         itemType, 
                        void        *pItem     = NULL, 
                        PCINT16      itemSize  = 0,
                        PCINT32      maxReply  = 0,
                        PCINT64      index     = 0,
                        PCINT32      count     = 1,
                        PCINT32      first     = 0,
                        PCINT32      updateCtr = 0 )
{ 
   PCRequest *req = (PCRequest *) connTbl[target].buffer;
   connTbl[target].lastError = PCERROR_SUCCESS;

   memset( req, 0, sizeof( *req ) );

   req->reqSignature = SIGNATURE;                 // sanity check signature
   req->reqSeq       = ++connTbl[target].reqSeq;  // requestor sequence number
   req->reqOp        = op;                        // requested operation: get
   req->reqType      = itemType;                  // requested data type: name rule
   req->reqVersion   = 1;                         // expected data version code
   req->reqUpdCtr    = updateCtr;                 // requestor's update counter from get
   req->reqIndex     = index;                     // requestor's insert point, etc.
   req->reqCount     = count;                     // requestor's returned data item max count
   req->reqFirst     = first;                     // requestor's first index to retrieve
   req->maxReply     = min( (PCUINT32) maxReply, 
                            (PCUINT32) connTbl[target].bufSize - offsetof(PCResponse, rspData) );   
   req->reqDataLen   = itemSize;                  // data length that follows.
   if ( pItem ) memcpy( req->reqData, pItem, itemSize );
}
 
static BOOL PCReopen( PCid id )
{
   ++connTbl[id].connCount;
   connTbl[id].connTime = time( NULL );
   connTbl[id].handle   = INVALID_HANDLE_VALUE;

   // Connect to desired server and pipe...
   if ( WaitNamedPipe( connTbl[id].name, NMPWAIT_USE_DEFAULT_WAIT ) )
      connTbl[id].handle = CreateFile( connTbl[id].name, GENERIC_READ + GENERIC_WRITE, 0,
                                       NULL, OPEN_EXISTING, 
                                       SECURITY_SQOS_PRESENT + SECURITY_IMPERSONATION + FILE_FLAG_OVERLAPPED, 
                                       NULL );

      // Update table entry...
   connTbl[id].lastError = connTbl[id].handle == INVALID_HANDLE_VALUE? GetLastError() : PCERROR_SUCCESS;

   // return success or fail indication...
   return connTbl[id].lastError == PCERROR_SUCCESS;
}

static BOOL PCRetryCode( PCid id )
{
   static PCUINT32 retryCodes[] = { ERROR_BAD_PIPE,           ERROR_PIPE_BUSY,   ERROR_NO_DATA, 
                                    ERROR_PIPE_NOT_CONNECTED, ERROR_BROKEN_PIPE, ERROR_SEM_TIMEOUT,
                                    ERROR_NETNAME_DELETED,    ERROR_INVALID_HANDLE };
   for ( PCUINT32 i = 0; i < ENTRY_COUNT(retryCodes); ++i ) 
      if ( connTbl[id].lastError == retryCodes[i] ) return TRUE;
   return FALSE;
}

static void PCSetReqFlag( PCid target, PCINT32 flag ) 
{
   ((PCRequest *) connTbl[target].buffer)->reqFlags |= flag;
}

static BOOL PCTestResponse( PCid        target, 
                            PCUINT32    bytesActual )
{
   PCResponse *rsp = (PCResponse *) connTbl[target].buffer;
   PCUINT32 hdrBytesExpected = sizeof(PCResponse) - sizeof(rsp->rspData);
   if ( bytesActual < hdrBytesExpected ) {
      connTbl[target].lastError = PCERROR_INVALID_RESPONSE_LENGTH;
      return FALSE;
   }

   if ( rsp->rspReqSignature != SIGNATURE || rsp->rspReqSeq != connTbl[target].reqSeq ) {
      connTbl[target].lastError = PCERROR_INVALID_RESPONSE;
      return FALSE;
   }

   PCUINT32 dataBytesReceived = rsp->rspDataItemCount * rsp->rspDataItemLen;
   if ( bytesActual < hdrBytesExpected + dataBytesReceived ) {
      connTbl[target].lastError = PCERROR_INVALID_RESPONSE_LENGTH;
      return FALSE;
   }

   if ( rsp->rspResult != PCRESULT_SUCCESS ) {
      connTbl[target].lastError = rsp->rspError;
      return FALSE;
   }

   connTbl[target].lastError = PCERROR_SUCCESS;
   return TRUE;
}

static PCINT32 PCCopyData( PCid      target, 
                         void       *pData, 
                         PCINT32     maxItemsRequested,
                         PCUINT32    maxLen,
                         PCINT32    *nUpdateCtr = NULL ) 
{
   PCResponse *rsp = (PCResponse *) connTbl[target].buffer; 

   if ( rsp->rspFlags & PCRSPFLAG_MOREDATA ) connTbl[target].lastError = PCERROR_MORE_DATA;

   if ( nUpdateCtr ) *nUpdateCtr = rsp->rspUpdCtr;
   
   PCUINT32 items = min( rsp->rspDataItemCount, maxItemsRequested );
   PCUINT32 copyLen = items * rsp->rspDataItemLen;
   
   if ( copyLen > maxLen ) {
      connTbl[target].lastError = PCERROR_TRUNCATED;
      items   = maxLen / rsp->rspDataItemLen;
      copyLen = items * rsp->rspDataItemLen;
   }

   memcpy( pData, rsp->rspData, copyLen );

   return items;
}

static BOOL PCReadRsp( PCid target )
{
   BOOL test;

   do {
      PCULONG32 bytesRead;
      ResetEvent( connTbl[target].overlap.hEvent );
      PCULONG32 rc = ReadFile( connTbl[target].handle, 
                               connTbl[target].buffer, connTbl[target].bufSize, 
                               &bytesRead, &connTbl[target].overlap );
      if ( !rc && GetLastError() != ERROR_IO_PENDING ) {
         connTbl[target].lastError = GetLastError();
         return FALSE;
      }
      if ( WAIT_TIMEOUT == WaitForSingleObject( connTbl[target].overlap.hEvent, connTbl[target].timeout ) ) {
         CancelIo( connTbl[target].handle );
         connTbl[target].lastError = PCERROR_REQUEST_TIMED_OUT;
         return FALSE;
      }
      else if ( !GetOverlappedResult( connTbl[target].handle, &connTbl[target].overlap, &bytesRead, FALSE ) ) { 
         connTbl[target].lastError = GetLastError();
         return FALSE;
      }
      test = PCTestResponse( target, bytesRead );
   } while ( !test && PCGetLastError( target ) == PCERROR_INVALID_RESPONSE );

   return test;
}

static BOOL PCSendReceive( PCid target )
{
   PCRequest *req = (PCRequest *) connTbl[target].buffer;
   PCULONG32 bytesActual, bytesToWrite = sizeof(PCRequest) - sizeof(req->reqData) + req->reqDataLen;

   ResetEvent( connTbl[target].overlap.hEvent );
   for ( int retryCt = 0; retryCt < PC_MAX_RETRIES + 1; ++retryCt ) {
      PCULONG32 rc = WriteFile( connTbl[target].handle, req, bytesToWrite, &bytesActual, &connTbl[target].overlap );
      if ( rc || GetLastError() == ERROR_IO_PENDING ) break;
      else {
         connTbl[target].lastError = GetLastError();
         if ( PCRetryCode( target ) ) Sleep( rand() * 300 / RAND_MAX );
         else return FALSE;
         PCReopen( target );
      }
   }
   if ( WAIT_TIMEOUT == WaitForSingleObject( connTbl[target].overlap.hEvent, connTbl[target].timeout ) ) {
      CancelIo( connTbl[target].handle );
      connTbl[target].lastError = PCERROR_REQUEST_TIMED_OUT;
      return FALSE;
   }
   else if ( !GetOverlappedResult( connTbl[target].handle, &connTbl[target].overlap, &bytesActual, FALSE ) ) { 
      connTbl[target].lastError = GetLastError();
      return FALSE;
   }

   if ( retryCt >= PC_MAX_RETRIES + 1 ) return FALSE;

   if ( bytesToWrite != bytesActual ) {
      connTbl[target].lastError = PCERROR_IO_INCOMPLETE;
      return FALSE;
   }

   return PCReadRsp( target );
}

//======================================================================================//
// PCOpen -- establish connection to PC on named machine.
// Returns:   PCid to use with future PC calls or 0 on error (use PCGetLastError).
// Arguments: 0) pointer to target computer name or NULL to use local machine,
//            1) buffer to be used in server communication or NULL (library allocates).
//            2) size of buffer supplied or to be allocated in bytes. 
//======================================================================================//
PCid PCOpen( const TCHAR *targetComputer, char *buffer, PCUINT32 bufSize )
{

   if ( bufSize < PC_MIN_BUF_SIZE || bufSize > PC_MAX_BUF_SIZE ) {
      connTbl[0].lastError = PCERROR_INVALID_PARAMETER;
      return 0;
   }

   TCHAR pipe[MAX_PATH];
   _tcscpy( pipe, TEXT("\\\\") );
   _tcscat( pipe, targetComputer? targetComputer : TEXT(".") );
   _tcscat( pipe, PIPENAME );

   // Connect to desired server and pipe...
   if ( WaitNamedPipe( pipe, NMPWAIT_USE_DEFAULT_WAIT ) ) {
      HANDLE hPipe = CreateFile( pipe, GENERIC_READ + GENERIC_WRITE, 0,
                                 NULL, OPEN_EXISTING, 
                                 SECURITY_SQOS_PRESENT + SECURITY_IMPERSONATION + FILE_FLAG_OVERLAPPED, 
                                 NULL );
   
      // Map result to local handle table and return index...
      if ( hPipe != INVALID_HANDLE_VALUE ) {
         if ( ++nextId >= ENTRY_COUNT(connTbl) ) nextId = 1;
         for ( int i = nextId, ctr = 1; 
               ctr++ < ENTRY_COUNT(connTbl) && connTbl[i].handle; 
               i = i >= ENTRY_COUNT(connTbl)? 1 : i + 1 ) ;
         if ( ctr >= ENTRY_COUNT(connTbl) ) {
            connTbl[0].lastError = PCERROR_TOO_MANY_CONNECTIONS;
            CloseHandle( hPipe );
            return 0;
         }
         if ( !buffer ) {
            buffer = new char[bufSize];
            if ( buffer ) connTbl[i].flags |= PCAPIFLAG_FREEBUFFER;
            else {
               connTbl[0].lastError = ERROR_NOT_ENOUGH_MEMORY;
               CloseHandle( hPipe );
               return 0;
            }
         }

         _tcscpy( connTbl[i].name, pipe );
         connTbl[i].handle    = hPipe;
         connTbl[i].connCount = 1;
         connTbl[i].connTime  = time( NULL );
         connTbl[i].lastError = PCERROR_SUCCESS;
         connTbl[i].buffer    = buffer;
         connTbl[i].bufSize   = bufSize;
         connTbl[i].timeout   = 5000;
         memset( &connTbl[i].overlap, 0, sizeof(connTbl[i].overlap) );
         connTbl[i].overlap.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
         return i;
      }
   }

   DWORD lErr = GetLastError();
   connTbl[0].lastError = (lErr == ERROR_FILE_NOT_FOUND)? PCERROR_SERVICE_NOT_RUNNING : lErr;
   return 0;      
}

//======================================================================================//
// PCClose -- break connection to PC on previously connected machine.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen, 
//======================================================================================//
BOOL PCClose( PCid target )
{
   BOOL rc = PCIsValidPCId( target );

   if ( rc ) {
      if ( !CloseHandle( connTbl[target].handle ) ) {
         connTbl[target].lastError = GetLastError();
         rc = FALSE;
      }
      if ( connTbl[target].flags & PCAPIFLAG_FREEBUFFER ) {
         delete [] connTbl[target].buffer;
      }
      connTbl[target].handle = connTbl[target].buffer  = NULL;
      connTbl[target].flags  = connTbl[target].bufSize = 0;
   }

   return rc;
}     

//======================================================================================//
// PCGetLastError -- return last error reported for a target
// Returns:   last PC API error for this client.
// Arguments: 0) PCid from PCOpen, 
//======================================================================================//
PCULONG32 PCGetLastError( PCid target )
{
   if ( target >= 0 && target < ENTRY_COUNT(connTbl) )
      return connTbl[target].lastError;
   else
      return PCERROR_INVALID_PCID;
}     

//======================================================================================//
// PCGetServiceInfo -- get ProcCon Service indentification and parameters.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) pointer to area to receive system information, 
//            2) size of this area in bytes,
//======================================================================================//
BOOL PCGetServiceInfo( PCid target, PCSystemInfo *sysInfo, PCINT32 nByteCount )
{
   if ( !PCIsValidPCId( target ) ) return FALSE;

   // Build request...
   PCBuildReq( target, PCOP_GET, PCTYPE_SERVERINFO ); 

   // Send request, receive response and verify success...
   if ( !PCSendReceive( target ) ) return FALSE;

   // Pass appropriate data back to caller...
   PCCopyData( target, sysInfo, 1, nByteCount );
   return TRUE;
}

//======================================================================================//
// PCControlFunction -- various ProcCon control functions to support restore, etc.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) control flags to describe desired control functions, 
//            2) [optional] data that modifies control function.
//======================================================================================//
BOOL PCControlFunction( PCid target, PCINT32 ctlFlags, PCINT32 ctlData ) 
{
   if ( !PCIsValidPCId( target ) ) return FALSE;

   // Build request...
   PCBuildReq( target, PCOP_CTL, PCTYPE_CONTROL, NULL, 0, 0, ctlFlags, ctlData ); 

   // Send request, receive response and pass back result...
   return PCSendReceive( target );
}

//======================================================================================//
// PCSetServiceParms -- set ProcCon Service parameters.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) pointer to area containing new system parameters, 
//            2) size of this area in bytes,
//======================================================================================//
BOOL PCSetServiceParms( PCid target, PCSystemParms *sysParms, PCINT32 nByteCount )
{
   if ( !PCIsValidPCId( target ) ) return FALSE;

   // Apply timeout locally...
   // We apply our value right away so that it covers this call...
   // If out of range, reject it and skip calling the server.
   if ( sysParms->timeoutValueMs < PC_MIN_TIMEOUT || 
        sysParms->timeoutValueMs > PC_MAX_TIMEOUT ) {
      connTbl[target].lastError = PCERROR_INVALID_PARAMETER;
      return FALSE;
   }
   else
      connTbl[target].timeout = sysParms->timeoutValueMs;

   // Build request...
   PCBuildReq( target, PCOP_REP, PCTYPE_SERVERPARMS, sysParms, 
               sizeof(PCSystemParms), nByteCount ); 

   // Send request, receive response and pass back result...
   BOOL rc = PCSendReceive( target );
   return rc;
}

//======================================================================================//
// PCKillProcess -- kill the specified process
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) Pid of the process to kill from PCGetProcList statistics, 
//            2) Create time of the process to kill from PCGetProcList statistics.
//======================================================================================//
BOOL PCKillProcess( PCid target, PID_VALUE processPid, TIME_VALUE createTime )
{
   if ( !PCIsValidPCId( target ) ) return FALSE;

   // Build request...
   PCBuildReq( target, PCOP_KILL, PCTYPE_PROCLIST, &createTime, sizeof(createTime), 0, processPid ); 

   // Send request, receive response and pass back result...
   return PCSendReceive( target );
}

//======================================================================================//
// PCKillJob -- kill the specified job
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) Name of the job to kill. 
//======================================================================================//
BOOL PCKillJob( PCid target, JOB_NAME jobName )
{
   if ( !PCIsValidPCId( target ) ) return FALSE;

   // Build request...
   PCBuildReq( target, PCOP_KILL, PCTYPE_JOBLIST, jobName, sizeof(JOB_NAME) ); 

   // Send request, receive response and pass back result...
   return PCSendReceive( target );
}

//======================================================================================//
// PCGetNameRules -- get fixed-format table containing name rules, one entry per rule.
// Returns:    1 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) pointer to table to receive name rule list, 
//            2) size of this table in bytes,
//            3) [optional, default is 0] index of first entry to return (0-relative),
//            4) [optional] location to store update counter to be supplied on update.
// Notes:     If PCGetLastError returns PCERROR_MORE_DATA, there is more data to retrieve.
//            Name rule order is significant: rules are executed from top to bottom.
//======================================================================================//
PCINT32 PCGetNameRules( PCid target,  PCNameRule *pRuleList, PCINT32 nByteCount, 
                      PCINT32 nFirst, PCINT32 *nUpdateCtr )
{
   if ( !PCIsValidPCId( target ) ) return -1;

   // Build request...
   PCINT32 maxItemsRequested = PCMaxItemCount( target, nByteCount, sizeof(PCNameRule) );
   PCBuildReq( target, PCOP_GET, PCTYPE_NAMERULE, 
               pRuleList, sizeof(PCNameRule), nByteCount, 
               0, maxItemsRequested, nFirst ); 

   // Send request, receive response and verify success...
   if ( !PCSendReceive( target ) ) return -1;

   // Pass appropriate data back to caller...
   return PCCopyData( target, pRuleList, maxItemsRequested, nByteCount, nUpdateCtr );
} 

//======================================================================================//
// PCGetProcSummary -- get fixed-format table summarizing all defined processes.
// Returns:    0 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) pointer to table to receive rule summary list, first entry indicates start point, 
//            2) size of this table in bytes.
//            3) a set of flags used to further specify or limit list operation.
// Notes:     If PCGetLastError returns PCERROR_MORE_DATA, there is more data to retrieve.
//            List entries are in alphabetic order by process name.
//======================================================================================//
PCINT32 PCGetProcSummary( PCid target, PCProcSummary *pProcList, PCINT32 nByteCount, PCUINT32 listFlags )
{
   if ( !PCIsValidPCId( target ) ) return -1;

   // Build request...
   PCINT32 maxItemsRequested = PCMaxItemCount( target, nByteCount, sizeof(PCProcSummary) );
   PCBuildReq( target, PCOP_GET, PCTYPE_PROCSUMMARY, 
               pProcList, sizeof(PCProcSummary), nByteCount, listFlags, maxItemsRequested ); 

   // Send request, receive response and verify success...
   if ( !PCSendReceive( target ) ) return -1;

   // Pass appropriate data back to caller...
   return PCCopyData( target, pProcList, maxItemsRequested, nByteCount );
} 
 
//======================================================================================//
// PCGetJobSummary -- get fixed-format table summarizing all defined jobs.
// Returns:    0 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) pointer to table to receive rule summary list, first entry indicates start point, 
//            2) size of this table in bytes.
//            3) a set of flags used to further specify or limit list operation.
// Notes:     If PCGetLastError returns PCERROR_MORE_DATA, there is more data to retrieve.
//            List entries are in alphabetic order by job name.
//======================================================================================//
PCINT32 PCGetJobSummary( PCid target, PCJobSummary *pJobList, PCINT32 nByteCount, PCUINT32 listFlags ) 
{
   if ( !PCIsValidPCId( target ) ) return -1;

   // Build request...
   PCINT32 maxItemsRequested = PCMaxItemCount( target, nByteCount, sizeof(PCJobSummary) );
   PCBuildReq( target, PCOP_GET, PCTYPE_JOBSUMMARY, 
               pJobList, sizeof(PCJobSummary), nByteCount, listFlags, maxItemsRequested ); 

   // Send request, receive response and verify success...
   if ( !PCSendReceive( target ) ) return -1;

   // Pass appropriate data back to caller...
   return PCCopyData( target, pJobList, maxItemsRequested, nByteCount );
} 

//======================================================================================//
// PCGetJobList -- get list of all defined jobs, both running and not.
// Returns:    0 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) pointer to structure to receive job list, 
//            2) size of this structure in bytes.
//            3) a TRUE/FALSE flag indicating if only running jobs should be included.
// Notes:     If PCGetLastError returns PCERROR_MORE_DATA, there is more data to retrieve.
//            List entries are in alphabetic order by job name.
//======================================================================================//
PCINT32 PCGetJobList( PCid target, PCJobListItem *pJobList, PCINT32 nByteCount, PCUINT32 listFlags )
{
   if ( !PCIsValidPCId( target ) ) return -1;

   // Build request...
   PCINT32 maxItemsRequested = PCMaxItemCount( target, nByteCount, sizeof(PCJobListItem) );
   PCBuildReq( target, PCOP_GET, PCTYPE_JOBLIST, 
               pJobList, sizeof(PCJobListItem), nByteCount, listFlags, maxItemsRequested ); 

   // Send request, receive response and verify success...
   if ( !PCSendReceive( target ) ) return -1;

   // Pass appropriate data back to caller...
   return PCCopyData( target, pJobList, maxItemsRequested, nByteCount );
} 

//======================================================================================//
// PCGetProcList -- get list of all defined process names, both running and not.
// Returns:    0 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError. 
// Arguments: 0) PCid from PCOpen,
//            1) pointer to structure to receive process list, 
//            2) size of this structure in bytes.
//            3) a TRUE/FALSE flag indicating if only running jobs should be included.
// Notes:     If PCGetLastError returns PCERROR_MORE_DATA, there is more data to retrieve.
//            List entries are in alphabetic order by process name.
//======================================================================================//
PCINT32 PCGetProcList( PCid target, PCProcListItem *pProcList, PCINT32 nByteCount, PCUINT32 listFlags )
{
   if ( !PCIsValidPCId( target ) ) return -1;

   // Build request...
   PCINT32 maxItemsRequested = PCMaxItemCount( target, nByteCount, sizeof(PCProcListItem) );
   PCBuildReq( target, PCOP_GET, PCTYPE_PROCLIST, 
               pProcList, sizeof(PCProcListItem), nByteCount, listFlags, maxItemsRequested ); 

   // Send request, receive response and verify success...
   if ( !PCSendReceive( target ) ) return -1;

   // Pass appropriate data back to caller...
   return PCCopyData( target, pProcList, maxItemsRequested, nByteCount );
} 

//======================================================================================//
// PCGetProcDetail -- get full management and descriptive data associated with a process name.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to structure to receive process data, 
//            2) size of this structure in bytes,
//            3) [optional] location to store update counter to be supplied on update.
// Note:      If the process is a member of a job, the job's management rules will be
//            used instead of the process rules unless the job definition is missing.
//======================================================================================//
BOOL PCGetProcDetail( PCid target, PCProcDetail *pProcDetail, PCINT32 nByteCount, PCINT32 *nUpdateCtr )
{
   if ( !PCIsValidPCId( target ) ) return FALSE;

   // Build request...
   PCBuildReq( target, PCOP_GET, PCTYPE_PROCDETAIL, pProcDetail, 
               offsetof(PCProcDetail, vLength), nByteCount ); 

   // Send request, receive response and verify success...
   if ( !PCSendReceive( target ) ) return FALSE;

   // Pass appropriate data back to caller...
   PCCopyData( target, pProcDetail, 1, nByteCount, nUpdateCtr );
   return TRUE;
} 

//======================================================================================//
// PCGetJobDetail -- get full management and descriptive data associated with a job name.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to structure to receive job data, 
//            2) size of this structure in bytes,
//            3) [optional] location to store update counter to be supplied on update.
//======================================================================================//
BOOL PCGetJobDetail( PCid target, PCJobDetail *pJobDetail, PCINT32 nByteCount, PCINT32 *nUpdateCtr )
{
   if ( !PCIsValidPCId( target ) ) return FALSE;

   // Build request...
   PCBuildReq( target, PCOP_GET, PCTYPE_JOBDETAIL, pJobDetail, 
               offsetof(PCProcDetail, vLength), nByteCount ); 

   // Send request, receive response and verify success...
   if ( !PCSendReceive( target ) ) return FALSE;

   // Pass appropriate data back to caller...
   PCCopyData( target, pJobDetail, 1, nByteCount, nUpdateCtr );
   return TRUE;
}

//======================================================================================//
// PCAddNameRule -- add a name rule to the name rule table.
// Returns:    0 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to name rule to add, 
//            2) index of name rule line BEFORE which this addition is to occur (0-based), 
//            3) update counter returned from PCGetNameRules,
//            4-6) [optional] same args as PCGetNameRules to return updated name rule table.
//======================================================================================//
PCINT32 PCAddNameRule( PCid target, PCNameRule *pRule, PCINT32 nIndex, PCINT32 nUpdateCtr,
                       PCNameRule *pRuleList, PCINT32 nByteCount, PCINT32 nFirst, PCINT32 *nNewUpdateCtr )
{
   if ( !PCIsValidPCId( target ) ) return -1;

   // Build request...
   PCINT32 maxItemsRequested = PCMaxItemCount( target, nByteCount, sizeof(PCNameRule) );
   PCBuildReq( target, PCOP_ADD, PCTYPE_NAMERULE, 
               pRule, sizeof(PCNameRule), nByteCount, 
               nIndex, maxItemsRequested, nFirst, nUpdateCtr ); 
   if ( pRuleList ) PCSetReqFlag( target, PCREQFLAG_DOLIST );

   // Send request, receive response and verify success...
   if ( !PCSendReceive( target ) ) return -1;

   // Pass appropriate data back to caller...
   if ( pRuleList ) 
      return PCCopyData( target, pRuleList, maxItemsRequested, nByteCount, nNewUpdateCtr );
   else return 0;
} 

//======================================================================================//
// PCReplNameRule -- Replace a name rule in the name rule table.
// Returns:    0 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to name rule replacement data, 
//            2) index of name rule line to replace (0-based), 
//            3) update counter returned from PCGetNameRules,
//            4-6) [optional] same args as PCGetNameRules to return updated name rule table.
//======================================================================================//
PCINT32 PCReplNameRule( PCid target, PCNameRule *pRule, PCINT32 nIndex, PCINT32 nUpdateCtr,
                        PCNameRule *pRuleList, PCINT32 nByteCount, PCINT32 nFirst, PCINT32 *nNewUpdateCtr )
{
   if ( !PCIsValidPCId( target ) ) return -1;

   // Build request...
   PCINT32 maxItemsRequested = PCMaxItemCount( target, nByteCount, sizeof(PCNameRule) );
   PCBuildReq( target, PCOP_REP, PCTYPE_NAMERULE, 
               pRule, sizeof(PCNameRule), nByteCount, 
               nIndex, maxItemsRequested, nFirst, nUpdateCtr ); 
   if ( pRuleList ) PCSetReqFlag( target, PCREQFLAG_DOLIST );

   // Send request, receive response and verify success...
   if ( !PCSendReceive( target ) ) return -1;

   // Pass appropriate data back to caller...
   if ( pRuleList )
      return PCCopyData( target, pRuleList, maxItemsRequested, nByteCount, nNewUpdateCtr );
   else return 0;
} 

//======================================================================================//
// PCDeleteNameRule -- Delete a name rule from the name rule table.
// Returns:    0 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) index of name rule line to delete (0-based), 
//            2) update counter returned from PCGetNameRules,
//            3-5) [optional] same args as PCGetNameRules to return updated name rule table.
//======================================================================================//
PCINT32 PCDeleteNameRule( PCid target, PCINT32 nIndex, PCINT32 nUpdateCtr,
                          PCNameRule *pRuleList, PCINT32 nByteCount, PCINT32 nFirst, PCINT32 *nNewUpdateCtr )
{
   if ( !PCIsValidPCId( target ) ) return -1;

   // Build request...
   PCINT32 maxItemsRequested = PCMaxItemCount( target, nByteCount, sizeof(PCNameRule) );
   PCBuildReq( target, PCOP_DEL, PCTYPE_NAMERULE, 
               NULL, 0, nByteCount, 
               nIndex, maxItemsRequested, nFirst, nUpdateCtr ); 
   if ( pRuleList ) PCSetReqFlag( target, PCREQFLAG_DOLIST );

   // Send request, receive response and verify success...
   if ( !PCSendReceive( target ) ) return -1;

   // Pass appropriate data back to caller...
   if ( pRuleList )
      return PCCopyData( target, pRuleList, maxItemsRequested, nByteCount, nNewUpdateCtr );
   else return 0;
} 

//======================================================================================//
// PCSwapNameRules -- Swap the order of two adjacent entries in the name rule table.  
// Note:      This API is needed because the order of entires in the table is significant.
// Returns:    0 or greater to indicate the number of items in the response (may be incomplete).
//            -1 on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) index of name rule line to swap with line index+1 (0-based), 
//            2) update counter returned from PCGetNameRules,
//            3-5) [optional] same args as PCGetNameRules to return updated name rule table.
//======================================================================================//
PCINT32 PCSwapNameRules( PCid target, PCINT32 nIndex, PCINT32 nUpdateCtr,
                         PCNameRule *pRuleList, PCINT32 nByteCount, PCINT32 nFirst, PCINT32 *nNewUpdateCtr )
{
   if ( !PCIsValidPCId( target ) ) return -1;

   // Build request...
   PCINT32 maxItemsRequested = PCMaxItemCount( target, nByteCount, sizeof(PCNameRule) );
   PCBuildReq( target, PCOP_ORD, PCTYPE_NAMERULE, 
               NULL, 0, nByteCount, nIndex, maxItemsRequested, nFirst, nUpdateCtr ); 
   if ( pRuleList ) PCSetReqFlag( target, PCREQFLAG_DOLIST );

   // Send request, receive response and verify success...
   if ( !PCSendReceive( target ) ) return -1;

   // Pass appropriate data back to caller...
   if ( pRuleList ) 
      return PCCopyData( target, pRuleList, maxItemsRequested, nByteCount, nNewUpdateCtr );
   else return 0;
} 

//======================================================================================//
// PCAddProcDetail -- add a new process to the process management database.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to process detail to add, name must not exist.
//            2) [optional] pointer to buffer to retrieve updated proc summary for this entry.
// Note:      No update counter is needed for adding detail since add fails if the name 
//            exists.
//======================================================================================//
BOOL PCAddProcDetail( PCid target, PCProcDetail *pProcDetail, PCProcSummary *pProcList )
{
   if ( !PCIsValidPCId( target ) ) return FALSE;

   // Build request...
   PCBuildReq( target, PCOP_ADD, PCTYPE_PROCDETAIL, pProcDetail, 
               (PCINT16) (offsetof(PCProcDetail, vData) + pProcDetail->vLength) ); 
   if ( pProcList ) PCSetReqFlag( target, PCREQFLAG_DOLIST );

   // Send request, receive response and verify success...
   if ( !PCSendReceive( target ) ) return FALSE;

   // Pass appropriate data back to caller...
   if ( pProcList ) 
      PCCopyData( target, pProcList, 1, sizeof(PCProcSummary) );
   return TRUE;
} 

//======================================================================================//
// PCDeleteProcDetail -- Delete a process from the process management database.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to process detail to Delete, name must exist,
// Note:      No update counter is needed for deleting since delete fails if the name 
//            doesn't exist.
//======================================================================================//
BOOL PCDeleteProcDetail( PCid target, PCProcDetail *pProcDetail )
{
   if ( !PCIsValidPCId( target ) ) return FALSE;

   // Build request (note that only the summary portion is included)...
   PCBuildReq( target, PCOP_DEL, PCTYPE_PROCDETAIL, pProcDetail, sizeof( PCProcSummary ) ); 

   // Send request, receive response and verify success...
   return PCSendReceive( target );
} 

//======================================================================================//
// PCReplProcDetail -- Replace a process in the process management database.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to process detail to replace, name must exist,
//            2) update counter from PCGetProcDetail.
//            3) [optional] pointer to buffer to retrieve updated proc summary for this entry.
//======================================================================================//
BOOL PCReplProcDetail( PCid target, PCProcDetail *pProcDetail, PCINT32 nUpdateCtr, PCProcSummary *pProcList )
{
   if ( !PCIsValidPCId( target ) ) return FALSE;

   // Build request...
   PCBuildReq( target, PCOP_REP, PCTYPE_PROCDETAIL, pProcDetail, 
               (PCINT16) (offsetof(PCProcDetail, vData) + pProcDetail->vLength), 0, 0, 1, 0, nUpdateCtr ); 
   if ( pProcList ) PCSetReqFlag( target, PCREQFLAG_DOLIST );

   // Send request, receive response and verify success...
   if ( !PCSendReceive( target ) ) return FALSE;

   // Pass appropriate data back to caller...
   if ( pProcList ) 
      PCCopyData( target, pProcList, 1, sizeof(PCProcSummary) );
   return TRUE;
} 


//======================================================================================//
// PCAddJobDetail -- add a new job definition to the job management database.
// Returns:   1 on success (treat as TRUE or as a count if summary item requested).
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to job detail to add, name must not exist,
//            2) [optional] pointer to buffer to retrieve updated job summary for this entry.
// Note:      No update counter is needed for adding since add fails if the name 
//            exists.
//======================================================================================//
BOOL PCAddJobDetail( PCid target, PCJobDetail *pJobDetail, PCJobSummary *pJobList ) 
{
   if ( !PCIsValidPCId( target ) ) return FALSE;

   // Build request...
   PCBuildReq( target, PCOP_ADD, PCTYPE_JOBDETAIL, pJobDetail, 
               (PCINT16) (offsetof(PCJobDetail, vData) + pJobDetail->vLength) ); 
   if ( pJobList ) PCSetReqFlag( target, PCREQFLAG_DOLIST );

   // Send request, receive response and verify success...
   if ( !PCSendReceive( target ) ) return FALSE;

   // Pass appropriate data back to caller...
   if ( pJobList ) 
      PCCopyData( target, pJobList, 1, sizeof(PCJobSummary) );
   return TRUE;
}

//======================================================================================//
// PCDeleteJobDetail -- Delete a job from the job management database.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to job detail to Delete, name must exist,
// Note:      No update counter is needed for deleting since delete fails if the name 
//            doesn't exist.
//======================================================================================//
BOOL PCDeleteJobDetail( PCid target, PCJobDetail *pJobDetail )
{
   if ( !PCIsValidPCId( target ) ) return FALSE;

   // Build request (note that only the summary portion is included)...
   PCBuildReq( target, PCOP_DEL, PCTYPE_JOBDETAIL, pJobDetail, sizeof( PCJobSummary ) ); 

   // Send request, receive response and verify success...
   return PCSendReceive( target );
}

//======================================================================================//
// PCReplJobDetail -- Replace a job in the job management database.
// Returns:   TRUE on success.
//            FALSE on failure, use PCGetLastError.
// Arguments: 0) PCid from PCOpen,
//            1) pointer to job detail to replace, name must exist,
//            2) update counter from PCGetJobDetail.
//            3) [optional] pointer to buffer to retrieve updated job summary for this entry.
//======================================================================================//
BOOL PCReplJobDetail( PCid target, PCJobDetail *pJobDetail, PCINT32 nUpdateCtr, PCJobSummary *pJobList )
{
   if ( !PCIsValidPCId( target ) ) return FALSE;

   // Build request...
   PCBuildReq( target, PCOP_REP, PCTYPE_JOBDETAIL, pJobDetail, 
               (PCINT16) (offsetof(PCJobDetail, vData) + pJobDetail->vLength), 0, 0, 1, 0, nUpdateCtr ); 
   if ( pJobList ) PCSetReqFlag( target, PCREQFLAG_DOLIST );

   // Send request, receive response and verify success...
   if ( !PCSendReceive( target ) ) return FALSE;

   // Pass appropriate data back to caller...
   if ( pJobList ) 
      PCCopyData( target, pJobList, 1, sizeof(PCJobSummary) );
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\service\cprocconmgr.cpp ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998, 1999  Sequent Computer Systems, Incorporated                       //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|---------------------------------------------------------------------------------------//            
|   This file implements the CProcConMgr class methods defined in ProcConSvc.h          //
|---------------------------------------------------------------------------------------//            
|                                                                                       //
|Created:                                                                               //
|                                                                                       //
|   Jarl McDonald 07-98                                                                 //
|                                                                                       //
|Revision History:                                                                      //
|                                                                                       //
|=======================================================================================*/
#include "ProcConSvc.h"
#include <psapi.h>         

// Constructor
// Note: this function runs as part of service start so keep it quick!
CProcConMgr::CProcConMgr( PCContext *ctxt ) : 
                 m_mediatorEvent( ctxt->mediatorEvent ),
                 m_mediatorTable( ctxt->mediatorTable ),
                 m_cPC( *ctxt->cPC ),     m_cDB( *ctxt->cDB ),   
                 m_rawProcList( NULL ),   m_rawProcCount( 0 ), 
                 m_procManagedCount( 0 ), m_jobManagedCount( 0 ),
                 m_procAnchor( NULL ),    m_jobAnchor( NULL ),
                 m_reportThread( NULL ),  
                 m_systemMask( 1 ),       m_sequencer( 1 )
{
   ULONG_PTR mask;
   
   InitializeCriticalSection( &m_mgCSMgrLists );
   
   PCBuildAdminSecAttr( m_secAttr );

   GetProcessAffinityMask( GetCurrentProcess(), &mask, &m_systemMask );
   
   m_assocPort.CompletionPort = ctxt->completionPort;
   if ( m_assocPort.CompletionPort ) {
      m_reportThread = CreateThread( NULL, 10000, &JobReporter, this, 0, NULL );
      if ( !m_reportThread ) {
         PCLogUnExError( TEXT("JobReporter"), TEXT("CreateThread") );
         CloseHandle( m_assocPort.CompletionPort );
         m_assocPort.CompletionPort = NULL;
      }
   }
}

// Destructor
CProcConMgr::~CProcConMgr( void ) 
{
   EnterCriticalSection( &m_mgCSMgrLists );

   if ( m_rawProcList ) delete [] m_rawProcList;
   for ( ManagedProc *nextProc, *proc = m_procAnchor; proc; proc = nextProc ) {
      nextProc = proc->next;
      delete proc;
   }
   for ( ManagedJob *nextJob, *job = m_jobAnchor; job; job = nextJob ) {
      nextJob = job->next;
      delete job;       
   }
   m_jobAnchor       = NULL;
   m_procAnchor      = NULL;
   m_jobManagedCount = m_procManagedCount = 0;

   PCFreeSecAttr( m_secAttr );

   LeaveCriticalSection( &m_mgCSMgrLists );
   DeleteCriticalSection( &m_mgCSMgrLists );
}

//--------------------------------------------------------------------------------------------//
// Function to determine if all CProcConMgr initial conditions have been met                  //
// Input:    None                                                                             //
// Returns:  TRUE if ready, FALSE if not                                                      //
//--------------------------------------------------------------------------------------------//
BOOL CProcConMgr::ReadyToRun( void ) 
{ 
   return m_secAttr.lpSecurityDescriptor != NULL; 
}

//--------------------------------------------------------------------------------------------//
// The Process Management thread                                                              //
// Input:    nothing                                                                          //
// Returns:  0 if successful, 1 if not                                                        //
//--------------------------------------------------------------------------------------------//
PCULONG32 CProcConMgr::Run( void )                          
{

   HANDLE objList[] = { m_cPC.GetShutEvent(), m_cDB.GetDbEvent() };

   // Trigger database load...
   if ( m_cDB.LoadRules( m_cDB.LOADFLAG_ALL_RULES ) != ERROR_SUCCESS )
      return 1;

   // ProcCon main process loop...
   for ( ;; ) {

      // Discover all running processes/jobs...
      Discover();

      // Apply management rules...
      Manage();

      PCULONG32 event = WaitForMultipleObjects( ENTRY_COUNT(objList), objList, FALSE, m_cDB.GetPollDelay() ); 
      if ( event == WAIT_FAILED ) {
      	PCLogUnExError( TEXT("PCManager"), TEXT("Wait") );
         break;
      }
      
      // if wait ended due to db update or timeout we loop, for shutdown we stop looping...
      if ( event - WAIT_OBJECT_0 == 0 ) {   // we got shutdown event
         if ( m_assocPort.CompletionPort ) 
            PostQueuedCompletionStatus( m_assocPort.CompletionPort, 0, 0, NULL );
         Sleep( 1000 );
         break;
      }

   }  // end for

   return 0;
}

//--------------------------------------------------------------------------------------------//
// Job Object Completion Port: function to listen to the job completion port and handle msgs. //
// Input:    pointer to CProcConMgr class (function is static)                                //
// Returns:  nothing -- runs until shutdown requested                                         //
// Note:     this is a static member function and thus does not have a 'this' context.        //
//--------------------------------------------------------------------------------------------//
PCULONG32 __stdcall CProcConMgr::JobReporter( void *inPtr ) {

   CProcConMgr &cMgr = *((CProcConMgr *) inPtr);

   OVERLAPPED *data;
   DWORD       msgId; 
   ULONG_PTR   compKey;

   while ( GetQueuedCompletionStatus( cMgr.GetComplPort(), &msgId, &compKey, &data, INFINITE ) ) {

      if ( !compKey ) break;                    // shutdown requested

      EnterCriticalSection( cMgr.GetListCSPtr() );

      for ( ManagedJob *job = cMgr.GetJobAnchor(); job && compKey != job->compKey; job = job->next ) ;

      // If we found the job, proceed to handle the event...
      if ( job ) {
         TCHAR value[24], pid[24];       
         const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job->fullJobName, value, pid };

         // Make sure we have the latest job definition...
         PCJobDef *jobDef;
         if ( cMgr.m_cDB.GetJobMgmtDefs( &jobDef, &job->jName ) ) { // Returns 0 if job definition not found
            cMgr.UpdateJobEntry( *job, jobDef );
            delete [] jobDef;
         }

         // Make sure we have the latest job stats...
         cMgr.UpdateJobObjInfo( *job );

         switch ( msgId ) {
         //******** job time limit hit, data is NULL
         case JOB_OBJECT_MSG_END_OF_JOB_TIME: {
            _i64tot( PCLargeIntToInt64( job->JOExtendedLimitInfo.BasicLimitInformation.PerJobUserTimeLimit ) / 10000, value, 10 );
            // Check for termination or just post...
            DWORD rc = WaitForSingleObject( job->jobHandle, 0 );
            // If we're only posting the limit exceeded, issue msg, suppress future msgs...
            if ( rc == WAIT_TIMEOUT ) {      
               PCLogMessage( PC_SERVICE_JOB_HIT_TIME_LIMIT_NOTERM, EVENTLOG_INFORMATION_TYPE, 
                             ENTRY_COUNT(msgs), msgs );
               job->timeExceededReported = TRUE;                         // suppress additional reports
            }
            // If we're posting the limit exceeded with all procs terminated, issue msg, clear state...
            else {                           
               PCLogMessage( PC_SERVICE_JOB_HIT_TIME_LIMIT_TERMINATED, EVENTLOG_INFORMATION_TYPE, 
                             ENTRY_COUNT(msgs), msgs );
               job->curJobTimeLimitCNS = 0;                              // clear limit to force update
               cMgr.ApplyJobMgmt( *job );                                // go re-apply time limit to reset
            }
            break;
            }
         //******** proc time limit hit, proc already being terminated, data = PID
         case JOB_OBJECT_MSG_END_OF_PROCESS_TIME: 
            _i64tot( (ULONG_PTR) data, pid, 10 );
            _i64tot( PCLargeIntToInt64( job->JOExtendedLimitInfo.BasicLimitInformation.PerProcessUserTimeLimit ) / 10000, value, 10 );         
            PCLogMessage( PC_SERVICE_PROC_HIT_TIME_LIMIT, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
            break;
         //******** proc count limit hit, data = NULL
         case JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT: 
            _ltot( job->JOExtendedLimitInfo.BasicLimitInformation.ActiveProcessLimit, value, 10 );         
            PCLogMessage( PC_SERVICE_JOB_HIT_COUNT_LIMIT, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
            break;
         //******** proc count hit 0, data = NULL
         case JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO:
            if ( job->jobParms.mFlags & PCMFLAG_END_JOB_WHEN_EMPTY )
               cMgr.JobIsEmpty( job );                 // job should be deleted after this call!
            break;
         //******** process created in job or added to job, data = PID
         case JOB_OBJECT_MSG_NEW_PROCESS: {
            PID_VALUE newPid = (ULONG_PTR) data;
            // See if the proc is one of our managed procs (will be if entry is for adding, not creating)...
            for ( ManagedProc *Proc = cMgr.GetProcAnchor(); 
                  Proc && Proc->pStats.pid != newPid; 
                  Proc = Proc->next ) ;
            // if not found, not in a job, or not in this job report on its creation...
            if ( !Proc || !Proc->reportAdd ) {                           
               TCHAR procName[PROC_NAME_LEN + 1], imageName[IMAGE_NAME_LEN + 1], pid[32];       
               const TCHAR *pmsgs[] = { PROCCON_SVC_DISP_NAME, job->fullJobName, procName, pid, imageName };
               _i64tot( (ULONG_PTR) data, pid, 10 );
               // Make sure new proc is in our raw proc list...
               cMgr.Discover();                     
               // Now locate the proc by PID...
               for ( PCULONG32 i = 0; 
                     i < cMgr.GetRawProcCount() && newPid != cMgr.GetRawProcEntry( i ).pId; 
                     ++i ) ;
               // If found, extract process and image names...
               if ( i < cMgr.GetRawProcCount() ) {
                  _tcscpy( procName,  cMgr.GetRawProcEntry( i ).pName );
                  _tcscpy( imageName, cMgr.GetRawProcEntry( i ).imageName );
               }
               // If not found (process that terminated already), use "unknown" (not localized)...
               else {
                  _tcscpy( procName,  PROCCON_UNKNOWN_PROCESS );
                  _tcscpy( imageName, PROCCON_UNKNOWN_PROCESS );
               }
               // Now report that this proc was created in ths job...
               PCLogMessage( PC_SERVICE_ADD_NONPC_PROC_TO_JOB, EVENTLOG_INFORMATION_TYPE, 
                             ENTRY_COUNT(pmsgs), pmsgs );
            }
            else if ( Proc->reportAdd ) {
                const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, Proc->pName, Proc->pidAsString, 
                                        Proc->imageName, job->fullJobName };
                PCLogMessage( PC_SERVICE_ADD_PROC_TO_JOB, EVENTLOG_INFORMATION_TYPE, ENTRY_COUNT(msgs), msgs );
            }
            break;
         }
         //******** process exiting job, data = PID of exiting process
         case JOB_OBJECT_MSG_EXIT_PROCESS: 
            break;
         //******** process exiting job, data = PID of exiting process
         case JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS: 
            break;
         //******** proc memory limit hit, data = PID
         case JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT:
            if ( cMgr.NotTooSoon( job, MEM_REJECT_REPORT_LIMIT ) ) {
               _i64tot( (ULONG_PTR) data, pid, 10 );
               _i64tot( job->JOExtendedLimitInfo.ProcessMemoryLimit, value, 10 );         
               PCLogMessage( PC_SERVICE_PROC_HIT_MEMORY_LIMIT, EVENTLOG_INFORMATION_TYPE, 
                             ENTRY_COUNT(msgs), msgs );
            }
            break;
         //******** job memory limit hit, data = PID of process that attempted to exceed limit
         case JOB_OBJECT_MSG_JOB_MEMORY_LIMIT: 
            if ( cMgr.NotTooSoon( job, MEM_REJECT_REPORT_LIMIT ) ) {
               _i64tot( (ULONG_PTR) data, pid, 10 );
               _i64tot( job->JOExtendedLimitInfo.JobMemoryLimit, value, 10 );         
               PCLogMessage( PC_SERVICE_JOB_HIT_MEMORY_LIMIT, EVENTLOG_INFORMATION_TYPE, 
                             ENTRY_COUNT(msgs), msgs );
            }
            break;
         default: 
            break;
         } // end switch
      }

      LeaveCriticalSection( cMgr.GetListCSPtr() );
   }

   if ( !cMgr.m_cPC.GotShutdown() )
      PCLogUnExError( TEXT("JobReporter"), TEXT("GetQueuedCompletionStatus") );
   CloseHandle( cMgr.GetComplPort() );
   return 0;
}

//--------------------------------------------------------------------------------------------//
// function to test memory exceeded reporting inteval is within limit seconds                 //
// Input:    pointer to managed job structure, limit seconds                                  //
// Returns:  TRUE if not too soon (interval exceeds limit), FALSE otherwise                   //
// Note:     if the tick ctr has wrapped, we simply treat it is as 'not too soon' and unwrap  //
//--------------------------------------------------------------------------------------------//
BOOL CProcConMgr::NotTooSoon( ManagedJob *job, PCULONG32 limit ) {
   PCULONG32 now = GetTickCount();
   BOOL      rc  = FALSE;
   if ( now < job->memRejectReportTime || ((now - job->memRejectReportTime) / 1000 >= limit) ) {
      rc = TRUE;
      job->memRejectReportTime = now;
   }
   return rc;
}

//--------------------------------------------------------------------------------------------//
// function to close a job object when no longer in use                                       //
// Input:    pointer to managed job structure                                                 //
// Returns:  nothing                                                                          //
// Note:     Caller must hold manager list critical section.                                  //
//--------------------------------------------------------------------------------------------//
void CProcConMgr::JobIsEmpty( ManagedJob *job ) {
   UpdateJobObjInfo( *job );                                            // Update stats incl proc count
   if ( job->JOBasicAndIoAcctInfo.BasicInfo.ActiveProcesses ) return;   // done - no longer empty!
   m_mediatorTable->SvcCloseEntry( job->fullJobName );
   ManagedJob *lastJob, *thisJob;
   for ( lastJob = thisJob = m_jobAnchor; thisJob; lastJob = thisJob, thisJob = thisJob->next ) {
      if ( thisJob == job ) {
         if ( lastJob == m_jobAnchor ) m_jobAnchor   = thisJob->next;
         else                          lastJob->next = thisJob->next;
         delete job;
         --m_jobManagedCount;
         break;
      }
   }
}

#define HIGHEST_SYSTEM_PID    31
//--------------------------------------------------------------------------------------------//
// function to discover all running processes and build a 'raw' list of them                  //
// Input:    none                                                                             //
// Returns:  nothing -- the current raw process list is deleted and rebuilt                   //
// Note:     A 'raw' list simply consists of an entry per process containing at least the PID //
//           and the ProcCon process name.  This list is used by the management fcns.         //
// Note 2:   There are several choices for discovering what processes are running:            //
//           Performance data registry interface (NT 3 and beyond),                           //
//           Performance data helper (NT 3 and beyond),                                       //
//           PSAPI (NT 4 and beyond),                                                         //
//           Tool help library (NT 5).                                                        //
//                                                                                            //
//           This function uses the PSAPI.  Originally toolhelp32 was used but was too buggy. //
//--------------------------------------------------------------------------------------------//
void CProcConMgr::Discover( void ) {                     

   DWORD   bytesListed, count, listCount = 512;    // first pass is double this count
   DWORD  *procList = NULL;                        // must track type used in EnumProcesses

   // Loop allocating (increasingly larger) buffer and enumerating processes until we see them all...
   do {
      // Free previous buffer, if any
      if ( procList ) delete [] procList;

      // Get a buffer we hope will be big enough (double previous size)...
      listCount *= 2;
      procList = new DWORD[listCount];

      // If complete failure, skip process enumeration...
      if ( !procList ) {
         PCLogNoMemory( TEXT("AllocTempRawProcList"), listCount * sizeof(*procList) );  // 7/28/2000 bugfix to report correct size
         return;
      }

      // Snapshot the process space...
      if ( !EnumProcesses( procList, listCount * sizeof(*procList), &bytesListed ) ) {
         PCLogUnExError( TEXT("PCDiscover"), TEXT("EnumProcesses") );
         delete [] procList;
         return;
      }
      count = bytesListed / sizeof(*procList);

   } while ( count == listCount );

   // Reset old process info...
   EnterCriticalSection( &m_mgCSMgrLists );

   if ( m_rawProcList ) delete [] m_rawProcList;
   m_rawProcCount = 0;

   // Allocate new raw process info list...
   m_rawProcList = new RawProcList[count];
   if ( !m_rawProcList ) {
      PCLogNoMemory( _T("AllocRawProcList"), sizeof(RawProcList) * count );
      LeaveCriticalSection( &m_mgCSMgrLists );
      delete [] procList;
      return;
   }
   memset( m_rawProcList, 0, sizeof(RawProcList) * count );

   // Walk the snapshot to extract data and determine process names from path names...
   TCHAR pathAndFile[MAX_PATH] = _T("");
   for ( DWORD proc = 0; proc < count; ++proc ) {

      HANDLE hProc = NULL;
      if (procList[proc] == 0) {
         _tcscpy( pathAndFile, PROCCON_SYSTEM_IDLE );
      }
      else if (procList[proc] <= HIGHEST_SYSTEM_PID) {
         _tcscpy( pathAndFile, PROCCON_SYSTEM_PROCESS );
      }
      else {
        hProc = OpenProcess( PROCESS_QUERY_INFORMATION    // to get counters, aff, prio, etc. 
                             + PROCESS_VM_READ,           // to get module information
                             FALSE, procList[proc] );
        if ( hProc ) {
           if ( !GetModuleFileNameEx( hProc, NULL, pathAndFile, ENTRY_COUNT( pathAndFile ) ) &&
                !GetModuleBaseName(   hProc, NULL, pathAndFile, ENTRY_COUNT( pathAndFile ) ) ) {
                 PCLogUnExError( procList[proc], _T("GetModuleFile/BaseName") );
           }
        }
        else continue;
      }

      // Save process data and assign process name (alias)...
      RawProcList &le = m_rawProcList[m_rawProcCount];
      le.pId = procList[proc];
      m_cDB.AssignProcName( pathAndFile, &le.pName, &le.imageName );

      // If name assigned (not hidden or unretrievable) include this in result...
      if ( *le.pName ) ++m_rawProcCount;

      // If we have an open handle, retrieve additional information, then close
      if (hProc) {
         GetProcessTimes( hProc, &le.createTime, &le.exitTime, &le.kernelTime, &le.userTime );
         le.actualPriority = PCMapPriorityToPC( GetPriorityClass( hProc ) );
         ULONG_PTR aff;
         if ( !GetProcessAffinityMask( hProc, &aff, &m_systemMask ) )
            PCLogUnExError( procList[proc], TEXT("GetAffinityMask") );
         le.actualAffinity = aff;
         CloseHandle( hProc );
      }
   }

   delete [] procList;

   // Sort the raw process list...
   qsort( m_rawProcList, m_rawProcCount, sizeof(RawProcList), CompareRawProcList );

   // Update job information...
   for ( ManagedJob *job = m_jobAnchor; job; job = job->next )
      UpdateJobObjInfo( *job );

   LeaveCriticalSection( &m_mgCSMgrLists );

}

//--------------------------------------------------------------------------------------------//
// function to apply ProcCon management rules to the system                                   //
// Input:    nothing                                                                          //
// Returns:  nothing -- process rules are applied as appropriate                              //
// Note:     entry conditions:                                                                //
//         o Running processes are listed in m_rawProcList (unless NULL), sorted by PID.      //
//         o Managed processes from last pass are listed in m_procManagedList, unless NULL.   //
//         o Managed jobs from last pass are listed in m_jobManagedList, unless NULL.         //
//         o Defined jobs and processes are available from the DB component.                  //
//         o Counts of entries are in m_rawProcCount, m_procManagedCount, m_jobManagedCount.  //
//         o No critical sections are held.                                                   //
//--------------------------------------------------------------------------------------------//
void CProcConMgr::Manage( void ) { 
   
   // Step 1 -- get the current management definitions we are to work from...
   PCJobDef  *jobDefs = NULL,  *jHit;
   PCProcDef *procDefs = NULL, *pHit;
   PCULONG32 numJobDefs  = m_cDB.GetJobMgmtDefs( &jobDefs );
   PCULONG32 numProcDefs = m_cDB.GetProcMgmtDefs( &procDefs );
   
   EnterCriticalSection( &m_mgCSMgrLists );

   // Step 2 -- allocate max possible space for a list of procs to be managed...
   ManagedProcItem *doProc = new ManagedProcItem[m_rawProcCount];
   PCULONG32 numProc = 0;
   if ( !doProc ) {
      PCLogNoMemory( TEXT("AllocManagedProcList"), sizeof(ManagedProcItem) * m_rawProcCount );
      delete [] jobDefs;  
      delete [] procDefs; 
      LeaveCriticalSection( &m_mgCSMgrLists );
      return;
   }

   // Step 3 -- locate processes in the current proc list needing management, place in managed list...
   PCULONG32 proc;
   if ( numProcDefs ) {
      for ( proc = 0; proc < m_rawProcCount; ++proc ) {
         // see if we have a definition for this proc name...
         pHit = (PCProcDef *) bsearch( m_rawProcList[proc].pName, 
                                       procDefs, 
                                       numProcDefs, 
                                       sizeof(PCProcDef), 
                                       CompareProcName );
         // A definition exists so save in our list...
         if ( pHit ) {
            doProc[numProc].pStats.pid             = m_rawProcList[proc].pId;
            doProc[numProc].pStats.createTime      = PCFileTimeToInt64( m_rawProcList[proc].createTime );
            doProc[numProc].pStats.TotalUserTime   = PCFileTimeToInt64( m_rawProcList[proc].userTime );
            doProc[numProc].pStats.TotalKernelTime = PCFileTimeToInt64( m_rawProcList[proc].kernelTime );
            doProc[numProc].pDef = pHit;
            memcpy( doProc[numProc].imageName, m_rawProcList[proc].imageName, sizeof(doProc[0].imageName) );
            ++numProc;
         }
      }
   }

   // Step 4 -- For each proc to be managed:
   //           a.  Open process handle,
   //           b.  Get process create time to determine if process is 'new' or 'old',
   //           c.  If 'old', locate existing ManagedProc and re-apply management if needed.
   //           d.  If 'new', create ManagedProc/ManagedJob apply management rules.
   //           e.  Close handle(s).
   //
   // Note: At this point we have snapshots of all data we need and hold no critical sections. 
   //       This will permit API calls, etc. to proceed without delay.

   // Bump sequencer so we can tell which entries have gone away...
   ++m_sequencer;

   // For each proc to manage -- do it...
   HANDLE hProc = NULL;
   for ( proc = 0; proc < numProc; ++proc ) {
      BOOL isManaged = FALSE;

      if ( hProc ) CloseHandle( hProc );

      PID_VALUE  pid = doProc[proc].pStats.pid;
      PCProcDef *def = doProc[proc].pDef;

      // Open process so we can manipulate it...
      hProc = OpenProcess( PROCESS_SET_QUOTA | PROCESS_TERMINATE | PROCESS_SET_INFORMATION | PROCESS_QUERY_INFORMATION, 
                           TRUE, (DWORD) pid );     // OpenProcess always uses 32-bit PID, even in Win64.  May change!
      // If we can't open it, report error unless process is simply gone, then ignore entry...
      if ( !hProc ) {
         if ( GetLastError() != ERROR_INVALID_PARAMETER )           
        	   PCLogUnExError( pid, TEXT("OpenProcess") );
         continue;
      }
      // We were able to open the process -- find or allocate a tracking entry for it.
      // The process is the same only if the pid and create time are the same...
      ManagedProc *pMProc = FindProcEntry( pid, doProc[proc].pStats.createTime );
      BOOL newProc        = pMProc == NULL;
      if ( newProc ) {
         pMProc = new ManagedProc( def->procName, pid, doProc[proc].pStats.createTime );
         if ( !pMProc ) {
            PCLogNoMemory( TEXT("AllocManagedProc"), sizeof(ManagedProc) );
            continue;
         }
      }
      pMProc->pStats.TotalUserTime   = doProc[proc].pStats.TotalUserTime;
      pMProc->pStats.TotalKernelTime = doProc[proc].pStats.TotalKernelTime;

      // Get actual priority, affinity, and image name...
      pMProc->actualPriority = PCMapPriorityToPC( GetPriorityClass( hProc ) );
      ULONG_PTR aff;
      GetProcessAffinityMask( hProc, &aff, &m_systemMask );
      pMProc->actualAffinity = aff;
      memcpy( pMProc->imageName, doProc[proc].imageName, sizeof(pMProc->imageName) );

      // Update our tracking entry for this process...
      UpdateProcEntry( *pMProc, *def, newProc );

      // If process is to be part of a job...
      TCHAR *job = def->memberOfJob;
      if ( def->mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP && *job ) {

         // Locate job definition...
         jHit = (PCJobDef *) bsearch( job, jobDefs, numJobDefs, sizeof(PCJobDef), CompareJobName );

         // Locate job tracking entry if it exists...
         ManagedJob *pMJob = FindJobEntry( job );
         BOOL newJob       = pMJob == NULL;

         // If no entry found and we have a job definition, create new entry...
         if ( newJob && jHit ) {
            pMJob = new ManagedJob( job, m_mediatorTable );
            if ( !pMJob )
               PCLogNoMemory( TEXT("AllocManagedJob"), sizeof(ManagedJob) );
         }
         // If we now have a job entry, proceed to manage the process via the job......
         if ( pMJob ) {
            // If Proc is already in a job...
            if ( pMProc->isInJob ) {
               // if not in this job, say we can't move it (but only say it once)...
               if ( pMJob != pMProc->pMJob ) {
                  if ( pMProc->pMJob && CompareJobName(pMJob->fullJobName, pMProc->lastAlreadyInJobErr) ) {
                     const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME,
                                             pMProc->pName, pMProc->pidAsString, pMProc->imageName, 
                                             pMJob->fullJobName, pMProc->pMJob->fullJobName };
                     PCLogMessage( PC_SERVICE_ALREADY_IN_JOB, EVENTLOG_ERROR_TYPE, ENTRY_COUNT(msgs), msgs );
                     memcpy( pMProc->lastAlreadyInJobErr, pMJob->fullJobName, sizeof(pMProc->lastAlreadyInJobErr) );
                  }
               }
               // if in this job and job not updated this pass, just (re)set mgmt behavior...
               else if ( pMJob->sequence != m_sequencer ) {  // this just prevents multiple calls for the same job
                  UpdateJobEntry( *pMJob, jHit, newJob );
                  UpdateJobObjInfo( *pMJob );
                  ApplyJobMgmt( *pMJob );
               }
               isManaged = TRUE;
            }
            // Proc not already in any job...
            else {
               // If job object does not exist -- create it...
               if ( !pMJob->jobHandle ) {
                  pMJob->jobHandle = CreateJobObject( &m_secAttr, pMJob->fullJobName );
                  if ( pMJob->jobHandle && GetLastError() != ERROR_ALREADY_EXISTS ) {
                     const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, pMJob->fullJobName };
                     PCLogMessage( PC_SERVICE_CREATE_JOB, EVENTLOG_INFORMATION_TYPE, ENTRY_COUNT(msgs), msgs );
                  }
                  m_mediatorTable->SvcAddEntry( pMJob->fullJobName, pMJob->compKey, m_secAttr ); // adds or updates
                     
               }
               if ( !pMJob->jobHandle )
            	   PCLogUnExError( pMJob->fullJobName, TEXT("CreateJobObj") );
               else {
                  // Update management parms with definition if any, apply mgmt to job obj, put proc in job...
                  UpdateJobEntry( *pMJob, jHit, newJob );
                  UpdateJobObjInfo( *pMJob );
                  ApplyJobMgmt( *pMJob );
                  if ( AssignProcessToJobObject( pMJob->jobHandle, hProc ) ) {
                     pMProc->pMJob     = pMJob;
                     pMProc->isInJob   = TRUE;
                     pMProc->reportAdd = TRUE;
                     isManaged         = TRUE;
                  }
                  else if ( GetLastError() == ERROR_ACCESS_DENIED ) {   // failed due to already in some other job
                     FULL_JOB_NAME errName = TEXT("-unknown-");
                     pMProc->pMJob   = NULL;                            // set the job as 'unknown'
                     pMProc->isInJob = TRUE;                            // we assume it is in some job
                     // See if this proc is in a job of ours by matching pids...
                     for ( ManagedJob *tstJob = m_jobAnchor; tstJob; tstJob = tstJob->next ) {
                        if ( GetProcListForJob( *tstJob ) ) {
                           for ( PCUINT32 pndx = 0; 
                                 pndx < tstJob->JOProcListInfo->NumberOfProcessIdsInList; 
                                 ++pndx ) {
                              if ( pMProc->pStats.pid == (PID_VALUE) tstJob->JOProcListInfo->ProcessIdList[pndx] ) {
                                 memcpy( errName, tstJob->fullJobName, sizeof(errName) );
                                 pMProc->pMJob = tstJob;
                                 isManaged     = TRUE;
                                 break;
                              }
                           }
                           delete [] ((UCHAR *) tstJob->JOProcListInfo);
                           tstJob->JOProcListInfo = NULL;
                        }
                        if ( isManaged ) break;
                     }
                     // If the job was not found or is not the job we expect, then report...
                     if ( pMProc->pMJob != pMJob && 
                          CompareJobName( pMJob->fullJobName, pMProc->lastAlreadyInJobErr ) ) {
                        const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME,
                                                pMProc->pName, pMProc->pidAsString, pMProc->imageName, 
                                                pMJob->fullJobName, errName };
                        PCLogMessage( PC_SERVICE_ALREADY_IN_JOB, EVENTLOG_ERROR_TYPE, ENTRY_COUNT(msgs), msgs );
                        memcpy( pMProc->lastAlreadyInJobErr, pMJob->fullJobName, sizeof(pMProc->lastAlreadyInJobErr) );
                     }
                  }
                  else if ( GetLastError() != ERROR_NOT_ENOUGH_QUOTA )  // this will be reported via Compl Port
                     PCLogUnExError( pid, TEXT("AssignProcToJobObj") );
               }
            }
         }
      }
      // If not managed as a job member for any reason, apply proc management rules...
      if ( !isManaged )
         ApplyProcMgmt( *pMProc, hProc );
   }

   // Clean up any open handles and delete jobs and procs that no longer exist...
   if ( hProc ) CloseHandle( hProc );
   DeleteOrphanProcEntries();
   DeleteOrphanJobEntries();

   LeaveCriticalSection( &m_mgCSMgrLists );

   delete [] doProc;
   delete [] jobDefs; 
   delete [] procDefs;
}

//--------------------------------------------------------------------------------------------//
// function to find a process entry in our list of currently managed processes                //
// Input:    PID and create time of process to find                                           //
// Returns:  pointer to found process entry or NULL if not found                              //
// Note:     A process muct match PID and create time to be a match.                          //
//           If just the PID matches, the PID has been reused and the old proc is gone.       //
//--------------------------------------------------------------------------------------------//
CProcConMgr::ManagedProc *CProcConMgr::FindProcEntry( PID_VALUE pid, __int64 &createTime ) {
   for ( ManagedProc *p = m_procAnchor; 
         p && p->pStats.pid != pid; 
         p = p->next ) ;
   if ( p && memcmp( &p->pStats.createTime, &createTime, sizeof(createTime) ) ) p = NULL;
   return p;
}

//--------------------------------------------------------------------------------------------//
// function to find a job entry in our list of currently managed jobs                         //
// Input:    job name of job to find                                                          //
// Returns:  pointer to found job entry or NULL if not found                                  //
//--------------------------------------------------------------------------------------------//
CProcConMgr::ManagedJob *CProcConMgr::FindJobEntry( TCHAR *job, ManagedJob **plast ) {
   for ( ManagedJob *p = m_jobAnchor, *lst = m_jobAnchor; 
         p && CompareJobName( p->jName, job ); 
         lst = p, p = p->next ) ;
   if ( plast ) *plast = lst;
   return p;
}

//--------------------------------------------------------------------------------------------//
// function to update a process entry in our list of currently managed processes              //
// Input:    pointer to list entry being updated, pointer to definition data, new flag        //
// Returns:  nothing -- cannot fail                                                           //
//--------------------------------------------------------------------------------------------//
void CProcConMgr::UpdateProcEntry( ManagedProc &proc, PCProcDef &item, BOOL newProc ) {
   if ( newProc ) {
      proc.next    = m_procAnchor;
      m_procAnchor = &proc;
      ++m_procManagedCount;
   }
   if ( memcmp( &proc.procParms, &item, sizeof(proc.procParms) ) ) {
      memcpy( &proc.procParms, &item, sizeof(proc.procParms) );
      proc.passSkipFlags = 0;
   }
   proc.sequence = m_sequencer;
}

//--------------------------------------------------------------------------------------------//
// function to update a job entry in our list of currently managed jobs                       //
// Input:    pointer to list entry being updated, pointer to definition data, new flag        //
// Returns:  nothing -- cannot fail                                                           //
//--------------------------------------------------------------------------------------------//
void CProcConMgr::UpdateJobEntry( ManagedJob &job, PCJobDef *item, BOOL newJob ) {
   if ( newJob ) {
      job.next    = m_jobAnchor;
      m_jobAnchor = &job;
      ++m_jobManagedCount;
   }
   if ( item && memcmp( &job.jobParms, item, sizeof(job.jobParms) ) ) {
      memcpy( &job.jobParms, item, sizeof(job.jobParms) );
      job.dataErrorFlags = job.timeExceededReported = 0;
   }
   job.sequence = m_sequencer;
}

//--------------------------------------------------------------------------------------------//
// function to allocate and build a job object process list and hang it on the ManagedJob     //
// Input:    ptr to managed job                                                               //
// Returns:  TRUE if successful, FALSE if not (error issued)                                  //
//--------------------------------------------------------------------------------------------//
BOOL CProcConMgr::GetProcListForJob( ManagedJob &job ) {

   DWORD  actual, size, entryCount = 16;

   for ( ;; ) {
      delete [] ((UCHAR *) job.JOProcListInfo);
      size = sizeof(JOBOBJECT_BASIC_PROCESS_ID_LIST) + (entryCount - 1) * sizeof(job.JOProcListInfo->ProcessIdList[0]);
      job.JOProcListInfo = (JOBOBJECT_BASIC_PROCESS_ID_LIST *) new UCHAR[size];
      if ( !job.JOProcListInfo ) {
         PCLogNoMemory( TEXT("AllocJobProcList"), size );
         job.lastError = ERROR_NOT_ENOUGH_MEMORY;
         return FALSE;
      }
      if ( !QueryInformationJobObject( job.jobHandle, JobObjectBasicProcessIdList, 
                                       job.JOProcListInfo, size, &actual ) 
           && GetLastError() != ERROR_MORE_DATA ) {
         job.lastError = GetLastError();
         PCLogUnExError( job.fullJobName, TEXT("GetJobObjProcListInfo") );
         memset( job.JOProcListInfo, 0, sizeof(*job.JOProcListInfo) );
         return FALSE;
      }
      if ( job.JOProcListInfo->NumberOfAssignedProcesses > job.JOProcListInfo->NumberOfProcessIdsInList )
         entryCount = job.JOProcListInfo->NumberOfAssignedProcesses + 2;
      else break;
   } 

   return TRUE;
}

//--------------------------------------------------------------------------------------------//
// function to populate a managed job structure with job object information                   //
// Input:    ptr to managed job                                                               //
// Returns:  nothing                                                                          //
//--------------------------------------------------------------------------------------------//
void CProcConMgr::UpdateJobObjInfo( ManagedJob &job ) {
   PCULONG32 actual;
   if ( !QueryInformationJobObject( job.jobHandle, JobObjectExtendedLimitInformation, 
                                    &job.JOExtendedLimitInfo, sizeof(job.JOExtendedLimitInfo), &actual ) ) {
      job.lastError = GetLastError();
      PCLogUnExError( job.fullJobName, TEXT("GetJobObjExtLimitInfo") );
      memset( &job.JOExtendedLimitInfo, 0, sizeof(job.JOExtendedLimitInfo) );
   }
   else if ( !QueryInformationJobObject( job.jobHandle, JobObjectBasicAndIoAccountingInformation, 
                                    &job.JOBasicAndIoAcctInfo, sizeof(job.JOBasicAndIoAcctInfo), &actual ) ) {
      job.lastError = GetLastError();
      PCLogUnExError( job.fullJobName, TEXT("GetBasicAndIoAcctInfo") );
      memset( &job.JOBasicAndIoAcctInfo, 0, sizeof(job.JOBasicAndIoAcctInfo) );
   }
   else if ( GetProcListForJob( job ) ) {
      for ( PCULONG32 i = 0; i < job.JOProcListInfo->NumberOfProcessIdsInList; ++i ) {
         for ( PCULONG32 p = 0; p < m_rawProcCount; ++p ) {
            if ( m_rawProcList[p].pId == job.JOProcListInfo->ProcessIdList[i] ) {
               m_rawProcList[p].pMJob = &job;
               break;
            }
         }
      }
      delete [] ((UCHAR *) job.JOProcListInfo);
      job.JOProcListInfo = NULL;
   }

}

//--------------------------------------------------------------------------------------------//
// function to delete process entries orphaned in our list of currently managed processes     //
// Input:    none                                                                             //
// Returns:  nothing                                                                          //
// Note:     Caller must hold the CS that protects the list hanging off m_procAnchor          //
//--------------------------------------------------------------------------------------------//
void CProcConMgr::DeleteOrphanProcEntries( void ) {
   for ( BOOL done = FALSE; !done; ) {
      done = TRUE;
      for ( ManagedProc *p = m_procAnchor, *plast = NULL; p; plast = p, p = p->next ) {
         if ( p->sequence != m_sequencer ) {
            if ( p == m_procAnchor ) m_procAnchor = p->next;
            else plast->next = p->next;
            delete p;
            --m_procManagedCount;
            done = FALSE;
            break;
         }
      }
   }
}

//--------------------------------------------------------------------------------------------//
// function to delete job entries that have gone empty when 'close on empty' is set           //
// Input:    none                                                                             //
// Returns:  nothing                                                                          //
// Note:     Caller must hold the CS that protects the list hanging off m_jobAnchor           //
//--------------------------------------------------------------------------------------------//
void CProcConMgr::DeleteOrphanJobEntries( void ) {
   for ( BOOL done = FALSE; !done; ) {
      done = TRUE;
      for ( ManagedJob *p = m_jobAnchor; p; p = p->next ) {
         if ( p->sequence != m_sequencer ) {                   // job was not visited during last proc scan
            PCJobDef *jobDef;
            if ( m_cDB.GetJobMgmtDefs( &jobDef, &p->jName ) ) {// Returns 0 if job definition not found
               UpdateJobEntry( *p, jobDef );
               delete [] jobDef;
            }
            if ( p->jobParms.mFlags & PCMFLAG_END_JOB_WHEN_EMPTY ) {
               JobIsEmpty( p );                                // job should be deleted after this call!
               done = FALSE;
               break;
            }
         }
      }
   }
}

//--------------------------------------------------------------------------------------------//
// function to apply requested management behavior to the job in question                     //
// Input:    reference to managed job definition                                              //
// Returns:  TRUE if requested behavior was assigned to the job, else FALSE                   //
// Note:     Assigning a process to a job cannot be undone.  Thus, when this function returns //
//           TRUE the process is always associated with the job until the process ends.       //
//--------------------------------------------------------------------------------------------//
BOOL CProcConMgr::ApplyJobMgmt( ManagedJob &job ) {

   BOOL applied = FALSE, change = FALSE, wantON, isON;

   // Establish flags to show what changes were made this pass...
   int doAff = 0, doPri = 0, doSch = 0, doWS = 0, doProcTime = 0, doJobTime = 0, doProcCount = 0,
       doProcMemory = 0, doJobMemory = 0, brkAwayOKAct = 0, silentBrkAwayAct = 0, dieUHExcept = 0;

   // Next prepare any updates needed to get where we want...
   // for all PC management flags, 
   //   o if management is requested and is either not in place or a different limit is requested: 
   //        turn on job object management flag and set limit value (if applicable)
   //   o if management is not requested but is currently in place: 
   //        turn off job object management flag (leave limit alone)

   // Process Breakaway flag (if requested by CreateProcess, process is outside job if flag is set)
   //                        (if flag is not set, CreateProcess will fail)...
   brkAwayOKAct = PCTestSetUnset( job.jobParms.mFlags, PCMFLAG_SET_PROC_BREAKAWAY_OK,
                                  job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags, 
                                  JOB_OBJECT_LIMIT_BREAKAWAY_OK );
   if ( brkAwayOKAct ) change = TRUE;
   if ( brkAwayOKAct > 0 )
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_BREAKAWAY_OK;
   else if ( brkAwayOKAct < 0 )
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags &= ~JOB_OBJECT_LIMIT_BREAKAWAY_OK;

   // Process Silent Breakaway flag (flag on means processes created in job are always outside job)...
   silentBrkAwayAct = PCTestSetUnset( job.jobParms.mFlags, PCMFLAG_SET_SILENT_BREAKAWAY,
                                      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags, 
                                      JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK );
   if ( silentBrkAwayAct ) change = TRUE;
   if ( silentBrkAwayAct > 0 )
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK;
   else if ( silentBrkAwayAct < 0 )
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags &= ~JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK;

   // Process die on UH Execption flag (flag on means suppress GPF message box)...
   dieUHExcept = PCTestSetUnset( job.jobParms.mFlags, PCMFLAG_SET_DIE_ON_UH_EXCEPTION,
                                 job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags, 
                                 JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION );
   if ( dieUHExcept ) change = TRUE;
   if ( dieUHExcept > 0 )
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION;
   else if ( dieUHExcept < 0 )
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags &= ~JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION;

   // Process process memory limit flag...
   PCUINT32 pageSize = m_cPC.GetPageSize();
   MEMORY_VALUE oldProcMemory = job.JOExtendedLimitInfo.ProcessMemoryLimit, 
                newProcMemory = ((job.jobParms.procMemoryLimit + pageSize - 1) / pageSize) * pageSize;

   // Ensure that process memory limit is not larger than API can handle...
   if ( sizeof(SIZE_T) == 4 && newProcMemory > ((MAXDWORD / pageSize) * pageSize) ) newProcMemory = ((MAXDWORD / pageSize) * pageSize);
   
   wantON = job.jobParms.mFlags & PCMFLAG_APPLY_PROC_MEMORY_LIMIT;
   isON   = job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_PROCESS_MEMORY;
   if ( wantON && (!isON || newProcMemory != oldProcMemory) ) {
      if ( !newProcMemory ) {
         if ( !(job.dataErrorFlags & PCMFLAG_APPLY_PROC_MEMORY_LIMIT) ) {
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName };
            PCLogMessage( PC_SERVICE_APPLY_PROC_MEMORY_REJECT, EVENTLOG_ERROR_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         }
         job.dataErrorFlags |= PCMFLAG_APPLY_PROC_MEMORY_LIMIT;
      }
      else {
         job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_MEMORY;
         job.JOExtendedLimitInfo.ProcessMemoryLimit                = (SIZE_T) newProcMemory;
         doProcMemory = 1;
         change       = TRUE;
      }
   }
   else if ( !wantON && isON ) {
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags &= ~JOB_OBJECT_LIMIT_PROCESS_MEMORY;
      doProcMemory = -1;
      change       = TRUE;
   }

   // Process job memory limit flag...
   MEMORY_VALUE oldJobMemory = job.JOExtendedLimitInfo.JobMemoryLimit, 
                newJobMemory = ((job.jobParms.jobMemoryLimit + pageSize - 1) / pageSize) * pageSize;

   // Ensure that requested job memory limit is not larger than API can handle...
   if ( sizeof(SIZE_T) == 4 && newJobMemory > ((MAXDWORD / pageSize) * pageSize) ) newJobMemory = ((MAXDWORD / pageSize) * pageSize); 

   wantON = job.jobParms.mFlags & PCMFLAG_APPLY_JOB_MEMORY_LIMIT;
   isON   = job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_JOB_MEMORY;
   if ( wantON && (!isON || newJobMemory != oldJobMemory) ) {
      if ( !newJobMemory ) {
         if ( !(job.dataErrorFlags & PCMFLAG_APPLY_JOB_MEMORY_LIMIT) ) {
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName };
            PCLogMessage( PC_SERVICE_APPLY_JOB_MEMORY_REJECT, EVENTLOG_ERROR_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         }
         job.dataErrorFlags |= PCMFLAG_APPLY_JOB_MEMORY_LIMIT;
      }
      else {
         job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_JOB_MEMORY;
         job.JOExtendedLimitInfo.JobMemoryLimit                    = (SIZE_T) newJobMemory;
         doJobMemory = 1;
         change      = TRUE;
      }
   }
   else if ( !wantON && isON ) {
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags &= ~JOB_OBJECT_LIMIT_JOB_MEMORY;
      doJobMemory = -1;
      change      = TRUE;
   }

   // Process affinity flag...
   AFFINITY oldAff = job.JOExtendedLimitInfo.BasicLimitInformation.Affinity, 
            newAff = job.jobParms.affinity & m_systemMask;
   wantON = job.jobParms.mFlags & PCMFLAG_APPLY_AFFINITY;
   isON   = job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_AFFINITY;
   if ( wantON && (!isON || newAff != oldAff) ) {
      if ( !newAff ) {
         if ( !(job.dataErrorFlags & PCMFLAG_APPLY_AFFINITY) ) {
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName };
            PCLogMessage( PC_SERVICE_APPLY_JOB_AFFINITY_REJECT, EVENTLOG_ERROR_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         }
         job.dataErrorFlags |= PCMFLAG_APPLY_AFFINITY;
      }
      else {
         job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_AFFINITY;
         job.JOExtendedLimitInfo.BasicLimitInformation.Affinity    = (ULONG_PTR) newAff;
         doAff  = 1;
         change = TRUE;
      }
   }
   else if ( !wantON && isON ) {
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags &= ~JOB_OBJECT_LIMIT_AFFINITY;
      doAff  = -1;
      change = TRUE;
   }

   // Process priority flag...
   PRIORITY oldPri = job.JOExtendedLimitInfo.BasicLimitInformation.PriorityClass, 
            newPri = PCMapPriorityToNT( job.jobParms.priority );
   wantON = job.jobParms.mFlags & PCMFLAG_APPLY_PRIORITY;
   isON   = job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_PRIORITY_CLASS;
   if ( wantON && (!isON || newPri != oldPri) ) {
      if ( !newPri ) {
         if ( !(job.dataErrorFlags & PCMFLAG_APPLY_PRIORITY) ) {
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName };
            PCLogMessage( PC_SERVICE_APPLY_JOB_PRIORITY_REJECT, EVENTLOG_ERROR_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         }
         job.dataErrorFlags |= PCMFLAG_APPLY_PRIORITY;
      }
      else {
         job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags    |= JOB_OBJECT_LIMIT_PRIORITY_CLASS;
         job.JOExtendedLimitInfo.BasicLimitInformation.PriorityClass  = newPri;
         doPri  = 1;
         change = TRUE;
      }
   }
   else if ( !wantON && isON ) {
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags &= ~JOB_OBJECT_LIMIT_PRIORITY_CLASS;
      doPri  = -1;
      change = TRUE;
   }

   // Process scheduling class flag...
   SCHEDULING_CLASS oldSch = job.JOExtendedLimitInfo.BasicLimitInformation.SchedulingClass, 
                    newSch = job.jobParms.schedClass;
   wantON = job.jobParms.mFlags & PCMFLAG_APPLY_SCHEDULING_CLASS;
   isON   = job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_SCHEDULING_CLASS;
   if ( wantON && (!isON || newSch != oldSch) ) {
      if ( newSch > 9 ) {
         if ( !(job.dataErrorFlags & PCMFLAG_APPLY_SCHEDULING_CLASS) ) {
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName };
            PCLogMessage( PC_SERVICE_APPLY_JOB_SCHEDULING_CLASS_REJECT, EVENTLOG_ERROR_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         }
         job.dataErrorFlags |= PCMFLAG_APPLY_SCHEDULING_CLASS;
      }
      else {
         job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags      |= JOB_OBJECT_LIMIT_SCHEDULING_CLASS;
         job.JOExtendedLimitInfo.BasicLimitInformation.SchedulingClass  = newSch;
         doSch  = 1;
         change = TRUE;
      }
   }
   else if ( !wantON && isON ) {
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags &= ~JOB_OBJECT_LIMIT_SCHEDULING_CLASS;
      doSch  = -1;
      change = TRUE;
   }

   // Process working set flag...
   MEMORY_VALUE oldMinWS = job.JOExtendedLimitInfo.BasicLimitInformation.MinimumWorkingSetSize,
                oldMaxWS = job.JOExtendedLimitInfo.BasicLimitInformation.MaximumWorkingSetSize;
   MEMORY_VALUE newMinWS = (job.jobParms.minWS + pageSize - 1) / pageSize * pageSize,
                newMaxWS = (job.jobParms.maxWS + pageSize - 1) / pageSize * pageSize;

   // Ensure that requested working set limits are not larger than API can handle...
   if ( sizeof(SIZE_T) == 4 && newMaxWS > ((MAXDWORD / pageSize) * pageSize) ) {  // exceeds largest 32 bit value that is page size multiple
      newMaxWS = ((MAXDWORD / pageSize) * pageSize); 
      if ( newMinWS >= newMaxWS )        
         newMinWS = newMaxWS - 4 * pageSize;  
   }

   wantON = job.jobParms.mFlags & PCMFLAG_APPLY_WS_MINMAX;
   isON   = job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_WORKINGSET;
   if ( wantON && (!isON || oldMinWS != newMinWS || oldMaxWS != newMaxWS) ) {
      if ( !newMinWS || newMaxWS <= newMinWS ) {
         if ( !(job.dataErrorFlags & PCMFLAG_APPLY_WS_MINMAX) ) {
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName };
            PCLogMessage( PC_SERVICE_APPLY_JOB_WORKING_SET_REJECT, EVENTLOG_ERROR_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         }
         job.dataErrorFlags |= PCMFLAG_APPLY_WS_MINMAX;
      }
      else {
         job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags            |= JOB_OBJECT_LIMIT_WORKINGSET;
         job.JOExtendedLimitInfo.BasicLimitInformation.MinimumWorkingSetSize  = (SIZE_T) newMinWS;
         job.JOExtendedLimitInfo.BasicLimitInformation.MaximumWorkingSetSize  = (SIZE_T) newMaxWS;
         doWS   = 1;
         change = TRUE;
      }
   }
   else if ( !wantON && isON ) {
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags &= ~JOB_OBJECT_LIMIT_WORKINGSET;
      doWS   = -1;
      change = TRUE;
   }

   // Process process count limit flag...
   PCULONG32 oldProcCount = job.JOExtendedLimitInfo.BasicLimitInformation.ActiveProcessLimit, 
             newProcCount = job.jobParms.procCountLimit;
   wantON = job.jobParms.mFlags & PCMFLAG_APPLY_PROC_COUNT_LIMIT;
   isON   = job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
   if ( wantON && (!isON || newProcCount != oldProcCount) ) {
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags         |= JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
      job.JOExtendedLimitInfo.BasicLimitInformation.ActiveProcessLimit  = newProcCount;
      doProcCount = 1;
      change      = TRUE;
   }
   else if ( !wantON && isON ) {
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags &= ~JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
      doProcCount = -1;
      change      = TRUE;
   }

   // Process process time limit flag...
   TIME_VALUE oldProcTime = PCLargeIntToInt64( job.JOExtendedLimitInfo.BasicLimitInformation.PerProcessUserTimeLimit ), 
              newProcTime = job.jobParms.procTimeLimitCNS;
   wantON = job.jobParms.mFlags & PCMFLAG_APPLY_PROC_TIME_LIMIT;
   isON   = job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_PROCESS_TIME;
   if ( wantON && (!isON || newProcTime != oldProcTime) ) {
      if ( newProcTime < PC_MIN_TIME_LIMIT ) {
         if ( !(job.dataErrorFlags & PCMFLAG_APPLY_PROC_TIME_LIMIT) ) {
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName };
            PCLogMessage( PC_SERVICE_APPLY_PROC_TIME_REJECT, EVENTLOG_ERROR_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         }
         job.dataErrorFlags |= PCMFLAG_APPLY_PROC_TIME_LIMIT;
      }
      else {
         job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_TIME;
         job.JOExtendedLimitInfo.BasicLimitInformation.PerProcessUserTimeLimit.QuadPart  = newProcTime;
         doProcTime  = 1;
         change      = TRUE;
      }
   }
   else if ( !wantON && isON ) {
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags &= ~JOB_OBJECT_LIMIT_PROCESS_TIME;
      doProcTime  = -1;
      change      = TRUE;
   }

   // Process job time limit flag...
   TIME_VALUE oldJobTime = job.curJobTimeLimitCNS, 
              newJobTime = job.jobParms.jobTimeLimitCNS;
   wantON = job.jobParms.mFlags & PCMFLAG_APPLY_JOB_TIME_LIMIT;
   isON   = job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_JOB_TIME;
   if ( wantON && ( (!isON && !job.timeExceededReported) || newJobTime != oldJobTime ) ) {
      if ( newJobTime < PC_MIN_TIME_LIMIT ) {
         if ( !(job.dataErrorFlags & PCMFLAG_APPLY_JOB_TIME_LIMIT) ) {
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName };
            PCLogMessage( PC_SERVICE_APPLY_JOB_TIME_REJECT, EVENTLOG_ERROR_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         }
         job.dataErrorFlags |= PCMFLAG_APPLY_JOB_TIME_LIMIT;
      }
      else {
         job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_JOB_TIME;
         job.JOExtendedLimitInfo.BasicLimitInformation.PerJobUserTimeLimit.QuadPart  = newJobTime;
         doJobTime  = 1;
         change      = TRUE;
         job.curJobTimeLimitCNS = newJobTime;
      }
   }
   else if ( !wantON && isON ) {
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags &= ~JOB_OBJECT_LIMIT_JOB_TIME;
      doJobTime  = -1;
      change      = TRUE;
      job.curJobTimeLimitCNS = 0;
   }

   // If we are about to change things other than job timing, set preserve job time...
   if ( change && !doJobTime )
      job.JOExtendedLimitInfo.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME;

   // Now apply the updates needed and report if unsuccessful...
   if ( change && !SetInformationJobObject( job.jobHandle, JobObjectExtendedLimitInformation, 
                                            &job.JOExtendedLimitInfo, sizeof(job.JOExtendedLimitInfo) ) ) 
      PCLogUnExError( job.fullJobName, TEXT("SetJobObjLimitInfo") );

   // The job object has been updated.  Now do any completion port processing needed and report on changes.
   else {

      // First determine if we need to associate a completion port...
      if ( !job.hasComplPort && m_assocPort.CompletionPort ) {
         m_assocPort.CompletionKey = (void *) job.compKey;
         if ( !SetInformationJobObject( job.jobHandle, JobObjectAssociateCompletionPortInformation, 
               &m_assocPort, sizeof(m_assocPort) ) && GetLastError() != ERROR_INVALID_PARAMETER )
            PCLogUnExError( job.fullJobName, TEXT("SetJobObjComplPortInfo") );
         else job.hasComplPort = TRUE;
      }

      // Next determine if we need to set end-of-job time time handling...
      if ( job.hasComplPort ) {
         JOBOBJECT_END_OF_JOB_TIME_INFORMATION eojData;
         eojData.EndOfJobTimeAction = job.jobParms.mFlags & PCMFLAG_MSG_ON_JOB_TIME_LIMIT_HIT? 
                                      JOB_OBJECT_POST_AT_END_OF_JOB : JOB_OBJECT_TERMINATE_AT_END_OF_JOB;
         if ( eojData.EndOfJobTimeAction != job.lastEojAction &&
              !SetInformationJobObject( job.jobHandle, JobObjectEndOfJobTimeInformation, 
                                        &eojData, sizeof(eojData) ) )
            PCLogUnExError( job.fullJobName, TEXT("SetJobObjEndOfJobInfo") );
         else job.lastEojAction = eojData.EndOfJobTimeAction;
      }

      // Report on breakaway OK flag change, if any...
      if ( brkAwayOKAct ) {
         const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName };
         if ( brkAwayOKAct > 0 )
            PCLogMessage( PC_SERVICE_SET_BREAKAWAY_ALLOWED, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         else
            PCLogMessage( PC_SERVICE_UNSET_BREAKAWAY_ALLOWED, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
      }

      // Report on silent breakaway flag change, if any...
      if ( silentBrkAwayAct ) {
         const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName };
         if ( silentBrkAwayAct > 0 )
            PCLogMessage( PC_SERVICE_SET_SILENT_BREAKAWAY_ENABLED, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         else
            PCLogMessage( PC_SERVICE_UNSET_SILENT_BREAKAWAY_ENABLED, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
      }

      // Report on unhandled exception flag change, if any...
      if ( dieUHExcept ) {
         const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName };
         if ( dieUHExcept > 0 )
            PCLogMessage( PC_SERVICE_SET_LIMIT_DIE_ON_UNHANDLED_EXCEPTION, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         else
            PCLogMessage( PC_SERVICE_UNSET_LIMIT_DIE_ON_UNHANDLED_EXCEPTION, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
      }

      // Report on process memory limit change, if any...
      if ( doProcMemory ) {
         TCHAR from[32], to[32];
         _i64tot( oldProcMemory, from, 10 );         
         _i64tot( newProcMemory, to,   10 );          
         const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName, from, to };
         if ( doProcMemory > 0 )
            PCLogMessage( PC_SERVICE_CHANGE_JOB_PROCESS_MEMORY, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         else
            PCLogMessage( PC_SERVICE_REMOVE_JOB_PROCESS_MEMORY, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
      }

      // Report on job memory limit change, if any...
      if ( doJobMemory ) {
         TCHAR from[32], to[32];
         _i64tot( oldJobMemory, from, 10 );         
         _i64tot( newJobMemory, to,   10 );          
         const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName, from, to };
         if ( doJobMemory > 0 )
            PCLogMessage( PC_SERVICE_CHANGE_JOB_JOB_MEMORY, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         else
            PCLogMessage( PC_SERVICE_REMOVE_JOB_JOB_MEMORY, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
      }

      // Report on process time limit change, if any...
      if ( doProcTime ) {
         TCHAR from[32], to[32];
         _i64tot( oldProcTime / 10000, from, 10 );         // display in milliseconds
         _i64tot( newProcTime / 10000, to,   10 );         // display in milliseconds 
         const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName, from, to };
         if ( doProcTime > 0 )
            PCLogMessage( PC_SERVICE_CHANGE_JOB_PROCESS_TIME, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         else
            PCLogMessage( PC_SERVICE_REMOVE_JOB_PROCESS_TIME, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
      }

      // Report on job time limit change, if any...
      if ( doJobTime ) {
         TCHAR from[32], to[32];
         _i64tot( oldJobTime / 10000, from, 10 );         // display in milliseconds
         _i64tot( newJobTime / 10000, to,   10 );         // display in milliseconds 
         const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName, from, to };
         if ( doJobTime > 0 )
            PCLogMessage( PC_SERVICE_CHANGE_JOB_JOB_TIME, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         else
            PCLogMessage( PC_SERVICE_REMOVE_JOB_JOB_TIME, EVENTLOG_INFORMATION_TYPE,
                          ENTRY_COUNT(msgs), msgs );
      }

      // Report on process count limit change, if any...
      if ( doProcCount ) {
         TCHAR from[32], to[32];
         _ltot( oldProcCount, from, 10 );
         _ltot( newProcCount, to,   10 );
         const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName, from, to };
         if ( doProcCount > 0 )
            PCLogMessage( PC_SERVICE_CHANGE_JOB_PROCESS_COUNT, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         else 
            PCLogMessage( PC_SERVICE_REMOVE_JOB_PROCESS_COUNT, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
      }

      // Report on priority class limit change, if any...
      if ( doPri ) {
         TCHAR from[32], to[32];
         _ltot( PCMapPriorityToPC( oldPri ), from, 10 );
         _ltot( PCMapPriorityToPC( newPri ), to,   10 );
         const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName, from, to };
         if ( doPri > 0 )
            PCLogMessage( PC_SERVICE_CHANGE_JOB_PRIORITY, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         else
            PCLogMessage( PC_SERVICE_REMOVE_JOB_PRIORITY, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
      }

      // Report on affinity limit change, if any...
      if ( doAff ) {
         TCHAR from[32] = TEXT("0x"), to[32] = TEXT("0x");
         _i64tot( oldAff, &from[2], 16 );
         _i64tot( newAff, &to[2],   16 );
         const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName, from, to };
         if ( doAff > 0 )
            PCLogMessage( PC_SERVICE_CHANGE_JOB_AFFINITY, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         else
            PCLogMessage( PC_SERVICE_REMOVE_JOB_AFFINITY, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
      }

      // Report on scheduling class limit change, if any...
      if ( doSch ) {
         TCHAR from[32], to[32];
         _ltot( oldSch, from, 10 );
         _ltot( newSch, to,   10 );
         const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName, from, to };
         if ( doSch > 0 )
            PCLogMessage( PC_SERVICE_CHANGE_JOB_SCHEDULING_CLASS, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         else 
            PCLogMessage( PC_SERVICE_REMOVE_JOB_SCHEDULING_CLASS, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
      }

      // Report on working set limit change, if any...
      if ( doWS ) {
         TCHAR from[32], to[32], from2[32], to2[32];
         _i64tot( oldMinWS, from,  10 );
         _i64tot( oldMaxWS, from2, 10 );
         _i64tot( newMinWS, to,    10 );
         _i64tot( newMaxWS, to2,   10 );
         const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, job.fullJobName, from, from2, to, to2 };
         if ( doWS > 0 )
            PCLogMessage( PC_SERVICE_CHANGE_JOB_WORKING_SET, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
         else
            PCLogMessage( PC_SERVICE_REMOVE_JOB_WORKING_SET, EVENTLOG_INFORMATION_TYPE, 
                          ENTRY_COUNT(msgs), msgs );
      }

      applied = TRUE;
   }

   return applied;
}

//--------------------------------------------------------------------------------------------//
// function to apply requested management behavior to the process in question                 //
// Input:    managed process definition, process handle                                       //
// Returns:  TRUE if any requested behavior is successfully applied, else FALSE               //
//--------------------------------------------------------------------------------------------//
BOOL CProcConMgr::ApplyProcMgmt( ManagedProc &proc, HANDLE hProc ) {
   BOOL setProc = FALSE;
   ULONG_PTR   oldAff,   newAff;
   PRIORITY    oldPri,   newPri;
   SIZE_T      oldMinWS, oldMaxWS;

   // Handle request to set or unset process affinity...

   // Check to see if affinity is to be applied...
   if ( proc.procParms.mFlags & PCMFLAG_APPLY_AFFINITY  ) {
      // Get current affinity and save as original if not yet saved...
      GetProcessAffinityMask( hProc, &oldAff, &m_systemMask );
      if ( !(proc.originalParms.mFlags & PCMFLAG_APPLY_AFFINITY) ) {
         proc.originalParms.mFlags   |= PCMFLAG_APPLY_AFFINITY;
         proc.originalParms.affinity  = oldAff;
      }
      // Get new affinity and complain if invalid and not reported...
      newAff = (ULONG_PTR) proc.procParms.affinity & m_systemMask;
      if ( !newAff && !(proc.passSkipFlags & PCMFLAG_APPLY_AFFINITY) ) {
         // Flag to skip affinity test on next pass so we don't report error repeatedly...
         proc.passSkipFlags |= PCMFLAG_APPLY_AFFINITY;
         const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, proc.pName };
         PCLogMessage( PC_SERVICE_APPLY_PROC_AFFINITY_REJECT, EVENTLOG_ERROR_TYPE, 
                       ENTRY_COUNT(msgs), msgs );
      }
      // If new affinity differs from old, attempt change and report on success or failure...
      else if ( newAff != oldAff ) {
         PCULONG32 rc = SetProcessAffinityMask( hProc, newAff );
         if ( rc ) {
            proc.passSkipFlags  &= ~PCMFLAG_APPLY_AFFINITY;
            proc.isAppliedFlags |=  PCMFLAG_APPLY_AFFINITY;
            TCHAR from[32] = TEXT("0x"), to[32] = TEXT("0x");
            _i64tot( oldAff, &from[2], 16 );
            _i64tot( newAff, &to[2],   16 );
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, proc.pName, proc.pidAsString, proc.imageName, from, to };
            PCLogMessage( PC_SERVICE_CHANGE_PROC_AFFINITY, EVENTLOG_INFORMATION_TYPE, ENTRY_COUNT(msgs), msgs );
            setProc = TRUE;
         }
         else if ( !(proc.passSkipFlags & PCMFLAG_APPLY_AFFINITY) ) {
            proc.passSkipFlags |= PCMFLAG_APPLY_AFFINITY;
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, proc.pName, proc.pidAsString, proc.imageName };
            PCLogMessage( PC_SERVICE_APPLY_PROC_AFFINITY_ERROR, EVENTLOG_ERROR_TYPE, ENTRY_COUNT(msgs), msgs );
         }
      }
   }
   // Not applying affinity -- check to see if affinity is to be un-applied...
   else if ( !(proc.procParms.mFlags & PCMFLAG_APPLY_AFFINITY) && proc.isAppliedFlags & PCMFLAG_APPLY_AFFINITY ) {
      // Get current affinity to verify we are making a change...
      GetProcessAffinityMask( hProc, &oldAff, &m_systemMask );
      newAff = (ULONG_PTR) proc.originalParms.affinity;
      if ( newAff != oldAff ) {
         PCULONG32 rc = SetProcessAffinityMask( hProc, newAff );
         // We reverted to original value, reset flags and report...
         if ( rc ) {
            proc.isAppliedFlags &= ~PCMFLAG_APPLY_AFFINITY;
            proc.passSkipFlags  &= ~PCMFLAG_APPLY_AFFINITY;
            TCHAR from[32] = TEXT("0x"), to[32] = TEXT("0x");
            _i64tot( oldAff, &from[2], 16 );
            _i64tot( newAff, &to[2],   16 );
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, proc.pName, proc.pidAsString, proc.imageName, from, to };
            PCLogMessage( PC_SERVICE_CHANGE_PROC_AFFINITY, EVENTLOG_INFORMATION_TYPE, ENTRY_COUNT(msgs), msgs );
            setProc = TRUE;
         }
         else if ( !(proc.passSkipFlags & PCMFLAG_APPLY_AFFINITY) ) {
            proc.passSkipFlags |= PCMFLAG_APPLY_AFFINITY;
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, proc.pName, proc.pidAsString, proc.imageName };
            PCLogMessage( PC_SERVICE_APPLY_PROC_AFFINITY_ERROR, EVENTLOG_ERROR_TYPE, ENTRY_COUNT(msgs), msgs );
         }
      }
      else {
         proc.isAppliedFlags &= ~PCMFLAG_APPLY_AFFINITY;
         proc.passSkipFlags  &= ~PCMFLAG_APPLY_AFFINITY;
      }
   }

   // Handle request to set or unset process priority...

   // Check to see if priority is to be applied now...
   if ( proc.procParms.mFlags & PCMFLAG_APPLY_PRIORITY ) {
      // Get current priority and save as original if not yet saved...
      oldPri = GetPriorityClass( hProc );
      if ( !(proc.originalParms.mFlags & PCMFLAG_APPLY_PRIORITY) ) {
         proc.originalParms.mFlags   |= PCMFLAG_APPLY_PRIORITY;
         proc.originalParms.priority  = PCMapPriorityToPC( oldPri );
      }
      // Get new priority and complain if zero...
      newPri = PCMapPriorityToNT( proc.procParms.priority );
      if ( !newPri  && !(proc.passSkipFlags & PCMFLAG_APPLY_PRIORITY) ) {
         proc.passSkipFlags |= PCMFLAG_APPLY_PRIORITY;
         const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, proc.pName };
         PCLogMessage( PC_SERVICE_APPLY_PROC_PRIORITY_REJECT, EVENTLOG_ERROR_TYPE, 
                       ENTRY_COUNT(msgs), msgs );
      }
      // If new priority differs from old, attempt change and report on success or failure...
      else if ( newPri != oldPri ) {
         PCULONG32 rc = SetPriorityClass( hProc, newPri );
         if ( rc ) {
            proc.passSkipFlags  &= ~PCMFLAG_APPLY_PRIORITY;
            proc.isAppliedFlags |=  PCMFLAG_APPLY_PRIORITY;
            TCHAR from[32], to[32];
            _ltot( PCMapPriorityToPC( oldPri ), from, 10 );
            _ltot( PCMapPriorityToPC( newPri ), to,   10 );
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, proc.pName, proc.pidAsString, proc.imageName, from, to };
            PCLogMessage( PC_SERVICE_CHANGE_PROC_PRIORITY, EVENTLOG_INFORMATION_TYPE, ENTRY_COUNT(msgs), msgs );
            setProc = TRUE;
         }
         else if ( !(proc.passSkipFlags & PCMFLAG_APPLY_PRIORITY) ) {
            // Flag to skip priority test on next pass so we don't report error repeatedly...
            proc.passSkipFlags |= PCMFLAG_APPLY_PRIORITY;
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, proc.pName, proc.pidAsString, proc.imageName };
            PCLogMessage( PC_SERVICE_APPLY_PROC_PRIORITY_ERROR, EVENTLOG_ERROR_TYPE, ENTRY_COUNT(msgs), msgs );
         }
      }
   }
   // Not applying priority -- check to see if priority is to be un-applied...
   else if ( !(proc.procParms.mFlags & PCMFLAG_APPLY_PRIORITY) && proc.isAppliedFlags & PCMFLAG_APPLY_PRIORITY ) {
      // Get current priority to verify we are making a change...
      oldPri = GetPriorityClass( hProc );
      newPri = PCMapPriorityToNT( proc.originalParms.priority );
      if ( newPri != oldPri) {
         PCULONG32 rc = SetPriorityClass( hProc, newPri );
         // We reverted to original value, reset all flags and report...
         if ( rc ) {
            proc.isAppliedFlags &= ~PCMFLAG_APPLY_PRIORITY;
            proc.passSkipFlags  &= ~PCMFLAG_APPLY_PRIORITY;
            TCHAR from[32], to[32];
            _ltot( PCMapPriorityToPC( oldPri ), from, 10 );
            _ltot( PCMapPriorityToPC( newPri ), to,   10 );
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, proc.pName, proc.pidAsString, proc.imageName, from, to };
            PCLogMessage( PC_SERVICE_CHANGE_PROC_PRIORITY, EVENTLOG_INFORMATION_TYPE, ENTRY_COUNT(msgs), msgs );
            setProc = TRUE;
         }
         else if ( !(proc.passSkipFlags & PCMFLAG_APPLY_PRIORITY) ) {
            proc.passSkipFlags |= PCMFLAG_APPLY_PRIORITY;
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, proc.pName, proc.pidAsString, proc.imageName };
            PCLogMessage( PC_SERVICE_APPLY_PROC_PRIORITY_ERROR, EVENTLOG_ERROR_TYPE, ENTRY_COUNT(msgs), msgs );
         }
      }
      else {
         proc.isAppliedFlags &= ~PCMFLAG_APPLY_PRIORITY;
         proc.passSkipFlags  &= ~PCMFLAG_APPLY_PRIORITY;
      }
   }

   // Handle request to set or unset process working set...

   // Check to see if working set is to be applied now...
   if ( proc.procParms.mFlags & PCMFLAG_APPLY_WS_MINMAX ) {

      // Ensure that requested working set limits are not larger than API can handle...
      PCUINT32 pageSize = m_cPC.GetPageSize();
      if ( sizeof(SIZE_T) == 4 && proc.procParms.maxWS > ((MAXDWORD / pageSize) * pageSize) ) {  // exceeds largest 32 bit value that is page size multiple
         proc.procParms.maxWS = ((MAXDWORD / pageSize) * pageSize); 
         if ( proc.procParms.minWS >= proc.procParms.maxWS )        
            proc.procParms.minWS = proc.procParms.maxWS - 4 * pageSize;  
      }

      // Get current working set and save as original if not yet saved...
      GetProcessWorkingSetSize( hProc, &oldMinWS, &oldMaxWS );
      if ( !(proc.originalParms.mFlags & PCMFLAG_APPLY_WS_MINMAX) ) {
         proc.originalParms.mFlags |= PCMFLAG_APPLY_WS_MINMAX;
         proc.originalParms.minWS   = oldMinWS;
         proc.originalParms.maxWS   = oldMaxWS;
      }
      // Verify new working set and complain if bad...
      if ( (!proc.procParms.minWS || proc.procParms.minWS >= proc.procParms.maxWS) && 
           !(proc.passSkipFlags & PCMFLAG_APPLY_WS_MINMAX) ) {
         proc.passSkipFlags |= PCMFLAG_APPLY_WS_MINMAX;
         const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, proc.pName };
         PCLogMessage( PC_SERVICE_APPLY_PROC_WORKING_SET_REJECT, EVENTLOG_ERROR_TYPE, 
                       ENTRY_COUNT(msgs), msgs );
      }
      // If new working set differs from old, attempt change and report on success or failure...
      else if ( proc.procParms.minWS != oldMinWS || proc.procParms.maxWS != oldMaxWS ) {
         PCULONG32 rc = SetProcessWorkingSetSize( hProc, (SIZE_T) proc.procParms.minWS, 
                                                         (SIZE_T) proc.procParms.maxWS );
         if ( rc ) {
            proc.passSkipFlags  &= ~PCMFLAG_APPLY_WS_MINMAX;
            proc.isAppliedFlags |=  PCMFLAG_APPLY_WS_MINMAX;
            TCHAR from[32], to[32], from2[32], to2[32];
            _i64tot( (__int64) oldMinWS,   from,  10 );
            _i64tot( (__int64) oldMaxWS,   from2, 10 );
            _i64tot( proc.procParms.minWS, to,    10 );
            _i64tot( proc.procParms.maxWS, to2,   10 );
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, proc.pName, proc.pidAsString, proc.imageName, 
                                    from, from2, to, to2 };
            PCLogMessage( PC_SERVICE_CHANGE_PROC_WORKING_SET, EVENTLOG_INFORMATION_TYPE, ENTRY_COUNT(msgs), msgs );
            setProc = TRUE;
         }
         else if ( !(proc.passSkipFlags & PCMFLAG_APPLY_WS_MINMAX) ) {
            proc.passSkipFlags |= PCMFLAG_APPLY_WS_MINMAX;
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, proc.pName, proc.pidAsString, proc.imageName };
            PCLogMessage( PC_SERVICE_APPLY_PROC_WORKINGSET_ERROR, EVENTLOG_ERROR_TYPE, ENTRY_COUNT(msgs), msgs );
         }
      }
   }
   // Not applying working set -- check to see if working set is to be un-applied...
   else if ( !(proc.procParms.mFlags & PCMFLAG_APPLY_WS_MINMAX) && proc.isAppliedFlags & PCMFLAG_APPLY_WS_MINMAX ) {
      // Get current working set to verify we are making a change...
      GetProcessWorkingSetSize( hProc, &oldMinWS, &oldMaxWS );
      if ( proc.originalParms.minWS != oldMinWS || proc.originalParms.maxWS != oldMaxWS ) {
         PCULONG32 rc = SetProcessWorkingSetSize( hProc, (SIZE_T) proc.originalParms.minWS, 
                                                         (SIZE_T) proc.originalParms.maxWS );
         // We reverted to original values, reset all flags and report...
         if ( rc ) {
            proc.passSkipFlags  &= ~PCMFLAG_APPLY_WS_MINMAX;
            proc.isAppliedFlags &= ~PCMFLAG_APPLY_WS_MINMAX;
            TCHAR from[32], to[32], from2[32], to2[32];
            _i64tot( (__int64) oldMinWS,   from,  10 );
            _i64tot( (__int64) oldMaxWS,   from2, 10 );
            _i64tot( proc.originalParms.minWS, to,    10 );
            _i64tot( proc.originalParms.maxWS, to2,   10 );
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, proc.pName, proc.pidAsString, proc.imageName, 
                                    from, from2, to, to2 };
            PCLogMessage( PC_SERVICE_CHANGE_PROC_WORKING_SET, EVENTLOG_INFORMATION_TYPE, ENTRY_COUNT(msgs), msgs );
            setProc = TRUE;
         }
         else if ( !(proc.passSkipFlags & PCMFLAG_APPLY_WS_MINMAX) ) {
            proc.passSkipFlags |= PCMFLAG_APPLY_WS_MINMAX;
            const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, proc.pName, proc.pidAsString, proc.imageName };
            PCLogMessage( PC_SERVICE_APPLY_PROC_WORKINGSET_ERROR, EVENTLOG_ERROR_TYPE, ENTRY_COUNT(msgs), msgs );
         }
      }
      else {
         proc.isAppliedFlags &= ~PCMFLAG_APPLY_WS_MINMAX;
         proc.passSkipFlags  &= ~PCMFLAG_APPLY_WS_MINMAX;
      }
   }

   return setProc;
}

//--------------------------------------------------------------------------------------------//
// function to build copy of active process list for exporting (to API)                       //
// Input:    location to store allocated buffer (call frees it)                               //
// Returns:  number of entries in the list                                                    //
//--------------------------------------------------------------------------------------------//
PCULONG32 CProcConMgr::ExportActiveProcList( PCProcListItem **list ) {

   Discover();                                      // Go build or refresh process and job lists

   EnterCriticalSection( &m_mgCSMgrLists );

   PCULONG32 count = m_rawProcCount;
   *list = NULL;

   if ( m_rawProcList ) {
      *list = new PCProcListItem[m_rawProcCount];
      if ( !*list ) {
         PCLogNoMemory( TEXT("AllocExportProcList"), sizeof(PCProcListItem) * m_rawProcCount );
         LeaveCriticalSection( &m_mgCSMgrLists );
         return 0;
      }
      else memset( *list, 0, sizeof(PCProcListItem) * m_rawProcCount );
   }

   for ( PCULONG32 i = 0; i < count; ++i ) {
      PCProcListItem &target = (*list)[i];
      memcpy( target.procName,  m_rawProcList[i].pName,     sizeof(target.procName) );
      memcpy( target.imageName, m_rawProcList[i].imageName, sizeof(target.imageName) );
      target.procStats.pid             = m_rawProcList[i].pId;
      target.procStats.createTime      = PCFileTimeToInt64( m_rawProcList[i].createTime );
      target.procStats.TotalUserTime   = PCFileTimeToInt64( m_rawProcList[i].userTime );
      target.procStats.TotalKernelTime = PCFileTimeToInt64( m_rawProcList[i].kernelTime );
      target.actualPriority            = m_rawProcList[i].actualPriority;
      target.actualAffinity            = m_rawProcList[i].actualAffinity;
      target.lFlags = PCLFLAG_IS_RUNNING;
      if ( m_rawProcList[i].pMJob ) {
         target.lFlags |= PCLFLAG_IS_IN_A_JOB;
         memcpy(target.jobName, m_rawProcList[i].pMJob->jName, sizeof( target.jobName ) );
      }
   }

   LeaveCriticalSection( &m_mgCSMgrLists );

   return count;
}

//--------------------------------------------------------------------------------------------//
// function to build copy of active job list for exporting (to API)                           //
// Input:    location to store allocated buffer (call frees it)                               //
// Returns:  number of entries in the list                                                    //
//--------------------------------------------------------------------------------------------//
PCULONG32 CProcConMgr::ExportActiveJobList( PCJobListItem **list ) {

   Discover();                                      // Go build or refresh process and job lists

   EnterCriticalSection( &m_mgCSMgrLists );

   PCULONG32 count = m_jobManagedCount;

   // Allocate buffer for job list (caller will free)...
   *list = new PCJobListItem[count];
   if ( !*list ) {
      PCLogNoMemory( TEXT("AllocJobList"), sizeof(PCJobListItem) * count );
      LeaveCriticalSection( &m_mgCSMgrLists );
      return 0;
   }
   memset( *list, 0, sizeof(PCJobListItem) * count );

   // Copy job names to list and set flag(s)...
   PCULONG32 i = 0;
   for ( ManagedJob *curJob = m_jobAnchor; curJob; curJob = curJob->next, ++i ) {
      PCJobListItem &target = (*list)[i];
      memcpy( target.jobName, curJob->jName, sizeof(curJob->jName) );

      target.jobStats.TotalUserTime             = 
         PCLargeIntToInt64( curJob->JOBasicAndIoAcctInfo.BasicInfo.TotalUserTime );
      target.jobStats.TotalKernelTime           = 
         PCLargeIntToInt64( curJob->JOBasicAndIoAcctInfo.BasicInfo.TotalKernelTime );
      target.jobStats.ThisPeriodTotalUserTime   = 
         PCLargeIntToInt64( curJob->JOBasicAndIoAcctInfo.BasicInfo.ThisPeriodTotalUserTime );
      target.jobStats.ThisPeriodTotalKernelTime = 
         PCLargeIntToInt64( curJob->JOBasicAndIoAcctInfo.BasicInfo.ThisPeriodTotalKernelTime );
      target.jobStats.TotalPageFaultCount       = curJob->JOBasicAndIoAcctInfo.BasicInfo.TotalPageFaultCount;
      target.jobStats.TotalProcesses            = curJob->JOBasicAndIoAcctInfo.BasicInfo.TotalProcesses;
      target.jobStats.ActiveProcesses           = curJob->JOBasicAndIoAcctInfo.BasicInfo.ActiveProcesses;
      target.jobStats.TotalTerminatedProcesses  = curJob->JOBasicAndIoAcctInfo.BasicInfo.TotalTerminatedProcesses;
      target.jobStats.ReadOperationCount        = curJob->JOBasicAndIoAcctInfo.IoInfo.ReadOperationCount;
      target.jobStats.WriteOperationCount       = curJob->JOBasicAndIoAcctInfo.IoInfo.WriteOperationCount;
      target.jobStats.OtherOperationCount       = curJob->JOBasicAndIoAcctInfo.IoInfo.OtherOperationCount;
      target.jobStats.ReadTransferCount         = curJob->JOBasicAndIoAcctInfo.IoInfo.ReadTransferCount;
      target.jobStats.WriteTransferCount        = curJob->JOBasicAndIoAcctInfo.IoInfo.WriteTransferCount;
      target.jobStats.OtherTransferCount        = curJob->JOBasicAndIoAcctInfo.IoInfo.OtherTransferCount;
      target.jobStats.PeakProcessMemoryUsed     = curJob->JOExtendedLimitInfo.PeakProcessMemoryUsed;
      target.jobStats.PeakJobMemoryUsed         = curJob->JOExtendedLimitInfo.PeakJobMemoryUsed;

      target.actualPriority                     = 
         PCMapPriorityToPC( curJob->JOExtendedLimitInfo.BasicLimitInformation.PriorityClass );
      target.actualAffinity                     = curJob->JOExtendedLimitInfo.BasicLimitInformation.Affinity;
      target.actualSchedClass                   = curJob->JOExtendedLimitInfo.BasicLimitInformation.SchedulingClass;
      target.lFlags                             = PCLFLAG_IS_RUNNING;
   }

   // Sort the list by name...
   qsort( *list, count, sizeof(PCJobListItem), CompareJobName );

   LeaveCriticalSection( &m_mgCSMgrLists );

   return count;
}

//--------------------------------------------------------------------------------------------//
// functions to kill a job (only ProcCon created jobs can be killed)                          //
// Input:    job name                                                                         //
// Returns:  PCERROR_SUCCESS on success, else error code                                      //
//--------------------------------------------------------------------------------------------//
INT32 CProcConMgr::KillJob( JOB_NAME &name ) {

   // Determine if user has right to kill jobs...
   if ( m_cDB.TestAccess( PROCCON_REG_KILLJOB_ACCTEST ) != ERROR_SUCCESS ) 
      return GetLastError();
   
   INT32 err = PCERROR_DOES_NOT_EXIST;       // prime error code for subsequent logic

   // Locate the job in our job list to get handle.  If found, simply terminate the job.
   //   Note that terminating the job simply means terminate all contained processes.
   //   If the close on empty option is set, the job will be closed in the notify routine.
   EnterCriticalSection( &m_mgCSMgrLists );

   for ( ManagedJob *prev = NULL, *job = m_jobAnchor; job; prev = job, job = job->next ) {
      if ( !CompareJobName( &name, &job->jName ) ) {
         if ( !TerminateJobObject( job->jobHandle, ERROR_PROCESS_ABORTED ) ) 
            err = GetLastError();
         else 
            err = PCERROR_SUCCESS;
         break;
      }
   }

   LeaveCriticalSection( &m_mgCSMgrLists );

   // If successful, log a message...
   if ( err == PCERROR_SUCCESS ) {
      const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, name };
      PCLogMessage( PC_SERVICE_KILLED_JOB, EVENTLOG_INFORMATION_TYPE, ENTRY_COUNT(msgs), msgs );
   }

   return err;
}

//--------------------------------------------------------------------------------------------//
// functions to kill a process (any Windows process can be killed)                            //
// Input:    process pid and process create time                                              //
// Returns:  PCERROR_SUCCESS on success, else error code                                      //
//--------------------------------------------------------------------------------------------//
INT32 CProcConMgr::KillProcess( ULONG_PTR pid, TIME_VALUE created ) {

   // Determine if user has right to kill processes...
   if ( m_cDB.TestAccess( PROCCON_REG_KILLPROC_ACCTEST ) != ERROR_SUCCESS ) 
      return GetLastError();

   INT32 err = ERROR_SUCCESS;

   // Attempt to get a handle to the process...
   HANDLE hProc = OpenProcess( PROCESS_QUERY_INFORMATION    // to get time data 
                               + PROCESS_TERMINATE,         // to terminate it
                               FALSE, (DWORD) pid );        // Win64 OpenProcess still uses DWORD PID == warning
   // If we found it, determine if its the same one (by create time) and terminate it...
   if ( hProc ) {
      FILETIME create, exit, kernel, user;
      GetProcessTimes( hProc, &create, &exit, &kernel, &user );
      if ( created != 0x777deadfeeb1e777 && PCFileTimeToInt64( create ) != created )
         err = PCERROR_DOES_NOT_EXIST;
      else if ( !TerminateProcess( hProc, ERROR_PROCESS_ABORTED ) ) 
         err = GetLastError();
      CloseHandle( hProc );
   }
   else {
      err = GetLastError();
      if ( err == ERROR_INVALID_PARAMETER )
         err = PCERROR_DOES_NOT_EXIST;
   }

   // If successful, log a message...
   if ( err == ERROR_SUCCESS ) {
      TCHAR pidAsString[32];       
      _i64tot( pid, pidAsString, 10 );
      const TCHAR *msgs[] = { PROCCON_SVC_DISP_NAME, pidAsString };
      PCLogMessage( PC_SERVICE_KILLED_PROCESS, EVENTLOG_INFORMATION_TYPE, ENTRY_COUNT(msgs), msgs );
   }

   return err;
}

   // End of CProcConMgr.cpp
//============================================================================J McDonald fecit====//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\service\cproccondb.cpp ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998, 1999  Sequent Computer Systems, Incorporated                       //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|---------------------------------------------------------------------------------------//            
|   This file implements the CProcConDB class methods defined in ProcConSvc.h           //
|---------------------------------------------------------------------------------------//            
|                                                                                       //
|Created:                                                                               //
|                                                                                       //
|   Jarl McDonald 07-98                                                                 //
|                                                                                       //
|Revision History:                                                                      //
|   Paul Skoglund 04-2001                                                               //
|     -Support Microsoft feature request to add event log reporting for all Proccon     //
|      rule editing.                                                                    //
|     -Fix bug with restore not flushing old process and group execution rules.         //
|      Problem appeared if the restore didn't include any process execution rules       //
|      or group execution rules.                                                        //
|   Paul Skoglund 05-2001                                                               //
|     -Remove rounding to page boundry of working set min and max values.  This is      //
|      now done in the apply functions; this is consistent with the handling of         //
|      process and job committed memory limits.                                         //
|=======================================================================================*/
#include "ProcConSvc.h"

const TCHAR      CProcConDB::PCDB_PREFIX_FLAGS       = TEXT('F');
const TCHAR      CProcConDB::PCDB_PREFIX_AFFINITY    = TEXT('A');
const TCHAR      CProcConDB::PCDB_PREFIX_PRIORITY    = TEXT('P');
const TCHAR      CProcConDB::PCDB_PREFIX_MINWS       = TEXT('L');
const TCHAR      CProcConDB::PCDB_PREFIX_MAXWS       = TEXT('H');
const TCHAR      CProcConDB::PCDB_PREFIX_SCHEDCLASS  = TEXT('S');
const TCHAR      CProcConDB::PCDB_PREFIX_PROCTIME    = TEXT('T');
const TCHAR      CProcConDB::PCDB_PREFIX_JOBTIME     = TEXT('U');
const TCHAR      CProcConDB::PCDB_PREFIX_ACTIVEPROCS = TEXT('C');
const TCHAR      CProcConDB::PCDB_PREFIX_PROCMEMORY  = TEXT('M');
const TCHAR      CProcConDB::PCDB_PREFIX_JOBMEMORY   = TEXT('N');

const TCHAR      CProcConDB::BEG_BRACKET         = TEXT('{');  // leading char in rules stored in DB
const TCHAR      CProcConDB::END_BRACKET         = TEXT('}');  // trailing char in rules stored in DB
const TCHAR      CProcConDB::FIELD_SEP           = TEXT(',');  // separates fields in rules stored in DB
const TCHAR      CProcConDB::STRING_DELIM        = TEXT('"');  // delimits text strings stored in DB
const TCHAR      CProcConDB::RULE_MATCHONE       = TEXT('?');     
const TCHAR      CProcConDB::RULE_MATCHANY       = TEXT('*');     
const TCHAR      CProcConDB::NAME_IS_PGM[]       = COPY_PGM_NAME;     
const TCHAR      CProcConDB::NAME_IS_DIR[]       = COPY_DIR_NAME;     
const TCHAR      CProcConDB::HIDE_PROC_PATTERN[] = HIDE_THIS_PROC;     
const TCHAR      CProcConDB::PATTERN_CHARS[]     = TEXT("PDH");     
      PCNameRule CProcConDB::DEFAULT_NAME_RULE   = { { RULE_MATCHANY, 0 }, COPY_PGM_NAME, { 0 }, MATCH_PGM };     

// CProcConDB Constructor
// Note: this runs as part of service start so keep it quick!
CProcConDB::CProcConDB( PCUINT32 pageSize ) : 
                                 m_fmtNameRules( NULL ), m_intNameRules( NULL ),
                                 m_parmRegKey( NULL ),   m_procRegKey( NULL ),   m_jobRegKey( NULL ), 
                                 m_dbEvent( NULL ),      m_parmEvent( NULL ),
                                 m_procSummary( NULL ),  m_jobSummary( NULL ),
                                 m_numNameRules( 0 ),    m_numProcRules( 0 ),    m_numJobRules( 0 ),
                                 m_updCtrName( 1 ),      m_updCtrProc( 1 ),      m_updCtrJob( 1 ),
                                 m_pollDelay( 60 ),      m_pageSize( pageSize ), m_cMgr( NULL ),
                                 m_LogRuleEdits( TRUE )
{

   InitializeCriticalSection( &m_dbCSNameRule );
   InitializeCriticalSection( &m_dbCSProcRule );
   InitializeCriticalSection( &m_dbCSJobRule );
   memset( m_curProfile, 0, sizeof(m_curProfile) );

   memcpy( DEFAULT_NAME_RULE.description, PROCCON_DEFAULT_NAMERULE_DESC, sizeof(DEFAULT_NAME_RULE.description) );

   if ( !PCBuildAdminSecAttr( m_secAttr ) ) return; 

   if ( !OpenParmKey() ) return;
   if ( !OpenProcKey() ) return;
   if ( !OpenJobKey()  ) return;

   // Get (or set to default if it doesn't exist) basic parameters...
   PCULONG32  dfltPoll = m_pollDelay;                      // save default
   m_lastRegError = GetPCParm( PROCCON_DATA_POLLDELAY, &m_pollDelay );
   if ( m_lastRegError != ERROR_SUCCESS ) {
      RegError( TEXT("Load/Set Parameter"), PROCCON_DATA_POLLDELAY );
      return;
   }
   if ( m_pollDelay < PC_MIN_POLL_DELAY || m_pollDelay > PC_MAX_POLL_DELAY )   // ensure sanity
      m_pollDelay = dfltPoll;    
   m_pollDelay *= 1000;                               // convert to milliseconds

   m_dbEvent   = CreateEvent( NULL, TRUE, FALSE, NULL );
   m_parmEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
   if ( !m_dbEvent || !m_parmEvent ) {                     // Should never happen
      PCLogUnExError( m_dbEvent? TEXT("RegEvent") : TEXT("DBEvent"), TEXT("CreateEvent") );
      return;
   }

   m_lastRegError = RegNotifyChangeKeyValue( m_parmRegKey, TRUE, 
                                             REG_NOTIFY_CHANGE_NAME + REG_NOTIFY_CHANGE_LAST_SET, 
                                             m_parmEvent, TRUE );
   if ( m_lastRegError != ERROR_SUCCESS ) {                // Should never happen
      RegError( TEXT("RegNotifyChangeKeyValue") );
      CloseHandle( m_parmEvent );
      m_parmEvent = NULL;
      return;
   }
}

// CProcConDB Destructor
CProcConDB::~CProcConDB( void ) 
{
   if ( m_fmtNameRules ) delete [] m_fmtNameRules;
   if ( m_intNameRules ) delete [] m_intNameRules;

   if ( m_parmRegKey   ) RegCloseKey( m_parmRegKey );
   if ( m_procRegKey   ) RegCloseKey( m_procRegKey );
   if ( m_jobRegKey    ) RegCloseKey( m_jobRegKey );
   if ( m_dbEvent      ) CloseHandle( m_dbEvent );
   if ( m_parmEvent    ) CloseHandle( m_parmEvent );

   PCFreeSecAttr( m_secAttr ); 

   DeleteCriticalSection( &m_dbCSNameRule );
   DeleteCriticalSection( &m_dbCSProcRule );
   DeleteCriticalSection( &m_dbCSJobRule );
}

//--------------------------------------------------------------------------------------------//
// Function to determine if all CProcConDB initial conditions have been met                   //
// Input:    None                                                                             //
// Returns:  TRUE if ready, FALSE if not                                                      //
//--------------------------------------------------------------------------------------------//
BOOL CProcConDB::ReadyToRun( void )  
{ 
   return m_parmRegKey && 
      m_procRegKey     && 
      m_jobRegKey      && 
      m_dbEvent        && 
      m_parmEvent      &&
      m_secAttr.lpSecurityDescriptor; 
}

//--------------------------------------------------------------------------------------------//
// Function to create/open a registry key at HKEY_LOCAL_MACHINE level                         //
// Input:    key name, location of opened key                                                 //
// Returns:  ERROR_SUCCESS if successful, error code if not                                   //
// Note:     key is created with DB security attributes (established in constructor).         //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::CreateKeyAtHKLM( const TCHAR *key, HKEY *hKey ) {
   if ( !*hKey ) {
      PCULONG32 regDisp;
      m_lastRegError = RegCreateKeyEx( HKEY_LOCAL_MACHINE, key, 0, TEXT(""), 0, 
                                       KEY_READ + KEY_WRITE, &m_secAttr, hKey, &regDisp );
      if ( m_lastRegError != ERROR_SUCCESS )                   // Should never happen
         return RegError( TEXT("RegCreateKeyEx"), key );
   }
   return ERROR_SUCCESS;
}

//--------------------------------------------------------------------------------------------//
// Function to drive the loading of all ProcCon rules from the database (NT registry)         //
// Input:    which rules to load flags                                                        //
// Returns:  ERROR_SUCCESS if successful, NT error code if not                                //
// Note:     if an error is returned, an error event has been logged.                         //
//           if success is returned, a database event has been pulsed to wake those that care.//
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::LoadRules( PCULONG32  which ) 
{
   PCULONG32  rc = ERROR_SUCCESS;

   if ( which & LOADFLAG_NAME_RULES ) {
      EnterCriticalSection( &m_dbCSNameRule );
      ++m_updCtrName;
      rc = LoadNameRules( &m_numNameRules );
      LeaveCriticalSection( &m_dbCSNameRule );
   }

   if ( rc == ERROR_SUCCESS && which & LOADFLAG_PROC_RULES ) {
      EnterCriticalSection( &m_dbCSProcRule );
      ++m_updCtrProc;
      rc = LoadProcSummary();
      LeaveCriticalSection( &m_dbCSProcRule );
   }
   if ( rc == ERROR_SUCCESS && which & LOADFLAG_JOB_RULES  ) {
      EnterCriticalSection( &m_dbCSJobRule );
      ++m_updCtrJob;
      rc = LoadJobSummary();
      LeaveCriticalSection( &m_dbCSJobRule );
   }
   if ( rc != ERROR_SUCCESS ) {
      SetLastError( rc );
      PCLogUnExError( TEXT("PCDataBase"), TEXT("LoadRules") );
   }
   else
      PulseEvent( m_dbEvent );          // Tell others database may have changed

   return rc;
}

//--------------------------------------------------------------------------------------------//
// Function to load all ProcCon name rules from the database                                  //
// Input:    pointer to rule count location,                                                  //
// Returns:  ERROR_SUCCESS if successful, NT error code if not                                //
// Note:     If an error is returned, an error event has been logged.                         //
// N.B.:     The appropriate critical section mast be held by the CALLER.                     //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::LoadNameRules( PCULONG32 *count ) 
{

   // Determine size of data and validate type of data...
   // If data is missing or of invalid type, set to default (empty) value.
   PCULONG32 vType, vSize;

   vSize = 0;
   m_lastRegError = RegQueryValueEx( m_parmRegKey, PROCCON_DATA_NAMERULES, 
                                     NULL, &vType, NULL, &vSize );
   if ( m_lastRegError != ERROR_SUCCESS && m_lastRegError != ERROR_FILE_NOT_FOUND ) 
      return RegError( TEXT("RegQueryValueEx"), PROCCON_DATA_NAMERULES );

   if ( vType != REG_MULTI_SZ || m_lastRegError == ERROR_FILE_NOT_FOUND ) {
      vType = REG_MULTI_SZ;
      vSize = 2 * sizeof(TCHAR);
      m_lastRegError = RegSetValueEx( m_parmRegKey, PROCCON_DATA_NAMERULES, NULL, vType, 
                                      (UCHAR *) TEXT("\0\0"), vSize );
      if ( m_lastRegError != ERROR_SUCCESS )
         return RegDataError( PROCCON_DATA_NAMERULES );
   }

   // Allocate space for raw rules...
   *count = 0;
   TCHAR *rawNameRules = new TCHAR[vSize / sizeof(TCHAR)];
   if ( !rawNameRules ) 
      return PCLogNoMemory( TEXT("AllocNameRules"), vSize / sizeof(TCHAR) ); 

   // Load the rule data...
   m_lastRegError = RegQueryValueEx( m_parmRegKey, PROCCON_DATA_NAMERULES, 
                         NULL, &vType, (UCHAR *) rawNameRules, &vSize );
   if ( m_lastRegError != ERROR_SUCCESS ) {
      delete [] rawNameRules;
      return RegError( TEXT("RegQueryValueEx"), PROCCON_DATA_NAMERULES );
   }

   // Count strings in the data...
   PCULONG32   i, len;
   TCHAR *p, *end = rawNameRules + vSize / sizeof(TCHAR);
   if ( *rawNameRules ) {
      for ( p = rawNameRules; p < end; ++*count, p += _tcslen( p ) + 1 ) ;
      --*count;                        // uncount null entry at end due to double-NULL
   }

   // Delete old copy of rules, if any, and allocate and zero new......
   if ( m_fmtNameRules ) delete [] m_fmtNameRules;
   if ( m_intNameRules ) { delete [] m_intNameRules;  m_intNameRules = NULL; }
   m_fmtNameRules = new PCNameRule[*count + 1];   // include an entry for our default rule
   if ( !m_fmtNameRules ) {      
      delete [] rawNameRules;
      return PCLogNoMemory( TEXT("AllocFmtNameRules"), sizeof(PCNameRule) * (*count + 1) ); 
   }

   memset( m_fmtNameRules, 0, sizeof(PCNameRule) * (*count + 1) );

   // Build formatted copy from raw copy...
   for ( i = 0, p = rawNameRules; i < *count; ++i, p += len + 1 ) {
      len = _tcslen( p );                             // length of this rule
      TCHAR *beg = p;                                 // start of rule
      TCHAR *end = beg + len;                         // first byte past rule

      if ( *beg++ != BEG_BRACKET || *--end != END_BRACKET ) {
         delete [] rawNameRules;
         return RegDataError( PROCCON_DATA_NAMERULES );
      }
      m_fmtNameRules[i].matchType = *beg++;           // get type, point to separator

      if ( *--end == STRING_DELIM ) {                 // if we have description, extract it
         TCHAR *strend = --end;
         while ( *end != STRING_DELIM && end > beg ) --end; // find matching delimiter
         PCULONG32 len = (PCULONG32) (strend - end);
         memcpy( m_fmtNameRules[i].description, end + 1, len * sizeof(TCHAR) );
         if ( end > beg ) end -= 2;
      }

      TCHAR *procEnd = end;
      while ( *end != FIELD_SEP && end > beg ) --end; // find last separator in rule
      if ( *beg != FIELD_SEP || *end != FIELD_SEP || beg == end ) {
         delete [] rawNameRules;
         return RegDataError( PROCCON_DATA_NAMERULES );
      }

      memcpy( m_fmtNameRules[i].matchString, beg + 1, (UINT32) (end - beg - 1) * sizeof(TCHAR) );
      memcpy( m_fmtNameRules[i].procName,    end + 1, (UINT32) (procEnd - end) * sizeof(TCHAR) );
   }

   delete [] rawNameRules;                            // done with raw data

   // Add our default rule at end...
   memcpy( &m_fmtNameRules[*count], &DEFAULT_NAME_RULE, sizeof(DEFAULT_NAME_RULE) );
   ++*count;                                          // count the default rule

   return ERROR_SUCCESS;
}

//--------------------------------------------------------------------------------------------//
// Function to store all ProcCon name rules in the database                                   //
// Input:    none -- m_fmtNameRules and m_numNameRules are the data source                    //
// Returns:  ERROR_SUCCESS if successful, NT error code if not                                //
// Notes: 1) If an error is returned, an error event has been logged.                         //
//        2) The appropriate critical section must be held by the CALLER.                     //
//        3) The default rule, last in the list, is not stored in the database.               //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::StoreNameRules( void ) 
{
   TCHAR *rawNameRules = (TCHAR *) new char[(sizeof(PCNameRule) + 10) * m_numNameRules];
   if ( !rawNameRules ) 
      return PCLogNoMemory( TEXT("AllocNameRules"), sizeof(PCNameRule) * m_numNameRules );
   
   // Build raw (all character) format of all but last rule.mgmtParms...
   TCHAR *loc = rawNameRules;
   for ( PCULONG32  i = 0; i < m_numNameRules - 1; ++i ) {
      loc += _stprintf( loc, TEXT("%c%c%c%.*s%c%.*s%c%c%.*s%c%c"), 
                        BEG_BRACKET, 
                                                 m_fmtNameRules[i].matchType,   FIELD_SEP,
                           MATCH_STRING_LEN,     m_fmtNameRules[i].matchString, FIELD_SEP,
                           PROC_NAME_LEN,        m_fmtNameRules[i].procName,    FIELD_SEP,
             STRING_DELIM, NAME_DESCRIPTION_LEN, m_fmtNameRules[i].description, STRING_DELIM,
                        END_BRACKET );
      *loc++ = 0;    // terminate substring with NULL
   }
   *loc++ = 0;    // terminated all data by a second NULL

   // Store the rule data...  
   m_lastRegError = RegSetValueEx( m_parmRegKey, PROCCON_DATA_NAMERULES, 
                                   NULL, REG_MULTI_SZ, (UCHAR *) rawNameRules, 
                                   (ULONG32) ((UCHAR *) loc - (UCHAR *) rawNameRules) );
   delete [] ((char *) rawNameRules);

   if ( m_lastRegError != ERROR_SUCCESS )
      return RegError( TEXT("RegSetValueEx"), PROCCON_DATA_NAMERULES );

   return ERROR_SUCCESS;
}

//--------------------------------------------------------------------------------------------//
// Function to load ProcCon process summary data from the database                            //
// Input:    none                                                                             //
// Returns:  ERROR_SUCCESS if successful, NT error code if not                                //
// Note:     If an error is returned, an error event has been logged.                         // 
// N.B.:     The appropriate critical section mast be held by the CALLER.                     //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::LoadProcSummary( void )     
{
   // Delete old data, if any...
   if ( m_procSummary ) {
      delete [] m_procSummary;
      m_procSummary = NULL;
   }
   m_numProcRules = 0;

   // Determine how many rules we have, done if none...
   m_lastRegError = RegQueryInfoKey( m_procRegKey, NULL, NULL, NULL, &m_numProcRules, 
                                     NULL, NULL, NULL, NULL, NULL, NULL, NULL );
   if ( m_lastRegError != ERROR_SUCCESS ) {                    // Should never happen
      TCHAR key[MAX_PATH];
      return RegError( TEXT("RegQueryInfoKey"), BuildProcKey( key ) );
   }

   // Allocate storage for rules to be loaded...
   m_procSummary = new PCProcSummary[m_numProcRules];
   if ( !m_procSummary ) {
      m_numProcRules = 0;
      return PCLogNoMemory( TEXT("LoadProcessRules"), sizeof(PCProcSummary) * m_numProcRules );
   }
   memset( m_procSummary, 0, sizeof(PCProcSummary) * m_numProcRules );

   for ( PCULONG32  i = 0, err = 0; i < m_numProcRules; ++i ) {

      PCProcSummary &item = (m_procSummary)[i];

      // Get next subkey (proc name)...
      FILETIME keyLastWrite;
      PCULONG32     nameLen = ENTRY_COUNT(item.procName);
      m_lastRegError = RegEnumKeyEx( m_procRegKey, i, item.procName, &nameLen, NULL, NULL, NULL, &keyLastWrite );
      if ( m_lastRegError != ERROR_SUCCESS ) {                   
         TCHAR key[MAX_PATH];
         err = RegError( TEXT("RegEnumKeyEx"), BuildProcKey( key ) );
         break;
      }

      // Open the subkey to get proc details...
      HKEY hKeyTemp;
      m_lastRegError = RegOpenKeyEx( m_procRegKey, item.procName, 0, KEY_READ + KEY_WRITE, &hKeyTemp );
      if ( m_lastRegError != ERROR_SUCCESS ) {                   // Should never happen
         TCHAR key[MAX_PATH];
         err = RegError( TEXT("RegOpenKeyEx"), BuildProcKey( key ), item.procName );
         break;
      }

      err = LoadProcSummaryItem( hKeyTemp, item );
      RegCloseKey( hKeyTemp );
   }

   if ( err ) {
      delete [] m_procSummary; 
      m_procSummary = NULL;
      m_numProcRules = 0;
   }
   else if ( m_numProcRules > 1 )
      qsort( m_procSummary, m_numProcRules, sizeof(PCProcSummary), CompareProcSummary );

   return err;
}

//--------------------------------------------------------------------------------------------//
// Function to load summary data for a process from the database                              //
// Input:    registry key to use,                                                             //
//           summary structure to complete                                                    //
// Returns:  nothing (errors are handled by flagging the rule)                                //
// Note:     NT error code                                                                    //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::LoadProcSummaryItem( const HKEY &hKey, PCProcSummary &item ) {

   // Get job membership information if this is a process name and MemberOf is present and valid..
   PCULONG32  byteType, workLen = sizeof(item.memberOfJobName);
   if ( RegQueryValueEx( hKey, PROCCON_DATA_MEMBEROF, NULL, &byteType, (UCHAR *)item.memberOfJobName, &workLen )
        == ERROR_SUCCESS && byteType == REG_SZ )
      item.mgmtParms.mFlags |= PCMFLAG_PROC_HAS_JOB_REFERENCE;

   return LoadMgmtRules( hKey, item.mgmtParms );

}

//--------------------------------------------------------------------------------------------//
// Function to load job summary data from the database                                        //
// Input:    none                                                                             //
// Returns:  ERROR_SUCCESS if successful, NT error code if not                                //
// Note:     If an error is returned, an error event has been logged.                         // 
// N.B.:     The appropriate critical section mast be held by the CALLER.                     //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::LoadJobSummary( void )     
{
   // Delete old data, if any...
   if ( m_jobSummary ) {
      delete [] m_jobSummary;
      m_jobSummary = NULL;
   }
   m_numJobRules = 0;

   // Determine how many rules we have, done if none...
   m_lastRegError = RegQueryInfoKey( m_jobRegKey, NULL, NULL, NULL, &m_numJobRules, 
                                     NULL, NULL, NULL, NULL, NULL, NULL, NULL );
   if ( m_lastRegError != ERROR_SUCCESS ) {                    // Should never happen
      TCHAR key[MAX_PATH];
      return RegError( TEXT("RegQueryInfoKey"), BuildJobKey( key ) );
   }

   // Allocate storage for rules to be loaded...
   m_jobSummary = new PCJobSummary[m_numJobRules];
   if ( !m_jobSummary ) {
      m_numJobRules = 0;
      return PCLogNoMemory( TEXT("LoadJobessRules"), sizeof(PCJobSummary) * m_numJobRules );
   }
   memset( m_jobSummary, 0, sizeof(PCJobSummary) * m_numJobRules );

   for ( PCULONG32  i = 0, err = 0; i < m_numJobRules; ++i ) {

      PCJobSummary &item = (m_jobSummary)[i];

      // Get next subkey (job name)...
      FILETIME keyLastWrite;
      PCULONG32     nameLen = ENTRY_COUNT(item.jobName);
      m_lastRegError = RegEnumKeyEx( m_jobRegKey, i, item.jobName, &nameLen, NULL, NULL, NULL, &keyLastWrite );
      if ( m_lastRegError != ERROR_SUCCESS ) {                   
         TCHAR key[MAX_PATH];
         err = RegError( TEXT("RegEnumKeyEx"), BuildJobKey( key ) );
         break;
      }

      // Open the subkey to get job details...
      HKEY hKeyTemp;
      m_lastRegError = RegOpenKeyEx( m_jobRegKey, item.jobName, 0, KEY_READ + KEY_WRITE, &hKeyTemp );
      if ( m_lastRegError != ERROR_SUCCESS ) {                   // Should never happen
         TCHAR key[MAX_PATH];
         err = RegError( TEXT("RegOpenKeyEx"), BuildJobKey( key ), item.jobName );
         break;
      }

      err = LoadJobSummaryItem( hKeyTemp, item );
      RegCloseKey( hKeyTemp );
   }

   if ( err ) {
      delete [] m_jobSummary; 
      m_jobSummary = NULL;
      m_numJobRules = 0;
   }
   else if ( m_numJobRules > 1 )
      qsort( m_jobSummary, m_numJobRules, sizeof(PCJobSummary), CompareJobSummary );

   return err;
}

//--------------------------------------------------------------------------------------------//
// Function to load summary data for a job from the database                                  //
// Input:    registry key to use,                                                             //
//           summary structure to complete                                                    //
// Returns:  nothing (errors are handled by flagging the rule)                                //
// Note:     NT error code                                                                    //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::LoadJobSummaryItem( const HKEY &hKey, PCJobSummary &item ) {

   return LoadMgmtRules( hKey, item.mgmtParms );
}

//--------------------------------------------------------------------------------------------//
// Function to load management data from the database                                         //
// Input:    registry key to use,                                                             //
//           parameter structure to complete                                                  //
// Returns:  nothing (errors are handled by flagging the rule)                                //
// Note:     NT or PC error code                                                              //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::LoadMgmtRules( const HKEY &hKey, MGMT_PARMS &parms ) {

   ULONG byteType;
   TCHAR work[1024];
   PCULONG32  workLen;
   BOOL  gotdata = FALSE;

   parms.affinity  = parms.minWS = parms.maxWS = 0;
   parms.mFlags   &= ~PCMFLAG_SAVEABLE_BITS;           // clear database bits
   parms.priority  = parms.schedClass = 0;
   memset( parms.description, 0, sizeof(parms.description) );
   memset( parms.future,      0, sizeof(parms.future) );

   // If we have a profile name, attempt to retrieve parameters for this profile..
   if ( *parms.profileName ) {
      workLen = sizeof(work);
      m_lastRegError = RegQueryValueEx( hKey, parms.profileName, NULL, &byteType, (
                                        UCHAR *)work, &workLen );
      
      if ( m_lastRegError == ERROR_SUCCESS )
         gotdata = TRUE;
      else if ( m_lastRegError != ERROR_FILE_NOT_FOUND )
         return RegError( TEXT("RegQueryValueEx"), parms.profileName );
   }

   // If no profile-based data, attempt to retrieve parameters via default name..
   if ( !gotdata ) {
      workLen = sizeof(work);
      m_lastRegError = RegQueryValueEx( hKey, PROCCON_DATA_DEFAULTRULES, NULL, &byteType, 
                                        (UCHAR *)work, &workLen ); 

      if ( m_lastRegError != ERROR_SUCCESS ) {
         parms.mFlags |= PCMFLAG_NORULES;
         return RegError( TEXT("RegQueryValueEx"), PROCCON_DATA_DEFAULTRULES );
      }
   }

   // Verify basic format --- data between braces '{}'...
   TCHAR *beg = work, *end = work + workLen / sizeof(TCHAR) - 1;
   if ( *beg++ != BEG_BRACKET || *--end != END_BRACKET ) {
      parms.mFlags |= PCMFLAG_BADRULES;
      return PCERROR_BAD_DATABASE_DATA;
   }
   if ( beg == end ) return PCERROR_SUCCESS;             // just an entry of "{}"

   for ( TCHAR *e = beg; *e; ++e ) {
      switch ( *e ) {
      case PCDB_PREFIX_FLAGS:
         parms.mFlags |= PCGetParmValue( e + 1, &e );
         break;
      case PCDB_PREFIX_AFFINITY:
         parms.affinity = PCGetParmValue64( e + 1, &e );
         break;
      case PCDB_PREFIX_PRIORITY:
         parms.priority = PCGetParmValue( e + 1, &e );
         break;
      case PCDB_PREFIX_MINWS:
         parms.minWS = PCGetParmValue64( e + 1, &e );
         break;
      case PCDB_PREFIX_MAXWS:
         parms.maxWS = PCGetParmValue64( e + 1, &e );
         break;
      case PCDB_PREFIX_SCHEDCLASS:
         parms.schedClass = PCGetParmValue( e + 1, &e );
         break;
      case PCDB_PREFIX_PROCTIME:
         parms.procTimeLimitCNS = PCGetParmValue64( e + 1, &e );
         break;
      case PCDB_PREFIX_JOBTIME:
         parms.jobTimeLimitCNS = PCGetParmValue64( e + 1, &e );
         break;
      case PCDB_PREFIX_ACTIVEPROCS:
         parms.procCountLimit = PCGetParmValue( e + 1, &e );
         break;
      case PCDB_PREFIX_PROCMEMORY:
         parms.procMemoryLimit = PCGetParmValue64( e + 1, &e );
         break;
      case PCDB_PREFIX_JOBMEMORY:
         parms.jobMemoryLimit = PCGetParmValue64( e + 1, &e );
         break;
      default:
         parms.mFlags |= PCMFLAG_BADRULES;
         return PCERROR_BAD_DATABASE_DATA;
      }

      if ( *e != END_BRACKET && *e != FIELD_SEP ) {
         parms.mFlags |= PCMFLAG_BADRULES;
         return PCERROR_BAD_DATABASE_DATA;
      }
   }

   // Load description, if any...
   workLen = sizeof(work);
   m_lastRegError = RegQueryValueEx( hKey, PROCCON_DATA_DESCRIPTION, NULL, &byteType, 
                                     (UCHAR *)work, &workLen ); 
   if ( m_lastRegError == ERROR_SUCCESS )
      _tcsncpy( parms.description, work, RULE_DESCRIPTION_LEN );
   else if ( m_lastRegError != ERROR_FILE_NOT_FOUND )
      return RegError( TEXT("RegQueryValueEx"), PROCCON_DATA_DESCRIPTION );

   return PCERROR_SUCCESS;
}

//--------------------------------------------------------------------------------------------//
// Function to store ProcCon process detail management rule in the database                   //
// Input:    ref to data to store.                                                            //
// Returns:  ERROR_SUCCESS if successful, NT or PC error code if not                          //
// Note:     If an error is returned, an error event has been logged.                         // 
// Note:     The appropriate critical section mast be held by the CALLER.                     //
// Note:     key is created with DB security attributes (established in constructor).         //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::StoreProcDetail( const PCProcDetail &rule )      
{
   // Open or create and open the process subkey...
   HKEY  hKeyTemp;
   PCULONG32  regDisp;
   m_lastRegError = RegCreateKeyEx( m_procRegKey, rule.base.procName, 0, TEXT(""), 0, 
                                    KEY_READ + KEY_WRITE, &m_secAttr, &hKeyTemp, &regDisp );
   if ( m_lastRegError != ERROR_SUCCESS )                   // Should never happen
      return RegError( TEXT("RegCreateKeyEx"), rule.base.procName );

   PCULONG32  err = StoreProcValues( hKeyTemp, rule );
   RegCloseKey( hKeyTemp );

   return err;
}

//--------------------------------------------------------------------------------------------//
// Function to store values for a job or process management rule in the database              //
// Input:    registry key to use,                                                             //
//           management rule structure to store                                               //
// Returns:  ERROR_SUCCESS if successful, NT or PC error code if not                          //
// Note:     Data errors lead to default behavior, not failure.                               //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::StoreProcValues( const HKEY &hKey, const PCProcDetail &rule ) {

   PCULONG32  err = 0;

   // Set/delete job membership information as needed...
   PCULONG32  len = _tcslen( rule.base.memberOfJobName );
   if ( len ) {
      m_lastRegError = RegSetValueEx( hKey, PROCCON_DATA_MEMBEROF, NULL, REG_SZ, 
                                      (UCHAR *) rule.base.memberOfJobName, (len + 1) * sizeof(TCHAR) );
      if ( m_lastRegError != ERROR_SUCCESS )                    // Should never happen
         err = RegError( TEXT("RegSetValueEx"), PROCCON_DATA_MEMBEROF );
   }
   else {
      m_lastRegError = RegDeleteValue( hKey, PROCCON_DATA_MEMBEROF );    
      if ( m_lastRegError != ERROR_SUCCESS && m_lastRegError != ERROR_FILE_NOT_FOUND )       
         err = RegError( TEXT("RegDeleteValue"), PROCCON_DATA_MEMBEROF );
   }

   // Set management data under profile name (or default)...
   if ( !err ) err = StoreMgmtRules( hKey, rule.base.mgmtParms );

   // Set variable data...
   if ( !err && rule.vLength) err = StoreVariableData( hKey, rule.vLength, rule.vData );

   return err;
}

//--------------------------------------------------------------------------------------------//
// Function to store ProcCon job detail definition in the database                            //
// Input:    ref to data to store.                                                            //
// Returns:  ERROR_SUCCESS if successful, NT or PC error code if not                          //
// Note:     If an error is returned, an error event has been logged.                         // 
// Note:     The appropriate critical section mast be held by the CALLER.                     //
// Note:     key is created with DB security attributes (established in constructor).         //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::StoreJobDetail( const PCJobDetail &rule )      
{
   // Open or create and open the job subkey...
   HKEY  hKeyTemp;
   PCULONG32  regDisp;
   m_lastRegError = RegCreateKeyEx( m_jobRegKey, rule.base.jobName, 0, TEXT(""), 0, 
                                    KEY_READ + KEY_WRITE, &m_secAttr, &hKeyTemp, &regDisp );
   if ( m_lastRegError != ERROR_SUCCESS )                   // Should never happen
      return RegError( TEXT("RegCreateKeyEx"), rule.base.jobName );

   PCULONG32  err = StoreJobValues( hKeyTemp, rule );
   RegCloseKey( hKeyTemp );

   return err;
}

//--------------------------------------------------------------------------------------------//
// Function to store values for a job management rule in the database                         //
// Input:    registry key to use,                                                             //
//           management rule structure to store                                               //
// Returns:  ERROR_SUCCESS if successful, NT or PC error code if not                          //
// Note:     Data errors lead to default behavior, not failure.                               //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::StoreJobValues( const HKEY &hKey, const PCJobDetail &rule ) {

   PCULONG32  err = 0;

   // Set management data under profile name (or default)...
   err = StoreMgmtRules( hKey, rule.base.mgmtParms );

   // Set variable data...
   if ( !err && rule.vLength) err = StoreVariableData( hKey, rule.vLength, rule.vData );

   return err;
}

//--------------------------------------------------------------------------------------------//
// Function to store management rules for a job or process in the database                    //
// Input:    registry key to use, profile name to use,                                        //
//           management rule structure to store.                                              //
// Returns:  NT error code                                                                    //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::StoreMgmtRules( const HKEY &hKey, const MGMT_PARMS &parms ) {

   PCULONG32  err = ERROR_SUCCESS;
   const TCHAR * const name = *parms.profileName? parms.profileName : PROCCON_DATA_DEFAULTRULES;
   TCHAR buf[512];

   // Set 'normal' setting for data to keep unacceptable data out of the DB.
   PRIORITY         priority = parms.priority;
   SCHEDULING_CLASS schedCls = parms.schedClass;
   if ( !priority )    priority = PCPrioNormal;
   if ( schedCls > 9 ) schedCls = 5;

   // Determine if caller is authorized to set various parameters...
   if ( PCMapPriorityToNT( parms.priority ) == REALTIME_PRIORITY_CLASS &&
        TestAccess( PROCCON_REG_REALTIME_ACCTEST ) != ERROR_SUCCESS )
      return GetLastError();

   // Build parameter string to store in database...
   PCULONG32 len = _stprintf( buf, TEXT("%c")
                              TEXT("%c0x%x%c")       // flgs 
                              TEXT("%c0x%I64x%c")    // aff
                              TEXT("%c0x%x%c")       // prio
                              TEXT("%c0x%I64x%c")    // min WS
                              TEXT("%c0x%I64x%c")    // max WS
                              TEXT("%c0x%x%c")       // sched cls
                              TEXT("%c0x%I64x%c")    // proc time
                              TEXT("%c0x%I64x%c")    // job time
                              TEXT("%c0x%x%c")       // proc ct
                              TEXT("%c0x%I64x%c")    // proc mem
                              TEXT("%c0x%I64x%c"),   // job mem
                             BEG_BRACKET, 
                                PCDB_PREFIX_FLAGS,       parms.mFlags & PCMFLAG_SAVEABLE_BITS, FIELD_SEP,
                                PCDB_PREFIX_AFFINITY,    parms.affinity,                       FIELD_SEP,
                                PCDB_PREFIX_PRIORITY,    priority,                             FIELD_SEP,
                                PCDB_PREFIX_MINWS,       parms.minWS,                          FIELD_SEP,
                                PCDB_PREFIX_MAXWS,       parms.maxWS,                          FIELD_SEP,
                                PCDB_PREFIX_SCHEDCLASS,  schedCls,                             FIELD_SEP,
                                PCDB_PREFIX_PROCTIME,    parms.procTimeLimitCNS,               FIELD_SEP,
                                PCDB_PREFIX_JOBTIME,     parms.jobTimeLimitCNS,                FIELD_SEP,
                                PCDB_PREFIX_ACTIVEPROCS, parms.procCountLimit,                 FIELD_SEP,
                                PCDB_PREFIX_PROCMEMORY,  parms.procMemoryLimit,                FIELD_SEP,
                                PCDB_PREFIX_JOBMEMORY,   parms.jobMemoryLimit,  
                             END_BRACKET );

   // Store the string...
   m_lastRegError = RegSetValueEx( hKey, name, NULL, REG_SZ, (UCHAR *) buf, (len + 1) *sizeof(TCHAR) );
   if ( m_lastRegError != ERROR_SUCCESS )                    // Should never happen
      err = RegError( TEXT("RegSetValueEx"), name );

   // Store the description, or, if none, delete any existing description...
   if ( *parms.description ) {
      m_lastRegError = RegSetValueEx( hKey, PROCCON_DATA_DESCRIPTION, NULL, REG_SZ, 
                                      (UCHAR *) parms.description, 
                                      (_tcslen(parms.description) + 1) * sizeof(parms.description[0]) );
      if ( m_lastRegError != ERROR_SUCCESS )                    // Should never happen
         err = RegError( TEXT("RegSetValueEx"), PROCCON_DATA_DESCRIPTION );
   }
   else 
      m_lastRegError = RegDeleteValue( hKey, PROCCON_DATA_DESCRIPTION );

   return err;
}

//--------------------------------------------------------------------------------------------//
// Function to load variable detail data for a job or process in the database                 //
// Input:    registry key to use, data length, data pointer                                   //
// Returns:  NT error code                                                                    //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::LoadVariableData( const HKEY &hKey, PCINT16 *length, TCHAR *data ) {

   PCULONG32  err = ERROR_SUCCESS, regType, regLen = *length;         
   *length = 0;

   m_lastRegError = RegQueryValueEx( hKey, PROCCON_DATA_VARDATA, NULL, 
                                     &regType, (UCHAR *) data, &regLen );

   if ( m_lastRegError == ERROR_MORE_DATA ) return m_lastRegError;

   if ( m_lastRegError == ERROR_SUCCESS )
      *length = (PCINT16) regLen;
   else if ( m_lastRegError != ERROR_FILE_NOT_FOUND ) 
      err = RegError( TEXT("RegQueryValueEx"), PROCCON_DATA_VARDATA );

   return err;
}

//--------------------------------------------------------------------------------------------//
// Function to store variable detail data for a job or process in the database                //
// Input:    registry key to use, data length, data pointer                                   //
// Returns:  NT error code                                                                    //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::StoreVariableData( const HKEY &hKey, const PCINT16 vLength, const TCHAR *vData ) {

   PCULONG32  err = ERROR_SUCCESS;

   m_lastRegError = RegSetValueEx( hKey, PROCCON_DATA_VARDATA, NULL, REG_BINARY, (UCHAR *) vData, vLength );
   if ( m_lastRegError != ERROR_SUCCESS )                    
      err = RegError( TEXT("RegSetValueEx"), PROCCON_DATA_VARDATA );

   return err;
}

//--------------------------------------------------------------------------------------------//
// Function to perform updates after name rules are updated                                   //
// Input:    none -- m_fmtNameRules and m_numNameRules are the data source                    //
// Returns:  ERROR_SUCCESS if successful, NT error code if not                                //
// Note:     The appropriate critical section mast be held by the CALLER.                     //
//           If successful, a database event is pulsed to wake those that care.               //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::NameRulesUpdated( void ) 
{
   ++m_updCtrName;
   PCULONG32  err = StoreNameRules();
   if ( err == ERROR_SUCCESS ) 
      PulseEvent( m_dbEvent );          // Tell others data may have changed
   return err;
}

//--------------------------------------------------------------------------------------------//
// Functions to open (or create) the registry key names for various keys                      //
// Input:    none -- updates member data                                                      //
// Returns:  TRUE on success, else FALSE                                                      //
//--------------------------------------------------------------------------------------------//
BOOL CProcConDB::OpenParmKey( void ) {
   TCHAR key[MAX_PATH];
   PCBuildParmKey( key );

   m_lastRegError = CreateKeyAtHKLM( key, &m_parmRegKey );
   if ( m_lastRegError != ERROR_SUCCESS ) {               // Indicates not properly installed
      PCLogMessage( PC_DB_OPEN_FAILED, EVENTLOG_ERROR_TYPE, 
                    1, TEXT("CreateParmKey") ,
                    sizeof(m_lastRegError), &m_lastRegError );
      return FALSE;
   }

   return TRUE;
}

BOOL CProcConDB::OpenProcKey( void ) {
   TCHAR key[MAX_PATH];
   BuildProcKey( key );

   m_lastRegError = CreateKeyAtHKLM( key, &m_procRegKey );
   if ( m_lastRegError != ERROR_SUCCESS ) {               // Indicates not properly installed
      PCLogMessage( PC_DB_OPEN_FAILED, EVENTLOG_ERROR_TYPE, 
                    1, TEXT("CreateProcKey") ,
                    sizeof(m_lastRegError), &m_lastRegError );
      return FALSE;
   }

   return TRUE;
}

BOOL CProcConDB::OpenJobKey( void ) {
   TCHAR key[MAX_PATH];
   BuildJobKey( key );

   m_lastRegError = CreateKeyAtHKLM( key, &m_jobRegKey );
   if ( m_lastRegError != ERROR_SUCCESS ) {               // Indicates not properly installed
      PCLogMessage( PC_DB_OPEN_FAILED, EVENTLOG_ERROR_TYPE, 
                    1, TEXT("CreateGroupKey") ,
                    sizeof(m_lastRegError), &m_lastRegError );
      return FALSE;
   }

   return TRUE;
}

//--------------------------------------------------------------------------------------------//
// Functions to build the registry key names for various keys                                 //
// Input:    location to build key and, for the name keys, the name                           //
// Returns:  nothing (cannot fail)                                                            //
//--------------------------------------------------------------------------------------------//
TCHAR *CProcConDB::BuildProcKey( TCHAR *key ) {
   PCBuildParmKey( key );
   _tcscat( key, TEXT("\\") );
   _tcscat( key, PROCCON_REG_PROCRULES_SUBKEY );
   return key;
}

TCHAR *CProcConDB::BuildJobKey( TCHAR *key ) {
   PCBuildParmKey( key );
   _tcscat( key, TEXT("\\") );
   _tcscat( key, PROCCON_REG_JOBRULES_SUBKEY );
   return key;
}

//--------------------------------------------------------------------------------------------//
// Function to report a registry function error                                               //
// Input:    name of operation that failed, optional additional string                        //
// Returns:  original error                                                                   //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::RegError( const TCHAR *op, const TCHAR *what1, const TCHAR *what2 ) {
   TCHAR str[MAX_PATH];
   _tcscpy( str, what1? what1 : TEXT("") );
   if ( what2 ) _tcscat( str, what2 );
   const TCHAR *strings[] = { op, str };
   PCLogMessage( PC_UNEXPECTED_REGISTRY_ERROR, EVENTLOG_ERROR_TYPE, 
                 2, strings, sizeof(m_lastRegError), &m_lastRegError );
   return m_lastRegError;
}

//--------------------------------------------------------------------------------------------//
// Function to report a registry data error                                                   //
// Input:    name associated with data                                                        //
// Returns:  NT error ERROR_INVALID_DATA                                                      //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::RegDataError( const TCHAR *what ) {
   PCULONG32  dummy = ERROR_INVALID_DATA;
   PCLogMessage( PC_INVALID_DATA_ERROR, EVENTLOG_ERROR_TYPE, 
                 1, what, sizeof(dummy), &dummy );
   return dummy;
}

//--------------------------------------------------------------------------------------------//
// Function to set a new poll delay                                                           //
// Input:   proposed new delay                                                                //
// Returns: NT or PC error code                                                               //
// Note:    lower and upper limits on poll delay are a bit arbitrary (2 secs to 15 mins OK)   //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::SetPollDelaySeconds( PCULONG32  newDelay )
{
   if ( TestAccess( PROCCON_REG_POLLRATE_ACCTEST ) != ERROR_SUCCESS )
      return GetLastError();

   if ( newDelay >= PC_MIN_POLL_DELAY && newDelay <= PC_MAX_POLL_DELAY ) {         
      m_pollDelay = newDelay * 1000;                               // convert to milliseconds
      return SetPCParm( PROCCON_DATA_POLLDELAY, newDelay );
   }
   else
      return PCERROR_INVALID_PARAMETER;
}

//--------------------------------------------------------------------------------------------//
// Functions to get or set DWORD values in the registry (parms, etc.)                         //
// Input:    name of parameter, pointer to data location                                      //
// Returns:  registry function error or success                                               //
// Note:     If a parameter cannot be retrieved or is not a REG_DWORD, it is replaced with    //
//           the supplied value as a default.                                                 //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::GetPCParm( const TCHAR *name, PCULONG32 *data ) 
{
   PCULONG32  byteType, lastLen = sizeof(PCULONG32 );
   UCHAR *addr = (UCHAR *) data;
   PCULONG32  rc = RegQueryValueEx( m_parmRegKey, name, NULL, &byteType, addr, &lastLen );
   if ( rc != ERROR_SUCCESS || byteType != REG_DWORD)
      rc = RegSetValueEx( m_parmRegKey, name, NULL, REG_DWORD, addr, sizeof(PCULONG32) );
   return rc;
}

PCULONG32  CProcConDB::SetPCParm( const TCHAR *name, PCULONG32  data ) 
{
   return RegSetValueEx( m_parmRegKey, name, NULL, REG_DWORD, (UCHAR *) &data, sizeof(PCULONG32) );
}

PCULONG32  CProcConDB::DeleteAllNameRules( void ) {
   
   if ( TestAccess( PROCCON_REG_RESTORE_ACCTEST ) != ERROR_SUCCESS )  // delete all preceeds restore
      return GetLastError();

   PCULONG32  rc;

   EnterCriticalSection( &m_dbCSNameRule );

   m_lastRegError = RegDeleteValue( m_parmRegKey, PROCCON_DATA_NAMERULES );
   if ( m_lastRegError != ERROR_SUCCESS && m_lastRegError != ERROR_FILE_NOT_FOUND ) 
      rc = RegError( TEXT("RegDeleteValue"), PROCCON_DATA_NAMERULES );
   else {
      PCLogMessage( PC_SERVICE_DEL_ALL_NAME_RULES, EVENTLOG_INFORMATION_TYPE, 0, NULL );
      rc = LoadRules( LOADFLAG_NAME_RULES );
   }

   LeaveCriticalSection( &m_dbCSNameRule );

   return rc;
}

PCULONG32  CProcConDB::DeleteAllProcDefs( void ) {

   if ( TestAccess( PROCCON_REG_RESTORE_ACCTEST ) != ERROR_SUCCESS )  // delete all preceeds restore
      return GetLastError();

   PCULONG32  rc = ERROR_SUCCESS;
   EnterCriticalSection( &m_dbCSProcRule );

   if ( m_procRegKey ) RegCloseKey( m_procRegKey );
   m_procRegKey = NULL;

   m_lastRegError = PCDeleteKeyTree( m_parmRegKey, PROCCON_REG_PROCRULES_SUBKEY );
   if ( m_lastRegError != ERROR_SUCCESS && m_lastRegError != ERROR_FILE_NOT_FOUND ) 
      rc = RegError( TEXT("RegDeleteValue"), PROCCON_REG_PROCRULES_SUBKEY );
   else {
      PCLogMessage( PC_SERVICE_DEL_ALL_PROC_RULES, EVENTLOG_INFORMATION_TYPE, 0, NULL );
      if ( !OpenProcKey() ) 
         rc = m_lastRegError;      // should not fail since worked at startup
      else 
         rc = LoadRules( LOADFLAG_PROC_RULES );
   }

   LeaveCriticalSection( &m_dbCSProcRule );
   return rc;
}

PCULONG32  CProcConDB::DeleteAllJobDefs( void ) {
   
   if ( TestAccess( PROCCON_REG_RESTORE_ACCTEST ) != ERROR_SUCCESS )  // delete all preceeds restore
      return GetLastError();

   PCULONG32  rc = ERROR_SUCCESS;
   EnterCriticalSection( &m_dbCSJobRule );

   if ( m_jobRegKey ) RegCloseKey( m_jobRegKey );
   m_jobRegKey = NULL;

   m_lastRegError = PCDeleteKeyTree( m_parmRegKey, PROCCON_REG_JOBRULES_SUBKEY );
   if ( m_lastRegError != ERROR_SUCCESS && m_lastRegError != ERROR_FILE_NOT_FOUND ) 
      rc = RegError( TEXT("RegDeleteValue"), PROCCON_REG_JOBRULES_SUBKEY );
   else {
      PCLogMessage( PC_SERVICE_DEL_ALL_JOB_RULES, EVENTLOG_INFORMATION_TYPE, 0, NULL );
      if ( !OpenJobKey() ) 
         rc = m_lastRegError;       // should not fail since worked at startup
      else
         rc = LoadRules( LOADFLAG_JOB_RULES );
   }

   LeaveCriticalSection( &m_dbCSJobRule );
   return rc;
}

//--------------------------------------------------------------------------------------------//
// Functions to get job management data in internal (non-API) format                          //
// Input:    location to store list pointer, name to locate or NULL                           //
// Returns:  count of entries                                                                 //
// Note:     if name supplied, only thet entry is located and listed, else all are listed     // 
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::GetJobMgmtDefs( PCJobDef **pList, JOB_NAME *name )
{
   EnterCriticalSection( &m_dbCSJobRule );

   PCULONG32  numRules = name? 1 : m_numJobRules;        // copy count for use outside CS

   if ( !numRules ) { // 7/28/2000 bugfix to prevent leak when no rules
      *pList = NULL;
      LeaveCriticalSection( &m_dbCSJobRule );
      return 0;
   }

   *pList = new PCJobDef[numRules];
   if ( !*pList ) {
      PCLogNoMemory( TEXT("AllocInternalJobDefs"), numRules * sizeof(PCJobDef) ); 
      LeaveCriticalSection( &m_dbCSJobRule );
      return 0;
   }
   memset( *pList, 0, numRules * sizeof(PCJobDef) );

   // copy summary data to buffer until end of data...
   PCJobDef *list = *pList;

   // If looking for a specific entry, locate it and build one entry...
   if ( name ) {
      for ( PCULONG32 i = 0; i < m_numJobRules; ++i ) {
         if ( !CompareJobName( m_jobSummary[i].jobName, name ) ) {
            SetJobDefEntry( list, m_jobSummary[i] );
            break;
         }
      }
      // If entry not found -- delete list, set 0 count...
      if ( i >= m_numJobRules ) {
         delete [] *pList;
         *pList   = NULL;
         numRules = 0;
      }
   }
   else for ( PCULONG32 i = 0; i < numRules; ++i, ++list ) {
      SetJobDefEntry( list, m_jobSummary[i] );
   }

   LeaveCriticalSection( &m_dbCSJobRule );

   if ( numRules > 1 ) qsort( *pList, numRules, sizeof(PCJobDef), CompareJobDef );

   return numRules;
}

void  CProcConDB::SetJobDefEntry( PCJobDef *list, PCJobSummary &m_jobSummary ) {
   memcpy( list->jobName, m_jobSummary.jobName, sizeof(list->jobName) ); 
   memcpy( list->profileName, m_jobSummary.mgmtParms.profileName, sizeof(list->profileName) ); 
   list->mFlags           = m_jobSummary.mgmtParms.mFlags;     
   list->affinity         = m_jobSummary.mgmtParms.affinity;     
   list->priority         = m_jobSummary.mgmtParms.priority;     
   list->minWS            = m_jobSummary.mgmtParms.minWS;     
   list->maxWS            = m_jobSummary.mgmtParms.maxWS;
   list->schedClass       = m_jobSummary.mgmtParms.schedClass;
   list->procCountLimit   = m_jobSummary.mgmtParms.procCountLimit;   
   list->procTimeLimitCNS = m_jobSummary.mgmtParms.procTimeLimitCNS; 
   list->jobTimeLimitCNS  = m_jobSummary.mgmtParms.jobTimeLimitCNS; 
   list->procMemoryLimit  = m_jobSummary.mgmtParms.procMemoryLimit; 
   list->jobMemoryLimit   = m_jobSummary.mgmtParms.jobMemoryLimit;
}
//--------------------------------------------------------------------------------------------//
// Functions to get process management data in internal (non-API) format                      //
// Input:    location to store list pointer                                                   //
// Returns:  count of entries                                                                 //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::GetProcMgmtDefs( PCProcDef **pList )
{
   EnterCriticalSection( &m_dbCSProcRule );

   PCULONG32  numRules = m_numProcRules;        // copy count for use outside CS

   if ( !numRules ) { // 7/28/2000 bugfix to prevent leak when no rules
      *pList = NULL;      
      LeaveCriticalSection( &m_dbCSProcRule );
      return 0;
   }

   *pList = new PCProcDef[numRules];
   if ( !*pList ) {
      PCLogNoMemory( TEXT("AllocInternalProcDefs"), numRules * sizeof(PCProcDef) ); 
      LeaveCriticalSection( &m_dbCSProcRule );
      return 0;
   }

   // copy summary data to buffer until end of data...
   PCProcDef *list = *pList;
   for ( PCULONG32  i = 0; i < numRules; ++i, ++list ) {
      memcpy( list->procName, m_procSummary[i].procName, sizeof(list->procName) ); 
      memcpy( list->memberOfJob, m_procSummary[i].memberOfJobName, sizeof(list->memberOfJob) ); 
      memcpy( list->profileName, m_procSummary[i].mgmtParms.profileName, sizeof(list->profileName) ); 
      list->mFlags     = m_procSummary[i].mgmtParms.mFlags;     
      list->affinity   = m_procSummary[i].mgmtParms.affinity;     
      list->priority   = m_procSummary[i].mgmtParms.priority;     
      list->minWS      = m_procSummary[i].mgmtParms.minWS;     
      list->maxWS      = m_procSummary[i].mgmtParms.maxWS;
   }

   LeaveCriticalSection( &m_dbCSProcRule );

   if ( numRules > 1 ) qsort( *pList, numRules, sizeof(PCProcDef), CompareProcDef );

   return numRules;
}

//--------------------------------------------------------------------------------------------//
// Functions to get proc summary list data in API format                                      //
// Input:    start point and target loc, max count, item len return, item count return        //
// Returns:  TRUE if more data exists, else FALSE (there are no error conditions)             //
//--------------------------------------------------------------------------------------------//
BOOL CProcConDB::GetProcSummary( const PCProcSummary *pStart,
                                       PCUINT32       listFlags,
                                       PCProcSummary *pSummary, 
                                 const PCINT32        maxCount,
                                       PCINT16       *itemLen, 
                                       PCINT16       *itemCount )
{
   EnterCriticalSection( &m_dbCSProcRule );

   *itemLen = sizeof(PCProcSummary);

   PCULONG32  numRules = m_numProcRules;        // copy count for use outside CS

   if ( listFlags & PC_LIST_MATCH_ONLY )        // if match only, set starting point to same
      listFlags |= PC_LIST_STARTING_WITH;

   // locate copy start point...
   for ( PCULONG32 i = 0; i < numRules; ++i ) {
      int cmp = CompareProcSummary( pStart, &m_procSummary[i] );
      if      ( (listFlags & PC_LIST_STARTING_WITH) && cmp <= 0 ) break;
      else if ( cmp < 0 )                                         break;
   }

   // copy data to buffer until end of data or max requested hit...
   for ( *itemCount = 0; i < numRules && *itemCount < maxCount; ++i, ++*itemCount ) {
      if ( (listFlags & PC_LIST_MATCH_ONLY) && CompareProcSummary( pStart, &m_procSummary[i] ) )
         break;
      memcpy( pSummary++, &m_procSummary[i], *itemLen ); 
}

   LeaveCriticalSection( &m_dbCSProcRule );

   return (listFlags & PC_LIST_MATCH_ONLY)? FALSE : i < numRules;
}

//--------------------------------------------------------------------------------------------//
// Functions to get job summary list data in API format                                       //
// Input:    start point and target loc, max count, item len return, item count return        //
// Returns:  TRUE if more data exists, else FALSE (there are no error conditions)             //
//--------------------------------------------------------------------------------------------//
BOOL CProcConDB::GetJobSummary( const PCJobSummary *pStart,
                                      PCUINT32      listFlags,
                                      PCJobSummary *pSummary, 
                                const PCINT32       maxCount,
                                      PCINT16      *itemLen, 
                                      PCINT16      *itemCount )
{
   EnterCriticalSection( &m_dbCSJobRule );

   *itemLen = sizeof(PCJobSummary);

   PCULONG32  numRules = m_numJobRules;        // copy count for use outside CS

   if ( listFlags & PC_LIST_MATCH_ONLY )        // if match only, set starting point to same
      listFlags |= PC_LIST_STARTING_WITH;

   // locate copy start point (first entry greater than supplied)...
   for ( PCULONG32 i = 0; i < numRules; ++i ) {
      int cmp = CompareJobSummary( pStart, &m_jobSummary[i] );
      if      ( (listFlags & PC_LIST_STARTING_WITH) && cmp <= 0 ) break;
      else if ( cmp < 0 )                                         break;
   }

   // copy data to buffer until end of data or max requested hit...
   for ( *itemCount = 0; i < numRules && *itemCount < maxCount; ++i, ++*itemCount ) {
      if ( (listFlags & PC_LIST_MATCH_ONLY) && CompareJobSummary( pStart, &m_jobSummary[i] ) )
         break;
      memcpy( pSummary++, &m_jobSummary[i], *itemLen );
   }

   LeaveCriticalSection( &m_dbCSJobRule );

   return (listFlags & PC_LIST_MATCH_ONLY)? FALSE : i < numRules;
}

//--------------------------------------------------------------------------------------------//
// Functions to get process detail data in API format                                         //
// Input:    request input and output detail buffers, data version code, update counter to set//
// Returns:  PC or NT error code or PCERROR_SUCCESS                                           //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::GetProcDetail( const PCProcDetail *pIn,
                                            PCProcDetail *pDetail,
                                      const BYTE          version,
                                            PCINT32      *updateCtr )
{
   PCULONG32  err = ERROR_SUCCESS;

   EnterCriticalSection( &m_dbCSProcRule );

   if ( updateCtr ) *updateCtr = m_updCtrProc;

   // Open the process subkey...
   HKEY  hKeyTemp;
   m_lastRegError = RegOpenKeyEx( m_procRegKey, pIn->base.procName, 0, 
                                    KEY_READ + KEY_WRITE, &hKeyTemp );
   if ( m_lastRegError != ERROR_SUCCESS )
      if ( m_lastRegError != ERROR_FILE_NOT_FOUND )
         err = RegError( TEXT("RegOpenKeyEx"), pIn->base.procName );
      else err = PCERROR_DOES_NOT_EXIST;

   if ( err == ERROR_SUCCESS ) {
      memcpy( pDetail, pIn, sizeof(*pDetail) );       // prime name fields with supplied names

      err = LoadProcSummaryItem( hKeyTemp, pDetail->base );

      if ( err == ERROR_SUCCESS )
         err = LoadVariableData( hKeyTemp, &pDetail->vLength, pDetail->vData );

      RegCloseKey( hKeyTemp );
   }

   LeaveCriticalSection( &m_dbCSProcRule );

   return err;
}

//--------------------------------------------------------------------------------------------//
// Functions to add process detail data from API format                                       //
// Input:    detail buffer, data version code                                                 //
// Returns:  PC or NT error code or PCERROR_SUCCESS                                           //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::AddProcDetail( const PCProcDetail *pDetail,
                                      const BYTE          version )
{
   EnterCriticalSection( &m_dbCSProcRule );

   // Open the process subkey...
   HKEY  hKeyTemp;
   PCULONG32  err = RegOpenKeyEx( m_procRegKey, pDetail->base.procName, 0, KEY_READ + KEY_WRITE, &hKeyTemp );
   if ( err != ERROR_FILE_NOT_FOUND ) {
      if ( err == ERROR_SUCCESS ) {
         err = PCERROR_EXISTS;
         RegCloseKey( hKeyTemp );
      }
      else {
         m_lastRegError = err;
         RegError( TEXT("RegOpenKeyEx"), pDetail->base.procName );
      }
   } else 
      err = StoreProcDetail( *pDetail );
   
   if ( !err ) 
      err = LoadRules( LOADFLAG_PROC_RULES );

   LeaveCriticalSection( &m_dbCSProcRule );

   if ( err == PCERROR_SUCCESS && m_LogRuleEdits )
      LogProcSummaryChange(&pDetail->base, version, NULL);

   return err;
}

//--------------------------------------------------------------------------------------------//
// Functions to replace process detail data in API format                                     //
// Input:    detail buffer, data version code, update counter to verify                       //
// Returns:  PC or NT error code or PCERROR_SUCCESS                                           //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::ReplProcDetail( const PCProcDetail *pDetail,
                                       const BYTE          version,
                                       const PCINT32       updateCtr )
{
   PCULONG32    err = ERROR_SUCCESS;
   PCProcSummary oldProcSummary;
   PCINT16 itemsReturned = 0;
   PCINT16 itemLen = sizeof(oldProcSummary);

   EnterCriticalSection( &m_dbCSProcRule );

   if ( updateCtr != m_updCtrProc ) err = PCERROR_UPDATE_OCCURRED;
   else {
      // Open the process subkey...
      HKEY  hKeyTemp;
      err = RegOpenKeyEx( m_procRegKey, pDetail->base.procName, 0, KEY_READ + KEY_WRITE, &hKeyTemp );
      if ( err == ERROR_SUCCESS ) {
         GetProcSummary(&pDetail->base, PC_LIST_MATCH_ONLY, &oldProcSummary, 1, &itemLen, &itemsReturned );
         err = StoreProcValues( hKeyTemp, *pDetail );
         RegCloseKey( hKeyTemp );
         if ( !err ) 
            err = LoadRules( LOADFLAG_PROC_RULES );
      } else {
         if ( err != ERROR_FILE_NOT_FOUND ) {
            m_lastRegError = err;
            RegError( TEXT("RegOpenKeyEx"), pDetail->base.procName );
         }
         else err = PCERROR_DOES_NOT_EXIST;
      }
   }

   LeaveCriticalSection( &m_dbCSProcRule );

   if ( err == PCERROR_SUCCESS && itemsReturned == 1 && m_LogRuleEdits )
      LogProcSummaryChange(&pDetail->base, version, &oldProcSummary);

   return err;
}

//--------------------------------------------------------------------------------------------//
// Functions to delete process detail data from API format                                    //
// Input:    summary portion of detail buffer, data version code                              //
// Returns:  PC or NT error code or PCERROR_SUCCESS                                           //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::DelProcDetail( const PCProcSummary *pSummary,
                                      const BYTE           version )
{
   EnterCriticalSection( &m_dbCSProcRule );

   PCULONG32  err;

   // Delete just the profile data if profile name supplied...
   if ( *pSummary->mgmtParms.profileName ) {
      HKEY hKeyTemp;
      err = RegOpenKeyEx( m_procRegKey, pSummary->procName, 0, KEY_READ + KEY_WRITE, &hKeyTemp );
      if ( err == ERROR_SUCCESS ) {
         err = RegDeleteValue( hKeyTemp, pSummary->mgmtParms.profileName );
         RegCloseKey( hKeyTemp );
      }
   }
   // Otherwise delete the entire process detail key...
   else
      err = RegDeleteKey( m_procRegKey, pSummary->procName ); 
   
   // Handle result...
   if ( err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND ) {
      m_lastRegError = err;
      RegError( TEXT("DelProcDetail"), pSummary->procName );
   }
   else if ( err == ERROR_SUCCESS )
      err = LoadRules( LOADFLAG_PROC_RULES );

   LeaveCriticalSection( &m_dbCSProcRule );

   if ( err == ERROR_SUCCESS && m_LogRuleEdits )
      PCLogMessage( PC_SERVICE_DEL_PROC_EXECUTION_RULE, EVENTLOG_INFORMATION_TYPE, 
                   1, pSummary->procName );

   return err;
}

//--------------------------------------------------------------------------------------------//
// Function to Log a replace or add change to a process execution rule                        //
// Input:    summary portion of detail buffer, data version code, orignal(old) summary        //
//           portion of detail buffer prior to the change                                     //
// Returns:  nothing                                                                          //
//--------------------------------------------------------------------------------------------//
void CProcConDB::LogProcSummaryChange( const PCProcSummary *pNewSummary,
                                       const BYTE          version,
                                       const PCProcSummary *pOldSummary )
{
   // description
   // member of job
   // affinity
   TCHAR toAffinity[32], fromAffinity[32] = { 0 };
   PCFormatAffinityLimit(toAffinity, ENTRY_COUNT(toAffinity), pNewSummary->mgmtParms);
   if ( pOldSummary )
      PCFormatAffinityLimit(fromAffinity, ENTRY_COUNT(fromAffinity), pOldSummary->mgmtParms);

   // priority 
   TCHAR toPriority[32], fromPriority[32] = { 0 };
   PCFormatPriorityLimit(toPriority, ENTRY_COUNT(toPriority), pNewSummary->mgmtParms);
   if ( pOldSummary )
      PCFormatPriorityLimit(fromPriority, ENTRY_COUNT(fromPriority), pOldSummary->mgmtParms);

   // working set 
   TCHAR toWS[64], fromWS[64];
   PCFormatWorkingSetLimit(toWS, ENTRY_COUNT(toWS), pNewSummary->mgmtParms);
   if ( pOldSummary )
      PCFormatWorkingSetLimit(fromWS, ENTRY_COUNT(fromWS), pOldSummary->mgmtParms);

   if ( !pOldSummary ) {
      const TCHAR *msgs[] = { pNewSummary->procName,
                              pNewSummary->mgmtParms.description,
                              PCIsSetToStr(pNewSummary->mgmtParms.mFlags,  PCMFLAG_APPLY_JOB_MEMBERSHIP), pNewSummary->memberOfJobName,
                              toAffinity, toPriority, toWS 
                            };
      PCLogMessage( PC_SERVICE_ADD_PROC_EXECUTION_RULE, EVENTLOG_INFORMATION_TYPE, 
                    ENTRY_COUNT(msgs), msgs );

   }
   else {

      const TCHAR *msgs[] = { pNewSummary->procName,
                              pNewSummary->mgmtParms.description, pOldSummary->mgmtParms.description,
                              PCIsSetToStr(pNewSummary->mgmtParms.mFlags,  PCMFLAG_APPLY_JOB_MEMBERSHIP), pNewSummary->memberOfJobName,
                              PCIsSetToStr(pOldSummary->mgmtParms.mFlags,  PCMFLAG_APPLY_JOB_MEMBERSHIP), pOldSummary->memberOfJobName,
                              toAffinity, fromAffinity, 
                              toPriority, fromPriority,
                              toWS, fromWS
                            };
      PCLogMessage( PC_SERVICE_REPL_PROC_EXECUTION_RULE, EVENTLOG_INFORMATION_TYPE, 
                   ENTRY_COUNT(msgs), msgs );
   }

}

//--------------------------------------------------------------------------------------------//
// Functions to get job detail data in API format                                             //
// Input:    detail buffer, data version code, update counter to set                          //
// Returns:  PC or NT error code or PCERROR_SUCCESS                                           //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::GetJobDetail( const PCJobDetail *pIn,
                                      PCJobDetail *pDetail,
                                const BYTE         version,
                                      PCINT32     *updateCtr )
{
   PCULONG32  err = ERROR_SUCCESS;

   EnterCriticalSection( &m_dbCSJobRule );

   if ( updateCtr ) *updateCtr = m_updCtrJob;

   // Open the job subkey...
   HKEY  hKeyTemp;
   m_lastRegError = RegOpenKeyEx( m_jobRegKey, pIn->base.jobName, 0, 
                                    KEY_READ + KEY_WRITE, &hKeyTemp );
   if ( m_lastRegError != ERROR_SUCCESS )
      if ( m_lastRegError != ERROR_FILE_NOT_FOUND )
         err = RegError( TEXT("RegOpenKeyEx"), pIn->base.jobName );
      else err = PCERROR_DOES_NOT_EXIST;

   if ( err == ERROR_SUCCESS ) {
      memcpy( pDetail, pIn, sizeof(*pDetail) );       // prime name fields with supplied names

      err = LoadJobSummaryItem( hKeyTemp, pDetail->base );

      if ( err == ERROR_SUCCESS )
         err = LoadVariableData( hKeyTemp, &pDetail->vLength, pDetail->vData );

      RegCloseKey( hKeyTemp );
   }

   LeaveCriticalSection( &m_dbCSJobRule );

   return err;
}

//--------------------------------------------------------------------------------------------//
// Functions to add job detail data from API format                                           //
// Input:    detail buffer, data version code                                                 //
// Returns:  PC or NT error code or PCERROR_SUCCESS                                           //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::AddJobDetail( const PCJobDetail *pDetail,
                                const BYTE         version )
{
   EnterCriticalSection( &m_dbCSJobRule );

   // Open the job subkey...
   HKEY  hKeyTemp;
   PCULONG32  err = RegOpenKeyEx( m_jobRegKey, pDetail->base.jobName, 0, KEY_READ + KEY_WRITE, &hKeyTemp );
   if ( err != ERROR_FILE_NOT_FOUND ) {
      if ( err == ERROR_SUCCESS ) {
         err = PCERROR_EXISTS;
         RegCloseKey( hKeyTemp );
      }
      else {
         m_lastRegError = err;
         RegError( TEXT("RegOpenKeyEx"), pDetail->base.jobName );
      }
   } else 
      err = StoreJobDetail( *pDetail );
   
   if ( !err ) 
      err = LoadRules( LOADFLAG_JOB_RULES );

   LeaveCriticalSection( &m_dbCSJobRule );

   if ( err == ERROR_SUCCESS && m_LogRuleEdits )
      LogJobSummaryChange(&pDetail->base, version, NULL);

   return err;
}

//--------------------------------------------------------------------------------------------//
// Functions to replace job detail data in API format                                         //
// Input:    detail buffer, data version code                                                 //
// Returns:  PC or NT error code or PCERROR_SUCCESS                                           //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::ReplJobDetail( const PCJobDetail *pDetail,
                                      const BYTE         version,
                                      const PCINT32      updateCtr )
{
   PCULONG32  err = ERROR_SUCCESS;
   PCJobSummary oldJobSummary;
   PCINT16 itemsReturned = 0;
   PCINT16 itemLen = sizeof(oldJobSummary);

   EnterCriticalSection( &m_dbCSJobRule );

   if ( updateCtr != m_updCtrJob ) err = PCERROR_UPDATE_OCCURRED;
   else {
      // Open the job subkey...
      HKEY  hKeyTemp;
      err = RegOpenKeyEx( m_jobRegKey, pDetail->base.jobName, 0, KEY_READ + KEY_WRITE, &hKeyTemp );
      if ( err == ERROR_SUCCESS ) {
         GetJobSummary(&pDetail->base, PC_LIST_MATCH_ONLY, &oldJobSummary, 1, &itemLen, &itemsReturned );
         err = StoreJobValues( hKeyTemp, *pDetail );
         RegCloseKey( hKeyTemp );
         if ( !err ) 
            err = LoadRules( LOADFLAG_JOB_RULES );
      } else {
         if ( err != ERROR_FILE_NOT_FOUND ) {
            m_lastRegError = err;
            RegError( TEXT("RegOpenKeyEx"), pDetail->base.jobName );
         }
         else err = PCERROR_DOES_NOT_EXIST;
      }
   }

   LeaveCriticalSection( &m_dbCSJobRule );

   if ( err == ERROR_SUCCESS && itemsReturned == 1 && m_LogRuleEdits )
      LogJobSummaryChange(&pDetail->base, version, &oldJobSummary);

   return err;
}
 
//--------------------------------------------------------------------------------------------//
// Functions to delete job detail data from API format                                        //
// Input:    summary portion of detail buffer, data version code                              //
// Returns:  PC or NT error code or PCERROR_SUCCESS                                           //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::DelJobDetail( const PCJobSummary *pSummary,
                                     const BYTE          version )
{
   EnterCriticalSection( &m_dbCSJobRule );

   PCULONG32  err;

   // Delete just the profile data if profile name supplied...
   if ( *pSummary->mgmtParms.profileName ) {
      HKEY hKeyTemp;
      err = RegOpenKeyEx( m_jobRegKey, pSummary->jobName, 0, KEY_READ + KEY_WRITE, &hKeyTemp );
      if ( err == ERROR_SUCCESS ) {
         err = RegDeleteValue( hKeyTemp, pSummary->mgmtParms.profileName );
         RegCloseKey( hKeyTemp );
      }
   }
   // Otherwise delete the entire job detail key...
   else
      err = RegDeleteKey( m_jobRegKey, pSummary->jobName ); 
   
   // Handle result...
   if ( err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND ) {
      m_lastRegError = err;
      RegError( TEXT("DelJobDetail"), pSummary->jobName );
   }
   else if ( err == ERROR_SUCCESS )
      err = LoadRules( LOADFLAG_JOB_RULES );

   LeaveCriticalSection( &m_dbCSJobRule );

   if ( err == ERROR_SUCCESS && m_LogRuleEdits )
      PCLogMessage( PC_SERVICE_DEL_JOB_EXECUTION_RULE, EVENTLOG_INFORMATION_TYPE, 
                   1, pSummary->jobName );

   return err;
}

//--------------------------------------------------------------------------------------------//
// Function to Log a replace or add change to a group execution rule                          //
// Input:    summary portion of detail buffer, data version code, orignal(old) summary        //
//           portion of detail buffer prior to the change                                     //
// Returns:  nothing                                                                          //
//--------------------------------------------------------------------------------------------//
void CProcConDB::LogJobSummaryChange( const PCJobSummary *pNewSummary,
                                      const BYTE          version,
                                      const PCJobSummary *pOldSummary )
{
   // description
   // affinity
   TCHAR toAffinity[32], fromAffinity[32] = { 0 };
   PCFormatAffinityLimit(toAffinity, ENTRY_COUNT(toAffinity), pNewSummary->mgmtParms);
   if ( pOldSummary )
      PCFormatAffinityLimit(fromAffinity, ENTRY_COUNT(fromAffinity), pOldSummary->mgmtParms);

   // priority 
   TCHAR toPriority[32], fromPriority[32] = { 0 };
   PCFormatPriorityLimit(toPriority, ENTRY_COUNT(toPriority), pNewSummary->mgmtParms);
   if ( pOldSummary )
      PCFormatPriorityLimit(fromPriority, ENTRY_COUNT(fromPriority), pOldSummary->mgmtParms);

   // working set 
   TCHAR toWS[64], fromWS[64] = { 0 };
   PCFormatWorkingSetLimit(toWS, ENTRY_COUNT(toWS), pNewSummary->mgmtParms);
   if ( pOldSummary )
      PCFormatWorkingSetLimit(fromWS, ENTRY_COUNT(fromWS), pOldSummary->mgmtParms);

   // scheduling class
   TCHAR toSch[32], fromSch[32] = { 0 };
   PCFormatSchedClassLimit(toSch, ENTRY_COUNT(toSch), pNewSummary->mgmtParms);
   if ( pOldSummary )
      PCFormatSchedClassLimit(fromSch, ENTRY_COUNT(fromSch), pOldSummary->mgmtParms);

   // process count
   TCHAR toProcCount[32], fromProcCount[32] = { 0 };
   PCFormatProcessCountLimit(toProcCount, ENTRY_COUNT(toProcCount), pNewSummary->mgmtParms);
   if ( pOldSummary )
      PCFormatProcessCountLimit(fromProcCount, ENTRY_COUNT(fromProcCount), pOldSummary->mgmtParms);

   // process committed memory
   TCHAR toProcMemory[32], fromProcMemory[32] = { 0 };
   PCFormatProcMemLimit(toProcMemory, ENTRY_COUNT(toProcMemory), pNewSummary->mgmtParms);
   if ( pOldSummary )
      PCFormatProcMemLimit(fromProcMemory, ENTRY_COUNT(fromProcMemory), pOldSummary->mgmtParms);

   // job committed memory
   TCHAR toJobMemory[32], fromJobMemory[32] = { 0 };
   PCFormatJobMemLimit(toJobMemory, ENTRY_COUNT(toJobMemory), pNewSummary->mgmtParms);
   if ( pOldSummary )
      PCFormatJobMemLimit(fromJobMemory, ENTRY_COUNT(fromJobMemory), pOldSummary->mgmtParms);

   // per process user time
   TCHAR toProcTime[32], fromProcTime[32] = { 0 };
   PCFormatProcTimeLimit(toProcTime, ENTRY_COUNT(toProcTime), pNewSummary->mgmtParms);
   if ( pOldSummary )
      PCFormatProcTimeLimit(fromProcTime, ENTRY_COUNT(fromProcTime), pOldSummary->mgmtParms);

   // job user time 
   TCHAR toJobTime[32], fromJobTime[32] = { 0 };
   PCFormatJobTimeLimit(toJobTime, ENTRY_COUNT(toJobTime), pNewSummary->mgmtParms);
   if ( pOldSummary )
      PCFormatJobTimeLimit(fromJobTime, ENTRY_COUNT(fromJobTime), pOldSummary->mgmtParms);

   // job user time action
   TCHAR toEndofJobTimeAction[128], fromEndofJobTimeAction[128] = { 0 };
   PCFormatEndofJobAction(toEndofJobTimeAction, ENTRY_COUNT(toEndofJobTimeAction), pNewSummary->mgmtParms);
   if ( pOldSummary )
      PCFormatEndofJobAction(fromEndofJobTimeAction, ENTRY_COUNT(fromEndofJobTimeAction), pOldSummary->mgmtParms);

   // end job when no process in job
   TCHAR toEndJobEmpty[16], fromEndJobEmpty[16] = { 0 };
   PCFormatOnOrOffLimit(toEndJobEmpty, ENTRY_COUNT(toEndJobEmpty), pNewSummary->mgmtParms, PCMFLAG_END_JOB_WHEN_EMPTY);
   if ( pOldSummary )
      PCFormatOnOrOffLimit(fromEndJobEmpty, ENTRY_COUNT(fromEndJobEmpty), pOldSummary->mgmtParms, PCMFLAG_END_JOB_WHEN_EMPTY);

   // die on unhandled exception
   TCHAR toDieUHExcept[16], fromDieUHExcept[16] = { 0 };
   PCFormatOnOrOffLimit(toDieUHExcept, ENTRY_COUNT(toDieUHExcept), pNewSummary->mgmtParms, PCMFLAG_SET_DIE_ON_UH_EXCEPTION);
   if ( pOldSummary )
      PCFormatOnOrOffLimit(fromDieUHExcept, ENTRY_COUNT(fromDieUHExcept), pOldSummary->mgmtParms, PCMFLAG_SET_DIE_ON_UH_EXCEPTION);

   // silent breakaway
   TCHAR toSilentBrkAwayAct[16], fromSilentBrkAwayAct[16] = { 0 };
   PCFormatOnOrOffLimit(toSilentBrkAwayAct, ENTRY_COUNT(toSilentBrkAwayAct), pNewSummary->mgmtParms, PCMFLAG_SET_SILENT_BREAKAWAY);
   if ( pOldSummary )
      PCFormatOnOrOffLimit(fromSilentBrkAwayAct, ENTRY_COUNT(fromSilentBrkAwayAct), pOldSummary->mgmtParms, PCMFLAG_SET_SILENT_BREAKAWAY);

   // breakaway OK
   TCHAR toBrkAwayOKAct[16], fromBrkAwayOKAct[16] = { 0 };
   PCFormatOnOrOffLimit(toBrkAwayOKAct, ENTRY_COUNT(toBrkAwayOKAct), pNewSummary->mgmtParms, PCMFLAG_SET_PROC_BREAKAWAY_OK);
   if ( pOldSummary )
      PCFormatOnOrOffLimit(fromBrkAwayOKAct, ENTRY_COUNT(fromBrkAwayOKAct), pOldSummary->mgmtParms, PCMFLAG_SET_PROC_BREAKAWAY_OK);

   if ( !pOldSummary ) {
      const TCHAR *msgs[] = { pNewSummary->jobName,
                              pNewSummary->mgmtParms.description,
                              toAffinity,
                              toPriority,
                              toWS,
                              toSch,
                              toProcCount,  
                              toProcMemory,
                              toJobMemory,
                              toProcTime,
                              toJobTime,
                              toEndofJobTimeAction,
                              toEndJobEmpty,
                              toDieUHExcept,
                              toSilentBrkAwayAct,
                              toBrkAwayOKAct
                            };
      PCLogMessage( PC_SERVICE_ADD_JOB_EXECUTION_RULE, EVENTLOG_INFORMATION_TYPE, 
                    ENTRY_COUNT(msgs), msgs );

   }
   else {

      const TCHAR *msgs[] = { pNewSummary->jobName,
                              pNewSummary->mgmtParms.description, pOldSummary->mgmtParms.description,
                              toAffinity,           fromAffinity, 
                              toPriority,           fromPriority,
                              toWS,                 fromWS,
                              toSch,                fromSch,
                              toProcCount,          fromProcCount,
                              toProcMemory,         fromProcMemory,
                              toJobMemory,          fromJobMemory,
                              toProcTime,           fromProcTime,
                              toJobTime,            fromJobTime,
                              toEndofJobTimeAction, fromEndofJobTimeAction,
                              toEndJobEmpty,        fromEndJobEmpty,
                              toDieUHExcept,        fromDieUHExcept,
                              toSilentBrkAwayAct,   fromSilentBrkAwayAct,
                              toBrkAwayOKAct,       fromBrkAwayOKAct
                            };
      PCLogMessage( PC_SERVICE_REPL_JOB_EXECUTION_RULE, EVENTLOG_INFORMATION_TYPE, 
                   ENTRY_COUNT(msgs), msgs );
   }

}


//--------------------------------------------------------------------------------------------//
// Functions to get name rules in API format                                                  //
// Input:    start point, target loc, conts, etc. -- see below                                //
// Returns:  TRUE if more data exists, else FALSE (there are no error conditions)             //
//--------------------------------------------------------------------------------------------//
BOOL CProcConDB::GetNameRules( const PCINT32     first, 
                                     PCNameRule *pRules, 
                               const PCINT32     maxCount,
                                     PCINT16    *itemLen, 
                                     PCINT16    *itemCount, 
                                     PCINT32    *updCtr )
{
   EnterCriticalSection( &m_dbCSNameRule );

   *itemLen   = sizeof(PCNameRule);
   *itemCount = 0;
   *updCtr    = m_updCtrName;

   // copy data to buffer until end of data or max requested hit
   for ( PCULONG32  i = first, numRules = m_numNameRules; 
         i < numRules && *itemCount < maxCount; 
         ++i, ++*itemCount )
      memcpy( pRules++, &m_fmtNameRules[i], *itemLen ); 

   LeaveCriticalSection( &m_dbCSNameRule );

   return i < numRules;
}

//--------------------------------------------------------------------------------------------//
// Function to add a name rule                                                                //
// Input:    new rule, data version, new index ("add before index"), update counter           //
// Returns:  PCERROR_SUCCESS if successful, error code if not                                 //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::AddNameRule( const PCNameRule *pRule, 
                                    const BYTE        version, 
                                    const PCULONG32   index, 
                                    const PCINT32     updCtr )
{
   PCINT32 APIerr = PCERROR_SUCCESS;
   PROC_NAME procName = { 0 };

   EnterCriticalSection( &m_dbCSNameRule );

   if      ( updCtr != m_updCtrName )  APIerr = PCERROR_UPDATE_OCCURRED;
   else if ( index >= m_numNameRules ) APIerr = PCERROR_INDEX_OUT_OF_RANGE;
   else {
      PCNameRule *newRules = new PCNameRule[m_numNameRules + 1];
      PCULONG32  newSize = sizeof(PCNameRule) * (m_numNameRules + 1);
      if ( !newRules ) {
         PCLogNoMemory( TEXT("AllocFmtNameRules"), newSize ); 
         APIerr = PCERROR_SERVER_INTERNAL_ERROR;      
      }
      else {
         memcpy(procName, &m_fmtNameRules[index].procName, sizeof(procName));
         memset( newRules, 0, newSize );
         for ( PCULONG32  i = 0, j = 0; i < m_numNameRules; ++i ) {
            if ( index == i ) memcpy( &newRules[j++], pRule, sizeof(newRules[0]) );
            memcpy( &newRules[j++], &m_fmtNameRules[i], sizeof(newRules[0]) );
         }
         if ( m_intNameRules ) { delete [] m_intNameRules;  m_intNameRules = NULL; }
         PCNameRule *oldRules = m_fmtNameRules;
         m_fmtNameRules = newRules;
         ++m_numNameRules;
         APIerr = NameRulesUpdated();
         if ( APIerr != ERROR_SUCCESS ) {
            m_fmtNameRules = oldRules;
            --m_numNameRules;
            delete [] newRules;
         }
         else
            delete [] oldRules;
      }
   }

   LeaveCriticalSection( &m_dbCSNameRule );

   if ( APIerr == PCERROR_SUCCESS && m_LogRuleEdits )
   {
      TCHAR indexString1[16], indexString2[16];
      TCHAR matchTypeAsString[] = { pRule->matchType, 0};
      _ultot( index,     indexString1, 10 );
      _ultot( index + 1, indexString2, 10 );
    
      const TCHAR *msgs[] = { indexString1, pRule->procName,
                              indexString2, procName,
                              pRule->description,
                              pRule->matchString, 
                              matchTypeAsString
                            };

      PCLogMessage( PC_SERVICE_ADD_ALIAS_RULE, EVENTLOG_INFORMATION_TYPE, 
                    ENTRY_COUNT(msgs), msgs);
   }

   return APIerr;
}

//--------------------------------------------------------------------------------------------//
// Function to replace a name rule                                                            //
// Input:    new rule, data version, index of rule to replace, update counter                 //
// Returns:  PCERROR_SUCCESS if successful, error code if not                                 //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::ReplNameRule( const PCNameRule *pRule, 
                                     const BYTE        version, 
                                     const PCULONG32   index, 
                                     const PCINT32     updCtr )
{
   PCINT32 APIerr = PCERROR_SUCCESS;
   PCNameRule oldRule;

   EnterCriticalSection( &m_dbCSNameRule );

   if      ( updCtr != m_updCtrName )      APIerr = PCERROR_UPDATE_OCCURRED;
   else if ( index >= m_numNameRules - 1 ) APIerr = PCERROR_INDEX_OUT_OF_RANGE;
   else {
      memcpy( &oldRule, &m_fmtNameRules[index], sizeof(oldRule) );
      memcpy( &m_fmtNameRules[index], pRule, sizeof(m_fmtNameRules[index]) );
      BuildIntNameRule( index );
      APIerr = NameRulesUpdated();
   }

   LeaveCriticalSection( &m_dbCSNameRule );

   if ( APIerr == PCERROR_SUCCESS && m_LogRuleEdits )
   {
      TCHAR indexAsString[16];
      TCHAR matchTypeAsString[] =  { pRule->matchType,   0 };
      TCHAR matchType2AsString[] = { oldRule.matchType, 0 };
      _ultot( index,     indexAsString, 10 );
    
      const TCHAR *msgs[] = { indexAsString, 
                              pRule->procName,    oldRule.procName,
                              pRule->description, oldRule.description,
                              pRule->matchString, oldRule.matchString, 
                              matchTypeAsString,  matchType2AsString, 
                            };

      PCLogMessage( PC_SERVICE_REPL_ALIAS_RULE, EVENTLOG_INFORMATION_TYPE, 
                    ENTRY_COUNT(msgs), msgs);
   }

   return APIerr;
}

//--------------------------------------------------------------------------------------------//
// Function to delete a name rule                                                             //
// Input:    index of rule to delete, update counter                                          //
// Returns:  PCERROR_SUCCESS if successful, error code if not                                 //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::DelNameRule( const PCULONG32  index, 
                                    const PCINT32    updCtr )
{
   PCINT32 APIerr = PCERROR_SUCCESS;
   PROC_NAME procName = { 0 };

   EnterCriticalSection( &m_dbCSNameRule );

   if      ( updCtr != m_updCtrName )      APIerr = PCERROR_UPDATE_OCCURRED;
   else if ( index >= m_numNameRules - 1 ) APIerr = PCERROR_INDEX_OUT_OF_RANGE;
   else {
      PCNameRule *newRules = new PCNameRule[m_numNameRules - 1];
      memcpy(procName, &m_fmtNameRules[index].procName, sizeof(procName));
      if ( !newRules ) {
         PCLogNoMemory( TEXT("AllocFmtNameRules"), sizeof(PCNameRule) * (m_numNameRules - 1) ); 
         APIerr = PCERROR_SERVER_INTERNAL_ERROR;      
      }
      else {
         for ( PCULONG32  i = 0, j = 0; i < m_numNameRules; ++i ) {
            if ( index != i ) 
               memcpy( &newRules[j++], &m_fmtNameRules[i], sizeof(m_fmtNameRules[i]) );
         }
         delete [] m_fmtNameRules;
         if ( m_intNameRules ) { delete [] m_intNameRules;  m_intNameRules = NULL; }
         m_fmtNameRules = newRules;
         --m_numNameRules;
         APIerr = NameRulesUpdated();
      }
   }

   LeaveCriticalSection( &m_dbCSNameRule );

   if ( APIerr == PCERROR_SUCCESS && m_LogRuleEdits )
      PCLogMessage( PC_SERVICE_DEL_ALIAS_RULE, EVENTLOG_INFORMATION_TYPE, 
                    1, procName );
   return APIerr;
}

//--------------------------------------------------------------------------------------------//
// Function to swap adjacent name rules                                                       //
// Input:    index of rule to swap with following rule, update counter                        //
// Returns:  PCERROR_SUCCESS if successful, error code if not                                 //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConDB::SwapNameRule( const PCULONG32  index, 
                                     const PCINT32    updCtr )
{
   PCINT32 APIerr = PCERROR_SUCCESS;
   PROC_NAME procName1 = { 0 };
   PROC_NAME procName2 = { 0 };

   EnterCriticalSection( &m_dbCSNameRule );

   if      ( updCtr != m_updCtrName )      APIerr = PCERROR_UPDATE_OCCURRED;
   else if ( index >= m_numNameRules - 2 ) APIerr = PCERROR_INDEX_OUT_OF_RANGE;
   else {
      PCNameRule rule;
      memcpy(procName1, &m_fmtNameRules[index].procName, sizeof(procName1));
      memcpy(procName2, &m_fmtNameRules[index+1].procName, sizeof(procName2));
      memcpy( &rule,                      &m_fmtNameRules[index],     sizeof(rule) );
      memcpy( &m_fmtNameRules[index],     &m_fmtNameRules[index + 1], sizeof(rule) );
      memcpy( &m_fmtNameRules[index + 1], &rule,                      sizeof(rule) );
      BuildIntNameRule( index );
      BuildIntNameRule( index + 1 );
      APIerr = NameRulesUpdated();
   }

   LeaveCriticalSection( &m_dbCSNameRule );

   if ( APIerr == PCERROR_SUCCESS && m_LogRuleEdits )
   {
      TCHAR indexString1[16], indexString2[16];
      _ultot( index,     indexString1, 10 );
      _ultot( index + 1, indexString2, 10 );
    
      const TCHAR *msgs[] = { indexString1, procName1, indexString2, procName2 };
      PCLogMessage( PC_SERVICE_SWAP_ALIAS_RULE, EVENTLOG_INFORMATION_TYPE, 
                    ENTRY_COUNT(msgs), msgs );
   }
   return APIerr;
}

//--------------------------------------------------------------------------------------------//
// Functions to get proc list data in API format                                              //
// Input:    start point and target loc, max count, item len return, item count return        //
// Returns:  TRUE if more data exists, else FALSE (there are no error conditions)             //
//--------------------------------------------------------------------------------------------//
BOOL CProcConDB::GetProcList( const PCProcListItem *pStart,
                              const PCUINT32        listFlags,
                                    PCProcListItem *pList, 
                              const PCINT32         maxCount,
                                    PCINT16        *itemLen, 
                                    PCINT16        *itemCount )
{

   *itemLen   = sizeof(PCProcListItem);
   *itemCount = 0;

   PCULONG32  procEntries = 0, nameEntries = 0, activeEntries = 0;
   PCProcListItem *procList = NULL, *nameList = NULL;

   // Get process definition rule data...
   EnterCriticalSection( &m_dbCSProcRule );

   procEntries = m_numProcRules;

   // allocate space for process definition list...
   procList = new PCProcListItem[ procEntries ];
   if ( !procList ) {
      PCLogNoMemory( TEXT("AllocProcList1"), sizeof(PCProcListItem) * procEntries ); 
      procEntries = 0;      
   }
   memset( procList, 0, sizeof(PCProcListItem) * procEntries );

   // Add names of defined processes...
   for ( PCULONG32  i = 0; i < procEntries; ++i ) {
      memcpy( procList[i].procName, m_procSummary[i].procName, sizeof(procList->procName) );
      procList[i].lFlags = PCLFLAG_IS_DEFINED;
      if ( m_procSummary[i].mgmtParms.mFlags & PCMFLAG_PROC_HAS_JOB_REFERENCE ) {
         procList[i].lFlags |= PCLFLAG_HAS_MEMBER_OF_JOB;
         memcpy( procList[i].jobName,  m_procSummary[i].memberOfJobName, sizeof(procList->jobName) );
      }
      if ( PCIsProcManaged( m_procSummary[i].mgmtParms, &m_procSummary[i].memberOfJobName ) )
         procList[i].lFlags |= PCLFLAG_IS_MANAGED;
   }

   LeaveCriticalSection( &m_dbCSProcRule );

   // Get name rule data...
   EnterCriticalSection( &m_dbCSNameRule );

   PCULONG32  names = m_numNameRules - 1;             // exclude default rule which is last

   // allocate space for name list...
   nameList = new PCProcListItem[ names ];
   if ( !nameList ) {
      PCLogNoMemory( TEXT("AllocProcList2"), sizeof(PCProcListItem) * names ); 
      names = 0;      
   }
   memset( nameList, 0, sizeof(PCProcListItem) * names );

   // Add names from name rules...
   for ( i = 0; i < names; ++i ) {
      if ( !NameHasPattern( m_fmtNameRules[i].procName ) ) {
         memcpy( nameList[nameEntries].procName, m_fmtNameRules[i].procName, sizeof(nameList->procName) );
         nameList[nameEntries++].lFlags = PCLFLAG_HAS_NAME_RULE;
      }
   }

   LeaveCriticalSection( &m_dbCSNameRule );

   // Get running process data--------------------------------------------------------
   PCProcListItem *activeList;
   activeEntries = m_cMgr->ExportActiveProcList( &activeList );

   // Build full list...
   PCULONG32  entries = procEntries + nameEntries + activeEntries;
   PCProcListItem *fullList = new PCProcListItem[ entries ];
   if ( !fullList ) {
      PCLogNoMemory( TEXT("AllocProcList3"), sizeof(PCProcListItem) * entries ); 
      entries = procEntries = nameEntries = activeEntries = 0;      
   }

   if ( procEntries )
      memcpy( fullList, procList, sizeof(PCProcListItem) * procEntries );
   if ( nameEntries )
      memcpy( fullList + procEntries, nameList, sizeof(PCProcListItem) * nameEntries );
   if ( activeEntries )
      memcpy( fullList + procEntries + nameEntries, activeList, sizeof(PCProcListItem) * activeEntries );

   delete [] procList;
   delete [] nameList;
   delete [] activeList;

   qsort( fullList, entries, *itemLen, CompareProcListItem );

   // copy data to buffer until end of data or max requested hit...
   int rc;
   PC_LIST_FLAGS lastFlags = 0;
   PCProcListItem li;                  // list item being built
   memset( &li, 0, sizeof(li) );

   for ( i = 0, *itemCount = 0; 
         i < entries && *itemCount < maxCount; 
         lastFlags = fullList[i++].lFlags ) {
      // if name changed or both have pids we have a new process...
      if ( (rc = CompareProcName( li.procName, fullList[i].procName )) || 
           (li.procStats.pid && fullList[i].procStats.pid) ) {
         // See if new name belongs in the list and, if so, wrap up last entry and start new...
         if ( ProcBelongsInList( li, pStart, listFlags ) ) {
            memcpy( pList, &li, *itemLen );
            pList->lFlags |= lastFlags;
            ++pList;
            ++*itemCount;
         }
         PC_LIST_FLAGS savedFlags = li.lFlags;
         memcpy( &li, &fullList[i], *itemLen );
         li.actualPriority = PCMapPriorityForAPI( li.actualPriority );
         if ( !rc ) li.lFlags = savedFlags;
      }
      else {
         li.lFlags |= fullList[i].lFlags;
         if ( fullList[i].lFlags & PCLFLAG_IS_RUNNING ) {
            memcpy( &li.procStats, &fullList[i].procStats, sizeof(li.procStats) );
            memcpy(  li.imageName,  fullList[i].imageName, sizeof(li.imageName) );
            memcpy(  li.jobName,    fullList[i].jobName,   sizeof(li.jobName)   );
            li.actualPriority = PCMapPriorityForAPI( fullList[i].actualPriority );
            li.actualAffinity = fullList[i].actualAffinity;
         }
         if ( fullList[i].lFlags & PCLFLAG_HAS_MEMBER_OF_JOB )
            memcpy( li.jobName, fullList[i].jobName,   sizeof(li.jobName) );
      }
   }
   if ( *itemCount < maxCount && ProcBelongsInList( li, pStart, listFlags ) ) {
      memcpy( pList, &li, *itemLen );
      pList->lFlags |= lastFlags;
      ++*itemCount;
   }

   delete [] fullList;

   return i < entries;
}

//--------------------------------------------------------------------------------------------//
// Functions to get job list data in API format                                               //
// Input:    start point and target loc, max count, item len return, item count return        //
// Returns:  TRUE if more data exists, else FALSE (there are no error conditions)             //
//--------------------------------------------------------------------------------------------//
BOOL CProcConDB::GetJobList( const PCJobListItem *pStart,
                             const PCUINT32       listFlags,
                                   PCJobListItem *pList, 
                             const PCINT32        maxCount,
                                   PCINT16       *itemLen, 
                                   PCINT16       *itemCount )
{

   *itemLen   = sizeof(PCJobListItem);
   *itemCount = 0;

   PCULONG32  jobEntries = 0, jrefEntries = 0, activeEntries = 0;
   PCJobListItem *jobList = NULL, *jrefList = NULL;

   // Get job definition rule data...
   EnterCriticalSection( &m_dbCSJobRule );

   jobEntries = m_numJobRules;

   // allocate space for job definition list...
   jobList = new PCJobListItem[ jobEntries ];
   if ( !jobList ) {
      PCLogNoMemory( TEXT("AllocJobList1"), sizeof(PCJobListItem) * jobEntries ); 
      jobEntries = 0;      
   }
   else memset( jobList, 0, sizeof(PCJobListItem) * jobEntries );

   // Add names of defined jobs...
   for ( PCULONG32  i = 0; i < jobEntries; ++i ) {
      memcpy( jobList[i].jobName, m_jobSummary[i].jobName, sizeof(jobList->jobName) );
      jobList[i].lFlags = PCLFLAG_IS_DEFINED;
      if ( PCIsJobManaged( m_jobSummary[i].mgmtParms ) )
         jobList[i].lFlags |= PCLFLAG_IS_MANAGED;
   }

   LeaveCriticalSection( &m_dbCSJobRule );

   EnterCriticalSection( &m_dbCSProcRule );

   jrefEntries = m_numProcRules;

   // allocate space for job reference list...
   jrefList = new PCJobListItem[ jrefEntries ];
   if ( !jrefList ) {
      PCLogNoMemory( TEXT("AllocJobList2"), sizeof(PCJobListItem) * jrefEntries ); 
      jrefEntries = 0;      
   }
   else memset( jrefList, 0, sizeof(PCJobListItem) * jrefEntries );

   // Add names from process definitions...
   PCULONG32  ctr = 0;
   for ( i = 0; i < jrefEntries; ++i ) {
      if ( *(m_procSummary[i].memberOfJobName) ) {
         memcpy( jrefList[ctr].jobName, m_procSummary[i].memberOfJobName, sizeof(jrefList->jobName) );
         jrefList[ctr].lFlags = PCLFLAG_HAS_MEMBER_OF_JOB;
         ++ctr;
      }
   }
   jrefEntries = ctr;

   LeaveCriticalSection( &m_dbCSProcRule );

   // Add names of running jobs...
   PCJobListItem *activeList;
   activeEntries = m_cMgr->ExportActiveJobList( &activeList );

   // Build full list...
   PCULONG32  entries = jobEntries + jrefEntries + activeEntries;
   PCJobListItem *fullList = new PCJobListItem[ entries ];
   if ( !fullList ) {
      PCLogNoMemory( TEXT("AllocJobList3"), sizeof(PCJobListItem) * entries ); 
      entries = jobEntries = jrefEntries = activeEntries = 0;      
   }
   if ( jobEntries )
      memcpy( fullList, jobList, sizeof(PCJobListItem) * jobEntries );
   if ( jrefEntries )
      memcpy( fullList + jobEntries, jrefList, sizeof(PCJobListItem) * jrefEntries );
   if ( activeEntries )
      memcpy( fullList + jobEntries + jrefEntries,  activeList, sizeof(PCJobListItem) * activeEntries );

   delete [] jobList;
   delete [] jrefList;
   delete [] activeList;

   // Sort full list...
   qsort( fullList, entries, *itemLen, CompareJobListItem );

   // copy data to buffer until end of data or max requested hit...
   PCJobListItem li;                  // list item being built
   memset( &li, 0, sizeof(li) );

   for ( i = 0, *itemCount = 0; i < entries && *itemCount < maxCount; ++i ) {
      // if name changed we have a new job...
      if ( CompareJobName( li.jobName, fullList[i].jobName ) ) {
         if ( JobBelongsInList( li, pStart, listFlags ) ) {
            memcpy( pList++, &li, *itemLen );
            ++*itemCount;
         }
         memcpy( &li, &fullList[i], *itemLen );
         li.actualPriority = PCMapPriorityForAPI( li.actualPriority );
      }
      else {
         li.lFlags |= fullList[i].lFlags;
         if ( fullList[i].lFlags & PCLFLAG_IS_RUNNING ) {
            li.actualPriority   = PCMapPriorityForAPI( fullList[i].actualPriority );
            li.actualAffinity   = fullList[i].actualAffinity;
            li.actualSchedClass = fullList[i].actualSchedClass;
            memcpy( &li.jobStats, &fullList[i].jobStats, sizeof(li.jobStats) );
         }
      }
   }
   if ( *itemCount < maxCount && *li.jobName && JobBelongsInList( li, pStart, listFlags ) ) {
      memcpy( pList, &li, *itemLen );
      ++*itemCount;
   }

   delete [] fullList;

   return i < entries;
}

//--------------------------------------------------------------------------------------------//
// Functions to assign a process name given a path+exe name                                   //
// Input:    path name, location to build proc name                                           //
// Returns:  nothing -- cannot fail due to default name rule                                  //
//--------------------------------------------------------------------------------------------//
void CProcConDB::AssignProcName( const TCHAR *path, PROC_NAME *name, IMAGE_NAME *iName ) {

   // First parse path name into nodes and exe name...
   TCHAR  pCopy[MAX_PATH];
   TCHAR *nodes[MAX_PATH / 2], *p = pCopy;
   _tcscpy( pCopy, path );

   if ( *(p + 1) == TEXT('?') )                         // skip if we have a \??\ prefix
      p += 4;

   // jump over leading drive letter or computer and share (UNC) name...
   if ( *(p + 1) == TEXT(':') )
      p += 2;
   else if ( *(p + 1) == TEXT('\\') ) {
      p = _tcschr( p + 2, TEXT('\\') );                 // scan for end of computer name
      if ( p ) p = _tcschr( p + 1, TEXT('\\') );        // scan for end of share name
      if ( p ) ++p;                                     // advance to first of path name
   }

   if ( p && *p == TEXT('\\') ) ++p;                    // skip \ if we start at root

   // locate and save start of each node, setting '\' to null to get szstrings...
   for ( PCULONG32  nodeCt = 0; p && nodeCt < ENTRY_COUNT(nodes); ++nodeCt ) {
      nodes[nodeCt] = p;
      p = _tcschr( p, TEXT('\\') );
      if ( p ) *p++ = 0;
   }
   if ( !nodeCt ) {                                      // should not occur
      _tcscpy( (TCHAR *) name,  TEXT("<err>") );
      _tcscpy( (TCHAR *) iName, TEXT("<err>") );
      return;
   }

   // set exe name pointer and extension location...
   TCHAR *exeName = nodes[--nodeCt];
   _tcsncpy( (TCHAR *) iName, exeName, IMAGE_NAME_LEN );
   const int extStart = ExtStartLoc( exeName );

   // Gain control over rules and build internal version if needed...
   EnterCriticalSection( &m_dbCSNameRule );

   if ( !m_intNameRules && !BuildIntNameRules() ) {
      LeaveCriticalSection( &m_dbCSNameRule );
      return;
   }

   // scan rules until we have a match...
   for ( PCULONG32  i = 0, done = FALSE; !done && i < m_numNameRules; ++i ) {
      switch ( m_intNameRules[i].mType ) {
      case MATCH_PGM:
         if ( !(m_intNameRules[i].mFlags & MFLAG_HAS_EXTENSION) && extStart )
            exeName[extStart] = 0;
         if ( NameMatch( TRUE, m_intNameRules[i].mFlags & MFLAG_HAS_WILDCARD, 
                         m_intNameRules[i].mString, (const TCHAR **) &exeName ) ) {
            NameSet( name,
                     m_intNameRules[i].mFlags & MFLAG_HAS_NAME_PATTERN,
                     m_intNameRules[i].mName, exeName );
            done = TRUE;
         }
         if ( !(m_intNameRules[i].mFlags & MFLAG_HAS_EXTENSION) && extStart )
            exeName[extStart] = TEXT('.');
         break;
      case MATCH_DIR: {
         PCULONG32  matchNode;
         if ( NameMatch( TRUE, m_intNameRules[i].mFlags & MFLAG_HAS_WILDCARD, 
                         m_intNameRules[i].mString, (const TCHAR **) nodes, nodeCt, &matchNode ) ) {
            NameSet( name,
                     m_intNameRules[i].mFlags & MFLAG_HAS_NAME_PATTERN,
                     m_intNameRules[i].mName, exeName, nodes[matchNode] );
            done = TRUE;
         }
         break;
      }
      case MATCH_ANY:
         if ( NameMatch( FALSE, m_intNameRules[i].mFlags & MFLAG_HAS_WILDCARD, 
                         m_intNameRules[i].mString, &path ) ) {
            NameSet( name, 
                     m_intNameRules[i].mFlags & MFLAG_HAS_NAME_PATTERN, 
                     m_intNameRules[i].mName, exeName );
            done = TRUE;
         }
         break;
      }  // end switch
   }  // end for

   LeaveCriticalSection( &m_dbCSNameRule );

   if ( !done )                                       // should not occur
      _tcscpy( (TCHAR *) name, TEXT("<err>") );
}

BOOL CProcConDB::NameMatch( const BOOL        compare,       // TRUE for compare operation, FALSE for scan
                            const BOOL        hasWildcard,   // string contains wildcard character(s)
                            const TCHAR      *str,           // string to match against
                            const TCHAR     **arg,           // path name argument(s)
                            const PCULONG32   argCt,         // number of arguments
                                  PCULONG32  *mIdx ) {       // where to store matching arg index or NULL
   BOOL good = FALSE;

   // Compare against every match argument supplied...
   for ( PCULONG32  i = 0; !good && i < argCt; ++i, ++arg ) {
      // for wildcard compares scan character by character...
      if ( hasWildcard ) {
         good = TRUE;
         for ( const TCHAR *p = str, *a = *arg; good && *p && *p != TEXT('*'); ++p, ++a )
            good = (*a && *p == TEXT('?')) || _totupper( *p ) == _totupper( *a );
      }
      // for non-wildcard compares just do straight compare or scan...
      else
         good = (  compare && !_tcsicmp( *arg, str )  ) ||
                ( !compare &&  PCiStrStr( *arg, str ) ); 
   }

   if ( good && mIdx ) *mIdx = i -1;

   return good;
}

void CProcConDB::NameSet(       PROC_NAME *name,        // where to put name
                          const BOOL       isPattern,   // string contains <x> pattern(s)
                          const TCHAR     *pattern,     // where to get name
                          const TCHAR     *patArgP,     // where to get pgm pattern substitution
                          const TCHAR     *patArgN ) {  // where to get node pattern substitution or NULL

   memset( name, 0, sizeof(*name) );

   if ( !isPattern )
      _tcsncpy( (TCHAR *) name, pattern, ENTRY_COUNT(*name) - 1 );
   else {
      TCHAR out[MAX_PATH * 2];
      memset( out, 0, sizeof(out) );
      TCHAR *outp = out;
      for ( PCULONG32  i = 0; *pattern; ++i ) {
         if ( !_tcsnicmp( pattern, NAME_IS_PGM, 3 ) )
         {
            _tcscpy( outp, patArgP );
            outp    += _tcslen( patArgP );
            pattern += 3;
         }
         else if ( !_tcsnicmp( pattern, HIDE_PROC_PATTERN, 3 ) )
         {
            *name[0] = 0;
            return;
         }
         else if ( patArgN && !_tcsnicmp( pattern, NAME_IS_DIR, 3 ) ) 
            {
               _tcscpy( outp, patArgN );
               outp    += _tcslen( patArgN );
               pattern += 3;
            }
         else
            *outp++ = *pattern++;
      }
      _tcsncpy( (TCHAR *) name, out, ENTRY_COUNT(*name) - 1 );
   }
}

int CProcConDB::ExtStartLoc( const TCHAR *name ) {  // Find start of name extension or 0
   int len = _tcslen( name );
   for ( int i = len - 1; i > 0 && i > len - 4; --i )
      if ( name[i] == TEXT('.') ) break;
   return ( i > 0 && name[i] == TEXT('.') )? i : 0;
}

//--------------------------------------------------------------------------------------------//
// Functions to build internal format name rules based on API format name rules               //
// Input:    nothing -- operates on member data                                               //
// Returns:  TRUE if successful, else FALSE                                                   //
// Note:     caller must hold the name rule critical section                                  //
//--------------------------------------------------------------------------------------------//
BOOL CProcConDB::BuildIntNameRules( void ) {

   if ( m_intNameRules ) delete [] m_intNameRules;
   m_intNameRules = new PCNameRuleInt[m_numNameRules];

   if ( !m_intNameRules ) {
      PCLogNoMemory( TEXT("AllocIntNameRules"), m_numNameRules * sizeof(PCNameRuleInt) ); 
      return FALSE;
   }

   for ( PCULONG32  i = 0; i < m_numNameRules; ++i ) 
      BuildIntNameRule( i );

   return TRUE;
}

void CProcConDB::BuildIntNameRule( PCULONG32  index ) {

   if ( !m_intNameRules || index >= m_numNameRules ) 
      return;

   PCNameRuleInt &iRule = m_intNameRules[index];
   PCNameRule    &fRule = m_fmtNameRules[index];
   memset( &iRule, 0, sizeof(iRule) );

   // Copy match type...
   iRule.mType = fRule.matchType;

   // Copy/expand match string...
   ExpandEnvironmentStrings( fRule.matchString, iRule.mString, ENTRY_COUNT(iRule.mString) );

   // Flag if match string contains wildcards * or ?...
   if ( _tcschr( iRule.mString, TEXT('*') ) || _tcschr( iRule.mString, TEXT('?') ) )
      iRule.mFlags |= MFLAG_HAS_WILDCARD;
   
   // Flag if match string contains extension...
   if ( ExtStartLoc( iRule.mString ) ) 
      iRule.mFlags |= MFLAG_HAS_EXTENSION;

   // Copy name and flag if name contains pattern (assume pattern if '<' present)...
   memcpy( iRule.mName, fRule.procName, sizeof(iRule.mName) );
   if ( NameHasPattern( iRule.mName ) ) 
      iRule.mFlags |= MFLAG_HAS_NAME_PATTERN;
   
   // Copy description...
   memcpy( iRule.mDesc, fRule.description, sizeof(iRule.mDesc) );
}

//--------------------------------------------------------------------------------------------//
// Function to test users right to perform an action                                          //
// Input:    action name ptr                                                                  //
// Returns:  ERROR_SUCCESS if access is allowed, else an error code                           //
// Note:     access tests are implemented as READ tests against a registry key in PARAMETERS. //
//           Also, any failure is reported as access denied in the spirit of reporting little //
//           information in case of security failures.                                        //
//--------------------------------------------------------------------------------------------//
INT32 CProcConDB::TestAccess( const TCHAR *key ) {
   HKEY outKey;

   DWORD err = RegOpenKeyEx( m_parmRegKey, key, NULL, KEY_QUERY_VALUE, &outKey );
   if ( err == ERROR_SUCCESS ) RegCloseKey( outKey );
   else {
      err = ERROR_ACCESS_DENIED;          // always use access denied to report failure
      SetLastError( err );
   }

   return err;
}

// End of CProcConDB.cpp
//============================================================================J McDonald fecit====//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\service\cprocconuser.cpp ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998, 1999  Sequent Computer Systems, Incorporated                       //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|---------------------------------------------------------------------------------------//            
|   This file implements the CProcConUser class methods defined in ProcConSvc.h         //
|---------------------------------------------------------------------------------------//            
|                                                                                       //
|Created:                                                                               //
|                                                                                       //
|   Jarl McDonald 07-98                                                                 //
|                                                                                       //
|Revision History:                                                                      //
|                                                                                       //
|=======================================================================================*/
#include "ProcConSvc.h"

const TCHAR *CProcConUser::PIPENAME = TEXT("\\\\.\\pipe\\ProcConPip"); 

// Constructor
// Note: this function runs as part of service start so keep it quick!
CProcConUser::CProcConUser( PCContext *ctxt ) : 
                                        m_cPC( *ctxt->cPC ),     m_cDB( *ctxt->cDB ),
                                        m_inBufChars( 4096 ),    m_outBufChars( 65536 ),
                                        m_clientTimeout( 5000 ), m_clientCount( 0 )
{
   PCBuildAdminSecAttr( m_secAttr );

   m_hConnEvent  = CreateEvent( NULL, TRUE, FALSE, NULL );
   if ( !m_hConnEvent ) 
      PCLogUnExError( TEXT("PCClientConn"), TEXT("CreateEvent") );

   m_olConn.hEvent = m_hConnEvent;
}

// Destructor
CProcConUser::~CProcConUser( void ) 
{
   PCFreeSecAttr( m_secAttr );
   if ( m_hConnEvent ) CloseHandle( m_hConnEvent ); 
}

//--------------------------------------------------------------------------------------------//
// Function to determine if all CProcConUser initial conditions have been met                 //
// Input:    None                                                                             //
// Returns:  TRUE if ready, FALSE if not                                                      //
//--------------------------------------------------------------------------------------------//
BOOL CProcConUser::ReadyToRun( void ) 
{
   return m_hConnEvent != NULL && m_secAttr.lpSecurityDescriptor && !m_cPC.GotShutdown();
}

//--------------------------------------------------------------------------------------------//
// Function to set a new timeout                                                              //
// Input:   proposed new timeout                                                              //
// Returns: NT or PC error code                                                               //
// Note:    lower and upper limits on timeout are a bit arbitrary (.1 secs to 30 secs OK)     //
//          This timeout only applies to the pipe connection timeout at clients, not to       //
//          transaction timeouts (which are handled by the client alone).                     //
//--------------------------------------------------------------------------------------------//
PCULONG32  CProcConUser::SetTimeout( PCULONG32  newTimeout )
{
   if ( newTimeout >= PC_MIN_TIMEOUT && newTimeout <= PC_MAX_TIMEOUT ) {         
      m_clientTimeout = newTimeout;                               
      return ERROR_SUCCESS;
   }
   else
      return PCERROR_INVALID_PARAMETER;
}

//--------------------------------------------------------------------------------------------//
// CProcConUser thread function -- this function runs in its own thread and simply offers the //
//           PC named pipe to the world.  Each pipe connection causes a client thread with    //
//           its own context to be launched and then a new pipe 'port' is created.            //
// Input:    None                                                                             //
// Returns:  0                                                                                //
//--------------------------------------------------------------------------------------------//
PCULONG32 CProcConUser::Run( void )                          
{

   // Wait for DB initialization to complete before establishing user service environment.
   // If this isn't the first call here, the delay serves to provide some pacing.
   WaitForSingleObject( m_cDB.GetDbEvent(), 1000 );
 
   HANDLE waitList[]      = { m_olConn.hEvent, m_cPC.GetShutEvent() };
   HANDLE hThread         = NULL;
   ClientContext *context = NULL;

   // User connect thread main loop -- handles all user connections to ProcCon.
   // There is only one user connect thread.
   // This loop runs until shutdown is signalled or until a bad NT error occurs.
   for ( ; !m_cPC.GotShutdown(); ++m_clientCount ) { 

      // Create a new client context..
      context = new ClientContext( m_clientCount, &m_cPC, &m_cDB, this, m_inBufChars, m_outBufChars );
      if ( !context ) {
         PCLogNoMemory( TEXT("ClientContext"), sizeof(ClientContext) );
         break;
      }

      // Create a pipe instance...
      context->hPipe = CreateNamedPipe( PIPENAME,  
           PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,               // read/write access, overlapped enabled 
           PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,   // message-based, blocking 
           PIPE_UNLIMITED_INSTANCES,                                // no limit  
           m_outBufChars,                                           // output buffer size 
           m_inBufChars,                                            // input buffer size 
           m_clientTimeout,                                         // client side time-out 
           &m_secAttr );                                            // our security attr -- built in constructor 
      if ( context->hPipe == INVALID_HANDLE_VALUE ) {
         PCLogUnExError( TEXT("PCClientConn"), TEXT("CreatePipe") );
         context->hPipe = NULL;
         break;
      }
 
      // Initiate pipe connect (but don't wait for a connection)... 
      DWORD connError = 0;
      BOOL launchClient = FALSE;
      ResetEvent( m_olConn.hEvent );
      if ( !ConnectNamedPipe( context->hPipe, &m_olConn ) )
         connError = GetLastError();
      
      // If we have a suspended client from our last connect, release it before waiting on a new connection...
      if ( hThread ) {
         if ( ResumeThread( hThread ) == 0xffffffff )
            PCLogUnExError( TEXT("PCClientConn"), TEXT("ResumeThread1") );
         CloseHandle( hThread );
         hThread = NULL;
      }

      // Analyze result of connect. If necessary, wait for a client or a shutdown request...
      if ( !connError || connError == ERROR_PIPE_CONNECTED ) 
         launchClient = TRUE;
      else if ( connError == ERROR_IO_PENDING ) { 
         PCULONG32 rc = WaitForMultipleObjects( ENTRY_COUNT(waitList), waitList, FALSE, INFINITE );

         // If we got a client, create a thread for it...
         if ( rc - WAIT_OBJECT_0 == 0 ) {
            PCULONG32 bytes;
            if ( !GetOverlappedResult( context->hPipe, &m_olConn, &bytes, TRUE ) ) {
               PCLogUnExError( TEXT("PCClientConn"), TEXT("ConnectPipeResult") );
               break;
            }
            else launchClient = TRUE;
         }
         // If we got a shutdown request, just break out...
         else if ( rc - WAIT_OBJECT_0 == 1 )
            break;
         else {
            PCLogUnExError( TEXT("PCClientConn"), TEXT("WaitOnPipeOrShutdown") );
            break;   
         }
      }
      else {
         PCLogUnExError( TEXT("PCClientConn"), TEXT("ConnectPipe") );
         break;
      }

      // If we have a good connection, start a suspended client thread.
      // The thread will be released after we have a new pipe instance ready to go. 
      // This minimizes the interval during which a pipe instance is not available.
      if ( launchClient ) {
         hThread = CreateThread( NULL, 0, PCClientThread, context, CREATE_SUSPENDED, NULL ); 
         if ( !hThread ) {
            PCLogUnExError( TEXT("PCClientConn"), TEXT("CreateThread") );
            break;
         }
         context = NULL;                // Client thread deletes its context, we're done with it
      }
      
   }
   
   // Clean up if we have a context that has not been passed to a client thread...
   if ( context ) {
      if ( context->hPipe ) {
         CancelIo( context->hPipe );
         CloseHandle( context->hPipe );
      }
      delete context;
   }

   // If we have a suspended client, release it before leaving...
   if ( hThread ) {
      if ( ResumeThread( hThread ) == 0xffffffff )
         PCLogUnExError( TEXT("PCClientConn"), TEXT("ResumeThread2") );
      CloseHandle( hThread );
   }

   // Note: if this return is not due to a shutdwon request, this function will be called again.
   // This 'pipe restart' is the last line of recovery in case of serious pipe (or other) errors.
   return 0;
}

// End of CProcConUser.cpp
//============================================================================J McDonald fecit====//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\service\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ProcConService.rc
//
#define IDS_PATCHED                     100
#define IDS_DEBUG                       101
#define IDS_BETA                        102
#define IDI_SERVICE                     102
#define IDS_SERVICE_DISP_NAME           103
#define IDS_MEDIATOR_DISP_NAME          104
#define IDS_SERVICE_DESCRIPTION         105
#define IDS_UNKNOWN_PROCESS             106
#define IDS_DEFAULT_NAMERULE            107
#define IDS_FLAG_ON                     108
#define IDS_FLAG_OFF                    109
#define IDS_SYSTEM_IDLE                 110
#define IDS_SYSTEM_PROCESS              111
#define IDS_SERVICE_USAGE               112
#define IDS_UNABLE_TO_INSTALL           113
#define IDS_SERVICE_INSTALLED           114
#define IDS_REGISTRY_OPEN_FAILED        115
#define IDS_ADD_VALUE_SERVICE_DESC_FAILED 116
#define IDS_APP_KEY_OPEN_FAILED         117
#define IDS_APP_KEY_CREATED             118
#define IDS_APP_KEY_ADD_FAILED          119
#define IDS_REG_KEY_CREATE_FAILED       120
#define IDS_EVENTLOG_REG_SETUP_FAILED   121
#define IDS_EVENTLOG_REG_SETUP          122
#define IDS_PARAM_KEY_CREATE_FAILED     123
#define IDS_PARAM_DATA_UPDATE_FAILED    124
#define IDS_PARAM_DATA_CREATED          125
#define IDS_CREATESERVICE_FAILED        126
#define IDS_OPENSCMGR_FAILED            127
#define IDS_STOPPING                    128
#define IDS_DOT                         129
#define IDS_STOPPED                     130
#define IDS_FAILED_TO_STOP              131
#define IDS_REG_ENTRIES_REMOVED         132
#define IDS_DELETE_SVC_FAILED           133
#define IDS_OPEN_SVC_FAILED             134
#define IDS_APP_REG_ENTRY_DELETED       135
#define IDS_APP_REG_ENTRY_DEL_FAILED    136
#define IDS_EVTLOG_REG_DELETED          137
#define IDS_EVTLOG_REG_DEL_FAILED       138
#define IDS_REG_TREE_DEL_FAILED         139

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\about.cpp ===
/*======================================================================================//
|  Windows NT Process Control                                                           //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    About.cpp                                                                //
|                                                                                       //
|Description:  Implementation of ISnapinAbout Interface for ProcCon                     //
|                                                                                       //
|Created:      Paul Skoglund 09-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/


#include "StdAfx.h"
#include "ProcCon.h"
#include "About.h"


#define MAX_STR_RESOURCE_LEN    (256)
#define MAX_STR_RESOURCE_SIZE  (sizeof(TCHAR) * MAX_STR_RESOURCE_LEN)


CAbout::CAbout() : VersionObj(_Module.GetModuleInstance())
{
  ATLTRACE( _T("CAbout::CAbout()\n") );
}


CAbout::~CAbout()
{
  ATLTRACE( _T("CAbout::~CAbout()\n") );
}

HRESULT CAbout::WrapLoadString(LPOLESTR *ptr, int nID)
{
  *ptr = reinterpret_cast<LPOLESTR> (CoTaskMemAlloc(MAX_STR_RESOURCE_SIZE));
  if (!*ptr)
    return E_FAIL;

  if (LoadString(_Module.GetResourceInstance(), nID, *ptr, MAX_STR_RESOURCE_LEN))
    return S_OK;

  CoTaskMemFree(*ptr);
  *ptr = NULL;
  
  return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
//  ISnapinAbout Implementation:
//
STDMETHODIMP CAbout::GetSnapinDescription (LPOLESTR* lpDescription)
{
  ATLTRACE( _T("CAbout::GetSnapinDescription()\n") );
	return WrapLoadString(lpDescription, IDS_DESCRIPTION);
}

STDMETHODIMP CAbout::GetProvider(LPOLESTR* lpName)
{
  ATLTRACE( _T("CAbout::GetProvider()\n") );

  int len = (_tcslen(VersionObj.strGetCompanyName()) + 1 ) * sizeof(TCHAR);

  *lpName = reinterpret_cast<LPOLESTR> (CoTaskMemAlloc(len));
  if (!*lpName)
    return E_FAIL;

  _tcscpy(*lpName, VersionObj.strGetCompanyName());

  return S_OK;
}

STDMETHODIMP CAbout::GetSnapinVersion(LPOLESTR* lpVersion)
{
  ATLTRACE( _T("CAbout::GetSnapinVersion()\n") );

  int len = (_tcslen(VersionObj.GetFileVersion()) + 1 ) * sizeof(TCHAR);

  len += _tcslen(VersionObj.GetFileFlags()) * sizeof(TCHAR);

  *lpVersion = reinterpret_cast<LPOLESTR> (CoTaskMemAlloc(len));
  if (!*lpVersion)
    return E_FAIL;

  _tcscpy(*lpVersion, VersionObj.GetFileVersion());
  _tcscat(*lpVersion, VersionObj.GetFileFlags());

  return S_OK;
}

STDMETHODIMP CAbout::GetSnapinImage(HICON* hAppIcon)
{ 
  ATLTRACE( _T("CAbout::GetSnapinImage()\n") );

  ASSERT(hAppIcon);
  *hAppIcon = LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_PROCCON));
  ASSERT( *hAppIcon );
  return *hAppIcon ? S_OK : E_FAIL;
}

STDMETHODIMP CAbout::GetStaticFolderImage
(
  HBITMAP* hSmallImage, 
  HBITMAP* hSmallImageOpen, 
  HBITMAP* hLargeImage, 
  COLORREF* cLargeMask
)
{
  ATLTRACE( _T("CAbout::GetStaticFolderImage()\n") );

	if (!hSmallImage || !hSmallImageOpen || !hLargeImage || !cLargeMask)
		return S_FALSE;

	*hSmallImage     = (HBITMAP) ::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_NODES_16x16), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR );
	ASSERT(hSmallImage);

	*hSmallImageOpen = (HBITMAP) ::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_NODES_16x16), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR );
	ASSERT(hSmallImageOpen);

	*hLargeImage     = (HBITMAP) ::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_NODES_32x32), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR );
	ASSERT(hLargeImage);

	*cLargeMask = RGB(255,0, 255);

  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\about.h ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    About.h                                                                  //
|                                                                                       //
|Description:  Class definition for CAbout; for ISnapinAbout interface implementation   //
|                                                                                       //
|Created:      Paul Skoglund 09-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|  09-10-1998  Moved ISnapinAbout interface implemenation to separate class             //
|                                                                                       //
|=======================================================================================*/


#ifndef __ABOUT_H_
#define __ABOUT_H_

#include "Resource.h"       // main symbols
#include "Globals.h"
#include "version.h"


class ATL_NO_VTABLE CAbout : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAbout, &CLSID_About>,
  public ISnapinAbout
{
  public:
    CAbout();
    ~CAbout();

    // Note: we can't use DECLARE_REGISTRY_RESOURCEID(IDR_PROCCON)
    // because we need to be able to localize some of the strings we
    // write into the registry.
    static HRESULT STDMETHODCALLTYPE UpdateRegistry(BOOL bRegister) {
        return UpdateRegistryHelper(IDR_PROCCON, bRegister);
    }

DECLARE_NOT_AGGREGATABLE(CAbout)

BEGIN_COM_MAP(CAbout)
  COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()

  private:
    HRESULT WrapLoadString(LPOLESTR *ptr, int nID);
    CVersion VersionObj;


  // ISnapinAbout
  public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR* lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR* lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR* lpVersion);
    STDMETHOD(GetSnapinImage)(HICON* hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP* hSmallImage, 
                                    HBITMAP* hSmallImageOpen, 
                                    HBITMAP* hLargeImage, 
                                    COLORREF* cLargeMask);
};

#endif //__ABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\service\procconmain.cpp ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998, 1999 Sequent Computer Systems, Incorporated.  All rights reserved. //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|---------------------------------------------------------------------------------------//            
;    This file contains main(), ServiceMain(), and Service Start, Stop, and Control.    //
|---------------------------------------------------------------------------------------//            
|                                                                                       //
|Created:                                                                               //
|                                                                                       //
|   Jarl McDonald 07-98                                                                 //
|                                                                                       //
|Revision History:                                                                      //
|                                                                                       //
|=======================================================================================*/
#include "ProcConSvc.h"
#include <shellapi.h>             

//--------------------------------------------------------------------------------//
// Globals                                                                        //
//--------------------------------------------------------------------------------//
BOOL                  svcStop    = FALSE;                // shows if stop has been issued
BOOL                  notService = FALSE;                // TRUE if we're running as a console app
SERVICE_STATUS_HANDLE ssHandle;                          // service control handler
SERVICE_STATUS        ssStatus;                          // current service status
PCULONG32             ssErrCode  = 0;                    // error code for status reporting

CProcCon             *cPCptr     = NULL;                 // Pointer to give service rtns access

static void
Usage( void )
{
    DWORD numWritten;
    DWORD numToWrite;
    HANDLE StdOut;
       
    StdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    numToWrite = _tcslen(PROCCON_SERVICE_USAGE);
    if (! WriteConsole(StdOut,
                       PROCCON_SERVICE_USAGE,
                       numToWrite,
                       &numWritten,
                       0)) {
        WriteFile(StdOut,
                  PROCCON_SERVICE_USAGE,
                  numToWrite * sizeof(TCHAR),
                  &numWritten,
                  NULL);
    }
}

//=======================================================================================//
// main function -- initiate requested action: install, remove, run as console app, run as service
//
// Input:   none -- args retrieved via GetCommandLine   
// Returns: no return value
//
void _cdecl main( void )
{
   // Load our strings so we have proper reporting, etc.
   PCLoadStrings();

   int    argc;
   TCHAR *cmdLine = GetCommandLineW();
   TCHAR **argv   = CommandLineToArgvW( cmdLine, &argc );
   if (!argv) {
       Usage();
       return;
   }

   // See if a command line command was given -- only true if a switch (- or /)...
   if ( argc > 1 && (argv[1][0] == '-' || argv[1][0] == '/') ) {
      if      ( !_tcsicmp( TEXT("install"),   argv[1] + 1 ) ) PCInstallService( argc - 2, &argv[2] );
      else if ( !_tcsicmp( TEXT("remove"),    argv[1] + 1 ) ) PCRemoveService( argc - 2, &argv[2] );
      else if ( !_tcsicmp( TEXT("reinstall"), argv[1] + 1 ) ) {
         PCRemoveService(  argc - 2, &argv[2] );
         PCInstallService( argc - 2, &argv[2] );
      }
#ifdef _DEBUG
      else if ( !_tcsicmp( TEXT("noservice"), argv[1] + 1 ) ) PCConsoleService( argc - 2, &argv[2] );
#endif
      else Usage();

      return;
   }

   // No command line -- we are to run as a service...
   
   // Then kick things off...
   static SERVICE_TABLE_ENTRY dispTbl[] = {
      { const_cast <TCHAR *> (PROCCON_SVC_NAME), (LPSERVICE_MAIN_FUNCTION) PCServiceMain },
      { NULL,                                    NULL                                    }
   };

   if ( !StartServiceCtrlDispatcher( dispTbl ) ) {
      ssErrCode = GetLastError();
      PCLogMessage( PC_SERVICE_DISPATCH_ERROR, EVENTLOG_ERROR_TYPE, 1, PROCCON_SVC_DISP_NAME, 
                    sizeof(ssErrCode), &ssErrCode );
   }
}

//=======================================================================================//
// PCServiceMain -- our main service routine -- will start processing
//
// Input:   argc, argv (now as PCULONG32 and TCHAR).  
// Returns: no return value
//
void WINAPI PCServiceMain( PCULONG32 Argc, LPTSTR *Argv ) {

   // register our service control handler...
   ssHandle = RegisterServiceCtrlHandler( PROCCON_SVC_NAME, PCServiceControl );

   if ( ssHandle ) {
      // Initialize fixed-value status members...
      ssStatus.dwServiceType             = SERVICE_WIN32_OWN_PROCESS;
      ssStatus.dwServiceSpecificExitCode = 0;

      // request handling of alignment errors.  We know we have som issues on IA64 machines.
      SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT);

      // report status to the service control manager and start service...
      if ( PCReportStatus( SERVICE_START_PENDING, NO_ERROR, 3000) )
         PCStartService( Argc, Argv );

      if ( svcStop )
         PCLogMessage( PC_SERVICE_STOPPED, EVENTLOG_INFORMATION_TYPE, 1, PROCCON_SVC_DISP_NAME );

      // report stopped status to the service control manager...
      PCReportStatus( SERVICE_STOPPED, ssErrCode, 0 );
   }

   return;
}

//=======================================================================================//
// The Process Management app start point
//
// Input:   argc, argv (now as PCULONG32 and TCHAR, both ignored) 
// Returns: no return value
//
void PCStartService( PCULONG32 Argc, LPTSTR *Argv ) {

   // See that we are running under Windows 2000 Datacenter Server only...
#if !defined(_DEBUG) && !defined(IBM_NUMAQ_PC)
   if ( !PCTestOSVersion() ) {
      PCLogMessage( PC_SERVICE_UNSUPPORTED_WINDOWS_VERSION, EVENTLOG_ERROR_TYPE, 1, PROCCON_SVC_DISP_NAME );
      //ssErrCode = ERROR_BAD_ENVIRONMENT;  // have to use an NT error to get SCM to put it in the event log nicely
      return;
   }
#endif

   // Make sure we are not already running and set up mutual exclusion...
   // If the process is started twice in service mode the 
   // SCM will enforce the single instance rule but we could be burned 
   // by a debug version.
   // It appears to take the system longer to clean up the orphaned event
   // then it take SCM to realize the service crashed, is not running, and
   // can be started again.
   // If we exit we don't report status to SCM and that's not good.
   if (!PCSetIsRunning( PROCCON_SVC_EXCLUSION, PROCCON_SVC_DISP_NAME )) {
     // ssErrCode = ERROR_ALREADY_EXISTS; // have to use an NT error to get SCM to put it in the event log nicely
     return;
   }

   //
   // Instantiate ourselves and test for success...
   //
   CProcCon cPC;
   if ( !cPC.ReadyToRun() ) {
      PCLogMessage( PC_STARTUP_FAILED, EVENTLOG_ERROR_TYPE, 1, PROCCON_SVC_DISP_NAME );
      // ssErrCode = ; // have to use an NT error to get SCM to put it in the event log nicely
      return;
   }

   cPCptr = &cPC;                      // set global pointer for Service Stop usage

   //  We are ready to start processing so set service started...
   if ( !PCReportStatus( SERVICE_RUNNING, NO_ERROR, 0) ) {
      // no likely recovery...
      cPC.HardStop(ssErrCode);
      cPCptr = NULL; // not necesary
      return;
   } 
   else if ( !notService )
      PCLogMessage( PC_SERVICE_STARTED, EVENTLOG_INFORMATION_TYPE, 1, PROCCON_SVC_DISP_NAME );

   //
   // Main service process...
   //
   cPC.Run();
   cPCptr = NULL; // a reminder that the global pointer references a stack variable
}

//=============================================================================================
// function to initiate service stop.
//
// Input:   none  
// Returns: nothing
// Note:    what's done here must not take longer than 3 seconds by NT service rules
//
VOID PCStopService()
{
   svcStop = TRUE;
   if ( cPCptr )
      cPCptr->Stop();
}

//=============================================================================================
// function to handle ControlService for us.
//
// Input:   control code  
// Returns: nothing
//
void WINAPI PCServiceControl( PCULONG32 dwCtrlCode ) {
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop or shutdown the service...
        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            PCReportStatus( SERVICE_STOP_PENDING, NO_ERROR, 0 );
            PCStopService();
            return;

        // Other standard control codes...
        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:
        case SERVICE_CONTROL_INTERROGATE:
            break;

        // invalid or user control codes...
        default:
            break;

    }

    PCReportStatus(ssStatus.dwCurrentState, NO_ERROR, 0);
}

//=============================================================================================
// function to handle service status reporting to NT
//
// Input:   current state, exit code, wait hint  
// Returns: TRUE if status reported (or not a service), else FALSE
//
//
BOOL PCReportStatus( PCULONG32 dwCurrentState, PCULONG32 dwWin32ExitCode, PCULONG32 dwWaitHint ) {
   static PCULONG32 dwCheckPoint = 1;
   BOOL fResult = TRUE;

   if ( !notService ) {
      ssStatus.dwControlsAccepted = dwCurrentState == SERVICE_RUNNING? SERVICE_ACCEPT_STOP : 0;
      ssStatus.dwCurrentState     = dwCurrentState;
      ssStatus.dwWin32ExitCode    = dwWin32ExitCode;
      ssStatus.dwWaitHint         = dwWaitHint;

      if ( dwCurrentState == SERVICE_RUNNING || dwCurrentState == SERVICE_STOPPED )
         ssStatus.dwCheckPoint = 0;
      else
         ssStatus.dwCheckPoint = dwCheckPoint++;


      // Report the status of the service to the service control manager.
      //
      if ( !(fResult = SetServiceStatus( ssHandle, &ssStatus )) ) {
         ssErrCode = GetLastError();
         PCLogMessage( PC_SERVICE_STATUS_ERROR, EVENTLOG_ERROR_TYPE, 1, PROCCON_SVC_DISP_NAME, 
                       sizeof(ssErrCode), &ssErrCode );
      }
   }

   return fResult;
}

#ifdef _DEBUG
//=============================================================================================
// FUNCTION: PCConsoleService -- run the service as a console application instead.
//
// Input:   standard argc, argv  
// Returns: no return value
//
void PCConsoleService(int argc, TCHAR **argv) {

   notService = TRUE;

   SetConsoleCtrlHandler( PCControlHandler, TRUE );

   // Set privileges we may need when not a service under LocalSystem...
   PCSetPrivilege( SE_DEBUG_NAME, TRUE );
   PCSetPrivilege( SE_INC_BASE_PRIORITY_NAME, TRUE );

   PCStartService( argc, argv );
}

//=============================================================================================
// function to handle console ctrl-C and break to simulate service stop when in console mode.
//
// Input:   control code  
// Returns: TRUE if handled, FALSE if not
//
BOOL WINAPI PCControlHandler( PCULONG32 dwCtrlType ) {
   switch( dwCtrlType )
   {
   case CTRL_BREAK_EVENT:  
   case CTRL_C_EVENT:      
      PCStopService();
      return TRUE;
      break;

   }
   return FALSE;
}
#endif

// End of PCMain.cpp
//============================================================================J McDonald fecit====//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\service\procconstrt.cpp ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998, 1999 Sequent Computer Systems, Incorporated.  All rights reserved. //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|---------------------------------------------------------------------------------------//            
;   This file contains non-member functions to start ProcCon threads                    //
|---------------------------------------------------------------------------------------//            
|                                                                                       //
|Created:                                                                               //
|                                                                                       //
|   Jarl McDonald 04-99                                                                 //
|                                                                                       //
|Revision History:                                                                      //
|                                                                                       //
|=======================================================================================*/
#include "ProcConSvc.h"
             
//=======================================================================================//
// Functions to start various threads in Process Control.
//
// Input:   pointer to thread context structure.
// Returns: thread return code -- 0 for success, other for failure.
//
PCULONG32 _stdcall PCProcServer( void *ctxt ) {
   
   Sleep( 2000 );                                      // Wait a bit before we jump in
   ULONG rc = 1;

   PCContext *context = (PCContext *) ctxt;

   context->cMgr = new CProcConMgr( context );

   if ( !context->cMgr )
      PCLogNoMemory( TEXT("AllocProcConMgrClass"), sizeof(CProcConMgr) );
   else if ( context->cMgr->ReadyToRun() ) {   
      context->cDB->SetPCMgr( context->cMgr );            // tell DB mgr about ProcCon mgr
      rc = context->cMgr->Run();
   }

   if ( rc && !context->cPC->GotShutdown() ) context->cPC->Stop();
   SetEvent( context->mgrDoneEvent );
   return rc;
}

PCULONG32 _stdcall PCUserServer( void *ctxt ) {

   Sleep( 2000 );                                      // Wait a bit before we jump in

   PCContext *context = (PCContext *) ctxt;

   context->cUser = new CProcConUser( context );

   if ( !context->cUser )
      PCLogNoMemory( TEXT("AllocProcConUserClass"), sizeof(CProcConUser) );
   else    
      while ( context->cUser->ReadyToRun() ) context->cUser->Run();

   if ( !context->cPC->GotShutdown() ) context->cPC->Stop();
   SetEvent( context->userDoneEvent );
   return 0;
}

ULONG _stdcall PCClientThread( void *context ) {

   ULONG rc = 1;

   CProcConClient *cClient = new CProcConClient( (ClientContext *) context );

   if ( !cClient )
      PCLogNoMemory( TEXT("AllocProcConClientClass"), sizeof(CProcConClient) );
   else {  
      if ( cClient->ReadyToRun() ) rc = cClient->Run();
      delete cClient;
   }

   return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\service\procconservice.cpp ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998, 1999  Sequent Computer Systems, Incorporated                       //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|---------------------------------------------------------------------------------------//            
|   This file contains the ProcCon NT service install and remove functions              //
|---------------------------------------------------------------------------------------//            
|                                                                                       //
|Created:                                                                               //
|                                                                                       //
|   Jarl McDonald 07-98                                                                 //
|                                                                                       //
|Revision History:                                                                      //
|   Jarl McDonald 19-08-99 change service start type to auto                            //
|                                                                                       //
|=======================================================================================*/
#include "ProcConSvc.h"             

//========================================================================================
//  function to install the ProcCon service...  no input or output
//  Note: installation also includes the EventLog entries necessary to 
//        resolve our event log messages.
//
void PCInstallService(int argc, TCHAR **argv) {

   TCHAR path[MAX_PATH], err[512];

   // Use security descriptor that allows admin access for our registry data.
   // Post-installation the access list may need to be tailored.
   SECURITY_ATTRIBUTES  adminAttr;
   if ( !PCBuildAdminSecAttr( adminAttr ) ) {
      const VOID *args[] = { NULL, PROCCON_SVC_DISP_NAME };
      PCLogErrStdout( PC_SERVICE_UNABLE_TO_INSTALL, GetLastError(), args );
      return;
   }

   // Get our module name -- needed to install service and error log message file...
   if ( !GetModuleFileName( NULL, path, MAX_PATH ) ) {
      const VOID *args[] = { NULL, PROCCON_SVC_DISP_NAME };
      PCLogErrStdout( PC_SERVICE_UNABLE_TO_INSTALL, GetLastError(), args );
      return;
   }

   // Open SCM and install ourselves...
   SC_HANDLE hSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_CREATE_SERVICE );
   PCULONG32 rc = GetLastError();

   TCHAR *acct = NULL, *pswd = NULL;
   if ( argc > 0 ) acct = argv[0];
   if ( argc > 1 ) pswd = argv[1];

   if ( hSCManager ) {
      SC_HANDLE hService = CreateService( hSCManager,                  // SCManager database
                                          PROCCON_SVC_NAME,            // name of service
                                          PROCCON_SVC_DISP_NAME,       // name to display
                                          GENERIC_READ,                // desired access
                                          SERVICE_WIN32_OWN_PROCESS,   // service type
                                          SERVICE_AUTO_START,          // start type -- auto by MS req.
                                          SERVICE_ERROR_NORMAL,        // error control type
                                          path,                        // service's binary
                                          NULL,                        // no load ordering group
                                          NULL,                        // no tag identifier
                                          TEXT(""),                    // dependencies
                                          acct,                        // account or NULL
                                          pswd);                       // password or NULL

      // If installed, add related registry keys...
      rc = GetLastError();
      if ( hService ) {
         PCLogStdout( PC_SERVICE_SERVICE_INSTALLED, PROCCON_SVC_DISP_NAME );
         CloseServiceHandle(hService);

         HKEY  hKey;
         PCULONG32 regDisp, types = 0x07;
         TCHAR key[512];

         // Add registry key describing service...
         PCBuildBaseKey( key );
         rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, key, 0, KEY_READ + KEY_WRITE, &hKey );
         if ( rc != ERROR_SUCCESS ) {
            const VOID *args[] = { NULL, PROCCON_SVC_DISP_NAME, key };
            PCLogErrStdout( PC_SERVICE_REGISTRY_OPEN_FAILED,
                            rc,
                            args );
         } else {
            rc = RegSetValueEx( hKey, PROCCON_SERVICE_DESCRIPTION_NAME, NULL, REG_SZ, 
                                (UCHAR *) PROCCON_SERVICE_DESCRIPTION, 
                                (_tcslen( PROCCON_SERVICE_DESCRIPTION ) + 1) * sizeof(TCHAR) );
            if ( rc != ERROR_SUCCESS ) {
               const VOID *args[] = { NULL, PROCCON_SVC_DISP_NAME, PROCCON_SERVICE_DESCRIPTION_NAME };
               PCLogErrStdout( PC_SERVICE_ADD_VALUE_SERVICE_DESC_FAILED, rc, args );
            }
            
            RegCloseKey( hKey );
         }

         // Add registry key describing server application...
         rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, PROCCON_SERVER_APP_KEY, 0, KEY_SET_VALUE, &hKey );
         if ( rc != ERROR_SUCCESS ) {
            const VOID *args[] = { NULL, PROCCON_SVC_DISP_NAME, PROCCON_SERVER_APP_KEY };
            PCLogErrStdout( PC_SERVICE_APP_KEY_OPEN_FAILED, rc, args );
         } else {
            rc = RegSetValueEx( hKey, PROCCON_SERVER_APP_VALUE_NAME, NULL, REG_SZ, 
                                (UCHAR *) PROCCON_SVC_DISP_NAME, 
                                (_tcslen( PROCCON_SVC_DISP_NAME ) + 1) * sizeof(TCHAR) );
            if ( rc == ERROR_SUCCESS )
               PCLogStdout( PC_SERVICE_APP_KEY_CREATED, PROCCON_SVC_DISP_NAME );
            else {
               const VOID *args[] = { NULL, PROCCON_SVC_DISP_NAME, PROCCON_SERVER_APP_VALUE_NAME };
               PCLogErrStdout( PC_SERVICE_APP_KEY_ADD_FAILED,
                               rc,
                               args );
            }
            RegCloseKey( hKey );
         }

         // Add registry key to support ProcCon event log messages...
         // NULL security attribute is used to cause inheritance of attributes.
         PCBuildMsgKey( key );
         rc = RegCreateKeyEx( HKEY_LOCAL_MACHINE, key, 
                              0, TEXT(""), 0, KEY_READ + KEY_WRITE, NULL, &hKey, &regDisp );
         if ( rc != ERROR_SUCCESS ) {
            const VOID *args[] = { NULL, PROCCON_SVC_DISP_NAME, key };
            PCLogErrStdout( PC_SERVICE_REG_KEY_CREATE_FAILED,
                            rc,
                            args );
         } else {
            BOOL fname = TRUE;
            rc = RegSetValueEx( hKey, EVENT_MSG_FILE_NAME, NULL, REG_SZ, 
                                (UCHAR *) path, (_tcslen( path ) + 1) * sizeof(path[0]) );
            if ( rc == ERROR_SUCCESS ) {
               fname = FALSE;
               rc = RegSetValueEx( hKey, EVENT_MSG_TYPES_SUPPORT, NULL, REG_DWORD, 
                                   (UCHAR *) &types, sizeof( types ) );
            }

            if ( rc != ERROR_SUCCESS ) {
                const VOID *args[] = { NULL,
                                       PROCCON_SVC_DISP_NAME,
                                       fname
                                       ? EVENT_MSG_FILE_NAME
                                       : EVENT_MSG_TYPES_SUPPORT };
                PCLogErrStdout( PC_SERVICE_EVENTLOG_REG_SETUP_FAILED,
                                rc,
                                args );
            } else {
               PCLogStdout( PC_SERVICE_EVENTLOG_REG_SETUP, PROCCON_SVC_DISP_NAME );
            }

            RegCloseKey( hKey );
         }

         // Add registry keys to support ProcCon...
         // Security attribute for the PARAMETERS key is local administrators only.
         // Security attribute for the access keys is local administrators only also.
         PCBuildParmKey( key );
         rc = RegCreateKeyEx( HKEY_LOCAL_MACHINE, key, 
                              0, TEXT(""), 0, KEY_READ + KEY_WRITE, &adminAttr, &hKey, &regDisp );
         if ( rc != ERROR_SUCCESS ) {
             const VOID *args[] = { NULL, PROCCON_SVC_DISP_NAME, key };
             PCLogErrStdout( PC_SERVICE_PARAM_KEY_CREATE_FAILED, rc, args );
         } else {
            rc = RegSetValueEx( hKey, PROCCON_DATA_NAMERULES, NULL, REG_MULTI_SZ, 
                                (UCHAR *) TEXT("\0\0"), 2 * sizeof(TCHAR) );
            if ( rc != ERROR_SUCCESS ) {
                const VOID *args[] = { NULL, PROCCON_SVC_DISP_NAME, PROCCON_DATA_NAMERULES };
                PCLogErrStdout( PC_SERVICE_PARAM_DATA_UPDATE_FAILED, rc, args );
            } else {
               HKEY hTemp;
               for ( int i = 0; i < ENTRY_COUNT( accessKeyList ); ++i ) {
                   rc = RegCreateKeyEx( hKey, accessKeyList[i], 0, TEXT(""), 0, 
                                        KEY_WRITE, &adminAttr, &hTemp, &regDisp );
                   if ( rc == ERROR_SUCCESS ) RegCloseKey( hTemp );
                   else {
                       const VOID *args[] = { NULL, PROCCON_SVC_DISP_NAME, accessKeyList[i] };
                       PCLogErrStdout( PC_SERVICE_PARAM_DATA_UPDATE_FAILED, rc, args );
                      break;
                   }
               }
            }
            if ( rc == ERROR_SUCCESS ) {
                PCLogStdout( PC_SERVICE_PARAM_DATA_CREATED, PROCCON_SVC_DISP_NAME );
            }
            RegCloseKey( hKey );
         }
      }
      else {
          const VOID *args[] = { NULL, PROCCON_SVC_DISP_NAME };
          PCLogErrStdout( PC_SERVICE_CREATESERVICE_FAILED, rc, args );
      }
      CloseServiceHandle(hSCManager);
   }
   else {
       PCLogErrStdout( PC_SERVICE_OPENSCMGR_FAILED, rc, NULL );
   }
   PCFreeSecAttr( adminAttr ); 
}

//=============================================================================================
//  function to remove (deinstall) the service...  no input or output
//
void PCRemoveService(int argc, TCHAR **argv) {

   TCHAR       err[512];

   // Open SCM and service then proceed with stop and delete...
   SC_HANDLE hSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
   if ( hSCManager ) {
      SC_HANDLE hService = OpenService( hSCManager, PROCCON_SVC_NAME, SERVICE_ALL_ACCESS );

      if ( hService ) {

         // try to stop the service...
         if ( ControlService( hService, SERVICE_CONTROL_STOP, &ssStatus ) ) {
             PCLogStdout( PC_SERVICE_STOPPING, PROCCON_SVC_DISP_NAME );
            Sleep( 1000 );

            while( QueryServiceStatus( hService, &ssStatus ) ) {
               if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING ) {
                   PCLogStdout( PC_SERVICE_DOT );
                   Sleep( 1000 );
               }
               else
                  break;
            }

            if ( ssStatus.dwCurrentState == SERVICE_STOPPED ) {
                PCLogStdout( PC_SERVICE_STOPPING_STOPPED, PROCCON_SVC_DISP_NAME );
            } else {
                PCLogStdout( PC_SERVICE_FAILED_TO_STOP, PROCCON_SVC_DISP_NAME );
            }
         }

         // now remove the service...
         if( DeleteService( hService ) ) {
             PCLogStdout( PC_SERVICE_REG_ENTRIES_REMOVED, PROCCON_SVC_DISP_NAME );
         }
         else {
             PCLogErrStdout( PC_SERVICE_DELETE_SVC_FAILED, GetLastError(), NULL );
         }
         CloseServiceHandle( hService );
      }
      else {
          PCLogErrStdout( PC_SERVICE_OPEN_SVC_FAILED, GetLastError(), NULL );
      }
      CloseServiceHandle( hSCManager );
   }
   else {
       PCLogErrStdout( PC_SERVICE_OPENSCMGR_FAILED, GetLastError(), NULL );
   }
   HKEY  hKey;
   TCHAR key[512];
   // now remove server application registry keys...
   PCULONG32 rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, PROCCON_SERVER_APP_KEY, 0, KEY_SET_VALUE, &hKey );
   if ( rc == ERROR_SUCCESS ) {
      rc = RegDeleteValue( hKey, PROCCON_SERVER_APP_VALUE_NAME );
      RegCloseKey( hKey );
   }
   if ( rc == ERROR_SUCCESS ) {
       PCLogStdout( PC_SERVICE_APP_REG_ENTRY_DELETED, PROCCON_SVC_DISP_NAME );
   } else if ( rc != ERROR_FILE_NOT_FOUND ) {
       const VOID *args[] = { NULL, PROCCON_SVC_DISP_NAME, PROCCON_SERVER_APP_VALUE_NAME };
       PCLogErrStdout( PC_SERVICE_APP_REG_ENTRY_DEL_FAILED, rc, args );
   }
   
   // now remove message registry keys...
   PCBuildMsgKey( key );
   rc = RegDeleteKey( HKEY_LOCAL_MACHINE, key );
   if ( rc == ERROR_SUCCESS || rc == ERROR_KEY_DELETED ) {
       PCLogStdout( PC_SERVICE_EVTLOG_REG_DELETED, PROCCON_SVC_DISP_NAME );
   } else if ( rc != ERROR_FILE_NOT_FOUND ) {
       const VOID *args[] = { NULL, PROCCON_SVC_DISP_NAME, key };
       PCLogErrStdout( PC_SERVICE_EVTLOG_REG_DEL_FAILED, rc, args );
   }
   
   // now attempt removal of parameter registry keys...
   // (Delete of the service should have already deleted the Parameters sub-key)
   PCBuildParmKey( key );
   rc = PCDeleteKeyTree( HKEY_LOCAL_MACHINE, key ); 
   // PCDeleteKeyTree does not return ERROR_KEY_DELETED or ERROR_FILE_NOT_FOUND
   if ( rc != ERROR_SUCCESS ) {
       const VOID *args[] = { NULL, PROCCON_SVC_DISP_NAME, key };
       PCLogErrStdout( PC_SERVICE_REG_TREE_DEL_FAILED, rc, args );
   }
}

void
PCWriteStdout(
    PTCHAR Buffer,
    DWORD  BufferLen
    )
{
    DWORD  Written;

    static BOOL   ConsoleWorks = TRUE;
    static HANDLE StdOutHandle = INVALID_HANDLE_VALUE;

    if (StdOutHandle == INVALID_HANDLE_VALUE) {
        StdOutHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    }

    if (ConsoleWorks) {
        ConsoleWorks = WriteConsole(StdOutHandle,
                                    Buffer,
                                    BufferLen,
                                    &Written,
                                    NULL);
    }

    if (! ConsoleWorks) {
        WriteFile(StdOutHandle,
                  Buffer,
                  BufferLen * sizeof(TCHAR),
                  &Written,
                  NULL);
    }
}

void
CDECL
PCLogStdout(
    const PCULONG32 msgCode,
    ...
    )
{
    va_list args;
    PTCHAR Buffer;
    DWORD  BufferLen;
    
    va_start(args, msgCode);

    BufferLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                              | FORMAT_MESSAGE_FROM_HMODULE,
                              NULL,
                              msgCode,
                              0,
                              (LPWSTR) &Buffer,
                              1,
                              &args);

    va_end(args);

    if (BufferLen) {
        PCWriteStdout(Buffer, BufferLen);
        LocalFree(Buffer);
    }
}

void
PCLogErrStdout(
    const PCULONG32   msgCode,
    const PCULONG32   errCode,
    const VOID      **args
    )
{
    PTCHAR Buffer;
    PTCHAR ErrBuffer;
    DWORD  BufferLen;
    DWORD  ErrBufferLen;

    ErrBufferLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                 | FORMAT_MESSAGE_IGNORE_INSERTS
                                 | FORMAT_MESSAGE_FROM_SYSTEM,
                                 0,
                                 errCode,
                                 0,
                                 (LPWSTR) &ErrBuffer,
                                 1,
                                 NULL);

    if (ErrBufferLen) {

        if (args) {
            args[0] = ErrBuffer;
        }

        BufferLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                  | FORMAT_MESSAGE_FROM_HMODULE
                                  | (args
                                     ? FORMAT_MESSAGE_ARGUMENT_ARRAY
                                     : 0),
                                  NULL,
                                  msgCode,
                                  0,
                                  (LPWSTR) &Buffer,
                                  1,
                                  (va_list *) (args
                                               ? (PVOID) args
                                               : (PVOID) ErrBuffer));

        if (BufferLen) {
            PCWriteStdout(Buffer, BufferLen);
            LocalFree(Buffer);
        }

        LocalFree(ErrBuffer);
    }
}

// End of PCService.cpp
//============================================================================J McDonald fecit====//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\basenode.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    BaseNode.cpp                                                             //
|                                                                                       //
|Description:  Helpers for container nodes                                              //
|                                                                                       //
|Created:      Paul Skoglund 05-1999                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#include "StdAfx.h"
#include "BaseNode.h"

#include "ManagementPages.h"

HRESULT InsertProcessHeaders(IHeaderCtrl2* ipHeaderCtrl)
{
  ASSERT(ipHeaderCtrl);
  if (!ipHeaderCtrl)
    return E_UNEXPECTED;

  ITEM_STR str;

  LoadStringHelper(str, IDS_PROCESS_ALIAS_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( CProcessFolder::PROCESS_ALIAS_COLUMN, str, 0, PROCESS_ALIAS_COLUMN_WIDTH )); 

  LoadStringHelper(str, IDS_IMAGE_NAME_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( CProcessFolder::IMAGE_NAME_COLUMN, str, 0, IMAGE_NAME_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_PID_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( CProcessFolder::PID_COLUMN, str, 0, PID_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_STATUS_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( CProcessFolder::STATUS_COLUMN, str, 0, STATUS_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_AFFINITY_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( CProcessFolder::AFFINITY_COLUMN, str, 0, AFFINITY_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_PRIORITY_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( CProcessFolder::PRIORITY_COLUMN, str, 0, PRIORITY_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_JOB_OWNER_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( CProcessFolder::JOB_OWNER_COLUMN, str, 0, JOB_OWNER_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_USER_TIME_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( CProcessFolder::USER_TIME_COLUMN, str, 0, USER_TIME_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_KERNEL_TIME_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( CProcessFolder::KERNEL_TIME_COLUMN, str, 0, KERNEL_TIME_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_CREATE_TIME_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( CProcessFolder::CREATE_TIME_COLUMN, str, 0, CREATE_TIME_COLUMN_WIDTH ));

  return S_OK;
}


HRESULT PCProcListGetDisplayInfo(RESULTDATAITEM &ResultItem, const PCProcListItem &ref, ITEM_STR &StorageStr)
{
  if (ResultItem.mask & RDI_IMAGE)
  {
    if (ref.lFlags & PCLFLAG_IS_DEFINED)
      ResultItem.nImage = PROCITEMIMAGE;
    else
      ResultItem.nImage = PROCITEMIMAGE_NODEFINITION;
  }

  if (ResultItem.mask & RDI_STR)
  {
		LPCTSTR &pstr = ResultItem.str;
    switch (ResultItem.nCol)
    {
    case CProcessFolder::PROCESS_ALIAS_COLUMN:
      pstr = ref.procName;
      break;
		case CProcessFolder::IMAGE_NAME_COLUMN:
			if (ref.lFlags & PCLFLAG_IS_RUNNING)
				pstr = ref.imageName;
			else 
				pstr = _T("");
			break;
		case CProcessFolder::PID_COLUMN:
			if (ref.lFlags & PCLFLAG_IS_RUNNING)
				pstr = FormatPCUINT64(StorageStr, ref.procStats.pid);
			else 
				pstr = _T("");
			break;
    case CProcessFolder::STATUS_COLUMN:
      if(ref.lFlags & PCLFLAG_IS_MANAGED)
        pstr = (TCHAR *) LoadStringHelper(StorageStr, IDS_MANAGED);
      else
        pstr = _T("");
      break;
		case CProcessFolder::AFFINITY_COLUMN:
			if (ref.lFlags & PCLFLAG_IS_RUNNING)
				pstr = FormatAffinity(StorageStr, ref.actualAffinity);			
			else
				pstr = _T("");
			break;
    case CProcessFolder::PRIORITY_COLUMN:
			if (ref.lFlags & PCLFLAG_IS_RUNNING)
				pstr = FormatPriority(StorageStr, ref.actualPriority);
			else
				pstr = _T("");
			break;
		case CProcessFolder::JOB_OWNER_COLUMN:
			if (ref.lFlags & PCLFLAG_IS_IN_A_JOB)
				pstr = ref.jobName;
			else
				pstr = _T("");
			break;
    case CProcessFolder::USER_TIME_COLUMN:
			if (ref.lFlags & PCLFLAG_IS_RUNNING)
				pstr = FormatTimeToms(StorageStr, ref.procStats.TotalUserTime);
			else
				pstr = _T("");
			break;
    case CProcessFolder::KERNEL_TIME_COLUMN:
			if (ref.lFlags & PCLFLAG_IS_RUNNING)
				pstr = FormatTimeToms(StorageStr, ref.procStats.TotalKernelTime);
			else
				pstr = _T("");
			break;
    case CProcessFolder::CREATE_TIME_COLUMN:
			if (ref.lFlags & PCLFLAG_IS_RUNNING)
				pstr = FormatTime(StorageStr, ref.procStats.createTime);
			else
				pstr = _T("");
			break;
    default:
      ASSERT(FALSE);
      pstr = _T("");
      break;
    }
  }
  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\service\procconsvc.h ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998, 1999  Sequent Computer Systems, Incorporated                       //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|---------------------------------------------------------------------------------------//            
|   This file is the ProcCon header file used only by the ProcCon NT Service            //
|---------------------------------------------------------------------------------------//            
|                                                                                       //
|Created:                                                                               //
|                                                                                       //
|   Jarl McDonald 07-98                                                                 //
|                                                                                       //
|Revision History:                                                                      //
|                                                                                       //
|=======================================================================================*/
#include <windows.h>
#include <winnt.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <assert.h>
#include <search.h>
#include <time.h>
#include <winver.h>
#include "resource.h"
#include "ProcConSvcMsg.h"                      // Message definitions
#include "..\svclib\ProcConVersion.h"
#include "..\library\ProcConAPI.h"              // Client API definitions
#include "..\library\ProcConClnt.h"             // Definitions shared with client side library

//================================================================================//
// Various macros, defines, typedefs, etc...
#define ENTRY_COUNT(x) (sizeof(x) / sizeof(x[0]))

typedef TCHAR  FULL_JOB_NAME[JOB_NAME_LEN + 7 + 1];

#define HANDLE_FF_64  ((HANDLE) 0xffffffffffffffff)

#define MEM_REJECT_REPORT_LIMIT 10
//================================================================================//
// Various global utility function prototypes...
LPTSTR      PCNTErrorText   ( PCULONG32 error, LPTSTR buf, PCULONG32 size );
void        PCLogMessage    ( const PCULONG32  msgCode, 
                              const WORD       msgType, 
                                    WORD       numStrings, 
                              const void      *msgStrings, 
                                    PCULONG32  enData = 0, 
                                    void      *msgData = NULL );
void        PCLogUnExError  ( const __int64    pid,    const TCHAR *what );
void        PCLogUnExError  ( const TCHAR     *who,    const TCHAR *what );
PCULONG32   PCLogNoMemory   ( const TCHAR     *string, const PCULONG32 len );

void CDECL  PCLogStdout     ( const PCULONG32  msgCode,
                              ... );

void        PCLogErrStdout  ( const PCULONG32   msgCode,
                              const PCULONG32   errCode,
                              const VOID      **args );

BOOL        PCTestOSVersion ( void );
BOOL        PCSetIsRunning  ( const TCHAR *who, const TCHAR *dispName );
BOOL        PCTestIsRunning ( const TCHAR *who, const TCHAR *dispName = NULL );

void        PCInstallService( int argc, TCHAR **argv );
void        PCRemoveService ( int argc, TCHAR **argv );
void WINAPI PCServiceMain   ( PCULONG32 Argc, LPTSTR *Argv );
void WINAPI PCServiceControl( PCULONG32 dwCtrlCode );
BOOL        PCReportStatus  ( PCULONG32 dwCurrentState, PCULONG32 dwWin32ExitCode, PCULONG32 dwWaitHint );
void        PCStartService  ( PCULONG32 Argc, LPTSTR *Argv );
VOID        PCStopService   ( void );

#ifdef _DEBUG
void        PCConsoleService( int argc, TCHAR **argv );
BOOL WINAPI PCControlHandler( PCULONG32 dwCtrlType );
#endif

BOOL        PCValidName     ( const TCHAR *name, const PCULONG32 len, const BOOL nullOK = FALSE );
BOOL        PCValidMatchType( const TCHAR type );

PCULONG32   PCGetParmValue  ( TCHAR *loc, TCHAR **end );
__int64     PCGetParmValue64( TCHAR *loc, TCHAR **end );

int         PCSignof64      (__int64 x );

const       TCHAR *PCiStrStr( const TCHAR *it, const TCHAR *here );

void        PCBuildBaseKey  ( TCHAR *key );
void        PCBuildParmKey  ( TCHAR *key );
void        PCBuildMsgKey   ( TCHAR *key );

void        PCLoadStrings   ( void );

BOOL        PCSetPrivilege  ( TCHAR *privilege, BOOL enable );
 
PCULONG32   PCDeleteKeyTree ( HKEY hKey, const TCHAR *keyName );

PCULONG32   PCBuildNullSecAttr ( SECURITY_ATTRIBUTES &secAttr );
PCULONG32   PCBuildAdminSecAttr( SECURITY_ATTRIBUTES &secAttr );
void        PCFreeSecAttr      ( SECURITY_ATTRIBUTES &secAttr );
BOOL        PCGetAdminGroupName( TCHAR *Name, PCULONG32 *NameLen );

PCULONG32   PCMapPriorityToNT  ( PRIORITY  prio );
PRIORITY    PCMapPriorityToPC  ( PCULONG32 prio );
PRIORITY    PCMapPriorityForAPI( PRIORITY  prio );

__int64     PCLargeIntToInt64  ( LARGE_INTEGER &in );
__int64     PCFileTimeToInt64  ( FILETIME      &in );

BOOL        PCIsProcManaged    ( MGMT_PARMS &def, JOB_NAME *job );
BOOL        PCIsJobManaged     ( MGMT_PARMS &def );

LPCTSTR     PCIsSetToStr       (PC_MGMT_FLAGS field, PCMgmtFlags flag);
int         PCTestSetUnset     ( DWORD field1, DWORD flag1, DWORD field2, DWORD flag2 );

void PCFormatAffinityLimit     (TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def);
void PCFormatPriorityLimit     (TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def);
void PCFormatWorkingSetLimit   (TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def);
void PCFormatSchedClassLimit   (TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def);
void PCFormatProcessCountLimit (TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def);
void PCFormatProcTimeLimit     (TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def);
void PCFormatJobTimeLimit      (TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def);
void PCFormatProcMemLimit      (TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def);
void PCFormatJobMemLimit       (TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def);
void PCFormatEndofJobAction    (TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def);
void PCFormatOnOrOffLimit      (TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def, PCMgmtFlags flag);

PCULONG32 _stdcall PCProcServer  ( void *context );                           
PCULONG32 _stdcall PCUserServer  ( void *context );                           
PCULONG32 _stdcall PCClientThread( void *context );                           

static int _cdecl CompareProcName( const void *left, const void *right ) {
   return _tcsnicmp( (TCHAR *) left, (TCHAR *) right, PROC_NAME_LEN );
}

static int _cdecl CompareJobName( const void *left, const void *right ) {
   return _tcsnicmp( (TCHAR *) left, (TCHAR *) right, JOB_NAME_LEN );
}

//================================================================================//
// Mediator related constants and typedefs...
//
const static TCHAR * const PC_MEDIATOR_BASE_NAME   = TEXT("ProcConMD8.exe");           // Name of mediator executable
const static TCHAR * const PC_MEDIATOR_EXCLUSION   = TEXT("ProcConMD8OnlyMe");         // Name to ensure only one mediator is running
const static TCHAR * const PC_MEDIATOR_EVENT       = TEXT("ProcConMD8Evt");            // Name of event for service->mediator signalling
const static TCHAR * const PC_MEDIATOR_FILEMAP     = TEXT("ProcConMD8Jobs");           // Name of file map for shared job list

// For data fields below, (S) means only the Servie updates, (M) means only the mediator updates.
// Jobs (groups) are never removed from the system since they accumulate useful statistics.
// There are no synchronization issues due to strict field ownership and because the list only grows.  

// Contents of shared table entry.  Each group block contains a set of these group entries.
typedef struct _PCMediateEntry {
   FULL_JOB_NAME  groupName;                  // (S) Name of this group (job object)
   ULONG_PTR      groupKey;                   // (S) Completion port key associated with this group
   PCULONG32      groupFlags;                 // (S) Flags to control closing
   HANDLE         mediatorHandle;             // (M) For mediator's use
} PCMediateEntry;

#define PCMEDIATE_CLOSE_ME  0x00000001

// Contents of group block.  The header contains the first block. Subsequent blocks are created
// mapped, and chained to the first one as needed.  The entire structure should fit in 4K.  
typedef struct _PCMediateBlock {
   HANDLE                  svcNextBlockHandle;    // (S) Service's next block handle or NULL
   struct _PCMediateBlock *svcNextBlockAddress;   // (S) Service's next block address or NULL
   HANDLE                  medNextBlockHandle;    // (M) Mediator's next block handle or NULL
   struct _PCMediateBlock *medNextBlockAddress;   // (M) Mediator's next block address or NULL
   PCULONG32               groupCount;            // (S) Number of groups in group list below
   PCMediateEntry          group[24];             // Group list for this block (sized to fit in 4K block)
} PCMediateBlock;

// Shared table header.  This table is shared by both the Service and Mediator via a named file mapping.
// The first block of group names is part of the header. Additional blocks are chained off the first block.
typedef struct _PCMediateHdr {

   // Can be called by Service or Mediator...
   PCMediateBlock *NextBlock( PCMediateBlock *blk ) {
      return GetCurrentProcessId() == svcPID? blk->svcNextBlockAddress :
                                              blk->medNextBlockAddress;
   }

   // Can be called by Service only, NOT Mediator...
   PCMediateBlock *SvcAddBlock( PCMediateBlock *lastBlk, SECURITY_ATTRIBUTES &secAttr ) {
      lastBlk->svcNextBlockHandle = CreateFileMapping( HANDLE_FF_64, &secAttr, PAGE_READWRITE, 
                                                       0, sizeof(PCMediateBlock), NULL );
      if ( !lastBlk->svcNextBlockHandle ) {
         PCLogUnExError( TEXT("PCMediateBlock"), TEXT("CreateBlock") );
         return NULL;
      }
      lastBlk->svcNextBlockAddress = (PCMediateBlock *) MapViewOfFile( lastBlk->svcNextBlockHandle, 
                                                                       FILE_MAP_WRITE, 0, 0, 0 );
      if ( !lastBlk->svcNextBlockAddress ) {
         CloseHandle( lastBlk->svcNextBlockHandle );
         lastBlk->svcNextBlockHandle = NULL;
         PCLogUnExError( TEXT("PCMediateBlock"), TEXT("MapBlock") );
      }
      return lastBlk->svcNextBlockAddress;
   }

   // Can be called by Service only, NOT Mediator...
   void SvcAddEntry( const FULL_JOB_NAME &name, const ULONG_PTR key, SECURITY_ATTRIBUTES &secAttr ) {
      // First see if in list marked closed -- simply unmark if found...
      for ( PCMediateBlock *blk = &groupBlock; blk; blk = NextBlock( blk ) ) {
         for ( PCULONG32 i = 0; i < blk->groupCount; ++i ) {
            if ( !CompareJobName(blk->group[i].groupName, &name ) ) {
               blk->group[i].groupFlags &= ~PCMEDIATE_CLOSE_ME;
               SetEvent( svcEventHandle );
               return;
            }
         }
      }
      // Not found -- add to end of list...
      PCMediateBlock *newBlk;
      for ( blk = &groupBlock; blk; blk = newBlk ) {
         if ( blk->groupCount < ENTRY_COUNT( blk->group ) ) {
            memcpy( blk->group[blk->groupCount].groupName, &name, sizeof(name) );
            blk->group[blk->groupCount++].groupKey = key;
            SetEvent( svcEventHandle );
            break;
         }
         newBlk = NextBlock( blk );
         if ( !newBlk ) newBlk = SvcAddBlock( blk, secAttr ); 
      }
   }

   // Can be called by Service only, NOT Mediator...
   void SvcCloseEntry( FULL_JOB_NAME &name ) {
      for ( PCMediateBlock *blk = &groupBlock; blk; blk = NextBlock( blk ) ) {
         for ( PCULONG32 i = 0; i < blk->groupCount; ++i ) {
            if ( !CompareJobName(blk->group[i].groupName, &name ) ) {
               blk->group[i].groupFlags |= PCMEDIATE_CLOSE_ME;
               SetEvent( svcEventHandle );
               return;
            }
         }
      }
   }

   // Can be called by Service or Mediator (but only Service uses)...
   ULONG_PTR NewKey( const TCHAR *name ) {
      for ( PCMediateBlock *blk = &groupBlock; blk; blk = NextBlock( blk ) ) {
         for ( PCULONG32 i = 0; i < blk->groupCount; ++i ) {
            if ( !_tcscmp( name, blk->group[i].groupName ) ) 
               return blk->group[i].groupKey;
         }
      }
      return ++lastCompKey;
   }

   // Can be called by Service only, NOT Mediator...
   void SvcChainBlocks( void ) {
      for ( PCMediateBlock *blk = &groupBlock; blk; blk = NextBlock( blk ) ) {
         if ( blk->medNextBlockHandle ) {
            if ( !DuplicateHandle( medProcessInfo.hProcess,
                                   blk->medNextBlockHandle,
                                   GetCurrentProcess(),
                                   &blk->svcNextBlockHandle,
                                   NULL,
                                   FALSE,
                                   DUPLICATE_SAME_ACCESS ) )
               PCLogUnExError( TEXT("PCMediateBlock"), TEXT("DupBlkHandle") );
            else {
               blk->svcNextBlockAddress = (PCMediateBlock *) MapViewOfFile( blk->svcNextBlockHandle, 
                                                                            FILE_MAP_WRITE, 0, 0, 0 );
               if ( !blk->svcNextBlockAddress ) {
                  PCLogUnExError( TEXT("PCMediateBlock"), TEXT("MapJobBlk") );
                  CloseHandle( blk->svcNextBlockHandle );
                  blk->svcNextBlockHandle = NULL;
                  return;
               }
            }
         }
      }
   }

   // Can be called by Mediator only, NOT Service...
   void MedChainBlocks( BOOL doAll ) {
      HANDLE hSvcProc = OpenProcess( PROCESS_DUP_HANDLE, FALSE, (DWORD) svcPID );  // OpenProcess uses DWORD PID, thus truncation in WIN64
      if ( !hSvcProc ) {
         PCLogUnExError( svcPID, TEXT("OpenSvcProcFromMed") );
         return;
      }
      for ( PCMediateBlock *blk = &groupBlock; blk; blk = NextBlock( blk ) ) {
         if ( blk->svcNextBlockHandle && (doAll || !blk->medNextBlockAddress) ) {
            if ( !DuplicateHandle( hSvcProc,
                                   blk->svcNextBlockHandle,
                                   GetCurrentProcess(),
                                   &blk->medNextBlockHandle,
                                   NULL,
                                   FALSE,
                                   DUPLICATE_SAME_ACCESS ) )
               PCLogUnExError( TEXT("PCMediateBlock"), TEXT("DupServiceBlkHandle") );
            else {
               blk->medNextBlockAddress = (PCMediateBlock *) MapViewOfFile( blk->medNextBlockHandle, 
                                                                            FILE_MAP_WRITE, 0, 0, 0 );
               if ( !blk->medNextBlockAddress ) {
                  PCLogUnExError( TEXT("PCMediateBlock"), TEXT("MapServiceJobBlk") );
                  CloseHandle( blk->medNextBlockHandle );
                  blk->medNextBlockHandle = NULL;
                  break;
               }
            }
         }
      }
      CloseHandle( hSvcProc );
   }

   ULONG_PTR             lastCompKey;         // (S) Last completion key assigned to a group (or 0)
   HANDLE                svcPortHandle;       // (S) Service's Completion port handle
   HANDLE                svcEventHandle;      // (S) Service's event handle for service->mediator signalling
   ULONG_PTR             svcPID;              // (S) Service's PID
   PROCESS_INFORMATION   medProcessInfo;      // (S) initially, (M) replaces IDs. Mediator process information
   HANDLE                medPortHandle;       // (M) Mediator's copy of completion port handle
   VERSION_STRING        medProductVersion;   // (M) Meidator's product version
   VERSION_STRING        medFileVersion;      // (M) Meidator's file version
   VERSION_STRING        medFileFlags;        // (M) Meidator's file flags
   PCMediateBlock        groupBlock;          // First data block
} PCMediateHdr;

//================================================================================//
// Enable forward class references...
class CProcCon;
class CProcConDB;
class CProcConMgr;
class CProcConUser;

//================================================================================//
// Miscellaneous
const static TCHAR * const PROCCON_SVC_NAME            = TEXT("ProcCon");           // Service name
const static TCHAR * const PROCCON_SVC_EXCLUSION       = TEXT("ProcConSvcOnlyMe");  // Name to ensure only one service is running

extern TCHAR PROCCON_SVC_DISP_NAME[128];                              // Service display name (loaded)
extern TCHAR PROCCON_MEDIATOR_DISP_NAME[128];                         // Mediator display name (loaded)
extern TCHAR PROCCON_UNKNOWN_PROCESS[32];                             // Name used for process already terminated (loaded)
extern TCHAR PROCCON_SERVICE_DESCRIPTION[256];                        // The service description value (loaded string)
extern TCHAR PROCCON_DEFAULT_NAMERULE_DESC[NAME_DESCRIPTION_LEN + 1]; // Description field for default alias rule 
extern TCHAR PROCCON_FLAG_ON[32];                                     // Name used to indicate behavior is set
extern TCHAR PROCCON_FLAG_OFF[32];                                    // Name used to indicate behavior is not set
extern TCHAR PROCCON_SYSTEM_PROCESS[32];                              // Name used for 'System' process (loaded)
extern TCHAR PROCCON_SYSTEM_IDLE[64];                                 // Name used for 'System Idle Process' (loaded)
extern TCHAR PROCCON_SERVICE_USAGE[256];

typedef struct _PCContext {
   CProcCon      *cPC; 
   CProcConMgr   *cMgr;
   HANDLE         mgrDoneEvent;
   CProcConUser  *cUser;
   HANDLE         userDoneEvent;
   CProcConDB    *cDB;
   HANDLE         completionPort;
   HANDLE         mediatorEvent;
   HANDLE         mediatorTableHandle;
   PCMediateHdr  *mediatorTable;
} PCContext;

typedef struct _ClientContext {

   _ClientContext( PCULONG32 client, CProcCon *pcPC, CProcConDB *pcDB, CProcConUser *pcUser, 
                   PCULONG32 inSize, PCULONG32 outSize ) : 
             clientNo( client ),   hPipe( NULL ), 
             cPC( pcPC ),          cDB( pcDB ),      cUser( pcUser ), 
             inBufChars( inSize ), outBufChars( outSize ) 
   { 
   };
              
   ~_ClientContext( void ) {
};

   PCULONG32     clientNo;
   HANDLE        hPipe;
   PCULONG32     inBufChars;
   PCULONG32     outBufChars;
   CProcCon     *cPC;
   CProcConDB   *cDB;
   CProcConUser *cUser;

} ClientContext;

typedef struct _PCJobDef {
   JOB_NAME         jobName;          // Job name associated with this definition
   PROFILE_NAME     profileName;      // Profile name associated with this definition
   PC_MGMT_FLAGS    mFlags;           // Flags indicating which mgmt data to actually apply
   AFFINITY         affinity;         // processor affinity to apply if flagged
   PRIORITY         priority;         // NT priority to apply if flagged
   MEMORY_VALUE     minWS;            // NT minimum working set to apply if flagged
   MEMORY_VALUE     maxWS;            // NT maximum working set to apply if flagged
   SCHEDULING_CLASS schedClass;       // NT scheduling class to apply if flagged
   PCULONG32        procCountLimit;   // Number of processes in the job (jobs only).
   TIME_VALUE       procTimeLimitCNS; // Per process time limit in 100ns (CNS) units or 0.
   TIME_VALUE       jobTimeLimitCNS;  // Per job time limit in 100ns (CNS) units or 0.
   MEMORY_VALUE     procMemoryLimit;  // Hard memory commit limit per process (jobs only).
   MEMORY_VALUE     jobMemoryLimit;   // Hard memory commit limit per job (jobs only).
} PCJobDef;

typedef struct _PCProcDef {
   PROC_NAME        procName;    // Process name associated with this definition -- must be first
   PROFILE_NAME     profileName; // Profile name associated with this definition
   JOB_NAME         memberOfJob; // Job name to associate process with if flagged
   PC_MGMT_FLAGS    mFlags;      // Flags indicating which mgmt data to actually apply
   AFFINITY         affinity;    // processor affinity to apply if flagged
   PRIORITY         priority;    // NT priority to apply if flagged
   MEMORY_VALUE     minWS;       // NT minimum working set to apply if flagged
   MEMORY_VALUE     maxWS;       // NT maximum working set to apply if flagged
} PCProcDef;

//================================================================================//
// Registry related constants...
//
// Registry Server Apps Key (to let us appear as a server app in MMC)...
const static TCHAR * const PROCCON_SERVER_APP_KEY           = 
    TEXT("SYSTEM\\CurrentControlSet\\Control\\Server Applications");
// Registry Base Key (full key will include added subkey)...
const static TCHAR * const PROCCON_REG_SERVICE_BASE         =                          // Base key for all registry data
    TEXT("SYSTEM\\CurrentControlSet\\Services\\");
const static TCHAR * const PROCCON_SERVICE_DESCRIPTION_NAME = TEXT("Description");     // Name or the Service Description value

//
// Registry Subkeys...
const static TCHAR * const PROCCON_REG_EVENTLOG_SUBKEY   = TEXT("EventLog\\System\\");  // Subkey for event log parameters
const static TCHAR * const PROCCON_REG_PARMS_SUBKEY      = TEXT("Parameters");          // Subkey for ProcCon parameters
const static TCHAR * const PROCCON_REG_PROCRULES_SUBKEY  = TEXT("ProcessRules");        // Subkey for our job rules
const static TCHAR * const PROCCON_REG_JOBRULES_SUBKEY   = TEXT("GroupRules");          // Subkey for our process rules

// Access test subkeys...
const static TCHAR * const PROCCON_REG_KILLPROC_ACCTEST  = TEXT("AccessControl\\KillProcess");        // To allow process kill 
const static TCHAR * const PROCCON_REG_KILLJOB_ACCTEST   = TEXT("AccessControl\\KillGroup");          // To allow job kill 
const static TCHAR * const PROCCON_REG_REALTIME_ACCTEST  = TEXT("AccessControl\\SetRealTimePriority");// To allow real time priority 
const static TCHAR * const PROCCON_REG_POLLRATE_ACCTEST  = TEXT("AccessControl\\SetPollSeconds");     // To allow changing poll rate 
const static TCHAR * const PROCCON_REG_RESTORE_ACCTEST   = TEXT("AccessControl\\Restore");            // To allow database restore

const static TCHAR * const accessKeyList[] = { 
                     PROCCON_REG_KILLPROC_ACCTEST, PROCCON_REG_KILLJOB_ACCTEST, 
                     PROCCON_REG_REALTIME_ACCTEST, PROCCON_REG_POLLRATE_ACCTEST,
                     PROCCON_REG_RESTORE_ACCTEST };

//
// Registry Value names...
const static TCHAR * const PROCCON_SERVER_APP_VALUE_NAME = TEXT("{7cfc9f00-0641-11d2-8014-00104b9a3106}");

const static TCHAR * const PROCCON_DATA_DEFAULTRULES     = TEXT("DfltMgmt");            // Name of our dflt mgmt rules
const static TCHAR * const PROCCON_DATA_DESCRIPTION      = TEXT("Description");         // Name of our description value
const static TCHAR * const PROCCON_DATA_VARDATA          = TEXT("VarData");             // Name of our variable detail data
const static TCHAR * const PROCCON_DATA_MEMBEROF         = TEXT("MemberOf");            // Name of our member of value
const static TCHAR * const PROCCON_DATA_NAMERULES        = TEXT("NameRules");           // Name of our name rules table
const static TCHAR * const PROCCON_DATA_POLLDELAY        = TEXT("ProcessPollSeconds");  // Name of our poll rate value

const static TCHAR * const EVENT_MSG_FILE_NAME           = TEXT("EventMessageFile");    // message files in EventLog key
const static TCHAR * const EVENT_MSG_TYPES_SUPPORT       = TEXT("TypesSupported");      // types supported in EventLog key

//================================================================================//
// Globals                                                                        //
//
extern BOOL                  svcStop;
extern BOOL                  notService;
extern SERVICE_STATUS_HANDLE ssHandle;                    // service control handler
extern SERVICE_STATUS        ssStatus;                    // current service status
extern PCULONG32             ssErrCode;                   // error code for status reporting

//================================================================================//
// ProcCon classes...

//------------------------------------------------------------------------------------------------//
// This class is a ProcCon instance -- its job is to start ProcCon's threads and wait.
//------------------------------------------------------------------------------------------------//
class CProcCon {

public:
   // Public methods
    CProcCon( void );
   ~CProcCon( void );

   BOOL         ReadyToRun   ( void );
   void         Run          ( void );
   void         HardStop     ( PCULONG32 ExitCode  = 0  );
   void         Stop         ( void );
   PCULONG32    StartMediator( void );
   PCULONG32    StopMediator ( void );
   BOOL         GotShutdown  ( void )    { return m_shutDown;           }
   HANDLE       GetShutEvent ( void )    { return m_shutEvent;          }
   PCUINT32     GetPageSize  ( void )    { return m_PageSize;           }
   PCUINT32     GetProcCount ( void )    { return m_NumberOfProcessors; }
   CProcConMgr *GetPCMgr     ( void )    { return m_context.cMgr;       }

   void         GetPCSystemInfo( PCSystemInfo *data, PCINT16 *itemLen, PCINT16 *itemCount );

private:
   // Private methods
   void LaunchProcServer( void );                     // Starts the Process Management thread
   void LaunchUserServer( void );                     // Starts the User Communication thread

   // Private attributes
   enum PCThreads { PROC_SERVER = 0, USER_SERVER = 1 };

   BOOL                 m_shutDown;
   HANDLE               m_shutEvent;
   HANDLE               m_endEvent;
   HANDLE               m_hThread[2];
   SECURITY_ATTRIBUTES  m_secAttr;                   // admin level security attrs
   BOOL                 m_ready;
   PCContext            m_context;
   PCUINT32             m_NumberOfProcessors;
   PCUINT32             m_PageSize;
   CVersion            *m_versionInfo;
};

//------------------------------------------------------------------------------------------------//
// This class is ProcCon's user management thread.  It waits for connections and establishes
// the connecting user's environment -- including a client thread.
//------------------------------------------------------------------------------------------------//
class CProcConUser {

public:
   // Public methods
    CProcConUser( PCContext *ctxt );
   ~CProcConUser( void );

   BOOL      ReadyToRun( void ); 
   PCULONG32 Run       ( void );
   PCULONG32 GetTimeout( void )  { return m_clientTimeout; }
   PCULONG32 SetTimeout( PCULONG32 newTimeout ); 

private:
   // Private methods

   // Private attributes
   const static TCHAR *PIPENAME; 

   CProcCon            &m_cPC;
   CProcConDB          &m_cDB;
   PCULONG32            m_outBufChars;
   PCULONG32            m_inBufChars;
   PCULONG32            m_clientTimeout;
   HANDLE               m_hConnEvent;
   OVERLAPPED           m_olConn;                    // for overlapped I/O on pipe connect
   PCULONG32            m_clientCount;               // counts clients
   SECURITY_ATTRIBUTES  m_secAttr;                   // security attributes for our pipe
};

//------------------------------------------------------------------------------------------------//
// This class is a ProcCon client thread.  There may be any number of clients connected at once.
//------------------------------------------------------------------------------------------------//
class CProcConClient {

public:
   // Public methods
    CProcConClient( ClientContext *ctxt );
   ~CProcConClient( void );

   BOOL   ReadyToRun( void );
   PCULONG32 Run     ( void );

private:
   // Private methods
   BOOL  ProcessRequest   ( PCULONG32 inLen, PCULONG32 *outLen );
   void  PrimeResponse    ( PCResponse *rsp, PCRequest *req );
   BOOL  ErrorResponse    ( PCULONG32 errCode, PCResponse *rsp, PCULONG32 *outLen );

   BOOL  DoNameRules      ( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen );
   BOOL  DoJobSummary     ( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen );
   BOOL  DoProcSummary    ( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen );
   BOOL  DoProcList       ( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen );
   BOOL  DoJobList        ( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen );
   BOOL  DoProcDetail     ( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen );
   BOOL  DoJobDetail      ( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen );
   BOOL  DoServerInfo     ( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen );
   BOOL  DoServerParms    ( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen );
   BOOL  DoControl        ( PCRequest *req, PCResponse *rsp, PCULONG32 *outLen );

   BOOL  Impersonate      ( PCRequest *req );
   void  UnImpersonate    ( PCRequest *req );

   void  GenerateJobDetail( PCProcDetail *reqDetail );

   // Private attributes
   CProcCon      &m_cPC;
   CProcConDB    &m_cDB;
   CProcConUser  &m_cUser;
   HANDLE         m_hPipe;
   BOOL           m_impersonating;
   PCULONG32      m_clientNo;
   PCULONG32      m_outBufChars;
   PCULONG32      m_inBufChars;
   TCHAR         *m_outBuf;
   TCHAR         *m_inBuf;
   HANDLE         m_hReadEvent;
   HANDLE         m_hWriteEvent;
   OVERLAPPED     m_olRead;
   OVERLAPPED     m_olWrite;
};

//------------------------------------------------------------------------------------------------//
// This class is ProcCon's management thread.  It periodically discovers what's running and 
// manages the workload according to management definitions.
//------------------------------------------------------------------------------------------------//
class CProcConMgr {

   struct _ManagedJob;

public:
   // Public methods
    CProcConMgr( PCContext *ctxt );
   ~CProcConMgr( void );

   BOOL      ReadyToRun          ( void );
   PCULONG32 Run                 ( void );
   PCULONG32 ExportActiveProcList( PCProcListItem **list );
   PCULONG32 ExportActiveJobList ( PCJobListItem **list );
   AFFINITY  GetSystemMask       ( void ) { return m_systemMask; }
   INT32     KillJob             ( JOB_NAME &name );
   INT32     KillProcess         ( ULONG_PTR pid, TIME_VALUE created );
   void      JobIsEmpty          ( struct _ManagedJob *job );

private:

   // These structures are temporary lists of procs and jobs needing management...
   typedef struct _ManagedProcItem {
      PROC_STATISTICS  pStats;               // process Id, etc.
      PCProcDef       *pDef;                 // process definition pointer.
      IMAGE_NAME       imageName;            // NT 'image' (exe) name 
   } ManagedProcItem;

   typedef struct _ManagedJobItem {
      PCJobDef       *jDef;                 // process definition pointer.
   } ManagedJobItem;

   // These structures describe running processes and jobs...
   typedef struct _ManagedJob {

      _ManagedJob( TCHAR *name, PCMediateHdr *mData ) : 
                   next( NULL ), jobHandle( NULL ), lastEojAction( 789123 ), 
                   sequence( 0 ), lastError( 0 ),  curJobTimeLimitCNS( 0 ), dataErrorFlags( 0 ),
                   memRejectReportTime( 0 ),
                   timeExceededReported( FALSE ), hasComplPort( FALSE ), JOProcListInfo( NULL ) {
         memset( jName,                 0, sizeof(jName) );
         memset( &jobParms,             0, sizeof(jobParms) );
         memset( fullJobName,           0, sizeof(fullJobName) );
         memset( &JOBasicAndIoAcctInfo, 0, sizeof(JOBasicAndIoAcctInfo) );
         memset( &JOExtendedLimitInfo,  0, sizeof(JOExtendedLimitInfo) );
         _tcscpy( jName, name );                             // Save user supplied name
         _tcscpy( fullJobName, TEXT("MSjob_") );             // Full name includes constant
         _tcscat( fullJobName, name );                       // and user supplied name
         compKey = mData->NewKey( fullJobName );             // Assign our completion key
      }

      ~_ManagedJob( void ) {
         if ( jobHandle ) CloseHandle( jobHandle );
      }

      JOB_NAME                                      jName;                   // job name -- key.
      struct _ManagedJob                           *next;                    // next ManagedJob entry or NULL
      PCULONG32                                     sequence;                // to detect when job updates have been done
      HANDLE                                        jobHandle;               // Job object handle
      BOOL                                          hasComplPort;            // TRUE if job has port association
      BOOL                                          timeExceededReported;    // Time excceed msg issued (post on time limit)
      PCULONG32                                     memRejectReportTime;     // Last Tick Count of memory reject reporting
      PC_MGMT_FLAGS                                 dataErrorFlags;          // Flags to suppress duplicate error reporting
      ULONG_PTR                                     compKey;                 // Key for completion port to find job
      PCULONG32                                     lastEojAction;           // last setting for EOJ time lime reporting 
      PCJobDef                                      jobParms;                // ProcCon job management parameters
      PCULONG32                                     lastError;               // Last NT error accessing JO
      FULL_JOB_NAME                                 fullJobName;             // Fully decorated job name
      TIME_VALUE                                    curJobTimeLimitCNS;      // Our currently assigned job time limit
      JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION JOBasicAndIoAcctInfo;    // JO acct info from last Discover() call
      JOBOBJECT_EXTENDED_LIMIT_INFORMATION          JOExtendedLimitInfo;     // JO ext limits from last Discover() call 
      JOBOBJECT_BASIC_PROCESS_ID_LIST              *JOProcListInfo;          // JO proc list from last Discover() call
   } ManagedJob;

   typedef struct _ManagedProc {

      _ManagedProc( TCHAR *name, PID_VALUE pid, __int64 &createtime ) 
         : next( NULL ),        sequence( 0 ),       
           isInJob( FALSE ),    reportAdd( FALSE ),
           passSkipFlags( 0 ),  isAppliedFlags( 0 ), 
           actualPriority( 0 ), actualAffinity( 0 ), 
           pMJob( NULL ) 
      {
         memset( &pStats,              0, sizeof(pStats)        );
         memset( &imageName,           0, sizeof(imageName)     );
         memset( &procParms,           0, sizeof(procParms)     );
         memset( &originalParms,       0, sizeof(originalParms) );
         memset( &lastAlreadyInJobErr, 0, sizeof(lastAlreadyInJobErr) );
         _tcscpy( pName, name );
         _i64tot( pid, pidAsString, 10 );
         pStats.pid = pid;
         pStats.createTime = createtime;

      }

      PROC_STATISTICS      pStats;                  // pid, etc.
      PROC_NAME            pName;                   // process name as assigned by ProcCon
      struct _ManagedProc *next;                    // next ManagedProc entry or NULL
      PCULONG32            sequence;                // to detect when referenced proc has gone away
      PRIORITY             actualPriority;          // actual base priority
      AFFINITY             actualAffinity;          // actual affinity mask
      IMAGE_NAME           imageName;               // NT 'image' (exe) name
      BOOL                 isInJob;                 // TRUE if proc is assigned to job below
      BOOL                 reportAdd;               // TRUE if job reporter should report as 'added to'
      PC_MGMT_FLAGS        passSkipFlags;           // Flags to suppress attempted re-application of limit
      PC_MGMT_FLAGS        isAppliedFlags;          // Flags to indicate whether limit is applied or not
      TCHAR                pidAsString[16];         // string version of pId for log messages
      ManagedJob          *pMJob;                   // ptr to Managed Job when isInJob
      FULL_JOB_NAME        lastAlreadyInJobErr;     // Last rejected job name due to already in above job
      PCProcDef            procParms;               // proc management parameters (used to apply settings)
      PCProcDef            originalParms;           // original process parameters (used to un-apply settings)
   } ManagedProc;

   // These structures are raw (unfiltered) lists of currently running jobs and procs...
   typedef struct _RawJobList {
      PROC_NAME       jName;                // job name.
   } RawJobList;

   typedef struct _RawProcList {
      ULONG_PTR           pId;              // process Id (PID).
      FILETIME            createTime;       // process create time
      FILETIME            exitTime;         // process exit time (we don't use)
      FILETIME            userTime;         // process user time
      FILETIME            kernelTime;       // process kernel time
      PROC_NAME           pName;            // process name.
      struct _ManagedJob *pMJob;            // ptr to ManagedJob if in job or NULL if not in job
      PRIORITY            actualPriority;   // actual base priority
      AFFINITY            actualAffinity;   // actual affinity mask 
      IMAGE_NAME          imageName;        // NT 'image' (exe) name 
   } RawProcList;

   // Private methods
   void Discover     ( void );     // Discovers running processes/jobs
   void Manage       ( void );     // Applies mgmt rules to processes/jobs

   BOOL NotTooSoon   ( ManagedJob *job, PCULONG32 limit );

   static PCULONG32 __stdcall JobReporter( void *inPtr );

   static int _cdecl CompareRawProcList( const void *left, const void *right ) {
      return PCSignof64(((RawProcList *) left )->pId - ((RawProcList *) right)->pId);
   }

   static int _cdecl CompareRawJobList( const void *left, const void *right ) {
      return CompareJobName( left, right );           // job name is first in raw structure
   }

   void         DeleteOrphanProcEntries( void );
   void         DeleteOrphanJobEntries ( void );

   ManagedProc *FindProcEntry    ( PID_VALUE pid, __int64 &createTime );
   ManagedJob  *FindJobEntry     ( TCHAR *job, ManagedJob **plast = NULL );
   void         UpdateProcEntry  ( ManagedProc &proc, PCProcDef &item, BOOL newProc );
   void         UpdateJobEntry   ( ManagedJob  &job,  PCJobDef  *item, BOOL newProc = FALSE );
   BOOL         GetProcListForJob( ManagedJob &job );
   void         UpdateJobObjInfo ( ManagedJob  &job );
   BOOL         ApplyJobMgmt     ( ManagedJob  &job );
   BOOL         ApplyProcMgmt    ( ManagedProc &proc, HANDLE hProc );

   HANDLE            GetComplPort   ( void        ) { return m_assocPort.CompletionPort; }
   ManagedJob       *GetJobAnchor   ( void        ) { return m_jobAnchor;                }
   ManagedProc      *GetProcAnchor  ( void        ) { return m_procAnchor;               }
   PCULONG32         GetRawProcCount( void        ) { return m_rawProcCount;             }
   RawProcList      &GetRawProcEntry( PCULONG32 i ) { return m_rawProcList[i];           }
   CRITICAL_SECTION *GetListCSPtr   ( void        ) { return &m_mgCSMgrLists;            }

   // Private attributes
private:
   CProcCon            &m_cPC;
   CProcConDB          &m_cDB;

   JOBOBJECT_ASSOCIATE_COMPLETION_PORT m_assocPort;  // associated completion port structure

   HANDLE               m_reportThread;      // thread that monitors completion port

   ULONG_PTR            m_systemMask;        // NT system affinity mask: shows processors present
   PCULONG32            m_sequencer;         // To detect when processes are no longer around

   CRITICAL_SECTION     m_mgCSMgrLists;      // to protect various process and job lists below

   SECURITY_ATTRIBUTES  m_secAttr;           // security attributes for our job objects

   RawProcList         *m_rawProcList;       // proc information from last process discovery or NULL
   PCULONG32            m_rawProcCount;      // number of entries in raw rpoc list

   PCULONG32            m_jobManagedCount;   // count of managed job entries in m_jobAnchor
   ManagedJob          *m_jobAnchor;         // linked list of currently managed jobs

   PCULONG32            m_procManagedCount;  // count of managed proc entries in m_procAnchor;
   ManagedProc         *m_procAnchor;        // linked list of currently managed procs

   HANDLE               m_mediatorEvent;     // mediator signalling event
   PCMediateHdr        *m_mediatorTable;     // data shared with mediator

};

//------------------------------------------------------------------------------------------------//
// This class is ProcCon's database control and owns all external data.  
// This class does not include a thread -- all database calls are synchronous from other threads.  
//------------------------------------------------------------------------------------------------//
class CProcConDB {

public:
   const enum LoadFlags { LOADFLAG_NAME_RULES = 0x00000001, 
                          LOADFLAG_PROC_RULES = 0x00000002, 
                          LOADFLAG_JOB_RULES  = 0x00000004,
                          LOADFLAG_ALL_RULES  = 0x00000007,
   };

   // Public methods
    CProcConDB( PCUINT32 size );
   ~CProcConDB( void ); 

   BOOL      ReadyToRun         ( void );
   PCULONG32 LoadRules          ( PCULONG32 which );
   HANDLE    GetDbEvent         ( void )  { return m_dbEvent; }
   PCULONG32 GetPollDelay       ( void )  { return m_pollDelay; }
   PCULONG32 GetPollDelaySeconds( void )  { return m_pollDelay / 1000; }
   PCULONG32 SetPollDelaySeconds( PCULONG32 newDelay );
   void      SetPCMgr           ( CProcConMgr *pMgr ) { m_cMgr = pMgr; }
   void      AssignProcName     ( const TCHAR *path, PROC_NAME *name, IMAGE_NAME *iName );   
   INT32     TestAccess         ( const TCHAR *key );

   PCULONG32 GetJobMgmtDefs ( PCJobDef **pList, JOB_NAME *name = NULL );
   PCULONG32 GetProcMgmtDefs( PCProcDef **pList );

   BOOL      GetNameRules  ( const PCINT32 first, PCNameRule *pRules,
                             const PCINT32 maxCount, PCINT16 *itemLen, PCINT16 *itemCount, PCINT32 *updCtr );
   PCULONG32 AddNameRule   ( const PCNameRule *pRule, const BYTE version, const PCULONG32 index, const PCINT32 updCtr );
   PCULONG32 ReplNameRule  ( const PCNameRule *pRule, const BYTE version, const PCULONG32 index, const PCINT32 updCtr );
   PCULONG32 DelNameRule   ( const PCULONG32 index, const PCINT32 updCtr );
   PCULONG32 SwapNameRule  ( const PCULONG32 index, const PCINT32 updCtr );

   BOOL      GetJobSummary ( const PCJobSummary  *pStart, PCUINT32 listFlags,
                             PCJobSummary  *pSummary, const PCINT32 maxCount, PCINT16 *itemLen, PCINT16 *itemCount );
   BOOL      GetProcSummary( const PCProcSummary *pStart, PCUINT32 listFlags,
                             PCProcSummary *pSummary, const PCINT32 maxCount, PCINT16 *itemLen, PCINT16 *itemCount );

   BOOL      GetJobList    ( const PCJobListItem  *pStart, const PCUINT32 listFlags, PCJobListItem  *pList,   
                             const PCINT32 maxCount, PCINT16 *itemLen, PCINT16 *itemCount );
   BOOL      GetProcList   ( const PCProcListItem *pStart, const PCUINT32 listFlags, PCProcListItem *pList,   
                             const PCINT32 maxCount, PCINT16 *itemLen, PCINT16 *itemCount );

   PCULONG32 GetProcDetail ( const PCProcDetail  *pIn, PCProcDetail *pDetail, const BYTE version, PCINT32 *updCtr );
   PCULONG32 AddProcDetail ( const PCProcDetail  *pDetail,  const BYTE version );
   PCULONG32 ReplProcDetail( const PCProcDetail  *pDetail,  const BYTE version, const PCINT32 updCtr );
   PCULONG32 DelProcDetail ( const PCProcSummary *pSummary, const BYTE version );
   void      LogProcSummaryChange( const PCProcSummary *pSummary, const BYTE version, const PCProcSummary *pOldSummary );

   PCULONG32 GetJobDetail  ( const PCJobDetail  *pIn, PCJobDetail *pDetail, const BYTE version, PCINT32 *updCtr );
   PCULONG32 AddJobDetail  ( const PCJobDetail  *pDetail,  const BYTE version );
   PCULONG32 ReplJobDetail ( const PCJobDetail  *pDetail,  const BYTE version, const PCINT32 updCtr );
   PCULONG32 DelJobDetail  ( const PCJobSummary *pSummary, const BYTE version );
   void      LogJobSummaryChange( const PCJobSummary *pSummary, const BYTE version, const PCJobSummary *pOldSummary );

   PCULONG32 DeleteAllNameRules( void );
   PCULONG32 DeleteAllProcDefs ( void );
   PCULONG32 DeleteAllJobDefs  ( void );

private:
   // Private methods
   BOOL  OpenProcKey        ( void );
   BOOL  OpenParmKey        ( void );
   BOOL  OpenJobKey         ( void );

   PCULONG32 RegError        ( const TCHAR *op,   const TCHAR *what1 = NULL, const TCHAR *what2 = NULL );
   PCULONG32 RegDataError    ( const TCHAR *what );
   PCULONG32 GetPCParm       ( const TCHAR *name, PCULONG32 *data );
   PCULONG32 SetPCParm       ( const TCHAR *name, PCULONG32 data ); 
   PCULONG32 CreateKeyAtHKLM ( const TCHAR *key,  HKEY *hKey );
   BOOL  BuildIntNameRules  ( void );
   void  BuildIntNameRule   ( PCULONG32 index );
   BOOL  NameMatch          ( const BOOL compare, const BOOL hasWildcard, const TCHAR *str, 
                              const TCHAR **arg, const PCULONG32 argCt = 1, PCULONG32 *mIdx = NULL );
   void  NameSet            ( PROC_NAME *name, const BOOL isPattern, const TCHAR *pattern, 
                              const TCHAR *patArgP, const TCHAR *patArgN = NULL  );
   int   ExtStartLoc        ( const TCHAR *name );
   void  SetJobDefEntry     ( PCJobDef *list, PCJobSummary &m_jobSummary );

   TCHAR *BuildProcKey      ( TCHAR *key );
   TCHAR *BuildJobKey       ( TCHAR *key );
   
   PCULONG32 LoadNameRules      ( PCULONG32 *count );
   PCULONG32 StoreNameRules     ( void );
   PCULONG32 NameRulesUpdated   ( void ); 

   PCULONG32 LoadProcSummary    ( void ); 
   PCULONG32 LoadJobSummary     ( void ); 
   PCULONG32 LoadProcSummaryItem( const HKEY &hKeyTemp, PCProcSummary &summary );
   PCULONG32 LoadJobSummaryItem ( const HKEY &hKeyTemp, PCJobSummary  &summary );
   PCULONG32 LoadMgmtRules      ( const HKEY &hKey,     MGMT_PARMS    &parms );
   PCULONG32 LoadVariableData   ( const HKEY &hKey,     PCINT16 *vLength,     TCHAR *vData );

   PCULONG32 StoreJobDetail     ( const PCJobDetail  &detail );      
   PCULONG32 StoreProcDetail    ( const PCProcDetail &detail );      
   PCULONG32 StoreJobValues     ( const HKEY &hKey, const PCJobDetail  &detail );
   PCULONG32 StoreProcValues    ( const HKEY &hKey, const PCProcDetail &detail );
   PCULONG32 StoreMgmtRules     ( const HKEY &hKey, const MGMT_PARMS   &parms );
   PCULONG32 StoreVariableData  ( const HKEY &hKey, const PCINT16 vLength, const TCHAR *vData );
   
static inline int _cdecl CompareProcSummary( const void *left, const void *right ) {
   int comp = _tcsnicmp( ((PCProcSummary *) left )->procName,
                         ((PCProcSummary *) right)->procName, PROC_NAME_LEN );
   if ( !comp )
      return _tcsnicmp( ((PCProcSummary *) left )->mgmtParms.profileName,
                        ((PCProcSummary *) right)->mgmtParms.profileName, PROFILE_NAME_LEN );
   else return comp;
}

static inline int _cdecl CompareJobSummary( const void *left, const void *right ) {
   int comp = _tcsnicmp( ((PCJobSummary *) left )->jobName,
                         ((PCJobSummary *) right)->jobName, JOB_NAME_LEN );
   if ( !comp )
      return _tcsnicmp( ((PCJobSummary *) left )->mgmtParms.profileName,
                        ((PCJobSummary *) right)->mgmtParms.profileName, PROFILE_NAME_LEN );
   else return comp;
}

static inline int _cdecl CompareProcListItemProcName( const void *left, const void *right ) {
   return _tcsnicmp( ((PCProcListItem *) left )->procName,
                     ((PCProcListItem *) right)->procName, PROC_NAME_LEN );
}

static inline int _cdecl CompareProcListItemPidOptional( const void *left, const void *right ) {
   int cmp = CompareProcListItemProcName( left, right );
   if ( !cmp && ((PCProcListItem *) left )->procStats.pid ) {
      cmp = PCSignof64(((PCProcListItem *) left )->procStats.pid - ((PCProcListItem *) right )->procStats.pid);
   }
   return cmp;
}

static inline int _cdecl CompareProcListItem( const void *left, const void *right ) {
   int cmp = CompareProcListItemProcName( left, right );
   if ( !cmp ) cmp = PCSignof64(((PCProcListItem *) left )->procStats.pid - ((PCProcListItem *) right )->procStats.pid);
   return cmp;
}

static inline int _cdecl CompareProcListItemJobName( const void *left, const void *right ) {
   return _tcsnicmp( ((PCProcListItem *) left )->jobName,
                     ((PCProcListItem *) right)->jobName, JOB_NAME_LEN );
}

static inline int _cdecl CompareJobListItem( const void *left, const void *right ) {
   return _tcsnicmp( ((PCJobListItem *) left )->jobName,
                     ((PCJobListItem *) right)->jobName, JOB_NAME_LEN );
}

static inline int _cdecl CompareProcDef( const void *left, const void *right ) {
   return _tcsnicmp( ((PCProcDef *) left )->procName,
                     ((PCProcDef *) right)->procName, PROC_NAME_LEN );
}

static inline int _cdecl CompareJobDef( const void *left, const void *right ) {
   return _tcsnicmp( ((PCJobDef *) left )->jobName,
                     ((PCJobDef *) right)->jobName, JOB_NAME_LEN );
}

BOOL NameHasPattern( const TCHAR *name ) {
   for ( const TCHAR *pStart = _tcschr( name, NAME_IS_PGM[0] ); 
         pStart; 
         pStart = _tcschr( pStart + 1, NAME_IS_PGM[0] ) ) {
      if ( _tcschr( PATTERN_CHARS, _totupper( *(pStart + 1) ) ) && *(pStart + 2) == NAME_IS_PGM[2] )
         return TRUE;
   }
   return FALSE;
}

BOOL JobBelongsInList( const PCJobListItem &li, 
                       const PCJobListItem *pStart, 
                       const PCUINT32       listFlags )
{
   PCINT32 cmp = CompareJobListItem( pStart, li.jobName );
   BOOL    inRange;
   if      ( listFlags & PC_LIST_MATCH_ONLY )    inRange = cmp == 0;
   else if ( listFlags & PC_LIST_STARTING_WITH ) inRange = cmp <= 0;
   else                                     inRange = cmp < 0;
   return *li.jobName && inRange && 
          (!(listFlags & PC_LIST_ONLY_RUNNING) || li.lFlags & PCLFLAG_IS_RUNNING);
}

BOOL ProcBelongsInList( const PCProcListItem &li, 
                        const PCProcListItem *pStart, 
                        const PCUINT32        listFlags )
{
   if ( listFlags & PC_LIST_MEMBERS_OF && CompareProcListItemJobName( pStart, &li ) ) 
      return FALSE;

   BOOL inRange;
   int  cmp = (listFlags & PC_LIST_MATCH_ONLY)? 
              CompareProcListItemPidOptional( pStart, &li ) : CompareProcListItem( pStart, &li );
   if      ( listFlags & PC_LIST_MATCH_ONLY )    inRange = cmp == 0;
   else if ( listFlags & PC_LIST_STARTING_WITH ) inRange = cmp <= 0;
   else                                          inRange = cmp < 0;

   return *li.procName && inRange && 
          (!(listFlags & PC_LIST_ONLY_RUNNING) || li.lFlags & PCLFLAG_IS_RUNNING);
}


// Private attributes
   const enum MatchFlags { MFLAG_HAS_WILDCARD     = 0x00000001, 
                           MFLAG_HAS_NAME_PATTERN = 0x00000002, 
                           MFLAG_HAS_EXTENSION    = 0x00000004, 
   };

   typedef struct _PCNameRuleInt {
      MATCH_TYPE       mType;                           // value is MATCH_PGM, MATCH_DIR, or MATCH_ANY.
      PCULONG32        mFlags;                          // flags to indicate wildcards, derived name, etc.
      TCHAR            mString[MAX_PATH];               // match string may include * and ? wildcard chars
      PROC_NAME        mName;                           // process name to use when match succeeds.
      NAME_DESCRIPTION mDesc;                           // user's description of rule
   } PCNameRuleInt;

   const static TCHAR      PCDB_PREFIX_FLAGS;
   const static TCHAR      PCDB_PREFIX_AFFINITY;
   const static TCHAR      PCDB_PREFIX_PRIORITY;
   const static TCHAR      PCDB_PREFIX_MINWS;
   const static TCHAR      PCDB_PREFIX_MAXWS;
   const static TCHAR      PCDB_PREFIX_SCHEDCLASS;
   const static TCHAR      PCDB_PREFIX_PROCTIME;
   const static TCHAR      PCDB_PREFIX_JOBTIME;
   const static TCHAR      PCDB_PREFIX_ACTIVEPROCS;
   const static TCHAR      PCDB_PREFIX_PROCMEMORY;
   const static TCHAR      PCDB_PREFIX_JOBMEMORY;

   const static TCHAR      BEG_BRACKET;         // leading char in rules stored in DB
   const static TCHAR      END_BRACKET;         // trailing char in rules stored in DB
   const static TCHAR      FIELD_SEP;           // separates fields in rules/values stored in DB
   const static TCHAR      STRING_DELIM;        // delimits text strings stored in DB
   const static TCHAR      RULE_MATCHONE;       // match any one characters
   const static TCHAR      RULE_MATCHANY;       // match any string of characters
   const static TCHAR      NAME_IS_PGM[];       // variable name rule text == pgm name     
   const static TCHAR      NAME_IS_DIR[];       // variable name rule text == matched dir name     
   const static TCHAR      HIDE_PROC_PATTERN[]; // pattern meaning hide this proc from view/processing     
   const static TCHAR      PATTERN_CHARS[];     // the pattern characters allowed in process names     
         static PCNameRule DEFAULT_NAME_RULE;   // default rule -- always last in name rules tbl

   CProcConMgr         *m_cMgr;            // ProcCon Manager class for live data access
   CRITICAL_SECTION     m_dbCSNameRule;    // to protect name data access
   CRITICAL_SECTION     m_dbCSProcRule;    // to protect process data access
   CRITICAL_SECTION     m_dbCSJobRule;     // to protect job data access
   PCULONG32            m_lastRegError;    // last error when accessing registry or ERROR_SUCCESS
   PCULONG32            m_pollDelay;       // process space poll delay in millseconds
   const BOOL           m_LogRuleEdits;    // report each rule edit with an Event Log entry
   HKEY                 m_parmRegKey;      // open key for registry parameter access or NULL
   HKEY                 m_procRegKey;      // open key for registry proc rules access or NULL
   HKEY                 m_jobRegKey;       // open key for registry job rules access or NULL
   PCNameRule          *m_fmtNameRules;    // name rules formatted into API structures or NULL
   PCNameRuleInt       *m_intNameRules;    // name rules formatted into our internal structure or NULL
   HANDLE               m_dbEvent;         // to signal interested parties when DB changes
   HANDLE               m_parmEvent;       // for NT to signal us on external DB change (should not happen)
   PCProcSummary       *m_procSummary;     // ptr to array of process rule summaries from DB or NULL
   PCJobSummary        *m_jobSummary;      // ptr to array of job rule summaries from DB or NULL
   SECURITY_ATTRIBUTES  m_secAttr;         // security attributes for our registry keys
   PCULONG32            m_numNameRules;    // number of rules in m_raw/fmtNameRules arrays
   PCULONG32            m_numProcRules;    // number of rules in m_procRules array
   PCULONG32            m_numJobRules;     // number of rules in m_jobRules array
   PCINT32              m_updCtrName;      // update counter for name rules
   PCINT32              m_updCtrProc;      // update counter for proc rules
   PCINT32              m_updCtrJob;       // update counter for job rules
   PCUINT32             m_pageSize;        // page size for rounding memory values
   TCHAR                m_curProfile[32];  // current profile (invalid implies DfltMgmt profile)
};

#ifdef _DEBUG
inline void _cdecl DbgTrace(LPCSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	char szBuffer[512];

	nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	assert(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

	OutputDebugStringA(szBuffer);
	va_end(args);
}
#else
inline void _cdecl DbgTrace(LPCSTR lpszFormat, ...) {}
#endif

// End of ProcConSvc.h
//============================================================================J McDonald fecit====//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\component.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    Component.cpp                                                            //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|Created:      Paul Skoglund 07-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#include "StdAfx.h"
#include "ProcCon.h"
#include "Component.h"
 
#include "BaseNode.h"
#include "DataObj.h"



/////////////////////////////////////////////////////////////////////////////
// CComponent

CComponent::CComponent()
{
  ATLTRACE( _T("Component::Component\n"));
  m_ipConsole2          = NULL;                 
  m_ipHeaderCtrl2       = NULL;               
  m_ipResultData        = NULL;   
  m_ipConsoleVerb       = NULL;
  m_ipConsoleNameSpace2 = NULL;
	m_ipDisplayHelp       = NULL;

  m_pCompData           = NULL;  // Points to parent object not an interface
                                       
  m_hbmp16x16     = NULL;
  m_hbmp32x32     = NULL;

  m_hSelectedScope = NULL;

  m_bInitializedAndNotDestroyed = FALSE;

} // end Constructor()

//---------------------------------------------------------------------------
//
CComponent::~CComponent()
{
  ATLTRACE( _T("Component::~Component\n") );
} // end Destructor()

/////////////////////////////////////////////////////////////////////////////
// IComponent implementation
// 

//---------------------------------------------------------------------------
// IComponent::Initialize is called when a snap-in is being created and
// has items in the result pane to enumerate. The pointer to IConsole that
// is passed in is used to make QueryInterface calls to the console for
// interfaces such as IResultData.
//
STDMETHODIMP CComponent::Initialize
(
  LPCONSOLE ipConsole        // [in] Pointer to IConsole's IUnknown interface
)
{
  ATLTRACE( _T("Component::Initialize()\n") );

	ASSERT( NULL != ipConsole );


  HRESULT hr = S_OK;

  // Save away all the interfaces we'll need.
  // Fail if we can't QI the required interfaces.

  hr = ipConsole->QueryInterface( IID_IConsole2,
	                                  (VOID**)&m_ipConsole2
								                  );
  if( FAILED(hr) ) 
    return hr;


  hr = m_ipConsole2->QueryInterface( IID_IResultData,
	                                  (VOID**)&m_ipResultData
								                  );
  if( FAILED(hr) ) 
    return hr;

  hr = m_ipConsole2->QueryInterface( IID_IHeaderCtrl2,
	                                  (VOID**)&m_ipHeaderCtrl2
								                  );
  if( FAILED(hr) ) 
    return hr;                         // Console needs the header
  else                                 // control pointer
    m_ipConsole2->SetHeader( m_ipHeaderCtrl2 );

  hr = m_ipConsole2->QueryConsoleVerb( &m_ipConsoleVerb );
  if( FAILED(hr) ) 
    return hr;

  hr = m_ipConsole2->QueryInterface( IID_IConsoleNameSpace2,
	                                  (VOID**)&m_ipConsoleNameSpace2
								                  );
  if( FAILED(hr) ) 
    return hr;

	hr = m_ipConsole2->QueryInterface( IID_IDisplayHelp,
	                                  (VOID**)&m_ipDisplayHelp
								                  );
  if( FAILED(hr) ) 
    return hr;


  // Load the bitmaps from the dll for the results pane
  m_hbmp16x16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_NODES_16x16));
  ASSERT( m_hbmp16x16 );
  m_hbmp32x32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_NODES_32x32));
  ASSERT( m_hbmp32x32 );
  
  m_bInitializedAndNotDestroyed = TRUE;

  return hr;

} // end Initialize()

//---------------------------------------------------------------------------
//  Store the parent CComponetData object.
//
void CComponent::SetComponentData
(
  CComponentData*  pCompData // [in] Parent CComponentData object
)
{
  ATLTRACE( _T("Component::SetComponentData\n") );
  ASSERT( NULL != pCompData );                    
  ASSERT( NULL == m_pCompData );       // Can't do this twice

  m_pCompData = pCompData;             // Cache a way to get to the 
                                       // parent CComponentData
} // end SetComponentData()

//---------------------------------------------------------------------------
// Releases all references to the console.
// Only the console should call this method.
// 
STDMETHODIMP CComponent::Destroy
(
  MMC_COOKIE Cookie          // Reserved, not in use at this time
)
{
  ATLTRACE( _T("Component::Destroy\n") );

  m_bInitializedAndNotDestroyed = FALSE;

  // Release the interfaces that we QI'ed
  m_ipConsole2->SetHeader(NULL);

  SAFE_RELEASE( m_ipHeaderCtrl2       );     
  SAFE_RELEASE( m_ipResultData        );     
  SAFE_RELEASE( m_ipConsoleVerb       );
  SAFE_RELEASE( m_ipConsoleNameSpace2 );
  SAFE_RELEASE( m_ipConsole2          );
	SAFE_RELEASE( m_ipDisplayHelp       );

  if( NULL != m_hbmp16x16 )
    DeleteObject(m_hbmp16x16);

  if( NULL != m_hbmp32x32 )
    DeleteObject(m_hbmp32x32);

  return S_OK;

} // end Destroy()


//---------------------------------------------------------------------------
// Returns a data object that can be used to retrieve context information
// for the specified cookie.

//ok, now believe this interface is only queried about items added to the result pane.

STDMETHODIMP CComponent::QueryDataObject
(
  MMC_COOKIE         Cookie,      // [in]  Specifies the unique identifier 
  DATA_OBJECT_TYPES  Context,     // [in]  Type of data object
  LPDATAOBJECT*      ppDataObject // [out] Points to address of returned data
)
{
  if (!m_bInitializedAndNotDestroyed)
  {
    ASSERT(FALSE);
    return E_UNEXPECTED;
  }

  // check for magic multi-select cookie
  if (IS_SPECIAL_COOKIE(Cookie) )
  {
    if (Cookie == MMC_MULTI_SELECT_COOKIE)
      ATLTRACE( _T("Component::QueryDataObject: MMC_MULTI_SELECT_COOKIE unimplemented\n") );
    else 
      ATLTRACE( _T("Component::QueryDataObject: special cookie %p unimplemented\n"), Cookie );
    return E_UNEXPECTED;
  }

  ASSERT( CCT_SCOPE          == Context  ||      // Must have a context
	        CCT_RESULT         == Context  ||      // we understand
          CCT_SNAPIN_MANAGER == Context
        ); 
  
  if (Context == CCT_SCOPE)
  {
    ASSERT(FALSE);
    ATLTRACE( _T("Component::QueryDataObject: asking for CCT_SCOPE Context??\n") );
    return m_pCompData->QueryDataObject(Cookie, Context, ppDataObject);
  }
  else if (Context == CCT_RESULT)
  {
    ATLTRACE( _T("Component::QueryDataObject: CCT_RESULT \n") );

    CComObject<CDataObject>* pDataObj;
    CComObject<CDataObject>::CreateInstance( &pDataObj );
    if( ! pDataObj )             // DataObject was not created
    {
      ASSERT(pDataObj);
      return E_OUTOFMEMORY;
    }

    // use selected node to get, "parent" folder 

    SCOPEDATAITEM Item;

    memset(&Item, 0, sizeof(Item));
    Item.mask = SDI_PARAM;
    Item.ID   = m_hSelectedScope;

    if ( S_OK != m_ipConsoleNameSpace2->GetItem(&Item) )
      return E_UNEXPECTED;

    CBaseNode *pFolder = reinterpret_cast<CBaseNode *>(Item.lParam);

    pDataObj->SetDataObject( Context, pFolder, Cookie );

    //ATLTRACE( _T("%s-Component::QueryDataObject: CCT_RESULT \n"), pFolder->GetNodeName() );


    return pDataObj->QueryInterface( IID_IDataObject,
                                   reinterpret_cast<void**>(ppDataObject) );
  }

  // else ...
  // CCT_SNAPIN_MANAGER
  // CCT_UNITIALIZED 
  ASSERT( Context == 0);  // 
  return E_UNEXPECTED;
} // end QueryDataObject()


//---------------------------------------------------------------------------
//
STDMETHODIMP CComponent::GetDisplayInfo
(
  LPRESULTDATAITEM pResultItem    // [in,out] Type of info required
)
{
  ASSERT( NULL != pResultItem );

  if( NULL == pResultItem)
    return E_UNEXPECTED;

  if (!m_bInitializedAndNotDestroyed)
  {
    ASSERT(FALSE);
    return E_UNEXPECTED;
  }

  HRESULT hr = S_OK;

  // the RDI_PARAM flag does not have to be set on input to indicate that the LPARAM is valid
  //if (!(pResultItem->mask & RDI_PARAM))
  //  return E_UNEXPECTED;

  if (pResultItem->bScopeItem)
  {     
    ASSERT(pResultItem->lParam);
    CBaseNode *pData= reinterpret_cast<CBaseNode *>(pResultItem->lParam);
    if (!pData)
      return E_UNEXPECTED;

    hr = pData->GetDisplayInfo(*pResultItem);
  }
  else
  {
    SCOPEDATAITEM Item;

    memset(&Item, 0, sizeof(Item));
    Item.mask = SDI_PARAM;
    Item.ID   = m_hSelectedScope;

    if ( !m_hSelectedScope || S_OK != m_ipConsoleNameSpace2->GetItem(&Item) || !Item.lParam)
      return E_UNEXPECTED;

    CBaseNode *pData = reinterpret_cast<CBaseNode *>(Item.lParam);

    hr = pData->GetDisplayInfo(*pResultItem);
  }

  return hr;

} // end GetDisplayInfo()


//---------------------------------------------------------------------------
// Determines what the result pane view should be
//
STDMETHODIMP CComponent::GetResultViewType
(
  MMC_COOKIE  Cookie,        // [in]  Specifies the unique identifier 
  BSTR* ppViewType,    // [out] Points to address of the returned view type
  long* pViewOptions   // [out] Pointer to the MMC_VIEW_OPTIONS enumeration
)
{
  ATLTRACE(_T("Component::GetResultViewType Cookie 0x%lX\n"), Cookie);

  if (!Cookie) // root node
    *pViewOptions = MMC_VIEW_OPTIONS_NONE;
  else
    *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

  return S_FALSE;  // Ask for default listview.

} // end GetResultViewType()


//---------------------------------------------------------------------------
//  
//
HRESULT CComponent::CompareObjects
(
  LPDATAOBJECT ipDataObjectA,  // [in] First data object to compare 
  LPDATAOBJECT ipDataObjectB   // [in] Second data object to compare
)
{
  ATLTRACE(_T("Component::CompareObjects\n"));

  if (!m_bInitializedAndNotDestroyed)
  {
    ASSERT(FALSE);
    return E_UNEXPECTED;
  }

  CDataObject *pdoA;
  CDataObject *pdoB;

  pdoA = ExtractOwnDataObject( ipDataObjectA );
  pdoB = ExtractOwnDataObject( ipDataObjectB );
  ASSERT( pdoA || pdoB );

  // If extraction failed for one of them, then that one is foreign and
  // can't be equal to the other one.  (Or else ExtractOwnDataObject
  // returned NULL because it ran out of memory, but the most conservative
  // thing to do in that case is say they're not equal.)
  if( !pdoA || !pdoB )
  {
    ATLTRACE(_T("Component::CompareObjects() - FALSE one or both objects not recognized\n") );
    return S_FALSE;
  }

  // If they differ then the objects refer to different things.

  CBaseNode *pNodeA = pdoA->GetBaseObject();
  CBaseNode *pNodeB = pdoB->GetBaseObject();

  if( pNodeA && pNodeB && pNodeA->GetNodeType() == pNodeB->GetNodeType() )
  {
    if (!pdoA->IsResultItem() && !pdoB->IsResultItem())
    {
      ATLTRACE(_T("Component::CompareObjects() - TRUE both nodes %s\n"), pNodeA->GetNodeName() );
      return S_OK;
    }
    if ( pdoA->GetResultItemCookie() == pdoB->GetResultItemCookie() )
    {
      ATLTRACE(_T("Component::CompareObjects() - TRUE both %s\n"), pNodeA->GetNodeName() );
      return S_OK;
    }
    ATLTRACE(_T("Component::CompareObjects() - FALSE both %s\n"), pNodeA->GetNodeName() );
  }
  else
  {
    ATLTRACE(_T("Component::CompareObjects() - FALSE\n") );
  }
  return S_FALSE;

} // end CompareObjects()


//---------------------------------------------------------------------------
//  Handle notifications from the console
//
STDMETHODIMP CComponent::Notify
(
  LPDATAOBJECT     ipDataObject, // [in] Points to data object
  MMC_NOTIFY_TYPE  Event,        // [in] Identifies action taken by user
  LPARAM           Arg,          // [in] Depends on the notification type
  LPARAM           Param         // [in] Depends on the notification type
)
{
  ATLTRACE( _T("Component::Notify %p 0x%X %p %p\n"), ipDataObject, Event, Arg, Param );

  if (!m_bInitializedAndNotDestroyed)
  {
    ASSERT(FALSE);
    return E_UNEXPECTED;
  }

  HRESULT hr = S_OK;

  /*
  // not all notifies set ipDataObject...  
    MMCN_ACTIVATE
    MMCN_BTN_CLICK
  //MMCN_CLICK
    MMCN_COLUMN_CLICK
  //MMCN_CONTEXTMENU
    MMCN_CUTORMOVE
    MMCN_DELETE
    MMCN_EXPAND
  //MMCN_HELP
    MMCN_MENU_BTNCLICK
    MMCN_PASTE
    MMCN_QUERY_PASTE
    MMCN_REMOVE_CHILDREN
    MMCN_RENAME
    MMCN_SELECT
    MMCN_SHOW
    MMCN_VIEW_CHANGE
    MMCN_SNAPINHELP
    MMCN_CONTEXTHELP
    MMCN_INITOCX
    MMCN_FILTER_CHANGE
    MMCN_FILTERBTN_CLICK
    MMCN_RESTORE_VIEW
    MMCN_PRINT
    MMCN_PRELOAD
    MMCN_LISTPAD
  */

  CDataObject* pDO = NULL;
  CBaseNode *pNode = NULL;

  MMC_NOTIFY_TYPE NeedDataObject[] = { MMCN_VIEW_CHANGE, MMCN_SHOW, MMCN_DBLCLICK, MMCN_SELECT, MMCN_REFRESH, MMCN_DELETE, MMCN_CONTEXTHELP };

  for(int i = 0; i < ARRAY_SIZE(NeedDataObject); i++)
  {
    if (Event == NeedDataObject[i])
    {
      pDO   = ExtractOwnDataObject(ipDataObject);
      pNode = ExtractBaseObject(ipDataObject);

      if (!pDO || !pNode)
			{
				ASSERT(FALSE);
        return E_UNEXPECTED;
			}
      break;
    }
  }

  switch( Event )
  {
    case MMCN_ADD_IMAGES: //ok
      hr = OnAddImages( ipDataObject, (IImageList *) Arg, Param );
      break;

    case MMCN_SHOW:       //ok
      //ATLTRACE( _T("Component::Notify: MMCN_SHOW\n") );
      hr = OnShow( ipDataObject, (BOOL) Arg, Param );
      break;

    case MMCN_SELECT:     //fair
      //ATLTRACE( _T("Component::Notify: MMCN_SELECT\n") );
      hr = OnSelect( ipDataObject, Arg, Param );
      break;

    case MMCN_REFRESH:
      //ATLTRACE( _T("Component::Notify: MMCN_REFRESH\n") );
      hr = OnRefresh( ipDataObject );
      break;

    case MMCN_DELETE:  // Arg and Param have no meaning
      if (pNode && pDO->IsResultItem() ) 
        hr = pNode->OnDelete(m_ipConsole2, pDO->GetResultItemCookie());
      else
        hr = E_UNEXPECTED;
      break;
    
    case MMCN_VIEW_CHANGE:
      ATLTRACE( _T("Component::Notify: MMCN_VIEW_CHANGE\n") );
      if (m_hSelectedScope == pNode->GetID() )
        hr = pNode->OnViewChange(m_ipResultData, Arg, Param);
      break;

    case MMCN_PROPERTY_CHANGE:
      ATLTRACE( _T("Component::Notify: MMCN_PROPERTY_CHANGE\n") );
      hr = OnPropertyChange( (BOOL) Arg, Param);
      break;

		case MMCN_HELP:  // obsolete
			ATLTRACE( _T("Component::Notify: MMCN_HELP unimplemented\n") );
			hr = S_FALSE;
			break;

    case MMCN_SNAPINHELP:  // obsolete
			//  11/1998 
			//    nolonger used: implement ISnapinHelp interface, then MMC will merge the snapin's help and MMC help
      ATLTRACE( _T("Component::Notify: MMCN_SNAPINHELP unimplemented\n") );
      hr = S_FALSE;
      break;

    case MMCN_CONTEXTHELP:  
			// return S_FALSE for default behavior... actually, any return value other than S_OK 
			// invokes HTMLHelp with MMC overview topic.
      ATLTRACE( _T("Component::Notify: MMCN_CONTEXTHELP\n") );
			if (pNode)
				hr = pNode->OnHelpCmd(m_ipDisplayHelp );
			else
				hr = E_UNEXPECTED;
      break;

    case MMCN_CLICK:
      ATLTRACE( _T("Component::Notify: MMCN_CLICK unimplemented\n") );
      break;

    case MMCN_DBLCLICK:      // return S_FALSE to have MMC do the default verb action...
			if (pNode && pDO->IsResultItem() )
        hr = pNode->OnDblClick(m_ipConsole2, pDO->GetResultItemCookie());
			else
				hr = S_FALSE;
      break;

    case MMCN_ACTIVATE:
      ATLTRACE( _T("Component::Notify: MMCN_ACTIVATE (%s) unimplemented\n"), Arg ? _T("activate") : _T("deactivate") );
      break;

    case MMCN_MINIMIZED:
      ATLTRACE( _T("Component::Notify: MMCN_MINIMIZED unimplemented\n") );
      break;

    case MMCN_BTN_CLICK:
      ATLTRACE( _T("Component::Notify: MMCN_BTN_CLICK unimplemented\n") );
      break;

    case MMCN_COLUMN_CLICK:
      ATLTRACE( _T("Component::Notify: MMCN_COLUMN_CLICK col: %p %s\n"), Arg, (Param == RSI_DESCENDING ) ? _T("Descending") : _T("Ascending") );
      break;

    case MMCN_COLUMNS_CHANGED:
      ATLTRACE( _T("Component::Notify: MMCN_COLUMNS_CHANGED Arg: %p, Param: %p\n"), Arg, Param );
      hr = S_OK;
      break;

    default:
      ATLTRACE( _T("Component::Notify: unhandled notify event 0x%X\n"), Event );
      hr = S_OK;
      break;
  }
  return hr;

} // end Notify()


/////////////////////////////////////////////////////////////////////////////
//  Support methods
//

//---------------------------------------------------------------------------
// handle the MMCN_SHOW message.
//
HRESULT CComponent::OnShow
(
  LPDATAOBJECT ipDataObject,   // [in] Points to data object
  BOOL         bSelected,      // [in] selected/deselected scope
  HSCOPEITEM   hScopeID        // [in] HSCOPEITEM
)
{

  ASSERT( NULL != ipDataObject );
  ASSERT( NULL != m_ipResultData );
  
  CBaseNode *pNode = ExtractBaseObject( ipDataObject) ;
  ASSERT(pNode);
  if (!pNode)
  {
    m_hSelectedScope = NULL;
    return S_FALSE;
  }

  ATLTRACE(_T("%s-MMCN_SHOW Selected=%s\n"), pNode->GetNodeName(), (bSelected ? _T("true") : _T("false")) );

  if (!bSelected) // deselected scope pane item
    m_hSelectedScope = NULL;
  else            // selected scope pane item
  {
    VERIFY(S_OK == m_ipResultData->SetViewMode( MMCLV_VIEWSTYLE_REPORT ) );
    m_hSelectedScope = hScopeID;
  }

  CJobFolder *pJobFolder = dynamic_cast<CJobFolder *> (pNode);

  if (pJobFolder)
    return pJobFolder->OnShow(bSelected, hScopeID, m_ipHeaderCtrl2, m_ipConsole2, m_ipConsoleNameSpace2);

  CJobItemFolder *pJobItemFolder = dynamic_cast<CJobItemFolder *> (pNode);
  if (pJobItemFolder)
    return pJobItemFolder->OnShow(bSelected, hScopeID, m_ipHeaderCtrl2, m_ipConsole2, m_ipConsoleNameSpace2);

  return pNode->OnShow(bSelected, hScopeID, m_ipHeaderCtrl2, m_ipConsole2);
} // end OnShow()


//---------------------------------------------------------------------------
//
HRESULT CComponent::OnAddImages
(
  LPDATAOBJECT ipDataObject, // [in] Points to the data object
  IImageList *ipImageList,   // [in] Interface pointer to IImageList
  HSCOPEITEM  hID            // [in] HSCOPEITEM of item currently selected or deselected 
)
{
  ASSERT( ipImageList );
  if (!ipImageList)
    return E_UNEXPECTED;

  HRESULT hr = ipImageList->ImageListSetStrip( (LONG_PTR *) m_hbmp16x16, (LONG_PTR *) m_hbmp32x32, 0, RGB(255,0, 255) );

  ASSERT( S_OK == hr );

  return hr;

} // end OnAddImages()

//---------------------------------------------------------------------------
//  This is a handler for the MMCN_SELECT notification.
//  MMC 1.1 documentation for IComponent::Notify MMCN_SELECT
//    claims the LPDATAOBJECT is for the scope item but
//    in reality appears to be the dataobject for whatever item/node is selected
//
HRESULT CComponent::OnSelect
(
  LPDATAOBJECT ipDataObject, // [in] Points to the data object
  LPARAM       Arg,          // [in] Contains flags about the selected item 
  LPARAM       Param         // [in] Not used
)
{
  CDataObject *pDO   = ExtractOwnDataObject( ipDataObject );
  CBaseNode   *pNode = ExtractBaseObject( ipDataObject);

  if( !m_ipConsoleVerb || !pDO || !pNode)
    return E_UNEXPECTED;

  ATLTRACE(_T("%s-MMCN_SELECT: Scope=%s, Select=%s, ResultItem=%s\n"),
    pNode->GetNodeName(), 
    (LOWORD(Arg) ? _T("true") : _T("false")),
    (HIWORD(Arg) ? _T("true") : _T("false")), 
    pDO->IsResultItem() ? _T("yes") : _T("no"));

  ASSERT(!(pDO->IsResultItem()) == (BOOL) LOWORD(Arg) );

  if (pDO->IsResultItem())
    return pNode->OnSelect(LOWORD(Arg), HIWORD(Arg), m_ipConsoleVerb, pDO->GetResultItemCookie());
  else
    return pNode->OnSelect(LOWORD(Arg), HIWORD(Arg), m_ipConsoleVerb);

} // end OnSelect()


//---------------------------------------------------------------------------
//  MMCN_REFRESH notification
//
HRESULT CComponent::OnRefresh
(
  LPDATAOBJECT ipDataObject // [in] Points to the data object 
)
{
  CBaseNode* pNode = ExtractBaseObject( ipDataObject );
  ASSERT(pNode);
  if (!pNode )
    return E_UNEXPECTED;

  ATLTRACE( _T("%s-Component::Notify: MMCN_REFRESH\n"), pNode->GetNodeName() );

  if (m_hSelectedScope != pNode->GetID() )
  {
    ATLTRACE( _T("Attempt patch of framework!\n"));
    //OnShow(ipDataObject, TRUE, pNode->GetID());
    m_ipConsole2->SelectScopeItem(pNode->GetID());
  }

  CJobFolder *pJobFolder = dynamic_cast<CJobFolder *> (pNode);
  if (pJobFolder)
    return pJobFolder->OnRefresh(m_ipConsole2, m_ipConsoleNameSpace2);

  return pNode->OnRefresh(m_ipConsole2);
} // end OnRefresh()

//---------------------------------------------------------------------------
//  MMCN_PROPERTY_CHANGE notification
//
HRESULT CComponent::OnPropertyChange
( 
  BOOL bScopeItem, 
  LPARAM Param
)                            
{
  if (bScopeItem)
	{
		ASSERT(FALSE);  // what is this path being used by?
    return S_OK;
	}

  PROPERTY_CHANGE_HDR *pUpdate = reinterpret_cast<PROPERTY_CHANGE_HDR*>(Param);

  if (pUpdate )
  {
    if (pUpdate->pFolder && !pUpdate->bScopeItem)
    {
      SCOPEDATAITEM Item;

      memset(&Item, 0, sizeof(Item));
      Item.mask = SDI_PARAM;
      Item.ID   = m_hSelectedScope;

      if ( m_hSelectedScope && S_OK == m_ipConsoleNameSpace2->GetItem(&Item) && 
           reinterpret_cast<CBaseNode *>(Item.lParam) == pUpdate->pFolder )
      {
        pUpdate->pFolder->OnPropertyChange(pUpdate, m_ipConsole2);
      }
    }
    pUpdate = FreePropChangeInfo(pUpdate);
  }

  return S_OK;
  
} // end OnPropertyChange()

#ifdef USE_IRESULTDATACOMPARE
/////////////////////////////////////////////////////////////////////////////
//  IResultDataCompare method implementations
//
STDMETHODIMP CComponent::Compare(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int * pnResult )
{

  ATLTRACE( _T("Component::Compare %p %p %p\n"), lUserParam, cookieA, cookieB );
	SCOPEDATAITEM Item;

  memset(&Item, 0, sizeof(Item));
  Item.mask = SDI_PARAM;
  Item.ID   = m_hSelectedScope;

  if ( S_OK != m_ipConsoleNameSpace2->GetItem(&Item) )
    return E_UNEXPECTED;

  CBaseNode *pFolder = reinterpret_cast<CBaseNode *>(Item.lParam);

	if (!pFolder)
		return E_UNEXPECTED;

	return pFolder->ResultDataCompare(lUserParam, cookieA, cookieB, pnResult);
}
#endif

/////////////////////////////////////////////////////////////////////////////
//  IExtendContextMenu method implementations
//
STDMETHODIMP CComponent::AddMenuItems
( 
  LPDATAOBJECT           ipDataObject,     // [in] Points to data object
  LPCONTEXTMENUCALLBACK  piCallback,       // [in] Pointer to IContextMenuCallback
  long*                  pInsertionAllowed // [in,out] Insertion flags
)
{
  ASSERT( NULL != ipDataObject );

  if (!m_bInitializedAndNotDestroyed)
  {
    ASSERT(FALSE);
    return E_UNEXPECTED;
  }

	if (IsMMCMultiSelectDataObject(ipDataObject))
    return E_UNEXPECTED;

  CDataObject *pDO;
  CBaseNode   *pNode;

  VERIFY(pDO   = ExtractOwnDataObject( ipDataObject ));
  VERIFY(pNode = ExtractBaseObject(    ipDataObject ));

  if (!pDO || !pNode)
    return E_UNEXPECTED;

  if (pDO->IsResultItem())
    return pNode->AddMenuItems(piCallback, pInsertionAllowed, pDO->GetResultItemCookie() );
  else
    return pNode->AddMenuItems(piCallback, pInsertionAllowed );

} // end AddMenuItems()

/////////////////////////////////////////////////////////////////////////////
//  IExtendContextMenu method implementations
//
STDMETHODIMP CComponent::Command
(
  long nCommandID,           // [in] Command to handle
  LPDATAOBJECT ipDataObject  // [in] Points to data object, pass through
)
{
  if (!m_bInitializedAndNotDestroyed)
  {
    ASSERT(FALSE);
    return E_UNEXPECTED;
  }

  HRESULT hr = S_FALSE;

  CDataObject *pDO   = ExtractOwnDataObject( ipDataObject );
  CBaseNode   *pNode = ExtractBaseObject( ipDataObject);
  
  if (!pDO || !pNode)
    return S_FALSE;

  if ( pDO->IsResultItem() )
    hr = pNode->OnMenuCommand(m_ipConsole2, nCommandID, pDO->GetResultItemCookie() );
  else
  {
    CJobFolder *pJobFolder = dynamic_cast<CJobFolder *> (pNode);
    if (pJobFolder)
      hr = pJobFolder->OnMenuCommand(m_ipConsole2, m_ipConsoleNameSpace2, nCommandID);
    else 
      hr = pNode->OnMenuCommand(m_ipConsole2, nCommandID );
  }
  
  if (hr == S_OK)  // already successfully handled
    return hr;

  ATLTRACE(_T("Component::Command - unrecognized or failed command %d\n"), nCommandID);

  return hr;

} // end Command()


/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet2 implementation
//

//---------------------------------------------------------------------------
// The console calls this method to determine whether the Properties menu
// item should be added to the context menu.  We added the Properties item
// by enabling the verb.  So long as we have a vaild DataObject we
// can return OK.
//

HRESULT CComponent::QueryPagesFor
(
  LPDATAOBJECT ipDataObject  // [in] Points to IDataObject for selected node  
)
{
  if (!m_bInitializedAndNotDestroyed)
  {
    ASSERT(FALSE);
    return E_UNEXPECTED;
  }

  CDataObject *pDO   = ExtractOwnDataObject( ipDataObject );
  CBaseNode   *pNode = ExtractBaseObject( ipDataObject);
  if (!pDO || !pNode)
    return S_FALSE;

  if (pDO->IsResultItem())
    return pNode->QueryPagesFor(pDO->GetResultItemCookie());
  else
    return pNode->QueryPagesFor();

} // end QueryPagesFor()

HRESULT CComponent::CreatePropertyPages 
(
  LPPROPERTYSHEETCALLBACK lpProvider,    // Pointer to the callback interface
  LONG_PTR                handle,        // Handle for routing notification
  LPDATAOBJECT            ipDataObject   // Pointer to the data object
)
{
  ASSERT( NULL != lpProvider );

  if (!m_bInitializedAndNotDestroyed)
  {
    ASSERT(FALSE);
    return E_UNEXPECTED;
  }

  CDataObject *pDO   = ExtractOwnDataObject( ipDataObject );
  CBaseNode   *pNode = ExtractBaseObject( ipDataObject);

  if (!pDO || !pNode)
    return S_FALSE;

  if (pDO->IsResultItem())
    return pNode->OnCreatePropertyPages(lpProvider, handle, pDO->GetContext(), pDO->GetResultItemCookie());
  else
    return pNode->OnCreatePropertyPages(lpProvider, handle, pDO->GetContext());

} // end CreatePropertyPages()


HRESULT CComponent::GetWatermarks
(
	LPDATAOBJECT lpIDataObject,
  HBITMAP *lphWatermark,
  HBITMAP * lphHeader,
  HPALETTE * lphPalette,
  BOOL* bStretch
)
{
	ATLTRACE(_T("\n\nComponent::GetWatermarks\n\n"));

  if (!m_bInitializedAndNotDestroyed)
  {
    ASSERT(FALSE);
    return E_UNEXPECTED;
  }

	// no indication this method has ever been invoked

  *lphWatermark = NULL;
  *lphHeader    = NULL;
  *lphPalette   = NULL;
  *bStretch     = FALSE;
  return S_OK;
} // end GetWatermarks()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\basenode.h ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    BaseNode.h                                                               //
|                                                                                       //
|Description:  Class definitions for all container nodes                                //
|                                                                                       //
|Created:      Paul Skoglund 07-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/


#ifndef _CLASS_BASENODE_
#define _CLASS_BASENODE_

#include "resource.h"
#include "HelpTopics.h"
#include "DataObj.h"

#pragma warning(push)
#include <string>
#pragma warning(pop)
#pragma warning(push)
#pragma warning(4 : 4284)
#include <list>
#pragma warning(pop)

using std::basic_string;
using std::list;

typedef basic_string<TCHAR> tstring;

typedef struct  _CONTEXTMENUITEMBYID
{
	int  strNameID;
  int  strStatusBarTextID;
  LONG lCommandID;
  LONG lInsertionPointID;
}	CONTEXTMENUITEMBYID;

typedef enum tagNODETYPE {
  UNINIZALIZED_NODE         = 0x00L,
  ROOT_NODE                 = 0x01L,
    MANAGEMENTRULE_NODE     = 0x02L,
      NAMERULE_NODE         = 0x04L,
      PROCESSRULE_NODE      = 0x08L,
      JOBRULE_NODE          = 0x10L,
    PROCESS_NODE            = 0x20L,
    JOB_NODE                = 0x40L,
      JOBITEM_NODE          = 0x80L,
} NODETYPE;

typedef enum _PC_VIEW_UPDATE_HINT
{
  PC_VIEW_UPDATEALL         = 0x1,       // cache has been invalidated
  PC_VIEW_SETITEM          	= 0x2,       // cache is valid, set single item
	PC_VIEW_UPDATEITEM	      = 0x4,       // cache is valid, update single item
	PC_VIEW_ADDITEM   	      = 0x8,       // cache is valid, add single item
  PC_VIEW_DELETEITEM 	      = 0x10,      // cache is valid, remove single item
  PC_VIEW_REDRAWALL         = 0x11,      // cache is valid, redraw all items
}	PC_VIEW_UPDATE_HINT;

const int PROCESS_ALIAS_COLUMN_WIDTH          = 140; 
const int DESCRIPTION_COLUMN_WIDTH            = 200;
const int MATCH_COLUMN_WIDTH                  = 200;
const int TYPE_COLUMN_WIDTH                   = 110;
const int NAME_COLUMN_WIDTH                   = 225;
const int APPLY_JOB_COLUMN_WIDTH              = 155;
const int JOB_COLUMN_WIDTH                    = 140;
const int APPLY_AFFINITY_COLUMN_WIDTH         = 95;
const int AFFINITY_COLUMN_WIDTH               = 130;
const int APPLY_PRIORITY_COLUMN_WIDTH         = 100;
const int PRIORITY_COLUMN_WIDTH               = 95;
const int APPLY_SCHEDULING_CLASS_COLUMN_WIDTH = 150;
const int SCHEDULING_CLASS_COLUMN_WIDTH       = 120;
const int IMAGE_NAME_COLUMN_WIDTH             = 120;
const int PID_COLUMN_WIDTH                    = 50;
const int ACTIVE_PROCESS_COUNT_COLUMN_WIDTH   = 115;
const int STATUS_COLUMN_WIDTH                 = 65;
const int JOB_OWNER_COLUMN_WIDTH              = 105;
const int APPLY_MINMAXWS_COLUMN_WIDTH         = 100;
const int MINWS_COLUMN_WIDTH                  = 115;
const int MAXWS_COLUMN_WIDTH                  = 115;
const int APPLY_PROC_CMEM_LIMIT_COLUMN_WIDTH  = 200;
const int PROC_CMEM_LIMIT_COLUMN_WIDTH        = 195;
const int APPLY_JOB_CMEM_LIMIT_COLUMN_WIDTH   = 195;
const int JOB_CMEM_LIMIT_COLUMN_WIDTH         = 185;
const int APPLY_PROCCOUNT_LIMIT_COLUMN_WIDTH  = 160;
const int PROCCOUNT_LIMIT_COLUMN_WIDTH        = 120;
const int APPLY_PROC_CPUTIME_LIMIT_COLUMN_WIDTH=170;
const int PROC_CPUTIME_LIMIT_COLUMN_WIDTH     = 150;
const int APPLY_JOB_CPUTIME_LIMIT_COLUMN_WIDTH= 150;
const int JOB_CPUTIME_LIMIT_COLUMN_WIDTH      = 150;
const int ACTION_JOB_CPUTIME_LIMIT_COLUMN_WIDTH=165;
const int ENDJOB_ON_NO_PROC_COLUMN_WIDTH      = 180;
const int DIE_ON_UNHANDLED_EXCEPT_COLUMN_WIDTH= 150;
const int ALLOW_BREAKAWAY_COLUMN_WIDTH        = 150;
const int ALLOW_SILENT_BREAKAWAY_COLUMN_WIDTH = 165;

const int USER_TIME_COLUMN_WIDTH              = 105;
const int KERNEL_TIME_COLUMN_WIDTH            = 105;
const int CREATE_TIME_COLUMN_WIDTH            = 130;

const int PERIOD_USER_TIME_COLUMN_WIDTH       = 130;
const int PERIOD_KERNEL_TIME_COLUMN_WIDTH     = 140;
const int PAGE_FAULT_COUNT_COLUMN_WIDTH       = 100;
const int PROCESS_COUNT_COLUMN_WIDTH          = 110;
const int TERMINATED_PROCESS_COUNT_COLUMN_WIDTH=140;
const int READOP_COUNT_COLUMN_WIDTH           = 120;
const int WRITEOP_COUNT_COLUMN_WIDTH          = 120;
const int OTHEROP_COUNT_COLUMN_WIDTH          = 120;
const int READTRANS_COUNT_COLUMN_WIDTH        = 140;
const int WRITETRANS_COUNT_COLUMN_WIDTH       = 140;
const int OTHERTRANS_COUNT_COLUMN_WIDTH       = 140;
const int PEAK_PROC_MEM_COLUMN_WIDTH          = 160;
const int PEAK_JOB_MEM_COLUMN_WIDTH           = 150;

// Scope node image numbers
const int PROCCON_SNAPIN_IMAGE     = 0;
const int PROCCON_SNAPIN_OPENIMAGE = 0;
const int RULES_IMAGE              = 1;
const int RULES_OPENIMAGE          = 1;
const int ALIASRULES_IMAGE         = 2;
const int ALIASRULES_OPENIMAGE     = 2;
const int PROCRULES_IMAGE          = 3;
const int PROCRULES_OPENIMAGE      = 3;
const int JOBRULES_IMAGE           = 4;
const int JOBRULES_OPENIMAGE       = 4;
const int PROCESSES_IMAGE          = 5;
const int PROCESSES_OPENIMAGE      = 5;
const int JOBS_IMAGE               = 6;
const int JOBS_OPENIMAGE           = 6;
const int ITEMIMAGE_ERROR          = 11;
const int EMPTY_IMAGE              = 12;

const int PROCESSRULEITEMIMAGE       = PROCRULES_IMAGE;
const int JOBRULEITEMIMAGE           = JOBRULES_IMAGE;

const int PROCITEMIMAGE              = 7;
const int PROCITEMIMAGE_NODEFINITION = EMPTY_IMAGE;    // 8;

const int JOBITEMIMAGE               = 9;
const int JOBITEMIMAGE_NODEFINITION  = 10;
const int JOBIMAGE_NODEFINITION      = 10;

const int FOLDER                     = 13;
const int OPEN_FOLDER                = 14;


HRESULT InsertProcessHeaders(IHeaderCtrl2* ipHeaderCtrl);
HRESULT PCProcListGetDisplayInfo(RESULTDATAITEM &ResultItem, const PCProcListItem &ref, ITEM_STR &StorageStr);


class CBaseNode
{
  private:
    CBaseNode();

  public:
    CBaseNode(NODETYPE nNodeType, CBaseNode *pParent = NULL ) : 
        m_NodeType(nNodeType), m_pParent(pParent), nUpdateCtr(0), m_refcount(1)
    {
    }
    virtual ~CBaseNode() { ATLTRACE(_T("~CBaseNode\n"));}

    void AddRef()
    {
      ++m_refcount;
    }
    void Release()
    {
      if (--m_refcount == 0)
        delete this;
    }

    virtual LPCTSTR GetNodeName() = 0;
    virtual HRESULT GetDisplayInfo(RESULTDATAITEM &ResultItem) = 0;

    virtual const GUID  *GetGUIDptr() = 0;
    virtual const TCHAR *GetGUIDsz()  = 0;
    virtual BOOL  IsPersisted()       = 0;        // support for CCF_SNODEID, and CCF_SNODEID2 formats
    virtual BOOL  GetPreload() { return FALSE; }  // support for CCF_SNAPIN_PRELOADS format
    

    virtual const int sImage() = 0;
    virtual const int sOpenImage() = 0;

    virtual void        SetID(HSCOPEITEM ID) = 0;
    virtual HSCOPEITEM  GetID()              = 0;
    virtual int         GetChildrenCount() { return 0; } 

    virtual CBaseNode* GetParentNode() { return m_pParent; }

    virtual const TCHAR *GetWindowTitle()         // support for CCF_WINDOW_TITLE format
    {
      if ( !GetParentNode() )
      {
        ASSERT(FALSE);  // the parent node must override this function and provide the handle!
        return _T("");
      }

      CBaseNode *pParent = GetParentNode();
      while (pParent->GetParentNode())
        pParent = pParent->GetParentNode();
    
      return pParent->GetNodeName();
    }

		virtual void GetComputerConnectionInfo(COMPUTER_CONNECTION_INFO &out)
		{
      if ( !GetParentNode() )
      {
				out.bLocalComputer = FALSE;
				memcpy(out.RemoteComputer, 0, sizeof(out.RemoteComputer));
        ASSERT(FALSE);  // the parent node must override this function and provide the handle!
        return;
      }

      CBaseNode *pParent = GetParentNode();
      while (pParent->GetParentNode())
        pParent = pParent->GetParentNode();
    
      pParent->GetComputerConnectionInfo(out);      
		}

    virtual const PCid GetPCid()
    {
      if ( !GetParentNode() )
      {
        ASSERT(FALSE);  // the parent node must override this function and provide the handle!
        return NULL;
      }

      CBaseNode *pParent = GetParentNode();
      while (pParent->GetParentNode())
        pParent = pParent->GetParentNode();
    
      return pParent->GetPCid();      
    }

    virtual BOOL ReportPCError(PCULONG32 nLastError)
    {
      if ( !GetParentNode() )
      {
        ASSERT(FALSE);  // the parent node must override this function and provide the handle!
        return FALSE;
      }

      CBaseNode *pParent = GetParentNode();
      while (pParent->GetParentNode())
        pParent = pParent->GetParentNode();
    
      return pParent->ReportPCError(nLastError);      
    }


    virtual BOOL ReportPCError()
    {
      if ( !GetParentNode() )
      {
        ASSERT(FALSE);  // the parent node must override this function and provide the handle!
        return FALSE;
      }

      CBaseNode *pParent = GetParentNode();
      while (pParent->GetParentNode())
        pParent = pParent->GetParentNode();
    
      return pParent->ReportPCError();      
    }

    virtual PCULONG32 GetLastPCError()
    {
      if ( !GetParentNode() )
      {
        ASSERT(FALSE);  // the parent node must override this function and provide the handle!
        return FALSE;
      }

      CBaseNode *pParent = GetParentNode();
      while (pParent->GetParentNode())
        pParent = pParent->GetParentNode();
    
      return pParent->GetLastPCError();      
    }

    //IComponentData::Notify
    virtual HRESULT OnExpand(BOOL bExpand, HSCOPEITEM hItem, IConsoleNameSpace2 *ipConsoleNameSpace2) { return S_OK;    } // return value not used
    virtual HRESULT OnRename(LPOLESTR pszNewName)                                                   { return S_FALSE; } // rename not allowed
    virtual HRESULT OnRemoveChildren(HSCOPEITEM hID)                                                { return S_OK;    } // return value not used 

    //IComponent::Notify
    virtual HRESULT OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2* ipHeaderCtrl, IConsole2 *ipConsole2) { ASSERT(hItem == GetID()); return S_OK; } // return value used
    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb)                { return S_OK;    } // return value not used
    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie) { return S_OK;    } // return value not used
    virtual HRESULT OnDelete  (IConsole2 *ipConsole2, LPARAM Cookie)    { return S_FALSE; } // return value not used
		virtual HRESULT OnDblClick(IConsole2 *ipConsole2, LPARAM Cookie)    { return S_FALSE; } // return S_FALSE to get default verb
    virtual HRESULT OnHelpCmd(IDisplayHelp *ipDisplayHelp)  { return S_FALSE; } // return value not used
    virtual HRESULT OnRefresh(IConsole2 *ipConsole2)        { return S_FALSE; } // return value not used

    virtual HRESULT OnViewChange(IResultData *ipResultData, LPARAM data, LONG_PTR hint) { return S_OK; }

#ifdef USE_IRESULTDATACOMPARE
		//IResultDataCompare
		virtual HRESULT ResultDataCompare(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int * pnResult ) { return E_UNEXPECTED; }
#endif

    //IExtendContextMenu::Command
    virtual HRESULT AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed)                { return S_OK; }
    virtual HRESULT AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed, LPARAM Cookie) { return S_OK; }
    virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, long nCommandID)                               { return E_UNEXPECTED; }
    virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, long nCommandID, LPARAM Cookie)                { return E_UNEXPECTED; }

    //IExtendPropertySheet2
    virtual HRESULT OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, DATA_OBJECT_TYPES context)                { return S_FALSE; }
    virtual HRESULT OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, DATA_OBJECT_TYPES context, LPARAM Cookie) { return S_FALSE; }
    virtual HRESULT QueryPagesFor()              { return S_FALSE; } 
    virtual HRESULT QueryPagesFor(LPARAM Cookie) { return S_FALSE; } 
    // GetWatermarks handled at "global" level in CComponent, CComponentData   

    virtual HRESULT SendViewChange(IConsole2 *ipConsole2, LPARAM ResultCookie, PC_VIEW_UPDATE_HINT hint)
    {
      ASSERT(ipConsole2);
      if (!ipConsole2)
        return E_UNEXPECTED;

      ASSERT( ((hint == PC_VIEW_UPDATEALL || hint == PC_VIEW_REDRAWALL) && !ResultCookie) || 
              ((hint != PC_VIEW_UPDATEALL && hint != PC_VIEW_REDRAWALL) &&  ResultCookie) );

      LPDATAOBJECT             ipDataObject = NULL;
      CComObject<CDataObject>* pDataObj;
      CComObject<CDataObject>::CreateInstance( &pDataObj );
      if( ! pDataObj )             // DataObject was not created
      {
        ASSERT(pDataObj);
        return E_OUTOFMEMORY;
      }

      pDataObj->SetDataObject( CCT_RESULT, this );

      HRESULT hr = pDataObj->QueryInterface( IID_IDataObject, (void **)&ipDataObject);

      if (hr == S_OK)
        hr = ipConsole2->UpdateAllViews(ipDataObject, ResultCookie, hint);

      ipDataObject->Release();

      ASSERT(hr == S_OK);
      return hr;
    }

    virtual HRESULT OnPropertyChange(PROPERTY_CHANGE_HDR *pUpdate, IConsole2 *ipConsole2) 
    { 
      ATLTRACE(_T("Unhandled OnPropertyChange for %s.\n"), GetNodeName());
      return E_UNEXPECTED; 
    }
       
    virtual const NODETYPE GetNodeType() { return m_NodeType; }  // should try and remove the need for this...

  private:
    NODETYPE m_NodeType;           // Describes the node type
    CBaseNode *m_pParent;
    int        m_refcount;

  protected:
     PCINT32     nUpdateCtr;
     
}; // end class CBaseNode

class CRootFolder : public CBaseNode
{
  public:
    CRootFolder();
    virtual ~CRootFolder();

  private:
    static const GUID         m_GUID;
    static const TCHAR *const m_szGUID;

  public:
    virtual LPCTSTR GetNodeName();
    virtual HRESULT GetDisplayInfo(RESULTDATAITEM &ResultItem);

    virtual const GUID  *GetGUIDptr() { return &m_GUID;  } 
    virtual const TCHAR *GetGUIDsz()  { return m_szGUID; }
    virtual BOOL  IsPersisted()       { return TRUE;     }

    virtual const int sImage()     { return PROCCON_SNAPIN_IMAGE; }
    virtual const int sOpenImage() { return PROCCON_SNAPIN_IMAGE; }

    virtual void        SetID(HSCOPEITEM ID)     { m_ID = ID;   }
    virtual HSCOPEITEM  GetID()                  { return m_ID; }
    virtual int         GetChildrenCount()       { return 3; } 

    virtual const PCid GetPCid();
    virtual BOOL       ReportPCError();
    virtual BOOL       ReportPCError(PCULONG32 nLastError);
    virtual PCULONG32  GetLastPCError();

    virtual HRESULT OnParentExpand(BOOL bExpand, HSCOPEITEM hItem, IConsoleNameSpace2 *ipConsoleNameSpace2);
    virtual HRESULT OnExpand(BOOL bExpand, HSCOPEITEM hItem, IConsoleNameSpace2 *ipConsoleNameSpace2 );
    virtual HRESULT OnParentRemoveChildren(HSCOPEITEM hID);
    virtual HRESULT OnRemoveChildren(HSCOPEITEM hID);

    virtual HRESULT AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed);
    virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, long nCommandID);
    virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, long nCommandID, LPARAM Cookie);

    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb);
    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie);
		virtual HRESULT OnHelpCmd(IDisplayHelp *ipDisplayHelp);

    virtual HRESULT OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, DATA_OBJECT_TYPES context);
    virtual HRESULT QueryPagesFor();

    virtual HRESULT OnPropertyChange(PROPERTY_CHANGE_HDR *pUpdate, IConsole2 *ipConsole2);

    void Config(BOOL bUseLocal, TCHAR Computer[SNAPIN_MAX_COMPUTERNAME_LENGTH + 1]);
    void SetConsoleInterface(LPCONSOLE ipConsole2) { m_ipConsole2 = ipConsole2; }
    
  private:
    HSCOPEITEM         m_ID;
    HSCOPEITEM         m_ParentID;  // when the snapin is an extension, we have a parent in the scope pane
    list<CBaseNode *>  m_NodeList;
    ITEM_STR           m_name;
    tstring            m_machinedisplayname;
    tstring            m_longname;  // Node's display name including computer context...

 	  //ITEM_STR           m_TypeDescriptionStr;
    ITEM_STR           m_DescriptionStr;

    BOOL               m_bUseLocalComputer;
    TCHAR              m_Computer[SNAPIN_MAX_COMPUTERNAME_LENGTH + 1];
    BOOL               m_bDirty;

    PCid               m_hPC;                      // handle to service 
    PCULONG32          m_PCLastError;
    LPCONSOLE          m_ipConsole2;

    static const CONTEXTMENUITEMBYID TaskMenuItems[];    
  
  private:    
    HRESULT AddNodes(IConsoleNameSpace2 *ipConsoleNameSpace2);
    HRESULT AddNode (IConsoleNameSpace2 *ipConsoleNameSpace2, CBaseNode *pSubNode);
    void    FreeNodes();

    LPCTSTR GetComputerDisplayName() const;
    HRESULT OnChangeComputerConnection();    
    
  public:
    LPCTSTR GetComputerName() const;

    void    SetComputerName(TCHAR Computer[SNAPIN_MAX_COMPUTERNAME_LENGTH + 1]);
		virtual void GetComputerConnectionInfo(COMPUTER_CONNECTION_INFO &out);

    // IStream implementation
    HRESULT IsDirty() const;
    HRESULT Load(IStream *pStm);
    HRESULT Save(IStream *pStm, BOOL fClearDirty);
    HRESULT GetSizeMax(ULARGE_INTEGER *pcbSize);
}; // end class CRootFolder


class CRuleFolder : public CBaseNode
{
  public:
    CRuleFolder(CBaseNode *pParent);
    virtual ~CRuleFolder();

  private:
    static const GUID         m_GUID;
    static const TCHAR *const m_szGUID;

  public:
    virtual LPCTSTR GetNodeName();
    virtual HRESULT GetDisplayInfo(RESULTDATAITEM &ResultItem);

    virtual const GUID  *GetGUIDptr() { return &m_GUID;  } 
    virtual const TCHAR *GetGUIDsz()  { return m_szGUID; }
    virtual BOOL  IsPersisted()       { return TRUE;     }

    virtual const int sImage()     { return RULES_IMAGE;     }
    virtual const int sOpenImage() { return RULES_OPENIMAGE; }

    virtual void        SetID(HSCOPEITEM ID)     { m_ID = ID;   }
    virtual HSCOPEITEM  GetID()                  { return m_ID; }
    virtual int         GetChildrenCount()       { return 3; }  //$$ determine dynamically...although really only zero/non-zero critical

    virtual HRESULT OnExpand(BOOL bExpand, HSCOPEITEM hItem, IConsoleNameSpace2 *ipConsoleNameSpace2);
    virtual HRESULT OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2* ipHeaderCtrl, IConsole2* ipConsole2);

    virtual HRESULT OnViewChange(IResultData *ipResultData, LPARAM thing, LONG_PTR hint);
    virtual HRESULT ShowAllItems(IResultData* ipResultData, BOOL bCacheValid);

    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb);
    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie);
		virtual HRESULT OnHelpCmd(IDisplayHelp *ipDisplayHelp);


  private:
    HSCOPEITEM m_ID;
    list<CBaseNode *> m_NodeList;

    ITEM_STR m_name;         // Node's display name

    enum {
      NAME_COLUMN,
    };


    HRESULT AddNode (IConsoleNameSpace2 *ipConsoleNameSpace2, CBaseNode *pSubNode);
    void    FreeNodes();

}; // end class CRuleFolder


class CNameRuleFolder : public CBaseNode
{
  public:
    CNameRuleFolder(CBaseNode *pParent);
    virtual ~CNameRuleFolder(); 

  private:
    static const GUID         m_GUID;
    static const TCHAR *const m_szGUID;

  public:
    virtual LPCTSTR GetNodeName();   
    virtual HRESULT GetDisplayInfo(RESULTDATAITEM &ResultItem);

    virtual const GUID  *GetGUIDptr() { return &m_GUID;  } 
    virtual const TCHAR *GetGUIDsz()  { return m_szGUID; }
    virtual BOOL  IsPersisted()       { return TRUE;     }

    virtual const int sImage()     { return ALIASRULES_IMAGE;     }
    virtual const int sOpenImage() { return ALIASRULES_OPENIMAGE; }

    virtual void        SetID(HSCOPEITEM ID)     { m_ID = ID;   }
    virtual HSCOPEITEM  GetID()                  { return m_ID; }

    virtual HRESULT AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed);
    virtual HRESULT AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed, LPARAM Cookie);
    virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, long nCommandID);
    virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, long nCommandID, LPARAM Cookie);
    virtual HRESULT OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2* ipHeaderCtrl, IConsole2* ipConsole2);
    virtual HRESULT OnDelete  (IConsole2 *ipConsole2, LPARAM Cookie);
		virtual HRESULT OnDblClick(IConsole2 *ipConsole2, LPARAM Cookie);
    virtual HRESULT OnRefresh (IConsole2 *ipConsole2);

    virtual HRESULT OnViewChange(IResultData *ipResultData, LPARAM data, LONG_PTR hint);
    virtual HRESULT ShowAllItems(IResultData* ipResultData, BOOL bCacheValid);

    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb);
    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie);
		virtual HRESULT OnHelpCmd(IDisplayHelp *ipDisplayHelp);

  private:
    HSCOPEITEM m_ID;
    ITEM_STR   m_name;
	  ITEM_STR   m_ResultStr;

    enum {      
      PROCESS_ALIAS_COLUMN, 
			DESCRIPTION_COLUMN,
      MATCH_COLUMN,
      TYPE_COLUMN
    };

    list<PCNameRule *> Cache;
    list<PCNameRule *> MemBlocks;
    static const CONTEXTMENUITEMBYID ResultsTopMenuItems[];

    BOOL OnInsertNameRule(IConsole2 *ipConsole2, PCNameRule *InsertPoint);
		HRESULT OnEdit(IConsole2 *ipConsole2,PCNameRule *InsertPoint, INT32 index, BOOL bReadOnly);

    void ClearCache();
    BOOL RefreshCache();

}; // end class CNameRuleFolder


class CProcessRuleFolder : public CBaseNode
{
  public:
    CProcessRuleFolder(CBaseNode *pParent);
    virtual ~CProcessRuleFolder();

  private:
    static const GUID         m_GUID;
    static const TCHAR *const m_szGUID;

  public:
    virtual LPCTSTR GetNodeName();
    virtual HRESULT GetDisplayInfo(RESULTDATAITEM &ResultItem);

    virtual const GUID  *GetGUIDptr() { return &m_GUID;  } 
    virtual const TCHAR *GetGUIDsz()  { return m_szGUID; }
    virtual BOOL  IsPersisted()       { return TRUE;     }

    virtual const int sImage()     { return PROCRULES_IMAGE;  }
    virtual const int sOpenImage() { return PROCRULES_OPENIMAGE; }

    virtual void        SetID(HSCOPEITEM ID)     { m_ID = ID;   }
    virtual HSCOPEITEM  GetID()                  { return m_ID; }

    virtual HRESULT AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed);    
    virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, long nCommandID);
    virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, long nCommandID, LPARAM Cookie);
    virtual HRESULT OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2 *ipHeaderCtrl, IConsole2 *ipConsole2);
    virtual HRESULT OnDelete (IConsole2 *ipConsole2, LPARAM Cookie);
    virtual HRESULT OnRefresh(IConsole2 *ipConsole2);

    virtual HRESULT OnViewChange(IResultData *ipResultData, LPARAM data, LONG_PTR hint);
    virtual HRESULT ShowAllItems(IResultData* ipResultData, BOOL bCacheValid);

    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb);
    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie);
		virtual HRESULT OnHelpCmd(IDisplayHelp *ipDisplayHelp);

    virtual HRESULT OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, DATA_OBJECT_TYPES context, LPARAM Cookie);
    virtual HRESULT QueryPagesFor(LPARAM Cookie);
		virtual HRESULT OnPropertyChange(PROPERTY_CHANGE_HDR *pUpdate, IConsole2 *ipConsole2);

  private:
    HSCOPEITEM m_ID;
    ITEM_STR   m_name;         // Node's display name
	  ITEM_STR   m_ResultStr;

    enum {
      PROCESS_ALIAS_COLUMN,
			DESCRIPTION_COLUMN,
      APPLY_JOB_COLUMN,
      JOB_COLUMN,
      APPLY_AFFINITY_COLUMN,
      AFFINITY_COLUMN,
      APPLY_PRIORITY_COLUMN,
      PRIORITY_COLUMN,
      APPLY_MINMAXWS_COLUMN,
      MINWS_COLUMN,
      MAXWS_COLUMN,
    };

    list<PCProcSummary *> Cache;
    list<PCProcSummary *> MemBlocks;
    static const CONTEXTMENUITEMBYID TopMenuItems[];
    static const CONTEXTMENUITEMBYID NewMenuItems[];

    void ClearCache();
    BOOL RefreshCache();

}; // end class CProcessRuleFolder

class CJobRuleFolder : public CBaseNode
{
  public:
    CJobRuleFolder(CBaseNode *pParent);
    virtual ~CJobRuleFolder();

  private:
    static const GUID         m_GUID;
    static const TCHAR *const m_szGUID;

  public:
    virtual LPCTSTR GetNodeName();
    virtual HRESULT GetDisplayInfo(RESULTDATAITEM &ResultItem);

    virtual const GUID  *GetGUIDptr() { return &m_GUID;  } 
    virtual const TCHAR *GetGUIDsz()  { return m_szGUID; }
    virtual BOOL  IsPersisted()       { return TRUE;     }

    virtual const int sImage()     { return JOBRULES_IMAGE;     }
    virtual const int sOpenImage() { return JOBRULES_OPENIMAGE; }

    virtual void        SetID(HSCOPEITEM ID)     { m_ID = ID;   }
    virtual HSCOPEITEM  GetID()                  { return m_ID; }

    virtual HRESULT AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed);
    virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, long nCommandID);
    virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, long nCommandID, LPARAM Cookie);
    virtual HRESULT OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2* ipHeaderCtrl, IConsole2 *ipConsole2);
    virtual HRESULT OnDelete (IConsole2 *ipConsole2, LPARAM Cookie);
    virtual HRESULT OnRefresh(IConsole2 *ipConsole2);

    virtual HRESULT OnViewChange(IResultData *ipResultData, LPARAM data, LONG_PTR hint);
    virtual HRESULT ShowAllItems(IResultData* ipResultData, BOOL bCacheValid);

    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb);
    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie);
		virtual HRESULT OnHelpCmd(IDisplayHelp *ipDisplayHelp);

    virtual HRESULT OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, DATA_OBJECT_TYPES context, LPARAM Cookie);
    virtual HRESULT QueryPagesFor(LPARAM Cookie);
		virtual HRESULT OnPropertyChange(PROPERTY_CHANGE_HDR *pUpdate, IConsole2 *ipConsole2);

  private:
    HSCOPEITEM m_ID;
    ITEM_STR   m_name;         // Node's display name
	  ITEM_STR   m_ResultStr;

    enum {
      JOB_COLUMN,
			DESCRIPTION_COLUMN,
      APPLY_AFFINITY_COLUMN,
      AFFINITY_COLUMN,
      APPLY_PRIORITY_COLUMN,
      PRIORITY_COLUMN,
			APPLY_SCHEDULING_CLASS_COLUMN, 
			SCHEDULING_CLASS_COLUMN, 
      APPLY_MINMAXWS_COLUMN,
      MINWS_COLUMN,
      MAXWS_COLUMN,
      APPLY_PROC_CMEM_LIMIT_COLUMN,
      PROC_CMEM_LIMIT_COLUMN,
      APPLY_JOB_CMEM_LIMIT_COLUMN,
      JOB_CMEM_LIMIT_COLUMN,
      APPLY_PROCCOUNT_LIMIT_COLUMN,
      PROCCOUNT_LIMIT_COLUMN,
      APPLY_PROC_CPUTIME_LIMIT_COLUMN,
      PROC_CPUTIME_LIMIT_COLUMN,
      APPLY_JOB_CPUTIME_LIMIT_COLUMN,
      JOB_CPUTIME_LIMIT_COLUMN,
      ACTION_JOB_CPUTIME_LIMIT_COLUMN,
      ENDJOB_ON_NO_PROC_COLUMN,
      DIE_ON_UNHANDLED_EXCEPT_COLUMN,
      ALLOW_BREAKAWAY_COLUMN,
      ALLOW_SILENT_BREAKAWAY_COLUMN
    };


    list<PCJobSummary *> Cache;
    list<PCJobSummary *> MemBlocks;
    static const CONTEXTMENUITEMBYID TopMenuItems[];
    static const CONTEXTMENUITEMBYID NewMenuItems[];

    void ClearCache();
    BOOL RefreshCache();

}; // end class CJobRuleFolder



class CProcessFolder : public CBaseNode
{
  public:
    CProcessFolder(CBaseNode *pParent);
    virtual ~CProcessFolder();

  private:
    static const GUID         m_GUID;
    static const TCHAR *const m_szGUID;

  public:
    virtual LPCTSTR GetNodeName();
    virtual HRESULT GetDisplayInfo(RESULTDATAITEM &ResultItem);

    virtual const GUID  *GetGUIDptr() { return &m_GUID;  } 
    virtual const TCHAR *GetGUIDsz()  { return m_szGUID; }
    virtual BOOL  IsPersisted()       { return TRUE;     }

    virtual const int sImage()     { return PROCESSES_IMAGE;     }
    virtual const int sOpenImage() { return PROCESSES_OPENIMAGE; }

    virtual void        SetID(HSCOPEITEM ID)     { m_ID = ID;   }
    virtual HSCOPEITEM  GetID()                  { return m_ID; }

    virtual HRESULT AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed);
    virtual HRESULT AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed, LPARAM Cookie);
    virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, long nCommandID);
    virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, long nCommandID, LPARAM Cookie);
    virtual HRESULT OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2* ipHeaderCtrl, IConsole2 *ipConsole2);
    virtual HRESULT OnRefresh(IConsole2 *ipConsole2);

    virtual HRESULT OnViewChange(IResultData *ipResultData, LPARAM data, LONG_PTR hint);
    virtual HRESULT ShowAllItems(IResultData* ipResultData, BOOL bCacheValid);

    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb);
    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie);
		virtual HRESULT OnHelpCmd(IDisplayHelp *ipDisplayHelp);

    virtual HRESULT OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, DATA_OBJECT_TYPES context, LPARAM Cookie);
    virtual HRESULT QueryPagesFor(LPARAM Cookie);
    virtual HRESULT OnPropertyChange(PROPERTY_CHANGE_HDR *pUpdate, IConsole2 *ipConsole2);

  private:
    HSCOPEITEM m_ID;
    ITEM_STR   m_name;         // Node's display name
	  ITEM_STR   m_ResultStr;
		LONG       m_fViewOption;

  public:
    enum {
      PROCESS_ALIAS_COLUMN,
			IMAGE_NAME_COLUMN,
			PID_COLUMN,
      STATUS_COLUMN,
      AFFINITY_COLUMN,
      PRIORITY_COLUMN,
			JOB_OWNER_COLUMN,
      USER_TIME_COLUMN,
      KERNEL_TIME_COLUMN,
      CREATE_TIME_COLUMN
    };

  private:
    list<PCProcListItem *> Cache;
    list<PCProcListItem *> MemBlocks;

		static const CONTEXTMENUITEMBYID ResultsTopMenuItems[];
    static const CONTEXTMENUITEMBYID ViewMenuItems[];

    void ClearCache();
    BOOL RefreshCache();

}; // end class CProcessFolder


class CJobFolder : public CBaseNode
{
  public:
    CJobFolder(CBaseNode *pParent);
    virtual ~CJobFolder();

  private:
    static const GUID         m_GUID;
    static const TCHAR *const m_szGUID;

  public:
    virtual LPCTSTR GetNodeName();
    virtual HRESULT GetDisplayInfo(RESULTDATAITEM &ResultItem);

    virtual const GUID  *GetGUIDptr() { return &m_GUID;  } 
    virtual const TCHAR *GetGUIDsz()  { return m_szGUID; }
    virtual BOOL  IsPersisted()       { return TRUE;     }

    virtual const int sImage()     { return JOBS_IMAGE;     }
    virtual const int sOpenImage() { return JOBS_OPENIMAGE; }

    virtual void        SetID(HSCOPEITEM ID)     { m_ID = ID;   }
    virtual HSCOPEITEM  GetID()                  { return m_ID; }
    virtual int         GetChildrenCount()       { return 1; }  //$$ determine dynamically...although really only zero/non-zero critical
    
    virtual HRESULT OnExpand(BOOL bExpand, HSCOPEITEM hItem, IConsoleNameSpace2 *ipConsoleNameSpace2);

    virtual HRESULT AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed);
    virtual HRESULT AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed, LPARAM Cookie);
    virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, IConsoleNameSpace2 *ipConsoleNameSpace2, long nCommandID);
  //virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, long nCommandID);
    virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, long nCommandID, LPARAM Cookie);
  //virtual HRESULT OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2* ipHeaderCtrl, IConsole2 *ipConsole2);
    virtual HRESULT OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2* ipHeaderCtrl, IConsole2 *ipConsole2, IConsoleNameSpace2 *ipConsoleNameSpace2);  
  //virtual HRESULT OnRefresh(IConsole2 *ipConsole2);
    virtual HRESULT OnRefresh(IConsole2 *ipConsole2, IConsoleNameSpace2 *ipConsoleNameSpace2);

    virtual HRESULT OnViewChange(IResultData *ipResultData, LPARAM data, LONG_PTR hint);
    virtual HRESULT ShowAllItems(IResultData* ipResultData, BOOL bCacheValid);

    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb);
    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie);
		virtual HRESULT OnHelpCmd(IDisplayHelp *ipDisplayHelp);

  private:
    HSCOPEITEM m_ID;
    list<CBaseNode *> m_NodeList;

    ITEM_STR   m_name;         // Node's display name
	  ITEM_STR   m_ResultStr;
		LONG       m_fViewOption;
  
  public:
    enum {
      JOB_COLUMN,
      STATUS_COLUMN,
			ACTIVE_PROCESS_COUNT_COLUMN,
      AFFINITY_COLUMN,
      PRIORITY_COLUMN,
			SCHEDULING_CLASS_COLUMN,

      USER_TIME_COLUMN,
      KERNEL_TIME_COLUMN,

      PERIOD_USER_TIME_COLUMN,
      PERIOD_KERNEL_TIME_COLUMN,
      PAGE_FAULT_COUNT_COLUMN,
      PROCESS_COUNT_COLUMN,
      TERMINATED_PROCESS_COUNT_COLUMN,
      READOP_COUNT_COLUMN,
      WRITEOP_COUNT_COLUMN,
      OTHEROP_COUNT_COLUMN,
      READTRANS_COUNT_COLUMN,
      WRITETRANS_COUNT_COLUMN,
      OTHERTRANS_COUNT_COLUMN,
      PEAK_PROC_MEM_COLUMN,
      PEAK_JOB_MEM_COLUMN,
    };

  private:
    static const CONTEXTMENUITEMBYID ViewMenuItems[];

    HRESULT RePopulateScopePane(IConsoleNameSpace2 *ipConsoleNameSpace2);
    HRESULT AddNode(IConsoleNameSpace2 *ipConsoleNameSpace2, CBaseNode *pSubNode);
    void    FreeNodes();

    int ScopeCount(HSCOPEITEM ID, IConsoleNameSpace2 *ipConsoleNameSpace2);

}; // end class CJobFolder

class CJobItemFolder : public CBaseNode
{
  public:
    CJobItemFolder(CBaseNode *pParent, const PCJobListItem &thejob);
    virtual ~CJobItemFolder();

  private:
    static const GUID         m_GUID;
    static const TCHAR *const m_szGUID;

  public:
    virtual LPCTSTR GetNodeName();
    virtual HRESULT GetDisplayInfo(RESULTDATAITEM &ResultItem);

    virtual const GUID  *GetGUIDptr() { return &m_GUID;  } 
    virtual const TCHAR *GetGUIDsz()  { return m_szGUID; }
    virtual BOOL  IsPersisted()       { return FALSE;    }

    virtual const int sImage()     { if (m_JobItem.lFlags & PCLFLAG_IS_DEFINED) return JOBITEMIMAGE; else return JOBIMAGE_NODEFINITION; }
    virtual const int sOpenImage() { return sImage(); }

    virtual void        SetID(HSCOPEITEM ID)     { m_ID = ID;   }
    virtual HSCOPEITEM  GetID()                  { return m_ID; }

    virtual HRESULT AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed);

    virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, IConsoleNameSpace2 *ipConsoleNameSpace2, long nCommandID);
    virtual HRESULT OnMenuCommand(IConsole2 *ipConsole2, long nCommandID);
    virtual HRESULT OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2* ipHeaderCtrl, IConsole2 *ipConsole2, IConsoleNameSpace2 *ipConsoleNameSpace2);
    //virtual HRESULT OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2* ipHeaderCtrl, IConsole2 *ipConsole2);
    virtual HRESULT OnRefresh(IConsole2 *ipConsole2);

    virtual HRESULT OnViewChange(IResultData *ipResultData, LPARAM data, LONG_PTR hint);
    virtual HRESULT ShowAllItems(IResultData* ipResultData, BOOL bCacheValid);

    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb);
    virtual HRESULT OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie);
		virtual HRESULT OnHelpCmd(IDisplayHelp *ipDisplayHelp);

    virtual HRESULT OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, DATA_OBJECT_TYPES context);
    virtual HRESULT OnCreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, DATA_OBJECT_TYPES context, LPARAM Cookie);
    virtual HRESULT QueryPagesFor();
    virtual HRESULT QueryPagesFor(LPARAM Cookie);
    virtual HRESULT OnPropertyChange(PROPERTY_CHANGE_HDR *pUpdate, IConsole2 *ipConsole2);

  private:
    HSCOPEITEM            m_ID;
    PCJobListItem         m_JobItem;
    
	  ITEM_STR   m_ResultStr;

    list<PCProcListItem *> Cache;
    list<PCProcListItem *> MemBlocks;

		static const CONTEXTMENUITEMBYID ResultsTopMenuItems[];

    void ClearCache();
    BOOL RefreshCache(IConsole2 *ipConsole2);

    HRESULT PCJobListGetDisplayInfo(RESULTDATAITEM &ResultItem, const PCJobListItem  &ref, ITEM_STR &StorageStr);

}; // end class CJobItemFolder




#endif // _CLASS_BASENODE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\componentdata.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    ComponentData.cpp                                                        //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|Created:      Paul Skoglund 07-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/
#include "StdAfx.h"
#include "ProcCon.h"
#include "Component.h"

#include "DataObj.h"

#include "BaseNode.h"



/////////////////////////////////////////////////////////////////////////////
// CComponentData - This class is the interface to handle anything to do 
//                  with the scope pane. MMC calls the IComponent interfaces.
//                  This class keeps a few pointers to interfaces that MMC
//                  implements.

CComponentData::CComponentData() : m_Initialized(FALSE)
{
  ATLTRACE( _T("ComponentData::ComponentData()\n") );
  m_ipConsoleNameSpace2 = NULL;
  m_ipConsole2          = NULL;
  m_hbmpSNodes16        = NULL;
  m_hbmpSNodes32        = NULL;
  m_ipScopeImage        = NULL;

  m_hWatermark1         = NULL;
  m_hHeader1            = NULL;

#if	USE_WIZARD97_WATERMARKS
	// Load the bitmaps for property sheet watermark and headers
  m_hWatermark1 = ::LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_WATERMARK1));
  ASSERT( m_hWatermark1 );
#endif
#if USE_WIZARD97_HEADERS
  m_hHeader1 = ::LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_HEADER1));
  ASSERT( m_hHeader1 );
#endif

  // this needs to be dynamic/per instance because our snap-in can be added multiple times to the same console
  m_ptrRootNode        = new CRootFolder();
}

CComponentData::~CComponentData()
{
  // We release the cached interface pointers in Destroy()
  ATLTRACE( _T("ComponentData::~ComponentData()\n") );

  SAFE_RELEASE( m_ptrRootNode );     

  if( NULL != m_hWatermark1 )
    ::DeleteObject( m_hWatermark1 );

  if( NULL != m_hHeader1 )
    ::DeleteObject( m_hHeader1);

  ATLTRACE( _T("ComponentData::~ComponentData() The End\n\n") );
}


/////////////////////////////////////////////////////////////////////////////
// IComponentData methods
//

//---------------------------------------------------------------------------
// We get here only once, when the user clicks on the snapin.
//
// This method should not change as we progress through further steps.
// Here we get a chance to get pointer to some interfaces MMC provides.
// We QueryInterface for pointers to the name space and console, which
// we cache in local variables
// The other task to acomplish here is the adding of a bitmap that contains
// the icons to be used in the scope pane.
//
STDMETHODIMP CComponentData::Initialize
(
  LPUNKNOWN pUnknown         // [in] Pointer to the IConsoles IUnknown interface
)
{
  ATLTRACE( _T("ComponentData::Initialize()\n") );
  ASSERT( NULL != pUnknown );

  if (!m_ptrRootNode)
  {
    ATLTRACE( _T("  ComponentData::Initialize() Failed - no root node!\n"));
    return E_UNEXPECTED;
  }

  ATLTRACE( _T("  RootFolder <%s>\n"), m_ptrRootNode->GetNodeName() );

  // MMC should only call ::Initialize once!
  ASSERT( NULL == m_ipConsoleNameSpace2 );

  if (!pUnknown)
    return E_UNEXPECTED;

  HRESULT hr;

  hr = pUnknown->QueryInterface(IID_IConsoleNameSpace2, (VOID**)(&m_ipConsoleNameSpace2));
  ASSERT( S_OK == hr );

  hr = pUnknown->QueryInterface(IID_IConsole2, (VOID**)(&m_ipConsole2));
  ASSERT( S_OK == hr );

  if (m_ipConsole2)
  {
    hr = m_ipConsole2->QueryScopeImageList(&m_ipScopeImage);
    ASSERT( S_OK == hr );
  }

  // Load the bitmaps from the dll
  m_hbmpSNodes16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_NODES_16x16));
  ASSERT( NULL != m_hbmpSNodes16 );

  m_hbmpSNodes32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_NODES_32x32));
  ASSERT( NULL != m_hbmpSNodes32 );
 
  // Set the images
  if (m_ipScopeImage)
  {
    hr = m_ipScopeImage->ImageListSetStrip( (LONG_PTR *) m_hbmpSNodes16,
                                            (LONG_PTR *) m_hbmpSNodes32,
                                            0,
                                            RGB(255, 0, 255)
                                           );
    ASSERT( S_OK == hr );
  }

  if (hr == S_OK && m_ipConsoleNameSpace2 && m_ipConsole2 && m_ipScopeImage && m_hbmpSNodes16 && m_hbmpSNodes32)
    m_Initialized = TRUE;
  else if (hr == S_OK)
    hr = E_UNEXPECTED;

  ATLTRACE( _T("  ComponentData::Initialize() <%s>\n"), m_Initialized ? _T("Succeeded") : _T("Failed"));

  m_ptrRootNode->SetConsoleInterface(m_ipConsole2);

  return S_OK;

} // end Initialize()


//---------------------------------------------------------------------------
// Release interfaces and clean up objects which allocated memory
//
STDMETHODIMP CComponentData::Destroy()
{
  ATLTRACE( _T("ComponentData::Destroy()\n") );

  if (m_ptrRootNode)
    m_ptrRootNode->SetConsoleInterface(NULL);

  // Free interfaces
  SAFE_RELEASE(m_ipConsoleNameSpace2);
  SAFE_RELEASE(m_ipConsole2);
  SAFE_RELEASE(m_ipScopeImage);

  VERIFY( ::DeleteObject( m_hbmpSNodes16 ) );
  VERIFY( ::DeleteObject( m_hbmpSNodes32 ) );

  return S_OK;

} // end Destroy()


//---------------------------------------------------------------------------
// Come in here once right after Initialize. MMC wants a pointer to the
// IComponent interface.
//
STDMETHODIMP CComponentData::CreateComponent
(
  LPCOMPONENT* ppComponent   // [out] Pointer to the location that stores
)                            // the newly created pointer to IComponent
{
  ATLTRACE( _T("ComponentData::CreateComponent()\n") );

  if (!m_Initialized)
    return E_UNEXPECTED;

  ASSERT( NULL != ppComponent );  

  CComObject<CComponent>* pObject;
  CComObject<CComponent>::CreateInstance( &pObject );

  ASSERT( NULL != pObject );
  if (!pObject)
    return E_UNEXPECTED;

  pObject->SetComponentData( this );

  return pObject->QueryInterface( IID_IComponent, reinterpret_cast<void**>(ppComponent) );
} // end CreateComponent()


//---------------------------------------------------------------------------
// 
//
STDMETHODIMP CComponentData::Notify
(
  LPDATAOBJECT     ipDataObject,  // [in] Points to the selected data object
  MMC_NOTIFY_TYPE  Event,         // [in] Identifies action taken by user. 
  LPARAM           Arg,           // [in] Depends on the notification type
  LPARAM           Param          // [in] Depends on the notification type
)
{
  ATLTRACE( _T("ComponentData::Notify %p 0x%X %p %p\n"), ipDataObject, Event, Arg, Param );

  HRESULT hr = S_FALSE;

  switch( Event )
  {
    // documented IComponentData::Notify Event
    case MMCN_EXPAND:
			{	
				CBaseNode *pNode = ExtractBaseObject(ipDataObject);
				if (pNode)
        {
				  ATLTRACE(_T("ComponentData::Notify MMCN_EXPAND (%s) %s \n"), ((BOOL) Arg) ? _T("expand") : _T("collapse"), pNode->GetNodeName());
				  hr = pNode->OnExpand( (BOOL) Arg, Param, m_ipConsoleNameSpace2 );
        }
        else
        {
          ATLTRACE(_T("ComponentData::Notify MMCN_EXPAND (%s)\n"), ((BOOL) Arg) ? _T("expand") : _T("collapse"));
          static UINT s_cfMachineName = ::RegisterClipboardFormat(_T("MMC_SNAPIN_MACHINE_NAME"));

          FORMATETC fmt       = { (CLIPFORMAT) s_cfMachineName, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
          STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
          
          stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, SNAPIN_MAX_COMPUTERNAME_LENGTH + 1 );
          if (stgmedium.hGlobal)
          {          
            if (S_OK == ipDataObject->GetDataHere(&fmt, &stgmedium) &&
                m_ptrRootNode)
            {
              m_ptrRootNode->SetComputerName((TCHAR *)stgmedium.hGlobal);    
              hr = m_ptrRootNode->OnParentExpand( (BOOL) Arg, Param, m_ipConsoleNameSpace2 );
            }
            GlobalFree(stgmedium.hGlobal);
          }
          /*
          HRESULT res = ipDataObject->QueryGetData(&fmt);
          ATLTRACE(_T("  QueryData 0x%p\n"), res);
          if (res == S_OK)
          {
            int x = 9;
          }

          IEnumFORMATETC *ipEnumFORMATETC = 0;
          HRESULT res = ipDataObject->EnumFormatEtc(DATADIR_GET, &ipEnumFORMATETC);
          if (res == S_OK && ipEnumFORMATETC)
          {
            ULONG out = 0;
            FORMATETC aFormat;
            res = ipEnumFORMATETC->Next(1, &aFormat, &out);
            while (res == S_OK && out == 1)
            {
              const CLIPFORMAT cf = aFormat.cfFormat;
              out = 0;
              _TCHAR szFormatName[246];
              if (!GetClipboardFormatName(cf, szFormatName, ARRAY_SIZE(szFormatName)))
                _tcscpy(szFormatName, _T("Unknown format") );
              ATLTRACE(_T("  %s\n"), szFormatName);
              res = ipEnumFORMATETC->Next(1, &aFormat, &out);
            }
            ipEnumFORMATETC->Release();
          }
          */
        }
			}
      break;

    // documented IComponentData::Notify Event (documented under Event but not Notify method)
    case MMCN_REMOVE_CHILDREN:
			{	
				CBaseNode *pNode = ExtractBaseObject(ipDataObject);
				if (pNode) // it "our" node call the specific handler
        {
          ATLTRACE(_T("ComponentData::Notify MMCN_REMOVE_CHILDREN %s\n"), pNode->GetNodeName());
				  hr = pNode->OnRemoveChildren( Arg );
        }
        else if (m_ptrRootNode)  // extension--the data object is "our" parent
        {
          ATLTRACE(_T("ComponentData::Notify MMCN_REMOVE_CHILDREN -- extension\n"));
          hr = m_ptrRootNode->OnParentRemoveChildren( Arg );
        }
        else
        {
          ATLTRACE(_T("ComponentData::Notify MMCN_REMOVE_CHILDREN -- unexpected\n"));
          hr = E_UNEXPECTED;
        }
			}
      break;

    // documented IComponentData::Notify Event
    case MMCN_PROPERTY_CHANGE:
      ATLTRACE(_T("ComponentData::Notify MMCN_PROPERTY_CHANGE \n"));
      hr = OnPropertyChange( (BOOL) Arg, Param);
			break;

    case MMCN_HELP:
      // supposively NOT USED by MMC
      ATLTRACE( _T("ComponentData::Notify MMCN_HELP unimplemented\n") );
      hr = S_FALSE;
      break;

    case MMCN_SNAPINHELP:
      ATLTRACE( _T("ComponentData::Notify MMCN_SNAPINHELP unimplemented\n") );
      hr = S_FALSE;
      break;

    case MMCN_CONTEXTHELP:
      ATLTRACE( _T("ComponentData::Notify MMCN_CONTEXTHELP unimplemented\n") );
      hr = S_FALSE;
      break;

    case MMCN_EXPANDSYNC:
      {
 				CBaseNode *pNode = ExtractBaseObject(ipDataObject);
        ASSERT(pNode);
				if (!pNode)
					return E_UNEXPECTED;
        ATLTRACE( _T("ComponentData::Notify MMCN_EXPANDSYNC %s unimplemented\n"), pNode->GetNodeName() );
        MMC_EXPANDSYNC_STRUCT *info = (MMC_EXPANDSYNC_STRUCT *) Param;
        hr = S_FALSE;
      }
      break;

    case MMCN_DELETE:                  // - shouldn't see
      ATLTRACE( _T("ComponentData::Notify MMCN_DELETE unimplemented\n") );
      hr = S_FALSE;
      break;

    /*
    // not seeing any of the NOTIFY events below/add as needed

    // NOT documented as a IComponentData::Notify Event
    case MMCN_REFRESH:
      ATLTRACE( _T("ComponentData::Notify MMCN_REFRESH unimplemented\n") );
      break;

    // CCF_SNAPIN_PRELOADS  format specific
    case MMCN_PRELOAD:
      ATLTRACE( _T("ComponentData::Notify MMCN_PRELAOD unimplemented\n") );
      break;

    // documented IComponentData::Notify Event
    case MMCN_RENAME:                  // - shouldn't see
      ATLTRACE( _T("ComponentData::Notify MMCN_RENAME unimplemented\n") );
      hr = S_FALSE;
      break;

  case MMCN_DELETE:                  // - shouldn't see
      ATLTRACE( _T("ComponentData::Notify MMCN_DELETE unimplemented\n") );
      hr = S_FALSE;
      break;

    case MMCN_BTN_CLICK:
    case MMCN_CONTEXTHELP:
    case MMCN_CUTORMOVE:
    case MMCN_QUERY_PASTE:
    case MMCN_PASTE:
    case MMCN_PRINT:
    */

    default:
      ATLTRACE(_T("ComponentData::NOTIFY unhandled notify event 0x%X\n"), Event);
      hr = S_FALSE;
      break;
  }
  return hr;

} // end Notify()

//---------------------------------------------------------------------------
//  MMCN_PROPERTY_CHANGE notification
//
HRESULT CComponentData::OnPropertyChange
( 
  BOOL bScopeItem, 
  LPARAM Param
)                            
{
  if (!bScopeItem)
	{
		ASSERT(FALSE);  // what is this path being used by?
    return S_OK;
	}

  PROPERTY_CHANGE_HDR *pUpdate = reinterpret_cast<PROPERTY_CHANGE_HDR*>(Param);

  if (pUpdate)
  {
    if (pUpdate->pFolder && pUpdate->bScopeItem)
      pUpdate->pFolder->OnPropertyChange(pUpdate, m_ipConsole2);

    pUpdate = FreePropChangeInfo(pUpdate);
  }

  return S_OK;
  
} // end OnPropertyChange()


//---------------------------------------------------------------------------
// This is where MMC asks us to provide IDataObjects for every node in the
// scope pane.  We have to QI the object so it gets AddRef'd.  The node 
// manager handles deleting the objects.
//
STDMETHODIMP CComponentData::QueryDataObject
( 
  MMC_COOKIE        Cookie,       // [in]  Data object's unique identifier 
  DATA_OBJECT_TYPES Context,      // [in]  Data object's type
  LPDATAOBJECT*     ppDataObject  // [out] Points to the returned data object
)
{
  // check for magic multi-select cookie
  if (IS_SPECIAL_COOKIE(Cookie) )
  {
    if (Cookie == MMC_MULTI_SELECT_COOKIE)
      ATLTRACE( _T("ComponentData::QueryDataObject: MMC_MULTI_SELECT_COOKIE unimplemented\n") );
    else 
      ATLTRACE( _T("ComponentData::QueryDataObject: special cookie 0x%X unimplemented\n"), Cookie );
    return E_UNEXPECTED;
  }

  ATLTRACE( _T("ComponentData::QueryDataObject\n") );

  ASSERT( CCT_SCOPE          == Context  ||      // Must have a context
	        CCT_RESULT         == Context  ||      // we understand
          CCT_SNAPIN_MANAGER == Context
        );

  if (CCT_SNAPIN_MANAGER == Context || 
      CCT_SCOPE          == Context)
  {

    CComObject<CDataObject>* pDataObj;
    CComObject<CDataObject>::CreateInstance( &pDataObj );
    if( ! pDataObj )             // DataObject was not created
    {
      ASSERT(pDataObj); 
      return E_OUTOFMEMORY;
    } 

    CBaseNode *pFolder;

    if (Cookie == NULL)
    {
      ASSERT(m_ptrRootNode);
      pFolder = m_ptrRootNode;
    }
    else
    {
      pFolder = reinterpret_cast<CBaseNode *> (Cookie);
    }

    // ATLTRACE( _T("%s-ComponentData::QueryDataObject: %s\n"), pFolder->GetNodeName(), (Context == CCT_SCOPE) ? _T("CCT_SCOPE") : _T("CCT_SNAPIN_MANAGER") );

    pDataObj->SetDataObject( Context, pFolder );

    HRESULT hr =  pDataObj->QueryInterface( IID_IDataObject,
                                            reinterpret_cast<void**>(ppDataObject)
                                          );

		return hr;

  }
  else if (CCT_RESULT == Context)
  {
    // ATLTRACE( _T("ComponentData::QueryDataObject: CCT_RESULT unsupported\n") );
    return E_UNEXPECTED;
  }

  // CCT_UNINITIALIZED
  // ATLTRACE( _T("ComponentData::QueryDataObject: unsupported Context\n") );
  return E_UNEXPECTED;
} // end QueryDataObject()


//---------------------------------------------------------------------------
// This is where we provide strings for nodes in the scope pane.
// MMC handles the root node string.
//
STDMETHODIMP CComponentData::GetDisplayInfo
(
  LPSCOPEDATAITEM pItem      // [in, out] Points to a SCOPEDATAITEM struct
)
{
  ASSERT( NULL != pItem );
  HRESULT hr = S_OK;

  if (!pItem->mask)  // doesn't need anything
    return S_OK;

  // the SDI_PARAM flag does not have to be set on input to indicate that the LPARAM is valid
  //if (! (pItem->mask & SDI_PARAM) )
  //  return E_UNEXPECTED;

  //ASSERT( pItem->lParam);
  // get object from SCOPEITEM's lParam

  CBaseNode *pTmp = NULL;

  if (pItem->lParam)
    pTmp = reinterpret_cast<CBaseNode *>(pItem->lParam);
  else
    pTmp = dynamic_cast<CBaseNode *>(m_ptrRootNode);

  // this should never be called with the root node, 
  // all scope items with lParam pointer to object derived from CBaseNode
  if (!pTmp)
    return E_UNEXPECTED;

  if ( pItem->mask & SDI_STR )  // wants the display name
  {                                    
    pItem->displayname = const_cast<LPOLESTR>( pTmp->GetNodeName() );
  }
  if (pItem->mask & SDI_IMAGE)
  {
    pItem->nImage = pTmp->sImage();
  }
  if (pItem->mask & SDI_OPENIMAGE)
  {
    pItem->nOpenImage = pTmp->sOpenImage();
  }

  return hr;

} // end GetDisplayInfo()


//---------------------------------------------------------------------------
//
STDMETHODIMP CComponentData::CompareObjects
(
  LPDATAOBJECT ipDataObjectA,    // [in] First data object to compare
  LPDATAOBJECT ipDataObjectB     // [in] Second data object to compare
)
{
  CBaseNode *pdoA;
  CBaseNode *pdoB;

  pdoA = ExtractBaseObject( ipDataObjectA );
  pdoB = ExtractBaseObject( ipDataObjectB );

  ASSERT( pdoA || pdoB );

  // If extraction failed for one of them, then that one is foreign and
  // can't be equal to the other one.  (Or else ExtractOwnDataObject
  // returned NULL because it ran out of memory, but the most conservative
  // thing to do in that case is say they're not equal.)
  if( !pdoA || !pdoB )
  {
    ATLTRACE(_T("ComponentData::CompareObjects() - FALSE one or both objects not recognized\n") );
    return S_FALSE;
  }

  // If they have "our" same node type
  if( pdoA->GetNodeType() == pdoB->GetNodeType() )
  {
    ATLTRACE(_T("ComponentData::CompareObjects() - TRUE\n") );
    return S_OK;
  }

  ATLTRACE(_T("ComponentData::CompareObjects() - FALSE\n") );
  return S_FALSE;

} // end CompareObjects()


/////////////////////////////////////////////////////////////////////////////
//  IExtendContextMenu method implementations
//
STDMETHODIMP CComponentData::AddMenuItems
( 
  LPDATAOBJECT           ipDataObject,     // [in] Points to data object
  LPCONTEXTMENUCALLBACK  piCallback,       // [in] Pointer to IContextMenuCallback
  long*                  pInsertionAllowed // [in,out] Insertion flags
)
{
  ASSERT( NULL != ipDataObject );
  HRESULT hr = S_OK;

	if (IsMMCMultiSelectDataObject(ipDataObject))
    return E_UNEXPECTED;

  CBaseNode *pNode = ExtractBaseObject( ipDataObject );

  if (!pNode)
    return E_UNEXPECTED;

  return pNode->AddMenuItems(piCallback, pInsertionAllowed);

} // end AddMenuItems()

/////////////////////////////////////////////////////////////////////////////
//  IExtendContextMenu method implementations
//
STDMETHODIMP CComponentData::Command
(
  long nCommandID,           // [in] Command to handle
  LPDATAOBJECT ipDataObject  // [in] Points to data object
)
{
  HRESULT hr = S_FALSE;

  CDataObject *pDO   = ExtractOwnDataObject( ipDataObject );
  CBaseNode   *pNode = ExtractBaseObject( ipDataObject );
  ASSERT(pDO);
  if (!pDO || !pNode)
    return hr;

  // $$ not a desireable action to take but if this isn't done
  // the context menu for a node can be operated on, and the result pane doesn't reflect the
  // changes because the scope node selection wasn't changed when the context menu is obtained for 
  // a different node.
  // i.e. 
  //   Processes scope node is selected, 
  //   right click on root node get a context menu (for the root node) and connect to a different computer
  //   the system still shows the processes scope node selected and the result pane shows the 
  //   list of processes on the machine previously connected!
  m_ipConsole2->SelectScopeItem(pNode->GetID());

  /*
  {
    ATLTRACE( _T("Attempt patch of framework!\n"));
    //OnShow(ipDataObject, TRUE, pNode->GetID());
    m_ipConsole2->SelectScopeItem(pNode->GetID());
  }
  */

  CJobItemFolder *pJobItemFolder = dynamic_cast<CJobItemFolder *> (pNode);

  if (pJobItemFolder)
    hr = pJobItemFolder->OnMenuCommand(m_ipConsole2, m_ipConsoleNameSpace2, nCommandID );
  else
    hr = pNode->OnMenuCommand(m_ipConsole2, nCommandID );
  if (hr == S_OK)
    return hr;
  
  ATLTRACE(_T("ComponentData::Command - unrecognized or failed command %d\n"), nCommandID);

  return hr;

} // end Command()


STDMETHODIMP CComponentData::GetWatermarks
(
	LPDATAOBJECT ipDataObject,
  HBITMAP *lphWatermark,
  HBITMAP * lphHeader,
  HPALETTE * lphPalette,
  BOOL* bStretch
)
{
	// invoked during addition of snapin
	// may be called prior to Initialize() method like 
	// IComponentData::QueryDataObject() with CCT_SNAPIN_MANAGER context

	// note this may return NULL handles for watermark and header...this is suppose to be OK
	// see use of	USE_WIZARD97_ precompiled headers

	// 10/8/1998 with MMC 1.1 RC4
	//  MMC is calling this method with lphWatermark equal to IDataObject address
  //  if we store anything at the addresss we corrupt the IDataObject, 
	//  MMC then calls another method with corrupt IDataObject (CreatePropertyPages()) and boom
	//  access violation!
	//  report to Microsoft Derek Jacoby (10/8/1998)
	// 
	// 10/10/1998 Derek Jacoby 
	//  informed me the interface method has changed and now 
	//  includes an addition parameter....

  CDataObject *pDO   = ExtractOwnDataObject( ipDataObject );
  CBaseNode   *pNode = ExtractBaseObject( ipDataObject);

  if (pDO && pNode)
  {
    ATLTRACE(_T("ComponentData::GetWatermarks() %s\n"), pNode->GetNodeName());
    *lphWatermark = m_hWatermark1;
    *lphHeader    = m_hHeader1;
    *lphPalette   = NULL;
    *bStretch     = TRUE;
    return S_OK;
  }

  ATLTRACE(_T("ComponentData::GetWatermarks() %s\n"), _T("Unrecognized IDataObject"));
  return S_FALSE;
} // end GetWatermarks()

STDMETHODIMP CComponentData::QueryPagesFor
(
 LPDATAOBJECT ipDataObject
)
{
  CDataObject *pDO   = ExtractOwnDataObject( ipDataObject );
  CBaseNode   *pNode = ExtractBaseObject( ipDataObject);

  if (pDO && pDO->IsResultItem() )
  {
    ASSERT(FALSE); // WHY HERE?, why didn't Component::QueryPagesFor get asked?
  }

  if (pDO && pNode && !pDO->IsResultItem())
  {
    ATLTRACE(_T("ComponentData::QueryPagesFor() %s\n"), pNode->GetNodeName());
    return pNode->QueryPagesFor();
  }

  ATLTRACE(_T("ComponentData::QueryPagesFor() %s\n"), _T("Unrecognized IDataObject"));
  return S_FALSE;
}

STDMETHODIMP CComponentData::CreatePropertyPages
( 
  LPPROPERTYSHEETCALLBACK lpProvider,
  LONG_PTR handle,
  LPDATAOBJECT ipDataObject
)
{
  ASSERT( NULL != lpProvider );

  CDataObject *pDO   = ExtractOwnDataObject( ipDataObject );
  CBaseNode   *pNode = ExtractBaseObject( ipDataObject);

  if (pDO && pDO->IsResultItem() )
  {
    ASSERT(FALSE); // WHY HERE?
  }

  if (pDO && pNode && !pDO->IsResultItem())
  {
	  ATLTRACE(_T("ComponentData::CreatePropertyPages() %s\n"), pNode->GetNodeName());
    return pNode->OnCreatePropertyPages(lpProvider, handle, pDO->GetContext());
  }

  ATLTRACE(_T("ComponentData::CreatePropertyPages() %s\n"), _T("Unrecognized IDataObject"));
  return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// IStream implementation
//
STDMETHODIMP CComponentData::GetClassID(CLSID *pClassID)
{
	ATLTRACE(_T("ComponentData::GetClassID()\n"));
  *pClassID = CLSID_ComponentData;
  return S_OK;        
}	

STDMETHODIMP CComponentData::IsDirty()
{
	ATLTRACE(_T("ComponentData::IsDirty()\n"));

  HRESULT hr = S_FALSE;  // default to no changes...
  if (m_ptrRootNode)
    hr = m_ptrRootNode->IsDirty();

  ATLTRACE(_T("  ComponentData::IsDirty() %s\n"), (hr == S_OK ? _T("Dirty") : _T("No Changes")));

  return hr;
}

STDMETHODIMP CComponentData::Load(IStream *pStm)
{
	ATLTRACE(_T("\nComponentData::Load()\n"));

  if (m_ptrRootNode)
    return m_ptrRootNode->Load(pStm);

  return E_UNEXPECTED;
}
 
STDMETHODIMP CComponentData::Save(IStream *pStm, BOOL fClearDirty)
{
	ATLTRACE(_T("\nComponentData::Save()\n"));

  if (m_ptrRootNode)
    return m_ptrRootNode->Save(pStm, fClearDirty);

  return E_UNEXPECTED;
}

STDMETHODIMP CComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
	ATLTRACE(_T("ComponentData::GetSizeMax()\n"));

  if (m_ptrRootNode)
    return m_ptrRootNode->GetSizeMax(pcbSize);

  return E_UNEXPECTED;
}

/////////////////////////////////////////////////////////////////////////////
// ISnapinHelp2
//

STDMETHODIMP CComponentData::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{ 
	ATLTRACE(_T("ComponentData::GetHelpTopic()\n"));

	if (!lpCompiledHelpFile)
		return E_POINTER;

 	*lpCompiledHelpFile = reinterpret_cast<LPOLESTR> (CoTaskMemAlloc(_MAX_PATH * sizeof(TCHAR)));
	if (!*lpCompiledHelpFile)
		return E_OUTOFMEMORY;

  DWORD len = ExpandEnvironmentStrings(HELP_FilePath, *lpCompiledHelpFile, _MAX_PATH);
  if (len && len <= _MAX_PATH)
    return S_OK;

	return E_UNEXPECTED;
}

STDMETHODIMP CComponentData::GetLinkedTopics(LPOLESTR *lpCompiledHelpFiles)
{
	ATLTRACE(_T("ComponentData::GetLinkedTopics()\n"));

	if (!lpCompiledHelpFiles)
		return E_POINTER;

 	*lpCompiledHelpFiles = reinterpret_cast<LPOLESTR> (CoTaskMemAlloc(_MAX_PATH * sizeof(TCHAR)));
	if (!*lpCompiledHelpFiles)
		return E_OUTOFMEMORY;

  DWORD len = ExpandEnvironmentStrings(HELP_LinkedFilePaths, *lpCompiledHelpFiles, _MAX_PATH);
  if (len && len <= _MAX_PATH)
    return S_OK;

	return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\component.h ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    Component.h                                                              //
|                                                                                       //
|Description:  Class definition for CComponent, implements IComponent interface         //
|                                                                                       //
|Created:      Paul Skoglund 07-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

/////////////////////////////////////////////////////////////////////////////
// CComponent:  CComponent handles interactions with the result pane.  MMC
//              calls the IComponent interfaces.
//
// This is a part of the MMC SDK.
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// MMC SDK Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// MMC Library product.
//


#ifndef __COMPONENT_H_
#define __COMPONENT_H_

#include "Globals.h"
#include "ComponentData.h"


/////////////////////////////////////////////////////////////////////////////
// CComponent
class ATL_NO_VTABLE CComponent : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IComponent,
#ifdef USE_IRESULTDATACOMPARE
	public IResultDataCompare,
#endif
  public IExtendContextMenu,               
  public IExtendPropertySheet2
{
  public:
    CComponent();
    ~CComponent();

DECLARE_NOT_AGGREGATABLE(CComponent)

BEGIN_COM_MAP(CComponent)
	COM_INTERFACE_ENTRY(IComponent)
#ifdef USE_IRESULTDATACOMPARE
	COM_INTERFACE_ENTRY(IResultDataCompare)
#endif
  COM_INTERFACE_ENTRY(IExtendContextMenu)  
  COM_INTERFACE_ENTRY(IExtendPropertySheet2)
END_COM_MAP()

  // IComponent interface methods
  public:
    STDMETHOD(Initialize)(LPCONSOLE ipConsole);
    STDMETHOD(Notify)(LPDATAOBJECT ipDataObject, MMC_NOTIFY_TYPE Event, LPARAM Arg, LPARAM Param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT ipDataObjectA, LPDATAOBJECT ipDataObjectB);

#ifdef USE_IRESULTDATACOMPARE
	// IResultDataCompare
	public:
		STDMETHOD(Compare) (LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int * pnResult );
#endif

  // IExtendContextMenu 
  public:
    STDMETHOD(AddMenuItems)( LPDATAOBJECT ipDataObject,
                             LPCONTEXTMENUCALLBACK pCallback,
                             long *pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT ipDataObject);
	

  // IExtendPropertySheet2
  public:
    STDMETHOD(CreatePropertyPages)( LPPROPERTYSHEETCALLBACK lpProvider,
                                    LONG_PTR handle,
                                    LPDATAOBJECT ipDataObject
                                  );
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT ipDataObject);
    STDMETHOD(GetWatermarks)(LPDATAOBJECT ipDataObject, HBITMAP * lphWatermark, HBITMAP * lphHeader, HPALETTE * lphPalette, BOOL* bStretch);


  public:
    void SetComponentData(CComponentData* pCompData);


  private:
    IConsole2*          m_ipConsole2;          // MMC interface to console
    IHeaderCtrl2*       m_ipHeaderCtrl2;       // MMC interface to header control
    IResultData*        m_ipResultData;        // MMC interface to result data
    IConsoleVerb*       m_ipConsoleVerb;       // MMC interface to console verb
    IConsoleNameSpace2* m_ipConsoleNameSpace2; // MMC interface to console name space
		IDisplayHelp*       m_ipDisplayHelp;       // MMC interface to display help

    CComponentData*     m_pCompData;           // Parent scope pane object
    
    HBITMAP             m_hbmp16x16;
    HBITMAP             m_hbmp32x32;

    HSCOPEITEM          m_hSelectedScope;      // handle to selected scopeitem or null if nothing selected...

    BOOL                m_bInitializedAndNotDestroyed; 


  private:
    HRESULT OnShow(LPDATAOBJECT ipDataObject, BOOL bSelected, HSCOPEITEM hID);
    HRESULT OnSelect(LPDATAOBJECT ipDataObject, LPARAM Arg, LPARAM Param);
   
    HRESULT OnAddImages(LPDATAOBJECT ipDataObject, IImageList *ipImageList, HSCOPEITEM hID);

    HRESULT OnRefresh(LPDATAOBJECT ipDataObject);

    HRESULT OnPropertyChange( BOOL bScopeItem, LPARAM Param );

};

#endif //__COMPONENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\componentdata.h ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    ComponentData.h                                                          //
|                                                                                       //
|Description:  Class definition for CComponentData, implements IComponentData interface //
|                                                                                       //
|Created:      Paul Skoglund 07-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

/////////////////////////////////////////////////////////////////////////////
// CComponentData:  CComponentData handles interactions with the result pane.  MMC
//              calls the IComponentData interfaces.
//
// This is a part of the MMC SDK.
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// MMC SDK Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// MMC Library product.

#ifndef __COMPONENTDATA_H_
#define __COMPONENTDATA_H_


#include "Globals.h"


class CBaseNode;
class CRootFolder;
class CComponent;


class ATL_NO_VTABLE CComponentData : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CComponentData, &CLSID_ComponentData>,
  public IComponentData,
  public IExtendContextMenu,
  public IExtendPropertySheet2,
  public IPersistStream,
	public ISnapinHelp2
{
  public:
    CComponentData();
    ~CComponentData();

    // Note: we can't use DECLARE_REGISTRY_RESOURCEID(IDR_PROCCON)
    // because we need to be able to localize some of the strings we
    // write into the registry.
    static HRESULT STDMETHODCALLTYPE UpdateRegistry (BOOL bRegister) {
        return UpdateRegistryHelper(IDR_PROCCON, bRegister);
    }

DECLARE_NOT_AGGREGATABLE(CComponentData)

BEGIN_COM_MAP(CComponentData)
	COM_INTERFACE_ENTRY(IComponentData)
  COM_INTERFACE_ENTRY(IExtendContextMenu)
  COM_INTERFACE_ENTRY(IExtendPropertySheet2)
  COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(ISnapinHelp)
	COM_INTERFACE_ENTRY(ISnapinHelp2)
END_COM_MAP()

  // IComponentData methods
  public:
    STDMETHOD(CompareObjects)(LPDATAOBJECT ipDataObjectA, LPDATAOBJECT ipDataObjectB);
    STDMETHOD(GetDisplayInfo)(LPSCOPEDATAITEM pItem);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT * ppDataObject);
    STDMETHOD(Notify)(LPDATAOBJECT ipDataObject, MMC_NOTIFY_TYPE Event, LPARAM Arg, LPARAM Param);
    STDMETHOD(CreateComponent)(LPCOMPONENT * ppComponent);
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(Destroy)();

  // IExtendContextMenu 
  public:
    STDMETHOD(AddMenuItems)( LPDATAOBJECT ipDataObject,
                             LPCONTEXTMENUCALLBACK pCallback,
                             long *pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT ipDataObject);

  // IExtendPropertySheet2
  public:
    STDMETHOD(CreatePropertyPages)( LPPROPERTYSHEETCALLBACK lpProvider,
                                    LONG_PTR handle,
                                    LPDATAOBJECT ipDataObject
                                  );
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT ipDataObject);
    STDMETHOD(GetWatermarks)(LPDATAOBJECT ipDataObject, HBITMAP * lphWatermark, HBITMAP * lphHeader, HPALETTE * lphPalette, BOOL* bStretch);

  // IPersistStream
  public:
    STDMETHOD(GetClassID)(CLSID *pClassID);
  	STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);	  
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

	// ISnapinHelp2
	public:
		STDMETHOD(GetHelpTopic)    (LPOLESTR* lpCompiledHelpFile);
		STDMETHOD(GetLinkedTopics) (LPOLESTR* lpCompiledHelpFiles);

  private:
    IConsoleNameSpace2 *m_ipConsoleNameSpace2; // Pointer to the IConsoleNameSpace2 interface
    IConsole2          *m_ipConsole2;          // Pointer to the IConsole2 interface
    IImageList         *m_ipScopeImage;        // Pointer to the scope's ImageList interface
    HBITMAP             m_hbmpSNodes16;        // Strip to 16x16 images
    HBITMAP             m_hbmpSNodes32;        // Strip to 32x32 images
    

    CRootFolder        *m_ptrRootNode;         // newed in constructor...Initialize is too late
                                               // QueryDataObject() can be used prior to Initialize()

    BOOL                m_Initialized;         // TRUE implies Initialize() method returned S_OK

    HBITMAP             m_hWatermark1;         // property sheet watermark
    HBITMAP             m_hHeader1;            // property sheet header

    HRESULT OnPropertyChange( BOOL bScopeItem, LPARAM Param );
};

#endif //__COMPONENTDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\dataobj.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    DataObj.cpp                                                              //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|Created:                                                                               //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

// from samples...

#include "StdAfx.h"

#include "DataObj.h"
#include "BaseNode.h"
#include "Resource.h"

//#define COUNT_DEBUG

// not required but needed formats
UINT CDataObject::s_cfNodeID         = ::RegisterClipboardFormat(CCF_NODEID);             // not used in MMC 1.2 if CCF_NODEID2 is supported
UINT CDataObject::s_cfNodeID2        = ::RegisterClipboardFormat(CCF_NODEID2);
UINT CDataObject::s_cfSnapinPreloads = ::RegisterClipboardFormat(CCF_SNAPIN_PRELOADS);
UINT CDataObject::s_cfWindowTitle    = ::RegisterClipboardFormat(CCF_WINDOW_TITLE);

// required formats
UINT CDataObject::s_cfNodeType       = ::RegisterClipboardFormat(CCF_NODETYPE);
UINT CDataObject::s_cfNodeTypeString = ::RegisterClipboardFormat(CCF_SZNODETYPE);
UINT CDataObject::s_cfDisplayName    = ::RegisterClipboardFormat(CCF_DISPLAY_NAME);
UINT CDataObject::s_cfSnapinClsid    = ::RegisterClipboardFormat(CCF_SNAPIN_CLASSID);

// our additional formats...
UINT CDataObject::s_cfInternal       = ::RegisterClipboardFormat(CCF_SNAPIN_INTERNAL);
UINT CDataObject::s_cfBaseInternal   = ::RegisterClipboardFormat(CCF_SNAPIN_BASEINTERNAL);

LONG CDataObject::s_nCount = 0;

/////////////////////////////////////////////////////////////////////////////
// CDataObject - This class is used to pass data back and forth with MMC. It
//               uses a standard interface, IDataObject to acomplish this.
//               Refer to OLE documentation for a description of clipboard
//               formats and the IdataObject interface.
CDataObject::CDataObject()
{
  m_Cookie      = SPECIAL_COOKIE_MIN;
  m_Context     = CCT_UNINITIALIZED;
  m_pFolderObj  = NULL;
  m_bResultItem = FALSE;

  InterlockedIncrement(&s_nCount);
#ifdef COUNT_DEBUG
  ATLTRACE( _T("CDataObj::CDataObj() %ld\n"), s_nCount );
#endif

} // end Constructor()

//---------------------------------------------------------------------------
CDataObject::~CDataObject()
{
  InterlockedDecrement(&s_nCount);
#ifdef COUNT_DEBUG
  ATLTRACE( _T("CDataObj::~CDataObj() %ld\n"), s_nCount );
#endif
} // end Destructor()


/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
// 

STDMETHODIMP 
CDataObject::GetDataHere
(
  FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure 
  STGMEDIUM *pStgMedium      // [out] Pointer to the STGMEDIUM structure  
)
{
  ASSERT(pFormatEtc && pStgMedium );
  if (!pFormatEtc || !pStgMedium)
    return E_UNEXPECTED;

  HRESULT hr = DV_E_FORMATETC;         // Unknown format
  const   CLIPFORMAT cf = pFormatEtc->cfFormat;
  IStream *pStream = NULL;

  pStgMedium->pUnkForRelease = NULL;   // by OLE spec

  // Make sure FORMATETC is something we can handle...
  if( (DVASPECT_CONTENT != pFormatEtc->dwAspect) || (TYMED_HGLOBAL != pFormatEtc->tymed) )
    return DV_E_FORMATETC;

  SIZE_T Size = GlobalSize(pStgMedium->hGlobal);
  //
  // $$ potential problem...
  //  the stream just gets bigger as needed
  //   but GetDataHere is not suppose to do that...
  //   is this an issue?
  // 
  hr = CreateStreamOnHGlobal( pStgMedium->hGlobal, FALSE, &pStream );
  if( FAILED(hr) )
    return hr;

  if( cf == s_cfNodeType )
  {
    hr = WriteNodeTypeGUID( pStream );
  }
  else if( cf == s_cfNodeTypeString )
  {
    hr = WriteNodeTypeGUIDString( pStream );
  }    
  else if( cf == s_cfDisplayName )
  {
    hr = WriteDisplayName( pStream );
  }    
  else if( cf == s_cfSnapinClsid )
  {
    hr = WriteClsid( pStream );
  }
  else if( cf == s_cfInternal )
  {
    hr = WriteInternal( pStream );
  }
  else if( cf == s_cfBaseInternal )
  {
    hr = WriteBaseInternal( pStream );
  }
  else if (cf == s_cfSnapinPreloads )
  {
    hr = WriteSnapinPreloads( pStream );
  }
	/*  // wait and verify first, I haven't seen this yet 
	    // and don't want to discover that some time down the
			// road microsoft starts calling this and I'm not handling this correctly...
			// see QueryDataObject() special cookies too... and IS_SPECIAL_COOKIE in sdk help
  else if (cf == s_cfWindowTitle )
  {
    hr = WriteWindowTitle( pStream );
  }
	*/
  else
  {
    hr = DV_E_FORMATETC;
  }

  SIZE_T Size2 = GlobalSize(pStgMedium->hGlobal);

  ASSERT(Size == Size2);

  pStream->Release();

  return hr;

} // end GetDataHere()


//---------------------------------------------------------------------------
//
STDMETHODIMP CDataObject::GetData
(
  LPFORMATETC pFormatEtc,    // [in]  Pointer to the FORMATETC structure 
  LPSTGMEDIUM pStgMedium     // [out] Pointer to the STGMEDIUM structure  
)
{
  ASSERT(pFormatEtc && pStgMedium );
  if (!pFormatEtc || !pStgMedium)
    return E_UNEXPECTED;

  HRESULT hr = DV_E_FORMATETC;    // Unknown format
  const CLIPFORMAT cf = pFormatEtc->cfFormat;
  pStgMedium->pUnkForRelease = NULL;

  _TCHAR szFormatName[246];
  if (!GetClipboardFormatName(cf, szFormatName, ARRAY_SIZE(szFormatName)))
    _tcscpy(szFormatName, _T("Unknown format") );

  // Make sure FORMATETC is something we can handle...
  if( (DVASPECT_CONTENT != pFormatEtc->dwAspect) || (TYMED_HGLOBAL != pFormatEtc->tymed) )
  {
    ATLTRACE( _T("CDataObject::GetData() called with ClipFormat 0x%X %s return 0x%X\n"), cf, szFormatName, hr );
    return hr;
  }

  if (cf == s_cfNodeID          ||
      cf == s_cfNodeID2         ||
      cf == s_cfSnapinPreloads )
  {
    IStream *pStream = NULL;

    pStgMedium->tymed   = TYMED_HGLOBAL;
    pStgMedium->hGlobal = NULL;

    // the stream gets bigger as needed, not a problem
    hr = CreateStreamOnHGlobal( NULL, FALSE, &pStream );
    if( SUCCEEDED(hr) )
    {
      hr = GetHGlobalFromStream(pStream, &(pStgMedium->hGlobal));
      ASSERT( SUCCEEDED(hr) );

      if ( SUCCEEDED(hr) )
      {        
        if (cf == s_cfNodeID)
          hr = WriteNodeID( pStream, TRUE );
        else if (cf == s_cfNodeID2)
          hr = WriteNodeID( pStream );
        else if (cf == s_cfSnapinPreloads)
          hr = WriteSnapinPreloads(pStream);
        else 
        {
          // a more expensive path to say no!
          ASSERT(FALSE);  // we already checked for format ...function out of sync?
          GlobalFree(pStgMedium->hGlobal);
          pStgMedium->hGlobal = NULL;
          pStgMedium->tymed   = TYMED_NULL;
          hr = DV_E_FORMATETC;
        }
      }
      pStream->Release();
    }
  }

  //ATLTRACE( _T("CDataObject::GetData() called with ClipFormat 0x%X %s return 0x%X\n"), cf, szFormatName, hr );

  return hr;

} // end GetData()


//---------------------------------------------------------------------------
//  SetData can be implemented if a data consumer needs to change the 
//  properties of one of our nodes.
//
STDMETHODIMP CDataObject::SetData
(
  LPFORMATETC  pFormatEtc,   //[in] FormatEtc to use
  LPSTGMEDIUM  pStgMedium,   //[in] StgMedium to use
  BOOL         bRelease      //[in] TRUE if we release the memory
)
{
  ASSERT( pFormatEtc && pStgMedium );
  if (!pFormatEtc || !pStgMedium)
    return E_UNEXPECTED;

  HRESULT hr = DV_E_FORMATETC;

  // Make sure FORMATETC is something we can handle.
  if( (DVASPECT_CONTENT & pFormatEtc->dwAspect) && 
      (TYMED_HGLOBAL    & pFormatEtc->tymed   )  )
  {
    //
  }

  if( bRelease )
    ReleaseStgMedium( pStgMedium );

  ATLTRACE( _T("CDataObject::SetData() returned 0x%X \n"), hr );
  return hr; 

} // end SetData()


//---------------------------------------------------------------------------
//
STDMETHODIMP CDataObject::QueryGetData
(
  LPFORMATETC pFormatEtc     // [in] FormatEtc struct to test.
) 
{   
  ASSERT(pFormatEtc);
  if (!pFormatEtc)
    return E_UNEXPECTED;

  HRESULT hr = DV_E_FORMATETC;
  const CLIPFORMAT cf = pFormatEtc->cfFormat;

  // Make sure FORMATETC is something we can handle.
  if ( (DVASPECT_CONTENT != pFormatEtc->dwAspect) || (TYMED_HGLOBAL != pFormatEtc->tymed) ) 
    hr = DV_E_FORMATETC;
  else  if (cf == s_cfNodeID || cf == s_cfNodeID2 || cf == s_cfSnapinPreloads)
    hr = S_OK;
  else     
    hr = DV_E_FORMATETC;

 #ifdef _DEBUG
  _TCHAR szFormatName[246];
  if (!GetClipboardFormatName(cf, szFormatName, ARRAY_SIZE(szFormatName)))
    _tcscpy(szFormatName, _T("Unknown format") );
  //ATLTRACE( _T("CDataObject::QueryGetData() called with ClipFormat 0x%X %s return 0x%X\n"), cf, szFormatName, hr );
 #endif
  return hr;

} // end QueryGetData()


STDMETHODIMP CDataObject::EnumFormatEtc
(
  DWORD            dwDirection,        //[in]  Only DATADIR_GET supported
  LPENUMFORMATETC* ppEnumFormatEtc     //[out] Points to our IEnumFormatEtc
)
{ 
  ATLTRACE( _T("CDataObject::EnumFormatEtc\n"));
	return E_NOTIMPL;
} // end EnumFormatEtc()


/////////////////////////////////////////////////////////////////////////////
//  Support methods
//


//---------------------------------------------------------------------------
//  Write the appropriate GUID to the stream
//
HRESULT
CDataObject::WriteNodeTypeGUID
(
  IStream* pStream           // [in] Stream we are writing to
)
{
  if (!m_pFolderObj)
  {
     ASSERT( FALSE );
     return E_UNEXPECTED;
  }

  const GUID *pGuid = m_pFolderObj->GetGUIDptr();

  return pStream->Write( (PVOID)pGuid, sizeof(GUID), NULL );

} // end WriteNodeTypeGUID()



HRESULT
CDataObject::WriteNodeTypeGUIDString
(
  IStream* pStream           // [in] Stream we are writing to
)
{
  if (!m_pFolderObj)
  {
     ASSERT( FALSE );
     return E_UNEXPECTED;
  }
  
  const TCHAR *szGuid  = m_pFolderObj->GetGUIDsz();
  ULONG ulSizeofString = ( _tcslen(szGuid) + 1) * sizeof(TCHAR);

  return pStream->Write( szGuid, ulSizeofString, NULL );

} // end WriteNodeTypeGUIDString()



//---------------------------------------------------------------------------
//  Writes the display name to the stream, the node name
// 
HRESULT
CDataObject::WriteDisplayName
(
  IStream* pStream           // [in] Stream we are writing to     
)
{
  ASSERT(m_pFolderObj);

  if (!m_pFolderObj)
    return E_UNEXPECTED;

  ULONG ulSizeofName = _tcslen(m_pFolderObj->GetNodeName());  
  
  if (ulSizeofName)  // Count null character if we have a string  
    ulSizeofName++;

  ulSizeofName *= sizeof(TCHAR);

  return pStream->Write(m_pFolderObj->GetNodeName(), ulSizeofName, NULL);

} // end WriteDisplayName()

//---------------------------------------------------------------------------
//  Writes the Class ID to the stream
//
HRESULT
CDataObject::WriteClsid
(
  IStream* pStream           // [in] Stream we are writing to
)
{
  return pStream->Write( &CLSID_ComponentData,
                         sizeof(CLSID_ComponentData),
                         NULL
                       );
} // end WriteClsid()


//---------------------------------------------------------------------------
//  Writes a pointer to this data object to the stream
//
HRESULT
CDataObject::WriteInternal
(
  IStream* pStream           // [in] Stream we are writing to 
)
{
  ASSERT(m_pFolderObj);
  if (!m_pFolderObj)
    return E_UNEXPECTED;

  CDataObject *pThis = this;
  return pStream->Write( &pThis, sizeof(CDataObject*), NULL );

} // end WriteInternal

//---------------------------------------------------------------------------
//  Writes a CBaseNode pointer to the stream
//
HRESULT
CDataObject::WriteBaseInternal
(
  IStream* pStream           // [in] Stream we are writing to 
)
{
  ASSERT(m_pFolderObj);

  if (!m_pFolderObj)
    return E_UNEXPECTED;

  return pStream->Write( &m_pFolderObj, sizeof(CBaseNode *), NULL );

} // end WriteInternal

HRESULT
CDataObject::WriteNodeID
(
  IStream* pStream,                    // [in] Stream we are writing to
  BOOL     bCCF_NODEID /* = FALSE */   // [in] reply with older CCF_NODEID format rather than CCF_NODEID2
)
{
  if (!m_pFolderObj)
  {
     ASSERT( FALSE );
     return E_UNEXPECTED;
  }

  HRESULT hr;
  DWORD   dwFlags     = 0;
  BOOL     bPersisted = m_pFolderObj->IsPersisted();
  const TCHAR *szGuid = m_pFolderObj->GetGUIDsz();
  DWORD        cBytes = (_tcslen(szGuid) + 1) * sizeof(TCHAR);

  if (bCCF_NODEID)   // CCF_NODEID  (originial or older format)
  {
    // CCF_NODEID cBytes = 0 implies don't persist this node's selection
    if (!bPersisted)
      cBytes = 0;
    hr = pStream->Write(&cBytes, sizeof(cBytes), NULL);
    if (hr == S_OK) hr = pStream->Write(szGuid, cBytes, NULL);
  }
  else               // CCF_NODEID2 (newer format)
  {
    // CCF_NODEID2  doesn't permit writing cBytes = 0, Node GUID string is always written
    if (!bPersisted)
      dwFlags |= MMC_NODEID_SLOW_RETRIEVAL;
    hr = pStream->Write(&dwFlags, sizeof(dwFlags), NULL);
    if (hr == S_OK) hr = pStream->Write(&cBytes, sizeof(cBytes), NULL);
    if (hr == S_OK) hr = pStream->Write(szGuid, cBytes, NULL);
  }

  return hr;

} // WriteNodeID()


HRESULT
CDataObject::WriteSnapinPreloads
(
  IStream* pStream           // [in] Stream we are writing to
)
{
  if (!m_pFolderObj)
  {
     ASSERT( FALSE );
     return E_UNEXPECTED;
  }

  BOOL bPreload = m_pFolderObj->GetPreload();

  return pStream->Write( &bPreload, sizeof(bPreload), NULL );

} // end WriteSnapinPreloads()


//---------------------------------------------------------------------------
//  Writes the display name to the stream, the node name
// 
HRESULT
CDataObject::WriteWindowTitle
(
  IStream* pStream           // [in] Stream we are writing to     
)
{
  ASSERT(m_pFolderObj);
  if (!m_pFolderObj)
    return E_UNEXPECTED;

  ULONG ulSizeofName = _tcslen(m_pFolderObj->GetWindowTitle());  
  
  if (ulSizeofName)  // Count null character if we have a string  
    ulSizeofName++;

  ulSizeofName *= sizeof(TCHAR);

  return pStream->Write(m_pFolderObj->GetWindowTitle(), ulSizeofName, NULL);

} // end WriteWindowTitle()


//---------------------------------------------------------------------------
//
VOID 
CDataObject::SetDataObject
(
  DATA_OBJECT_TYPES  Context, // [in] Context of the caller
  CBaseNode         *pFolder
) 
{
  m_Context    = Context;
  m_pFolderObj = pFolder;
} // end SetDataObject()

//---------------------------------------------------------------------------
//
VOID 
CDataObject::SetDataObject
(
  DATA_OBJECT_TYPES  Context, // [in] Context of the caller
  CBaseNode         *pFolder,
  MMC_COOKIE         Cookie   // [in] Unique indentifier
)
{
  m_Context    = Context;
  m_pFolderObj = pFolder;
  m_Cookie     = Cookie;

  m_bResultItem = TRUE;

} // end SetDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\container.h ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1999  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    Container.h                                                              //
|                                                                                       //
|Description:  Class implemention for the root node                                     //
|                                                                                       //
|Created:      Paul Skoglund 04-1999                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#ifndef _CONTAINER_H_

#define _CONTAINER_H_

#include "BaseNode.h"

template <class T>
class CPropContainer
{
  public:
    CPropContainer(T &data,
                   CBaseNode *pFolder,
                   LONG_PTR handle, 
                   PCid hPCid,
                   const COMPUTER_CONNECTION_INFO &Target,
                   PCINT32 counter,
                   BOOL bScope,
                   int nHint) : m_org(data), m_new(data), 
         m_FolderNode(pFolder),
         m_MMCHandle(handle), 
         m_hPCid(hPCid),
         m_Target(Target), m_counter(counter),
         m_bScope(bScope), m_Hint(nHint), m_refcount(1), m_bNewPCid(FALSE) 
    { 
      m_FolderNode->AddRef();
    }
    ~CPropContainer() 
    {
      if ( m_MMCHandle )
      {
		    // $$ 
		    // documented handling of these notification handles is a little mysterious...
		    // or the design is questionable...
		    // only one page of a sheet needs to close the handle...since each property page needs the notification
		    // handle it seems a reference count approach would have been much better,...
        VERIFY(S_OK == MMCFreeNotifyHandle(m_MMCHandle));
        m_MMCHandle = NULL;
      }   
      //if ( m_org == m_new )
      if (0 != memcmp(&m_org,&m_new,sizeof(T)) ) 
      { 
        ATLTRACE(_T("Property page changes discarded\n"));
        //ASSERT(FALSE); 
      }
      if (m_bNewPCid && m_hPCid)
      {
        VERIFY( PCClose(m_hPCid) );
      }
      m_FolderNode->Release();
    }
    void AddRef()
    {
      ++m_refcount;
    }
    void Release()
    {
      if (--m_refcount == 0)
        delete this;
    }
    BOOL Apply(HWND hWnd) 
    { 
      if (0 != memcmp(&m_org,&m_new,sizeof(T)) ) 
      {
        if ( !Replace(m_hPCid, &m_new, m_counter) )
        {
          PCULONG32 err = PCGetLastError(m_hPCid);

          if (err == PCERROR_INVALID_PCID)
          {
	          m_hPCid = PCOpen(m_Target.bLocalComputer ? NULL : m_Target.RemoteComputer, NULL, max(sizeof(T),PC_MIN_BUF_SIZE) );

	          if (!m_hPCid)
		          err = PCGetLastError(m_hPCid);
	          else
	          {
              err = 0;
              m_bNewPCid = TRUE;
		          if (!Replace(m_hPCid, &m_new, m_counter))
			          err = PCGetLastError(m_hPCid);		    
	          }
          }

	        if (err)
	        {		        
            ::ReportPCError(err, hWnd);
		        SetLastError(err);
            return FALSE;
	        }
        }
        m_counter++;
        m_org = m_new;

			  PROPERTY_CHANGE_HDR *pUpdate = AllocPropChangeInfo(m_FolderNode, m_Hint, m_Target, m_bScope, m_Hint);

			  if (pUpdate)
			  {
				  if (S_OK != MMCPropertyChangeNotify( m_MMCHandle, (LPARAM) pUpdate ) )
				  {
					  ASSERT(FALSE); // why did mmc notify fail?
					  pUpdate = FreePropChangeInfo(pUpdate);
				  }
			  }
      }
      return TRUE;
    }
    virtual BOOL Replace( PCid hPCid, T *update, PCINT32 nCtr) = 0;
    const COMPUTER_CONNECTION_INFO &GetConnectionInfo() { return m_Target; }
		
  private:
    CBaseNode                *m_FolderNode;
		LONG_PTR                  m_MMCHandle;
    PCid                      m_hPCid;
    COMPUTER_CONNECTION_INFO  m_Target;    
    PCINT32                   m_counter;
    BOOL                      m_bScope;
    int                       m_Hint;

    BOOL                      m_bNewPCid;
    int                       m_refcount;
    T                         m_org;
  public:
    T                         m_new;
};

class CServicePageContainer :
	public CPropContainer<PCSystemParms>
{
  public:
    CServicePageContainer(PCSystemParms &parms,
                          CBaseNode *pFolder,
                          LONG_PTR  MMCHandle, 
                          PCid  hPCid,
                          const COMPUTER_CONNECTION_INFO &target,
                          PCINT32 counter,
                          BOOL  bScope,
                          int   nHint) 
       : CPropContainer<PCSystemParms> (parms, pFolder, MMCHandle, hPCid, target, counter, bScope, nHint) {}
    ~CServicePageContainer() { }
    BOOL Replace(PCid hPCid, PCSystemParms *sysParms, PCINT32 nCtr)
    {
      return PCSetServiceParms( hPCid, sysParms, sizeof(*sysParms) );  
    }

};

class CProcDetailContainer :
	public CPropContainer<PCProcDetail>
{
  public:
    CProcDetailContainer(PCProcDetail &procDetail,
                          CBaseNode *pFolder,
                          LONG_PTR  MMCHandle, 
                          PCid  hPCid,
                          const COMPUTER_CONNECTION_INFO &target,
                          PCINT32 counter,
                          BOOL  bScope,
                          int   nHint) 
       : CPropContainer<PCProcDetail> (procDetail, pFolder, MMCHandle, hPCid, target, counter, bScope, nHint) {}
    ~CProcDetailContainer() { }
    BOOL Replace(PCid hPCid, PCProcDetail *procDetail, PCINT32 nCtr)
    {
      return PCReplProcDetail( hPCid, procDetail, nCtr );  
    }
};

class CNewProcDetailContainer :
	public CPropContainer<PCProcDetail>
{
  public:
    CNewProcDetailContainer(PCProcDetail &procDetail,
                          CBaseNode *pFolder,
                          LONG_PTR  MMCHandle, 
                          PCid  hPCid,
                          const COMPUTER_CONNECTION_INFO &target,
                          PCINT32 counter,
                          BOOL  bScope,
                          int   nHint) 
       : CPropContainer<PCProcDetail> (procDetail, pFolder, MMCHandle, hPCid, target, counter, bScope, nHint) {}
    ~CNewProcDetailContainer() { }
    BOOL Replace(PCid hPCid, PCProcDetail *procDetail, PCINT32 nCtr)
    {
      return PCAddProcDetail( hPCid, procDetail, NULL );  
    }
};

class CJobDetailContainer :
	public CPropContainer<PCJobDetail>
{
  public:
    CJobDetailContainer(PCJobDetail &jobDetail,
                          CBaseNode *pFolder,
                          LONG_PTR  MMCHandle, 
                          PCid  hPCid,
                          const COMPUTER_CONNECTION_INFO &target,
                          PCINT32 counter,
                          BOOL  bScope,
                          int   nHint) 
       : CPropContainer<PCJobDetail> (jobDetail, pFolder, MMCHandle, hPCid, target, counter, bScope, nHint) {}
    ~CJobDetailContainer() { }
    BOOL Replace(PCid hPCid, PCJobDetail *jobDetail, PCINT32 nCtr)
    {
      return PCReplJobDetail( hPCid, jobDetail, nCtr );  
    }
};

class CNewJobDetailContainer :
	public CPropContainer<PCJobDetail>
{
  public:
    CNewJobDetailContainer(PCJobDetail &jobDetail,
                          CBaseNode *pFolder,
                          LONG_PTR  MMCHandle, 
                          PCid  hPCid,
                          const COMPUTER_CONNECTION_INFO &target,
                          PCINT32 counter,
                          BOOL  bScope,
                          int   nHint) 
       : CPropContainer<PCJobDetail> (jobDetail, pFolder, MMCHandle, hPCid, target, counter, bScope, nHint) {}
    ~CNewJobDetailContainer() { }
    BOOL Replace(PCid hPCid, PCJobDetail *jobDetail, PCINT32 nCtr)
    {
      return PCAddJobDetail( hPCid, jobDetail, NULL );  
    }
};



#endif  // _CONTAINER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\dataobj.h ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    DataObj.h                                                                //
|                                                                                       //
|Description:  Class definition for CDataObj, implements IDataObj interface             //
|                                                                                       //
|Created:      Paul Skoglund 07-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

/////////////////////////////////////////////////////////////////////////////
// DataObj: The IDataObject Interface is used to communicate data
//
// This is a part of the MMC SDK.
// Copyright (C) 1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// MMC SDK Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// MMC Library product.
//

#ifndef __DATAOBJ_H_
#define __DATAOBJ_H_

#include <atlctl.h>
#include <mmc.h>

#include "Globals.h"

// Custom clipboard formats
const TCHAR *const CCF_SNAPIN_INTERNAL     = _T("CF_PROCCON_DATAOBJECT_CONTAINER");
const TCHAR *const CCF_SNAPIN_BASEINTERNAL = _T("CF_PROCCON_BASENODEOBJECT_CONTAINER");


/////////////////////////////////////////////////////////////////////////////
// Defines, Types etc...
//


/////////////////////////////////////////////////////////////////////////////
// CDataObject - This class is used to pass data back and forth with MMC. It
//               uses a standard interface, IDataObject to acomplish this.
//                Refer to OLE documentation for a description of clipboard
//               formats and the IDataObject interface.

class CDataObject:
  //public IDataObjectImpl<CDataObject>,
  public IDataObject,
  public CComObjectRoot    
{
public:

DECLARE_NOT_AGGREGATABLE(CDataObject)

BEGIN_COM_MAP(CDataObject)
	COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

    CDataObject();
   ~CDataObject();
 
  // IDataObject methods 
  public:
    STDMETHOD(GetDataHere)(FORMATETC *pformatetc, STGMEDIUM *pmedium);

    STDMETHOD(EnumFormatEtc)( DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc );
    STDMETHOD(GetData)(LPFORMATETC pFormatEtc, LPSTGMEDIUM pStgMedium);
    STDMETHOD(QueryGetData)(LPFORMATETC pFormatEtc); 
    STDMETHOD(SetData)(LPFORMATETC pFormatEtc, LPSTGMEDIUM pStgMedium, BOOL bRelease);



  // The rest are not implemented
    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { 
      return E_NOTIMPL;
    };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { 
      return E_NOTIMPL; 
    };
    
    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { 
      return E_NOTIMPL; 
    };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { 
      return E_NOTIMPL; 
    };

  // Non-interface member functions
  public:
    DATA_OBJECT_TYPES GetContext()          { return m_Context; }
    MMC_COOKIE        GetResultItemCookie() { ASSERT(m_bResultItem); return m_Cookie; } 
    CBaseNode        *GetBaseObject()       { ASSERT(m_pFolderObj); return m_pFolderObj; }
    BOOL              IsResultItem()        { return m_bResultItem; }

    VOID              SetDataObject(DATA_OBJECT_TYPES, CBaseNode *pFolder );
    VOID              SetDataObject(DATA_OBJECT_TYPES, CBaseNode *pFolder, MMC_COOKIE ResultItemCookie);
    

  private:
    
    HRESULT  WriteNodeID        (IStream *pstm, BOOL bCCF_NODEID = FALSE );    
    HRESULT  WriteSnapinPreloads(IStream *pstm);
		HRESULT  WriteWindowTitle   (IStream* pstm);

    HRESULT  WriteNodeTypeGUID  (IStream *pstm);    
    HRESULT  WriteNodeTypeGUIDString(IStream *pstm);
    HRESULT  WriteDisplayName   (IStream *pstm);
    HRESULT  WriteClsid         (IStream *pstm);
    HRESULT  WriteInternal      (IStream *pstm);
    HRESULT  WriteBaseInternal  (IStream *pstm);

    DATA_OBJECT_TYPES   m_Context;      // Context in which this was created
    CBaseNode *         m_pFolderObj;   // Pointer to a folder object
    MMC_COOKIE          m_Cookie;       // result item LPARAM cookie or index
    BOOL                m_bResultItem;  // dataobject pointer for a result item...

  public:
    static LONG s_nCount;

    // not required, but used by MMC formats:
    static UINT s_cfNodeID;
    static UINT s_cfNodeID2;
    static UINT s_cfSnapinPreloads;
		static UINT s_cfWindowTitle;

    // required formats:
    static UINT s_cfNodeType;
    static UINT s_cfNodeTypeString;
    static UINT s_cfDisplayName;
    static UINT s_cfSnapinClsid;

    // custom formats:
    static UINT s_cfInternal;          // Our custom clipboard format
    static UINT s_cfBaseInternal;      // Our custom clipboard format
};

#endif // __DATAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\globals.h ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    Globals.h                                                                //
|                                                                                       //
|Description:
|                                                                                       //
|Created:      Paul Skoglund 07-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

//////////////////////////////////////////////////////////////////////////////////////////
// taken and modified from MMC SDK
//

#ifndef __GLOBALS_H_
#define __GLOBALS_H_

#include "ProcCon.h"
#include "..\Library\ProcConApi.h"
#include "resource.h"



// GetWatermarks() and PSH_WIZARD97 related
#define USE_WIZARD97_HEADERS    1
#define USE_WIZARD97_WATERMARKS 0

#define _ATL_DEBUG_REFCOUNT

#define ARRAY_SIZE(_X_) (sizeof(_X_)/sizeof(_X_[0]) )


const int MAX_ITEM_LEN = 256;
typedef TCHAR ITEM_STR[MAX_ITEM_LEN];

const int SNAPIN_MAX_COMPUTERNAME_LENGTH = 256;

const PCUINT32 COM_BUFFER_SIZE = PC_MAX_BUF_SIZE;



//---------------------------------------------------------------------------
// Global function defines
//

//---------------------------------------------------------------------------
template<class TYPE>
inline void SAFE_RELEASE( TYPE*& pObj )
{
  if( NULL != pObj ) 
  { 
    pObj->Release(); 
    pObj = NULL; 
  } 
  else 
  { 
    ATLTRACE( _T("Release called on NULL interface pointer \n") ); 
  }
} // end SAFE_RELEASE()


typedef struct {
  DWORD dwIDC;
  DWORD dwIDH;
} IDCsToIDHs;


class CBaseNode;
class CDataObject;


typedef struct {
#pragma pack(1)
  BOOL    bLocalComputer;
  WCHAR   RemoteComputer[SNAPIN_MAX_COMPUTERNAME_LENGTH + 1];
#pragma pack()
}  COMPUTER_CONNECTION_INFO;

typedef struct {
	CBaseNode                  *pFolder;
	COMPUTER_CONNECTION_INFO    Target;
	int                         nHint;                 // potential quick find hint after change...
	BOOL                        bScopeItem;
	int                         nPageRef;
} PROPERTY_CHANGE_HDR;


PROPERTY_CHANGE_HDR * AllocPropChangeInfo(CBaseNode *pFolder, int nHint, COMPUTER_CONNECTION_INFO &Target, BOOL bScopeItem, int nPageRef);
PROPERTY_CHANGE_HDR * FreePropChangeInfo(PROPERTY_CHANGE_HDR * pInfo);

const TCHAR *LoadStringHelper(ITEM_STR Out, int id);

HRESULT UpdateRegistryHelper(int id, BOOL bRegister);

HRESULT ExtractFromDataObject( LPDATAOBJECT ipDataObject,
                               UINT         cf,
                               SIZE_T       cb,
                               HGLOBAL *phGlobal
                             );

CBaseNode*   ExtractBaseObject( LPDATAOBJECT ipDataObject );
CDataObject* ExtractOwnDataObject( LPDATAOBJECT ipDataObject );


BOOL IsMMCMultiSelectDataObject(IDataObject* pDataObject);

BOOL ReportPCError(DWORD nLastError, HWND hwnd);
TCHAR *FormatErrorMessageIntoBuffer(DWORD nLastError);


#endif // __GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\helptopics.h ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    HelpTopics.h                                                             //
|                                                                                       //
|Description:  Help Topics and Help File Name for ProcCon                               //
|                                                                                       //
|Created:      10-1998                                                                  //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#ifndef _HELPTOPICS_H_
#define _HELPTOPICS_H_

// several topics below commented out pending improvement of the help content.
const TCHAR *const HELP_FilePath             = _T( "%SystemRoot%\\Help\\ProcCon.chm"                      );
const TCHAR *const HELP_LinkedFilePaths      = _T( "%SystemRoot%\\Help\\ProcCon_concepts.chm"             );
const TCHAR *const HELP_overview             = _T( "ProcCon_concepts.chm::/pctrl_overview.htm"            );
const TCHAR *const HELP_best_practices       = _T( "ProcCon_concepts.chm::/best_practices.htm"            );
const TCHAR *const HELP_howto                = _T( "ProcCon_concepts.chm::/howto.htm"                     );
const TCHAR *const HELP_howto_definerules    = _T( "ProcCon_concepts.chm::/howto_define.htm"              );
const TCHAR *const HELP_alias_define         = _T( "ProcCon_concepts.chm::/alias_define"                  );
const TCHAR *const HELP_pr_define            = _T( "ProcCon_concepts.chm::/pr_define.htm"                 );
const TCHAR *const HELP_jo_define            = _T( "ProcCon_concepts.chm::/jo_define.htm"                 );
const TCHAR *const HELP_howto_modifyrules    = _T( "ProcCon_concepts.chm::/howto_modify.htm"              );
const TCHAR *const HELP_alias_modify         = _T( "ProcCon_concepts.chm::/alias_modify"                  );
const TCHAR *const HELP_pr_modify            = _T( "ProcCon_concepts.chm::/pr_modify.htm"                 );
const TCHAR *const HELP_jo_modify            = _T( "ProcCon_concepts.chm::/jo_modify.htm"                 );
const TCHAR *const HELP_howto_workprocesses  = _T( "ProcCon_concepts.chm::/howto_work_process.htm"        );
const TCHAR *const HELP_pr_view              = _T( "ProcCon_concepts.chm::/pr_view.htm"                   );
const TCHAR *const HELP_howto_endpr          = _T( "ProcCon_concepts.chm::/howto_endpr.htm"               );
const TCHAR *const HELP_howto_workgroups     = _T( "ProcCon_concepts.chm::/howto_work_process_groups.htm" );
const TCHAR *const HELP_jo_view              = _T( "ProcCon_concepts.chm::/jo_view.htm"                   );
const TCHAR *const HELP_howto_assign_group   = _T( "ProcCon_concepts.chm::/howto_assigngroup.htm"         );
const TCHAR *const HELP_howto_endjo          = _T( "ProcCon_concepts.chm::/howto_endjo.htm"               );
const TCHAR *const HELP_serv_config          = _T( "ProcCon_concepts.chm::/serv_config.htm"               );
const TCHAR *const HELP_howto_changescan     = _T( "ProcCon_concepts.chm::/howto_change_scan.htm"         );
const TCHAR *const HELP_howto_changerqsttime = _T( "ProcCon_concepts.chm::/howto_request_timeout.htm"     );
const TCHAR *const HELP_howto_admin          = _T( "ProcCon_concepts.chm::/howto_administer.htm"          );
const TCHAR *const HELP_serv_start           = _T( "ProcCon_concepts.chm::/serv_start.htm"                );
const TCHAR *const HELP_howto_backup         = _T( "ProcCon_concepts.chm::/howto_backup.htm"              );
const TCHAR *const HELP_howto_update         = _T( "ProcCon_concepts.chm::/howto_update.htm"              );
const TCHAR *const HELP_howto_restrict       = _T( "ProcCon_concepts.chm::/howto_restrict.htm"            );
const TCHAR *const HELP_howto_changecomputer = _T( "ProcCon_concepts.chm::/howto_changecomputer.htm"      );
//const TCHAR *const HELP_howto_exportlist     = _T( "ProcCon_concepts.chm::/howto_export_list.htm"         );
const TCHAR *const HELP_howto_getversion     = _T( "ProcCon_concepts.chm::/howto_version.htm"             );
const TCHAR *const HELP_howto_automate       = _T( "ProcCon_concepts.chm::/howto_automate.htm"            );
//const TCHAR *const HELP_howto_maintainperf   = _T( "ProcCon_concepts.chm::/howto_maintain_min.htm"        );
//const TCHAR *const HELP_howto_ctrl_proctime  = _T( "ProcCon_concepts.chm::/howto_maintain_range.htm"      );

const TCHAR *const HELP_tech_overview        = _T( "ProcCon_concepts.chm::/overview_node.htm"             );
const TCHAR *const HELP_understanding        = _T( "ProcCon_concepts.chm::/understand_pc.htm"             );
const TCHAR *const HELP_pr_overview          = _T( "ProcCon_concepts.chm::/pr_overview.htm"               );
const TCHAR *const HELP_in_files             = _T( "ProcCon_concepts.chm::/in_files.htm"                  );

const TCHAR *const HELP_interpreting         = _T( "ProcCon_concepts.chm::/interp_pc.htm"                 );
const TCHAR *const HELP_interp_rules         = _T( "ProcCon_concepts.chm::/interp_ru.htm"                 );
const TCHAR *const HELP_interp_alias_rules   = _T( "ProcCon_concepts.chm::/interp_ru_a.htm"               );
const TCHAR *const HELP_interp_pr_rules      = _T( "ProcCon_concepts.chm::/interp_ru_pr.htm"              );
const TCHAR *const HELP_interp_grp_rules     = _T( "ProcCon_concepts.chm::/interp_ru_jo.htm"              );
const TCHAR *const HELP_interp_processes     = _T( "ProcCon_concepts.chm::/interp_pr.htm"                 );
const TCHAR *const HELP_interp_groups        = _T( "ProcCon_concepts.chm::/interp_jo.htm"                 );

const TCHAR *const HELP_ru_overview          = _T( "ProcCon_concepts.chm::/ru_overview.htm"               );
const TCHAR *const HELP_ru_alias             = _T( "ProcCon_concepts.chm::/ru_alias.htm"                  );
const TCHAR *const HELP_ru_proc              = _T( "ProcCon_concepts.chm::/ru_proc.htm"                   );
const TCHAR *const HELP_ru_proc_name         = _T( "ProcCon_concepts.chm::/ru_proc_name.htm"              );
const TCHAR *const HELP_pr_job_name          = _T( "ProcCon_concepts.chm::/pr_job_name.htm"               );
const TCHAR *const HELP_ru_affinity          = _T( "ProcCon_concepts.chm::/ru_affinity.htm"               );
const TCHAR *const HELP_ru_priority          = _T( "ProcCon_concepts.chm::/ru_priority.htm"               );
const TCHAR *const HELP_ru_workset           = _T( "ProcCon_concepts.chm::/ru_workset.htm"                );
const TCHAR *const HELP_ru_job               = _T( "ProcCon_concepts.chm::/ru_job.htm"                    );
const TCHAR *const HELP_ru_job_name          = _T( "ProcCon_concepts.chm::/ru_job_name.htm"               );
const TCHAR *const HELP_ru_job_procs         = _T( "ProcCon_concepts.chm::/ru_job_procs.htm"              );
const TCHAR *const HELP_ru_job_sch           = _T( "ProcCon_concepts.chm::/ru_job_sch.htm"                );
const TCHAR *const HELP_ru_job_mem           = _T( "ProcCon_concepts.chm::/ru_job_mem.htm"                );
const TCHAR *const HELP_ru_job_time          = _T( "ProcCon_concepts.chm::/ru_job_time.htm"               );
const TCHAR *const HELP_ru_job_adv           = _T( "ProcCon_concepts.chm::/ru_job_adv.htm"                );

const TCHAR *const HELP_co_overview          = _T( "ProcCon_concepts.chm::/co_overview.htm"               );
const TCHAR *const HELP_co_options           = _T( "ProcCon_concepts.chm::/co_options.htm"                );
const TCHAR *const HELP_co_examples          = _T( "ProcCon_concepts.chm::/co_examples.htm"               );
//const TCHAR *const HELP_automating           = _T( "ProcCon_concepts.chm::/automate_overview.htm"         );
const TCHAR *const HELP_seealso              = _T( "ProcCon_concepts.chm::/pctrl_resources.htm"           );
const TCHAR *const HELP_ProcCon_troubleshoot = _T( "ProcCon_concepts.chm::/ProcCon_troubleshoot.htm"      );

// process group and process overviews are now merged? ...
const TCHAR *const HELP_jo_overview          = HELP_pr_overview;


// Context-Sensitive help topics:
// Throughout the proccon snap-in sources the aliases below will be used to reference
// the context-sensitive help topics.  This extra level of indirection makes it
// easier to adopt Microsoft changes to the context-sensitive help topic MAP.
// HELP_ prefix used in the snap-in source code, 
// IDH_ prefixed names are the help topics.

#include "procont_HelpIDs.h"    // Microsoft defined context-sensitive help topic map.

const TCHAR *const ContextHelpFile           = _T( "proccon.hlp" );

#define NOHELP (DWORD (-1))
//process control property pages:
//  process control general property page:
//    NONE
//  process control version property page:
#define HELP_VER_FILE                  IDH_PC_Properties_fileversion
#define HELP_VER_DESCRIPTION           IDH_PC_Properties_description
#define HELP_VER_COPYRIGHT             IDH_PC_Properties_copyright
#define HELP_VER_OTHER_FRAME           NOHELP
#define HELP_VER_ITEM                  IDH_PC_Properties_itemname_field
#define HELP_VER_VALUE                 IDH_PC_Properties_value_field
//  process control service property page:
#define HELP_SERVICE_FILEVER           IDH_PC_ServiceTab_ScanInterval_fileversion
#define HELP_SERVICE_PRODUCTVER        IDH_PC_ServiceTab_ScanInterval_productversion
#define HELP_SERVICE_MGMT_FRAME        IDH_PC_ServiceTab_ScanInterval_scaninterval
#define HELP_SERVICE_SCANINTERVAL      IDH_PC_ServiceTab_ScanInterval_servmgmt
#define HELP_SERVICE_SCANINTERVAL_SP   NOHELP
#define HELP_SERVICE_REQSTTIMEOUT      IDH_PC_ServiceTab_ScanInterval_timeoutintervfield
#define HELP_SERVICE_REQSTTIMEOUT_SP   IDH_PC_ServiceTab_RequestTimeOut
#define HELP_SERVICE_TARGET_FRAME      IDH_PC_ServiceTab_ScanInterval_targetcomputerprop
#define HELP_SERVICE_ITEM              IDH_PC_ServiceTab_ScanInterval_itemnamelist
#define HELP_SERVICE_VALUE             IDH_PC_ServiceTab_ScanInterval_valuefield

//process control Add-in wizard pages:
//  process control general wizard page:
//    NONE
//  process control connect to computer wizard page:
#define HELP_wizCONNECT_FRAME          NOHELP
#define HELP_wizCONNECT_LOCAL          IDH_PC_Properties_localcomputer
#define HELP_wizCONNECT_ANOTHER        IDH_PC_Properties_anothercomputer
#define HELP_wizCONNECT_COMPUTER       IDH_PC_Properties_anothercomputer_field
#define HELP_wizCONNECT_BROWSE         IDH_PC_Properties_browse

//process alias property page:
//process alias insert new property page:
#define HELP_NRULE_MATCHTYPE_FRAME     NOHELP
#define HELP_NRULE_DIR                 IDH_PC_PAR_SubdirectoryName  
#define HELP_NRULE_IMAGE               IDH_PC_PAR_ImageName
#define HELP_NRULE_STRING              IDH_PC_PAR_String
#define HELP_NRULE_MATCHMASK           IDH_PC_PAR_MatchString
#define HELP_NRULE_COMMENT             IDH_PC_PAR_Description
#define HELP_NRULE_NAME                IDH_PC_PAR_AssignedOnAMatch
#define HELP_NRULE_BTN_ALIAS           IDH_PC_PAR_SubdirectoryName_arrow


//process execution rule property pages:
//  process execution rule general property page:
#define HELP_PROCID_NAME               IDH_PC_CPER_ProcessAlias
#define HELP_PROCID_COMMENT            IDH_PC_CPER_Description
#define HELP_PROCID_APPLYGROUP_FRAME   IDH_PC_CPER_ExecuteInGroup
#define HELP_PROCID_APPLYGROUP_CHK     IDH_PC_CPER_ExecuteInGroup
#define HELP_PROCID_JOB_LIST           IDH_PC_CPER_ProcessAlias_Executewithin
//  process with no rule property page:
#define HELP_PROCDEF_NAME              IDH_PC_CPER_ProcessAlias
#define HELP_PROCDEF_ADD               IDH_PC_Properties_definePER
//  affinity property page:
#define HELP_PROC_AFFINITY_FRAME       IDH_PC_CPER_Affinity
#define HELP_PROC_AFFINITY_APPLY       IDH_PC_CPER_Affinity
#define HELP_PROC_AFFINITY             IDH_PC_CPER_Affinity
//  priority property page:
#define HELP_PROC_PRIORITY_FRAME       IDH_PC_CPER_Priority
#define HELP_PROC_PRIORITY_APPLY       IDH_PC_CPER_Priority
#define HELP_PROC_PRIORITY_REAL        IDH_PC_CPER_Priority_ApplyPriority_Real
#define HELP_PROC_PRIORITY_HIGH        IDH_PC_CPER_Priority_ApplyPriority_High
#define HELP_PROC_PRIORITY_ABOVENORMAL IDH_PC_CPER_Priority_ApplyPriority_Above
#define HELP_PROC_PRIORITY_NORMAL      IDH_PC_CPER_Priority_ApplyPriority_Normal
#define HELP_PROC_PRIORITY_BELOWNORMAL IDH_PC_CPER_Priority_ApplyPriority_Below
#define HELP_PROC_PRIORITY_LOW         IDH_PC_CPER_Priority_ApplyPriority_Low
//  process execution rule memory property page:
#define HELP_PROC_WS_FRAME             IDH_PC_CPER_WorkingSet
#define HELP_PROC_WS_APPLY             IDH_PC_CPER_WorkingSet
#define HELP_PROC_WS_MIN               IDH_PC_CPER_WorkingSet_minfield
#define HELP_PROC_WS_MIN_SPIN          IDH_PC_CPER_WorkingSet_Minimum
#define HELP_PROC_WS_MAX               IDH_PC_CPER_WorkingSet_maxfield
#define HELP_PROC_WS_MAX_SPIN          IDH_PC_CPER_WorkingSet_Maximum


//process execution rule wizard pages:
//  process alias name and rule description wizard page:
#define HELP_wizPROCID_NAME            IDH_PC_CPER_wizard_ProcessAlias
#define HELP_wizPROCID_COMMENT         IDH_PC_CPER_wizard_Description
//  group membership wizard page:
#define HELP_wizPROCID_APPLYGROUP_FRAME IDH_PC_CPER_wizard_ExecuteInGroup
#define HELP_wizPROCID_APPLYGROUP_CHK  IDH_PC_CPER_wizard_ExecuteInGroup
#define HELP_wizPROCID_JOB_LIST        IDH_PC_CPER_wizard_ExecuteInGroup_Executewithin
//  affinity wizard page:
#define HELP_wizPROC_AFFINITY_FRAME    IDH_PC_CPER_wizard_Affinity
#define HELP_wizPROC_AFFINITY_APPLY    IDH_PC_CPER_wizard_Affinity
#define HELP_wizPROC_AFFINITY          IDH_PC_CPER_wizard_Affinity
//  priority wizard page:
#define HELP_wizPROC_PRIORITY_FRAME        IDH_PC_CPER_wizard_Priority
#define HELP_wizPROC_PRIORITY_APPLY        IDH_PC_CPER_wizard_Priority
#define HELP_wizPROC_PRIORITY_REAL         IDH_PC_CPER_wizard_Priority_ApplyPriority_Real
#define HELP_wizPROC_PRIORITY_HIGH         IDH_PC_CPER_wizard_Priority_ApplyPriority_High
#define HELP_wizPROC_PRIORITY_ABOVENORMAL  IDH_PC_CPER_wizard_Priority_ApplyPriority_Above
#define HELP_wizPROC_PRIORITY_NORMAL       IDH_PC_CPER_wizard_Priority_ApplyPriority_Normal
#define HELP_wizPROC_PRIORITY_BELOWNORMAL  IDH_PC_CPER_wizard_Priority_ApplyPriority_Below
#define HELP_wizPROC_PRIORITY_LOW          IDH_PC_CPER_wizard_Priority_ApplyPriority_Low
//  process working set wizard page:
#define HELP_wizPROC_WS_FRAME          IDH_PC_CPER_wizard_WorkingSet
#define HELP_wizPROC_WS_APPLY          IDH_PC_CPER_wizard_WorkingSet
#define HELP_wizPROC_WS_MIN            IDH_PC_CPER_wizard_WorkingSet_minfield
#define HELP_wizPROC_WS_MIN_SPIN       IDH_PC_CPER_wizard_WorkingSet_Minimum
#define HELP_wizPROC_WS_MAX            IDH_PC_CPER_wizard_WorkingSet_maxfield
#define HELP_wizPROC_WS_MAX_SPIN       IDH_PC_CPER_wizard_WorkingSet_Maximum

  
//process group execution rule property pages:
//  process group execution rule general property page:
#define HELP_GRPID_NAME                IDH_PC_CPGER_GroupName
#define HELP_GRPID_COMMENT             IDH_PC_CPGER_Description
#define HELP_PROCCOUNT_FRAME           IDH_PC_CPGER_ProcessCount
#define HELP_PROCCOUNT_APPLY           IDH_PC_CPGER_ProcessCount
#define HELP_PROCCOUNT_MAX             IDH_PC_CPGER_ProcessCount_apply_maxnumfield
#define HELP_PROCCOUNT_MAX_SPIN        IDH_PC_CPGER_ProcessCount_apply_maxnum
//  process group with no rule property page:
#define HELP_GRPDEF_NAME               IDH_PC_CPGER_GroupName
#define HELP_GRPDEF_ADD                IDH_PC_Properties_definePGER
//  affinity property page:
#define HELP_GRP_AFFINITY_FRAME        IDH_PC_CPGER_Affinity
#define HELP_GRP_AFFINITY_APPLY        IDH_PC_CPGER_Affinity
#define HELP_GRP_AFFINITY              IDH_PC_CPGER_Affinity
//  priority property page:
#define HELP_GRP_PRIORITY_FRAME        IDH_PC_CPGER_Priority
#define HELP_GRP_PRIORITY_APPLY        IDH_PC_CPGER_Priority
#define HELP_GRP_PRIORITY_REAL         IDH_PC_CPGER_Priority_ApplyPriority_Real
#define HELP_GRP_PRIORITY_HIGH         IDH_PC_CPGER_Priority_ApplyPriority_High
#define HELP_GRP_PRIORITY_ABOVENORMAL  IDH_PC_CPGER_Priority_ApplyPriority_Above
#define HELP_GRP_PRIORITY_NORMAL       IDH_PC_CPGER_Priority_ApplyPriority_Normal
#define HELP_GRP_PRIORITY_BELOWNORMAL  IDH_PC_CPGER_Priority_ApplyPriority_Below
#define HELP_GRP_PRIORITY_LOW          IDH_PC_CPGER_Priority_ApplyPriority_Low
//  process group execution rule scheduling property page:
#define HELP_SCHEDULING_FRAME          IDH_PC_CPGER_SchedulingClass
#define HELP_SCHEDULING_APPLY          IDH_PC_CPGER_SchedulingClass
#define HELP_SCHEDULING_CLASS          IDH_PC_CPGER_SchedulingClass_Apply_schedclassfield
#define HELP_SCHEDULING_CLASS_SPIN     IDH_PC_CPGER_SchedulingClass_Apply_schedclassfield  
//  process group execution rule memory property page:
#define HELP_GRP_WS_FRAME              IDH_PC_CPGER_WorkingSet
#define HELP_GRP_WS_APPLY              IDH_PC_CPGER_WorkingSet
#define HELP_GRP_WS_MIN                IDH_PC_CPGER_WorkingSet_workingsetminmemfield
#define HELP_GRP_WS_MIN_SPIN           IDH_PC_CPGER_WorkingSet_workingsetminmem
#define HELP_GRP_WS_MAX                IDH_PC_CPGER_WorkingSet_workingsetmaxmemfield
#define HELP_GRP_WS_MAX_SPIN           IDH_PC_CPGER_WorkingSet_workingsetmaxmem
#define HELP_GRP_PROCCOM_FRAME         IDH_PC_CPGER_ProcessCommittedMemory
#define HELP_GRP_PROCCOM_APPLY         IDH_PC_CPGER_ProcessCommittedMemory
#define HELP_GRP_PROCCOM_MAX           IDH_PC_CPGER_WorkingSet_proccommittedmaxmemfield // really bad help topic name
#define HELP_GRP_PROCCOM_MAX_SPIN      IDH_PC_CPGER_WorkingSet_procommittedmaxmem       // really bad help topic name
#define HELP_GRP_GRPCOM_FRAME          IDH_PC_CPGER_ProcessGroupCommittedMemory
#define HELP_GRP_GRPCOM_APPLY          IDH_PC_CPGER_ProcessGroupCommittedMemory
#define HELP_GRP_GRPCOM_MAX            IDH_PC_CPGER_WorkingSet_progrpcommaxmemfield     // really bad help topic name
#define HELP_GRP_GRPCOM_MAX_SPIN       IDH_PC_CPGER_WorkingSet_progrpcommaxmem          // really bad help topic name
//  process group execution rule time property page:
#define HELP_TIME_PROC_FRAME           IDH_PC_CPGER_PerUserTimeLimit
#define HELP_TIME_PROC_APPLY           IDH_PC_CPGER_PerUserTimeLimit
#define HELP_TIME_PROC_MAX             IDH_PC_CPGER_PerUserTimeLimit_processuserfield
#define HELP_TIME_GRP_FRAME            IDH_PC_CPGER_PerGroupTimeLimit
#define HELP_TIME_GRP_APPLY            IDH_PC_CPGER_PerGroupTimeLimit
#define HELP_TIME_GRP_MAX              IDH_PC_CPGER_PerUserTimeLimit_groupuserfield
#define HELP_TIME_GRP_TERMINATE        IDH_PC_CPGER_PerUserTimeLimit_groupuserterminate
#define HELP_TIME_GRP_LOG              IDH_PC_CPGER_PerUserTimeLimit_groupusereport
//  process group execution rule advanced property page:
#define HELP_ADV_FRAME                 NOHELP
#define HELP_ADV_ENDGRP                IDH_PC_CPGER_EndProcessGroupWhenNoProcess
#define HELP_ADV_NODIEONEX             IDH_PC_CPGER_DieOnUnhandledExceptions
#define HELP_ADV_SILENT_BREAKAWAY      IDH_PC_CPGER_SilentBreakaway
#define HELP_ADV_BREAKAWAY_OK          IDH_PC_CPGER_BreakawayOK


//process group execution rule wizard pages:
//  process group execution rule name and description wizard page:
#define HELP_wizGRPID_NAME             IDH_PC_CPGER_wizard_GroupName
#define HELP_wizGRPID_COMMENT          IDH_PC_CPGER_wizard_Description
//  affinity wizard page:
//  affinity wizard page:
#define HELP_wizGRP_AFFINITY_FRAME     IDH_PC_CPGER_wizard_Affinity
#define HELP_wizGRP_AFFINITY_APPLY     IDH_PC_CPGER_wizard_Affinity
#define HELP_wizGRP_AFFINITY           IDH_PC_CPGER_wizard_Affinity
//  priority wizard page:
#define HELP_wizGRP_PRIORITY_FRAME         IDH_PC_CPGER_wizard_Priority
#define HELP_wizGRP_PRIORITY_APPLY         IDH_PC_CPGER_wizard_Priority
#define HELP_wizGRP_PRIORITY_REAL          IDH_PC_CPGER_wizard_Priority_apply_Real
#define HELP_wizGRP_PRIORITY_HIGH          IDH_PC_CPGER_wizard_Priority_apply_High
#define HELP_wizGRP_PRIORITY_ABOVENORMAL   IDH_PC_CPGER_wizard_Priority_apply_Above
#define HELP_wizGRP_PRIORITY_NORMAL        IDH_PC_CPGER_wizard_Priority_apply_Normal
#define HELP_wizGRP_PRIORITY_BELOWNORMAL   IDH_PC_CPGER_wizard_Priority_apply_Below
#define HELP_wizGRP_PRIORITY_LOW           IDH_PC_CPGER_wizard_Priority_apply_Low
//  process group execution rule scheduling wizard page:
#define HELP_wizSCHEDULING_FRAME       IDH_PC_CPGER_wizard_SchedulingClass
#define HELP_wizSCHEDULING_APPLY       IDH_PC_CPGER_wizard_SchedulingClass
#define HELP_wizSCHEDULING_CLASS       IDH_PC_CPGER_wizard_SchedulingClass_schedclassfld
#define HELP_wizSCHEDULING_CLASS_SPIN  IDH_PC_CPGER_wizard_SchedulingClass_schedclassfld  
//  process group execution rule working set wizard page:
#define HELP_wizGRP_WS_FRAME           IDH_PC_CPGER_wizard_WorkingSet
#define HELP_wizGRP_WS_APPLY           IDH_PC_CPGER_wizard_WorkingSet
#define HELP_wizGRP_WS_MIN             IDH_PC_CPGER_wizard_WorkingSet_minmemfield
#define HELP_wizGRP_WS_MIN_SPIN        IDH_PC_CPGER_wizard_WorkingSet_minmem
#define HELP_wizGRP_WS_MAX             IDH_PC_CPGER_wizard_WorkingSet_maxmemfield
#define HELP_wizGRP_WS_MAX_SPIN        IDH_PC_CPGER_wizard_WorkingSet_maxmem
//  process group execution rule committed memory wizard page:
#define HELP_wizGRP_PROCCOM_FRAME      IDH_PC_CPGER_wizard_ProcessCommittedMemory
#define HELP_wizGRP_PROCCOM_APPLY      IDH_PC_CPGER_wizard_ProcessCommittedMemory
#define HELP_wizGRP_PROCCOM_MAX        IDH_PC_CPGER_wizard_ProcessCommittedMemory_pcmmfld
#define HELP_wizGRP_PROCCOM_MAX_SPIN   IDH_PC_CPGER_wizard_ProcessCommittedMemory_pcmaxme
#define HELP_wizGRP_GRPCOM_FRAME       IDH_PC_CPGER_wizard_ProcessGroupCommittedMemory
#define HELP_wizGRP_GRPCOM_APPLY       IDH_PC_CPGER_wizard_ProcessGroupCommittedMemory
#define HELP_wizGRP_GRPCOM_MAX         IDH_PC_CPGER_wizard_ProcessCommittedMemory_pgmmfld
#define HELP_wizGRP_GRPCOM_MAX_SPIN    IDH_PC_CPGER_wizard_ProcessCommittedMemory_pgmaxme
//  process group execution rule process count wizard page:
#define HELP_wizPROCCOUNT_FRAME        IDH_PC_CPGER_wizard_ProcessCount
#define HELP_wizPROCCOUNT_APPLY        IDH_PC_CPGER_wizard_ProcessCount
#define HELP_wizPROCCOUNT_MAX          IDH_PC_CPGER_wizard_ProcessCount_apply_maxnumfield
#define HELP_wizPROCCOUNT_MAX_SPIN     IDH_PC_CPGER_wizard_ProcessCount_apply_maxnum
//  process group execution rule CPU user time wizard page:
#define HELP_wizTIME_PROC_FRAME        IDH_PC_CPGER_wizard_PerUserTimeLimit
#define HELP_wizTIME_PROC_APPLY        IDH_PC_CPGER_wizard_PerUserTimeLimit
#define HELP_wizTIME_PROC_MAX          IDH_PC_CPGER_wizard_PerUserTimeLimit_pumaxtimefld
#define HELP_wizTIME_GRP_FRAME         IDH_PC_CPGER_wizard_PerGroupTimeLimit
#define HELP_wizTIME_GRP_APPLY         IDH_PC_CPGER_wizard_PerGroupTimeLimit
#define HELP_wizTIME_GRP_MAX           IDH_PC_CPGER_wizard_PerUserTimeLimitpgmaxtimefld
#define HELP_wizTIME_GRP_TERMINATE     IDH_PC_CPGER_wizard_PerUserTimeLimit_pgterminate
#define HELP_wizTIME_GRP_LOG           IDH_PC_CPGER_wizard_PerUserTimeLimit_pgreport
//  process group execution rule advanced wizard page:
#define HELP_wizADV_FRAME              NOHELP
#define HELP_wizADV_ENDGRP             IDH_PC_CPGER_wizard_EndProcessGroupWhenNoProcess
#define HELP_wizADV_NODIEONEX          IDH_PC_CPGER_wizard_DieOnUnhandledExceptions
//  process group execution rule advanced breakaway wizard page:
#define HELP_wizADV_BREAKAWAY_FRAME    NOHELP
#define HELP_wizADV_SILENT_BREAKAWAY   IDH_PC_CPGER_wizard_SilentBreakaway
#define HELP_wizADV_BREAKAWAY_OK       IDH_PC_CPGER_wizard_BreakawayOK

 
#endif // _HELPTOPICS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\jobitemfolder.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    JobItemFolder.cpp                                                        //
|                                                                                       //
|Description:  Implementation of a JobItem node                                         //
|                                                                                       //
|Created:      Paul Skoglund 04-1999                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#include "StdAfx.h"
#include "BaseNode.h"

#include "JobPages.h"
#include "ProcessPages.h"
#include "ManagementPages.h"
#include "ManagementRuleWizards.h"

#pragma warning(push)
#include <algorithm>
#pragma warning(pop)

using std::list<PCProcListItem*>;
using std::list<CBaseNode *>;
using std::find;

const GUID         CJobItemFolder::m_GUID   =   {0xff9baf66,0x064e,0x11d2,{0x80, 0x14,0x00,0x10,0x4b,0x9a,0x31,0x06} };
const TCHAR *const CJobItemFolder::m_szGUID = _T("{ff9baf66-064e-11d2-8014-00104b9a3106}");

const CONTEXTMENUITEMBYID CJobItemFolder::ResultsTopMenuItems[] =
{
  { IDS_JRULE_DEFINE,    ID_JRULE_DEFINE,    ID_JRULE_DEFINE,    CCM_INSERTIONPOINTID_PRIMARY_TOP  },
  { IDS_ENDJOB,          ID_ENDJOB,          ID_ENDJOB,          CCM_INSERTIONPOINTID_PRIMARY_TOP  },
  { 0,                   0,                  0,                  0                                 }
};


CJobItemFolder::CJobItemFolder(CBaseNode *pParent, const PCJobListItem &thejob)
    : CBaseNode(JOBITEM_NODE, pParent), m_JobItem(thejob), m_ID(0)
{

}

CJobItemFolder::~CJobItemFolder()
{
  ClearCache();
  ATLTRACE( _T("~CJobItemFolder end %p - %s\n"), this, GetNodeName());
}

LPCTSTR CJobItemFolder::GetNodeName()
{
  return m_JobItem.jobName;
}

HRESULT CJobItemFolder::GetDisplayInfo(RESULTDATAITEM &ResultItem)
{
  if (ResultItem.bScopeItem)
  {
    return PCJobListGetDisplayInfo(ResultItem, m_JobItem, m_ResultStr);
  }

  list<PCProcListItem*>::iterator item;

  item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcListItem*>(ResultItem.lParam) );

  if (item == Cache.end() )
    return E_UNEXPECTED;

  return PCProcListGetDisplayInfo(ResultItem, **item, m_ResultStr);
}

HRESULT CJobItemFolder::PCJobListGetDisplayInfo(RESULTDATAITEM &ResultItem, const PCJobListItem &ref, ITEM_STR &StorageStr)
{
  if (ResultItem.mask & RDI_IMAGE)
  {
    if (ref.lFlags & PCLFLAG_IS_DEFINED)
      ResultItem.nImage = JOBITEMIMAGE;
    else
      ResultItem.nImage = JOBITEMIMAGE_NODEFINITION;
  }

  if (ResultItem.mask & RDI_STR)
  {
    LPCTSTR &pstr = ResultItem.str;

    switch (ResultItem.nCol)
    {
    case CJobFolder::JOB_COLUMN:
      pstr = ref.jobName;
      break;
    case CJobFolder::STATUS_COLUMN:
      if(ref.lFlags & PCLFLAG_IS_MANAGED)
        pstr = LoadStringHelper(StorageStr, IDS_MANAGED);
      else
        pstr = _T("");
      break;
    case CJobFolder::ACTIVE_PROCESS_COUNT_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatProcCount(StorageStr, ref.jobStats.ActiveProcesses);
      else
        pstr = _T("");
      break;
    case CJobFolder::AFFINITY_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatAffinity(StorageStr, ref.actualAffinity);
      else
        pstr = _T("");
      break;
    case CJobFolder::PRIORITY_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatPriority(StorageStr, ref.actualPriority);
      else
        pstr = _T("");
      break;
    case CJobFolder::SCHEDULING_CLASS_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatSchedulingClass(StorageStr, ref.actualSchedClass);
      else
        pstr = _T("");
      break;
    case CJobFolder::USER_TIME_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatTimeToms(StorageStr, ref.jobStats.TotalUserTime);
      else
        pstr = _T("");
      break;
    case CJobFolder::KERNEL_TIME_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatTimeToms(StorageStr, ref.jobStats.TotalKernelTime);
      else
        pstr = _T("");
      break;
    //case CJobFolder::CREATE_TIME_COLUMN:
    case CJobFolder::PERIOD_USER_TIME_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatTimeToms(StorageStr, ref.jobStats.ThisPeriodTotalUserTime);
      else
        pstr = _T("");
      break;
    case CJobFolder::PERIOD_KERNEL_TIME_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatTimeToms(StorageStr, ref.jobStats.ThisPeriodTotalKernelTime);
      else
        pstr = _T("");
      break;
    case CJobFolder::PAGE_FAULT_COUNT_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatPCUINT64(StorageStr, ref.jobStats.TotalPageFaultCount);
      else
        pstr = _T("");
      break;
    case CJobFolder::PROCESS_COUNT_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatPCUINT64(StorageStr, ref.jobStats.TotalProcesses);
      else
        pstr = _T("");
      break;
    case CJobFolder::TERMINATED_PROCESS_COUNT_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatPCUINT64(StorageStr, ref.jobStats.TotalTerminatedProcesses);
      else
        pstr = _T("");
      break;
    case CJobFolder::READOP_COUNT_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatPCUINT64(StorageStr, ref.jobStats.ReadOperationCount);
      else
        pstr = _T("");
      break;
    case CJobFolder::WRITEOP_COUNT_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatPCUINT64(StorageStr, ref.jobStats.WriteOperationCount);
      else
        pstr = _T("");
      break;
    case CJobFolder::OTHEROP_COUNT_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatPCUINT64(StorageStr, ref.jobStats.OtherOperationCount);
      else
        pstr = _T("");
      break;
    case CJobFolder::READTRANS_COUNT_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatPCUINT64(StorageStr, ref.jobStats.ReadTransferCount);
      else
        pstr = _T("");
      break;
    case CJobFolder::WRITETRANS_COUNT_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatPCUINT64(StorageStr, ref.jobStats.WriteTransferCount);
      else
        pstr = _T("");
      break;
    case CJobFolder::OTHERTRANS_COUNT_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatPCUINT64(StorageStr, ref.jobStats.OtherTransferCount);
      else
        pstr = _T("");
      break;
    case CJobFolder::PEAK_PROC_MEM_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatMemory(StorageStr, ref.jobStats.PeakProcessMemoryUsed);
      else
        pstr = _T("");
      break;
    case CJobFolder::PEAK_JOB_MEM_COLUMN:
      if (ref.lFlags & PCLFLAG_IS_RUNNING)
        pstr = FormatMemory(StorageStr, ref.jobStats.PeakJobMemoryUsed);
      else
        pstr = _T("");
      break;
    default:
      ASSERT(FALSE);
      pstr = _T("");
      break;
    }
  }
  return S_OK;
}

HRESULT CJobItemFolder::OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2 *ipHeaderCtrl2, IConsole2 *ipConsole2, IConsoleNameSpace2 *ipConsoleNameSpace2)
{
  ASSERT(hItem == GetID());

  if (!bSelecting)
    return S_OK;

  SCOPEDATAITEM sdi = {0};
  // Update the item's image in the scope pane
  sdi.mask        = SDI_IMAGE | SDI_OPENIMAGE;
  sdi.nImage      = sImage();
  sdi.nOpenImage  = sOpenImage();
  sdi.ID          = m_ID;
  VERIFY(S_OK == ipConsoleNameSpace2->SetItem(&sdi));

  InsertProcessHeaders(ipHeaderCtrl2);

  return OnRefresh(ipConsole2);
}

HRESULT CJobItemFolder::AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed)
{
  HRESULT hr = S_OK;

  ITEM_STR name;
  ITEM_STR status;

  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
  {
    CONTEXTMENUITEM m = { 0 };
    for (const CONTEXTMENUITEMBYID *M = ResultsTopMenuItems; M->lCommandID; M++)
    {
      m.strName           = const_cast<TCHAR *>(LoadStringHelper(name,   M->strNameID));
      m.strStatusBarText  = const_cast<TCHAR *>(LoadStringHelper(status, M->strStatusBarTextID));
      m.lCommandID        = M->lCommandID;
      m.lInsertionPointID = M->lInsertionPointID;
      //m.fSpecialFlags   = 0;                // currently always 0, initialized to 0

      m.fFlags = MF_GRAYED;

      if (M->lCommandID == ID_JRULE_DEFINE)
      {
        if ( !(PCLFLAG_IS_DEFINED & m_JobItem.lFlags) )
          m.fFlags = MF_ENABLED;
      }
      else if (M->lCommandID == ID_ENDJOB)
      {
        if ( (PCLFLAG_IS_RUNNING & m_JobItem.lFlags) )
          m.fFlags = MF_ENABLED;
      }

      hr = piCallback->AddItem(&m);

      if (FAILED(hr))
        break;
    }
  }

  return hr;
}

HRESULT CJobItemFolder::OnMenuCommand(IConsole2 *ipConsole2, long nCommandID)
{
  ASSERT(FALSE);
  return S_OK;
}

HRESULT CJobItemFolder::OnMenuCommand(IConsole2 *ipConsole2, IConsoleNameSpace2 *ipConsoleNameSpace2, long nCommandID )
{
  switch(nCommandID)
  {
    case ID_JRULE_DEFINE:
      {
        PCid hID = GetPCid();
        PCSystemInfo SystemInfo;
        if (!hID || !PCGetServiceInfo(hID, &SystemInfo, sizeof(SystemInfo)))
        {
          ReportPCError();
          return S_OK;
        }

        PCJobDetail  JobDetail = { 0 };
        if (GroupRuleWizard(IDS_JRULE_DEFINE, JobDetail, SystemInfo.sysParms, &(m_JobItem.jobName) ) )
        {
          if (!PCAddJobDetail(hID, &JobDetail) )
            ReportPCError();
          else
          {
            PCJobListItem JobListInfo = { 0 };
            _tcscpy(JobListInfo.jobName, m_JobItem.jobName);
            PCINT32 count = PCGetJobList( GetPCid(), &JobListInfo, sizeof(PCJobListItem), PC_LIST_MATCH_ONLY);
            if (0 > count)
            {
              ReportPCError();
              return S_OK;
            }
            else if (1 == count)  // the expected-usual case
            {
              m_JobItem = JobListInfo;  // update local data

              SCOPEDATAITEM sdi = {0};
              // Update the item's image in the scope pane
              sdi.mask        = SDI_IMAGE | SDI_OPENIMAGE;
              sdi.nImage      = sImage();
              sdi.nOpenImage  = sOpenImage();
              sdi.ID          = m_ID;
              VERIFY(S_OK == ipConsoleNameSpace2->SetItem(&sdi));            
              VERIFY(S_OK == SendViewChange(ipConsole2, NULL, PC_VIEW_UPDATEALL));
              return S_OK;
            }
            // the very unlikely case that a group rule was:
            //   1) added and then immediately deleted by another administrator
            //   or
            //   2) bug resulted in PCGetJobList() not finding the just added item
            int ret;
            ITEM_STR str;
            LoadStringHelper(str, IDS_GROUP_NO_LONGER_EXISTS);
            ipConsole2->MessageBox( str, NULL, MB_OK | MB_ICONWARNING, &ret);

            // force a refresh of the Process Group folder
            ipConsole2->SelectScopeItem(GetParentNode()->GetID());
            return S_OK;
          }
        }
      }
      return S_OK;
    case ID_ENDJOB:
      ATLTRACE(_T("CJobItemFolder::end job %s\n"), GetNodeName());
      if (!GetPCid() || !PCKillJob(GetPCid(), m_JobItem.jobName ) )
        ReportPCError();
      else
      {
        ATLTRACE(_T("CJobItemFolder::job %s killed on server\n"), GetNodeName() );
        // MMC DeleteItem() on scope items is vunerable in certain cases.
        // in MMC handling of DeleteItem the snap-in is sent selection/show notifications
        //   if those handlers call DeleteItem on scope items problems can arise
        // Original ProcCon problem:
        // when the child folder (a specific job) is deleted, the focus moves
        // up one level on the tree to the jobs folder (process groups), in our handling
        // of selection of the job folder we delete all the children(specific jobs)
        // of the folder and repopulate the child folders(list of jobs).
        // MMC appears to try and delete the org. child folder twice - unpredicable
        // results follow.
        //
        // the process group has already been ended on the server rather than
        // delete the individual item in MMC scope pane we will just change the selection
        // in the scope pane and rely on the select handlers to correct the
        // MMC namespace(scope pane display)
        //   ipConsoleNameSpace2->DeleteItem(m_ID, TRUE);
        ipConsole2->SelectScopeItem(GetParentNode()->GetID());
      }
      return S_OK;
    default:
      break;
  }

  return E_UNEXPECTED;
}

HRESULT CJobItemFolder::OnHelpCmd(IDisplayHelp *ipDisplayHelp)
{
  if (!ipDisplayHelp)
    return E_UNEXPECTED;

  ipDisplayHelp->ShowTopic(const_cast<TCHAR *>(HELP_jo_overview));

  return S_OK;
}

// folder select
HRESULT CJobItemFolder::OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb)
{
  ASSERT(bScope);

  if ( bSelect && bScope )
  {
    VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE ) == S_OK);
    VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_REFRESH,    ENABLED, TRUE ) == S_OK);
    VERIFY( ipConsoleVerb->SetDefaultVerb( MMC_VERB_OPEN ) == S_OK );
  }
  return S_OK;
}

HRESULT CJobItemFolder::OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie)
{
  ASSERT(!bScope);

  VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE ) == S_OK);
  if (bSelect && !bScope) // incase the rules are changed again leave !bScope test
  {
    VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE ) == S_OK);
    VERIFY( ipConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES ) == S_OK );
  }
  return S_OK;
}

HRESULT CJobItemFolder::OnViewChange(IResultData *ipResultData, LPARAM thing, LONG_PTR hint)
{
  ASSERT(ipResultData);
  if (!ipResultData)
    return E_UNEXPECTED;

  VERIFY(ipResultData->ModifyViewStyle(MMC_SINGLESEL, MMC_NOSORTHEADER) == S_OK);

  list<PCProcListItem*>::iterator item;

  HRESULT hr = E_UNEXPECTED;
  switch (hint)
  {
  case PC_VIEW_REDRAWALL:// not currently used
    hr = ShowAllItems(ipResultData, TRUE);
    break;
  case PC_VIEW_ADDITEM:  // not currently used
    ASSERT(FALSE);       // add smarter support for this hint...
  case PC_VIEW_UPDATEALL:
    hr = ShowAllItems(ipResultData, FALSE);
    break;
  case PC_VIEW_UPDATEITEM:
    {
    HRESULTITEM hItem;
    hr = ipResultData->FindItemByLParam(thing, &hItem);
    if (hr == S_OK)
      hr = ipResultData->UpdateItem(hItem);
    }
    break;
  case PC_VIEW_SETITEM:
    item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcListItem*>(thing) );
    if (item == Cache.end())
      hr = E_UNEXPECTED;
    else
    {
      HRESULTITEM hItem;
      hr = ipResultData->FindItemByLParam(thing, &hItem);
      if (hr == S_OK)
      {
        RESULTDATAITEM data = { 0 };
        data.mask   = RDI_IMAGE;
        data.itemID = hItem;

        if ((*item)->lFlags & PCLFLAG_IS_DEFINED)
          data.nImage = PROCITEMIMAGE;
        else
          data.nImage = PROCITEMIMAGE_NODEFINITION;

        hr = ipResultData->SetItem(&data);
        if (hr == S_OK)
          hr = ipResultData->UpdateItem(hItem);
      }
    }
    break;
  case PC_VIEW_DELETEITEM:
    {
    HRESULTITEM hItem;
    hr = ipResultData->FindItemByLParam(thing, &hItem);
    if (hr == S_OK)
      hr = ipResultData->DeleteItem(hItem, 0);
    }
    break;
  default:
    hr = E_UNEXPECTED;
    break;
  }
  ASSERT(hr == S_OK);
  return hr;
}

HRESULT CJobItemFolder::ShowAllItems(IResultData* ipResultData, BOOL bCacheValid)
{
  list<PCProcListItem*>::iterator item;
  LPARAM selected = 0;
  LPARAM focused  = 0;

  RESULTDATAITEM data;

  if (bCacheValid)
  {
    memset(&data, 0, sizeof(data));
    data.nIndex = -1;
    data.nState = LVIS_SELECTED;
    data.mask   = RDI_STATE;

    if (S_OK == ipResultData->GetNextItem(&data) && data.nIndex != -1 )
    {
      selected = data.lParam;
    }

    memset(&data, 0, sizeof(data));
    data.nIndex = -1;
    data.nState = LVIS_FOCUSED;
    data.mask   = RDI_STATE;

    if (S_OK == ipResultData->GetNextItem(&data) && data.nIndex != -1)
    {
      focused = data.lParam;
    }
  }

  ipResultData->DeleteAllRsltItems();


  memset(&data, 0, sizeof(data));
  data.mask = RDI_STR | RDI_IMAGE | RDI_PARAM  | RDI_STATE;
  data.bScopeItem = FALSE;
  //data.itemID;
  data.nIndex = 0;
  data.nCol = 0;
  data.str = (LPOLESTR)MMC_CALLBACK;
  data.nImage = JOBITEMIMAGE;

  data.iIndent = 0; //reserved

  HRESULT hr = S_OK;
  for (list<PCProcListItem*>::iterator i = Cache.begin(); i != Cache.end(); ++i)
  {
    data.lParam = reinterpret_cast<LPARAM>(*i);

    if ((*i)->lFlags & PCLFLAG_IS_DEFINED)
      data.nImage = PROCITEMIMAGE;
    else
      data.nImage = PROCITEMIMAGE_NODEFINITION;

    data.nState = 0;
    if (data.lParam == selected)
      data.nState |= LVIS_SELECTED;
    if (data.lParam == focused)
      data.nState |= LVIS_FOCUSED;
    hr = ipResultData->InsertItem(&data);
    if (hr != S_OK)
      break;
  }

  return hr;
}

void CJobItemFolder::ClearCache()
{
  Cache.clear();

  for (list<PCProcListItem*>::iterator chunck = MemBlocks.begin(); chunck != MemBlocks.end(); ++chunck)
  {
    delete [] (*chunck);
  }
  MemBlocks.clear();
}

BOOL CJobItemFolder::RefreshCache(IConsole2 *ipConsole2)
{
  PCINT32  res = 0;
  PCULONG32 err = 0;
  PCProcListItem *last = NULL;

  const int MINIMUM_ALLOCATION = min((COM_BUFFER_SIZE/sizeof(PCProcListItem)), 100);

  ClearCache();

  PCid hID = GetPCid();
  if (!hID)
  {
    ReportPCError();
    return false;
  }

  PCJobListItem JobListInfo = { 0 };
  _tcscpy(JobListInfo.jobName, m_JobItem.jobName);

  PCINT32 count = PCGetJobList( GetPCid(), &JobListInfo, sizeof(PCJobListItem), PC_LIST_MATCH_ONLY);
  if (0 > count)
  {
    ReportPCError();
    return false;
  }
  else if (0 == count)
  {
    int ret;
    ITEM_STR str;
    LoadStringHelper(str, IDS_GROUP_NO_LONGER_EXISTS);
    ipConsole2->MessageBox( str, NULL, MB_OK | MB_ICONWARNING, &ret);
    return false;
  }

  m_JobItem = JobListInfo;

  do
  {
    PCProcListItem *ptr = new PCProcListItem[MINIMUM_ALLOCATION];

    if (!ptr)
    {
      err = ERROR_OUTOFMEMORY;
      break;
    }

    if (last)
      memcpy(ptr, last, sizeof(PCProcListItem));
    else
    {
      memset(ptr, 0, sizeof(PCProcListItem));
      _tcscpy(ptr->jobName, m_JobItem.jobName);
    }

    res = PCGetProcList( hID, ptr, MINIMUM_ALLOCATION * sizeof(PCProcListItem), PC_LIST_MEMBERS_OF);
    if (res < 0 )
    {
      err = GetLastPCError();
      delete [] ptr;
      break;
    }

    if (res > 0)
    {
      last = &ptr[res - 1];

      MemBlocks.push_front(ptr);
      for (INT32 i = 0; i < res; i++)
      {
        Cache.insert(Cache.end(), ptr);
        ptr++;
      }
    }
  } while (res > 0 && PCERROR_MORE_DATA == GetLastPCError() );

  if (err)
    ReportPCError(err);

  return err == 0;

}

HRESULT CJobItemFolder::QueryPagesFor()
{
  return S_OK;
}

HRESULT CJobItemFolder::QueryPagesFor(LPARAM Cookie)
{
  list<PCProcListItem*>::iterator item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcListItem*>(Cookie) );

  if (item == Cache.end() )
    return E_UNEXPECTED;

  return S_OK;
}

HRESULT CJobItemFolder::OnCreatePropertyPages( LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, DATA_OBJECT_TYPES context) 
{
  return CreatePropertyPagesForJobListItem(m_JobItem, lpProvider, handle, this);
}

HRESULT CJobItemFolder::OnCreatePropertyPages( LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, DATA_OBJECT_TYPES context, LPARAM Cookie) 
{
  list<PCProcListItem*>::iterator item;
  item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcListItem*>(Cookie) );

  if (item == Cache.end() )
    return E_UNEXPECTED;

  return CreatePropertyPagesForProcListItem(**item, lpProvider, handle, this);
}

HRESULT CJobItemFolder::OnPropertyChange(PROPERTY_CHANGE_HDR *pUpdate, IConsole2 *ipConsole2)
{
  return OnRefresh(ipConsole2);
}

HRESULT CJobItemFolder::OnRefresh(IConsole2 *ipConsole2)
{
  RefreshCache(ipConsole2);
  return SendViewChange(ipConsole2, NULL, PC_VIEW_UPDATEALL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\jobfolder.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    JobFolder.cpp                                                            //
|                                                                                       //
|Description:  Implementation of Job List node                                          //
|                                                                                       //
|Created:      Paul Skoglund 08-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#include "StdAfx.h"
#include "BaseNode.h"

#include "JobPages.h"
#include "ManagementPages.h"
#include "ManagementRuleWizards.h"

#pragma warning(push)
#include <algorithm>
#pragma warning(pop)

using std::list<PCJobListItem*>;
using std::list<CBaseNode *>;
using std::find;

const GUID         CJobFolder::m_GUID   =   {0xff9baf62,0x064e,0x11d2,{0x80, 0x14,0x00,0x10,0x4b,0x9a,0x31,0x06} };
const TCHAR *const CJobFolder::m_szGUID = _T("{ff9baf62-064e-11d2-8014-00104b9a3106}");

const CONTEXTMENUITEMBYID CJobFolder::ViewMenuItems[] =
{
  { IDS_JOBVIEW_ALL,     ID_JOBVIEW_ALL,     ID_JOBVIEW_ALL,     CCM_INSERTIONPOINTID_PRIMARY_VIEW },
  { IDS_JOBVIEW_RUN,     ID_JOBVIEW_RUN,     ID_JOBVIEW_RUN,     CCM_INSERTIONPOINTID_PRIMARY_VIEW },
  { IDS_JOBVIEW_MANAGED, ID_JOBVIEW_MANAGED, ID_JOBVIEW_MANAGED, CCM_INSERTIONPOINTID_PRIMARY_VIEW },
  { 0,                   0,                  0,                  0                                 }
};


CJobFolder::CJobFolder(CBaseNode *pParent) : CBaseNode(JOB_NODE, pParent), m_ID(0), m_fViewOption(ID_JOBVIEW_ALL)
{
  LoadStringHelper(m_name, IDS_JOBS_FOLDER);
}

CJobFolder::~CJobFolder()
{
  FreeNodes();
  ATLTRACE( _T("~CJobFolder end\n"));
}

void CJobFolder::FreeNodes()
{
  ATLTRACE( _T("CJobFolder::FreeNodes()\n"));
  for (list<CBaseNode *>::iterator i = m_NodeList.begin(); i != m_NodeList.end(); ++i)
  {
    (*i)->Release();
  }
  m_NodeList.clear();
}

LPCTSTR CJobFolder::GetNodeName()
{
  return m_name;
}

HRESULT CJobFolder::GetDisplayInfo(RESULTDATAITEM &ResultItem)
{
  if (ResultItem.bScopeItem)
  {
    if( ResultItem.mask & RDI_STR )
    {
      if (0 == ResultItem.nCol)
         ResultItem.str = const_cast<LPOLESTR>(GetNodeName());
      else
         ResultItem.str = _T("");
    }
    if (ResultItem.mask & RDI_IMAGE)
      ResultItem.nImage = sImage();
    return S_OK;
  }
  ASSERT(FALSE);
  return E_UNEXPECTED;
}

HRESULT CJobFolder::OnExpand(BOOL bExpand, HSCOPEITEM hItem, IConsoleNameSpace2 *ipConsoleNameSpace2)
{
  if (bExpand)
  {
    ASSERT(m_ID == hItem);

    RePopulateScopePane(ipConsoleNameSpace2);
  }

  return S_OK;
}

HRESULT CJobFolder::AddNode(IConsoleNameSpace2 *ipConsoleNameSpace2, CBaseNode *pSubNode)
{
  HRESULT  hr = S_OK;

  SCOPEDATAITEM sdi = {0};

  if (!pSubNode)
    return E_OUTOFMEMORY;

  // Place items into the scope pane
  sdi.mask        = SDI_STR       |   // Displayname is valid
                    SDI_PARAM     |   // lParam is valid
                    SDI_IMAGE     |   // nImage is valid
                    SDI_OPENIMAGE |   // nOpenImage is valid
                    SDI_CHILDREN  |   // cChildren is valid
                    SDI_PARENT;

  sdi.displayname = (LPOLESTR)MMC_CALLBACK;
  sdi.nImage      = pSubNode->sImage();
  sdi.nOpenImage  = pSubNode->sOpenImage();
  //sdi.nState = ???
  sdi.cChildren   = pSubNode->GetChildrenCount();
  sdi.lParam      = reinterpret_cast <LPARAM> (pSubNode);
  sdi.relativeID  = m_ID;


  hr = ipConsoleNameSpace2->InsertItem( &sdi );

  if (SUCCEEDED(hr))
  {
    pSubNode->SetID(sdi.ID);
    m_NodeList.push_front( pSubNode );
  }
  else
  {
    pSubNode->Release();
  }
  return hr;
}

HRESULT CJobFolder::OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2* ipHeaderCtrl,
                           IConsole2 *ipConsole2, IConsoleNameSpace2 *ipConsoleNameSpace2)
{
  ASSERT(hItem == GetID());

  if (!bSelecting)
    return S_OK;

  ITEM_STR str;

  LoadStringHelper(str, IDS_JOB_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( JOB_COLUMN, str, 0, JOB_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_STATUS_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( STATUS_COLUMN, str, 0, STATUS_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_ACTIVE_PROCESS_COUNT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( ACTIVE_PROCESS_COUNT_COLUMN, str, 0, ACTIVE_PROCESS_COUNT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_AFFINITY_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( AFFINITY_COLUMN, str, 0, AFFINITY_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_PRIORITY_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( PRIORITY_COLUMN, str, 0, PRIORITY_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_SCHEDULING_CLASS_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( SCHEDULING_CLASS_COLUMN, str, 0, SCHEDULING_CLASS_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_USER_TIME_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( USER_TIME_COLUMN, str, 0, USER_TIME_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_KERNEL_TIME_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( KERNEL_TIME_COLUMN, str, 0, KERNEL_TIME_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_PERIOD_USER_TIME_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( PERIOD_USER_TIME_COLUMN, str, 0, PERIOD_USER_TIME_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_PERIOD_KERNEL_TIME_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( PERIOD_KERNEL_TIME_COLUMN, str, 0, PERIOD_KERNEL_TIME_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_PAGE_FAULT_COUNT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( PAGE_FAULT_COUNT_COLUMN, str, 0, PAGE_FAULT_COUNT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_PROCESS_COUNT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( PROCESS_COUNT_COLUMN, str, 0, PROCESS_COUNT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_TERMINATED_PROCESS_COUNT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( TERMINATED_PROCESS_COUNT_COLUMN, str, 0, TERMINATED_PROCESS_COUNT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_READOP_COUNT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( READOP_COUNT_COLUMN, str, 0, READOP_COUNT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_WRITEOP_COUNT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( WRITEOP_COUNT_COLUMN, str, 0, WRITEOP_COUNT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_OTHEROP_COUNT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( OTHEROP_COUNT_COLUMN, str, 0, OTHEROP_COUNT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_READTRANS_COUNT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( READTRANS_COUNT_COLUMN, str, 0, READTRANS_COUNT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_WRITETRANS_COUNT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( WRITETRANS_COUNT_COLUMN, str, 0, WRITETRANS_COUNT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_OTHERTRANS_COUNT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( OTHERTRANS_COUNT_COLUMN, str, 0, OTHERTRANS_COUNT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_PEAK_PROC_MEM_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( PEAK_PROC_MEM_COLUMN, str, 0, PEAK_PROC_MEM_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_PEAK_JOB_MEM_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( PEAK_JOB_MEM_COLUMN, str, 0, PEAK_JOB_MEM_COLUMN_WIDTH ));

  return OnRefresh(ipConsole2, ipConsoleNameSpace2); 
}

HRESULT CJobFolder::AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed)
{
  HRESULT hr = S_OK;

  ITEM_STR name;
  ITEM_STR status;

  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
  {
    CONTEXTMENUITEM m = { 0 };
    for (const CONTEXTMENUITEMBYID *M = ViewMenuItems; M->lCommandID; M++)
    {
      m.strName           = const_cast<TCHAR *>(LoadStringHelper(name,   M->strNameID));
      m.strStatusBarText  = const_cast<TCHAR *>(LoadStringHelper(status, M->strStatusBarTextID));
      m.lCommandID        = M->lCommandID;
      m.lInsertionPointID = M->lInsertionPointID;
      //m.fSpecialFlags   = 0;              // currently always 0, initialized to 0

      if (m.lCommandID == m_fViewOption)
        m.fFlags = MF_CHECKED   | MF_ENABLED;
      else
        m.fFlags = MF_UNCHECKED | MF_ENABLED;

      hr = piCallback->AddItem(&m);

      if (FAILED(hr))
        break;
    }
    *pInsertionAllowed ^= CCM_INSERTIONALLOWED_VIEW;
  }
  return hr;
}

HRESULT CJobFolder::AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed, LPARAM Cookie)
{
  ASSERT(FALSE);
  return S_OK;
}

HRESULT CJobFolder::OnMenuCommand(IConsole2 *ipConsole2, IConsoleNameSpace2 *ipConsoleNameSpace2, long nCommandID )
{
  switch(nCommandID)
  {
    case ID_JOBVIEW_RUN:
    case ID_JOBVIEW_MANAGED:
    case ID_JOBVIEW_ALL:
      m_fViewOption = nCommandID;
      return OnRefresh(ipConsole2, ipConsoleNameSpace2);
    default:
      break;
  }

  return E_UNEXPECTED;
}

HRESULT CJobFolder::OnMenuCommand(IConsole2 *ipConsole2, long nCommandID, LPARAM Cookie )
{
  ASSERT(FALSE);
  return S_OK;
}

HRESULT CJobFolder::OnHelpCmd(IDisplayHelp *ipDisplayHelp)
{
  if (!ipDisplayHelp)
    return E_UNEXPECTED;

  ipDisplayHelp->ShowTopic(const_cast<TCHAR *>(HELP_jo_overview));

  return S_OK;
}

HRESULT CJobFolder::OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb)
{
  ASSERT(bScope);

  if ( bSelect && bScope )
  {
    ATLTRACE(_T("CJobFolder::OnSelect Scope=%s, Select=%s\n"), bScope ? _T("true") : _T("false"), bSelect ? _T("true") : _T("false"));

    VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE ) == S_OK);
    VERIFY( ipConsoleVerb->SetDefaultVerb( MMC_VERB_OPEN ) == S_OK ); 
  }

  return S_OK;
}

HRESULT CJobFolder::OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie)
{
  ASSERT(FALSE);
  return S_OK;
}

HRESULT CJobFolder::OnViewChange(IResultData *ipResultData, LPARAM thing, LONG_PTR hint)
{
  ASSERT(ipResultData);
  if (!ipResultData)  
    return E_UNEXPECTED;

  VERIFY(ipResultData->ModifyViewStyle(MMC_SINGLESEL, MMC_NOSORTHEADER) == S_OK);

  HRESULT hr = E_UNEXPECTED;
  switch (hint)
  {
  case PC_VIEW_UPDATEALL:
    hr = ShowAllItems(ipResultData, FALSE);
    break;
  case PC_VIEW_REDRAWALL:
  case PC_VIEW_ADDITEM:
  case PC_VIEW_UPDATEITEM:
  case PC_VIEW_SETITEM:
  case PC_VIEW_DELETEITEM:
  default:
    hr = E_UNEXPECTED;
    break;
  }
  ASSERT(hr == S_OK);
  return hr;
}

HRESULT CJobFolder::ShowAllItems(IResultData* ipResultData, BOOL bCacheValid)
{
  VERIFY( S_OK == ipResultData->DeleteAllRsltItems() );

  ITEM_STR str;
  if (ID_JOBVIEW_RUN == m_fViewOption)
    ipResultData->SetDescBarText(const_cast<TCHAR *>(LoadStringHelper(str, IDS_RUNNING_JOBS)));
  else if (ID_JOBVIEW_MANAGED == m_fViewOption)
    ipResultData->SetDescBarText(const_cast<TCHAR *>(LoadStringHelper(str, IDS_MANAGED_JOBS)));
  else
    ipResultData->SetDescBarText(_T(""));

  return S_OK;
}

HRESULT CJobFolder::OnRefresh(IConsole2 *ipConsole2, IConsoleNameSpace2 *ipConsoleNameSpace2)
{
  RePopulateScopePane(ipConsoleNameSpace2);
  return SendViewChange(ipConsole2, NULL, PC_VIEW_UPDATEALL);
}

HRESULT CJobFolder::RePopulateScopePane(IConsoleNameSpace2 *ipConsoleNameSpace2)
{
  int counter = 0;

  ATLTRACE(_T("CJobFolder::  RePopulateScopePane\n"));

  ASSERT( 0 <= (counter = ScopeCount(m_ID, ipConsoleNameSpace2)) );  // Debugging aid only

  // delete the MMC scope pane items for all the jobs - NOT the
  // process groups folder itself but delete it's content
  VERIFY(S_OK == ipConsoleNameSpace2->DeleteItem(m_ID, FALSE));
  // free 'our' objects for the job items nodes
  FreeNodes();

  // debug purposes only
  ASSERT(0 == ScopeCount(m_ID, ipConsoleNameSpace2));  // Debugging aid only

  PCINT32  res = 0;
  PCULONG32 err = 0;
  PCINT32  last = 0;

  const int MINIMUM_ALLOCATION = min((COM_BUFFER_SIZE/sizeof(PCJobListItem)), 100);

  PCJobListItem    tempjoblist[MINIMUM_ALLOCATION];  

  PCid hID = GetPCid();
  if (!hID)
  {
    ReportPCError();
    return false;
  }

  do
  {
    if (last)
      memcpy(&tempjoblist[0], &tempjoblist[last], sizeof(PCJobListItem));
    else
      memset(&tempjoblist[0], 0, sizeof(PCJobListItem));

    res = PCGetJobList( hID, &tempjoblist[0], MINIMUM_ALLOCATION * sizeof(PCJobListItem));
    if (res < 0 )
    {
      err = GetLastPCError();
      break;
    }

    if (res > MINIMUM_ALLOCATION)
    {
      err = PCERROR_INVALID_RESPONSE;
      break;
    }

    if (res > 0)
    {
      last = res - 1 ;

      for (PCINT32 i = 0; i < res; i++)
      {
        if (ID_JOBVIEW_RUN == m_fViewOption && !(tempjoblist[i].lFlags & PCLFLAG_IS_RUNNING)) 
          continue;
        else if (ID_JOBVIEW_MANAGED == m_fViewOption && !(tempjoblist[i].lFlags & PCLFLAG_IS_MANAGED))
          continue;

        VERIFY( S_OK == AddNode(ipConsoleNameSpace2, new CJobItemFolder(this, tempjoblist[i]) ) );
      }
    }
  } while (res > 0 && PCERROR_MORE_DATA == GetLastPCError() );

  if (err)
    ReportPCError(err);

  ASSERT( 0 <= (counter = ScopeCount(m_ID, ipConsoleNameSpace2)) );  // Debugging aid only

  return S_OK;
}

int CJobFolder::ScopeCount(HSCOPEITEM ID, IConsoleNameSpace2 *ipConsoleNameSpace2)
{
  HSCOPEITEM curID, prevID;
  MMC_COOKIE Cookie;

  int count = 0;

  HRESULT hr = ipConsoleNameSpace2->GetChildItem(ID, &curID, &Cookie);
  while(hr == S_OK && curID)
  {
    prevID = curID;
    count++;

    hr = ipConsoleNameSpace2->GetNextItem(prevID, &curID, &Cookie);
  }

  return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\jobpages.h ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    JobsPages.h                                                              //
|                                                                                       //
|Description:  Definition of Job Property pages                                         //
|                                                                                       //
|Created:      Paul Skoglund 09-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#ifndef __JOBPAGES_H_
#define __JOBPAGES_H_

#include "Globals.h"
#include "ppage.h"
#include "container.h"


extern HRESULT CreatePropertyPagesForJobListItem(
                 const PCJobListItem &JobListItem,
                 LPPROPERTYSHEETCALLBACK lpProvider,
                 LONG_PTR handle,
                 CBaseNode *BaseNodePtr );
extern HRESULT CreatePropertyPagesForJobDetail(
                 const JOB_NAME &jobName,
                 LPPROPERTYSHEETCALLBACK lpProvider,
                 LONG_PTR handle,
                 CBaseNode *BaseNodePtr );


class CBaseNode;

class CJobIDPage :
	public CMySnapInPropertyPageImpl<CJobIDPage>
{
public :
  CJobIDPage(int nTitle, CJobDetailContainer *pContainer);

  ~CJobIDPage();

	enum { IDD = IDD_JOBID_PAGE };

  CComBSTR  m_bJob;
  CComBSTR  m_bComment;
  
  bool       m_processcountchk;
  PROC_COUNT m_processcount;

	BEGIN_MSG_MAP(CJobIDPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP,       OnWMHelp)
    COMMAND_HANDLER(IDC_JOB, EN_CHANGE, OnEditChange)
    COMMAND_HANDLER(IDC_COMMENT, EN_CHANGE, OnEditChange)
  	COMMAND_HANDLER(IDC_PROCESSCOUNT, EN_CHANGE, OnEditChange)
    COMMAND_HANDLER(IDC_PROCESSCOUNT_CHK, BN_CLICKED, OnChk)
  	CHAIN_MSG_MAP(CMySnapInPropertyPageImpl<CJobIDPage>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnEditChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

  BOOL OnHelp();
	BOOL OnKillActive()      { return Validate(TRUE); }
  BOOL OnApply();

	BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
	BOOL Validate(BOOL bSave = FALSE);

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  CJobDetailContainer      *m_pJobContainer;

  BOOL                      m_bReadOnly;

  union {
    struct
    {
      int jobName : 1;
			int comment : 1;
      int processcountchk : 1;
      int processcount : 1;
    } Fields;
    int on;
  } PageFields;

};


class CJobUnmanagedPage :
	public CMySnapInPropertyPageImpl<CJobUnmanagedPage>
{
public :
  CJobUnmanagedPage(int nTitle, CNewJobDetailContainer *pContainer, const PCSystemParms sysParms);

  ~CJobUnmanagedPage();

	enum { IDD = IDD_JOBDEF_PAGE };

  CComBSTR m_bName;

	BEGIN_MSG_MAP(CJobUnmanagedPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP,       OnWMHelp)
    COMMAND_HANDLER(IDC_ADD, BN_CLICKED, OnAdd)
  	CHAIN_MSG_MAP(CMySnapInPropertyPageImpl<CJobUnmanagedPage>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

  BOOL OnHelp();
	BOOL OnKillActive()      { return Validate(TRUE); }
  BOOL OnApply();

	BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
	BOOL Validate(BOOL bSave = FALSE);

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  CNewJobDetailContainer   *m_pJobContainer;

  BOOL                      m_bReadOnly;
  PCSystemParms             m_SystemParms;
};


#endif // __JOBPAGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\globals.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    Globals.cpp                                                              //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|Created:      Paul Skoglund 07-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#include "StdAfx.h"

#include "mmc.h"

#include "Globals.h"
#include "DataObj.h"
#include "BaseNode.h"

PROPERTY_CHANGE_HDR * AllocPropChangeInfo(CBaseNode *pFolder, int nHint, COMPUTER_CONNECTION_INFO &Target, BOOL bScopeItem, int nPageRef)
{
  PROPERTY_CHANGE_HDR *ptr = (PROPERTY_CHANGE_HDR *) CoTaskMemAlloc(sizeof(PROPERTY_CHANGE_HDR));

  if (ptr)
  {
    ptr->pFolder    = pFolder;
		ptr->nHint      = nHint;
    ptr->Target     = Target;
    ptr->bScopeItem = bScopeItem;
    ptr->nPageRef   = nPageRef;
  }
  return ptr;
}

PROPERTY_CHANGE_HDR *FreePropChangeInfo(PROPERTY_CHANGE_HDR *pInfo)
{
  if (pInfo)
  {
    CoTaskMemFree(pInfo);
  }
  return NULL;
}

const TCHAR *LoadStringHelper(ITEM_STR strOut, int id)
{
  strOut[0] = 0;

  VERIFY( LoadString(_Module.GetResourceInstance(), id, strOut, MAX_ITEM_LEN) );

  return strOut;
}


HRESULT UpdateRegistryHelper(int Id, BOOL bRegister)
{
    TCHAR SnapinNameStr[MAX_ITEM_LEN];
    const TCHAR *SnapinName;
    
    struct _ATL_REGMAP_ENTRY MapEntries[] = {
        { _T("SNAPIN_NAME"), _T("Process Control") },
        { NULL, NULL }
    };

    SnapinName = LoadStringHelper(SnapinNameStr, IDS_PROCCON_SNAPIN_NAME);
    if (SnapinName) {
        MapEntries[0].szData = SnapinName;
    }

    return _Module.UpdateRegistryFromResource(Id, bRegister, MapEntries);
}


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
// 
CBaseNode* ExtractBaseObject
(
  LPDATAOBJECT ipDataObject      // [in] IComponent pointer 
)
{
  HGLOBAL      hGlobal;
  HRESULT      hr  = S_OK;
  CBaseNode *pNode = NULL;

  hr = ExtractFromDataObject( ipDataObject,
                              CDataObject::s_cfBaseInternal, 
                              sizeof(CBaseNode **),
                              &hGlobal
                            );

  if( SUCCEEDED(hr) )
  {
    pNode = *(CBaseNode **)(hGlobal);
    ASSERT( NULL != pNode );    

    HGLOBAL hRetVal = GlobalFree(hGlobal);   
    ASSERT( NULL == hRetVal );        // Must return NULL
  }

  return pNode;

} // end ExtractBaseObject()

CDataObject* ExtractOwnDataObject
(
  LPDATAOBJECT ipDataObject      // [in] IComponent pointer 
)
{
  HGLOBAL      hGlobal;
  HRESULT      hr  = S_OK;
  CDataObject* pDO = NULL;

  hr = ExtractFromDataObject( ipDataObject,
                              CDataObject::s_cfInternal, 
                              sizeof(CDataObject **),
                              &hGlobal
                            );

  if( SUCCEEDED(hr) )
  {
    pDO = *(CDataObject **)(hGlobal);
    ASSERT( NULL != pDO );    

    HGLOBAL hRetVal = GlobalFree(hGlobal);   
    ASSERT( NULL == hRetVal );        // Must return NULL
  }

  return pDO;

} // end ExtractOwnDataObject()

//---------------------------------------------------------------------------
//  Extracts data based on the passed-in clipboard format
//
HRESULT ExtractFromDataObject
(
  LPDATAOBJECT ipDataObject,   // [in]  Points to data object
  UINT         cfClipFormat,   // [in]  Clipboard format to use
  SIZE_T       nByteCount,     // [in]  Number of bytes to allocate
  HGLOBAL      *phGlobal       // [out] Points to the data we want 
)
{
  HRESULT hr = S_OK;
  STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
  FORMATETC formatetc = { (CLIPFORMAT) cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

  *phGlobal = NULL;

  ASSERT( NULL != ipDataObject );
  if (!ipDataObject)
    return E_INVALIDARG;

  do 
	{
    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, nByteCount );

		if( !stgmedium.hGlobal )
    {
      hr = E_OUTOFMEMORY;
      ATLTRACE( _T("Out of memory\n") );
      break;
    }

    // Attempt to get data from the object
    hr = ipDataObject->GetDataHere( &formatetc, &stgmedium );
    if (FAILED(hr))
    {
      break;       
    }

    // stgmedium now has the data we need 
    *phGlobal = stgmedium.hGlobal;
    stgmedium.hGlobal = NULL;

  } while (0); 

  if (FAILED(hr) && stgmedium.hGlobal)
  {
    HGLOBAL hRetVal = GlobalFree(stgmedium.hGlobal);   
    ASSERT( NULL == hRetVal );         // Must return NULL
  }
  return hr;

} // end ExtractFromDataObject()


static UINT s_cfMultiSelect = ::RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);

BOOL IsMMCMultiSelectDataObject(IDataObject* pDataObject)
{
  if (pDataObject == NULL)
    return FALSE;

  ASSERT(s_cfMultiSelect != 0);

  FORMATETC fmt = { (CLIPFORMAT) s_cfMultiSelect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

  return (pDataObject->QueryGetData(&fmt) == S_OK);
}

// Caller must release memory, by calling LocalFree on the returned pointer
TCHAR *FormatErrorMessageIntoBuffer(DWORD nLastError)
{
	TCHAR *pLastErrorText = NULL;
	UINT_PTR vars[2];

  FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,
    NULL, nLastError, 
    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
    (TCHAR *)&pLastErrorText, 0, NULL );

  if ( !pLastErrorText )
  {
		FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,
			_Module.GetResourceInstance(), nLastError, 
      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
      (TCHAR *)&pLastErrorText, 0, NULL );
  }

  // $$ if string was returned consider striping trailing line feed and/or period?
  
  if (pLastErrorText)
    vars[0] = (UINT_PTR) pLastErrorText;
  else
    vars[0] = (UINT_PTR) _T("");

  vars[1] = (UINT_PTR) (LONG_PTR) nLastError;

  TCHAR *pMsgBuf = NULL;

  FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        _Module.GetResourceInstance(),
        MSG_OPERATION_FAILED_WITHCODES,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
        (TCHAR *) &pMsgBuf,
        0,                     // minimum buffer allocation
        (va_list *) &vars      // message inserts
        );

  LocalFree( pLastErrorText );

  if (!pMsgBuf)
  {
    ASSERT(pMsgBuf);
    pMsgBuf = (TCHAR *) LocalAlloc(0, 128);
    if (pMsgBuf)
      _stprintf( pMsgBuf, TEXT("Error 0x%lx. A description of the error was not located."), nLastError );  // Do NOT localize -- last resort.
  }

  return pMsgBuf;
}

BOOL ReportPCError(DWORD nLastError, HWND hwnd)
{  
	TCHAR *pMsgBuf = FormatErrorMessageIntoBuffer(nLastError);

  if ( pMsgBuf )
  {
    ATLTRACE( (TCHAR *) pMsgBuf );
    ATLTRACE( _T("\n") );

    int ret = ::MessageBox(hwnd, pMsgBuf, NULL, MB_OK | MB_ICONWARNING);

    LocalFree(pMsgBuf);

    return TRUE;
  }

  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\jobrulefolder.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    JobRuleFolder.cpp                                                        //
|                                                                                       //
|Description:  Implementation of job rule node                                          //
|                                                                                       //
|Created:      Paul Skoglund 09-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#include "StdAfx.h"
#include "BaseNode.h"

#include "ManagementPages.h"
#include "ManagementRuleWizards.h"
#include "JobPages.h"

#pragma warning(push)
#include <algorithm>
#pragma warning(pop)

using std::find;
using std::list<PCJobSummary*>;

const GUID         CJobRuleFolder::m_GUID   =   {0xff9baf64,0x064e,0x11d2,{0x80, 0x14,0x00,0x10,0x4b,0x9a,0x31,0x06} };
const TCHAR *const CJobRuleFolder::m_szGUID = _T("{ff9baf64-064e-11d2-8014-00104b9a3106}");

// Array of view items to be inserted into the context menu.
const CONTEXTMENUITEMBYID CJobRuleFolder::TopMenuItems[] =
{ 
  { IDS_JRULE_TOP,    ID_JRULE_NEW,    ID_JRULE_NEW, CCM_INSERTIONPOINTID_PRIMARY_TOP },
  { 0,                0,               0,            0                                }
};

const CONTEXTMENUITEMBYID CJobRuleFolder::NewMenuItems[] =
{ 
  { IDS_JRULE_NEW,    ID_JRULE_NEW,    ID_JRULE_NEW, CCM_INSERTIONPOINTID_PRIMARY_NEW },
  { 0,                0,               0,            0                                }
};

CJobRuleFolder::CJobRuleFolder(CBaseNode *pParent) : CBaseNode(JOBRULE_NODE, pParent), m_ID(0)
{
  LoadStringHelper(m_name, IDS_JOBRULE_FOLDER);
}

CJobRuleFolder::~CJobRuleFolder()
{
  ClearCache();
  ATLTRACE( _T("~CJobRuleFolder end\n"));
}

LPCTSTR CJobRuleFolder::GetNodeName()    
{ 
  return m_name;
}

HRESULT CJobRuleFolder::GetDisplayInfo(RESULTDATAITEM &ResultItem)
{
  if (ResultItem.bScopeItem)
  {
    if( ResultItem.mask & RDI_STR )
    {
			if (0 == ResultItem.nCol)
				ResultItem.str = const_cast<LPOLESTR>(GetNodeName());
			else
				ResultItem.str = _T("");
    }
    if (ResultItem.mask & RDI_IMAGE)
      ResultItem.nImage = sImage();
    return S_OK;
  }

  list<PCJobSummary*>::iterator item;

  item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCJobSummary*>(ResultItem.lParam) );

  if (item == Cache.end() )
    return E_UNEXPECTED;

  if (ResultItem.mask & RDI_IMAGE)
    ResultItem.nImage = JOBRULEITEMIMAGE;

  if (ResultItem.mask & RDI_STR)
  {
    PCJobSummary &ref = **item;
    LPCOLESTR &pstr = ResultItem.str;

    switch (ResultItem.nCol)
    {
    case JOB_COLUMN:
      pstr = ref.jobName;
      break;
    case DESCRIPTION_COLUMN:
      pstr = ref.mgmtParms.description;
      break;
    case APPLY_AFFINITY_COLUMN:
      pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_APPLY_AFFINITY);
      break;
    case AFFINITY_COLUMN:
			pstr = FormatAffinity(m_ResultStr, ref.mgmtParms.affinity);
      break;
    case APPLY_PRIORITY_COLUMN:
      pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_APPLY_PRIORITY);
      break;
    case PRIORITY_COLUMN:
      pstr = FormatPriority(m_ResultStr, ref.mgmtParms.priority);
      break;
		case APPLY_SCHEDULING_CLASS_COLUMN:
      pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_APPLY_SCHEDULING_CLASS);
      break;
		case SCHEDULING_CLASS_COLUMN:
			pstr = FormatSchedulingClass(m_ResultStr, ref.mgmtParms.schedClass);
      break;
    case APPLY_MINMAXWS_COLUMN:
      pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_APPLY_WS_MINMAX);
      break;
    case MINWS_COLUMN:
      pstr = FormatMemory(m_ResultStr, ref.mgmtParms.minWS);
      break;
    case MAXWS_COLUMN:
      pstr = FormatMemory(m_ResultStr, ref.mgmtParms.maxWS);
      break;
    case APPLY_PROC_CMEM_LIMIT_COLUMN:
      pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_APPLY_PROC_MEMORY_LIMIT);
      break;
    case PROC_CMEM_LIMIT_COLUMN:
      pstr = FormatMemory(m_ResultStr, ref.mgmtParms.procMemoryLimit);
      break;
    case APPLY_JOB_CMEM_LIMIT_COLUMN:
      pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMORY_LIMIT);
      break;
    case JOB_CMEM_LIMIT_COLUMN:
      pstr = FormatMemory(m_ResultStr, ref.mgmtParms.jobMemoryLimit);
      break;
    case APPLY_PROCCOUNT_LIMIT_COLUMN:
      pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_APPLY_PROC_COUNT_LIMIT);
      break;
    case PROCCOUNT_LIMIT_COLUMN:
      pstr = FormatProcCount(m_ResultStr, ref.mgmtParms.procCountLimit);
      break;
    case APPLY_PROC_CPUTIME_LIMIT_COLUMN:
      pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_APPLY_PROC_TIME_LIMIT);
      break;
    case PROC_CPUTIME_LIMIT_COLUMN:
      pstr = FormatCNSTime(m_ResultStr, ref.mgmtParms.procTimeLimitCNS);
      break;
    case APPLY_JOB_CPUTIME_LIMIT_COLUMN:
      pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_TIME_LIMIT);
      break;
    case JOB_CPUTIME_LIMIT_COLUMN:
      pstr = FormatCNSTime(m_ResultStr, ref.mgmtParms.jobTimeLimitCNS);
      break;
    case ACTION_JOB_CPUTIME_LIMIT_COLUMN:
      pstr = FormatCPUTIMELimitAction(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_MSG_ON_JOB_TIME_LIMIT_HIT);
      break;
    case ENDJOB_ON_NO_PROC_COLUMN:
      pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_END_JOB_WHEN_EMPTY);
      break;
    case DIE_ON_UNHANDLED_EXCEPT_COLUMN:
      pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_SET_DIE_ON_UH_EXCEPTION);
      break;
    case ALLOW_BREAKAWAY_COLUMN:
      pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_SET_PROC_BREAKAWAY_OK);
      break;
    case ALLOW_SILENT_BREAKAWAY_COLUMN:
      pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_SET_SILENT_BREAKAWAY);
      break;
    default:
      ASSERT(FALSE);
      pstr = _T("");
      break;
    }
  }
  return S_OK;
}

HRESULT CJobRuleFolder::OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2* ipHeaderCtrl, IConsole2* ipConsole2)
{
  ASSERT(hItem == GetID());

  if (!bSelecting)
    return S_OK;

  ITEM_STR str;

  LoadStringHelper(str, IDS_JOB_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( JOB_COLUMN, str, 0, JOB_COLUMN_WIDTH ));

	LoadStringHelper(str, IDS_DESCRIPTION_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( DESCRIPTION_COLUMN, str, 0, DESCRIPTION_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_APPLY_AFFINITY_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( APPLY_AFFINITY_COLUMN, str, 0, APPLY_AFFINITY_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_AFFINITY_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( AFFINITY_COLUMN, str, 0, AFFINITY_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_APPLY_PRIORITY_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( APPLY_PRIORITY_COLUMN, str, 0, APPLY_PRIORITY_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_PRIORITY_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( PRIORITY_COLUMN, str, 0, PRIORITY_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_APPLY_SCHEDULING_CLASS_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( APPLY_SCHEDULING_CLASS_COLUMN, str, 0, APPLY_SCHEDULING_CLASS_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_SCHEDULING_CLASS_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( SCHEDULING_CLASS_COLUMN, str, 0, SCHEDULING_CLASS_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_APPLY_MINMAXWS_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( APPLY_MINMAXWS_COLUMN, str, 0, APPLY_MINMAXWS_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_MINWS_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( MINWS_COLUMN, str, 0, MINWS_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_MAXWS_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( MAXWS_COLUMN, str, 0, MAXWS_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_APPLY_PROC_CMEM_LIMIT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( APPLY_PROC_CMEM_LIMIT_COLUMN, str, 0, APPLY_PROC_CMEM_LIMIT_COLUMN_WIDTH ));
 
  LoadStringHelper(str, IDS_PROC_CMEM_LIMIT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( PROC_CMEM_LIMIT_COLUMN, str, 0, PROC_CMEM_LIMIT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_APPLY_JOB_CMEM_LIMIT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( APPLY_JOB_CMEM_LIMIT_COLUMN, str, 0, APPLY_JOB_CMEM_LIMIT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_JOB_CMEM_LIMIT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( JOB_CMEM_LIMIT_COLUMN, str, 0, JOB_CMEM_LIMIT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_APPLY_PROCCOUNT_LIMIT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( APPLY_PROCCOUNT_LIMIT_COLUMN, str, 0, APPLY_PROCCOUNT_LIMIT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_PROCCOUNT_LIMIT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( PROCCOUNT_LIMIT_COLUMN, str, 0, PROCCOUNT_LIMIT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_APPLY_PROC_CPUTIME_LIMIT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( APPLY_PROC_CPUTIME_LIMIT_COLUMN, str, 0, APPLY_PROC_CPUTIME_LIMIT_COLUMN_WIDTH ));
  
  LoadStringHelper(str, IDS_PROC_CPUTIME_LIMIT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( PROC_CPUTIME_LIMIT_COLUMN, str, 0, PROC_CPUTIME_LIMIT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_APPLY_JOB_CPUTIME_LIMIT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( APPLY_JOB_CPUTIME_LIMIT_COLUMN, str, 0, APPLY_JOB_CPUTIME_LIMIT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_JOB_CPUTIME_LIMIT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( JOB_CPUTIME_LIMIT_COLUMN, str, 0, JOB_CPUTIME_LIMIT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_ACTION_JOB_CPUTIME_LIMIT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( ACTION_JOB_CPUTIME_LIMIT_COLUMN, str, 0, ACTION_JOB_CPUTIME_LIMIT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_ENDJOB_ON_NO_PROC_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( ENDJOB_ON_NO_PROC_COLUMN, str, 0, ENDJOB_ON_NO_PROC_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_DIE_ON_UNHANDLED_EXCEPT_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( DIE_ON_UNHANDLED_EXCEPT_COLUMN, str, 0, DIE_ON_UNHANDLED_EXCEPT_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_ALLOW_BREAKAWAY_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( ALLOW_BREAKAWAY_COLUMN, str, 0, ALLOW_BREAKAWAY_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_ALLOW_SILENT_BREAKAWAY_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( ALLOW_SILENT_BREAKAWAY_COLUMN, str, 0, ALLOW_SILENT_BREAKAWAY_COLUMN_WIDTH ));
  
  return OnRefresh(ipConsole2);  
}

HRESULT CJobRuleFolder::AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed)
{ 
  HRESULT hr = S_OK; 
  ITEM_STR name;
  ITEM_STR status;

  BOOL bConnected = GetPCid();

  CONTEXTMENUITEM m = { 0 };
  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
  {
    for (const CONTEXTMENUITEMBYID *M = TopMenuItems; M->lCommandID; M++)
    {
      m.strName          = const_cast<TCHAR *>(LoadStringHelper(name,   M->strNameID));
      m.strStatusBarText = const_cast<TCHAR *>(LoadStringHelper(status, M->strStatusBarTextID));
			m.lCommandID        = M->lCommandID;
			m.lInsertionPointID = M->lInsertionPointID;
			m.fFlags            = bConnected ? MF_ENABLED : MF_GRAYED;
 		  //m.fSpecialFlags   = 0;		// currently always 0, initialized to 0

      hr = piCallback->AddItem(&m);

      if (FAILED(hr))
        break;
    }
  }

  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW )
  {
    for (const CONTEXTMENUITEMBYID *M = NewMenuItems; M->lCommandID; M++)
    {
      m.strName          = const_cast<TCHAR *>(LoadStringHelper(name,   M->strNameID));
      m.strStatusBarText = const_cast<TCHAR *>(LoadStringHelper(status, M->strStatusBarTextID));
			m.lCommandID        = M->lCommandID;
			m.lInsertionPointID = M->lInsertionPointID;
			m.fFlags            = bConnected ? MF_ENABLED : MF_GRAYED;
 		  //m.fSpecialFlags   = 0;		// currently always 0, initialized to 0

      hr = piCallback->AddItem(&m);

      if (FAILED(hr))
        break;
    }
  }

  return hr; 
}

HRESULT CJobRuleFolder::OnHelpCmd(IDisplayHelp *ipDisplayHelp)
{
	if (!ipDisplayHelp)
		return E_UNEXPECTED;

	ipDisplayHelp->ShowTopic(const_cast<TCHAR *>(HELP_ru_job));

	return S_OK;
}


HRESULT CJobRuleFolder::OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb )
{
  ASSERT(bScope);

  if (bSelect)
  {
    VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE ) == S_OK);
    VERIFY( ipConsoleVerb->SetDefaultVerb( MMC_VERB_OPEN ) == S_OK );
  }
  return S_OK;
}

HRESULT CJobRuleFolder::OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie)
{
  ASSERT(!bScope);

  VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE ) == S_OK);
  if (bSelect && !bScope)  // incase the rules are changed again leave !bScope test
  {
    VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE ) == S_OK);  
    VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_DELETE,     ENABLED, TRUE ) == S_OK);  
    VERIFY( ipConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES ) == S_OK ); 
  }
  return S_OK;
}

HRESULT CJobRuleFolder::OnMenuCommand(IConsole2 *ipConsole2, long nCommandID )
{
  HRESULT hr = S_FALSE;

  switch(nCommandID)
  {
		case ID_JRULE_DEFINE:
    case ID_JRULE_NEW:
      {
        PCid hID = GetPCid();
        PCSystemInfo SystemInfo;
        if (!hID || !PCGetServiceInfo(hID, &SystemInfo, sizeof(SystemInfo)))
        {
          ReportPCError();
          return S_OK;
        }

        PCJobSummary *ptr = new PCJobSummary[1];
        if (!ptr)
          return E_UNEXPECTED;

        PCJobDetail  JobDetail = { 0 };
                
        if (GroupRuleWizard(IDS_JRULE_CREATE_TITLE, JobDetail, SystemInfo.sysParms, NULL) )
        {
          if (PCAddJobDetail(hID, &JobDetail) )
          {
            *ptr = JobDetail.base;
            MemBlocks.push_front(ptr);
            Cache.push_front(ptr);
            VERIFY(S_OK == SendViewChange(ipConsole2, (INT_PTR) ptr, PC_VIEW_ADDITEM));
            return S_OK;
          }
          ReportPCError();
        }
        delete [] ptr;
      }
      return S_OK;  // we handled the message...
      break;
    default:
      break;
  }

  return hr;  
}

HRESULT CJobRuleFolder::OnMenuCommand(IConsole2 *ipConsole2, long nCommandID, LPARAM Cookie )
{
  return OnMenuCommand(ipConsole2, nCommandID);
}

HRESULT CJobRuleFolder::OnViewChange(IResultData *ipResultData, LPARAM thing, LONG_PTR hint)
{
  ASSERT(ipResultData);
  if (!ipResultData)  
    return E_UNEXPECTED;

  VERIFY(ipResultData->ModifyViewStyle(MMC_SINGLESEL, MMC_NOSORTHEADER) == S_OK);

  list<PCJobSummary*>::iterator item;

  HRESULT hr = E_UNEXPECTED;
  switch (hint)
  {
  case PC_VIEW_REDRAWALL:// not currently used
    hr = ShowAllItems(ipResultData, TRUE);
    break;
  case PC_VIEW_SETITEM:  // not currently used
    ASSERT(FALSE);       // add smarter support for this hint...
    hr = ShowAllItems(ipResultData, TRUE);
    break;
  case PC_VIEW_UPDATEALL:
    hr = ShowAllItems(ipResultData, FALSE);
    break;
  case PC_VIEW_UPDATEITEM:
    {
    HRESULTITEM hItem;
    hr = ipResultData->FindItemByLParam(thing, &hItem);
    if (hr == S_OK)
      hr = ipResultData->UpdateItem(hItem);    
    }
    break;
  case PC_VIEW_ADDITEM:
    item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCJobSummary*>(thing) );
    if (item == Cache.end())
      hr = E_UNEXPECTED;  
    else
    {
      RESULTDATAITEM data = { 0 };
      data.mask       = RDI_STR | RDI_IMAGE | RDI_PARAM | RDI_STATE;
      data.bScopeItem = FALSE;
      //data.itemID
      //data.nIndex
      //data.nCol
      data.str        = (LPOLESTR)MMC_CALLBACK;
      data.nImage     = JOBRULEITEMIMAGE;
      //data.nState
      //data.iIndent //reserved
      data.lParam     = thing;
      //data.nState
      hr = ipResultData->InsertItem(&data);
    }
    break;
  case PC_VIEW_DELETEITEM:
    {
    HRESULTITEM hItem;
    hr = ipResultData->FindItemByLParam(thing, &hItem);
    if (hr == S_OK)
      hr = ipResultData->DeleteItem(hItem, 0);    
    }
    break;
  default:
    hr = E_UNEXPECTED;
    break;
  }
  ASSERT(hr == S_OK);
  return hr;
}

HRESULT CJobRuleFolder::ShowAllItems(IResultData* ipResultData, BOOL bCacheValid)
{
  list<PCJobSummary*>::iterator item;
  LPARAM selected = 0;
  LPARAM focused  = 0;

  RESULTDATAITEM data;

  if (bCacheValid)
  {
    memset(&data, 0, sizeof(data));
	  data.nIndex = -1; 
	  data.nState = LVIS_SELECTED;
	  data.mask   = RDI_STATE;

	  if (S_OK == ipResultData->GetNextItem(&data) && data.nIndex != -1 )
    {
      selected = data.lParam;
    }

	  memset(&data, 0, sizeof(data));
	  data.nIndex = -1;
	  data.nState = LVIS_FOCUSED;
	  data.mask   = RDI_STATE;

	  if (S_OK == ipResultData->GetNextItem(&data) && data.nIndex != -1)
    {
      focused = data.lParam;
    }
  }

  ipResultData->DeleteAllRsltItems();

  memset(&data, 0, sizeof(data));
  data.mask = RDI_STR | RDI_IMAGE | RDI_PARAM | RDI_STATE;
  data.bScopeItem = FALSE;
  //data.itemID;
  data.nIndex = 0;
  data.nCol = 0;
  data.str = (LPOLESTR)MMC_CALLBACK;
  data.nImage = JOBRULEITEMIMAGE;

  data.iIndent = 0; //reserved

  HRESULT hr = S_OK;
  for (list<PCJobSummary*>::iterator i = Cache.begin(); i != Cache.end(); ++i)
  {
    data.lParam = reinterpret_cast<LPARAM>(*i);

    data.nState = 0;
 		if (data.lParam == selected)
  		data.nState |= LVIS_SELECTED;
    if (data.lParam == focused)
			data.nState |= LVIS_FOCUSED;
    
    hr = ipResultData->InsertItem(&data);
    if (hr != S_OK)
      break;
  }
  
  return hr;
}


void CJobRuleFolder::ClearCache()
{
  Cache.clear();

  for (list<PCJobSummary*>::iterator chunck = MemBlocks.begin(); chunck != MemBlocks.end(); ++chunck)
  {
    delete [] (*chunck);
  }
  MemBlocks.clear();
}

BOOL CJobRuleFolder::RefreshCache()
{
  PCINT32  res = 0;
  PCULONG32 err = 0;
  PCJobSummary *last = NULL;

  const int MINIMUM_ALLOCATION = min((COM_BUFFER_SIZE/sizeof(PCJobSummary)), 100);

  ClearCache();

  PCid hID = GetPCid();
  if (!hID)
  {
    ReportPCError();
    return false;
  }

  do
  {
    PCJobSummary *ptr = new PCJobSummary[MINIMUM_ALLOCATION];

    if (!ptr)
    {
      err = ERROR_OUTOFMEMORY;
      break;
    }

    if (last)
      memcpy(ptr, last, sizeof(PCJobSummary));
    else
      memset(ptr, 0, sizeof(PCJobSummary));

    res = PCGetJobSummary( hID, ptr, MINIMUM_ALLOCATION * sizeof(PCJobSummary));
    if (res < 0 )
    {
      err = GetLastPCError();
      // ATLTRACE(_T("PCJobSummary returned error 0x%lX\n"), err);
      delete [] ptr;
      break;
    }

    if (res > 0)
    {
      last = &ptr[res - 1];

      MemBlocks.push_front(ptr);
      for (INT32 i = 0; i < res; i++)
      {
        Cache.insert(Cache.end(), ptr);
        ptr++;
      }
    }
  } while (res > 0 && PCERROR_MORE_DATA == GetLastPCError() );

  if (err)
    ReportPCError();

  return err == 0;
}

HRESULT CJobRuleFolder::QueryPagesFor(LPARAM Cookie)
{
  list<PCJobSummary*>::iterator item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCJobSummary*>(Cookie) );

  if (item != Cache.end() )
    return S_OK;
    
  return E_UNEXPECTED;
}

HRESULT CJobRuleFolder::OnCreatePropertyPages( LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, DATA_OBJECT_TYPES context, LPARAM Cookie) 
{
  list<PCJobSummary*>::iterator item;
  item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCJobSummary*>(Cookie) );

  if (item == Cache.end() )
    return E_UNEXPECTED;

  return CreatePropertyPagesForJobDetail((*item)->jobName, lpProvider, handle, this);
}

HRESULT CJobRuleFolder::OnPropertyChange(PROPERTY_CHANGE_HDR *pUpdate, IConsole2 *ipConsole2)
{
	return OnRefresh(ipConsole2);
}

HRESULT CJobRuleFolder::OnDelete(IConsole2 *ipConsole2, LPARAM Cookie)
{ 
  list<PCJobSummary*>::iterator item;

  item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCJobSummary *>(Cookie));
  if (item == Cache.end() )
  {
    SendViewChange(ipConsole2, NULL, PC_VIEW_UPDATEALL);
    return E_UNEXPECTED;
  }

  PCJobDetail Detail;
  memset(&Detail, 0, sizeof(Detail));
  memcpy(&(Detail.base), (*item), sizeof(PCJobSummary) );

  if (!PCDeleteJobDetail(GetPCid(), &Detail))
  {
    ReportPCError();
    return E_UNEXPECTED;
  }

  Cache.erase(item);

  return SendViewChange(ipConsole2, Cookie, PC_VIEW_DELETEITEM);
}

HRESULT CJobRuleFolder::OnRefresh(IConsole2 *ipConsole2)
{
  RefreshCache();
  return SendViewChange(ipConsole2, NULL, PC_VIEW_UPDATEALL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\jobpages.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    JobPages.cpp                                                             //
|                                                                                       //
|Description:  Implementation of Job pages                                              //
|                                                                                       //
|Created:      Paul Skoglund 09-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#include "stdafx.h"

#include "JobPages.h"
#include "ManagementPages.h"
#include "ManagementRuleWizards.h"

static HRESULT ConstructJobDetailPropPages (LPPROPERTYSHEETCALLBACK lpProvider, 
                                            CJobDetailContainer *pContainer, 
                                            const PCJobDetail  &JobDetail,
                                            const PCSystemParms &SystemParms);
#if _MSC_VER >= 1200
#pragma warning( push )
#endif
#pragma warning( disable : 4800 ) //warning C4800: 'unsigned long' : forcing value to bool 'true' or 'false' (performance warning)

CJobIDPage::CJobIDPage(int nTitle, CJobDetailContainer *pContainer) : 
    CMySnapInPropertyPageImpl<CJobIDPage>(nTitle), 
    m_pJobContainer(pContainer), m_bJob(_T("")), m_bComment(_T(""))
{
  ASSERT(sizeof(PageFields.on) == sizeof(PageFields));

  PageFields.on     = 0;
  m_bReadOnly       = FALSE;

  m_processcountchk = FALSE;
  m_processcount    = 0;
  m_psp.dwFlags |= PSP_HASHELP;

  m_pJobContainer->AddRef();
}

CJobIDPage::~CJobIDPage()
{
  m_pJobContainer->Release();
}

LRESULT CJobIDPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	CComBSTR bTitle;

	PropSheet_SetTitle( GetParent(), PSH_PROPTITLE, FormatSheetTitle(bTitle, m_bJob, m_pJobContainer->GetConnectionInfo()));

	DisableControl(IDC_JOB);

  UpdateData(FALSE);

  bHandled = FALSE;

  // Setting focus when a property page does not work...

	return TRUE;  // Let the system set the focus
}

LRESULT CJobIDPage::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HELPINFO *phi = (HELPINFO*) lParam;
	if (phi && phi->iContextType == HELPINFO_WINDOW)
	{
    IDCsToIDHs HelpMap[]={{IDC_JOB,              HELP_GRPID_NAME         }, 
                          {IDC_COMMENT,          HELP_GRPID_COMMENT      }, 
                          {IDC_PROCCOUNT_FRAME,  HELP_PROCCOUNT_FRAME    }, 
                          {IDC_PROCESSCOUNT_CHK, HELP_PROCCOUNT_APPLY    },
                          {IDC_PROCESSCOUNT,     HELP_PROCCOUNT_MAX      }, 
                          {IDC_SPIN,             HELP_PROCCOUNT_MAX_SPIN },
                          {0,0} };

    ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap); 
		return TRUE;
	}
	bHandled = FALSE;
	return FALSE;
}

BOOL CJobIDPage::OnHelp()
{
	MMCPropertyHelp(const_cast<TCHAR*>(HELP_ru_job_name));
	return TRUE;
}

BOOL CJobIDPage::Validate(BOOL bSave)
{
  CComBSTR bStr;
  CComBSTR bComment;

  bStr.Empty();
  if (!GetDlgItemText( IDC_JOB, bStr.m_str ) || 
      !IsValidName(bStr, FALSE) )
  {
    HWND hWndCtl = GetDlgItem(IDC_JOB);
		if(hWndCtl)
      ::SetFocus(hWndCtl);

    ITEM_STR strOut;
    LoadStringHelper(strOut, IDS_JOBNAME_WARNING);
    MessageBox(strOut, NULL, MB_OK | MB_ICONWARNING);

    return FALSE;
  }

  if ( !GetDlgItemText(IDC_COMMENT, bComment.m_str) )
    bComment = _T("");
  if (bComment.Length() > RULE_DESCRIPTION_LEN)
  {
    HWND hWndCtl = GetDlgItem(IDC_COMMENT);
		if(hWndCtl)
      ::SetFocus(hWndCtl);
    MessageBeep(MB_ICONASTERISK);
    return FALSE;
  }

  LONG_PTR PosErr = 0;
  LRESULT processcount = SendDlgItemMessage(IDC_SPIN, UDM_GETPOS32, 0, (LPARAM) &PosErr);

  if (PosErr || processcount < 0)
  {
    HWND hWndCtl = GetDlgItem(IDC_PROCESSCOUNT);
		if(hWndCtl)
      ::SetFocus(hWndCtl);
		MessageBeep(MB_ICONASTERISK);
    return FALSE;
  }

  if (bSave)
	{
    _tcscpy(m_pJobContainer->m_new.base.mgmtParms.description, bComment);
    SetMGMTFlag(m_pJobContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_APPLY_PROC_COUNT_LIMIT, (BST_CHECKED == IsDlgButtonChecked(IDC_PROCESSCOUNT_CHK)));
    m_pJobContainer->m_new.base.mgmtParms.procCountLimit = (PROC_COUNT) processcount;
	}
  return TRUE;
}

BOOL CJobIDPage::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
		return Validate(TRUE);
  }
  else
  {
    VERIFY(SetDlgItemText( IDC_JOB,     m_bJob.m_str     ));
    VERIFY(SetDlgItemText( IDC_COMMENT, m_bComment.m_str ));
    SendDlgItemMessage( IDC_COMMENT,   EM_SETLIMITTEXT,  RULE_DESCRIPTION_LEN, 0);

    CheckDlgButton(IDC_PROCESSCOUNT_CHK, m_processcountchk ? BST_CHECKED : BST_UNCHECKED);

    SendDlgItemMessage(IDC_SPIN, UDM_SETRANGE32, 0, MAXLONG-1 );
 		SendDlgItemMessage(IDC_SPIN, UDM_SETPOS32,   0, m_processcount );

    if (m_bReadOnly || !m_processcountchk)
    {
      DisableControl(IDC_PROCESSCOUNT);
      DisableControl(IDC_SPIN);
    }
    if (m_bReadOnly)
		{
    	DisableControl(IDC_JOB);
      DisableControl(IDC_COMMENT);
      DisableControl(IDC_PROCESSCOUNT_CHK);
		}

    return TRUE;
  }
}

LRESULT CJobIDPage::OnEditChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  CComBSTR bStr; // GetDlgItemText returns FALSE, and doesn't create an empty 

  switch (wID) {
  case IDC_JOB:
    if (! GetDlgItemText(wID, bStr.m_str) )
      bStr = _T("");
    PageFields.Fields.jobName = (0 != _tcscmp(bStr, m_bJob));
    break;
  case IDC_COMMENT:
    if (! GetDlgItemText(wID, bStr.m_str) )
      bStr = _T("");
    PageFields.Fields.comment = (0 != _tcscmp(bStr, m_bComment));
    break;
  case IDC_PROCESSCOUNT:
    {
	  LRESULT processcount = SendDlgItemMessage(IDC_SPIN, UDM_GETPOS32, 0, 0);
    PageFields.Fields.processcount = ((PROC_COUNT) processcount != m_processcount);
    }
    break;
  default:
    ASSERT(FALSE);
    break;
  }

  SetModified(PageFields.on);
  
  bHandled = FALSE;
  return 0;
}

LRESULT CJobIDPage::OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_PROCESSCOUNT_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_PROCESSCOUNT_CHK));
    PageFields.Fields.processcountchk = (m_processcountchk != checked);

    ::EnableWindow(GetDlgItem(IDC_PROCESSCOUNT), checked);
    ::EnableWindow(GetDlgItem(IDC_SPIN),         checked);

    SetModified(PageFields.on);
  }
  bHandled = FALSE;
  return 0;
}


BOOL CJobIDPage::OnApply()
{
  if (m_bReadOnly || !PageFields.on)  
    return TRUE;

  if (m_pJobContainer->Apply( GetParent() ))
	{
		PageFields.on = 0;
    m_bComment = m_pJobContainer->m_new.base.mgmtParms.description;
    
    m_processcountchk = (m_pJobContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_APPLY_PROC_COUNT_LIMIT);
    m_processcount = m_pJobContainer->m_new.base.mgmtParms.procCountLimit;

    return TRUE; 
	}

  return FALSE;
}


///////////////////////////////////////////////////////////////////////////
//  Unmanaged Procees Page Implementation

CJobUnmanagedPage::CJobUnmanagedPage(int nTitle, CNewJobDetailContainer *pContainer, const PCSystemParms sysParms) :
    CMySnapInPropertyPageImpl<CJobUnmanagedPage>(nTitle), 
    m_pJobContainer(pContainer), m_SystemParms(sysParms), m_bName(_T(""))
{
  m_bReadOnly = FALSE;
  m_psp.dwFlags |= PSP_HASHELP;
  m_pJobContainer->AddRef();
}

CJobUnmanagedPage::~CJobUnmanagedPage()
{
  m_pJobContainer->Release();
}


LRESULT CJobUnmanagedPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	CComBSTR bTitle;
	PropSheet_SetTitle( GetParent(), PSH_PROPTITLE, FormatSheetTitle(bTitle, m_bName, m_pJobContainer->GetConnectionInfo()));

  DisableControl(IDC_NAME);

  if (m_bReadOnly)
	  DisableControl(IDC_ADD);

  UpdateData(FALSE);

  bHandled = FALSE;

  // Setting focus when a property page does not work...

	return TRUE;  // Let the system set the focus
}

LRESULT CJobUnmanagedPage::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HELPINFO *phi = (HELPINFO*) lParam;
	if (phi && phi->iContextType == HELPINFO_WINDOW)
	{
    IDCsToIDHs HelpMap[]={{IDC_NAME, HELP_GRPDEF_NAME }, 
                          {IDC_ADD,  HELP_GRPDEF_ADD  }, 
                          {0,0} };

    ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap); 
		return TRUE;
	}
	bHandled = FALSE;
	return FALSE;
}

BOOL CJobUnmanagedPage::OnHelp()
{
	MMCPropertyHelp(const_cast<TCHAR*>(HELP_ru_job));
	return TRUE;
}


LRESULT CJobUnmanagedPage::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wNotifyCode != BN_CLICKED || wID != IDC_ADD)
  {
    bHandled = FALSE;
    return 1;
  }

  PCJobDetail  JobDetail = { 0 };

  JOB_NAME  jname;

  _tcscpy(jname, m_bName);
  
  
  if (GroupRuleWizard(IDS_JRULE_DEFINE, JobDetail, m_SystemParms, &jname) )
  {
    m_pJobContainer->m_new = JobDetail;

    ::PostMessage(GetParent(), PSM_PRESSBUTTON, (WPARAM) PSBTN_OK, 0);
  }

  return 0;
}

BOOL CJobUnmanagedPage::Validate(BOOL bSave)
{
	return TRUE;
}

BOOL CJobUnmanagedPage::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
    return Validate(TRUE);
  }
  else
  {    
    VERIFY(SetDlgItemText( IDC_NAME, m_bName.m_str ));
    return TRUE;
  }
}

BOOL CJobUnmanagedPage::OnApply()
{
  if (m_bReadOnly)  
    return TRUE;

  if (m_pJobContainer->Apply(GetParent()) )
    return TRUE;

  return FALSE;
}

// Property Page Helper functions...

HRESULT CreatePropertyPagesForJobListItem( const PCJobListItem &JobListItem,
                                             LPPROPERTYSHEETCALLBACK lpProvider,
                                             LONG_PTR handle,
                                             CBaseNode *BaseNodePtr )
{
  if ( JobListItem.lFlags & PCLFLAG_IS_DEFINED )
  {
    return CreatePropertyPagesForJobDetail(JobListItem.jobName, lpProvider, handle, BaseNodePtr);
  }

  PCid hID = BaseNodePtr->GetPCid();
  PCSystemInfo sysInfo;

  if (!hID ||
      !PCGetServiceInfo(hID, &sysInfo, sizeof(sysInfo)) )
  {
    BaseNodePtr->ReportPCError();
    return S_OK;
  }

  COMPUTER_CONNECTION_INFO   ConnInfo;
	BaseNodePtr->GetComputerConnectionInfo(ConnInfo);

  PCJobDetail JobDetail = { 0 };
  _tcscpy(JobDetail.base.jobName, JobListItem.jobName);

  CNewJobDetailContainer *pContainer = new CNewJobDetailContainer(JobDetail, BaseNodePtr, handle, hID, ConnInfo, 0, FALSE, -1);
  if (pContainer)
  {
    CJobUnmanagedPage *pPage = new CJobUnmanagedPage(NULL, pContainer, sysInfo.sysParms);
    if (pPage)
    {
      pPage->m_bName = JobListItem.jobName;
      lpProvider->AddPage(pPage->Create());
    }
    pContainer->Release();
    pContainer = NULL;
  }

	return S_OK;
}

HRESULT CreatePropertyPagesForJobDetail( const JOB_NAME &jobName,                                                              
                                         LPPROPERTYSHEETCALLBACK lpProvider,
                                         LONG_PTR handle,
                                         CBaseNode *BaseNodePtr ) 
{
  PCid hID = BaseNodePtr->GetPCid();

  PCSystemInfo sysInfo; 

  PCJobDetail JobDetail = { 0 };
  _tcscpy(JobDetail.base.jobName, jobName);

  PCINT32 nUpdateCtr = 0;

  if (!hID ||
      !PCGetJobDetail  (hID, &JobDetail, sizeof(JobDetail), &nUpdateCtr) ||
      !PCGetServiceInfo(hID, &sysInfo, sizeof(sysInfo)) )
  {
    BaseNodePtr->ReportPCError();
    return S_OK;
  }

 	COMPUTER_CONNECTION_INFO   ConnInfo;
  BaseNodePtr->GetComputerConnectionInfo(ConnInfo);
  
  CJobDetailContainer *pContainer = new CJobDetailContainer(JobDetail, BaseNodePtr, handle, hID, ConnInfo, nUpdateCtr, FALSE, -1);

  if (pContainer)
  {
    ConstructJobDetailPropPages(lpProvider, pContainer, JobDetail, sysInfo.sysParms);
    pContainer->Release();
    pContainer = NULL;
  }

 	return S_OK;
}
  

HRESULT ConstructJobDetailPropPages(LPPROPERTYSHEETCALLBACK lpProvider, CJobDetailContainer *pContainer, const PCJobDetail &JobDetail, const PCSystemParms &SystemParms)
{
  CJobIDPage *pPage1 = new CJobIDPage(NULL, pContainer);
  if (pPage1)
  {
    pPage1->m_bJob  = JobDetail.base.jobName;

    pPage1->m_bComment = JobDetail.base.mgmtParms.description;

    pPage1->m_processcountchk = (JobDetail.base.mgmtParms.mFlags & PCMFLAG_APPLY_PROC_COUNT_LIMIT  );
    pPage1->m_processcount    =  JobDetail.base.mgmtParms.procCountLimit;

    lpProvider->AddPage(pPage1->Create());
  }

  CMGMTAffinityPage *pPage2 = new CMGMTAffinityPage(NULL, pContainer, SystemParms.processorMask);
  if (pPage2)
  {
    pPage2->m_affinitychk = (JobDetail.base.mgmtParms.mFlags & PCMFLAG_APPLY_AFFINITY);
    pPage2->m_affinity    =  JobDetail.base.mgmtParms.affinity;

    lpProvider->AddPage(pPage2->Create());
  }

  CMGMTPriorityPage *pPage3 = new CMGMTPriorityPage(NULL, pContainer);
  if (pPage3)
  {
    pPage3->m_prioritychk = (JobDetail.base.mgmtParms.mFlags & PCMFLAG_APPLY_PRIORITY);
    pPage3->m_priority    =  JobDetail.base.mgmtParms.priority;

    lpProvider->AddPage(pPage3->Create());
  }

  CMGMTSchedulingClassPage *pPage4 = new CMGMTSchedulingClassPage(NULL, pContainer);
  if (pPage4)
  {
    pPage4->m_schedClasschk = (JobDetail.base.mgmtParms.mFlags & PCMFLAG_APPLY_SCHEDULING_CLASS);
    pPage4->m_schedClass    =  JobDetail.base.mgmtParms.schedClass;

    lpProvider->AddPage(pPage4->Create());
  }

  CMGMTMemoryPage *pPage5 = new CMGMTMemoryPage(NULL, pContainer);
  if (pPage5)
  {
    pPage5->m_WSchk =(JobDetail.base.mgmtParms.mFlags & PCMFLAG_APPLY_WS_MINMAX);
    pPage5->m_minWS = JobDetail.base.mgmtParms.minWS;
    pPage5->m_maxWS = JobDetail.base.mgmtParms.maxWS;
    pPage5->m_procmemorylimitchk = (JobDetail.base.mgmtParms.mFlags & PCMFLAG_APPLY_PROC_MEMORY_LIMIT);
    pPage5->m_procmemorylimit    = JobDetail.base.mgmtParms.procMemoryLimit;
    pPage5->m_jobmemorylimitchk  = (JobDetail.base.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMORY_LIMIT);
    pPage5->m_jobmemorylimit     = JobDetail.base.mgmtParms.jobMemoryLimit;

    lpProvider->AddPage(pPage5->Create());
  }

  CMGMTTimePage *pPage6 = new CMGMTTimePage(NULL, pContainer);
  if (pPage6)
  {
    pPage6->m_procusertimechk   = (JobDetail.base.mgmtParms.mFlags & PCMFLAG_APPLY_PROC_TIME_LIMIT);
    pPage6->m_procusertime      =  JobDetail.base.mgmtParms.procTimeLimitCNS;
    pPage6->m_jobusertimechk    = (JobDetail.base.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_TIME_LIMIT);
    pPage6->m_jobusertime       =  JobDetail.base.mgmtParms.jobTimeLimitCNS;
    pPage6->m_jobmsgontimelimit = (JobDetail.base.mgmtParms.mFlags & PCMFLAG_MSG_ON_JOB_TIME_LIMIT_HIT);

    lpProvider->AddPage(pPage6->Create());
  }

  CMGMTAdvancedPage *pPage7 = new CMGMTAdvancedPage(NULL, pContainer);
  if (pPage7)
  {
    pPage7->m_endjob          = (JobDetail.base.mgmtParms.mFlags & PCMFLAG_END_JOB_WHEN_EMPTY );
    pPage7->m_unhandledexcept = (JobDetail.base.mgmtParms.mFlags & PCMFLAG_SET_DIE_ON_UH_EXCEPTION );
    pPage7->m_breakaway       = (JobDetail.base.mgmtParms.mFlags & PCMFLAG_SET_PROC_BREAKAWAY_OK   );
    pPage7->m_silentbreakaway = (JobDetail.base.mgmtParms.mFlags & PCMFLAG_SET_SILENT_BREAKAWAY    );

    lpProvider->AddPage(pPage7->Create());
  }

  return S_OK;
}

#if _MSC_VER >= 1200
#pragma warning( pop )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\managementrulewizards.h ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    ManagementRuleWizards.h                                                  //
|                                                                                       //
|Description:  Implementation of management rule wizards                                //
|                                                                                       //
|Created:      Paul Skoglund 09-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#ifndef __MANAGEMENTRULEWIZARDS_H__
#define __MANAGEMENTRULEWIZARDS_H__

#include "BaseNode.h"
#include "ppage.h"


extern bool GetGrpNameList(PCid id, list<tstring> &jobs);
extern list<tstring> *GetGrpNameList(PCid id);

BOOL IsValidName(const CComBSTR &bStr, BOOL nullOK);

extern BOOL ProcRuleWizard(int nTitle, const list<tstring> &jobsdefined, PCProcDetail &out, const PCSystemParms &SystemParms, PROC_NAME *procName = NULL);
extern BOOL GroupRuleWizard(int nTitle, PCJobDetail &out, const PCSystemParms &SystemParms, JOB_NAME *jobName = NULL);

class CProcNameWiz :
	public CMySnapInPropertyWizardImpl<CProcNameWiz>
{
public :
  CProcNameWiz(WIZ_POSITION pos, int nTitle, PCProcDetail *ProcDetail);

  ~CProcNameWiz();

	enum { IDD               = IDD_PROCNAME_WIZ             };
  enum { ID_HeaderTitle    = IDS_PROCESSALIAS_HDRTITLE    };
  enum { ID_HeaderSubTitle = IDS_PROCESSALIAS_HDRSUBTITLE };

	BEGIN_MSG_MAP(CProcNameWiz)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		MESSAGE_HANDLER(WM_HELP,       OnWMHelp)    
  	CHAIN_MSG_MAP(CMySnapInPropertyWizardImpl<CProcNameWiz>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

  BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
  BOOL OnWizardNext();

  void SetReadOnly()          { m_bReadOnly     = TRUE;}
  void SetNoNameChange()      { m_bNoNameChange = TRUE;}

private:
  PCProcDetail     *m_pProcDetail;
  BOOL              m_bReadOnly;
  BOOL              m_bNoNameChange;
};


class CProcGrpMemberWiz :
	public CMySnapInPropertyWizardImpl<CProcGrpMemberWiz>
{
public :
  CProcGrpMemberWiz(WIZ_POSITION pos, int nTitle, PCProcDetail *ProcDetail, const list<tstring> &jobsdefined);
  ~CProcGrpMemberWiz();

  enum { IDD               = IDD_PROCJOBMEMBER_WIZ  };
  enum { ID_HeaderTitle    = IDS_GRPMEM_HDRTITLE    };
  enum { ID_HeaderSubTitle = IDS_GRPMEM_HDRSUBTITLE };
  
	BEGIN_MSG_MAP(CProcGrpMemberWiz)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog) 
		MESSAGE_HANDLER(WM_HELP,       OnWMHelp)    
    COMMAND_HANDLER(IDC_JOBMEMBER_CHK, BN_CLICKED, OnJobChk)
  	CHAIN_MSG_MAP(CMySnapInPropertyWizardImpl<CProcGrpMemberWiz>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnJobChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

  BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
  BOOL OnWizardNext();

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  PCProcDetail     *m_pProcDetail;
  BOOL              m_bReadOnly;

	const list<tstring> &m_JobsExisting;
};


class CAffinityWiz :
	public CMySnapInPropertyWizardImpl<CAffinityWiz>
{
public :
  CAffinityWiz(WIZ_POSITION pos, int nTitle, PCProcDetail *ProcDetail, AFFINITY ProcessorMask = 0xFFffFFff);
  CAffinityWiz(WIZ_POSITION pos, int nTitle, PCJobDetail   *JobDetail, AFFINITY ProcessorMask = 0xFFffFFff);

  ~CAffinityWiz();

	enum { IDD               = IDD_AFFINITY_WIZ         };
  enum { ID_HeaderTitle    = IDS_AFFINITY_HDRTITLE    };
  enum { ID_HeaderSubTitle = IDS_AFFINITY_HDRSUBTITLE };

	BEGIN_MSG_MAP(CAffinityWiz)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		MESSAGE_HANDLER(WM_HELP,       OnWMHelp)    
    COMMAND_RANGE_HANDLER(IDC_AFFINITY1, IDC_AFFINITY64, OnAffinityEdit)
    COMMAND_HANDLER(IDC_AFFINITY_CHK, BN_CLICKED, OnChk)
  	CHAIN_MSG_MAP(CMySnapInPropertyWizardImpl<CAffinityWiz>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnAffinityEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

  BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
  BOOL OnWizardNext();

  BOOL OnSetActive();

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  typedef enum _PageType
  {
    PROCESS_PAGE,
    JOB_PAGE,
  } PageType;
  PageType          m_PageType;
  PCProcDetail     *m_pProcDetail;
  PCJobDetail      *m_pJobDetail;

  BOOL              m_bReadOnly;
  AFFINITY          m_ProcessorMask;

  void Initialize();
  void ApplyControlEnableRules(BOOL bForceDisable);
};


class CPriorityWiz :
	public CMySnapInPropertyWizardImpl<CPriorityWiz>
{
public :
  CPriorityWiz(WIZ_POSITION pos, int nTitle, PCProcDetail *ProcDetail);
  CPriorityWiz(WIZ_POSITION pos, int nTitle, PCJobDetail   *JobDetail);

  ~CPriorityWiz();

	enum { IDD               = IDD_PRIORITY_WIZ         };
  enum { ID_HeaderTitle    = IDS_PRIORITY_HDRTITLE    };
  enum { ID_HeaderSubTitle = IDS_PRIORITY_HDRSUBTITLE };

	BEGIN_MSG_MAP(CPriorityWiz)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)    
		MESSAGE_HANDLER(WM_HELP,       OnWMHelp)    
    COMMAND_HANDLER(IDC_PRIORITY_CHK, BN_CLICKED, OnChk)
    CHAIN_MSG_MAP(CMySnapInPropertyWizardImpl<CPriorityWiz>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

  BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
  BOOL OnWizardNext();

  BOOL OnSetActive();

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  typedef enum _PageType
  {
    PROCESS_PAGE,
    JOB_PAGE,
  } PageType;
  PageType          m_PageType;
  PCProcDetail     *m_pProcDetail;
  PCJobDetail      *m_pJobDetail;

  BOOL              m_bReadOnly;

  void Initialize();
  void ApplyControlEnableRules(BOOL bForceDisable);
};


class CJobNameWiz :
	public CMySnapInPropertyWizardImpl<CJobNameWiz>
{
public :
  CJobNameWiz(WIZ_POSITION pos, int nTitle, PCJobDetail *JobDetail);
  ~CJobNameWiz();

	enum { IDD               = IDD_JOBNAME_WIZ         };
  enum { ID_HeaderTitle    = IDS_GRPNAME_HDRTITLE    };
  enum { ID_HeaderSubTitle = IDS_GRPNAME_HDRSUBTITLE };

	BEGIN_MSG_MAP(CJobNameWiz)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)    
		MESSAGE_HANDLER(WM_HELP,       OnWMHelp)    
  	CHAIN_MSG_MAP(CMySnapInPropertyWizardImpl<CJobNameWiz>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

  BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
  BOOL OnWizardNext();

  void SetReadOnly()          { m_bReadOnly     = TRUE;}
  void SetNoNameChange()      { m_bNoNameChange = TRUE;}

private:
  PCJobDetail *m_pJobDetail;
  BOOL         m_bReadOnly;
  BOOL         m_bNoNameChange;
};


class CSchedulingClassWiz :
	public CMySnapInPropertyWizardImpl<CSchedulingClassWiz>
{
public :
  CSchedulingClassWiz(WIZ_POSITION pos, int nTitle, SCHEDULING_CLASS *sclass, bool *sclasschk);

  ~CSchedulingClassWiz();

	enum { IDD               = IDD_SCHEDULING_CLASS_WIZ   };
  enum { ID_HeaderTitle    = IDS_SCHEDCLASS_HDRTITLE    };
  enum { ID_HeaderSubTitle = IDS_SCHEDCLASS_HDRSUBTITLE };

	BEGIN_MSG_MAP(CSchedulingClassWiz)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)    
		MESSAGE_HANDLER(WM_HELP,       OnWMHelp)    
    COMMAND_HANDLER(IDC_SCHEDULING_CHK, BN_CLICKED, OnChk)
  	CHAIN_MSG_MAP(CMySnapInPropertyWizardImpl<CSchedulingClassWiz>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

  BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
  BOOL OnWizardNext();

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  bool             &m_schedClasschk;
  SCHEDULING_CLASS &m_schedClass;

  BOOL m_bReadOnly;
};


class CWorkingSetWiz :
	public CMySnapInPropertyWizardImpl<CWorkingSetWiz>
{
public :
  CWorkingSetWiz(WIZ_POSITION pos, int nTitle, PCProcDetail *ProcDetail);
  CWorkingSetWiz(WIZ_POSITION pos, int nTitle, PCJobDetail   *JobDetail);

  ~CWorkingSetWiz();

	enum { IDD               = IDD_MEMORY_WS_WIZ    };
  enum { ID_HeaderTitle    = IDS_WSET_HDRTITLE    };
  enum { ID_HeaderSubTitle = IDS_WSET_HDRSUBTITLE };

	BEGIN_MSG_MAP(CWorkingSetWiz)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		MESSAGE_HANDLER(WM_HELP,       OnWMHelp)    
    NOTIFY_HANDLER (IDC_MINWS_SPIN,     UDN_DELTAPOS, OnSpin)
    NOTIFY_HANDLER (IDC_MAXWS_SPIN,     UDN_DELTAPOS, OnSpin)
    COMMAND_HANDLER(IDC_WORKINGSET_CHK, BN_CLICKED,   OnChk)
  	CHAIN_MSG_MAP(CMySnapInPropertyWizardImpl<CWorkingSetWiz>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnSpin(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
  LRESULT OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

  BOOL Validate(BOOL bSave = FALSE);
  BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
  BOOL OnWizardNext();

  BOOL OnSetActive();

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  PCProcDetail     *m_pProcDetail;
  PCJobDetail      *m_pJobDetail;

  BOOL m_bReadOnly;

  void Initialize();
  void ApplyControlEnableRules(BOOL bForceDisable);
};


class CCommittedMemoryWiz :
	public CMySnapInPropertyWizardImpl<CCommittedMemoryWiz>
{
public :
  CCommittedMemoryWiz(WIZ_POSITION pos, int nTitle, MEMORY_VALUE *procmemorylimit, bool *procmemorylimitchk, MEMORY_VALUE *jobmemorylimit, bool *jobmemorylimitchk);

  ~CCommittedMemoryWiz();

	enum { IDD               = IDD_MEMORY_COMMIT_WIZ };
  enum { ID_HeaderTitle    = IDS_CMEM_HDRTITLE     };
  enum { ID_HeaderSubTitle = IDS_CMEM_HDRSUBTITLE  };

	BEGIN_MSG_MAP(CCommittedMemoryWiz)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		MESSAGE_HANDLER(WM_HELP,       OnWMHelp)    
    NOTIFY_HANDLER (IDC_PROC_SPIN,      UDN_DELTAPOS, OnSpin)
    NOTIFY_HANDLER (IDC_JOB_SPIN,       UDN_DELTAPOS, OnSpin)
    COMMAND_HANDLER(IDC_PROCMEMORY_CHK, BN_CLICKED,   OnChk)
    COMMAND_HANDLER(IDC_JOBMEMORY_CHK,  BN_CLICKED,   OnChk)
  	CHAIN_MSG_MAP(CMySnapInPropertyWizardImpl<CCommittedMemoryWiz>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnSpin(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
  LRESULT OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

  BOOL Validate(BOOL bSave = FALSE);
  BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
  BOOL OnWizardNext();

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  bool             &m_procmemorylimitchk;
  MEMORY_VALUE     &m_procmemorylimit;

  bool             &m_jobmemorylimitchk;
  MEMORY_VALUE     &m_jobmemorylimit;

  BOOL m_bReadOnly;
};


class CProcCountWiz :
	public CMySnapInPropertyWizardImpl<CProcCountWiz>
{
public :
  CProcCountWiz(WIZ_POSITION pos, int nTitle, PROC_COUNT *processcount, bool *processcountchk);

  ~CProcCountWiz();

	enum { IDD               = IDD_PROC_COUNT_WIZ        };
  enum { ID_HeaderTitle    = IDS_PROCCOUNT_HDRTITLE    };
  enum { ID_HeaderSubTitle = IDS_PROCCOUNT_HDRSUBTITLE };

	BEGIN_MSG_MAP(CProcCountWiz)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		MESSAGE_HANDLER(WM_HELP,       OnWMHelp)    
    COMMAND_HANDLER(IDC_PROCESSCOUNT_CHK, BN_CLICKED, OnChk)
  	CHAIN_MSG_MAP(CMySnapInPropertyWizardImpl<CProcCountWiz>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

  BOOL Validate(BOOL bSave = FALSE);
  BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
  BOOL OnWizardNext();

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  bool             &m_processcountchk;
  PROC_COUNT       &m_processcount;


  BOOL m_bReadOnly;
};


class CTimeWiz :
	public CMySnapInPropertyWizardImpl<CTimeWiz>
{
public :
  CTimeWiz(WIZ_POSITION pos, int nTitle, TIME_VALUE *procusertime, bool *procusertimechk, TIME_VALUE *jobusertime, bool *jobusertimechk, bool *jobmsgontimelimit);

  ~CTimeWiz();

	enum { IDD               = IDD_TIME_WIZ            };
  enum { ID_HeaderTitle    = IDS_CPUTIME_HDRTITLE    };
  enum { ID_HeaderSubTitle = IDS_CPUTIME_HDRSUBTITLE };

	BEGIN_MSG_MAP(CTimeWiz)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)    
		MESSAGE_HANDLER(WM_HELP,       OnWMHelp)    
    COMMAND_HANDLER(IDC_PROCUSERTIME_CHK, BN_CLICKED, OnChk)
    COMMAND_HANDLER(IDC_JOBUSERTIME_CHK,  BN_CLICKED, OnChk)
  	CHAIN_MSG_MAP(CMySnapInPropertyWizardImpl<CTimeWiz>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

  BOOL Validate(BOOL bSave = FALSE);
  BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
  BOOL OnWizardNext();

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  bool             &m_procusertimechk;
  TIME_VALUE       &m_procusertime;

  bool             &m_jobusertimechk;
  TIME_VALUE       &m_jobusertime;
  bool             &m_jobmsgontimelimit;

  BOOL m_bReadOnly;
};


class CAdvancedWiz :
	public CMySnapInPropertyWizardImpl<CAdvancedWiz>
{
public :
  CAdvancedWiz(WIZ_POSITION pos, int nTitle, bool *endjob, bool *unhandledexcept);

  ~CAdvancedWiz();

	enum { IDD               = IDD_ADVANCED_WIZ         };
  enum { ID_HeaderTitle    = IDS_ADVANCED_HDRTITLE    };
  enum { ID_HeaderSubTitle = IDS_ADVANCED_HDRSUBTITLE };

	BEGIN_MSG_MAP(CAdvancedWiz)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)    
		MESSAGE_HANDLER(WM_HELP,       OnWMHelp)    
  	CHAIN_MSG_MAP(CMySnapInPropertyWizardImpl<CAdvancedWiz>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

  BOOL Validate(BOOL bSave = FALSE);
  BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
  BOOL OnWizardNext();

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  bool             &m_endjob;
  bool             &m_unhandledexcept;

  BOOL m_bReadOnly;
};

class CAdvBreakawayWiz :
	public CMySnapInPropertyWizardImpl<CAdvBreakawayWiz>
{
public :
  CAdvBreakawayWiz(WIZ_POSITION pos, int nTitle, bool *breakaway, bool *silentbreakaway);

  ~CAdvBreakawayWiz();

  enum { IDD               = IDD_ADV_BREAKAWAY_WIZ};
  enum { ID_HeaderTitle    = IDS_ADV_BREAKAWAY_HDRTITLE    };
  enum { ID_HeaderSubTitle = IDS_ADV_BREAKAWAY_HDRSUBTITLE };

	BEGIN_MSG_MAP(CAdvBreakawayWiz)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)    
		MESSAGE_HANDLER(WM_HELP,       OnWMHelp)    
  	CHAIN_MSG_MAP(CMySnapInPropertyWizardImpl<CAdvBreakawayWiz>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

  BOOL Validate(BOOL bSave = FALSE);
  BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
  BOOL OnWizardNext();

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  bool             &m_breakaway;
  bool             &m_silentbreakaway;

  BOOL m_bReadOnly;
};



#endif //ifdef __MANAGEMENTRULEWIZARDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\managementrulewizards.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    ManagementRuleWizards.cpp                                                //
|                                                                                       //
|Description:  Implementation of process management rule wizards                        //
|                                                                                       //
|Created:      Paul Skoglund 09-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#include "stdafx.h"

#include "ManagementRuleWizards.h"
#include "ManagementPages.h"


using std::list<tstring>;


bool GetGrpNameList(PCid id, list<tstring> &jobs)
{
  PCINT32 res  = 0;

  PCJobSummary jlist[min((COM_BUFFER_SIZE/sizeof(PCJobSummary)), 100)];

  memset(&jlist[0], 0, sizeof(PCJobSummary));

  do
  {
    res = PCGetJobSummary( id, jlist, ARRAY_SIZE(jlist) * sizeof(PCJobSummary));
    if (res < 0 )
    {
      PCULONG32 err = PCGetLastError(id);
      return false;
    }

    if (res > 0)
    {
      for (INT32 i = 0; i < res; i++)
      {
        jobs.push_back(jlist[i].jobName);
      }
      memcpy(&jlist[0], &jlist[res-1], sizeof(PCJobSummary));
    }
  } while (res > 0 && PCERROR_MORE_DATA == PCGetLastError(id) );

  return true;
}

list<tstring> *GetGrpNameList(PCid id)
{
  list<tstring> *jlist = new list<tstring>;

  if (jlist)
    GetGrpNameList(id, *jlist);

  return jlist;
}

BOOL IsValidName(const CComBSTR &bStr, const BOOL nullOK)
{
  ASSERT(PROC_NAME_LEN == JOB_NAME_LEN);

  const TCHAR BLANK = _T(' ');

  if ( !bStr.Length() )  // empty string
    return nullOK;

  unsigned int len = bStr.Length();
  if ( len > JOB_NAME_LEN )
    return FALSE;

  if ( bStr[0] == BLANK || bStr[len - 1] == BLANK )
     return FALSE;  // leading/trailing blank

  if ( len != _tcscspn( bStr, _T("\\,\"")) )
    return FALSE; // hit invalid character

  return TRUE;
}


BOOL ProcRuleWizard(int nTitle, const list<tstring> &jobsdefined, PCProcDetail &out, const PCSystemParms &SystemParms, PROC_NAME *procName /* = NULL */)
{
  PROPSHEETHEADER sheet;
  HPROPSHEETPAGE  hPages[5];

  memset(&sheet, 0, sizeof(PROPSHEETHEADER));
  sheet.dwSize = sizeof(PROPSHEETHEADER);
  sheet.dwFlags = PSH_WIZARD; // | PSH_USEICONID;
  sheet.hwndParent = ::GetActiveWindow();
  sheet.hInstance = _Module.GetResourceInstance();
  sheet.pszIcon = NULL;                               // MAKEINTRESOURCE(IDI_MANAGEMENT);
  sheet.pszCaption = MAKEINTRESOURCE(nTitle);
  sheet.nPages = ARRAY_SIZE(hPages);
  sheet.nStartPage = 0;
  sheet.phpage = &hPages[0];
  sheet.pfnCallback = NULL;

#if USE_WIZARD97_WATERMARKS
  sheet.dwFlags |= PSH_WIZARD97 | PSH_WATERMARK;
  sheet.pszbmWatermark = MAKEINTRESOURCE(IDB_WATERMARK1);  
#endif
#if USE_WIZARD97_HEADERS
  sheet.dwFlags |= PSH_WIZARD97 | PSH_HEADER;
  sheet.pszbmHeader    = MAKEINTRESOURCE(IDB_HEADER1);
#endif

  memset(&out, 0, sizeof(PCProcDetail));

  if (procName)
    _tcscpy(out.base.procName, *procName);

  // set any ProcDetail Defaults...

  //memset(out.base.memberOfJobName, 0, sizeof(JOB_NAME));
  //SetMGMTFlag(out.base.mgmtParms.mFlags, PCMFLAG_APPLY_JOB_MEMBERSHIP, FALSE);

  //out.base.mgmtParms.affinity = 0;
  //SetMGMTFlag(out.base.mgmtParms.mFlags, PCMFLAG_APPLY_AFFINITY, FALSE);

  out.base.mgmtParms.priority = PCPrioNormal;
  //SetMGMTFlag(out.base.mgmtParms.mFlags, PCMFLAG_APPLY_PRIORITY, FALSE);

  CProcNameWiz *pPage1 = new CProcNameWiz(CProcNameWiz::FIRST_PAGE, nTitle, &out);
  if (!pPage1)
    return -1;
  hPages[0] = pPage1->Create();

  if (procName)
    pPage1->SetNoNameChange();

  CProcGrpMemberWiz *pPage2 = new CProcGrpMemberWiz(CProcGrpMemberWiz::MIDDLE_PAGE, nTitle, &out, jobsdefined);
  if (!pPage2)
  {
    delete pPage1;
    return -1;
  }
  hPages[1] = pPage2->Create();

  CAffinityWiz *pPage3 = new CAffinityWiz(CAffinityWiz::MIDDLE_PAGE, nTitle, &out, SystemParms.processorMask);
  if (!pPage3)
  {
    delete pPage1;
    delete pPage2;
    return -1;
  }
  hPages[2] = pPage3->Create();

  CPriorityWiz *pPage4 = new CPriorityWiz(CPriorityWiz::MIDDLE_PAGE, nTitle, &out);
  if (!pPage4)
  {
    delete pPage1;
    delete pPage2;
    delete pPage3;
    return -1;
  }
  hPages[3] = pPage4->Create();

  CWorkingSetWiz *pPage5 = new CWorkingSetWiz(CWorkingSetWiz::LAST_PAGE, nTitle, &out);
  if (!pPage5)
  {
    delete pPage1;
    delete pPage2;
    delete pPage3;
    delete pPage4;
    return -1;
  }
  hPages[4] = pPage5->Create();

  INT_PTR id = PropertySheet(&sheet);
  if (id > 0)
    return TRUE;

  return FALSE;
}


BOOL GroupRuleWizard(int nTitle, PCJobDetail &out, const PCSystemParms &SystemParms, JOB_NAME *jobName /* = NULL */)
{
  PROPSHEETHEADER sheet;
  HPROPSHEETPAGE  hPages[10];

  memset(&sheet, 0, sizeof(PROPSHEETHEADER));
  sheet.dwSize = sizeof(PROPSHEETHEADER);
  sheet.dwFlags = PSH_WIZARD;
  sheet.hwndParent = ::GetActiveWindow();
  sheet.hInstance = _Module.GetResourceInstance();
  sheet.pszIcon = NULL;
  sheet.pszCaption = MAKEINTRESOURCE(nTitle);
  sheet.nPages = ARRAY_SIZE(hPages);
  sheet.nStartPage = 0;
  sheet.phpage = &hPages[0];
  sheet.pfnCallback = NULL;

#if USE_WIZARD97_WATERMARKS
  sheet.dwFlags        |= PSH_WIZARD97 | PSH_WATERMARK;
  sheet.pszbmWatermark  = MAKEINTRESOURCE(IDB_WATERMARK1);
#endif
#if USE_WIZARD97_HEADERS
  sheet.dwFlags        |= PSH_WIZARD97 | PSH_HEADER;
  sheet.pszbmHeader     = MAKEINTRESOURCE(IDB_HEADER1);
#endif

  bool              applyschedulingclass;
  SCHEDULING_CLASS  schedulingclass;

  bool              procmemorylimitchk;
  MEMORY_VALUE      procmemorylimit;
  bool              jobmemorylimitchk;
  MEMORY_VALUE      jobmemorylimit;

  bool              processcountchk;
  PROC_COUNT        processcount;

  bool              procusertimechk;
  TIME_VALUE        procusertime;

  bool              jobusertimechk;
  TIME_VALUE        jobusertime;
  bool              jobmsgontimelimit;

  bool              breakaway;
  bool              silentbreakaway;

  bool              endjob;
  bool              unhandledexcept;

  memset(&out, 0, sizeof(PCJobDetail));

  // set any JobDetail Defaults...
  if (jobName)
    _tcscpy(out.base.jobName, *jobName);

  //out.base.mgmtParms.affinity = 0;
  //SetMGMTFlag(out.base.mgmtParms.mFlags, PCMFLAG_APPLY_AFFINITY, FALSE);

  out.base.mgmtParms.priority = PCPrioNormal;
  //SetMGMTFlag(out.base.mgmtParms.mFlags, PCMFLAG_APPLY_PRIORITY, FALSE);

  CJobNameWiz *pPage1 = new CJobNameWiz(CJobNameWiz::FIRST_PAGE, nTitle, &out);
  if (!pPage1)
    return -1;
  hPages[0] = pPage1->Create();

  if (jobName)
    pPage1->SetNoNameChange();

  CAffinityWiz *pPage2 = new CAffinityWiz(CAffinityWiz::MIDDLE_PAGE, nTitle, &out, SystemParms.processorMask);
  if (!pPage2)
  {
    delete pPage1;
    return -1;
  }
  hPages[1] = pPage2->Create();


  CPriorityWiz *pPage3 = new CPriorityWiz(CPriorityWiz::MIDDLE_PAGE, nTitle, &out);
  if (!pPage3)
  {
    delete pPage1;
    delete pPage2;
    return -1;
  }
  hPages[2] = pPage3->Create();

  CSchedulingClassWiz *pPage4 = new CSchedulingClassWiz(CSchedulingClassWiz::MIDDLE_PAGE, nTitle, &schedulingclass, &applyschedulingclass);
  if (!pPage4)
  {
    delete pPage1;
    delete pPage2;
    delete pPage3;
    return -1;
  }
  hPages[3] = pPage4->Create();

  CWorkingSetWiz *pPage5 = new CWorkingSetWiz(CWorkingSetWiz::MIDDLE_PAGE, nTitle, &out);
  if (!pPage5)
  {
    delete pPage1;
    delete pPage2;
    delete pPage3;
    delete pPage4;
    return -1;
  }
  hPages[4] = pPage5->Create();

  CCommittedMemoryWiz *pPage6 = new CCommittedMemoryWiz(CCommittedMemoryWiz::MIDDLE_PAGE, nTitle, &procmemorylimit, &procmemorylimitchk, &jobmemorylimit, &jobmemorylimitchk);
  if (!pPage6)
  {
    delete pPage1;
    delete pPage2;
    delete pPage3;
    delete pPage4;
    delete pPage5;
    return -1;
  }
  hPages[5] = pPage6->Create();

  CProcCountWiz *pPage7 = new CProcCountWiz(CProcCountWiz::MIDDLE_PAGE, nTitle, &processcount, &processcountchk);
  if (!pPage7)
  {
    delete pPage1;
    delete pPage2;
    delete pPage3;
    delete pPage4;
    delete pPage5;
    delete pPage6;
    return -1;
  }
  hPages[6] = pPage7->Create();

  CTimeWiz *pPage8 = new CTimeWiz(CTimeWiz::MIDDLE_PAGE, nTitle, &procusertime, &procusertimechk, &jobusertime, &jobusertimechk, &jobmsgontimelimit);
  if (!pPage8)
  {
    delete pPage1;
    delete pPage2;
    delete pPage3;
    delete pPage4;
    delete pPage5;
    delete pPage6;
    delete pPage7;
    return -1;
  }
  hPages[7] = pPage8->Create();

  CAdvancedWiz *pPage9 = new CAdvancedWiz(CAdvancedWiz::MIDDLE_PAGE, nTitle, &endjob, &unhandledexcept);
  if (!pPage9)
  {
    delete pPage1;
    delete pPage2;
    delete pPage3;
    delete pPage4;
    delete pPage5;
    delete pPage6;
    delete pPage7;
    delete pPage8;
    return -1;
  }
  hPages[8] = pPage9->Create();


  CAdvBreakawayWiz *pPage10 = new CAdvBreakawayWiz(CAdvBreakawayWiz::LAST_PAGE, nTitle, &breakaway, &silentbreakaway);
  if (!pPage10)
  {
    delete pPage1;
    delete pPage2;
    delete pPage3;
    delete pPage4;
    delete pPage5;
    delete pPage6;
    delete pPage7;
    delete pPage8;
    delete pPage9;
    return -1;
  }
  hPages[9] = pPage10->Create();

  INT_PTR id = PropertySheet(&sheet);
  if (id > 0)
  {
    out.base.mgmtParms.schedClass = schedulingclass;
    if (applyschedulingclass)
      out.base.mgmtParms.mFlags |= PCMFLAG_APPLY_SCHEDULING_CLASS;

    out.base.mgmtParms.procMemoryLimit = procmemorylimit;
    if (procmemorylimitchk)
      out.base.mgmtParms.mFlags |= PCMFLAG_APPLY_PROC_MEMORY_LIMIT;

    out.base.mgmtParms.jobMemoryLimit = jobmemorylimit;
    if (jobmemorylimitchk)
      out.base.mgmtParms.mFlags |= PCMFLAG_APPLY_JOB_MEMORY_LIMIT;

    out.base.mgmtParms.procCountLimit = processcount;
    if (processcountchk)
      out.base.mgmtParms.mFlags |= PCMFLAG_APPLY_PROC_COUNT_LIMIT;

    out.base.mgmtParms.procTimeLimitCNS = procusertime;
    if (procusertimechk)
      out.base.mgmtParms.mFlags |= PCMFLAG_APPLY_PROC_TIME_LIMIT;

    out.base.mgmtParms.jobTimeLimitCNS = jobusertime;
    if (jobusertimechk)
      out.base.mgmtParms.mFlags |= PCMFLAG_APPLY_JOB_TIME_LIMIT;

    if (jobmsgontimelimit)
      out.base.mgmtParms.mFlags |= PCMFLAG_MSG_ON_JOB_TIME_LIMIT_HIT;

    if (endjob)
      out.base.mgmtParms.mFlags |= PCMFLAG_END_JOB_WHEN_EMPTY;
    if (unhandledexcept)
      out.base.mgmtParms.mFlags |= PCMFLAG_SET_DIE_ON_UH_EXCEPTION;

    if (breakaway)
      out.base.mgmtParms.mFlags |= PCMFLAG_SET_PROC_BREAKAWAY_OK;
    if (silentbreakaway)
      out.base.mgmtParms.mFlags |= PCMFLAG_SET_SILENT_BREAKAWAY;

    return TRUE;
  }
  return FALSE;
}

///////////////////////////////////////////////////////////////////////////
//  ProcName

CProcNameWiz::CProcNameWiz(WIZ_POSITION pos, int nTitle, PCProcDetail *ProcDetail) :
   CMySnapInPropertyWizardImpl<CProcNameWiz>(pos, nTitle), m_pProcDetail(ProcDetail)
{
  ASSERT(m_pProcDetail);

  m_bReadOnly     = FALSE;
  m_bNoNameChange = FALSE;
}

CProcNameWiz::~CProcNameWiz()
{
}


LRESULT CProcNameWiz::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UpdateData(FALSE);

  bHandled = FALSE;

  return TRUE;  // Let the system set the focus
}

LRESULT CProcNameWiz::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  HELPINFO *phi = (HELPINFO*) lParam;
  if (phi && phi->iContextType == HELPINFO_WINDOW)
  {
    TCHAR *pTopic = const_cast<TCHAR*>(HELP_ru_proc_name);

    MMCPropertyHelp(pTopic);

    return TRUE;
  }
  bHandled = FALSE;
  return FALSE;
}

BOOL CProcNameWiz::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
    CComBSTR bName;
    if (!GetDlgItemText( IDC_NAME, bName.m_str ) ||
      !IsValidName(bName, FALSE) )
    {
      HWND hWndCtl = GetDlgItem(IDC_NAME);
      if(hWndCtl)
        ::SetFocus(hWndCtl);
      ITEM_STR strOut;
      LoadStringHelper(strOut, IDS_JOBNAME_WARNING);
      MessageBox(strOut, NULL, MB_OK | MB_ICONWARNING);
      return FALSE;
    }

    CComBSTR bComment;
    if ( !GetDlgItemText(IDC_COMMENT, bComment.m_str) )
      bComment = _T("");
    if (bComment.Length() > RULE_DESCRIPTION_LEN)
    {
      HWND hWndCtl = GetDlgItem(IDC_COMMENT);
      if(hWndCtl)
        ::SetFocus(hWndCtl);
      MessageBeep(MB_ICONASTERISK);
      return FALSE;
    }

    // everything validated so save 
    _tcscpy(m_pProcDetail->base.procName, bName);
    _tcscpy(m_pProcDetail->base.mgmtParms.description, bComment);

    return TRUE;
  }
  else
  {
    VERIFY(SetDlgItemText( IDC_NAME, m_pProcDetail->base.procName ));
    SendDlgItemMessage( IDC_NAME, EM_SETLIMITTEXT, PROC_NAME_LEN, 0);

    VERIFY(SetDlgItemText( IDC_COMMENT, m_pProcDetail->base.mgmtParms.description ));
    SendDlgItemMessage( IDC_COMMENT, EM_SETLIMITTEXT, RULE_DESCRIPTION_LEN, 0);

    if (m_bReadOnly)
    {
      DisableControl(IDC_NAME);
      DisableControl(IDC_COMMENT);
    }

    if (m_bNoNameChange)
      DisableControl(IDC_NAME);

    return TRUE;
  }
}


BOOL CProcNameWiz::OnWizardNext()
{
  if (!UpdateData(TRUE) )
    return FALSE;

  return TRUE;
}

///////////////////////////////////////////////////////////////////////////
//  JobMember

CProcGrpMemberWiz::CProcGrpMemberWiz(WIZ_POSITION pos, int nTitle, PCProcDetail *ProcDetail, const list<tstring> &jobsdefined) 
    : CMySnapInPropertyWizardImpl<CProcGrpMemberWiz>(pos, nTitle), 
      m_pProcDetail(ProcDetail), m_JobsExisting(jobsdefined)
{
  ASSERT(ProcDetail);

  m_bReadOnly = FALSE;
}

CProcGrpMemberWiz::~CProcGrpMemberWiz()
{
}


LRESULT CProcGrpMemberWiz::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UpdateData(FALSE);

  bHandled = FALSE;

  return TRUE;  // Let the system set the focus
}

LRESULT CProcGrpMemberWiz::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  HELPINFO *phi = (HELPINFO*) lParam;
  if (phi && phi->iContextType == HELPINFO_WINDOW)
  {
    TCHAR *pTopic = const_cast<TCHAR*>(HELP_pr_job_name);

    MMCPropertyHelp(pTopic);

    return TRUE;
  }
  bHandled = FALSE;
  return FALSE;
}

BOOL CProcGrpMemberWiz::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
    CComBSTR bStr;
    bool bChecked = (BST_CHECKED == IsDlgButtonChecked(IDC_JOBMEMBER_CHK));

    if (!GetDlgItemText( IDC_JOB_LIST, bStr.m_str ) )
      bStr = _T("");

    if ( !IsValidName(bStr, !bChecked) )
    {
      HWND hWndCtl = NULL;
      if (bChecked)
        hWndCtl = GetDlgItem(IDC_JOB_LIST);
      else
        hWndCtl = GetDlgItem(IDC_JOBMEMBER_CHK);
      if(hWndCtl)
        ::SetFocus(hWndCtl);

      ITEM_STR strOut;
      LoadStringHelper(strOut, IDS_JOBNAME_WARNING);
      MessageBox(strOut, NULL, MB_OK | MB_ICONWARNING);

      return FALSE;
    }

    SetMGMTFlag(m_pProcDetail->base.mgmtParms.mFlags, PCMFLAG_APPLY_JOB_MEMBERSHIP, bChecked);
    _tcscpy(m_pProcDetail->base.memberOfJobName, bStr);

    return TRUE;
  }
  else
  {
  list<tstring>::const_iterator i;
  for (i = m_JobsExisting.begin(); i != m_JobsExisting.end(); i++)
    SendDlgItemMessage(IDC_JOB_LIST, CB_ADDSTRING, 0, (LPARAM) (*i).c_str() );

  SendDlgItemMessage( IDC_JOB_LIST, CB_LIMITTEXT, JOB_NAME_LEN,  0);

    VERIFY(SetDlgItemText( IDC_JOB_LIST,  m_pProcDetail->base.memberOfJobName ));

    CheckDlgButton(IDC_JOBMEMBER_CHK, (m_pProcDetail->base.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP) ? BST_CHECKED : BST_UNCHECKED);

    if (m_bReadOnly || !(m_pProcDetail->base.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP) )
      DisableControl(IDC_JOB_LIST);

    if (m_bReadOnly)
      DisableControl(IDC_JOBMEMBER_CHK);

    return TRUE;
  }
}

LRESULT CProcGrpMemberWiz::OnJobChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_JOBMEMBER_CHK )
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_JOBMEMBER_CHK));
    ::EnableWindow(GetDlgItem(IDC_JOB_LIST), checked);
  }

  bHandled = FALSE;
  return 0;
}

BOOL CProcGrpMemberWiz::OnWizardNext()
{
  if (!UpdateData(TRUE) )
    return FALSE;

  return TRUE;
}

///////////////////////////////////////////////////////////////////////////
//  Affinity
CAffinityWiz::CAffinityWiz(WIZ_POSITION pos, int nTitle, PCProcDetail *ProcDetail, AFFINITY ProcessorMask) : 
              CMySnapInPropertyWizardImpl<CAffinityWiz>(pos, nTitle),
              m_PageType(PROCESS_PAGE), m_pProcDetail(ProcDetail), m_pJobDetail(NULL),
              m_ProcessorMask(ProcessorMask)
{
  Initialize();
}

CAffinityWiz::CAffinityWiz(WIZ_POSITION pos, int nTitle, PCJobDetail *JobDetail, AFFINITY ProcessorMask) :
              CMySnapInPropertyWizardImpl<CAffinityWiz>(pos, nTitle),
              m_PageType(JOB_PAGE), m_pProcDetail(NULL), m_pJobDetail(JobDetail),
              m_ProcessorMask(ProcessorMask)
{
  Initialize();
}

CAffinityWiz::~CAffinityWiz()
{
}

void CAffinityWiz::Initialize()
{
  ASSERT(m_PageType == PROCESS_PAGE && m_pProcDetail || m_PageType == JOB_PAGE && m_pJobDetail);

  m_bReadOnly = FALSE;
}

LRESULT CAffinityWiz::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UINT nPromptID;
  if (m_PageType == PROCESS_PAGE)
    nPromptID = IDS_AFFINITY_JOBWARNING;
  else
    nPromptID = IDS_AFFINITY_NOJOBWARNING;

  CComBSTR bStr;
  if (bStr.LoadString(nPromptID))
    VERIFY(SetDlgItemText(IDC_AFFINITY_PROMPT, bStr.m_str));

  UpdateData(FALSE);
  bHandled = FALSE;
  return TRUE;  // Let the system set the focus
}

LRESULT CAffinityWiz::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  HELPINFO *phi = (HELPINFO*) lParam;
  if (phi && phi->iContextType == HELPINFO_WINDOW)
  {
    TCHAR *pTopic = const_cast<TCHAR*>(HELP_ru_affinity);

    MMCPropertyHelp(pTopic);

    return TRUE;
  }
  bHandled = FALSE;
  return FALSE;
}

BOOL CAffinityWiz::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
    AFFINITY affinity = 0;
    bool     affinitychk = (BST_CHECKED == IsDlgButtonChecked(IDC_AFFINITY_CHK));

    int i;
    for ( i = IDC_AFFINITY1; i <= IDC_AFFINITY64; i++)
    {
      if ( BST_UNCHECKED != IsDlgButtonChecked(i) )
        affinity |= (ProcessorBit << (i - IDC_AFFINITY1));
    }

    // Warn the user if the affinity and processor mask don't
    // reference at least one processor
    if (affinitychk && !(affinity & m_ProcessorMask) )
    {
      ITEM_STR strOut;
      LoadStringHelper(strOut, IDS_AFFINITY_WARNING);
      if (IDYES != MessageBox(strOut, NULL, MB_YESNO | MB_ICONQUESTION))
        return FALSE;
    }

    if (m_PageType == PROCESS_PAGE)
    {
      m_pProcDetail->base.mgmtParms.affinity = affinity;
      SetMGMTFlag(m_pProcDetail->base.mgmtParms.mFlags, PCMFLAG_APPLY_AFFINITY, affinitychk);
    }
    else if (m_PageType == JOB_PAGE)
    {
      m_pJobDetail->base.mgmtParms.affinity  = affinity;
      SetMGMTFlag(m_pJobDetail->base.mgmtParms.mFlags, PCMFLAG_APPLY_AFFINITY, affinitychk);
    }

    return TRUE;
  }
  else
  {
    ASSERT(IDC_AFFINITY1 + 63 == IDC_AFFINITY64);

    AFFINITY affinity    = 0;
    bool     affinitychk = FALSE;

    if ( m_PageType == PROCESS_PAGE )
    {
      affinity = m_pProcDetail->base.mgmtParms.affinity;
      if (m_pProcDetail->base.mgmtParms.mFlags & PCMFLAG_APPLY_AFFINITY)
        affinitychk = TRUE;
    }
    else if ( m_PageType == JOB_PAGE )
    {
      affinity = m_pJobDetail->base.mgmtParms.affinity;
      if (m_pJobDetail->base.mgmtParms.mFlags & PCMFLAG_APPLY_AFFINITY)
        affinitychk = TRUE;
    }

    for(int i = IDC_AFFINITY1; i <= IDC_AFFINITY64; i++)
    {
      if (affinity & (ProcessorBit << (i - IDC_AFFINITY1) ) )
      {
        if (m_ProcessorMask & (ProcessorBit << (i - IDC_AFFINITY1)))
          CheckDlgButton(i, BST_CHECKED);
        else
          CheckDlgButton(i, BST_INDETERMINATE);
      }
      else
        CheckDlgButton(i, BST_UNCHECKED);
    }

    CheckDlgButton(IDC_AFFINITY_CHK, affinitychk ? BST_CHECKED : BST_UNCHECKED);

    ApplyControlEnableRules(FALSE);

    return TRUE;
  }
}

void CAffinityWiz::ApplyControlEnableRules(BOOL bForceDisable)
{
  BOOL bEnable;
  if (m_bReadOnly || !(BST_CHECKED == IsDlgButtonChecked(IDC_AFFINITY_CHK)) || bForceDisable)
    bEnable = FALSE;
  else
    bEnable = TRUE;

  for (int i = IDC_AFFINITY1; i <= IDC_AFFINITY64; i++)
    ::EnableWindow(GetDlgItem(i), bEnable);

  ::EnableWindow(GetDlgItem(IDC_AFFINITY_CHK), !(m_bReadOnly || bForceDisable));
}

BOOL CAffinityWiz::OnSetActive()
{
  if ( m_PageType == PROCESS_PAGE )
  {
    if (m_pProcDetail->base.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP)
      ApplyControlEnableRules(TRUE);
    else
      ApplyControlEnableRules(FALSE);
  }
  return TRUE;
}

LRESULT CAffinityWiz::OnAffinityEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wNotifyCode == BN_CLICKED)
  {
    ASSERT(wID >= IDC_AFFINITY1 && wID <= IDC_AFFINITY64);

    int bit = wID - IDC_AFFINITY1;
    UINT btnState = IsDlgButtonChecked(wID);
    if (btnState == BST_UNCHECKED)
    {
      if ( m_ProcessorMask & (ProcessorBit << bit))
        CheckDlgButton(wID, BST_CHECKED);
      else
        CheckDlgButton(wID, BST_INDETERMINATE);
    }
    else
    {
      CheckDlgButton(wID, BST_UNCHECKED);
    }
  }

  bHandled = FALSE;
  return 0;
}

LRESULT CAffinityWiz::OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_AFFINITY_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_AFFINITY_CHK));
    for (int i = IDC_AFFINITY1; i <= IDC_AFFINITY64; i++)
      ::EnableWindow(GetDlgItem(i), checked);
  }

  bHandled = FALSE;
  return 0;
}

BOOL CAffinityWiz::OnWizardNext()
{
  if (!UpdateData(TRUE) )
    return FALSE;

  return TRUE;
}

///////////////////////////////////////////////////////////////////////////
//  Priority

CPriorityWiz::CPriorityWiz(WIZ_POSITION pos, int nTitle, PCProcDetail *ProcDetail) :
               CMySnapInPropertyWizardImpl<CPriorityWiz>(pos, nTitle),
               m_PageType(PROCESS_PAGE), m_pProcDetail(ProcDetail), m_pJobDetail(NULL)
{
  Initialize();
}

CPriorityWiz::CPriorityWiz(WIZ_POSITION pos, int nTitle, PCJobDetail *JobDetail) :
               CMySnapInPropertyWizardImpl<CPriorityWiz>(pos, nTitle),
               m_PageType(JOB_PAGE), m_pProcDetail(NULL), m_pJobDetail(JobDetail)
{
  Initialize();
}

CPriorityWiz::~CPriorityWiz()
{
}

void CPriorityWiz::Initialize()
{
  ASSERT(m_PageType == PROCESS_PAGE && m_pProcDetail || m_PageType == JOB_PAGE && m_pJobDetail);

  m_bReadOnly = FALSE;
}


LRESULT CPriorityWiz::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UINT nPromptID;
  if (m_PageType == PROCESS_PAGE)
    nPromptID = IDS_PRIORITY_JOBWARNING;
  else
    nPromptID = IDS_PRIORITY_NOJOBWARNING;

  CComBSTR bStr;
  if (bStr.LoadString(nPromptID))
    VERIFY(SetDlgItemText(IDC_PRIORITY_PROMPT, bStr.m_str));

  UpdateData(FALSE);
  bHandled = FALSE;
  return TRUE;  // Let the system set the focus
}

LRESULT CPriorityWiz::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  HELPINFO *phi = (HELPINFO*) lParam;
  if (phi && phi->iContextType == HELPINFO_WINDOW)
  {
    TCHAR *pTopic = const_cast<TCHAR*>(HELP_ru_priority);

    MMCPropertyHelp(pTopic);

    return TRUE;
  }
  bHandled = FALSE;
  return FALSE;
}

BOOL CPriorityWiz::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
    BOOL prioritychk = (BST_CHECKED == IsDlgButtonChecked(IDC_PRIORITY_CHK));
    PRIORITY p = 0;
    for ( int i = IDC_LOW; i<= IDC_REALTIME; i++)
    {
      if ( BST_CHECKED == IsDlgButtonChecked(i) )
        p += IDToPriority(i);
    }

    if (IDToPriority(PriorityToID(p)) != p) //not fool proof, but do we really need to check this? no
    {
      MessageBeep(MB_ICONASTERISK);
      return FALSE;
    }

    if (m_PageType == PROCESS_PAGE)
    {
      m_pProcDetail->base.mgmtParms.priority = p;
      SetMGMTFlag(m_pProcDetail->base.mgmtParms.mFlags, PCMFLAG_APPLY_PRIORITY, prioritychk);
    }
    else if (m_PageType == JOB_PAGE)
    {
      m_pJobDetail->base.mgmtParms.priority  = p;
      SetMGMTFlag(m_pJobDetail->base.mgmtParms.mFlags, PCMFLAG_APPLY_PRIORITY, prioritychk);
    }
    return TRUE;
  }
  else
  {
    BOOL     prioritychk = FALSE;
    PRIORITY p           = PCPrioNormal;
    if (m_PageType == PROCESS_PAGE)
    {
      if (m_pProcDetail->base.mgmtParms.mFlags & PCMFLAG_APPLY_PRIORITY)
        prioritychk = TRUE;
      m_pProcDetail->base.mgmtParms.priority = p;
    }
    else if (m_PageType == JOB_PAGE)
    {
      if (m_pJobDetail->base.mgmtParms.mFlags & PCMFLAG_APPLY_PRIORITY)
        prioritychk = TRUE;
      m_pJobDetail->base.mgmtParms.priority  = p;
    }

    CheckDlgButton(IDC_PRIORITY_CHK, prioritychk ? BST_CHECKED : BST_UNCHECKED);

    CheckRadioButton(IDC_LOW, IDC_REALTIME, PriorityToID(p));

    ApplyControlEnableRules(FALSE);

    return TRUE;
  }
}

void CPriorityWiz::ApplyControlEnableRules(BOOL bForceDisable)
{
  BOOL bEnable;
  if (m_bReadOnly || !(BST_CHECKED == IsDlgButtonChecked(IDC_PRIORITY_CHK)) || bForceDisable)
    bEnable = FALSE;
  else 
    bEnable = TRUE;

  UINT ids[] = { IDC_REALTIME, IDC_HIGH, IDC_ABOVE_NORMAL, IDC_NORMAL, IDC_BELOW_NORMAL, IDC_LOW, 0 };
  for (int i = 0; ids[i]; i++)
    ::EnableWindow(GetDlgItem(ids[i]), bEnable);

  ::EnableWindow(GetDlgItem(IDC_PRIORITY_CHK), !(m_bReadOnly || bForceDisable));
}

BOOL CPriorityWiz::OnSetActive()
{
  if ( m_PageType == PROCESS_PAGE )
  {
    if (m_pProcDetail->base.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP)
      ApplyControlEnableRules(TRUE);
    else
      ApplyControlEnableRules(FALSE);
  }
  return TRUE;
}

LRESULT CPriorityWiz::OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_PRIORITY_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_PRIORITY_CHK));

    UINT ids[] = { IDC_REALTIME, IDC_HIGH, IDC_ABOVE_NORMAL, IDC_NORMAL, IDC_BELOW_NORMAL, IDC_LOW,0 };
    for (int i = 0; ids[i]; i++)
      ::EnableWindow(GetDlgItem(ids[i]), checked);
  }

  bHandled = FALSE;
  return 0;
}

BOOL CPriorityWiz::OnWizardNext()
{
  if (!UpdateData(TRUE) )
    return FALSE;

  return TRUE;
}


///////////////////////////////////////////////////////////////////////////
//  JobName

CJobNameWiz::CJobNameWiz(WIZ_POSITION pos, int nTitle, PCJobDetail *JobDetail) 
    : CMySnapInPropertyWizardImpl<CJobNameWiz>(pos, nTitle), 
    m_pJobDetail(JobDetail)
{
  ASSERT(m_pJobDetail);

  m_bReadOnly     = FALSE;
  m_bNoNameChange = FALSE;
}

CJobNameWiz::~CJobNameWiz()
{
}

LRESULT CJobNameWiz::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UpdateData(FALSE);

  bHandled = FALSE;

  return TRUE;  // Let the system set the focus
}

LRESULT CJobNameWiz::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  HELPINFO *phi = (HELPINFO*) lParam;
  if (phi && phi->iContextType == HELPINFO_WINDOW)
  {
    TCHAR *pTopic = const_cast<TCHAR*>(HELP_ru_job_name);

    MMCPropertyHelp(pTopic);

    return TRUE;
  }
  bHandled = FALSE;
  return FALSE;
}

BOOL CJobNameWiz::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
    CComBSTR bName;
    if (!GetDlgItemText( IDC_NAME, bName.m_str ) || 
        !IsValidName(bName, FALSE) )
    {
      HWND hWndCtl = GetDlgItem(IDC_NAME);
      if(hWndCtl)
        ::SetFocus(hWndCtl);

      ITEM_STR strOut;
      LoadStringHelper(strOut, IDS_JOBNAME_WARNING);
      MessageBox(strOut, NULL, MB_OK | MB_ICONWARNING);

      return FALSE;
    }
    CComBSTR bComment;
    if ( !GetDlgItemText(IDC_COMMENT, bComment.m_str) )
      bComment = _T("");
    if (bComment.Length() > RULE_DESCRIPTION_LEN)
    {
      HWND hWndCtl = GetDlgItem(IDC_COMMENT);
      if(hWndCtl)
        ::SetFocus(hWndCtl);
      MessageBeep(MB_ICONASTERISK);
      return FALSE;
    }

    // everything validated so save 
    _tcscpy(m_pJobDetail->base.jobName, bName);
    _tcscpy(m_pJobDetail->base.mgmtParms.description, bComment);

    return TRUE;
  }
  else
  {
    VERIFY(SetDlgItemText( IDC_NAME, m_pJobDetail->base.jobName ));
    SendDlgItemMessage( IDC_NAME, EM_SETLIMITTEXT, JOB_NAME_LEN, 0);

    VERIFY(SetDlgItemText( IDC_COMMENT, m_pJobDetail->base.mgmtParms.description ));
    SendDlgItemMessage( IDC_COMMENT, EM_SETLIMITTEXT, RULE_DESCRIPTION_LEN, 0);

    if (m_bReadOnly)
    {
      DisableControl(IDC_NAME);
      DisableControl(IDC_COMMENT);
    }

    if (m_bNoNameChange)
      DisableControl(IDC_NAME);

    return TRUE;
  }
}

BOOL CJobNameWiz::OnWizardNext()
{
  if (!UpdateData(TRUE) )
    return FALSE;

  return TRUE;
}

///////////////////////////////////////////////////////////////////////////
//  CSchedulingClassWiz

CSchedulingClassWiz::CSchedulingClassWiz(WIZ_POSITION pos, int nTitle, SCHEDULING_CLASS *sclass, bool *chk)
    : CMySnapInPropertyWizardImpl<CSchedulingClassWiz>(pos, nTitle), m_schedClass(*sclass), m_schedClasschk(*chk)
{
  m_bReadOnly = FALSE;

  m_schedClass    = 5;
  m_schedClasschk = FALSE;
}

CSchedulingClassWiz::~CSchedulingClassWiz()
{
}

LRESULT CSchedulingClassWiz::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UpdateData(FALSE);

  bHandled = FALSE;

  return TRUE;  // Let the system set the focus
}

LRESULT CSchedulingClassWiz::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  HELPINFO *phi = (HELPINFO*) lParam;
  if (phi && phi->iContextType == HELPINFO_WINDOW)
  {
    TCHAR *pTopic = const_cast<TCHAR*>(HELP_ru_job_sch);

    MMCPropertyHelp(pTopic);

    return TRUE;
  }
  bHandled = FALSE;
  return FALSE;
}

BOOL CSchedulingClassWiz::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
    LRESULT pos = SendDlgItemMessage(IDC_SPIN, UDM_GETPOS, 0, 0);
    if (0 == HIWORD(pos) && LOWORD(pos) >= 0 && LOWORD(pos) <= 9 )
    {
      m_schedClass    = (SCHEDULING_CLASS) LOWORD(pos);
      m_schedClasschk = (BST_CHECKED == IsDlgButtonChecked(IDC_SCHEDULING_CHK));
      return TRUE;
    }

    HWND hWndCtl = GetDlgItem(IDC_SCLASS);
    if(hWndCtl)
      ::SetFocus(hWndCtl);
    MessageBeep(MB_ICONASTERISK);
    return FALSE;
  }
  else
  {
    CheckDlgButton(IDC_SCHEDULING_CHK, m_schedClasschk ? BST_CHECKED : BST_UNCHECKED);

    SendDlgItemMessage(IDC_SPIN, UDM_SETPOS, 0, MAKELONG(m_schedClass, 0) );
    SendDlgItemMessage(IDC_SPIN, UDM_SETRANGE32, 0, 9);

    if (m_bReadOnly || !m_schedClasschk)
    {
      DisableControl(IDC_SCLASS);
      DisableControl(IDC_SPIN);
    }
    if (m_bReadOnly)
      DisableControl(IDC_SCHEDULING_CHK);

    return TRUE;
  }
}

LRESULT CSchedulingClassWiz::OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_SCHEDULING_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_SCHEDULING_CHK));

    ::EnableWindow(GetDlgItem(IDC_SCLASS), checked);
    ::EnableWindow(GetDlgItem(IDC_SPIN),   checked);
  }

  bHandled = FALSE;
  return 0;
}

BOOL CSchedulingClassWiz::OnWizardNext()
{
  if (!UpdateData(TRUE) )
    return FALSE;

  return TRUE;
}

///////////////////////////////////////////////////////////////////////////
//  CWorkingSetWiz
CWorkingSetWiz::CWorkingSetWiz(WIZ_POSITION pos, int nTitle, PCProcDetail *ProcDetail) 
    : CMySnapInPropertyWizardImpl<CWorkingSetWiz>(pos, nTitle), m_pProcDetail(ProcDetail), m_pJobDetail(NULL)
{
  Initialize();
}

CWorkingSetWiz::CWorkingSetWiz(WIZ_POSITION pos, int nTitle, PCJobDetail *JobDetail)  
    : CMySnapInPropertyWizardImpl<CWorkingSetWiz>(pos, nTitle), m_pProcDetail(NULL), m_pJobDetail(JobDetail)
{
  Initialize();
}

void CWorkingSetWiz::Initialize()
{
  m_bReadOnly = FALSE;
}

CWorkingSetWiz::~CWorkingSetWiz()
{
}

LRESULT CWorkingSetWiz::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UpdateData(FALSE);

  bHandled = FALSE;

  return TRUE;  // Let the system set the focus
}

LRESULT CWorkingSetWiz::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  HELPINFO *phi = (HELPINFO*) lParam;
  if (phi && phi->iContextType == HELPINFO_WINDOW)
  {
    TCHAR *pTopic = const_cast<TCHAR*>(HELP_ru_job_mem);
    if (m_pProcDetail)
      pTopic = const_cast<TCHAR*>(HELP_ru_workset);

    MMCPropertyHelp(pTopic);

    return TRUE;
  }
  bHandled = FALSE;
  return FALSE;
}

BOOL CWorkingSetWiz::Validate(BOOL bSave)
{
  LONG_PTR         PosErr = 0;
  MEMORY_VALUE     minWS;
  MEMORY_VALUE     maxWS;

  BOOL WSchk = (BST_CHECKED == IsDlgButtonChecked(IDC_WORKINGSET_CHK));

  minWS = SendDlgItemMessage(IDC_MINWS_SPIN, UDM_GETPOS32, 0, (LPARAM) &PosErr);
  if (PosErr || minWS > MAXLONG - 1 || (WSchk && minWS <= 0) )
  {
    HWND hWndCtl = GetDlgItem(IDC_MINWS);
    if(hWndCtl)
      ::SetFocus(hWndCtl);
    ITEM_STR strOut;
    LoadStringHelper(strOut, IDS_WSMINMAX_WARNING);
    MessageBox(strOut, NULL, MB_OK | MB_ICONWARNING);
    return FALSE;
  }
  maxWS = SendDlgItemMessage(IDC_MAXWS_SPIN, UDM_GETPOS32, 0, (LPARAM) &PosErr);
  if (PosErr || maxWS > MAXLONG - 1 || (WSchk && minWS >= maxWS) )
  {
      HWND hWndCtl = GetDlgItem(IDC_MAXWS);
      if(hWndCtl)
      ::SetFocus(hWndCtl);
    ITEM_STR strOut;
    LoadStringHelper(strOut, IDS_WSMINMAX_WARNING);
    MessageBox(strOut, NULL, MB_OK | MB_ICONWARNING);
    return FALSE;
  }

  if (bSave)
  {

    if (m_pProcDetail)
    {
      SetMGMTFlag(m_pProcDetail->base.mgmtParms.mFlags, PCMFLAG_APPLY_WS_MINMAX, WSchk);
      m_pProcDetail->base.mgmtParms.minWS = minWS *1024;
      m_pProcDetail->base.mgmtParms.maxWS = maxWS *1024;

    }
    else if (m_pJobDetail)
    {
      SetMGMTFlag(m_pJobDetail->base.mgmtParms.mFlags, PCMFLAG_APPLY_WS_MINMAX, WSchk);
      m_pJobDetail->base.mgmtParms.minWS  = minWS * 1024;
      m_pJobDetail->base.mgmtParms.maxWS  = maxWS * 1024;
    }

  }
  return TRUE;
}

BOOL CWorkingSetWiz::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
    return Validate(TRUE);
  }
  else
  {
    BOOL        WSchk = FALSE;
    MEMORY_VALUE minWS = 0;
    MEMORY_VALUE maxWS = 0;

    if (m_pProcDetail)
    {
      WSchk = m_pProcDetail->base.mgmtParms.mFlags & PCMFLAG_APPLY_WS_MINMAX;
      minWS = m_pProcDetail->base.mgmtParms.minWS;
      maxWS = m_pProcDetail->base.mgmtParms.maxWS;

    }
    else if (m_pJobDetail)
    {
      WSchk = m_pJobDetail->base.mgmtParms.mFlags & PCMFLAG_APPLY_WS_MINMAX;
      minWS = m_pJobDetail->base.mgmtParms.minWS;
      maxWS = m_pJobDetail->base.mgmtParms.maxWS;
    }
    if ( minWS/1024           > (MAXLONG - 1) ||
         maxWS/1024           > (MAXLONG - 1) )
      m_bReadOnly = TRUE;

    long minWSInK = (long) (minWS/1024);
    long maxWSInK = (long) (maxWS/1024);

    CheckDlgButton(IDC_WORKINGSET_CHK, WSchk ? BST_CHECKED : BST_UNCHECKED);
    SendDlgItemMessage(IDC_MINWS_SPIN, UDM_SETRANGE32, 0, MAXLONG - 1 );
    SendDlgItemMessage(IDC_MINWS_SPIN, UDM_SETPOS32,   0, minWSInK );

    SendDlgItemMessage(IDC_MAXWS_SPIN, UDM_SETRANGE32, 0, MAXLONG - 1 );
    SendDlgItemMessage(IDC_MAXWS_SPIN, UDM_SETPOS32,   0, maxWSInK );

    ApplyControlEnableRules(FALSE);

    return TRUE;
  }
}

void CWorkingSetWiz::ApplyControlEnableRules(BOOL bForceDisable)
{
  BOOL bEnable;
  if (m_bReadOnly || !(BST_CHECKED == IsDlgButtonChecked(IDC_WORKINGSET_CHK)) || bForceDisable)
    bEnable = FALSE;
  else
    bEnable = TRUE;

  UINT ids[] = { IDC_MINWS, IDC_MAXWS, IDC_MINWS_SPIN, IDC_MAXWS_SPIN, 0 };
  for (int i = 0; ids[i]; i++)
    ::EnableWindow(GetDlgItem(ids[i]), bEnable);

  ::EnableWindow(GetDlgItem(IDC_WORKINGSET_CHK), !(m_bReadOnly || bForceDisable));
}

BOOL CWorkingSetWiz::OnSetActive()
{
  if ( m_pProcDetail )
  {
    if (m_pProcDetail->base.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP)
      ApplyControlEnableRules(TRUE);
    else
      ApplyControlEnableRules(FALSE);
  }
  return TRUE;
}

LRESULT CWorkingSetWiz::OnSpin(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
  if (idCtrl == IDC_MINWS_SPIN ||
      idCtrl == IDC_MAXWS_SPIN )
  {
    NMUPDOWN * nmupdown = (NMUPDOWN *) pnmh;
    __int64 value = (__int64) nmupdown->iPos + 1024 * (__int64) nmupdown->iDelta;
    if ( value <= MAXLONG - 1 )
      nmupdown->iDelta *= 1024;
  }
  bHandled = FALSE;
  return 0;
}

LRESULT CWorkingSetWiz::OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_WORKINGSET_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_WORKINGSET_CHK));
    ::EnableWindow(GetDlgItem(IDC_MINWS),      checked);
    ::EnableWindow(GetDlgItem(IDC_MAXWS),      checked);
    ::EnableWindow(GetDlgItem(IDC_MINWS_SPIN), checked);
    ::EnableWindow(GetDlgItem(IDC_MAXWS_SPIN), checked);
  }
  bHandled = FALSE;
  return 0;
}

BOOL CWorkingSetWiz::OnWizardNext()
{
  if (!UpdateData(TRUE) )
    return FALSE;

  return TRUE;
}

///////////////////////////////////////////////////////////////////////////
//  CCommittedMemoryWiz

CCommittedMemoryWiz::CCommittedMemoryWiz(WIZ_POSITION pos, int nTitle, MEMORY_VALUE *procmemorylimit, bool *procmemorylimitchk, MEMORY_VALUE *jobmemorylimit, bool *jobmemorylimitchk) : 
    CMySnapInPropertyWizardImpl<CCommittedMemoryWiz>(pos, nTitle), 
    m_procmemorylimit(*procmemorylimit), m_procmemorylimitchk(*procmemorylimitchk),
    m_jobmemorylimit(*jobmemorylimit), m_jobmemorylimitchk(*jobmemorylimitchk)
{
  m_bReadOnly = FALSE;

  m_procmemorylimitchk = m_jobmemorylimitchk = FALSE;
  m_procmemorylimit    = m_jobmemorylimit = 0;
}

CCommittedMemoryWiz::~CCommittedMemoryWiz()
{
}

LRESULT CCommittedMemoryWiz::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UpdateData(FALSE);

  bHandled = FALSE;

  return TRUE;  // Let the system set the focus
}

LRESULT CCommittedMemoryWiz::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  HELPINFO *phi = (HELPINFO*) lParam;
  if (phi && phi->iContextType == HELPINFO_WINDOW)
  {
    TCHAR *pTopic = const_cast<TCHAR*>(HELP_ru_job_mem);

    MMCPropertyHelp(pTopic);

    return TRUE;
  }
  bHandled = FALSE;
  return FALSE;
}

BOOL CCommittedMemoryWiz::Validate(BOOL bSave)
{
  LONG_PTR          PosErr = 0;
  MEMORY_VALUE      procmemorylimit;
  MEMORY_VALUE      jobmemorylimit;

  procmemorylimit = SendDlgItemMessage(IDC_PROC_SPIN, UDM_GETPOS32, 0, (LPARAM) &PosErr);
  if (PosErr || procmemorylimit > MAXLONG - 1)
  {
    HWND hWndCtl = GetDlgItem(IDC_PROCMEMORY);
    if(hWndCtl)
      ::SetFocus(hWndCtl);
    MessageBeep(MB_ICONASTERISK);
    return FALSE;
  }
  jobmemorylimit = SendDlgItemMessage(IDC_JOB_SPIN, UDM_GETPOS32, 0, (LPARAM) &PosErr);
  if (PosErr || jobmemorylimit > MAXLONG - 1)
  {
    HWND hWndCtl = GetDlgItem(IDC_JOBMEMORY);
    if(hWndCtl)
      ::SetFocus(hWndCtl);
    MessageBeep(MB_ICONASTERISK);
    return FALSE;
  }

  if (bSave)
  {
    m_procmemorylimitchk = (BST_CHECKED == IsDlgButtonChecked(IDC_PROCMEMORY_CHK));
    m_procmemorylimit    = procmemorylimit * 1024;
    m_jobmemorylimitchk  = (BST_CHECKED == IsDlgButtonChecked(IDC_JOBMEMORY_CHK));
    m_jobmemorylimit     = jobmemorylimit * 1024;
  }
  return TRUE;
}

BOOL CCommittedMemoryWiz::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
    return Validate(TRUE);
  }
  else
  {
    if ( m_procmemorylimit/1024 > (MAXLONG - 1) ||
         m_jobmemorylimit/1024  > (MAXLONG - 1) )
      m_bReadOnly = TRUE;

    long ProcMemInK = (long) (m_procmemorylimit/1024);
    long JobMemInK  = (long) (m_jobmemorylimit/1024);

    CheckDlgButton(IDC_PROCMEMORY_CHK, m_procmemorylimitchk ? BST_CHECKED : BST_UNCHECKED);
    SendDlgItemMessage(IDC_PROC_SPIN, UDM_SETRANGE32, 0, MAXLONG - 1);
    SendDlgItemMessage(IDC_PROC_SPIN, UDM_SETPOS32,   0, ProcMemInK );

    CheckDlgButton(IDC_JOBMEMORY_CHK,  m_jobmemorylimitchk  ? BST_CHECKED : BST_UNCHECKED);
    SendDlgItemMessage(IDC_JOB_SPIN, UDM_SETRANGE32, 0, MAXLONG - 1);
    SendDlgItemMessage(IDC_JOB_SPIN, UDM_SETPOS32,   0, JobMemInK );

    if (m_bReadOnly || !m_procmemorylimitchk)
      DisableControl(IDC_PROCMEMORY);

    if (m_bReadOnly || !m_jobmemorylimitchk)
      DisableControl(IDC_JOBMEMORY);

    if (m_bReadOnly)
    {
      DisableControl(IDC_PROCMEMORY_CHK);
      DisableControl(IDC_JOBMEMORY_CHK);
    }
    return TRUE;
  }
}

LRESULT CCommittedMemoryWiz::OnSpin(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
  if (idCtrl == IDC_PROC_SPIN  ||
      idCtrl == IDC_JOB_SPIN )
  {
    NMUPDOWN * nmupdown = (NMUPDOWN *) pnmh;
    __int64 value = (__int64) nmupdown->iPos + 1024 * (__int64) nmupdown->iDelta;
    if ( value <= MAXLONG - 1 )
      nmupdown->iDelta *= 1024;
  }
  bHandled = FALSE;
  return 0;
}

LRESULT CCommittedMemoryWiz::OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_PROCMEMORY_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_PROCMEMORY_CHK));
    ::EnableWindow(GetDlgItem(IDC_PROCMEMORY), checked);
    ::EnableWindow(GetDlgItem(IDC_PROC_SPIN),  checked);
  }
  else if (wID == IDC_JOBMEMORY_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_JOBMEMORY_CHK));
    ::EnableWindow(GetDlgItem(IDC_JOBMEMORY), checked);
    ::EnableWindow(GetDlgItem(IDC_JOB_SPIN),  checked);
  }

  bHandled = FALSE;
  return 0;
}

BOOL CCommittedMemoryWiz::OnWizardNext()
{
  if (!UpdateData(TRUE) )
    return FALSE;

  return TRUE;
}

///////////////////////////////////////////////////////////////////////////
//  CProcCountWiz
CProcCountWiz::CProcCountWiz(WIZ_POSITION pos, int nTitle, PROC_COUNT *processcount, bool *processcountchk ) :
    CMySnapInPropertyWizardImpl<CProcCountWiz>(pos, nTitle),
    m_processcount(*processcount), m_processcountchk(*processcountchk)
{
  m_bReadOnly = FALSE;

  m_processcount = 0;
  m_processcountchk = FALSE;
}

CProcCountWiz::~CProcCountWiz()
{
}

LRESULT CProcCountWiz::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UpdateData(FALSE);

  bHandled = FALSE;

  return TRUE;  // Let the system set the focus
}

LRESULT CProcCountWiz::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  HELPINFO *phi = (HELPINFO*) lParam;
  if (phi && phi->iContextType == HELPINFO_WINDOW)
  {
    TCHAR *pTopic = const_cast<TCHAR*>(HELP_ru_job_procs);

    MMCPropertyHelp(pTopic);

    return TRUE;
  }
  bHandled = FALSE;
  return FALSE;
}

BOOL CProcCountWiz::Validate(BOOL bSave)
{
  LONG_PTR PosErr = 0;
  LRESULT processcount = SendDlgItemMessage(IDC_SPIN, UDM_GETPOS32, 0, (LPARAM) &PosErr);

  if (PosErr || processcount < 0)
  {
    HWND hWndCtl = GetDlgItem(IDC_PROCESSCOUNT);
    if(hWndCtl)
      ::SetFocus(hWndCtl);
    MessageBeep(MB_ICONASTERISK);
    return FALSE;
  }

  if (bSave)
  {
    m_processcountchk = (BST_CHECKED == IsDlgButtonChecked(IDC_PROCESSCOUNT_CHK));
    m_processcount    = (PROC_COUNT) processcount;
  }
  return TRUE;
}

BOOL CProcCountWiz::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
    return Validate(TRUE);
  }
  else
  {
    CheckDlgButton(IDC_PROCESSCOUNT_CHK, m_processcountchk ? BST_CHECKED : BST_UNCHECKED);

    SendDlgItemMessage(IDC_SPIN, UDM_SETRANGE32, 0, MAXLONG-1);
    SendDlgItemMessage(IDC_SPIN, UDM_SETPOS32,   0, m_processcount );

    if (m_bReadOnly || !m_processcountchk)
    {
      DisableControl(IDC_PROCESSCOUNT);
      DisableControl(IDC_SPIN);
    }
    if (m_bReadOnly)
      DisableControl(IDC_PROCESSCOUNT_CHK);

    return TRUE;
  }
}

LRESULT CProcCountWiz::OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_PROCESSCOUNT_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_PROCESSCOUNT_CHK));
    ::EnableWindow(GetDlgItem(IDC_PROCESSCOUNT), checked);
    ::EnableWindow(GetDlgItem(IDC_SPIN),         checked);
  }
  bHandled = FALSE;
  return 0;
}

BOOL CProcCountWiz::OnWizardNext()
{
  if (!UpdateData(TRUE) )
    return FALSE;

  return TRUE;
}


///////////////////////////////////////////////////////////////////////////
//  CTimeWiz
CTimeWiz::CTimeWiz(WIZ_POSITION pos, int nTitle,
                   TIME_VALUE *procusertime, bool *procusertimechk,
                   TIME_VALUE *jobusertime, bool *jobusertimechk, bool *jobmsgontimelimit) :
    CMySnapInPropertyWizardImpl<CTimeWiz>(pos, nTitle),
    m_procusertime(*procusertime), m_procusertimechk(*procusertimechk),
    m_jobusertime(*jobusertime), m_jobusertimechk(*jobusertimechk), m_jobmsgontimelimit(*jobmsgontimelimit)
{
  m_bReadOnly = FALSE;

  m_procusertimechk = m_jobusertimechk = m_jobmsgontimelimit = FALSE;
  m_procusertime    = m_jobusertime = 0;
}

CTimeWiz::~CTimeWiz()
{
}


LRESULT CTimeWiz::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UpdateData(FALSE);

  bHandled = FALSE;

  return TRUE;  // Let the system set the focus
}

LRESULT CTimeWiz::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  HELPINFO *phi = (HELPINFO*) lParam;
  if (phi && phi->iContextType == HELPINFO_WINDOW)
  {
    TCHAR *pTopic = const_cast<TCHAR*>(HELP_ru_job_time);

    MMCPropertyHelp(pTopic);

    return TRUE;
  }
  bHandled = FALSE;
  return FALSE;
}

BOOL CTimeWiz::Validate(BOOL bSave)
{
  TIME_VALUE procusertime;
  TIME_VALUE jobusertime;

  bool procusertimechk = (BST_CHECKED == IsDlgButtonChecked(IDC_PROCUSERTIME_CHK));
  bool jobusertimechk  = (BST_CHECKED == IsDlgButtonChecked(IDC_JOBUSERTIME_CHK));

  if ( !ValidateTimeField(m_hWnd, IDC_PROCUSERTIME, procusertime) ||
       (procusertimechk && procusertime < PC_MIN_TIME_LIMIT) )
  {
    HWND hWndCtl = GetDlgItem(IDC_PROCUSERTIME);
    if(hWndCtl)
      ::SetFocus(hWndCtl);
    MessageBeep(MB_ICONASTERISK);
    CComBSTR bTemp;
    if (bTemp.LoadString(IDS_TIMEENTRY))
      MessageBox(bTemp.m_str, NULL, MB_OK | MB_ICONWARNING);
    return FALSE;
  }
  if ( !ValidateTimeField(m_hWnd, IDC_JOBUSERTIME, jobusertime) ||
       (jobusertimechk && jobusertime < PC_MIN_TIME_LIMIT) )
  {
    HWND hWndCtl = GetDlgItem(IDC_JOBUSERTIME);
    if(hWndCtl)
      ::SetFocus(hWndCtl);
    MessageBeep(MB_ICONASTERISK);
    CComBSTR bTemp;
    if (bTemp.LoadString(IDS_TIMEENTRY))
      MessageBox(bTemp.m_str, NULL, MB_OK | MB_ICONWARNING);
    return FALSE;
  }

  if (bSave)
  {
    m_procusertimechk = procusertimechk;
    m_procusertime    = procusertime;
    m_jobusertimechk  = jobusertimechk;
    m_jobusertime     = jobusertime;
    m_jobmsgontimelimit =  (BST_CHECKED == IsDlgButtonChecked(IDC_JOBTIMELIMIT_MSG));
  }
  return TRUE;
}

BOOL CTimeWiz::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
    return Validate(TRUE);
  }
  else
  {
    ITEM_STR str;
    CheckDlgButton(IDC_PROCUSERTIME_CHK, m_procusertimechk ? BST_CHECKED : BST_UNCHECKED);
    SetDlgItemText(IDC_PROCUSERTIME,     FormatCNSTime(str, m_procusertime) );

    CheckDlgButton(IDC_JOBUSERTIME_CHK,  m_jobusertimechk  ? BST_CHECKED : BST_UNCHECKED);
    SetDlgItemText(IDC_JOBUSERTIME,      FormatCNSTime(str, m_jobusertime) );

    CheckRadioButton(IDC_JOBTIMELIMIT_TERM, IDC_JOBTIMELIMIT_MSG, m_jobmsgontimelimit ? IDC_JOBTIMELIMIT_MSG : IDC_JOBTIMELIMIT_TERM );

    if (m_bReadOnly || !m_procusertimechk)
      DisableControl(IDC_PROCUSERTIME);

    if (m_bReadOnly || !m_jobusertimechk)
    {
      DisableControl(IDC_JOBUSERTIME);
      DisableControl(IDC_JOBTIMELIMIT_TERM);
      DisableControl(IDC_JOBTIMELIMIT_MSG);
    }

    if (m_bReadOnly)
    {
      DisableControl(IDC_PROCUSERTIME_CHK);
      DisableControl(IDC_JOBUSERTIME_CHK);
    }
    return TRUE;
  }
}

LRESULT CTimeWiz::OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_PROCUSERTIME_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_PROCUSERTIME_CHK));
    ::EnableWindow(GetDlgItem(IDC_PROCUSERTIME), checked);
  }
  else if (wID == IDC_JOBUSERTIME_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_JOBUSERTIME_CHK));
    ::EnableWindow(GetDlgItem(IDC_JOBUSERTIME),       checked);
    ::EnableWindow(GetDlgItem(IDC_JOBTIMELIMIT_TERM), checked);
    ::EnableWindow(GetDlgItem(IDC_JOBTIMELIMIT_MSG),  checked);
  }
  bHandled = FALSE;
  return 0;
}

BOOL CTimeWiz::OnWizardNext()
{
  if (!UpdateData(TRUE) )
    return FALSE;

  return TRUE;
}


///////////////////////////////////////////////////////////////////////////
//  CAdvancedWiz

CAdvancedWiz::CAdvancedWiz(WIZ_POSITION pos, int nTitle, bool *endjob, bool *unhandledexcept ) :
    CMySnapInPropertyWizardImpl<CAdvancedWiz>(pos, nTitle),
    m_endjob(*endjob),m_unhandledexcept(*unhandledexcept)
{
  m_bReadOnly = FALSE;

  m_endjob = m_unhandledexcept = FALSE;
}

CAdvancedWiz::~CAdvancedWiz()
{
}

LRESULT CAdvancedWiz::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UpdateData(FALSE);

  bHandled = FALSE;

  return TRUE;  // Let the system set the focus
}

LRESULT CAdvancedWiz::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  HELPINFO *phi = (HELPINFO*) lParam;
  if (phi && phi->iContextType == HELPINFO_WINDOW)
  {
    TCHAR *pTopic = const_cast<TCHAR*>(HELP_ru_job_adv);

    MMCPropertyHelp(pTopic);

    return TRUE;
  }
  bHandled = FALSE;
  return FALSE;
}

BOOL CAdvancedWiz::Validate(BOOL bSave)
{
  if (bSave)
  {
    m_endjob          = (BST_CHECKED == IsDlgButtonChecked(IDC_ENDJOB_CHK));
    m_unhandledexcept = (BST_CHECKED == IsDlgButtonChecked(IDC_UNHANDLEDEXCEPT_CHK));
  }
  return TRUE;
}

BOOL CAdvancedWiz::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
    return Validate(TRUE);
  }
  else
  {
    CheckDlgButton(IDC_ENDJOB_CHK,          m_endjob          ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(IDC_UNHANDLEDEXCEPT_CHK, m_unhandledexcept ? BST_CHECKED : BST_UNCHECKED);

    if (m_bReadOnly)
    {
      DisableControl(IDC_ENDJOB_CHK);
      DisableControl(IDC_UNHANDLEDEXCEPT_CHK);
    }

    return TRUE;
  }
}

BOOL CAdvancedWiz::OnWizardNext()
{
  if (!UpdateData(TRUE) )
    return FALSE;

  return TRUE;
}

///////////////////////////////////////////////////////////////////////////
//  CAdvBreakawayWiz

CAdvBreakawayWiz::CAdvBreakawayWiz(WIZ_POSITION pos, int nTitle, bool *breakaway, bool *silentbreakaway) :
    CMySnapInPropertyWizardImpl<CAdvBreakawayWiz>(pos, nTitle),
    m_breakaway(*breakaway), m_silentbreakaway(*silentbreakaway)
{
  m_bReadOnly = FALSE;

  m_breakaway = m_silentbreakaway = FALSE;
}

CAdvBreakawayWiz::~CAdvBreakawayWiz()
{
}

LRESULT CAdvBreakawayWiz::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UpdateData(FALSE);

  bHandled = FALSE;

  return TRUE;  // Let the system set the focus
}

LRESULT CAdvBreakawayWiz::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  HELPINFO *phi = (HELPINFO*) lParam;
  if (phi && phi->iContextType == HELPINFO_WINDOW)
  {
    TCHAR *pTopic = const_cast<TCHAR*>(HELP_ru_job_adv);

    MMCPropertyHelp(pTopic);

    return TRUE;
  }
  bHandled = FALSE;
  return FALSE;
}

BOOL CAdvBreakawayWiz::Validate(BOOL bSave)
{
  if (bSave)
  {
    m_breakaway       = (BST_CHECKED == IsDlgButtonChecked(IDC_BREAKAWAY_CHK));
    m_silentbreakaway = (BST_CHECKED == IsDlgButtonChecked(IDC_SILENTBREAKAWAY_CHK));
  }
  return TRUE;
}

BOOL CAdvBreakawayWiz::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
    return Validate(TRUE);
  }
  else
  {
    CheckDlgButton(IDC_BREAKAWAY_CHK,       m_breakaway       ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(IDC_SILENTBREAKAWAY_CHK, m_silentbreakaway ? BST_CHECKED : BST_UNCHECKED);

    if (m_bReadOnly)
    {
      DisableControl(IDC_BREAKAWAY_CHK);
      DisableControl(IDC_SILENTBREAKAWAY_CHK);
    }

    return TRUE;
  }
}

BOOL CAdvBreakawayWiz::OnWizardNext()
{
  if (!UpdateData(TRUE) )
    return FALSE;

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\managementpages.h ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    ManagementPages.h                                                        //
|                                                                                       //
|Description:  Definition of Management Property pages                                  //
|                                                                                       //
|Created:      Paul Skoglund 09-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#ifndef __MANAGEMENTPAGES_H_
#define __MANAGEMENTPAGES_H_

#include "Globals.h"
#include "ppage.h"
#include "Container.h"

const AFFINITY ProcessorBit = 1;


const TIME_VALUE CNSperTenths   = 1000 * 1000;
const TIME_VALUE CNSperSec      = CNSperTenths  * 10;
const TIME_VALUE CNSperMinute   = CNSperSec     * 60;
const TIME_VALUE CNSperHour     = CNSperMinute  * 60;
const TIME_VALUE CNSperDay      = CNSperHour    * 24;
const TIME_VALUE CNSperYear     = CNSperDay     * 365;

const TIME_VALUE SecondsperYear = 365 * 24 * 60 * 60;
const TIME_VALUE MinutesperYear = 365 * 24 * 60;
const TIME_VALUE HoursperYear   = 365 * 24;

void SetMGMTFlag(PC_MGMT_FLAGS &flag, PCMgmtFlags bit, BOOL bOn);

// some formating helper functions
LPCTSTR FormatMatchType         (ITEM_STR str, const MATCH_TYPE       matchType);
LPCTSTR FormatAffinity          (ITEM_STR str, const AFFINITY         affinity);
LPCTSTR FormatPriority          (ITEM_STR str, const PRIORITY         priority);
LPCTSTR FormatSchedulingClass   (ITEM_STR str, const SCHEDULING_CLASS schedClass);
LPCTSTR FormatProcCount         (ITEM_STR str, const PROC_COUNT       procCount);
LPCTSTR FormatPCUINT32          (ITEM_STR str, const PCUINT32         uInt);
LPCTSTR FormatPCINT32           (ITEM_STR str, const PCINT32          aInt);
LPCTSTR FormatPCUINT64          (ITEM_STR str, const PCUINT64         aUInt64);
LPCTSTR FormatApplyFlag         (ITEM_STR str, const BOOL             applied);
LPCTSTR FormatMemory            (ITEM_STR str, const MEMORY_VALUE     memory_value);
LPCTSTR FormatTime              (ITEM_STR str, const TIME_VALUE       timevalue);
LPCTSTR FormatTimeToms          (ITEM_STR str, const TIME_VALUE       time);
LPCTSTR FormatCNSTime           (ITEM_STR str,       TIME_VALUE       timevalue);
LPCTSTR FormatCPUTIMELimitAction(ITEM_STR str, const BOOL             bMsgOnLimit);

LPCTSTR FormatSheetTitle(CComBSTR &Title, const CComBSTR &item_name, const COMPUTER_CONNECTION_INFO &Target);

// some dialog helper functions
int      PriorityToID(PRIORITY p);
PRIORITY IDToPriority(int id);
int      MatchTypeToID(MATCH_TYPE matchType);
BOOL     ValidateTimeField(HWND hDlg, WORD wID, TIME_VALUE &newtime);




class CBaseNode;

class CMGMTAffinityPage :
	public CMySnapInPropertyPageImpl<CMGMTAffinityPage>
{
public :
  CMGMTAffinityPage(int nTitle, CProcDetailContainer *pContainer, AFFINITY ProcessorMask = 0xFFffFFff);
  CMGMTAffinityPage(int nTitle, CJobDetailContainer  *pContainer, AFFINITY ProcessorMask = 0xFFffFFff);

  ~CMGMTAffinityPage();

	enum { IDD = IDD_AFFINITY_PAGE };

  bool     m_affinitychk;
  AFFINITY m_affinity;
  AFFINITY m_ProcessorMask;

	BEGIN_MSG_MAP(CMGMTAffinityPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP,       OnWMHelp)
    COMMAND_RANGE_HANDLER(IDC_AFFINITY1, IDC_AFFINITY64, OnAffinityEdit)
    COMMAND_HANDLER(IDC_AFFINITY_CHK, BN_CLICKED, OnChk)
  	CHAIN_MSG_MAP(CMySnapInPropertyPageImpl<CMGMTAffinityPage>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnAffinityEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	BOOL OnSetActive();
  BOOL OnHelp();
  BOOL OnKillActive()      { return Validate(TRUE); }
  BOOL OnApply();

	BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
	BOOL Validate(BOOL bSave = FALSE);

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
	HANDLE m_hIconImage;

  typedef enum _PageType
  {
    PROCESS_PAGE,
    JOB_PAGE,
  } PageType;

  CProcDetailContainer     *m_pProcContainer;
  CJobDetailContainer      *m_pJobContainer;

  BOOL                      m_bReadOnly;
	PageType                  m_PageType;
  union {
    struct
    {
      int affinitychk : 1;
      int affinity : 1;
    } Fields;
    int on;
  } PageFields;

  void Initialize();
  void ApplyControlEnableRules(BOOL bForceDisable);
};

class CMGMTPriorityPage :
	public CMySnapInPropertyPageImpl<CMGMTPriorityPage>
{
public :
  CMGMTPriorityPage(int nTitle, CProcDetailContainer  *pContainer);
  CMGMTPriorityPage(int nTitle, CJobDetailContainer   *pContainer);

  ~CMGMTPriorityPage();

	enum { IDD = IDD_PRIORITY_PAGE };

  bool     m_prioritychk;
  PRIORITY m_priority;

	BEGIN_MSG_MAP(CMGMTPriorityPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)    
    MESSAGE_HANDLER(WM_HELP,       OnWMHelp)
    COMMAND_RANGE_HANDLER(IDC_LOW, IDC_REALTIME, OnPriorityEdit)
    COMMAND_HANDLER(IDC_PRIORITY_CHK, BN_CLICKED, OnChk)
  	CHAIN_MSG_MAP(CMySnapInPropertyPageImpl<CMGMTPriorityPage>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnPriorityEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	BOOL OnSetActive();
  BOOL OnHelp();
  BOOL OnKillActive()      { return Validate(TRUE); }
  BOOL OnApply();

	BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
	BOOL Validate(BOOL bSave = FALSE);

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
	HANDLE m_hIconImage;

  typedef enum _PageType
  {
    PROCESS_PAGE,
    JOB_PAGE
  } PageType;

  CProcDetailContainer     *m_pProcContainer;
  CJobDetailContainer      *m_pJobContainer;

  BOOL                      m_bReadOnly;
	PageType                  m_PageType;
  union {
    struct
    {
      int prioritychk : 1;
      int priority : 1;
    } Fields;
    int on;
  } PageFields;

  void Initialize();
  void ApplyControlEnableRules(BOOL bForceDisable);
};

class CMGMTSchedulingClassPage :
	public CMySnapInPropertyPageImpl<CMGMTSchedulingClassPage>
{
public :
  CMGMTSchedulingClassPage(int nTitle, CJobDetailContainer  *pContainer);

  ~CMGMTSchedulingClassPage();

	enum { IDD = IDD_SCHEDULING_CLASS_PAGE };

  bool             m_schedClasschk;
  SCHEDULING_CLASS m_schedClass;

	BEGIN_MSG_MAP(CMGMTSchedulingClassPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP,       OnWMHelp)
		COMMAND_HANDLER(IDC_SCLASS, EN_CHANGE, OnEditChange)
    COMMAND_HANDLER(IDC_SCHEDULING_CHK, BN_CLICKED, OnChk)
  	CHAIN_MSG_MAP(CMySnapInPropertyPageImpl<CMGMTSchedulingClassPage>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnEditChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnPriorityEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

  BOOL OnHelp();
	BOOL OnKillActive()      { return Validate(TRUE); }
  BOOL OnApply();

	BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
	BOOL Validate(BOOL bSave = FALSE);

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  CJobDetailContainer      *m_pJobContainer;

  BOOL                      m_bReadOnly;
  union {
    struct
    {
      int schedClasschk : 1;
      int schedClass : 1;
    } Fields;
    int on;
  } PageFields;

};  // CMGMTSchedulingClassPage

class CMGMTMemoryPage :
	public CMySnapInPropertyPageImpl<CMGMTMemoryPage>
{
public :
  CMGMTMemoryPage(int nTitle, CProcDetailContainer *pContainer);
  CMGMTMemoryPage(int nTitle, CJobDetailContainer  *pContainer);

  ~CMGMTMemoryPage();

	enum { IDD = IDD_MEMORY_PAGE };

  bool             m_WSchk;
  MEMORY_VALUE     m_minWS;
  MEMORY_VALUE     m_maxWS;

  bool             m_procmemorylimitchk;
  MEMORY_VALUE     m_procmemorylimit;

  bool             m_jobmemorylimitchk;
  MEMORY_VALUE     m_jobmemorylimit;

	BEGIN_MSG_MAP(CMGMTMemoryPage)		
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP,       OnWMHelp)
    NOTIFY_HANDLER (IDC_MINWS_SPIN,     UDN_DELTAPOS, OnSpin)
    NOTIFY_HANDLER (IDC_MAXWS_SPIN,     UDN_DELTAPOS, OnSpin)
    NOTIFY_HANDLER (IDC_PROC_SPIN,      UDN_DELTAPOS, OnSpin)
    NOTIFY_HANDLER (IDC_JOB_SPIN,       UDN_DELTAPOS, OnSpin)
    COMMAND_HANDLER(IDC_WORKINGSET_CHK, BN_CLICKED,   OnChk)
    COMMAND_HANDLER(IDC_MINWS,          EN_CHANGE,    OnEditChange)
    COMMAND_HANDLER(IDC_MAXWS,          EN_CHANGE,    OnEditChange) 
    COMMAND_HANDLER(IDC_PROCMEMORY_CHK, BN_CLICKED,   OnChk)
    COMMAND_HANDLER(IDC_PROCMEMORY,     EN_CHANGE,    OnEditChange) 
    COMMAND_HANDLER(IDC_JOBMEMORY_CHK,  BN_CLICKED,   OnChk)
    COMMAND_HANDLER(IDC_JOBMEMORY,      EN_CHANGE,    OnEditChange)
  	CHAIN_MSG_MAP(CMySnapInPropertyPageImpl<CMGMTMemoryPage>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnEditChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnSpin(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

  BOOL OnSetActive();
  BOOL OnHelp();
	BOOL OnKillActive()      { return Validate(TRUE); }
  BOOL OnApply();

	BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
	BOOL Validate(BOOL bSave = FALSE);

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
	HANDLE m_hIconImage;

  CProcDetailContainer     *m_pProcContainer;
  CJobDetailContainer      *m_pJobContainer;

  BOOL                      m_bReadOnly;
  union {
    struct
    {
      int WSchk : 1;
      int minWS : 1;
      int maxWS : 1;
      int procmemorylimitchk : 1;
      int procmemorylimit : 1;
      int jobmemorylimitchk : 1;
      int jobmemorylimit : 1;
    } Fields;
    int on;
  } PageFields;

  void Initialize();
  void ApplyControlEnableRules(BOOL bForceDisable);
};

class CMGMTTimePage :
	public CMySnapInPropertyPageImpl<CMGMTTimePage>
{
public :
  CMGMTTimePage(int Title, CJobDetailContainer  *pContainer);

  ~CMGMTTimePage();

	enum { IDD = IDD_TIME_PAGE };

  bool       m_procusertimechk;
  TIME_VALUE m_procusertime;

  bool       m_jobusertimechk;
  TIME_VALUE m_jobusertime;
  bool       m_jobmsgontimelimit;
  
	BEGIN_MSG_MAP(CMGMTMemoryPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP,       OnWMHelp)
    COMMAND_HANDLER(IDC_PROCUSERTIME_CHK, BN_CLICKED, OnChk)
    COMMAND_HANDLER(IDC_PROCUSERTIME,     EN_CHANGE,  OnEditChange) 
    COMMAND_HANDLER(IDC_JOBUSERTIME_CHK,  BN_CLICKED, OnChk)
    COMMAND_HANDLER(IDC_JOBUSERTIME,      EN_CHANGE,  OnEditChange) 
    COMMAND_HANDLER(IDC_JOBTIMELIMIT_TERM,BN_CLICKED, OnChk)
    COMMAND_HANDLER(IDC_JOBTIMELIMIT_MSG, BN_CLICKED, OnChk)
  	CHAIN_MSG_MAP(CMySnapInPropertyPageImpl<CMGMTTimePage>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnEditChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

  BOOL OnHelp();
	BOOL OnKillActive()      { return Validate(TRUE); }
  BOOL OnApply();

	BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
	BOOL Validate(BOOL bSave = FALSE);

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  CJobDetailContainer      *m_pJobContainer;

  BOOL                      m_bReadOnly;
  union {
    struct
    {
      int procusertimechk   : 1;
      int procusertime      : 1;
      int jobusertimechk    : 1;
      int jobmsgontimelimit : 1;
      int jobusertime       : 1;
    } Fields;
    int on;
  } PageFields;

};

class CMGMTAdvancedPage :
	public CMySnapInPropertyPageImpl<CMGMTAdvancedPage>
{
public :
  CMGMTAdvancedPage(int nTitle, CJobDetailContainer *pContainer);

  ~CMGMTAdvancedPage();

	enum { IDD = IDD_ADVANCED_PAGE };

  bool      m_endjob;
  bool      m_unhandledexcept;
  bool      m_breakaway;
  bool      m_silentbreakaway;

	BEGIN_MSG_MAP(CMGMTAdvancedPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)    
    MESSAGE_HANDLER(WM_HELP,       OnWMHelp)
    COMMAND_HANDLER(IDC_ENDJOB_CHK,          BN_CLICKED, OnChk)
    COMMAND_HANDLER(IDC_UNHANDLEDEXCEPT_CHK, BN_CLICKED, OnChk)
    COMMAND_HANDLER(IDC_BREAKAWAY_CHK,       BN_CLICKED, OnChk)
    COMMAND_HANDLER(IDC_SILENTBREAKAWAY_CHK, BN_CLICKED, OnChk)
  	CHAIN_MSG_MAP(CMySnapInPropertyPageImpl<CMGMTAdvancedPage>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

  BOOL OnHelp();
	BOOL OnKillActive()      { return Validate(TRUE); }
  BOOL OnApply();

	BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
	BOOL Validate(BOOL bSave = FALSE);

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  CJobDetailContainer      *m_pJobContainer;

  BOOL                      m_bReadOnly;

  union {
    struct
    {
      int endjob : 1;
      int unhandledexcept : 1;
      int breakaway : 1;
      int silentbreakaway : 1;
    } Fields;
    int on;
  } PageFields;

};

#endif // __MANAGEMENTPAGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\namerulefolder.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    NameRuleFolder.cpp                                                       //
|                                                                                       //
|Description:  Implementation of Name rule node                                         //
|                                                                                       //
|Created:      Paul Skoglund 07-1998                                                    //
|                                                                                       //
|Work to be done:                                                                       //
|  8/18/1998                                                                            //
|  -preserve result pane selection when list is redrawn                                 //
|  -on PCXXX calls get the updated list                                                 //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/
 
#include "StdAfx.h"
#include "BaseNode.h"

#include "NameRulePages.h"
#include "ManagementPages.h" //(formating functions)

#pragma warning(push)
#include <algorithm>
#pragma warning(pop)

using std::find;
using std::list<PCNameRule*>;

const GUID         CNameRuleFolder::m_GUID   =   {0xff9baf60,0x064e,0x11d2,{0x80, 0x14,0x00,0x10,0x4b,0x9a,0x31,0x06} };
const TCHAR *const CNameRuleFolder::m_szGUID = _T("{ff9baf60-064e-11d2-8014-00104b9a3106}");

const CONTEXTMENUITEMBYID CNameRuleFolder::ResultsTopMenuItems[] =
{
  { IDS_NRULE_INSERT,   ID_NRULE_INSERT,   ID_NRULE_INSERT,   CCM_INSERTIONPOINTID_PRIMARY_TOP },
  { IDS_NRULE_MOVEUP,   ID_NRULE_MOVEUP,   ID_NRULE_MOVEUP,   CCM_INSERTIONPOINTID_PRIMARY_TOP },
  { IDS_NRULE_MOVEDOWN, ID_NRULE_MOVEDOWN, ID_NRULE_MOVEDOWN, CCM_INSERTIONPOINTID_PRIMARY_TOP },
  { IDS_NRULE_EDIT,     ID_NRULE_EDIT,     ID_NRULE_EDIT,     CCM_INSERTIONPOINTID_PRIMARY_TOP },
  { 0,                  0,                 0,                 0,                               }
};


CNameRuleFolder::CNameRuleFolder(CBaseNode *pParent) : CBaseNode(NAMERULE_NODE, pParent), m_ID(0)
{
  LoadStringHelper(m_name, IDS_NAMERULE_FOLDER);
}


CNameRuleFolder::~CNameRuleFolder()
{
  ClearCache();
  ATLTRACE(_T("~CNameRuleFolder end\n"));
}

LPCTSTR CNameRuleFolder::GetNodeName()
{ 
  return m_name;
}

HRESULT CNameRuleFolder::GetDisplayInfo(RESULTDATAITEM &ResultItem)
{
  if (ResultItem.bScopeItem)
  {
    if( ResultItem.mask & RDI_STR )
    {
      if (0 == ResultItem.nCol)
        ResultItem.str = const_cast<LPOLESTR>(GetNodeName());
      else
        ResultItem.str = _T("");
    }
    if (ResultItem.mask & RDI_IMAGE)
      ResultItem.nImage = sImage();
    return S_OK;
  }

  list<PCNameRule*>::iterator item;

  item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCNameRule*>(ResultItem.lParam) );

  if (item == Cache.end() )
    return E_UNEXPECTED;

  if (ResultItem.mask & RDI_STR)
  {
    PCNameRule &ref = **item;
    LPCTSTR &pstr = ResultItem.str;

    switch (ResultItem.nCol)
    {
    case TYPE_COLUMN:
      pstr = FormatMatchType(m_ResultStr, ref.matchType);
      break;
    case DESCRIPTION_COLUMN:
      pstr = ref.description;
      break;
    case MATCH_COLUMN:
      pstr = ref.matchString;
      break;
    case PROCESS_ALIAS_COLUMN:
      pstr = ref.procName;
      break;
    default:
      ASSERT(FALSE);
      pstr = _T("");
      break;
    }
  }

  return S_OK;

}

HRESULT CNameRuleFolder::OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2* ipHeaderCtrl, IConsole2* ipConsole2)
{
  ASSERT(hItem == GetID());

  if (!bSelecting)
    return S_OK;

  HRESULT  hr;
  ITEM_STR str;

  LoadStringHelper(str, IDS_PROCESS_ALIAS_RULE_HDR);
  hr = ipHeaderCtrl->InsertColumn( PROCESS_ALIAS_COLUMN, str, 0, PROCESS_ALIAS_COLUMN_WIDTH );
  ASSERT(hr == S_OK);

  LoadStringHelper(str, IDS_DESCRIPTION_HDR);
  hr = ipHeaderCtrl->InsertColumn( DESCRIPTION_COLUMN, str, 0, DESCRIPTION_COLUMN_WIDTH );
  ASSERT(hr == S_OK);

  LoadStringHelper(str, IDS_MATCH_HDR);
  hr = ipHeaderCtrl->InsertColumn( MATCH_COLUMN, str, 0, MATCH_COLUMN_WIDTH );
  ASSERT(hr == S_OK);

  LoadStringHelper(str, IDS_TYPE_HDR);
  hr = ipHeaderCtrl->InsertColumn( TYPE_COLUMN, str, 0, TYPE_COLUMN_WIDTH );
  ASSERT(hr == S_OK);

  return OnRefresh(ipConsole2);
}

HRESULT CNameRuleFolder::OnViewChange(IResultData *ipResultData, LPARAM thing, LONG_PTR hint)
{
  ASSERT(ipResultData);
  if (!ipResultData)  
    return E_UNEXPECTED;

  VERIFY(ipResultData->ModifyViewStyle((MMC_RESULT_VIEW_STYLE) (MMC_SINGLESEL | MMC_NOSORTHEADER), (MMC_RESULT_VIEW_STYLE) 0) == S_OK);

  list<PCNameRule*>::iterator item;

  HRESULT hr = E_UNEXPECTED;
  switch (hint)
  {
  case PC_VIEW_REDRAWALL:
    hr = ShowAllItems(ipResultData, TRUE);
    break;
  case PC_VIEW_UPDATEALL:
    hr = ShowAllItems(ipResultData, FALSE);
    break;
  case PC_VIEW_SETITEM:
    item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCNameRule*>(thing) );
    if (item == Cache.end())
      hr = E_UNEXPECTED;
    else
    {
      HRESULTITEM hItem;
      hr = ipResultData->FindItemByLParam(thing, &hItem);
      if (hr == S_OK)
      {
        RESULTDATAITEM data = { 0 };
        data.mask = RDI_IMAGE;
        data.itemID = hItem;

        switch((*item)->matchType)
        {
        case MATCH_PGM:
          data.nImage = ALIASRULES_IMAGE;    
          break;
        case MATCH_DIR:
          data.nImage = ALIASRULES_IMAGE;
          break;
        case MATCH_ANY:
          data.nImage = ALIASRULES_IMAGE;
          break;
        default:
          ASSERT(FALSE);
          data.nImage = ITEMIMAGE_ERROR;
          break;
        }
        hr = ipResultData->SetItem(&data);
        if (hr == S_OK)
          hr = ipResultData->UpdateItem(hItem);
      }
    }
    break;
  case PC_VIEW_UPDATEITEM:
    {
    HRESULTITEM hItem;
    hr = ipResultData->FindItemByLParam(thing, &hItem);
    if (hr == S_OK)
      hr = ipResultData->UpdateItem(hItem);
    }
    break;
  case PC_VIEW_ADDITEM:
    hr = ShowAllItems(ipResultData, TRUE);
    break;
  case PC_VIEW_DELETEITEM:
    {
    HRESULTITEM hItem;
    hr = ipResultData->FindItemByLParam(thing, &hItem);
    if (hr == S_OK)
      hr = ipResultData->DeleteItem(hItem, 0);    
    }
    break;
  default:
    hr = E_UNEXPECTED;
    break;
  }
  ASSERT(hr == S_OK);
  return hr;
}

HRESULT CNameRuleFolder::ShowAllItems(IResultData* ipResultData, BOOL bCacheValid)
{
  list<PCNameRule*>::iterator item;
  LPARAM selected = 0;
  LPARAM focused  = 0;

  RESULTDATAITEM data;

  if (bCacheValid)
  {
    memset(&data, 0, sizeof(data));
    data.nIndex = -1; 
    data.nState = LVIS_SELECTED;
    data.mask   = RDI_STATE;

    if (S_OK == ipResultData->GetNextItem(&data) && data.nIndex != -1 )
    {
      selected = data.lParam;
    }

    memset(&data, 0, sizeof(data));
    data.nIndex = -1;
    data.nState = LVIS_FOCUSED;
    data.mask   = RDI_STATE;

    if (S_OK == ipResultData->GetNextItem(&data) && data.nIndex != -1)
    {
      focused = data.lParam;
    }
  }

  ipResultData->DeleteAllRsltItems();

  memset(&data, 0, sizeof(data));
  data.mask = RDI_STR | RDI_IMAGE | RDI_PARAM | RDI_STATE;
  data.bScopeItem = FALSE;
  //data.itemID;
  data.nIndex = 0;
  data.nCol = 0;
  data.str = (LPOLESTR)MMC_CALLBACK;

  data.nState = 0;

  data.iIndent = 0; //reserved

  HRESULT hr = S_OK;
  for (list<PCNameRule*>::iterator i = Cache.begin(); i != Cache.end(); ++i)
  {
    data.lParam = reinterpret_cast<LPARAM>(*i);

    switch((*i)->matchType)
    {
    case MATCH_PGM:
      data.nImage = ALIASRULES_IMAGE;
      break;
    case MATCH_DIR:
      data.nImage = ALIASRULES_IMAGE;
      break;
    case MATCH_ANY:
      data.nImage = ALIASRULES_IMAGE;
      break;
    default:
      ASSERT(FALSE);
      data.nImage = ITEMIMAGE_ERROR;
      break;
    }

    data.nState = 0;

    if (data.lParam == selected)
      data.nState |= LVIS_SELECTED;
    if (data.lParam == focused)
      data.nState |= LVIS_FOCUSED;

    hr = ipResultData->InsertItem(&data);
    if (hr != S_OK)
      break;
  }

  return hr;
}

void CNameRuleFolder::ClearCache()
{
  Cache.clear();

  for (list<PCNameRule*>::iterator chunck = MemBlocks.begin(); chunck != MemBlocks.end(); ++chunck)
  {
    delete [] (*chunck);
  }
  MemBlocks.clear();
}

BOOL CNameRuleFolder::RefreshCache()
{
  PCINT32  res = 0;
  PCINT32  nFirst = 0;
  PCULONG32 err = 0;

  const int MINIMUM_ALLOCATION = min((COM_BUFFER_SIZE/sizeof(PCNameRule)), 100);

  ClearCache();

  PCid hID = GetPCid();
  if (!hID)
  {
    ReportPCError();
    return false;
  }

  do
  {
    PCNameRule *ptr = new PCNameRule[MINIMUM_ALLOCATION];

    if (!ptr)
    {
      err = ERROR_OUTOFMEMORY;
      break;
    }

    res = PCGetNameRules( hID, ptr, MINIMUM_ALLOCATION * sizeof(PCNameRule), nFirst, &nUpdateCtr);
    if (res < 0 )
    {
      err = GetLastPCError();
      delete [] ptr;
      break;
    }
    
    if (res > 0)
    {
      MemBlocks.push_front(ptr);
      for (INT32 i = 0; i < res; i++)
      {
        Cache.insert(Cache.end(), ptr);
        ptr++;
        nFirst++;
      }
    }
  } while (res > 0 && PCERROR_MORE_DATA == GetLastPCError() );

  if (err)
    ReportPCError();

  return err == 0;
}

HRESULT CNameRuleFolder::AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed )
{
  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    *pInsertionAllowed ^= CCM_INSERTIONALLOWED_VIEW;

  return S_OK;
}

HRESULT CNameRuleFolder::AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed, LPARAM Cookie)
{

  HRESULT hr = S_OK;

  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    *pInsertionAllowed ^= CCM_INSERTIONALLOWED_VIEW;

  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
  {
    list<PCNameRule*>::iterator item;
    item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCNameRule*>(Cookie) );
    if (item == Cache.end())
    {
      ASSERT(FALSE); // multiple view issue?
      return E_UNEXPECTED;
    }

    bool MoveUpAllowed = false;
    bool MoveDownAllowed = false;
    
    if ( Cache.size() > 2 )
    {
      if (item != Cache.begin() && item != --(Cache.end()) ) // not first and not last
        MoveUpAllowed = true;
      if (item != --(Cache.end()) && item != --(--(Cache.end())) ) // not last and not second to last
        MoveDownAllowed = true;
    }

    CONTEXTMENUITEM m = { 0 };

    ITEM_STR name;
    ITEM_STR status;

    for (const CONTEXTMENUITEMBYID *M = ResultsTopMenuItems; M->lCommandID; M++)
    {
      m.strName           = const_cast<TCHAR *>(LoadStringHelper(name,   M->strNameID));
      m.strStatusBarText  = const_cast<TCHAR *>(LoadStringHelper(status, M->strStatusBarTextID));
      m.lCommandID        = M->lCommandID;
      m.lInsertionPointID = M->lInsertionPointID;
      //m.fSpecialFlags     = 0;		// currently always 0, initialized to 0

      if (m.lCommandID == ID_NRULE_INSERT || m.lCommandID == ID_NRULE_EDIT)
        m.fFlags = MF_ENABLED;
      else if (m.lCommandID == ID_NRULE_MOVEUP && MoveUpAllowed)
        m.fFlags = MF_ENABLED;
      else if (m.lCommandID == ID_NRULE_MOVEDOWN && MoveDownAllowed)
        m.fFlags = MF_ENABLED;
      else
        m.fFlags = MF_GRAYED;

      hr = piCallback->AddItem(&m);

      if (FAILED(hr))
        break;
    }
  }
  return hr;
}

HRESULT CNameRuleFolder::OnHelpCmd(IDisplayHelp *ipDisplayHelp)
{
  if (!ipDisplayHelp)
    return E_UNEXPECTED;

  ipDisplayHelp->ShowTopic(const_cast<TCHAR *>(HELP_ru_alias));

  return S_OK;
}

HRESULT CNameRuleFolder::OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb )
{
  ASSERT(bScope);

  if ( bSelect )
  {
    VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE ) == S_OK);
    VERIFY( ipConsoleVerb->SetDefaultVerb( MMC_VERB_OPEN ) == S_OK );
  }

  return S_OK;
}

HRESULT CNameRuleFolder::OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie)
{
  ASSERT(!bScope);

  VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE ) == S_OK);

  if (bSelect && !bScope)  // incase the rules are changed again leave !bScope test
  {
    VERIFY( ipConsoleVerb->SetDefaultVerb( MMC_VERB_NONE ) == S_OK );                
    if (Cache.size() > 1 ) 
    {
      list<PCNameRule*>::iterator item;
      item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCNameRule*>(Cookie) );

      if (item != Cache.end() && ++item != Cache.end())
        VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE ) == S_OK);
    }
  }

  return S_OK;
}

HRESULT CNameRuleFolder::OnDblClick(IConsole2 *ipConsole2, LPARAM Cookie)
{
  return OnMenuCommand(ipConsole2, ID_NRULE_EDIT, Cookie);
}

HRESULT CNameRuleFolder::OnMenuCommand(IConsole2 *ipConsole2, long nCommandID )
{
  return E_UNEXPECTED;  // no naming rule folder commands
}

HRESULT CNameRuleFolder::OnMenuCommand(IConsole2 *ipConsole2, long nCommandID, LPARAM Cookie )
{
  HRESULT hr = S_FALSE;

  ASSERT(ipConsole2);
  if (!ipConsole2)
    return E_UNEXPECTED;

  PCNameRule *SelectedItem = reinterpret_cast<PCNameRule*>(Cookie);

  list<PCNameRule*>::iterator item;
  INT32 index;

  for (index = 0, item = Cache.begin(); item != Cache.end(); item ++, index++)
    if (*item == SelectedItem)
      break;

  if (item == Cache.end() )
    return E_UNEXPECTED;

  switch(nCommandID)
  {
    case ID_NRULE_EDIT:
      ATLTRACE(_T("Process Alias edit\n"));
      hr = OnEdit(ipConsole2, SelectedItem, index, ( (UINT) 1 + index == Cache.size()) );
      break;
    case ID_NRULE_INSERT:
      {
        ATLTRACE(_T("NamingRule insert\n"));      
        OnInsertNameRule(ipConsole2, SelectedItem);
      }
      break;
    case ID_NRULE_MOVEUP:
      //first and last item in the list cannot be moved up...
      if (item != Cache.begin() && item != --(Cache.end()) )
      {
        if (PCSwapNameRules( GetPCid(), --index, nUpdateCtr) < 0)
          ReportPCError();
        else 
        {
          nUpdateCtr++;
          item = Cache.erase(item);
          --item;
          Cache.insert(item, SelectedItem);

          hr = SendViewChange(ipConsole2, NULL, PC_VIEW_REDRAWALL);
        }
      }

      ATLTRACE(_T("Name Rule Move up\n"));
      break;
    case ID_NRULE_MOVEDOWN:
      //last and 2nd to last item in the list cannot be moved down...
      {
      list<PCNameRule*>::iterator last = --(Cache.end());  // we know the list has at least one item so this is OK
      if (Cache.size() > 2 && item != last && item != --last) 
      {
        if (PCSwapNameRules( GetPCid(), index, nUpdateCtr) < 0)
          ReportPCError();
        else
        {
          nUpdateCtr++;
          item = Cache.erase(item);  // returns next         
          item++; 
          Cache.insert(item, SelectedItem); //insert inserts before the iterator 

          hr = SendViewChange(ipConsole2, NULL, PC_VIEW_REDRAWALL);
        }
      }
      }
      ATLTRACE(_T("Name Rule Move down\n"));
      break;
    default:
      break;
  }

  return hr;  
}

// return TRUE if an edit was actually made
HRESULT CNameRuleFolder::OnEdit(IConsole2 *ipConsole2, PCNameRule *item, INT32 index, BOOL bReadOnly) 
{
  PCNameRule NewInfo = { 0 };

  if (NameRuleDlg(NewInfo, item, bReadOnly) && 
      !bReadOnly && memcmp(item, &NewInfo, sizeof(PCNameRule)) )
  {
    if ( PCReplNameRule( GetPCid(), &NewInfo, index, nUpdateCtr ) < 0)
    {
      ReportPCError();
    }
    else
    {
      nUpdateCtr++;
      _tcscpy(item->matchString, NewInfo.matchString);
      _tcscpy(item->procName,    NewInfo.procName);
      _tcscpy(item->description, NewInfo.description);

      // just an update will not if the icon is changed
      //   we are(were) changing the icon so do an addition SetItem
      if (item->matchType != NewInfo.matchType ) 
      {
        item->matchType   = NewInfo.matchType;
        SendViewChange(ipConsole2, (INT_PTR) item, PC_VIEW_SETITEM);
      }
      else
      SendViewChange(ipConsole2, (INT_PTR) item, PC_VIEW_UPDATEITEM);
    }
  }
  return S_OK;
}


BOOL CNameRuleFolder::OnInsertNameRule(IConsole2 *ipConsole2, PCNameRule *InsertPoint)
{
  list<PCNameRule*>::iterator item;
  INT32 index;

  for (index = 0, item = Cache.begin(); item != Cache.end(); item ++, index++)
    if (*item == InsertPoint)
      break;

  if (item == Cache.end() )
    return FALSE;

  PCNameRule *ptr = new PCNameRule[1];

  if (!ptr)
    return FALSE;

  if (NameRuleDlg(*ptr))
  {
    if (PCAddNameRule(GetPCid(), ptr, index, nUpdateCtr) < 0)
    {
      ReportPCError();
    }
    else
    {
      nUpdateCtr++;
      MemBlocks.push_front(ptr);
      Cache.insert(item, ptr);
      SendViewChange(ipConsole2, (INT_PTR) ptr, PC_VIEW_ADDITEM);
      return TRUE;
    }
  }

  delete [] ptr;

  return FALSE;
}

HRESULT CNameRuleFolder::OnDelete(IConsole2 *ipConsole2, LPARAM Cookie)
{
  ASSERT(ipConsole2);
  if (!ipConsole2)
    return E_UNEXPECTED;

  list<PCNameRule*>::iterator item;
  INT32 index;

  for (index = 0, item = Cache.begin(); item != Cache.end(); item ++, index++)
    if (*item == reinterpret_cast<PCNameRule *>(Cookie))
      break;

  if (item == Cache.end() )
  {
    SendViewChange(ipConsole2, NULL, PC_VIEW_UPDATEALL);
    return E_UNEXPECTED;
  }

  if (PCDeleteNameRule(GetPCid(), index, nUpdateCtr) < 0)
  {
    ReportPCError();
    return E_UNEXPECTED;
  }
  nUpdateCtr++;
  Cache.erase(item);

  return SendViewChange(ipConsole2, Cookie, PC_VIEW_DELETEITEM);
}

HRESULT CNameRuleFolder::OnRefresh(IConsole2 *ipConsole2)
{
  RefreshCache();
  return SendViewChange(ipConsole2, NULL, PC_VIEW_UPDATEALL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\namerulepages.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    NameRulePages.cpp                                                        //
|                                                                                       //
|Description:  Implementation of name rule property pages                               //
|                                                                                       //
|Created:      Paul Skoglund 07-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#include "stdafx.h"


#include "NameRulePages.h"
#include "globals.h"
#include "HelpTopics.h"

#include "ManagementPages.h"
#include "ManagementRuleWizards.h"

BOOL NameRuleDlg(PCNameRule &out, PCNameRule *In /* = NULL */, BOOL bReadOnly /* = FALSE */ )
{
  PROPSHEETHEADER sheet;
	memset(&sheet, 0, sizeof(PROPSHEETHEADER));
  sheet.dwSize       = sizeof(PROPSHEETHEADER);
  sheet.dwFlags      = PSH_NOAPPLYNOW | PSH_USEICONID;
  sheet.hwndParent   = ::GetActiveWindow();
  sheet.hInstance    = _Module.GetResourceInstance();
  sheet.pszIcon      = MAKEINTRESOURCE(IDI_ALIASRULES);
	if (In)
		sheet.pszCaption = MAKEINTRESOURCE(IDS_NRULE_EDIT_PROPERTIES);
	else
		sheet.pszCaption = MAKEINTRESOURCE(IDS_NRULE_DEFINE_PROPERTIES);
  sheet.nPages       = 1;
  sheet.nStartPage   = 0;

  CNRulePage *pPage = new CNRulePage(NULL, &out, In); //the "title" becomes the tab header not the window title...
  if (!pPage)
    return -1;

	if (bReadOnly)
		pPage->SetReadOnly();

  HPROPSHEETPAGE hPages[1];

  hPages[0] = pPage->Create();

  sheet.phpage = &hPages[0];
  sheet.pfnCallback = NULL;

  INT_PTR id = PropertySheet(&sheet);

  // CNRulePage pointer pPage does not need to be freed, it has "autodelete", see the templated class it is devired from...

	if (id > 0)
		return TRUE;

	return FALSE;
}

CNRulePage::CNRulePage(int nTitle, PCNameRule *OutBuffer, PCNameRule *InData) 
    : CMySnapInPropertyPageImpl<CNRulePage>(nTitle), m_bName(_T("")), m_bMask(_T("")), m_bComment(_T("")), m_Type(MATCH_PGM)
{
  ASSERT(sizeof(PageFields.on) == sizeof(PageFields));

  PageFields.on = 0;
  m_bReadOnly = FALSE;

  m_OutBuffer = OutBuffer;
  if (m_OutBuffer)
    memset(m_OutBuffer, 0, sizeof(*m_OutBuffer));

	if (InData)
  {
	  m_bName    = InData->procName;
    m_bMask    = InData->matchString;
		m_bComment = InData->description;
    m_Type     = InData->matchType;
	}

	m_hBtnImage   = NULL;

	m_psp.dwFlags |= PSP_HASHELP;
}

CNRulePage::~CNRulePage()
{
	if (m_hBtnImage)
	  VERIFY(::DestroyIcon( (HICON) m_hBtnImage));

	if (m_hMenu)
		VERIFY( ::DestroyMenu(m_hMenu) );
}


LRESULT CNRulePage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	m_hBtnImage = ::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_RARROW), IMAGE_ICON, 6, 7, LR_DEFAULTCOLOR );
	ASSERT(m_hBtnImage);
	if (m_hBtnImage)
		SendDlgItemMessage(IDC_BTN_ALIAS, BM_SETIMAGE, IMAGE_ICON, (LPARAM) m_hBtnImage);
	m_hMenu = ::LoadMenu( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_ALIAS_MACRO) );
	ASSERT(m_hMenu);

  SendDlgItemMessage( IDC_NAME,      EM_SETLIMITTEXT,  PROC_NAME_LEN,        0);
  SendDlgItemMessage( IDC_MATCHMASK, EM_SETLIMITTEXT,  MATCH_STRING_LEN,     0);
	SendDlgItemMessage( IDC_COMMENT,   EM_SETLIMITTEXT,  NAME_DESCRIPTION_LEN, 0);

  if (m_bReadOnly)
  {
    UINT ids[] = { IDC_DIR, IDC_IMAGE, IDC_STRING, IDC_NAME, IDC_MATCHMASK, IDC_COMMENT, IDC_BTN_ALIAS, 0 };

    for (int i = 0; ids[i]; i++)
			DisableControl(ids[i]);
  }

	UpdateData(FALSE);

  return TRUE;  // Let the system set the focus
}

LRESULT CNRulePage::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HELPINFO *phi = (HELPINFO*) lParam;
	if (phi && phi->iContextType == HELPINFO_WINDOW)
	{
    IDCsToIDHs HelpMap[] = {{IDC_MATCHTYPE_FRAME, HELP_NRULE_MATCHTYPE_FRAME}, 
                            {IDC_DIR,             HELP_NRULE_DIR},
                            {IDC_IMAGE,           HELP_NRULE_IMAGE},
                            {IDC_STRING,          HELP_NRULE_STRING},
                            {IDC_MATCHMASK,       HELP_NRULE_MATCHMASK},
                            {IDC_COMMENT,         HELP_NRULE_COMMENT},
                            {IDC_NAME,            HELP_NRULE_NAME}, 
                            {IDC_BTN_ALIAS,       HELP_NRULE_BTN_ALIAS},
                            {0,0} };

    ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap);
    //ATLTRACE(_T("Call to WinHelp(hwnd=0x%lX) failed %lu"), phi->hItemHandle, GetLastError() );
    
		return TRUE;
	}
	bHandled = FALSE;
	return FALSE;
}

BOOL CNRulePage::OnHelp()
{
	MMCPropertyHelp(const_cast<TCHAR*>(HELP_ru_alias));
	return TRUE;
}

BOOL CNRulePage::Validate(BOOL bSave)
{
  CComBSTR    bNameStr;
  CComBSTR    bMaskStr;
  CComBSTR    bCommentStr;
  MATCH_TYPE  TempType;
 
  if (!GetDlgItemText( IDC_MATCHMASK, bMaskStr.m_str ) || !bMaskStr.Length() || bMaskStr.Length() > MATCH_STRING_LEN)
  {
    HWND hWndCtl = GetDlgItem(IDC_MATCHMASK);
		if(hWndCtl)
      ::SetFocus(hWndCtl);
    MessageBeep(MB_ICONASTERISK);
    return FALSE;
  }

  if (!GetDlgItemText( IDC_NAME, bNameStr.m_str ) || 
      !IsValidName(bNameStr, FALSE) )
  {
    HWND hWndCtl = GetDlgItem(IDC_NAME);
		if(hWndCtl)
      ::SetFocus(hWndCtl);

    ITEM_STR strOut;
    LoadStringHelper(strOut, IDS_JOBNAME_WARNING);
    MessageBox(strOut, NULL, MB_OK | MB_ICONWARNING);

		return FALSE;
  }

	// comment/description field can be left blank...
  if ( !GetDlgItemText(IDC_COMMENT, bCommentStr.m_str))
    bCommentStr = _T("");
  if (bCommentStr.Length() > NAME_DESCRIPTION_LEN)
  {
    HWND hWndCtl = GetDlgItem(IDC_COMMENT);
		if(hWndCtl)
      ::SetFocus(hWndCtl);
    MessageBeep(MB_ICONASTERISK);
    return FALSE;
  }

  if ( IsDlgButtonChecked(IDC_IMAGE) )
    TempType = MATCH_PGM;
  else if ( IsDlgButtonChecked(IDC_DIR) )
    TempType = MATCH_DIR;
  else if ( IsDlgButtonChecked(IDC_STRING) )
    TempType = MATCH_ANY;
  else
	{
    MessageBeep(MB_ICONASTERISK);
    return FALSE;
	}

	if (bSave)
	{
    if (m_OutBuffer)
    {
      _tcscpy(m_OutBuffer->procName,    bNameStr);
      _tcscpy(m_OutBuffer->matchString, bMaskStr);
		  _tcscpy(m_OutBuffer->description, bCommentStr);     
      m_OutBuffer->matchType = TempType;
    }
	}
  return TRUE;
}
BOOL CNRulePage::UpdateData(BOOL bSaveAndValidate)
{

  if (bSaveAndValidate)
  {
		return Validate(TRUE);
  }
  else
  {
    ASSERT(IDC_DIR + 1 == IDC_IMAGE && IDC_IMAGE + 1 == IDC_STRING);

		VERIFY(SetDlgItemText( IDC_NAME,        m_bName.m_str    ));
		VERIFY(SetDlgItemText( IDC_MATCHMASK,   m_bMask.m_str    ));
		VERIFY(SetDlgItemText( IDC_COMMENT,     m_bComment.m_str ));
		CheckRadioButton(IDC_DIR, IDC_STRING, MatchTypeToID(m_Type) );

    // save a copy to output buffer, if the page is readonly the output
    // will be the same as the initialzed values
    if (m_OutBuffer)
    {
      _tcscpy(m_OutBuffer->procName,    m_bName);
      _tcscpy(m_OutBuffer->matchString, m_bMask);
		  _tcscpy(m_OutBuffer->description, m_bComment);     
      m_OutBuffer->matchType = m_Type;
    }

    return TRUE;
  }
}

LRESULT CNRulePage::OnEditChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  CComBSTR bStr; // GetDlgItemText returns FALSE, and doesn't create an empty 
  switch (wID) {
  case IDC_NAME:
    if (! GetDlgItemText(wID, bStr.m_str) )
      bStr = _T("");
    PageFields.Fields.matchname = (0 != _tcscmp(bStr, m_bName));
    break;
  case IDC_MATCHMASK:      
    if (! GetDlgItemText(wID, bStr.m_str) )
       bStr = _T("");
    PageFields.Fields.matchmask = (0 != _tcscmp(bStr, m_bMask));
    break;
  case IDC_COMMENT:      
    if (! GetDlgItemText(wID, bStr.m_str) )
       bStr = _T("");
    PageFields.Fields.comment = (0 != _tcscmp(bStr, m_bComment));
    break;
  default:
    ASSERT(FALSE); //
    break;
  }

  SetModified(PageFields.on);
  
  bHandled = FALSE;
  return 0;
}

LRESULT CNRulePage::OnAliasMacro(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wNotifyCode == BN_CLICKED && wID == IDC_BTN_ALIAS)
  {
		HMENU hSubMenu;

		if (m_hMenu && (hSubMenu = GetSubMenu(m_hMenu, 0)) )
		{
			CComBSTR bStrName;

  		if (!GetDlgItemText( IDC_NAME, bStrName.m_str ) )
					bStrName = _T("");

			MENUITEMINFO info = { 0 };
			info.cbSize = sizeof(info);
			info.fMask  = MIIM_STATE;
			info.fState = MFS_ENABLED;

			UINT nItems[] = {IDM_DIR, IDM_IMAGE, IDM_HIDE };

			// enable all items
			for (int i = 0; i < ARRAY_SIZE(nItems); i++)
			{
				VERIFY( SetMenuItemInfo(hSubMenu, nItems[i], FALSE, &info) );
			}

			// now disable selective options if not allowed...

			// if not a sub-dir match disable <d> macro...
			if ( !IsDlgButtonChecked(IDC_DIR) )  
			{
				info.fState = MFS_GRAYED;
				VERIFY( SetMenuItemInfo(hSubMenu, IDM_DIR, FALSE, &info) );
			}

			if ( _tcsstr(bStrName, COPY_PGM_NAME) )
			{
				info.fState = MFS_GRAYED;
				VERIFY( SetMenuItemInfo(hSubMenu, IDM_IMAGE, FALSE, &info) );
			}

			if ( _tcsstr(bStrName, HIDE_THIS_PROC) )
			{
				info.fState = MFS_GRAYED;
				VERIFY( SetMenuItemInfo(hSubMenu, IDM_HIDE, FALSE, &info) );
			}

			if ( _tcsstr(bStrName, COPY_DIR_NAME) )
			{
				info.fState = MFS_GRAYED;
				VERIFY( SetMenuItemInfo(hSubMenu, IDM_DIR, FALSE, &info) );
			}


			HWND hwndp = ::GetParent(m_hWnd);  // the property page is still a child window, so get it's parent...the sheet 
			
			RECT      rect      = { 0 };       // button's rect
			TPMPARAMS tpmparams = { 0 };       // use rect of assigned name edit control window

			tpmparams.cbSize = sizeof(tpmparams);

			VERIFY( ::GetWindowRect(GetDlgItem(IDC_BTN_ALIAS), &rect               ) );
			VERIFY( ::GetWindowRect(GetDlgItem(IDC_NAME),      &tpmparams.rcExclude) );
			
			TCHAR *txt = NULL;

			int mID = TrackPopupMenuEx(hSubMenu,
					                       TPM_LEFTALIGN | TPM_TOPALIGN | TPM_LEFTBUTTON | TPM_RETURNCMD | TPM_VERTICAL,  
																 rect.right, rect.top, hwndp, &tpmparams);

			if (mID == IDM_IMAGE)
				txt = COPY_PGM_NAME;
			else if (mID == IDM_HIDE)
				txt = HIDE_THIS_PROC;
			else if (mID == IDM_DIR)
				txt = COPY_DIR_NAME;

			if (txt)
				SendDlgItemMessage(IDC_NAME, EM_REPLACESEL, TRUE, (LPARAM) txt);

		}
  }

  bHandled = FALSE;
  return 0;
}

LRESULT CNRulePage::OnMaskTypeEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wNotifyCode == BN_CLICKED)
  {
    switch (wID) {
    case IDC_IMAGE:      
      PageFields.Fields.matchtype = (m_Type != MATCH_PGM);        
      break;
    case IDC_DIR:      
      PageFields.Fields.matchtype = (m_Type != MATCH_DIR);
      break;
    case IDC_STRING:      
      PageFields.Fields.matchtype = (m_Type != MATCH_ANY);
      break;
    default:
      PageFields.Fields.matchtype = 0;
      ASSERT(FALSE); //
      break;
    }
		SetModified(PageFields.on);  
	}

	if ( !IsDlgButtonChecked(IDC_DIR) )  
	{
		CComBSTR bStr;
		if ( GetDlgItemText(IDC_NAME, bStr.m_str) )
		{
			tstring tname(bStr.m_str);

			tstring::size_type sub = tname.find(COPY_DIR_NAME);

			if (sub != tstring::npos)
			{
				tname.erase(sub, _tcslen(COPY_DIR_NAME));
				SetDlgItemText(IDC_NAME, tname.c_str());
			}
		}
	}

  bHandled = FALSE;
  return 0;
}

BOOL CNRulePage::OnApply()
{
  if (m_bReadOnly || !PageFields.on)  
    return TRUE;

  if (m_OutBuffer)
  {    
    m_bName    = m_OutBuffer->procName;
    m_bMask    = m_OutBuffer->matchString;    
		m_bComment = m_OutBuffer->description;
    m_Type     = m_OutBuffer->matchType;

    PageFields.on = 0;
  }

  return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\managementpages.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    ManagementPages.cpp                                                      //
|                                                                                       //
|Description:  Implementation of Management Property pages                              //
|              Affinity, Priority, Workingset, Scheduling, Process Count                // 
|                                                                                       //
|Created:      Paul Skoglund 09-1998                                                    //
|                                                                                       //
|Notes:                                                                                 //
|  9/9/1999 Paul Skoglund                                                               //
|    On the up-down controls even though the controls are configured not to wrap        //
|    there appears to be a bug in the control that allows wrapping to occur if an       //
|    arrow is held down and is accelating.  The control appears to fails to accout      //
|    for acceleration when range checking.  Note the wizard dialogs are affected        //
|    by the same bug if a workaround is constructed.                                    //
|                                                                                       // 
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#include "stdafx.h"

#include "ManagementPages.h"

#if _MSC_VER >= 1200
#pragma warning( push )
#endif
#pragma warning( disable : 4800 ) //warning C4800: 'unsigned long' : forcing value to bool 'true' or 'false' (performance warning)

void SetMGMTFlag(PC_MGMT_FLAGS &flag, PCMgmtFlags bit, BOOL bOn)
{ 
  if (bOn) flag |= bit; 
  else flag &= ~bit; 
}

BOOL GetValue(TCHAR *const str, __int64 &value, __int64 &max);

BOOL GetValue(TCHAR *const str, __int64 &value, __int64 &max)
{
  TCHAR *pos = str;
  value = 0;

  while (*pos && *pos == _T('0') ) pos++;

  while (*pos)
  {
    if (value > (max/10)  ||
        (*pos - _T('0')) > (max - (10 * value))
       )
    {
      value = 0;
      return FALSE;
    }
    value = 10 * value + *pos - _T('0');
    pos++;
  }
  return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// some formating helper functions
//
LPCTSTR FormatMatchType( ITEM_STR strOut, const MATCH_TYPE matchType )
{
	switch (matchType)
  {        
		case MATCH_PGM:
			LoadStringHelper(strOut, IDS_MATCH_IMAGE);
			break;
		case MATCH_DIR:
			LoadStringHelper(strOut, IDS_MATCH_DIR);
			break;
		case MATCH_ANY:
			LoadStringHelper(strOut, IDS_MATCH_STRING);
			break;
		default:
			ASSERT(FALSE);
			LoadStringHelper(strOut, IDS_UNKNOWN);
		break;
	}
	return strOut;
}

LPCTSTR FormatAffinity(ITEM_STR str, const AFFINITY affinity)
{
  str[MAX_ITEM_LEN-1] = 0;
	_sntprintf(str, MAX_ITEM_LEN-1, _T("0x%I64X"), affinity);
	return str;
}

LPCTSTR FormatPriority(ITEM_STR str, const PRIORITY priority)
{
  if (priority == PCPrioNormal)
    LoadStringHelper(str, IDS_NORMAL);
	else if (priority == PCPrioRealTime)
    LoadStringHelper(str, IDS_REALTIME);
  else if (priority == PCPrioHigh)
    LoadStringHelper(str, IDS_HIGH);
  else if (priority == PCPrioAboveNormal)
    LoadStringHelper(str, IDS_ABOVE_NORMAL);
  else if (priority == PCPrioBelowNormal)
    LoadStringHelper(str, IDS_BELOW_NORMAL);
  else if (priority == PCPrioIdle)
    LoadStringHelper(str, IDS_LOW);
  else
    LoadStringHelper(str, IDS_UNKNOWN);

	return str;
}

LPCTSTR FormatSchedulingClass(ITEM_STR str, const SCHEDULING_CLASS schedClass)
{
  str[MAX_ITEM_LEN - 1] = 0;
	_sntprintf(str, MAX_ITEM_LEN - 1, _T("%u"), schedClass);
	return str;
}

LPCTSTR FormatProcCount(ITEM_STR str, const PROC_COUNT procCount)
{
  ASSERT(sizeof(PROC_COUNT) == sizeof(int));
  str[MAX_ITEM_LEN - 1] = 0;
	_sntprintf(str, MAX_ITEM_LEN - 1, _T("%u"), procCount);
	return str;
}

LPCTSTR FormatPCUINT32(ITEM_STR str, const PCUINT32 uInt)
{
  str[MAX_ITEM_LEN - 1] = 0;
	_sntprintf(str, MAX_ITEM_LEN - 1, _T("%u"), uInt);
	return str;
}

LPCTSTR FormatPCINT32(ITEM_STR str, const PCINT32 aInt)
{
  str[MAX_ITEM_LEN - 1] = 0;
	_sntprintf(str, MAX_ITEM_LEN - 1, _T("%d"), aInt);
	return str;
}

LPCTSTR FormatPCUINT64(ITEM_STR str, const PCUINT64 aUInt64)
{
  str[MAX_ITEM_LEN - 1] = 0;
	_sntprintf(str, MAX_ITEM_LEN - 1, _T("%I64u"), aUInt64);
	return str;
}

LPCTSTR FormatApplyFlag(ITEM_STR str, const BOOL applied)
{
  str[MAX_ITEM_LEN - 1] = 0;
	if (applied)
		LoadStringHelper(str, IDS_YES );
  else
    LoadStringHelper(str, IDS_NO  );
	return str;
}

LPCTSTR FormatMemory(ITEM_STR str, const MEMORY_VALUE memory_value)
{
  str[MAX_ITEM_LEN - 1] = 0;
  _sntprintf(str, MAX_ITEM_LEN - 1, _T("%I64u"), memory_value/1024 );
	return str;
}

LPCTSTR FormatTime(ITEM_STR str, const TIME_VALUE time)
{
  SYSTEMTIME systime, localsystime;
  int len;

  str[MAX_ITEM_LEN - 1] = 0;
  if ( FileTimeToSystemTime((FILETIME *) &time, &systime) &&
       SystemTimeToTzSpecificLocalTime(NULL, &systime, &localsystime) )
  {
    if (len = GetDateFormat( LOCALE_USER_DEFAULT, 0, &localsystime, NULL, str, MAX_ITEM_LEN - 1 ))
    {
      str[len - 1 ] = _T(' ');
      if (GetTimeFormat( LOCALE_USER_DEFAULT, 0, &localsystime, NULL, &str[len],  MAX_ITEM_LEN - len - 1))
      {
        return str;
      }
    }
  }
  str[0] = 0;
  return str;
}

LPCTSTR FormatTimeToms(ITEM_STR str, const TIME_VALUE time)
{
  str[MAX_ITEM_LEN - 1] = 0;
  _sntprintf(str, MAX_ITEM_LEN - 1, _T("%I64u"), time/10000 );
	return str;
}

LPCTSTR FormatCNSTime(ITEM_STR str, TIME_VALUE time)
{
  TIME_VALUE hours   = time / CNSperHour;

  time -= CNSperHour * hours;

  TIME_VALUE minutes = time / CNSperMinute;

  time -= CNSperMinute * minutes; 

  TIME_VALUE seconds = time / CNSperSec;

  time -= CNSperSec * seconds;

  str[MAX_ITEM_LEN - 1] = 0;

  _sntprintf(str, MAX_ITEM_LEN - 1, _T("%I64u:%.2I64u:%.2I64u.%.7I64u"), hours, minutes, seconds, time);

  int len = _tcslen(str);
  while (len && str[--len] == _T('0') ) //strip trailing 0's
    str[len] = 0;
  return str;
}

LPCTSTR FormatCPUTIMELimitAction(ITEM_STR str, BOOL bMsgOnLimit)
{
  str[MAX_ITEM_LEN - 1] = 0;
	if (bMsgOnLimit)
		LoadStringHelper(str, IDS_CPUTIMELIMT_ACTION_MSG );
  else
    LoadStringHelper(str, IDS_CPUTIMELIMT_ACTION_TERM );
	return str;
}

LPCTSTR FormatSheetTitle(CComBSTR &Title, const CComBSTR &item_name, const COMPUTER_CONNECTION_INFO &Target)
{	
	Title = item_name;
	
	CComBSTR bTemp;
	if (bTemp.LoadString(IDS_ON))
		Title.Append(bTemp);

	if (Target.bLocalComputer)
	{
		if (bTemp.LoadString(IDS_LOCAL_COMPUTER) )
			Title.Append(bTemp);
	}
	else
	{
		Title.Append(Target.RemoteComputer);
	}

	return Title.m_str;
}

///////////////////////////////////////////////////////////////////////////
// some dialog helper functions
//
int PriorityToID(PRIORITY p)
{
	ASSERT(IDC_REALTIME     == 1 + IDC_HIGH   && IDC_HIGH   == 1 + IDC_ABOVE_NORMAL && 
 			   IDC_ABOVE_NORMAL == 1 + IDC_NORMAL && IDC_NORMAL == 1 + IDC_BELOW_NORMAL && 
			   IDC_BELOW_NORMAL == 1 + IDC_LOW    );

  if (p == PCPrioRealTime)
    return IDC_REALTIME;
  else if (p == PCPrioHigh)
    return IDC_HIGH;
	else if (p == PCPrioAboveNormal)
		return IDC_ABOVE_NORMAL;
  else if (p == PCPrioNormal)
    return IDC_NORMAL;
	else if (p == PCPrioBelowNormal)
		return IDC_BELOW_NORMAL;
  else if (p == PCPrioIdle)
    return IDC_LOW;
  
  ASSERT(FALSE);

  return IDC_NORMAL;
}

PRIORITY IDToPriority(int id)
{
	ASSERT(IDC_REALTIME     == 1 + IDC_HIGH   && IDC_HIGH   == 1 + IDC_ABOVE_NORMAL && 
 			   IDC_ABOVE_NORMAL == 1 + IDC_NORMAL && IDC_NORMAL == 1 + IDC_BELOW_NORMAL && 
			   IDC_BELOW_NORMAL == 1 + IDC_LOW    );

  if (id == IDC_REALTIME)
    return PCPrioRealTime;
  else if (id == IDC_HIGH) 
    return PCPrioHigh;
	else if (id == IDC_ABOVE_NORMAL)
		return PCPrioAboveNormal;
  else if (id == IDC_NORMAL) 
    return PCPrioNormal;
	else if (id == IDC_BELOW_NORMAL)
		return PCPrioBelowNormal;
  else if (id == IDC_LOW)
    return PCPrioIdle;
  
  ASSERT(FALSE);

  return PCPrioNormal;
}

int MatchTypeToID(MATCH_TYPE matchType)
{
	ASSERT(IDC_DIR   + 1 == IDC_IMAGE && 
         IDC_IMAGE + 1 == IDC_STRING );

	if      (matchType == MATCH_PGM)
		return IDC_IMAGE;
	else if (matchType == MATCH_DIR)
		return IDC_DIR;
	else if (matchType == MATCH_ANY)
		return IDC_STRING;
	
  ASSERT(FALSE);
  return IDC_IMAGE;
}

BOOL ValidateTimeField(HWND hDlg, WORD wID, TIME_VALUE &newtime)
{
  TCHAR ValidChars[] = _T("0123456789.:");
  TCHAR Digits[]     = _T("0123456789");
  TCHAR StrBuffer[32];

  newtime = 0;

  StrBuffer[ARRAY_SIZE(StrBuffer) - 1 ] = 0;
  
	LRESULT pos = SendDlgItemMessage(hDlg, wID, WM_GETTEXT, ARRAY_SIZE(StrBuffer)-1, (LPARAM) &StrBuffer);
	if (pos > 0 )
  {
    if (pos != (int) _tcsspn(&StrBuffer[0], &ValidChars[0]) )
      return FALSE;

    __int64 cns     = 0;    
    __int64 seconds = 0;
    __int64 minutes = 0;
    __int64 hours   = 0;

    TCHAR *dot = _tcsrchr(&StrBuffer[0], _T('.'));
    if (dot) // convert tenths of second to CNS
    {
      *dot = 0;
      dot++;
      unsigned int len = _tcslen(dot);
      if (len > 7 || len != _tcsspn(dot, Digits) )
        return FALSE;
      cns = _ttoi64(dot);
      for(unsigned int x = 0; cns && x < (7 - len); x++)
        cns *= 10;
    }

    struct {
      __int64 *val;
      __int64  max;
    } fields [] = { 
      {&seconds, MAXLONGLONG/CNSperSec   }, 
      {&minutes, MAXLONGLONG/CNSperMinute}, 
      {&hours,   MAXLONGLONG/CNSperHour  }
    };

    for (int i = 0; i < ARRAY_SIZE(fields); i++)
    {
      dot = _tcsrchr(&StrBuffer[0], _T(':'));
      if (!dot)
      {
        dot = &StrBuffer[0];
      }
      else    
      {
        *dot = 0;
        dot++;
      }
      if (_tcslen(dot) != _tcsspn(dot, Digits))
        return FALSE;
      if ( !GetValue(dot, *(fields[i].val), fields[i].max) )
        return FALSE;

      if (dot == &StrBuffer[0])
        break;
    }

    newtime  = cns;
    if ( (CNSperSec * seconds) <= (MAXLONGLONG - newtime) )
    {
      newtime += CNSperSec * seconds;
      if ( (CNSperMinute * minutes) <= (MAXLONGLONG - newtime) )
      {
        newtime += CNSperMinute * minutes;
        if (CNSperHour * hours <= (MAXLONGLONG - newtime) )
        {
          newtime += CNSperHour * hours;
          return TRUE;
        }
      }
    }
  }
  newtime = 0;
  return FALSE;
}



///////////////////////////////////////////////////////////////////////////
//  Affinity Management Page Implementation

CMGMTAffinityPage::CMGMTAffinityPage(int nTitle, CProcDetailContainer *pContainer, AFFINITY ProcessorMask) :
                   CMySnapInPropertyPageImpl<CMGMTAffinityPage>(nTitle), 
                   m_PageType(PROCESS_PAGE), m_pProcContainer(pContainer), m_pJobContainer(NULL),
                   m_ProcessorMask(ProcessorMask)
{
  m_pProcContainer->AddRef();
  Initialize();
}


CMGMTAffinityPage::CMGMTAffinityPage(int nTitle, CJobDetailContainer *pContainer, AFFINITY ProcessorMask) :
                   CMySnapInPropertyPageImpl<CMGMTAffinityPage>(nTitle),
                   m_PageType(JOB_PAGE), m_pProcContainer(NULL), m_pJobContainer(pContainer),
                   m_ProcessorMask(ProcessorMask)
{
  m_pJobContainer->AddRef();
  Initialize();
}

void CMGMTAffinityPage::Initialize()
{
  ASSERT(sizeof(PageFields.on) == sizeof(PageFields));

  PageFields.on = 0;
  m_bReadOnly = FALSE;

  m_affinitychk = FALSE;
  m_affinity = 0;

  m_hIconImage = NULL;
	m_psp.dwFlags |= PSP_HASHELP;
}

CMGMTAffinityPage::~CMGMTAffinityPage()
{
	if (m_PageType == PROCESS_PAGE)
    m_pProcContainer->Release();
  else if (m_PageType == JOB_PAGE)
    m_pJobContainer->Release();

	if (m_hIconImage)
	  VERIFY(::DestroyIcon( (HICON) m_hIconImage));
}


LRESULT CMGMTAffinityPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	CComBSTR bStr;
	int PromptID;
	if (m_PageType == PROCESS_PAGE)
  {
  	m_hIconImage = ::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_PROCESSES), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR );
		PromptID = IDS_AFFINITY_JOBWARNING;
  }
  else
  {
  	m_hIconImage = ::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_JOBS), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR );	  
	  PromptID = IDS_AFFINITY_NOJOBWARNING;
  }

  ASSERT(m_hIconImage);
  if (m_hIconImage)
    SendDlgItemMessage(IDC_PAGE_ICON, STM_SETICON, (WPARAM) m_hIconImage, 0);

	if (bStr.LoadString(PromptID))
		VERIFY(SetDlgItemText(IDC_AFFINITY_PROMPT, bStr.m_str));

  UpdateData(FALSE);

  bHandled = FALSE;
  return TRUE;  // Let the system set the focus
}

LRESULT CMGMTAffinityPage::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HELPINFO *phi = (HELPINFO*) lParam;
	if (phi && phi->iContextType == HELPINFO_WINDOW)
	{
    if (phi->iCtrlId > IDC_AFFINITY1 && phi->iCtrlId < IDC_AFFINITY64)
    {
      phi->iCtrlId     = IDC_AFFINITY1;
      phi->hItemHandle = GetDlgItem(phi->iCtrlId);
    }
    if (m_pJobContainer)
    {
      IDCsToIDHs HelpMap[] = {{IDC_AFFINITY_FRAME, HELP_GRP_AFFINITY_FRAME }, 
                              {IDC_AFFINITY_CHK,   HELP_GRP_AFFINITY_APPLY }, 
                              {IDC_AFFINITY1,      HELP_GRP_AFFINITY},
                              {IDC_AFFINITY64,     HELP_GRP_AFFINITY},
                              {0,0} };

      ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap);
    } 
    else
    {
      IDCsToIDHs HelpMap[] = {{IDC_AFFINITY_FRAME, HELP_PROC_AFFINITY_FRAME }, 
                              {IDC_AFFINITY_CHK,   HELP_PROC_AFFINITY_APPLY }, 
                              {IDC_AFFINITY1,      HELP_PROC_AFFINITY},
                              {IDC_AFFINITY64,     HELP_PROC_AFFINITY},
                              {0,0} };

      ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap);
    }
		return TRUE;
	}
	bHandled = FALSE;
	return FALSE;
}

BOOL CMGMTAffinityPage::OnHelp()
{
	MMCPropertyHelp(const_cast<TCHAR*>(HELP_ru_affinity));
	return TRUE;
}


BOOL CMGMTAffinityPage::Validate(BOOL bSave /* = FALSE */)
{
  AFFINITY affinity = 0;
  bool affinitychk = (BST_CHECKED == IsDlgButtonChecked(IDC_AFFINITY_CHK));

  for (int i = IDC_AFFINITY1; i <= IDC_AFFINITY64; i++)
  {
    if ( BST_UNCHECKED != IsDlgButtonChecked(i) )
      affinity |= (ProcessorBit << (i - IDC_AFFINITY1)); 
  }

  // warn the user if they make changes but have an apply affinity rule without
  // referencing at least one available processor
  if (affinitychk && !(affinity & m_ProcessorMask) && PageFields.on)
  {
    ITEM_STR strOut;
    LoadStringHelper(strOut, IDS_AFFINITY_WARNING);
    if (IDYES != MessageBox(strOut, NULL, MB_YESNO | MB_ICONQUESTION))
      return FALSE;
  }

	if (bSave)
	{
 	  if (m_PageType == PROCESS_PAGE)
    {
      m_pProcContainer->m_new.base.mgmtParms.affinity = affinity;
      SetMGMTFlag(m_pProcContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_APPLY_AFFINITY, affinitychk);
    }
    else if (m_PageType == JOB_PAGE)
    {
      m_pJobContainer->m_new.base.mgmtParms.affinity  = affinity;
      SetMGMTFlag(m_pJobContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_APPLY_AFFINITY, affinitychk);
    }
	}

  return TRUE;
}


BOOL CMGMTAffinityPage::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
		return Validate(TRUE);
  }
  else
  {
    ASSERT(IDC_AFFINITY1 + 63 == IDC_AFFINITY64);

    for(int i = IDC_AFFINITY1; i <= IDC_AFFINITY64; i++)
    {
      if (m_affinity & (ProcessorBit << (i - IDC_AFFINITY1) ) )
      { 
        if (m_ProcessorMask & (ProcessorBit << (i - IDC_AFFINITY1)))
          CheckDlgButton(i, BST_CHECKED);
        else
          CheckDlgButton(i, BST_INDETERMINATE);
      }
      else
        CheckDlgButton(i, BST_UNCHECKED);
    }

    CheckDlgButton(IDC_AFFINITY_CHK, m_affinitychk ? BST_CHECKED : BST_UNCHECKED);

    ApplyControlEnableRules(FALSE);

    return TRUE;
  }
}

void CMGMTAffinityPage::ApplyControlEnableRules(BOOL bForceDisable)
{
  BOOL bEnable;
  if (m_bReadOnly || !m_affinitychk || bForceDisable)
    bEnable = FALSE;
  else 
    bEnable = TRUE;
  
  for (int i = IDC_AFFINITY1; i <= IDC_AFFINITY64; i++)
    ::EnableWindow(GetDlgItem(i), bEnable);
  
  ::EnableWindow(GetDlgItem(IDC_AFFINITY_CHK), !(m_bReadOnly || bForceDisable));
}


BOOL CMGMTAffinityPage::OnSetActive()
{
  if ( m_PageType == PROCESS_PAGE )
  {
    if (m_pProcContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP)
      ApplyControlEnableRules(TRUE);
    else
      ApplyControlEnableRules(FALSE);
  }
  return TRUE;
}

LRESULT CMGMTAffinityPage::OnAffinityEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wNotifyCode == BN_CLICKED)
  {
    ASSERT(wID >= IDC_AFFINITY1 && wID <= IDC_AFFINITY64);

    int bit = wID - IDC_AFFINITY1;
    UINT btnState = IsDlgButtonChecked(wID);
    if (btnState == BST_UNCHECKED)
    {
      if ( m_ProcessorMask & (ProcessorBit << bit))
        CheckDlgButton(wID, BST_CHECKED);
      else
        CheckDlgButton(wID, BST_INDETERMINATE);
    }
    else
    {
      CheckDlgButton(wID, BST_UNCHECKED);
    }

    AFFINITY affinity = 0;
    for ( int i = IDC_AFFINITY1; i<= IDC_AFFINITY64; i++)
    {
      if ( BST_UNCHECKED != IsDlgButtonChecked(i) )
        affinity |= (ProcessorBit << (i - IDC_AFFINITY1)); 
    }

    PageFields.Fields.affinity = (m_affinity != affinity);

    SetModified(PageFields.on);
  }

  bHandled = FALSE;
  return 0;
}

LRESULT CMGMTAffinityPage::OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_AFFINITY_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_AFFINITY_CHK));
    PageFields.Fields.affinitychk = (m_affinitychk != checked);

    for (int i = IDC_AFFINITY1; i <= IDC_AFFINITY64; i++)
      ::EnableWindow(GetDlgItem(i), checked);

    SetModified(PageFields.on);
  }

  bHandled = FALSE;
  return 0;
}

BOOL CMGMTAffinityPage::OnApply()
{
  if (m_bReadOnly || !PageFields.on)  
    return TRUE;

  if ( (m_PageType == PROCESS_PAGE && m_pProcContainer->Apply(GetParent())) ||
       (m_PageType == JOB_PAGE     &&  m_pJobContainer->Apply(GetParent())) )
  {
		PageFields.on = 0;
    if (m_PageType == PROCESS_PAGE)
    {
      m_affinity    = m_pProcContainer->m_new.base.mgmtParms.affinity;
      m_affinitychk = (m_pProcContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_APPLY_AFFINITY);
    }
    else if (m_PageType == JOB_PAGE)
    {
      m_affinity    = m_pJobContainer->m_new.base.mgmtParms.affinity;
      m_affinitychk = (m_pJobContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_APPLY_AFFINITY);
    }

    return TRUE; 
  }

  return FALSE;
}

///////////////////////////////////////////////////////////////////////////
//  Priority Management Page Implementation

CMGMTPriorityPage::CMGMTPriorityPage(int nTitle,  CProcDetailContainer  *pContainer) :
                   CMySnapInPropertyPageImpl<CMGMTPriorityPage>(nTitle), 
                   m_pProcContainer(pContainer), m_pJobContainer(NULL), m_PageType(PROCESS_PAGE)
{
  m_pProcContainer->AddRef();
  Initialize();
}

CMGMTPriorityPage::CMGMTPriorityPage(int nTitle,  CJobDetailContainer  *pContainer) :
                   CMySnapInPropertyPageImpl<CMGMTPriorityPage>(nTitle), 
                   m_pProcContainer(NULL), m_pJobContainer(pContainer), m_PageType(JOB_PAGE)
{
  m_pJobContainer->AddRef();
  Initialize();
}

void CMGMTPriorityPage::Initialize()
{
  ASSERT(sizeof(PageFields.on) == sizeof(PageFields));

  PageFields.on = 0;
  m_bReadOnly   = FALSE;

  m_prioritychk = FALSE;
  m_priority    = PCPrioNormal;

  m_hIconImage  = NULL;
	m_psp.dwFlags |= PSP_HASHELP;
}

CMGMTPriorityPage::~CMGMTPriorityPage()
{
  if (m_PageType == PROCESS_PAGE)
    m_pProcContainer->Release();
  else if (m_PageType == JOB_PAGE)
    m_pJobContainer->Release();

	if (m_hIconImage)
	  VERIFY(::DestroyIcon( (HICON) m_hIconImage));
}

LRESULT CMGMTPriorityPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	CComBSTR bStr;
	int PromptID;
	if (m_PageType == PROCESS_PAGE)
  {
    m_hIconImage = ::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_PROCESSES), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR );
	  ASSERT(m_hIconImage);
		PromptID = IDS_PRIORITY_JOBWARNING;
  }
  else
  {
   	m_hIconImage = ::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_JOBS), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR );
	  ASSERT(m_hIconImage);
	  PromptID = IDS_PRIORITY_NOJOBWARNING;
  }

  if (m_hIconImage)
    SendDlgItemMessage(IDC_PAGE_ICON, STM_SETICON, (WPARAM) m_hIconImage, 0);

	if (bStr.LoadString(PromptID))
		VERIFY(SetDlgItemText(IDC_PRIORITY_PROMPT, bStr.m_str));

  UpdateData(FALSE);
  bHandled = FALSE;
  return TRUE;  // Let the system set the focus
}

LRESULT CMGMTPriorityPage::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HELPINFO *phi = (HELPINFO*) lParam;
	if (phi && phi->iContextType == HELPINFO_WINDOW)
	{
    if (m_pJobContainer)
    {
      IDCsToIDHs HelpMap[] = {{IDC_PRIORITY_FRAME, HELP_GRP_PRIORITY_FRAME }, 
                              {IDC_PRIORITY_CHK,   HELP_GRP_PRIORITY_APPLY }, 
                              {IDC_REALTIME,       HELP_GRP_PRIORITY_REAL},
                              {IDC_HIGH,           HELP_GRP_PRIORITY_HIGH},
                              {IDC_ABOVE_NORMAL,   HELP_GRP_PRIORITY_ABOVENORMAL},
                              {IDC_NORMAL,         HELP_GRP_PRIORITY_NORMAL},
                              {IDC_BELOW_NORMAL,   HELP_GRP_PRIORITY_BELOWNORMAL},
                              {IDC_LOW,            HELP_GRP_PRIORITY_LOW},
                              {0,0} };

      ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap);
    }
    else
    {
      IDCsToIDHs HelpMap[] = {{IDC_PRIORITY_FRAME, HELP_PROC_PRIORITY_FRAME }, 
                              {IDC_PRIORITY_CHK,   HELP_PROC_PRIORITY_APPLY }, 
                              {IDC_REALTIME,       HELP_PROC_PRIORITY_REAL},
                              {IDC_HIGH,           HELP_PROC_PRIORITY_HIGH},
                              {IDC_ABOVE_NORMAL,   HELP_PROC_PRIORITY_ABOVENORMAL},
                              {IDC_NORMAL,         HELP_PROC_PRIORITY_NORMAL},
                              {IDC_BELOW_NORMAL,   HELP_PROC_PRIORITY_BELOWNORMAL},
                              {IDC_LOW,            HELP_PROC_PRIORITY_LOW},
                              {0,0} };

      ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap);
    }
		return TRUE;
	}
	bHandled = FALSE;
	return FALSE;
}

BOOL CMGMTPriorityPage::OnHelp()
{
	MMCPropertyHelp(const_cast<TCHAR*>(HELP_ru_priority));
	return TRUE;
}

BOOL CMGMTPriorityPage::Validate(BOOL bSave)
{
  PRIORITY p = 0;
  for ( int i = IDC_LOW; i <= IDC_REALTIME; i++)
  {
    if ( BST_CHECKED == IsDlgButtonChecked(i) )
      p += IDToPriority(i);
  }

  if (IDToPriority(PriorityToID(p)) != p) //not fool proof, but do we really need to check this? no
	{
		MessageBeep(MB_ICONASTERISK);
		return FALSE;
	}

	if (bSave)
	{
    if (m_PageType == PROCESS_PAGE)
    {
      m_pProcContainer->m_new.base.mgmtParms.priority = p;
      SetMGMTFlag(m_pProcContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_APPLY_PRIORITY, (BST_CHECKED == IsDlgButtonChecked(IDC_PRIORITY_CHK)));
    }
    else if (m_PageType == JOB_PAGE)
    {
      m_pJobContainer->m_new.base.mgmtParms.priority = p;
      SetMGMTFlag(m_pJobContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_APPLY_PRIORITY, (BST_CHECKED == IsDlgButtonChecked(IDC_PRIORITY_CHK)));
    }
	}

  return TRUE;
}

BOOL CMGMTPriorityPage::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
		return Validate(TRUE);
  }
  else
  {    
    CheckRadioButton(IDC_LOW, IDC_REALTIME, PriorityToID(m_priority));
    CheckDlgButton(IDC_PRIORITY_CHK, m_prioritychk ? BST_CHECKED : BST_UNCHECKED);

    ApplyControlEnableRules(FALSE);

    return TRUE;
  }
}

void CMGMTPriorityPage::ApplyControlEnableRules(BOOL bForceDisable)
{
  BOOL bEnable;
  if (m_bReadOnly || !m_prioritychk || bForceDisable)
    bEnable = FALSE;
  else 
    bEnable = TRUE;

  UINT ids[] = { IDC_REALTIME, IDC_HIGH, IDC_ABOVE_NORMAL, IDC_NORMAL, IDC_BELOW_NORMAL, IDC_LOW, 0 };
  for (int i = 0; ids[i]; i++)
    ::EnableWindow(GetDlgItem(ids[i]), bEnable);
  
  ::EnableWindow(GetDlgItem(IDC_PRIORITY_CHK), !(m_bReadOnly || bForceDisable));
}

BOOL CMGMTPriorityPage::OnSetActive()
{
  if ( m_PageType == PROCESS_PAGE )
  {
    if (m_pProcContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP)
      ApplyControlEnableRules(TRUE);
    else
      ApplyControlEnableRules(FALSE);
  }
  return TRUE;
}

LRESULT CMGMTPriorityPage::OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_PRIORITY_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_PRIORITY_CHK));
    PageFields.Fields.prioritychk = (m_prioritychk != checked);

    UINT ids[] = { IDC_REALTIME, IDC_HIGH, IDC_ABOVE_NORMAL, IDC_NORMAL, IDC_BELOW_NORMAL, IDC_LOW,0 };
    for (int i = 0; ids[i]; i++)
      ::EnableWindow(GetDlgItem(ids[i]), checked);

    SetModified(PageFields.on);
  }

  bHandled = FALSE;
  return 0;
}

LRESULT CMGMTPriorityPage::OnPriorityEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wNotifyCode == BN_CLICKED)
  {
    ASSERT(wID >= IDC_LOW && wID <= IDC_REALTIME );

    PRIORITY p = 0;
    for ( int i = IDC_LOW; i <= IDC_REALTIME; i++)
    {
      if ( BST_CHECKED == IsDlgButtonChecked(i) )
        p += IDToPriority(i);
    }

    PageFields.Fields.priority = (m_priority != p);

    SetModified(PageFields.on);
  }

  bHandled = FALSE;
  return 0;
}

BOOL CMGMTPriorityPage::OnApply()
{
  if (m_bReadOnly || !PageFields.on)  
    return TRUE;

  if ( (m_PageType == PROCESS_PAGE && m_pProcContainer->Apply(GetParent()) ) || 
       (m_PageType == JOB_PAGE     &&  m_pJobContainer->Apply(GetParent()) ) )
  {
    PageFields.on = 0;
    if (m_PageType == PROCESS_PAGE)
    {
      m_priority    = m_pProcContainer->m_new.base.mgmtParms.priority;
      m_prioritychk = m_pProcContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_APPLY_PRIORITY;
    }
    else if (m_PageType == JOB_PAGE)
    {
      m_priority    = m_pJobContainer->m_new.base.mgmtParms.priority;
      m_prioritychk = m_pJobContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_APPLY_PRIORITY;
    }
    return TRUE; 
  }

  return FALSE;
}


///////////////////////////////////////////////////////////////////////////
//  Scheduling Class Management Page Implementation

CMGMTSchedulingClassPage::CMGMTSchedulingClassPage(int nTitle, CJobDetailContainer *pContainer) 
    : CMySnapInPropertyPageImpl<CMGMTSchedulingClassPage>(nTitle),
    m_pJobContainer(pContainer)

{
  ASSERT(sizeof(PageFields.on) == sizeof(PageFields));

  PageFields.on = 0;
  m_bReadOnly   = FALSE;

  m_schedClasschk = FALSE;
  m_schedClass    = 5;

  m_psp.dwFlags |= PSP_HASHELP;
  m_pJobContainer->AddRef();
}

CMGMTSchedulingClassPage::~CMGMTSchedulingClassPage()
{
  m_pJobContainer->Release();
}


LRESULT CMGMTSchedulingClassPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UpdateData(FALSE);
  bHandled = FALSE;
  return TRUE;  // Let the system set the focus
}

LRESULT CMGMTSchedulingClassPage::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HELPINFO *phi = (HELPINFO*) lParam;
	if (phi && phi->iContextType == HELPINFO_WINDOW)
	{
    IDCsToIDHs HelpMap[] = {{IDC_SCHEDULING_FRAME, HELP_SCHEDULING_FRAME }, 
                            {IDC_SCHEDULING_CHK,   HELP_SCHEDULING_APPLY }, 
                            {IDC_SCLASS,           HELP_SCHEDULING_CLASS},
                            {IDC_SPIN,             HELP_SCHEDULING_CLASS_SPIN},
                            {0,0} };

    ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap);
    
		return TRUE;
	}
	bHandled = FALSE;
	return FALSE;
}

BOOL CMGMTSchedulingClassPage::OnHelp()
{
	MMCPropertyHelp(const_cast<TCHAR*>(HELP_ru_job_sch));
	return TRUE;
}

BOOL CMGMTSchedulingClassPage::Validate(BOOL bSave)
{
	LRESULT pos = SendDlgItemMessage(IDC_SPIN, UDM_GETPOS, 0, 0);
	if (0 == HIWORD(pos) && LOWORD(pos) >= 0 && LOWORD(pos) <= 9 )
	{
		if (bSave)
		{
      SetMGMTFlag(m_pJobContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_APPLY_SCHEDULING_CLASS, (BST_CHECKED == IsDlgButtonChecked(IDC_SCHEDULING_CHK)));
      m_pJobContainer->m_new.base.mgmtParms.schedClass = (SCHEDULING_CLASS) LOWORD(pos);
		}
		return TRUE;
  }

  HWND hWndCtl = GetDlgItem(IDC_SCLASS);
	if(hWndCtl)
    ::SetFocus(hWndCtl);
  MessageBeep(MB_ICONASTERISK);
  return FALSE;
}


BOOL CMGMTSchedulingClassPage::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
		return Validate(TRUE);
  }
  else
  {
		CheckDlgButton(IDC_SCHEDULING_CHK, m_schedClasschk ? BST_CHECKED : BST_UNCHECKED);

		SendDlgItemMessage(IDC_SPIN, UDM_SETPOS, 0, MAKELONG(m_schedClass, 0) );
		SendDlgItemMessage(IDC_SPIN, UDM_SETRANGE32, 0, 9);

    if (m_bReadOnly || !m_schedClasschk)
		{
      DisableControl(IDC_SCLASS);
			DisableControl(IDC_SPIN);
		}
    if (m_bReadOnly)
      DisableControl(IDC_SCHEDULING_CHK);

    return TRUE;
  }
	
}

LRESULT CMGMTSchedulingClassPage::OnEditChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_SCLASS)
	{
		PageFields.Fields.schedClass = FALSE;
		LRESULT pos = SendDlgItemMessage(IDC_SPIN, UDM_GETPOS, 0,0);
		if (0 == HIWORD(pos) && LOWORD(pos) >= 0 && LOWORD(pos) <= 9 )
			PageFields.Fields.schedClass = (m_schedClass != LOWORD(pos));
	}

  SetModified(PageFields.on);
  bHandled = FALSE;
  return 0;
}

LRESULT CMGMTSchedulingClassPage::OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_SCHEDULING_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_SCHEDULING_CHK));
    PageFields.Fields.schedClasschk = (m_schedClasschk != checked);

    ::EnableWindow(GetDlgItem(IDC_SCLASS), checked);
    ::EnableWindow(GetDlgItem(IDC_SPIN),   checked);

    SetModified(PageFields.on);
  }

  bHandled = FALSE;
  return 0;
}

BOOL CMGMTSchedulingClassPage::OnApply()
{
  if (m_bReadOnly || !PageFields.on) // read only, nothing modified
    return TRUE;

  if ( m_pJobContainer->Apply(GetParent()) )
	{
    PageFields.on = 0;
    m_schedClasschk = m_pJobContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_APPLY_SCHEDULING_CLASS;
    m_schedClass    = m_pJobContainer->m_new.base.mgmtParms.schedClass;
    return TRUE; 
	}

  return FALSE;
}

///////////////////////////////////////////////////////////////////////////
//  Memory Management Page Implementation

CMGMTMemoryPage::CMGMTMemoryPage(int nTitle, CProcDetailContainer *pContainer) : 
    CMySnapInPropertyPageImpl<CMGMTMemoryPage>(nTitle),
    m_pProcContainer(pContainer), m_pJobContainer(NULL)
{
  m_pProcContainer->AddRef();
  Initialize();
}

CMGMTMemoryPage::CMGMTMemoryPage(int nTitle, CJobDetailContainer *pContainer) : 
    CMySnapInPropertyPageImpl<CMGMTMemoryPage>(nTitle),
    m_pProcContainer(NULL), m_pJobContainer(pContainer)
{
  m_pJobContainer->AddRef();
  Initialize();
}

void CMGMTMemoryPage::Initialize()
{
  ASSERT(sizeof(PageFields.on) == sizeof(PageFields));

  PageFields.on = 0;
  m_bReadOnly   = FALSE;

  m_WSchk = FALSE;
  m_minWS = 0;
  m_maxWS = 0;

  m_procmemorylimitchk = FALSE;
  m_procmemorylimit    = 0;

  m_jobmemorylimitchk = FALSE;
  m_jobmemorylimit    = 0;

  m_hIconImage = NULL;
  m_psp.dwFlags |= PSP_HASHELP;
}

CMGMTMemoryPage::~CMGMTMemoryPage()
{
  if (m_pProcContainer)
    m_pProcContainer->Release();
  if (m_pJobContainer)
    m_pJobContainer->Release();

  if (m_hIconImage)
	  VERIFY(::DestroyIcon( (HICON) m_hIconImage));
}

LRESULT CMGMTMemoryPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  if (m_pProcContainer)
  {
  	m_hIconImage = ::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_PROCESSES), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR );
		//PromptID = IDS_AFFINITY_JOBWARNING;
  }
  else if (m_pJobContainer)
  {
  	m_hIconImage = ::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_JOBS), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR );
	  //PromptID = IDS_AFFINITY_NOJOBWARNING;
  }

	ASSERT(m_hIconImage);
  if (m_hIconImage)
    SendDlgItemMessage(IDC_PAGE_ICON, STM_SETICON, (WPARAM) m_hIconImage, 0);


  UpdateData(FALSE);
  bHandled = FALSE;
  return TRUE;  // Let the system set the focus
}

LRESULT CMGMTMemoryPage::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HELPINFO *phi = (HELPINFO*) lParam;
	if (phi && phi->iContextType == HELPINFO_WINDOW)
	{
    if (m_pJobContainer)
    {
      IDCsToIDHs HelpMap[]={{IDC_WORKINGSET_FRAME, HELP_GRP_WS_FRAME }, 
                            {IDC_WORKINGSET_CHK,   HELP_GRP_WS_APPLY }, 
                            {IDC_MINWS,            HELP_GRP_WS_MIN }, 
                            {IDC_MINWS_SPIN,       HELP_GRP_WS_MIN_SPIN},
                            {IDC_MAXWS,            HELP_GRP_WS_MAX},
                            {IDC_MAXWS_SPIN,       HELP_GRP_WS_MAX_SPIN },
                            {IDC_PROCMEM_FRM,      HELP_GRP_PROCCOM_FRAME }, 
                            {IDC_PROCMEMORY_CHK,   HELP_GRP_PROCCOM_APPLY }, 
                            {IDC_PROCMEMORY,       HELP_GRP_PROCCOM_MAX }, 
                            {IDC_PROC_SPIN,        HELP_GRP_PROCCOM_MAX_SPIN},
                            {IDC_JOBMEM_FRM,       HELP_GRP_GRPCOM_FRAME }, 
                            {IDC_JOBMEMORY_CHK,    HELP_GRP_GRPCOM_APPLY }, 
                            {IDC_JOBMEMORY,        HELP_GRP_GRPCOM_MAX }, 
                            {IDC_JOB_SPIN,         HELP_GRP_GRPCOM_MAX_SPIN},
                            {0,0} };

      ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap);
    }
    else
    {
      IDCsToIDHs HelpMap[]={{IDC_WORKINGSET_FRAME, HELP_PROC_WS_FRAME }, 
                            {IDC_WORKINGSET_CHK,   HELP_PROC_WS_APPLY }, 
                            {IDC_MINWS,            HELP_PROC_WS_MIN }, 
                            {IDC_MINWS_SPIN,       HELP_PROC_WS_MIN_SPIN},
                            {IDC_MAXWS,            HELP_PROC_WS_MAX},
                            {IDC_MAXWS_SPIN,       HELP_PROC_WS_MAX_SPIN },
                            {0,0} };

      ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap);
    }
		return TRUE;
	}
	bHandled = FALSE;
	return FALSE;
}

BOOL CMGMTMemoryPage::OnHelp()
{
	TCHAR *pTopic = const_cast<TCHAR*>(HELP_ru_workset);

  if (m_pJobContainer)
		pTopic = const_cast<TCHAR*>(HELP_ru_job_mem);

	MMCPropertyHelp(pTopic);
	return TRUE;
}

BOOL CMGMTMemoryPage::Validate(BOOL bSave)
{
  LONG_PTR         PosErr = 0;
  MEMORY_VALUE     minWS;
  MEMORY_VALUE     maxWS;
  MEMORY_VALUE     procmemorylimit;
  MEMORY_VALUE     jobmemorylimit;

  BOOL WSchk = (BST_CHECKED == IsDlgButtonChecked(IDC_WORKINGSET_CHK));

	minWS = SendDlgItemMessage(IDC_MINWS_SPIN, UDM_GETPOS32, 0, (LPARAM) &PosErr);
  if (PosErr || minWS > MAXLONG - 1 || (WSchk && minWS <= 0) )
	{
    HWND hWndCtl = GetDlgItem(IDC_MINWS);
	  if(hWndCtl)
      ::SetFocus(hWndCtl);
    ITEM_STR strOut;
    LoadStringHelper(strOut, IDS_WSMINMAX_WARNING);
    MessageBox(strOut, NULL, MB_OK | MB_ICONWARNING);
    return FALSE;
  }
	maxWS = SendDlgItemMessage(IDC_MAXWS_SPIN, UDM_GETPOS32, 0, (LPARAM) &PosErr);
	if (PosErr || maxWS > MAXLONG - 1 || (WSchk && minWS >= maxWS) )
	{  
    HWND hWndCtl = GetDlgItem(IDC_MAXWS);
	  if(hWndCtl)
      ::SetFocus(hWndCtl);
    ITEM_STR strOut;
    LoadStringHelper(strOut, IDS_WSMINMAX_WARNING);
    MessageBox(strOut, NULL, MB_OK | MB_ICONWARNING);
    return FALSE;
  }

  if (m_pJobContainer)
  {
	  procmemorylimit = SendDlgItemMessage(IDC_PROC_SPIN, UDM_GETPOS32, 0, (LPARAM) &PosErr);
	  if (PosErr || procmemorylimit > MAXLONG - 1 )
	  {  
      HWND hWndCtl = GetDlgItem(IDC_PROCMEMORY);
	    if(hWndCtl)
        ::SetFocus(hWndCtl);
      MessageBeep(MB_ICONASTERISK);
      return FALSE;
    }
	  jobmemorylimit = SendDlgItemMessage(IDC_JOB_SPIN, UDM_GETPOS32, 0, (LPARAM) &PosErr);
	  if (PosErr || jobmemorylimit > MAXLONG - 1 )
	  {  
      HWND hWndCtl = GetDlgItem(IDC_JOBMEMORY);
	    if(hWndCtl)
        ::SetFocus(hWndCtl);
      MessageBeep(MB_ICONASTERISK);
      return FALSE;
    }
  }

	if (bSave)
	{
    if (m_pProcContainer)
    {
      SetMGMTFlag(m_pProcContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_APPLY_WS_MINMAX, WSchk);
      m_pProcContainer->m_new.base.mgmtParms.minWS = minWS * 1024;
      m_pProcContainer->m_new.base.mgmtParms.maxWS = maxWS * 1024;
    }
    else if (m_pJobContainer)
    {
      SetMGMTFlag(m_pJobContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_APPLY_WS_MINMAX, WSchk);
      m_pJobContainer->m_new.base.mgmtParms.minWS = minWS * 1024;
      m_pJobContainer->m_new.base.mgmtParms.maxWS = maxWS * 1024;

      m_procmemorylimitchk = (BST_CHECKED == IsDlgButtonChecked(IDC_PROCMEMORY_CHK));
      m_procmemorylimit    = procmemorylimit * 1024;
      m_jobmemorylimitchk  = (BST_CHECKED == IsDlgButtonChecked(IDC_JOBMEMORY_CHK));
      m_jobmemorylimit     = jobmemorylimit * 1024;
      SetMGMTFlag(m_pJobContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_APPLY_PROC_MEMORY_LIMIT, (BST_CHECKED == IsDlgButtonChecked(IDC_PROCMEMORY_CHK)));
      m_pJobContainer->m_new.base.mgmtParms.procMemoryLimit = procmemorylimit * 1024;
      SetMGMTFlag(m_pJobContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_APPLY_JOB_MEMORY_LIMIT, (BST_CHECKED == IsDlgButtonChecked(IDC_JOBMEMORY_CHK)));
      m_pJobContainer->m_new.base.mgmtParms.jobMemoryLimit  = jobmemorylimit * 1024;
    }
	}
	return TRUE;
}


BOOL CMGMTMemoryPage::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
		return Validate(TRUE);
  }
  else
  {
    if ( m_minWS/1024           > (MAXLONG - 1) || 
         m_maxWS/1024           > (MAXLONG - 1) || 
         m_procmemorylimit/1024 > (MAXLONG - 1) || 
         m_jobmemorylimit/1024  > (MAXLONG - 1) )
      m_bReadOnly = TRUE;

    long minWSInK = (long) (m_minWS/1024);
    long maxWSInK = (long) (m_maxWS/1024);

		CheckDlgButton(IDC_WORKINGSET_CHK, m_WSchk ? BST_CHECKED : BST_UNCHECKED);
		SendDlgItemMessage(IDC_MINWS_SPIN, UDM_SETRANGE32, 0, MAXLONG - 1 );
    SendDlgItemMessage(IDC_MINWS_SPIN, UDM_SETPOS32,   0, minWSInK );    

 		SendDlgItemMessage(IDC_MAXWS_SPIN, UDM_SETRANGE32, 0, MAXLONG - 1);
    SendDlgItemMessage(IDC_MAXWS_SPIN, UDM_SETPOS32,   0, maxWSInK );

    if (m_pJobContainer)
    {      
      long ProcMemInK = (long) (m_procmemorylimit/1024);
      long JobMemInK  = (long) (m_jobmemorylimit/1024);

      CheckDlgButton(IDC_PROCMEMORY_CHK, m_procmemorylimitchk ? BST_CHECKED : BST_UNCHECKED);
 	    SendDlgItemMessage(IDC_PROC_SPIN, UDM_SETRANGE32, 0, MAXLONG - 1);
      SendDlgItemMessage(IDC_PROC_SPIN, UDM_SETPOS32,   0, ProcMemInK );

      CheckDlgButton(IDC_JOBMEMORY_CHK,  m_jobmemorylimitchk  ? BST_CHECKED : BST_UNCHECKED);
	    SendDlgItemMessage(IDC_JOB_SPIN, UDM_SETRANGE32, 0, MAXLONG - 1);
      SendDlgItemMessage(IDC_JOB_SPIN, UDM_SETPOS32,   0, JobMemInK );
    }

    if (m_pProcContainer)
    {
      UINT nIDs[] = { IDC_PROCMEM_FRM, IDC_PROCMEMORY_CHK, IDC_PROCMEM_LBL, IDC_PROCMEMORY, IDC_PROC_SPIN, IDC_JOBMEM_FRM, IDC_JOBMEMORY_CHK, IDC_JOBMEM_LBL, IDC_JOBMEMORY, IDC_JOB_SPIN };
      for (int i = 0; i < ARRAY_SIZE(nIDs); i++ )
      {
        HWND hWndCtl = GetDlgItem(nIDs[i]);
	      if(hWndCtl)
          ::ShowWindow(hWndCtl, SW_HIDE);
      }
    }

    ApplyControlEnableRules(FALSE);

    if (m_bReadOnly || !m_procmemorylimitchk)
			DisableControl(IDC_PROCMEMORY);

    if (m_bReadOnly || !m_jobmemorylimitchk)
			DisableControl(IDC_JOBMEMORY);

    if (m_bReadOnly)
		{
      DisableControl(IDC_PROCMEMORY_CHK);
      DisableControl(IDC_JOBMEMORY_CHK);
		}

    return TRUE;
  }	
}

void CMGMTMemoryPage::ApplyControlEnableRules(BOOL bForceDisable)
{
  BOOL bEnable;
  if (m_bReadOnly || !(BST_CHECKED == IsDlgButtonChecked(IDC_WORKINGSET_CHK)) || bForceDisable)
    bEnable = FALSE;
  else 
    bEnable = TRUE;

  UINT ids[] = { IDC_MINWS, IDC_MAXWS, IDC_MINWS_SPIN, IDC_MAXWS_SPIN };
  for (int i = 0; i < ARRAY_SIZE(ids); i++)
    ::EnableWindow(GetDlgItem(ids[i]), bEnable);
  
  ::EnableWindow(GetDlgItem(IDC_WORKINGSET_CHK), !(m_bReadOnly || bForceDisable));
}

BOOL CMGMTMemoryPage::OnSetActive()
{
  if ( m_pProcContainer )
  {
    if (m_pProcContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP)
      ApplyControlEnableRules(TRUE);
    else
      ApplyControlEnableRules(FALSE);
  }
  return TRUE;
}

LRESULT CMGMTMemoryPage::OnSpin(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
  if (idCtrl == IDC_MINWS_SPIN ||
      idCtrl == IDC_MAXWS_SPIN ||
      idCtrl == IDC_PROC_SPIN  ||
      idCtrl == IDC_JOB_SPIN )
	{
    NMUPDOWN * nmupdown = (NMUPDOWN *) pnmh;
    __int64 value = (__int64) nmupdown->iPos + 1024 * (__int64) nmupdown->iDelta;  
		if ( value <= MAXLONG - 1 )
      nmupdown->iDelta *= 1024;
	}
  bHandled = FALSE;
  return 0;
}


LRESULT CMGMTMemoryPage::OnEditChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  LONG_PTR PosErr = 0;
  LRESULT pos;

  if (wID == IDC_MINWS)
	{    
		PageFields.Fields.minWS = FALSE;
		pos = SendDlgItemMessage(IDC_MINWS_SPIN, UDM_GETPOS32, 0,(LPARAM) &PosErr);
		if (!PosErr && pos <= MAXLONG - 1)
			PageFields.Fields.minWS = (m_minWS != pos * 1024 );
    pos = SendDlgItemMessage(IDC_MINWS_SPIN, UDM_GETPOS32, 0, (LPARAM) &PosErr);
	}
  else if (wID == IDC_MAXWS)
	{
		PageFields.Fields.maxWS = FALSE;
		pos = SendDlgItemMessage(IDC_MAXWS_SPIN, UDM_GETPOS32, 0,(LPARAM) &PosErr);
		if (!PosErr && pos <= MAXLONG - 1 )
			PageFields.Fields.maxWS = (m_maxWS != pos * 1024);
	}
  else if (wID == IDC_PROCMEMORY)
	{
		PageFields.Fields.procmemorylimit = FALSE;
		pos = SendDlgItemMessage(IDC_PROC_SPIN, UDM_GETPOS32, 0,(LPARAM) &PosErr);
		if (!PosErr && pos <= MAXLONG - 1)
			PageFields.Fields.procmemorylimit = (m_procmemorylimit != pos * 1024);
	}
  else if (wID == IDC_JOBMEMORY)
	{
		PageFields.Fields.jobmemorylimit = FALSE;
		pos = SendDlgItemMessage(IDC_JOB_SPIN, UDM_GETPOS32, 0,(LPARAM) &PosErr);
		if (!PosErr && pos <= MAXLONG - 1)
			PageFields.Fields.jobmemorylimit = (m_jobmemorylimit != pos * 1024);
	}

  SetModified(PageFields.on);
  bHandled = FALSE;
  return 0;
}

LRESULT CMGMTMemoryPage::OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_WORKINGSET_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_WORKINGSET_CHK));
    PageFields.Fields.WSchk = (m_WSchk != checked);

    ::EnableWindow(GetDlgItem(IDC_MINWS),      checked);
    ::EnableWindow(GetDlgItem(IDC_MAXWS),      checked);
    ::EnableWindow(GetDlgItem(IDC_MINWS_SPIN), checked);
    ::EnableWindow(GetDlgItem(IDC_MAXWS_SPIN), checked);

    SetModified(PageFields.on);
  }
  else if (wID == IDC_PROCMEMORY_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_PROCMEMORY_CHK));
    PageFields.Fields.procmemorylimitchk = (m_procmemorylimitchk != checked);

    ::EnableWindow(GetDlgItem(IDC_PROCMEMORY), checked);
    ::EnableWindow(GetDlgItem(IDC_PROC_SPIN),  checked);

    SetModified(PageFields.on);
  }
  else if (wID == IDC_JOBMEMORY_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_JOBMEMORY_CHK));
    PageFields.Fields.jobmemorylimitchk = (m_jobmemorylimitchk != checked);

    ::EnableWindow(GetDlgItem(IDC_JOBMEMORY), checked);
    ::EnableWindow(GetDlgItem(IDC_JOB_SPIN),  checked);

    SetModified(PageFields.on);
  }

  bHandled = FALSE;
  return 0;
}

BOOL CMGMTMemoryPage::OnApply()
{    
  if (m_bReadOnly || !PageFields.on) // read only, nothing modified
    return TRUE;

  if ( (m_pProcContainer && m_pProcContainer->Apply(GetParent())) ||
       (m_pJobContainer  && m_pJobContainer->Apply( GetParent())) )
	{
    PageFields.on = 0;
    if (m_pProcContainer)
    {
      m_WSchk = m_pProcContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_APPLY_WS_MINMAX;
      m_minWS = m_pProcContainer->m_new.base.mgmtParms.minWS;
      m_maxWS = m_pProcContainer->m_new.base.mgmtParms.maxWS;
    }
    else if (m_pJobContainer)
    {
      m_WSchk = m_pJobContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_APPLY_WS_MINMAX;
      m_minWS = m_pJobContainer->m_new.base.mgmtParms.minWS;
      m_maxWS = m_pJobContainer->m_new.base.mgmtParms.maxWS;

      m_procmemorylimitchk = m_pJobContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_APPLY_PROC_MEMORY_LIMIT;
      m_procmemorylimit    = m_pJobContainer->m_new.base.mgmtParms.procMemoryLimit;
      m_jobmemorylimitchk  = m_pJobContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMORY_LIMIT;
      m_jobmemorylimit     = m_pJobContainer->m_new.base.mgmtParms.jobMemoryLimit;
    }
    return TRUE; 
	}

  return FALSE;
}

///////////////////////////////////////////////////////////////////////////
//  Time Limits Page Implementation

CMGMTTimePage::CMGMTTimePage(int nTitle, CJobDetailContainer *pContainer) :
    CMySnapInPropertyPageImpl<CMGMTTimePage>(nTitle), 
    m_pJobContainer(pContainer)
{
  ASSERT(sizeof(PageFields.on) == sizeof(PageFields));

  PageFields.on = 0;
  m_bReadOnly   = FALSE;

  m_procusertimechk = FALSE;
  m_procusertime    = 0;

  m_jobusertimechk = FALSE;
  m_jobmsgontimelimit = FALSE;
  m_jobusertime    = 0;

  m_psp.dwFlags |= PSP_HASHELP;
  m_pJobContainer->AddRef();
}

CMGMTTimePage::~CMGMTTimePage()
{
  m_pJobContainer->Release();
}

LRESULT CMGMTTimePage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UpdateData(FALSE);
  bHandled = FALSE;
  return TRUE;  // Let the system set the focus
}

LRESULT CMGMTTimePage::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HELPINFO *phi = (HELPINFO*) lParam;
	if (phi && phi->iContextType == HELPINFO_WINDOW)
	{
    IDCsToIDHs HelpMap[]={{IDC_PROCUSERTIME_FRAME, HELP_TIME_PROC_FRAME }, 
                          {IDC_PROCUSERTIME_CHK,   HELP_TIME_PROC_APPLY }, 
                          {IDC_PROCUSERTIME,       HELP_TIME_PROC_MAX }, 
                          {IDC_JOBUSERTIME_FRAME,  HELP_TIME_GRP_FRAME},
                          {IDC_JOBUSERTIME_CHK,    HELP_TIME_GRP_APPLY }, 
                          {IDC_JOBUSERTIME,        HELP_TIME_GRP_MAX },
                          {IDC_JOBTIMELIMIT_TERM,  HELP_TIME_GRP_TERMINATE }, 
                          {IDC_JOBTIMELIMIT_MSG,   HELP_TIME_GRP_LOG }, 
                          {0,0} };

    ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap); 
		return TRUE;
	}
	bHandled = FALSE;
	return FALSE;
}

BOOL CMGMTTimePage::OnHelp()
{
	MMCPropertyHelp(const_cast<TCHAR*>(HELP_ru_job_time));
	return TRUE;
}

BOOL CMGMTTimePage::Validate(BOOL bSave)
{
  TIME_VALUE procusertime;
  TIME_VALUE jobusertime;

  bool procusertimechk = (BST_CHECKED == IsDlgButtonChecked(IDC_PROCUSERTIME_CHK));
  bool jobusertimechk  = (BST_CHECKED == IsDlgButtonChecked(IDC_JOBUSERTIME_CHK));

	if ( !ValidateTimeField(m_hWnd, IDC_PROCUSERTIME, procusertime) || 
       (procusertimechk && procusertime < PC_MIN_TIME_LIMIT) )
	{  
    HWND hWndCtl = GetDlgItem(IDC_PROCUSERTIME);
	  if(hWndCtl)
      ::SetFocus(hWndCtl);
    MessageBeep(MB_ICONASTERISK);
   	CComBSTR bTemp;
  	if (bTemp.LoadString(IDS_TIMEENTRY))
      MessageBox(bTemp.m_str, NULL, MB_OK | MB_ICONWARNING);
    return FALSE;
  }
  if ( !ValidateTimeField(m_hWnd, IDC_JOBUSERTIME, jobusertime) || 
       (jobusertimechk && jobusertime < PC_MIN_TIME_LIMIT) )
	{  
    HWND hWndCtl = GetDlgItem(IDC_JOBUSERTIME);
	  if(hWndCtl)
      ::SetFocus(hWndCtl);
    MessageBeep(MB_ICONASTERISK);
   	CComBSTR bTemp;
  	if (bTemp.LoadString(IDS_TIMEENTRY))
      MessageBox(bTemp.m_str, NULL, MB_OK | MB_ICONWARNING);
    return FALSE;
  }

	if (bSave)
	{
    m_pJobContainer->m_new.base.mgmtParms.procTimeLimitCNS = procusertime;
    SetMGMTFlag(m_pJobContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_APPLY_PROC_TIME_LIMIT,     procusertimechk);

    m_pJobContainer->m_new.base.mgmtParms.jobTimeLimitCNS  = jobusertime;
    SetMGMTFlag(m_pJobContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_APPLY_JOB_TIME_LIMIT,      jobusertimechk);
    SetMGMTFlag(m_pJobContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_MSG_ON_JOB_TIME_LIMIT_HIT, (BST_CHECKED == IsDlgButtonChecked(IDC_JOBTIMELIMIT_MSG)));
	}
	return TRUE;
}


BOOL CMGMTTimePage::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
		return Validate(TRUE);
  }
  else
  {
    ITEM_STR str;

    CheckDlgButton(IDC_PROCUSERTIME_CHK, m_procusertimechk ? BST_CHECKED : BST_UNCHECKED);
    SetDlgItemText(IDC_PROCUSERTIME,     FormatCNSTime(str, m_procusertime));

    CheckDlgButton(IDC_JOBUSERTIME_CHK,  m_jobusertimechk  ? BST_CHECKED : BST_UNCHECKED);    
    SetDlgItemText(IDC_JOBUSERTIME,      FormatCNSTime(str, m_jobusertime));

    ASSERT(IDC_JOBTIMELIMIT_TERM + 1 == IDC_JOBTIMELIMIT_MSG);
    CheckRadioButton(IDC_JOBTIMELIMIT_TERM, IDC_JOBTIMELIMIT_MSG, m_jobmsgontimelimit ? IDC_JOBTIMELIMIT_MSG : IDC_JOBTIMELIMIT_TERM );

    if (m_bReadOnly || !m_procusertimechk)
			DisableControl(IDC_PROCUSERTIME);

    if (m_bReadOnly || !m_jobusertimechk)
    {
			DisableControl(IDC_JOBUSERTIME);
      DisableControl(IDC_JOBTIMELIMIT_TERM);
      DisableControl(IDC_JOBTIMELIMIT_MSG);
		}

    if (m_bReadOnly)
    {
      DisableControl(IDC_PROCUSERTIME_CHK);
      DisableControl(IDC_JOBUSERTIME_CHK);
    }

    return TRUE;
  }	
}

LRESULT CMGMTTimePage::OnEditChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

  TIME_VALUE time;

  if (wID == IDC_PROCUSERTIME)
	{
		PageFields.Fields.procusertime = FALSE;
    if ( ValidateTimeField(m_hWnd, wID, time) )
      PageFields.Fields.procusertime = (m_procusertime != time);
	}
  else if (wID == IDC_JOBUSERTIME)
	{
		PageFields.Fields.jobusertime = FALSE;
    if ( ValidateTimeField(m_hWnd, wID, time) )
      PageFields.Fields.jobusertime = (m_jobusertime != time);
	}

  SetModified(PageFields.on);

  bHandled = FALSE;
  return 0;
}

LRESULT CMGMTTimePage::OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_PROCUSERTIME_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_PROCUSERTIME_CHK));
    PageFields.Fields.procusertimechk = (m_procusertimechk != checked);
    ::EnableWindow(GetDlgItem(IDC_PROCUSERTIME), checked);

    SetModified(PageFields.on);
  }
  else if (wID == IDC_JOBUSERTIME_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_JOBUSERTIME_CHK));
    PageFields.Fields.jobusertimechk = (m_jobusertimechk != checked);
    ::EnableWindow(GetDlgItem(IDC_JOBUSERTIME),       checked);
    ::EnableWindow(GetDlgItem(IDC_JOBTIMELIMIT_TERM), checked);
    ::EnableWindow(GetDlgItem(IDC_JOBTIMELIMIT_MSG),  checked);

    SetModified(PageFields.on);
  }
  else if (wID == IDC_JOBTIMELIMIT_TERM)
  {
    bool checked = !(BST_CHECKED == IsDlgButtonChecked(IDC_JOBTIMELIMIT_TERM));
    PageFields.Fields.jobmsgontimelimit = (m_jobmsgontimelimit != checked);

    SetModified(PageFields.on);
  }
  else if (wID == IDC_JOBTIMELIMIT_MSG)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_JOBTIMELIMIT_MSG));
    PageFields.Fields.jobmsgontimelimit = (m_jobmsgontimelimit != checked);

    SetModified(PageFields.on);
  }

  bHandled = FALSE;
  return 0;
}

BOOL CMGMTTimePage::OnApply()
{    
  if (m_bReadOnly || !PageFields.on) // read only, nothing modified
    return TRUE;

  if (m_pJobContainer->Apply(GetParent()) )
	{
		PageFields.on = 0;

    m_procusertime      = m_pJobContainer->m_new.base.mgmtParms.procTimeLimitCNS;
    m_procusertimechk   = m_pJobContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_APPLY_PROC_TIME_LIMIT;

    m_jobusertime       = m_pJobContainer->m_new.base.mgmtParms.jobTimeLimitCNS;
    m_jobusertimechk    = m_pJobContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_TIME_LIMIT;
    m_jobmsgontimelimit = m_pJobContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_MSG_ON_JOB_TIME_LIMIT_HIT;

    return TRUE; 
	}

  return FALSE;
}

///////////////////////////////////////////////////////////////////////////
//  Advanced Page Implementation


CMGMTAdvancedPage::CMGMTAdvancedPage(int nTitle, CJobDetailContainer *pContainer) : 
    CMySnapInPropertyPageImpl<CMGMTAdvancedPage>(nTitle), 
    m_pJobContainer(pContainer)
{
  ASSERT(sizeof(PageFields.on) == sizeof(PageFields));

  PageFields.on = 0;
  m_bReadOnly = FALSE;

  m_endjob          = FALSE;
  m_unhandledexcept = FALSE;
  m_breakaway       = FALSE;
  m_silentbreakaway = FALSE;

  m_psp.dwFlags |= PSP_HASHELP;
  m_pJobContainer->AddRef();
}

CMGMTAdvancedPage::~CMGMTAdvancedPage()
{
  m_pJobContainer->Release();
}

LRESULT CMGMTAdvancedPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UpdateData(FALSE);

  bHandled = FALSE;

  // Setting focus when a property page does not work...

	return TRUE;  // Let the system set the focus
}

LRESULT CMGMTAdvancedPage::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HELPINFO *phi = (HELPINFO*) lParam;
	if (phi && phi->iContextType == HELPINFO_WINDOW)
	{
    IDCsToIDHs HelpMap[]={{IDC_ADV_FRAME,           HELP_ADV_FRAME }, 
                          {IDC_ENDJOB_CHK,          HELP_ADV_ENDGRP }, 
                          {IDC_UNHANDLEDEXCEPT_CHK, HELP_ADV_NODIEONEX }, 
                          {IDC_SILENTBREAKAWAY_CHK, HELP_ADV_SILENT_BREAKAWAY},
                          {IDC_BREAKAWAY_CHK,       HELP_ADV_BREAKAWAY_OK }, 
                          {0,0} };

    ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap); 
		return TRUE;
	}
	bHandled = FALSE;
	return FALSE;
}

BOOL CMGMTAdvancedPage::OnHelp()
{
	MMCPropertyHelp(const_cast<TCHAR*>(HELP_ru_job_adv));
	return TRUE;
}

BOOL CMGMTAdvancedPage::Validate(BOOL bSave)
{
  if (bSave)
	{
    SetMGMTFlag(m_pJobContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_END_JOB_WHEN_EMPTY,      (BST_CHECKED == IsDlgButtonChecked(IDC_ENDJOB_CHK)));
    SetMGMTFlag(m_pJobContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_SET_DIE_ON_UH_EXCEPTION, (BST_CHECKED == IsDlgButtonChecked(IDC_UNHANDLEDEXCEPT_CHK)));
    SetMGMTFlag(m_pJobContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_SET_PROC_BREAKAWAY_OK,   (BST_CHECKED == IsDlgButtonChecked(IDC_BREAKAWAY_CHK      )));
    SetMGMTFlag(m_pJobContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_SET_SILENT_BREAKAWAY,    (BST_CHECKED == IsDlgButtonChecked(IDC_SILENTBREAKAWAY_CHK)));
	}
  return TRUE;
}

BOOL CMGMTAdvancedPage::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
		return Validate(TRUE);
  }
  else
  {
    CheckDlgButton(IDC_ENDJOB_CHK,          m_endjob          ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(IDC_UNHANDLEDEXCEPT_CHK, m_unhandledexcept ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(IDC_BREAKAWAY_CHK,       m_breakaway       ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton(IDC_SILENTBREAKAWAY_CHK, m_silentbreakaway ? BST_CHECKED : BST_UNCHECKED);

    if (m_bReadOnly)
		{
      DisableControl(IDC_ENDJOB_CHK);
			DisableControl(IDC_UNHANDLEDEXCEPT_CHK);
      DisableControl(IDC_BREAKAWAY_CHK);
			DisableControl(IDC_SILENTBREAKAWAY_CHK);
		}

    return TRUE;
  }
}

LRESULT CMGMTAdvancedPage::OnChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_BREAKAWAY_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_BREAKAWAY_CHK));
    PageFields.Fields.breakaway = (m_breakaway != checked);

    SetModified(PageFields.on);
  }
  else if (wID == IDC_SILENTBREAKAWAY_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_SILENTBREAKAWAY_CHK));
    PageFields.Fields.silentbreakaway = (m_silentbreakaway != checked);

    SetModified(PageFields.on);
  }
  else if (wID == IDC_ENDJOB_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_ENDJOB_CHK));
    PageFields.Fields.endjob = (m_endjob != checked);

    SetModified(PageFields.on);
  }
  else if (wID == IDC_UNHANDLEDEXCEPT_CHK)
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_UNHANDLEDEXCEPT_CHK));
    PageFields.Fields.unhandledexcept = (m_unhandledexcept != checked);

    SetModified(PageFields.on);
  }

  bHandled = FALSE;
  return 0;
}

BOOL CMGMTAdvancedPage::OnApply()
{
  if (m_bReadOnly || !PageFields.on)  
    return TRUE;

  if (m_pJobContainer->Apply( GetParent() ))
	{
		PageFields.on = 0;

    m_endjob          = m_pJobContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_END_JOB_WHEN_EMPTY;
    m_unhandledexcept = m_pJobContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_SET_DIE_ON_UH_EXCEPTION;
    m_breakaway       = m_pJobContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_SET_PROC_BREAKAWAY_OK;
    m_silentbreakaway = m_pJobContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_SET_SILENT_BREAKAWAY;

    return TRUE; 
	}

  return FALSE;
}



#if _MSC_VER >= 1200
#pragma warning( pop )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\ppage.h ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:                                                                             //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|Created:      Paul Skoglund 07-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|    Based on code from ATL snapin wizard update for VC++ 6.0 - atlsnap.h
|      In this module class CSnapInPropertyPageImpl renamed to 
|      CMySnapInPropertyPageImpl to avoid name clash 
|    Modified to provide better support for Wizard style property pages...
|
|  1999 03 22 Paul Skoglund
|    Created CMySnapInPropertyWizardImpl template to use like CSnapInPropertyPageImpl
|      but specific for Wizard style pages.  The template forces declaration of 
|      Header Title resource ID and a SubHeader Title resource ID as used in the
|      PSH_WIZARD97 style.
|    Change to use Title as resource ID rather than string.
|
|=======================================================================================*/



#ifndef __PPAGE_H__
#define __PPAGE_H__

#ifndef ATLASSERT
#define ATLASSERT ASSERT
#endif

#include <mmc.h>
#include <commctrl.h>

#pragma comment(lib, "mmc.lib")
#pragma comment(lib, "comctl32.lib")

template <class T, bool bAutoDelete = true>
class ATL_NO_VTABLE CMySnapInPropertyPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CMySnapInPropertyPageImpl(int nTitle)
	{

		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = _Module.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

		if(nTitle != NULL)
		{
      m_psp.pszTitle = MAKEINTRESOURCE(nTitle);
      m_psp.dwFlags |= PSP_USETITLE;			
		}
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		ATLASSERT(hWnd == NULL);
		if(uMsg == PSPCB_CREATE)
		{
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}
		if (bAutoDelete && uMsg == PSPCB_RELEASE)
		{
			T* pPage = (T*)ppsp->lParam;
			delete pPage;
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		ATLASSERT(FALSE);
		return FALSE;
	}

// Operations
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		if(bChanged)
			::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
		else
			::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
	}

	typedef CMySnapInPropertyPageImpl< T, bAutoDelete > thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

// Message handler
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = (T*)this;
		LRESULT lResult = 0;
		// handle default
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
			lResult = !pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = !pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
			lResult = pT->OnHelp();
			break;
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	BOOL OnWizardBack()
	{
		return TRUE;
	}
	BOOL OnWizardNext()
	{
		return TRUE;
	}
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	BOOL OnHelp()
	{
		return TRUE;
	}

	void DisableControl(UINT id)
	{
		T* pT = dynamic_cast<T*>(this);

		if (!pT)
			return;

		HWND hWndCtl = pT->GetDlgItem(id);
		ASSERT(hWndCtl);
		if (hWndCtl)
			::EnableWindow(hWndCtl, FALSE);
	}
	
};

//
//  For Wizard Pages...
//
template <class T, bool bAutoDelete = true>
class ATL_NO_VTABLE CMySnapInPropertyWizardImpl : public CDialogImplBase
{
protected:
  BOOL OnBaseSetActive()
  {
    if (m_PagePosition != NOT_A_WIZARD)
    {
      DWORD dwFlags = 0;
      if ( m_PagePosition == FIRST_PAGE )
        dwFlags = PSWIZB_NEXT;
      else if ( m_PagePosition == MIDDLE_PAGE )
        dwFlags = PSWIZB_BACK | PSWIZB_NEXT;
      else if ( m_PagePosition == LAST_PAGE )
        dwFlags = PSWIZB_BACK | PSWIZB_FINISH;
      else  if ( m_PagePosition == LASTANDONLY_PAGE )
        dwFlags = PSWIZB_FINISH;

      ::PostMessage(GetParent(), PSM_SETWIZBUTTONS, 0, (LPARAM) dwFlags);
    }
	  T* pT = (T*)this;
    return pT->OnSetActive();
  }

public:
	PROPSHEETPAGE m_psp;
  
  typedef enum _WIZ_POSITION
  {
    NOT_A_WIZARD,
    FIRST_PAGE,
    MIDDLE_PAGE,
    LAST_PAGE,
    LASTANDONLY_PAGE,
  } WIZ_POSITION;
  WIZ_POSITION  m_PagePosition;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CMySnapInPropertyWizardImpl(WIZ_POSITION pageposition, int nTitle)
	{
    //
    m_PagePosition = pageposition;

		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK;
		m_psp.hInstance = _Module.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
		m_psp.lParam = (LPARAM)this;

		if(nTitle)
		{
      m_psp.pszTitle = MAKEINTRESOURCE(nTitle);
      m_psp.dwFlags |= PSP_USETITLE;			
		}
    if (T::ID_HeaderTitle)
    {
      m_psp.dwFlags           |= PSP_USEHEADERTITLE;
      m_psp.pszHeaderTitle     = MAKEINTRESOURCE(T::ID_HeaderTitle);
    }
    if (T::ID_HeaderSubTitle)
    {
      m_psp.dwFlags           |= PSP_USEHEADERSUBTITLE;
      m_psp.pszHeaderSubTitle  = MAKEINTRESOURCE(T::ID_HeaderSubTitle);
    }

	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		ATLASSERT(hWnd == NULL);
		if(uMsg == PSPCB_CREATE)
		{
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}
		if (bAutoDelete && uMsg == PSPCB_RELEASE)
		{
			T* pPage = (T*)ppsp->lParam;
			delete pPage;
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		ATLASSERT(FALSE);
		return FALSE;
	}

// Operations
	void CancelToClose()
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		::SendMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
	}
	void SetModified(BOOL bChanged = TRUE)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		if(bChanged)
			::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
		else
			::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0L);
	}
	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		ATLASSERT(GetParent() != NULL);

		return ::SendMessage(GetParent(), PSM_QUERYSIBLINGS, wParam, lParam);
	}

	typedef CMySnapInPropertyWizardImpl< T, bAutoDelete > thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()

// Message handler
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		ATLASSERT(::IsWindow(m_hWnd));
		NMHDR* pNMHDR = (NMHDR*)lParam;

		// don't handle messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T* pT = (T*)this;
		LRESULT lResult = 0;
		// handle default
		switch(pNMHDR->code)
		{
		case PSN_SETACTIVE:
			lResult = pT->OnBaseSetActive() ? 0 : -1;
			break;
		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;
		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;
		case PSN_RESET:
			pT->OnReset();
			break;
		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;
		case PSN_WIZNEXT:
			lResult = !pT->OnWizardNext();
			break;
		case PSN_WIZBACK:
			lResult = !pT->OnWizardBack();
			break;
		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;
		case PSN_HELP:
			lResult = pT->OnHelp();
			break;
		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

// Overridables
	BOOL OnSetActive()
	{
		return TRUE;
	}
	BOOL OnKillActive()
	{
		return TRUE;
	}
	BOOL OnApply()
	{
		return TRUE;
	}
	void OnReset()
	{
	}
	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	BOOL OnWizardBack()
	{
		return TRUE;
	}
	BOOL OnWizardNext()
	{
		return TRUE;
	}
	BOOL OnWizardFinish()
	{
    if ( m_PagePosition == LAST_PAGE )
    {
      T* pT = (T*)this;
      if ( !pT->OnWizardNext() )
        return FALSE;
    }
		return TRUE;
	}
	BOOL OnHelp()
	{
		return TRUE;
	}

	void DisableControl(UINT id)
	{
		T* pT = dynamic_cast<T*>(this);

		if (!pT)
			return;

		HWND hWndCtl = pT->GetDlgItem(id);
		ASSERT(hWndCtl);
		if (hWndCtl)
			::EnableWindow(hWndCtl, FALSE);
	}
	
};


#endif // __PPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\namerulepages.h ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    NameRulePages.h                                                          //
|                                                                                       //
|Description:  Definition of name rule property pages                                   //
|                                                                                       //
|Created:      Paul Skoglund 07-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#ifndef __NAMERULEPAGES_H_
#define __NAMERULEPAGES_H_

#include "Globals.h"
#include "ppage.h"

BOOL NameRuleDlg(PCNameRule &out, PCNameRule *Initializer = NULL, BOOL bReadOnly = FALSE);

class CBaseNode;

class CNRulePage :
	public CMySnapInPropertyPageImpl<CNRulePage>
{
public :
  CNRulePage(int nTitle, PCNameRule *out = NULL, PCNameRule *in = NULL);

  ~CNRulePage();

	enum { IDD = IDD_NAMERULE_PAGE };

  CComBSTR m_bName;
  CComBSTR m_bMask;
	CComBSTR m_bComment;
  MATCH_TYPE m_Type;

	BEGIN_MSG_MAP(CNRulePage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)    
		MESSAGE_HANDLER(WM_HELP,       OnWMHelp)    
    COMMAND_HANDLER(IDC_NAME,      EN_CHANGE, OnEditChange)
    COMMAND_HANDLER(IDC_MATCHMASK, EN_CHANGE, OnEditChange)
		COMMAND_HANDLER(IDC_COMMENT,   EN_CHANGE, OnEditChange)
		COMMAND_HANDLER(IDC_BTN_ALIAS, BN_CLICKED, OnAliasMacro)
    COMMAND_RANGE_HANDLER(IDC_DIR, IDC_STRING, OnMaskTypeEdit)
		CHAIN_MSG_MAP(CMySnapInPropertyPageImpl<CNRulePage>)
	END_MSG_MAP()


	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

  LRESULT OnEditChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnMaskTypeEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

  LRESULT OnAliasMacro(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	BOOL OnHelp();

	BOOL OnKillActive()      { return Validate(TRUE); }
  BOOL OnApply();

	BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
	BOOL Validate(BOOL bSave = FALSE);

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  PCNameRule *m_OutBuffer;

  BOOL       m_bReadOnly;
  union {
    struct
    {
      int matchtype : 1;
      int matchmask : 1;
      int matchname : 1;
			int comment   : 1;
    } Fields;
    int on;
  } PageFields;

	HANDLE m_hBtnImage;
	HMENU  m_hMenu;
};

#endif // __NAMERULEPAGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\processpages.h ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    ProcessPages.h                                                           //
|                                                                                       //
|Description:  Definition of Process Property pages                                     //
|                                                                                       //
|Created:      Paul Skoglund 08-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#ifndef __PROCESSPAGES_H_
#define __PROCESSPAGES_H_

#include "Globals.h"
#include "ppage.h"
#include "container.h"

#pragma warning(push)
#include <list>
#pragma warning(pop)


using std::list;

    // property page helpers
extern HRESULT CreatePropertyPagesForProcListItem(
                 const PCProcListItem &ProcListItem,
                 LPPROPERTYSHEETCALLBACK lpProvider,
                 LONG_PTR handle,
                 CBaseNode *BaseNodePtr ); 

extern HRESULT CreatePropertyPagesForProcDetail(
                 const PROC_NAME &procName,
                 LPPROPERTYSHEETCALLBACK lpProvider,
                 LONG_PTR handle,
                 CBaseNode *BaseNodePtr );

class CBaseNode;

class CProcessIDPage :
	public CMySnapInPropertyPageImpl<CProcessIDPage>
{
public :
  CProcessIDPage(int nTitle, CProcDetailContainer *pContainer, list<tstring> *jobnames = NULL);
  ~CProcessIDPage();

	enum { IDD = IDD_PROCID_PAGE };

  CComBSTR m_bName;
  CComBSTR m_bComment;
  CComBSTR m_bJob;
  bool     m_JobChk;

	BEGIN_MSG_MAP(CProcessIDPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP,       OnWMHelp)
    COMMAND_HANDLER(IDC_COMMENT, EN_CHANGE, OnEditChange)
    COMMAND_HANDLER(IDC_JOB_LIST, CBN_EDITCHANGE, OnEditChange)
		COMMAND_HANDLER(IDC_JOB_LIST, CBN_SELCHANGE,  OnEditChange)
    COMMAND_HANDLER(IDC_JOBMEMBER_CHK, BN_CLICKED, OnJobChk)
  	CHAIN_MSG_MAP(CMySnapInPropertyPageImpl<CProcessIDPage>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnEditChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnJobChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

  BOOL OnHelp();
	BOOL OnKillActive()      { return Validate(TRUE); }
  BOOL OnApply();

	BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
	BOOL Validate(BOOL bSave = FALSE);

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  CProcDetailContainer     *m_pProcContainer;

	BOOL                      m_bReadOnly;

	list<tstring>            *m_pJobNames;

  union {
    struct
    {
      int procName : 1;
      int comment  : 1;
      int jobChk   : 1;
      int jobName  : 1;
    } Fields;
    int on;
  } PageFields;
};


class CProcessUnmanagedPage :
	public CMySnapInPropertyPageImpl<CProcessUnmanagedPage>
{
public :
  CProcessUnmanagedPage(int nTitle, CNewProcDetailContainer *pProcContainer, const PCSystemParms sysParms, list<tstring> *jobnames = NULL);

  ~CProcessUnmanagedPage();

	enum { IDD = IDD_PROCDEF_PAGE };

  CComBSTR m_bName;

	BEGIN_MSG_MAP(CProcessUnmanagedPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP,       OnWMHelp)
    COMMAND_HANDLER(IDC_ADD, BN_CLICKED, OnAdd)
  	CHAIN_MSG_MAP(CMySnapInPropertyPageImpl<CProcessUnmanagedPage>)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

  BOOL OnHelp();
	BOOL OnKillActive()      { return Validate(TRUE); }
  BOOL OnApply();

	BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
	BOOL Validate(BOOL bSave = FALSE);

  void SetReadOnly()          { m_bReadOnly = TRUE;}

private:
  CNewProcDetailContainer        *m_pProcContainer;

  BOOL                      m_bReadOnly;
	list<tstring>            *m_pJobNames;

  PCSystemParms             m_SystemParms;
};


#endif // __PROCESSPAGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\processfolder.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    ProcessFolder.cpp                                                        //
|                                                                                       //
|Description:  Implementation of Process List                                           //
|                                                                                       //
|Created:      Paul Skoglund 08-1998                                                    //
|                                                                                       //
|Work to be done:                                                                       //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#include "StdAfx.h"
#include "BaseNode.h"

#include "ProcessPages.h"
#include "ManagementPages.h"
#include "ManagementRuleWizards.h"

#pragma warning(push)
#include <algorithm>
#pragma warning(pop)

using std::find;
using std::list<PCProcListItem*>;

const GUID         CProcessFolder::m_GUID   =   {0xff9baf63,0x064e,0x11d2,{0x80, 0x14,0x00,0x10,0x4b,0x9a,0x31,0x06} };
const TCHAR *const CProcessFolder::m_szGUID = _T("{ff9baf63-064e-11d2-8014-00104b9a3106}");

const CONTEXTMENUITEMBYID CProcessFolder::ResultsTopMenuItems[] = 
{ 
  { IDS_PRULE_DEFINE,     ID_PRULE_DEFINE,     ID_PRULE_DEFINE,     CCM_INSERTIONPOINTID_PRIMARY_TOP  },
  { IDS_ENDPROCESS,       ID_ENDPROCESS,       ID_ENDPROCESS,       CCM_INSERTIONPOINTID_PRIMARY_TOP  },
  { 0,                    0,                   0,                   0                                 }
};

const CONTEXTMENUITEMBYID CProcessFolder::ViewMenuItems[] = 
{ 
  { IDS_PROCVIEW_ALL,     ID_PROCVIEW_ALL,     ID_PROCVIEW_ALL,     CCM_INSERTIONPOINTID_PRIMARY_VIEW },
  { IDS_PROCVIEW_RUN,     ID_PROCVIEW_RUN,     ID_PROCVIEW_RUN,     CCM_INSERTIONPOINTID_PRIMARY_VIEW },
  { IDS_PROCVIEW_MANAGED, ID_PROCVIEW_MANAGED, ID_PROCVIEW_MANAGED, CCM_INSERTIONPOINTID_PRIMARY_VIEW },
  { 0,                    0,                   0,                   0},
};


CProcessFolder::CProcessFolder(CBaseNode *pParent) : CBaseNode(PROCESS_NODE, pParent), m_ID(0), m_fViewOption(ID_PROCVIEW_ALL)
{
  LoadStringHelper(m_name, IDS_PROCESSES_FOLDER);
}


CProcessFolder::~CProcessFolder()
{
  ClearCache();
  ATLTRACE( _T("~CProcessFolder end\n"));
}


LPCTSTR CProcessFolder::GetNodeName()
{ 
  return m_name;
}


HRESULT CProcessFolder::GetDisplayInfo(RESULTDATAITEM &ResultItem)    
{
  if (ResultItem.bScopeItem)
  {
    if( ResultItem.mask & RDI_STR )
    {
			if (0 == ResultItem.nCol)
				ResultItem.str = const_cast<LPOLESTR>(GetNodeName());
			else
				ResultItem.str = _T("");
    }
    if (ResultItem.mask & RDI_IMAGE)
      ResultItem.nImage = sImage();
    return S_OK;
  }
  else
  {
    list<PCProcListItem*>::iterator item;
    item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcListItem*>(ResultItem.lParam) );
    if (item == Cache.end() )  // $$ change this double check to an ASSERT...this could get s-l-o-w...
      return E_UNEXPECTED;
    return PCProcListGetDisplayInfo(ResultItem, *(reinterpret_cast<PCProcListItem*>(ResultItem.lParam)), m_ResultStr );
  }
}

HRESULT CProcessFolder::OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2* ipHeaderCtrl2, IConsole2* ipConsole2)
{
  ASSERT(hItem == GetID());

  if (!bSelecting)
    return S_OK;

  InsertProcessHeaders(ipHeaderCtrl2);

  return OnRefresh(ipConsole2);  
}

HRESULT CProcessFolder::AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed )
{
  HRESULT hr = S_OK;
  ITEM_STR name;
  ITEM_STR status;
  
  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
  {
    CONTEXTMENUITEM m = { 0 };
    for (const CONTEXTMENUITEMBYID *M = ViewMenuItems; M->lCommandID; M++)
    {
      m.strName           = const_cast<TCHAR *>(LoadStringHelper(name,   M->strNameID));
      m.strStatusBarText  = const_cast<TCHAR *>(LoadStringHelper(status, M->strStatusBarTextID));
			m.lCommandID        = M->lCommandID;
			m.lInsertionPointID = M->lInsertionPointID;
 		  //m.fSpecialFlags   = 0;		// currently always 0, initialized to 0

      if (m.lCommandID == m_fViewOption)
        m.fFlags = MF_CHECKED | MF_ENABLED;
      else
        m.fFlags = MF_UNCHECKED | MF_ENABLED;

      hr = piCallback->AddItem(&m);

      if (FAILED(hr))
        break;
    }
    *pInsertionAllowed ^= CCM_INSERTIONALLOWED_VIEW;
  }
  return hr;
}

HRESULT CProcessFolder::AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed, LPARAM Cookie)
{
  HRESULT hr = S_OK;
  ITEM_STR name;
  ITEM_STR status;

  list<PCProcListItem*>::iterator item;
  item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcListItem*>(Cookie) );
  if (item == Cache.end() )
    return E_UNEXPECTED;

  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
  {
    CONTEXTMENUITEM m = { 0 };
    for (const CONTEXTMENUITEMBYID *M = ResultsTopMenuItems; M->lCommandID; M++)
    {
      m.strName           = const_cast<TCHAR *>(LoadStringHelper(name,   M->strNameID));
      m.strStatusBarText  = const_cast<TCHAR *>(LoadStringHelper(status, M->strStatusBarTextID));
			m.lCommandID        = M->lCommandID;
			m.lInsertionPointID = M->lInsertionPointID;
 		  //m.fSpecialFlags   = 0;		// currently always 0, initialized to 0

      m.fFlags = MF_GRAYED;

      if (M->lCommandID == ID_PRULE_DEFINE)
      {
		    if ( !(PCLFLAG_IS_DEFINED & (*item)->lFlags) )
          m.fFlags = MF_ENABLED;
      }
      else if (M->lCommandID == ID_ENDPROCESS)
      {
		    if ( (PCLFLAG_IS_RUNNING & (*item)->lFlags) )
          m.fFlags = MF_ENABLED;
      }

      hr = piCallback->AddItem(&m);

      if (FAILED(hr))
        break;
    }
  }

  hr = AddMenuItems(piCallback, pInsertionAllowed);
  
  return hr;
}

HRESULT CProcessFolder::OnMenuCommand(IConsole2 *ipConsole2, long nCommandID )
{
  switch(nCommandID)
  {
    case ID_PROCVIEW_RUN:
    case ID_PROCVIEW_MANAGED:
    case ID_PROCVIEW_ALL:
      m_fViewOption = nCommandID;
			return OnRefresh(ipConsole2);  
    default:    
      break;
  }
  return E_UNEXPECTED;
}

HRESULT CProcessFolder::OnMenuCommand(IConsole2 *ipConsole2, long nCommandID, LPARAM Cookie )
{
  switch(nCommandID)
  {
    case ID_PROCVIEW_RUN:
    case ID_PROCVIEW_MANAGED:
    case ID_PROCVIEW_ALL:
			return OnMenuCommand(ipConsole2, nCommandID);  
    case ID_PRULE_DEFINE:
			{
				if (Cookie)
				{
					list<PCProcListItem*>::iterator item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcListItem*>(Cookie) );

					if (item != Cache.end() )
					{
            PCid hID = GetPCid();
            PCSystemInfo SystemInfo;
            if (!hID || !PCGetServiceInfo(hID, &SystemInfo, sizeof(SystemInfo)))
            {
              ReportPCError();
              return S_OK;
            }

						PCProcDetail  ProcDetail = { 0 };  
 					  list<tstring> jobs;
						GetGrpNameList(hID, jobs);
						if (ProcRuleWizard(IDS_PRULE_DEFINE, jobs, ProcDetail, SystemInfo.sysParms, &(*item)->procName ) )
						{
							if (!PCAddProcDetail(hID, &ProcDetail) )
								ReportPCError();
              else
              {
                if (1 == PCGetProcList( GetPCid(), *item, sizeof(PCProcListItem), PC_LIST_STARTING_WITH) )
                  VERIFY(S_OK == SendViewChange(ipConsole2, Cookie, PC_VIEW_SETITEM));
                else
                  VERIFY(S_OK == SendViewChange(ipConsole2, NULL, PC_VIEW_UPDATEALL));
              }
						}
						return S_OK;
					}
				}
			}
			break;
    case ID_ENDPROCESS:
			{
				if (Cookie)
				{
					list<PCProcListItem*>::iterator item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcListItem*>(Cookie) );

					if (item != Cache.end() )
					{
						if (!PCKillProcess(GetPCid(), (*item)->procStats.pid, (*item)->procStats.createTime) )
						  ReportPCError();
            else
              VERIFY(S_OK == SendViewChange(ipConsole2, Cookie, PC_VIEW_DELETEITEM));
						return S_OK;
					}
				}
			}
			break;
    default:    
      break;
  }
  return E_UNEXPECTED;
}

HRESULT CProcessFolder::OnHelpCmd(IDisplayHelp *ipDisplayHelp)
{
	if (!ipDisplayHelp)
		return E_UNEXPECTED;

	ipDisplayHelp->ShowTopic(const_cast<TCHAR *>(HELP_pr_overview));

	return S_OK;
}

HRESULT CProcessFolder::OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb)
{
  ASSERT(bScope);

  if (bSelect)
  {
    VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE ) == S_OK);
    VERIFY( ipConsoleVerb->SetDefaultVerb( MMC_VERB_OPEN ) == S_OK ); 
  }
  return S_OK;
}

HRESULT CProcessFolder::OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie)
{
  ASSERT(!bScope);

  VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE ) == S_OK);
  if (bSelect && !bScope) // incase the rules are changed again leave !bScope test
  {
    VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE ) == S_OK);
    VERIFY( ipConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES ) == S_OK ); 
  }
  return S_OK;
}

HRESULT CProcessFolder::OnViewChange(IResultData *ipResultData, LPARAM thing, LONG_PTR hint)
{
  ASSERT(ipResultData);
  if (!ipResultData)  
    return E_UNEXPECTED;

  VERIFY(ipResultData->ModifyViewStyle(MMC_SINGLESEL, MMC_NOSORTHEADER) == S_OK);

  list<PCProcListItem*>::iterator item;

  HRESULT hr = E_UNEXPECTED;
  switch (hint)
  {
  case PC_VIEW_REDRAWALL:// not currently used 
    hr = ShowAllItems(ipResultData, TRUE);
    break;
  case PC_VIEW_ADDITEM:  // not currently used
    ASSERT(FALSE);       // add smarter support for this hint...
                         // notice this falls through to PC_VIEW_UPDATEALL
  case PC_VIEW_UPDATEALL:
    hr = ShowAllItems(ipResultData, FALSE);
    break;
  case PC_VIEW_UPDATEITEM:
    {
    HRESULTITEM hItem;
    hr = ipResultData->FindItemByLParam(thing, &hItem);
    if (hr == S_OK)
      hr = ipResultData->UpdateItem(hItem);    
    }
    break;
  case PC_VIEW_SETITEM:
    item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcListItem*>(thing) );
    if (item == Cache.end())
      hr = E_UNEXPECTED;  
    else
    {
      HRESULTITEM hItem;
      hr = ipResultData->FindItemByLParam(thing, &hItem);
      if (hr == S_OK)
      {
        RESULTDATAITEM data = { 0 };
        data.mask   = RDI_IMAGE;
		    data.itemID = hItem;

        if ((*item)->lFlags & PCLFLAG_IS_DEFINED)
          data.nImage = PROCITEMIMAGE;
        else
          data.nImage = PROCITEMIMAGE_NODEFINITION;

		    hr = ipResultData->SetItem(&data);
        if (hr == S_OK)
          hr = ipResultData->UpdateItem(hItem);    
      }
    }
    break;
  case PC_VIEW_DELETEITEM:
    {
    HRESULTITEM hItem;
    hr = ipResultData->FindItemByLParam(thing, &hItem);
    if (hr == S_OK)
      hr = ipResultData->DeleteItem(hItem, 0);    
    }
    break;
  default:
    hr = E_UNEXPECTED;
    break;
  }
  ASSERT(hr == S_OK);
  return hr;
}

HRESULT CProcessFolder::ShowAllItems(IResultData* ipResultData, BOOL bCacheValid)
{
  list<PCProcListItem*>::iterator item;
  LPARAM selected = 0;
  LPARAM focused  = 0;

  RESULTDATAITEM data;

  if (bCacheValid)
  {
    memset(&data, 0, sizeof(data));
	  data.nIndex = -1; 
	  data.nState = LVIS_SELECTED;
	  data.mask   = RDI_STATE;

	  if (S_OK == ipResultData->GetNextItem(&data) && data.nIndex != -1 )
    {
      item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcListItem*>(data.lParam) );
		  if (item != Cache.end() )
		  {
        selected = data.lParam;
      }
    }

	  memset(&data, 0, sizeof(data));
	  data.nIndex = -1;
	  data.nState = LVIS_FOCUSED;
	  data.mask   = RDI_STATE;

	  if (S_OK == ipResultData->GetNextItem(&data) && data.nIndex != -1)
    {
      item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcListItem*>(data.lParam) );
		  if (item != Cache.end() )
		  {
        focused = data.lParam;
      }
    }
  }

  ipResultData->DeleteAllRsltItems();

  ITEM_STR str;
  if (ID_PROCVIEW_RUN == m_fViewOption) 
    ipResultData->SetDescBarText(const_cast<TCHAR *>(LoadStringHelper(str, IDS_RUNNING_PROCS)));
  else if (ID_PROCVIEW_MANAGED == m_fViewOption)
    ipResultData->SetDescBarText(const_cast<TCHAR *>(LoadStringHelper(str, IDS_MANAGED_PROCS)));
  else
    ipResultData->SetDescBarText(_T(""));
    
  memset(&data, 0, sizeof(data));
  data.mask = RDI_STR | RDI_IMAGE | RDI_PARAM | RDI_STATE;
  data.bScopeItem = FALSE;
  //data.itemID;
  data.nIndex = 0;
  data.nCol = 0;
  data.str = (LPOLESTR)MMC_CALLBACK;

  data.iIndent = 0; //reserved
                     
  HRESULT hr = S_OK;
  for (list<PCProcListItem*>::iterator i = Cache.begin(); i != Cache.end(); ++i)
  {
    data.lParam = reinterpret_cast<LPARAM>(*i);

    PCProcListItem &ref = *(*i);

    if (ID_PROCVIEW_RUN == m_fViewOption && !(ref.lFlags & PCLFLAG_IS_RUNNING)) 
      continue;
    else if (ID_PROCVIEW_MANAGED == m_fViewOption && !(ref.lFlags & PCLFLAG_IS_MANAGED))
      continue;

    if (ref.lFlags & PCLFLAG_IS_DEFINED)
      data.nImage = PROCITEMIMAGE;
    else
      data.nImage = PROCITEMIMAGE_NODEFINITION;

    data.nState = 0;
    
 		if (data.lParam == selected)
  		data.nState |= LVIS_SELECTED;
    if (data.lParam == focused)
			data.nState |= LVIS_FOCUSED;
    
    hr = ipResultData->InsertItem(&data);
    if (hr != S_OK)
      break;
  }
  
  return hr;
}

void CProcessFolder::ClearCache()
{
  Cache.clear();

  for (list<PCProcListItem*>::iterator chunck = MemBlocks.begin(); chunck != MemBlocks.end(); ++chunck)
  {
    delete [] (*chunck);
  }
  MemBlocks.clear();
}

BOOL CProcessFolder::RefreshCache()
{
  PCINT32  res = 0;
  PCULONG32 err = 0;
  PCProcListItem *last = NULL;

  const int MINIMUM_ALLOCATION = min((COM_BUFFER_SIZE/sizeof(PCProcListItem)), 100);

  ClearCache();

  PCid hID = GetPCid();
  if (!hID)
  {
    ReportPCError();
    return false;
  }

  do
  {
    PCProcListItem *ptr = new PCProcListItem[MINIMUM_ALLOCATION];

    if (!ptr)
    {
      err = ERROR_OUTOFMEMORY;
      break;
    }

    if (last)
      memcpy(ptr, last, sizeof(PCProcListItem));
    else
      memset(ptr, 0, sizeof(PCProcListItem));
    
    res = PCGetProcList( hID, ptr, MINIMUM_ALLOCATION * sizeof(PCProcListItem));
    if (res < 0 )
    {
      err = GetLastPCError();
      delete [] ptr;
      break;
    }

    if (res > 0)
    {
      last = &ptr[res - 1];

      MemBlocks.push_front(ptr);
      for (INT32 i = 0; i < res; i++)
      {
        Cache.insert(Cache.end(), ptr);
        ptr++;
      }
    }
  } while (res > 0 && PCERROR_MORE_DATA == GetLastPCError() );

  if (err)
    ReportPCError();

  return err == 0;
}

HRESULT CProcessFolder::QueryPagesFor(LPARAM Cookie)
{
  list<PCProcListItem*>::iterator item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcListItem*>(Cookie) );

  if (item == Cache.end() )
    return E_UNEXPECTED;

  return S_OK;
}

HRESULT CProcessFolder::OnCreatePropertyPages( LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, DATA_OBJECT_TYPES context, LPARAM Cookie) 
{ 
  list<PCProcListItem*>::iterator item;
  item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcListItem*>(Cookie) );

  if (item == Cache.end() )
    return E_UNEXPECTED;

  return CreatePropertyPagesForProcListItem(**item, lpProvider, handle, this);
}

HRESULT CProcessFolder::OnPropertyChange(PROPERTY_CHANGE_HDR *pUpdate, IConsole2 *ipConsole2)
{
	return OnRefresh(ipConsole2);
}

HRESULT CProcessFolder::OnRefresh(IConsole2 *ipConsole2)
{
  RefreshCache();
  return SendViewChange(ipConsole2, NULL, PC_VIEW_UPDATEALL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\proccon.cpp ===
/*======================================================================================//
|  Windows NT Process Control                                                           //
|                                                                                       //
|Copyright (c) 1999  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    ProcCon.cpp                                                              //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|Created:      Paul Skoglund 07-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|    3-27-1999 renamed ProcMan to ProcCon                                               //
|                                                                                       //
|=======================================================================================*/


// Note: Proxy/Stub Information
// To build a separate proxy/stub DLL,
// run nmake -f ProcConps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "ProcCon.h"


#include "ProcCon_i.c"

#include "ComponentData.h"
#include "About.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
  OBJECT_ENTRY(CLSID_ComponentData, CComponentData)
  OBJECT_ENTRY(CLSID_About, CAbout)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
  if ( DLL_PROCESS_ATTACH == dwReason )
  {
    SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT);
    _Module.Init(ObjectMap, hInstance);
    DisableThreadLibraryCalls(hInstance);
  }
  else if ( DLL_PROCESS_DETACH == dwReason )
    _Module.Term();

  return TRUE;

} // end DllMain()


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
  return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
  return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
  // registers object, typelib and all interfaces in typelib
  return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
  // see atlbase.h source for this overloaded method that also unregisters typelib
  HRESULT hr = _Module.UnregisterServer(TRUE);

/*
  if (FAILED(hr))
    return hr;

  change and use ATL CComModule::UnregisterServer(TRUE) that also unregisters the type library...

#if _WIN32_WINNT >= 0x0400
  // possible interest...see knowledge base article
  // FIX: ATL Servers Do Not Unregister Their Type Library
  // Last reviewed: September 1, 1998
  // Article ID: Q179688
  HRESULT hr2 = UnRegisterTypeLib(LIBID_PROCCONLib, 1, 0, LOCALE_NEUTRAL, SYS_WIN32);
  // 04/16/1999 Paul Skoglund
  //   if library has already been unregistered UnRegisterTypeLib() is
  //   returning 0x8002801C -- TYPE_E_REGISTRYACCESS
  //   seems like a bug...
  if (hr2 != TYPE_E_REGISTRYACCESS)
    return hr2;
#endif
*/

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\processrulefolder.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    ProcessRuleFolder.cpp                                                    //
|                                                                                       //
|Description:  Implementation of process rule node                                      //
|                                                                                       //
|Created:      Paul Skoglund 09-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#include "StdAfx.h"
#include "BaseNode.h"

#include "ManagementPages.h"
#include "ManagementRuleWizards.h"
#include "ProcessPages.h"

#pragma warning(push)
#include <algorithm>
#pragma warning(pop)

using std::find;
using std::list<PCProcSummary*>;

const GUID         CProcessRuleFolder::m_GUID   =   {0xff9baf65,0x064e,0x11d2,{0x80, 0x14,0x00,0x10,0x4b,0x9a,0x31,0x06} };
const TCHAR *const CProcessRuleFolder::m_szGUID = _T("{ff9baf65-064e-11d2-8014-00104b9a3106}");

// Array of view items to be inserted into the context menu.
const CONTEXTMENUITEMBYID CProcessRuleFolder::TopMenuItems[] =
{ 
  { IDS_PRULE_TOP,    ID_PRULE_NEW,    ID_PRULE_NEW, CCM_INSERTIONPOINTID_PRIMARY_TOP },
  { 0,                0,               0,            0                                }
};

const CONTEXTMENUITEMBYID CProcessRuleFolder::NewMenuItems[] =
{ 
  { IDS_PRULE_NEW,    ID_PRULE_NEW,    ID_PRULE_NEW, CCM_INSERTIONPOINTID_PRIMARY_NEW },
  { 0,                0,               0,            0                                }
};

CProcessRuleFolder::CProcessRuleFolder(CBaseNode *pParent) : CBaseNode(PROCESSRULE_NODE, pParent), m_ID(0)
{
  LoadStringHelper(m_name, IDS_PROCESSRULE_FOLDER);
}

CProcessRuleFolder::~CProcessRuleFolder()
{
  ClearCache();
  ATLTRACE( _T("~CProcessRuleFolder end\n"));
}

LPCTSTR CProcessRuleFolder::GetNodeName()    
{ 
  return m_name;
}

HRESULT CProcessRuleFolder::GetDisplayInfo(RESULTDATAITEM &ResultItem)
{
  if (ResultItem.bScopeItem)
  {
    if( ResultItem.mask & RDI_STR )
    {
			if (0 == ResultItem.nCol)
				ResultItem.str = const_cast<LPOLESTR>(GetNodeName());
			else
				ResultItem.str = _T("");
    }
    if (ResultItem.mask & RDI_IMAGE)
      ResultItem.nImage = sImage();
    return S_OK;
  }

  list<PCProcSummary*>::iterator item;

  item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcSummary*>(ResultItem.lParam) );

  if (item == Cache.end() )
    return E_UNEXPECTED;

  if (ResultItem.mask & RDI_IMAGE)
    ResultItem.nImage = PROCESSRULEITEMIMAGE;

  if (ResultItem.mask & RDI_STR)
  {
    PCProcSummary &ref = **item;
    LPCTSTR &pstr = ResultItem.str;

    switch (ResultItem.nCol)
    {
    case PROCESS_ALIAS_COLUMN:
      pstr = ref.procName;
      break;
    case DESCRIPTION_COLUMN:
      pstr = ref.mgmtParms.description;
      break;
    case APPLY_JOB_COLUMN:
      pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP);
      break;
    case JOB_COLUMN:
      pstr = ref.memberOfJobName;
      break;
    case APPLY_AFFINITY_COLUMN:
      if (ref.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP)
	      pstr = _T("");
      else 
				pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_APPLY_AFFINITY);
      break;
    case AFFINITY_COLUMN:
			if (ref.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP)
	      pstr = _T("");
      else 
				pstr = FormatAffinity(m_ResultStr, ref.mgmtParms.affinity);
      break;
    case APPLY_PRIORITY_COLUMN:
			if (ref.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP)
	      pstr = _T("");
      else
				pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_APPLY_PRIORITY);
      break;
    case PRIORITY_COLUMN:
			if (ref.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP)
	      pstr = _T("");
      else 
				pstr = FormatPriority(m_ResultStr, ref.mgmtParms.priority);
      break;
    case APPLY_MINMAXWS_COLUMN:
			if (ref.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP)
	      pstr = _T("");
      else
        pstr = FormatApplyFlag(m_ResultStr, ref.mgmtParms.mFlags & PCMFLAG_APPLY_WS_MINMAX);
      break;
    case MINWS_COLUMN:
			if (ref.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP)
	      pstr = _T("");
      else
        pstr = FormatMemory(m_ResultStr, ref.mgmtParms.minWS);
      break;
    case MAXWS_COLUMN:
			if (ref.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP)
	      pstr = _T("");
      else
        pstr = FormatMemory(m_ResultStr, ref.mgmtParms.maxWS);
      break;
    default:
      ASSERT(FALSE);
      pstr = _T("");
      break;
    }
  }
  return S_OK;
}

HRESULT CProcessRuleFolder::OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2 *ipHeaderCtrl, IConsole2 *ipConsole2)
{
  ASSERT(hItem == GetID());

  if (!bSelecting)
    return S_OK;

  ITEM_STR str;

  LoadStringHelper(str, IDS_PROCESS_ALIAS_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( PROCESS_ALIAS_COLUMN, str, 0, PROCESS_ALIAS_COLUMN_WIDTH ));

	LoadStringHelper(str, IDS_DESCRIPTION_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( DESCRIPTION_COLUMN, str, 0, DESCRIPTION_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_APPLY_JOB_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( APPLY_JOB_COLUMN, str, 0, APPLY_JOB_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_JOB_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( JOB_COLUMN, str, 0, JOB_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_APPLY_AFFINITY_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( APPLY_AFFINITY_COLUMN, str, 0, APPLY_AFFINITY_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_AFFINITY_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( AFFINITY_COLUMN, str, 0, AFFINITY_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_APPLY_PRIORITY_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( APPLY_PRIORITY_COLUMN, str, 0, APPLY_PRIORITY_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_PRIORITY_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( PRIORITY_COLUMN, str, 0, PRIORITY_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_APPLY_MINMAXWS_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( APPLY_MINMAXWS_COLUMN, str, 0, APPLY_MINMAXWS_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_MINWS_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( MINWS_COLUMN, str, 0, MINWS_COLUMN_WIDTH ));

  LoadStringHelper(str, IDS_MAXWS_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( MAXWS_COLUMN, str, 0, MAXWS_COLUMN_WIDTH ));

  return OnRefresh(ipConsole2);
}


HRESULT CProcessRuleFolder::AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed)
{ 
  HRESULT hr = S_OK; 
  ITEM_STR name;
  ITEM_STR status;

  BOOL bConnected = GetPCid();

  CONTEXTMENUITEM m = { 0 };
  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
  {
    for (const CONTEXTMENUITEMBYID *M = TopMenuItems; M->lCommandID; M++)
    {
      m.strName           = const_cast<TCHAR *>(LoadStringHelper(name,   M->strNameID));
      m.strStatusBarText  = const_cast<TCHAR *>(LoadStringHelper(status, M->strStatusBarTextID));
			m.lCommandID        = M->lCommandID;
			m.lInsertionPointID = M->lInsertionPointID;
      m.fFlags            = bConnected ? MF_ENABLED : MF_GRAYED;
 		  //m.fSpecialFlags   = 0;		// currently always 0, initialized to 0

      hr = piCallback->AddItem(&m);

      if (FAILED(hr))
        break;
    }
  }

  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW )
  {
    for (const CONTEXTMENUITEMBYID *M = NewMenuItems; M->lCommandID; M++)
    {
      m.strName           = const_cast<TCHAR *>(LoadStringHelper(name,   M->strNameID));
      m.strStatusBarText  = const_cast<TCHAR *>(LoadStringHelper(status, M->strStatusBarTextID));
			m.lCommandID        = M->lCommandID;
			m.lInsertionPointID = M->lInsertionPointID;
			m.fFlags            = bConnected ? MF_ENABLED : MF_GRAYED;
 		  //m.fSpecialFlags   = 0;		// currently always 0, initialized to 0

      hr = piCallback->AddItem(&m);

      if (FAILED(hr))
        break;
    }
  }

  return hr; 
}

HRESULT CProcessRuleFolder::OnHelpCmd(IDisplayHelp *ipDisplayHelp)
{
	if (!ipDisplayHelp)
		return E_UNEXPECTED;

	ipDisplayHelp->ShowTopic(const_cast<TCHAR *>(HELP_ru_proc));

	return S_OK;
}

HRESULT CProcessRuleFolder::OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb)
{
  ASSERT(bScope);

  if ( bSelect )
  {
    VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE ) == S_OK);
    VERIFY( ipConsoleVerb->SetDefaultVerb( MMC_VERB_OPEN ) == S_OK );
  }
  return S_OK;
}

HRESULT CProcessRuleFolder::OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie)
{
  ASSERT(!bScope);

  VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE ) == S_OK);
  if (bSelect && !bScope)  // incase the rules are changed again leave !bScope test
  {
    VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE ) == S_OK);
    VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_DELETE,     ENABLED, TRUE ) == S_OK);
    VERIFY( ipConsoleVerb->SetDefaultVerb( MMC_VERB_PROPERTIES ) == S_OK ); 
  }
  return S_OK;
}

HRESULT CProcessRuleFolder::OnMenuCommand(IConsole2 *ipConsole2, long nCommandID )
{
  HRESULT hr = S_FALSE;

  switch(nCommandID)
  {
    case ID_PRULE_NEW:
      {
        PCid hID = GetPCid();
        PCSystemInfo SystemInfo;
        if (!hID || !PCGetServiceInfo(hID, &SystemInfo, sizeof(SystemInfo)))
        {
          ReportPCError();
          return S_OK;
        }
        
        PCProcSummary *ptr = new PCProcSummary[1];
        if (!ptr)
          return E_UNEXPECTED;

        PCProcDetail  ProcDetail = { 0 };
        list<tstring> jobs;
				VERIFY( GetGrpNameList(hID, jobs) );

        if (ProcRuleWizard(IDS_PRULE_CREATE_TITLE, jobs, ProcDetail, SystemInfo.sysParms, NULL) )
        {
          if (PCAddProcDetail(hID, &ProcDetail) )
          {
            *ptr = ProcDetail.base;
            MemBlocks.push_front(ptr);
            Cache.push_front(ptr);
            VERIFY(S_OK == SendViewChange(ipConsole2, (INT_PTR) ptr, PC_VIEW_ADDITEM));
            return S_OK;
          }
          ReportPCError();
        }
        delete [] ptr;
      }
      return S_OK;  // we handled the message...      
    default:
      break;
  }
  return hr;  
}

HRESULT CProcessRuleFolder::OnMenuCommand(IConsole2 *ipConsole2, long nCommandID, LPARAM Cookie )
{
  return OnMenuCommand(ipConsole2, nCommandID);
}

HRESULT CProcessRuleFolder::OnViewChange(IResultData *ipResultData, LPARAM thing, LONG_PTR hint)
{
  ASSERT(ipResultData);
  if (!ipResultData)  
    return E_UNEXPECTED;

  VERIFY(ipResultData->ModifyViewStyle(MMC_SINGLESEL, MMC_NOSORTHEADER) == S_OK);

  list<PCProcSummary*>::iterator item;

  HRESULT hr = E_UNEXPECTED;
  switch (hint)
  {
  case PC_VIEW_REDRAWALL:// not currently used
    hr = ShowAllItems(ipResultData, TRUE);
    break;
  case PC_VIEW_SETITEM:  // not currently used
    ASSERT(FALSE);       // add smarter support for this hint...
    hr = ShowAllItems(ipResultData, TRUE);
    break;
  case PC_VIEW_UPDATEALL:
    hr = ShowAllItems(ipResultData, FALSE);
    break;
  case PC_VIEW_UPDATEITEM:
    {
    HRESULTITEM hItem;
    hr = ipResultData->FindItemByLParam(thing, &hItem);
    if (hr == S_OK)
      hr = ipResultData->UpdateItem(hItem);    
    }
    break;
  case PC_VIEW_ADDITEM:
    item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcSummary*>(thing) );
    if (item == Cache.end())
      hr = E_UNEXPECTED;  
    else
    {
      RESULTDATAITEM data = { 0 };
      data.mask       = RDI_STR | RDI_IMAGE | RDI_PARAM | RDI_STATE;
      data.bScopeItem = FALSE;
      //data.itemID
      //data.nIndex
      //data.nCol
      data.str        = (LPOLESTR)MMC_CALLBACK;
      data.nImage     = PROCESSRULEITEMIMAGE;
      //data.nState
      //data.iIndent //reserved
      data.lParam     = thing;
      //data.nState
      hr = ipResultData->InsertItem(&data);
    }
    break;
  case PC_VIEW_DELETEITEM:
    {
    HRESULTITEM hItem;
    hr = ipResultData->FindItemByLParam(thing, &hItem);
    if (hr == S_OK)
      hr = ipResultData->DeleteItem(hItem, 0);    
    }
    break;
  default:
    hr = E_UNEXPECTED;
    break;
  }
  ASSERT(hr == S_OK);
  return hr;
}

HRESULT CProcessRuleFolder::ShowAllItems(IResultData* ipResultData, BOOL bCacheValid)
{
  list<PCProcSummary*>::iterator item;
	LPARAM selected = 0;
	LPARAM focused  = 0;

  RESULTDATAITEM data;

  if (bCacheValid)
  {
    memset(&data, 0, sizeof(data));
	  data.nIndex = -1; 
	  data.nState = LVIS_SELECTED;
	  data.mask   = RDI_STATE;

	  if (S_OK == ipResultData->GetNextItem(&data) && data.nIndex != -1 )
    {
      selected = data.lParam;
    }

	  memset(&data, 0, sizeof(data));
	  data.nIndex = -1;
	  data.nState = LVIS_FOCUSED;
	  data.mask   = RDI_STATE;

	  if (S_OK == ipResultData->GetNextItem(&data) && data.nIndex != -1)
    {
      focused = data.lParam;
    }
  }

  ipResultData->DeleteAllRsltItems();

  memset(&data, 0, sizeof(data));
  data.mask = RDI_STR | RDI_IMAGE | RDI_PARAM | RDI_STATE;
  data.bScopeItem = FALSE;
  //data.itemID;
  data.nIndex = 0;
  data.nCol = 0;
  data.str = (LPOLESTR)MMC_CALLBACK;
  data.nImage = PROCESSRULEITEMIMAGE;
  data.nState = 0;

  data.iIndent = 0; //reserved

  HRESULT hr = S_OK;
  for (list<PCProcSummary*>::iterator i = Cache.begin(); i != Cache.end(); ++i)
  {
    data.lParam = reinterpret_cast<LPARAM>(*i);

    data.nState = 0;
    if (data.lParam == selected)
  		data.nState |= LVIS_SELECTED;
    if (data.lParam == focused)
			data.nState |= LVIS_FOCUSED;
  
    hr = ipResultData->InsertItem(&data);
    if (hr != S_OK)
      break;
  }
  
  return hr;
}

void CProcessRuleFolder::ClearCache()
{
  Cache.clear();

  for (list<PCProcSummary*>::iterator chunck = MemBlocks.begin(); chunck != MemBlocks.end(); ++chunck)
  {
    delete [] (*chunck);
  }
  MemBlocks.clear();
}

BOOL CProcessRuleFolder::RefreshCache()
{
  PCINT32  res = 0;
  PCULONG32 err = 0;
  PCProcSummary *last = NULL;

  const int MINIMUM_ALLOCATION = min((COM_BUFFER_SIZE/sizeof(PCProcSummary)), 100);

  ClearCache();

  PCid hID = GetPCid();
  if (!hID)
  {
    ReportPCError();
    return false;
  }

  do
  {
    PCProcSummary *ptr = new PCProcSummary[MINIMUM_ALLOCATION];

    if (!ptr)
    {
      err = ERROR_OUTOFMEMORY;
      break;
    }

    if (last)
      memcpy(ptr, last, sizeof(PCProcSummary));
    else
      memset(ptr, 0, sizeof(PCProcSummary));
    
    res = PCGetProcSummary( hID, ptr, MINIMUM_ALLOCATION * sizeof(PCProcSummary));
    if (res < 0 )
    {
      err = GetLastPCError();
      delete [] ptr;
      break;
    }

    if (res > 0)
    {
      last = &ptr[res - 1];

      MemBlocks.push_front(ptr);
      for (INT32 i = 0; i < res; i++)
      {
        Cache.insert(Cache.end(), ptr);
        ptr++;
      }
    }
  } while (res > 0 && PCERROR_MORE_DATA == GetLastPCError() );

  if (err)
    ReportPCError();

  return err == 0;
}

HRESULT CProcessRuleFolder::QueryPagesFor(LPARAM Cookie)
{
  list<PCProcSummary*>::iterator item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcSummary*>(Cookie) );

  if (item != Cache.end() )
    return S_OK;
    
  return E_UNEXPECTED;
}

HRESULT CProcessRuleFolder::OnCreatePropertyPages( LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, DATA_OBJECT_TYPES context, LPARAM Cookie) 
{
  list<PCProcSummary*>::iterator item;
  item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcSummary*>(Cookie) );

  if (item == Cache.end() )
    return E_UNEXPECTED;

  return CreatePropertyPagesForProcDetail( (*item)->procName, lpProvider, handle, this );

}

HRESULT CProcessRuleFolder::OnPropertyChange(PROPERTY_CHANGE_HDR *pUpdate, IConsole2 *ipConsole2)
{
	return OnRefresh(ipConsole2);
}

HRESULT CProcessRuleFolder::OnDelete(IConsole2 *ipConsole2, LPARAM Cookie)
{ 
  list<PCProcSummary*>::iterator item;
  item = find(Cache.begin(), Cache.end(), reinterpret_cast<PCProcSummary*>(Cookie) );

  if ( item == Cache.end() )
  {
    SendViewChange(ipConsole2, NULL, PC_VIEW_UPDATEALL);
    return E_UNEXPECTED;
  }

  PCProcDetail Detail;
  memset(&Detail, 0, sizeof(Detail));
  memcpy(&(Detail.base), (*item), sizeof(PCProcSummary) );

  if (!PCDeleteProcDetail(GetPCid(), &Detail))
  {
    ReportPCError();
    return E_UNEXPECTED;
  }

  Cache.erase(item);

  return SendViewChange(ipConsole2, Cookie, PC_VIEW_DELETEITEM);
}

HRESULT CProcessRuleFolder::OnRefresh(IConsole2 *ipConsole2)
{
  RefreshCache();
  return SendViewChange(ipConsole2, NULL, PC_VIEW_UPDATEALL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\procont_helpids.h ===
// process control "Version" tab
#define IDH_PC_Properties_fileversion                      100010
#define IDH_PC_Properties_description                      100020
#define IDH_PC_Properties_copyright                        100030
#define IDH_PC_Properties_itemname_field                   100040
#define IDH_PC_Properties_value_field                      100050

// process control "Service" tab
#define IDH_PC_ServiceTab_ScanInterval_fileversion         100110
#define IDH_PC_ServiceTab_ScanInterval_productversion      100120
#define IDH_PC_ServiceTab_ScanInterval_scaninterval        100130
#define IDH_PC_ServiceTab_ScanInterval_servmgmt            100140
#define IDH_PC_ServiceTab_ScanInterval_timeoutintervfield  100150
#define IDH_PC_ServiceTab_RequestTimeOut	                 100160
#define IDH_PC_ServiceTab_ScanInterval_targetcomputerprop  100170
#define IDH_PC_ServiceTab_ScanInterval_itemnamelist        100180
#define IDH_PC_ServiceTab_ScanInterval_valuefield          100190

// connect to another computer wizard
#define IDH_PC_Properties_localcomputer                    100210
#define IDH_PC_Properties_anothercomputer                  100220
#define IDH_PC_Properties_anothercomputer_field            100230
#define IDH_PC_Properties_browse                           100240

#define IDH_PC_Properties_finish                           100310

// process alias rule "Gereral" tab
#define IDH_PC_PAR_SubdirectoryName                        100410
#define IDH_PC_PAR_ImageName                               100420
#define IDH_PC_PAR_String                                  100430
#define IDH_PC_PAR_MatchString                             100440
#define IDH_PC_PAR_Description                             100450
#define IDH_PC_PAR_AssignedOnAMatch                        100460
#define IDH_PC_PAR_SubdirectoryName_arrow                  100470

// process execution rule "General" and "Identity" tab
#define IDH_PC_CPER_ProcessAlias                           101110
#define IDH_PC_CPER_Description                            101120
#define IDH_PC_CPER_ExecuteInGroup                         101130
#define IDH_PC_CPER_ProcessAlias_Executewithin             101140

#define IDH_PC_Properties_definePER                        101210

// process execution rule "Affinity" tab
#define IDH_PC_CPER_Affinity                               101310

// process execution rule "Priority" tab
#define IDH_PC_CPER_Priority                               101410
#define IDH_PC_CPER_Priority_ApplyPriority_Real            101420
#define IDH_PC_CPER_Priority_ApplyPriority_High            101430
#define IDH_PC_CPER_Priority_ApplyPriority_Above           101440
#define IDH_PC_CPER_Priority_ApplyPriority_Normal          101450
#define IDH_PC_CPER_Priority_ApplyPriority_Below           101460
#define IDH_PC_CPER_Priority_ApplyPriority_Low             101470

// process execution rule "Memory" tab
#define IDH_PC_CPER_WorkingSet                             101510
#define IDH_PC_CPER_WorkingSet_minfield                    101520
#define IDH_PC_CPER_WorkingSet_Minimum                     101530
#define IDH_PC_CPER_WorkingSet_maxfield                    101540
#define IDH_PC_CPER_WorkingSet_Maximum                     101550


// process group execution rule "Gereral" and "Identity" tab
#define IDH_PC_CPGER_GroupName                             102010
#define IDH_PC_CPGER_Description                           102020

#define IDH_PC_CPGER_ProcessCount                          102025
#define IDH_PC_CPGER_ProcessCount_apply_maxnumfield        102035
#define IDH_PC_CPGER_ProcessCount_apply_maxnum             102045

#define IDH_PC_Properties_definePGER                       102110

// process group execution rule "Affinity" tab
#define IDH_PC_CPGER_Affinity                              102310

// process group execution rule "Priority" tab
#define IDH_PC_CPGER_Priority                              102410
#define IDH_PC_CPGER_Priority_ApplyPriority_Real           102420
#define IDH_PC_CPGER_Priority_ApplyPriority_High           102430
#define IDH_PC_CPGER_Priority_ApplyPriority_Above          102440
#define IDH_PC_CPGER_Priority_ApplyPriority_Normal         102450
#define IDH_PC_CPGER_Priority_ApplyPriority_Below          102460
#define IDH_PC_CPGER_Priority_ApplyPriority_Low            102470

// process group execution rule "Memory" tab
#define IDH_PC_CPGER_WorkingSet                            102510
#define IDH_PC_CPGER_WorkingSet_workingsetminmemfield      102520
#define IDH_PC_CPGER_WorkingSet_workingsetminmem           102530
#define IDH_PC_CPGER_WorkingSet_workingsetmaxmemfield      102540
#define IDH_PC_CPGER_WorkingSet_workingsetmaxmem           102550

#define IDH_PC_CPGER_ProcessCommittedMemory                102610
#define IDH_PC_CPGER_WorkingSet_proccommittedmaxmemfield   102620
#define IDH_PC_CPGER_WorkingSet_procommittedmaxmem         102630
#define IDH_PC_CPGER_ProcessGroupCommittedMemory           102640
#define IDH_PC_CPGER_WorkingSet_progrpcommaxmemfield       102650
#define IDH_PC_CPGER_WorkingSet_progrpcommaxmem            102660

// process group execution rule "Scheduling" tab
#define IDH_PC_CPGER_SchedulingClass                       102710
#define IDH_PC_CPGER_SchedulingClass_Apply_schedclassfield 102720

// process group execution rule "Time" tab
#define IDH_PC_CPGER_PerUserTimeLimit                      102810
#define IDH_PC_CPGER_PerUserTimeLimit_processuserfield     102820
#define IDH_PC_CPGER_PerUserTimeLimit_processusermaxtime   102830
#define IDH_PC_CPGER_PerGroupTimeLimit                     102840
#define IDH_PC_CPGER_PerUserTimeLimit_groupuserfield       102850
#define IDH_PC_CPGER_PerUserTimeLimit_groupusermaxtime     102860
#define IDH_PC_CPGER_PerUserTimeLimit_groupuserterminate   102870
#define IDH_PC_CPGER_PerUserTimeLimit_groupusereport       102880

// process group execution rule "Advanced" tab
#define IDH_PC_CPGER_EndProcessGroupWhenNoProcess          102910
#define IDH_PC_CPGER_DieOnUnhandledExceptions              102920
#define IDH_PC_CPGER_SilentBreakaway                       102930
#define IDH_PC_CPGER_BreakawayOK                           102940


// process execution rule wizard - Identify 
#define IDH_PC_CPER_wizard_ProcessAlias                    201110
#define IDH_PC_CPER_wizard_Description                     201120
#define IDH_PC_CPER_wizard_ExecuteInGroup                  201130
#define IDH_PC_CPER_wizard_ExecuteInGroup_Executewithin    201140

// process execution rule wizard - Affinity
#define IDH_PC_CPER_wizard_Affinity                        201310

// process execution rule wizard - Priority
#define IDH_PC_CPER_wizard_Priority                        201410
#define IDH_PC_CPER_wizard_Priority_ApplyPriority_Real     201420
#define IDH_PC_CPER_wizard_Priority_ApplyPriority_High     201430
#define IDH_PC_CPER_wizard_Priority_ApplyPriority_Above    201440
#define IDH_PC_CPER_wizard_Priority_ApplyPriority_Normal   201450
#define IDH_PC_CPER_wizard_Priority_ApplyPriority_Below    201460
#define IDH_PC_CPER_wizard_Priority_ApplyPriority_Low      201470

// process execution rule wizard - Memory(Working Set)
#define IDH_PC_CPER_wizard_WorkingSet                      201510
#define IDH_PC_CPER_wizard_WorkingSet_minfield             201520
#define IDH_PC_CPER_wizard_WorkingSet_Minimum              201530
#define IDH_PC_CPER_wizard_WorkingSet_maxfield             201540
#define IDH_PC_CPER_wizard_WorkingSet_Maximum              201550


// process group execution rule wizard - Identity
#define IDH_PC_CPGER_wizard_GroupName                      202010
#define IDH_PC_CPGER_wizard_Description                    202020

// process group execution rule wizard - Process Count
#define IDH_PC_CPGER_wizard_ProcessCount                   202025
#define IDH_PC_CPGER_wizard_ProcessCount_apply_maxnumfield 202035
#define IDH_PC_CPGER_wizard_ProcessCount_apply_maxnum      202045

// process group execution rule wizard - Affinity
#define IDH_PC_CPGER_wizard_Affinity                       202310

// process group execution rule wizard - Priority
#define IDH_PC_CPGER_wizard_Priority                       202410
#define IDH_PC_CPGER_wizard_Priority_apply_Real            202420
#define IDH_PC_CPGER_wizard_Priority_apply_High            202430
#define IDH_PC_CPGER_wizard_Priority_apply_Above           202440
#define IDH_PC_CPGER_wizard_Priority_apply_Normal          202450
#define IDH_PC_CPGER_wizard_Priority_apply_Below           202460
#define IDH_PC_CPGER_wizard_Priority_apply_Low             202470

// process group execution rule wizard - Working Set
#define IDH_PC_CPGER_wizard_WorkingSet                     202510
#define IDH_PC_CPGER_wizard_WorkingSet_minmemfield         202520
#define IDH_PC_CPGER_wizard_WorkingSet_minmem              202530
#define IDH_PC_CPGER_wizard_WorkingSet_maxmemfield         202540
#define IDH_PC_CPGER_wizard_WorkingSet_maxmem              202550

// process group execution rule wizard - Committed Memory
#define IDH_PC_CPGER_wizard_ProcessCommittedMemory         202610
#define IDH_PC_CPGER_wizard_ProcessCommittedMemory_pcmmfld 202620
#define IDH_PC_CPGER_wizard_ProcessCommittedMemory_pcmaxme 202630
#define IDH_PC_CPGER_wizard_ProcessGroupCommittedMemory    202640
#define IDH_PC_CPGER_wizard_ProcessCommittedMemory_pgmmfld 202650
#define IDH_PC_CPGER_wizard_ProcessCommittedMemory_pgmaxme 202660

// process group execution rule wizard - Scheduling Class
#define IDH_PC_CPGER_wizard_SchedulingClass                202710
#define IDH_PC_CPGER_wizard_SchedulingClass_schedclassfld  202720

// process group execution rule wizard - Time 
#define IDH_PC_CPGER_wizard_PerUserTimeLimit               202810
#define IDH_PC_CPGER_wizard_PerUserTimeLimit_pumaxtimefld  202820
#define IDH_PC_CPGER_wizard_PerUserTimeLimit_pumaxtime     202830
#define IDH_PC_CPGER_wizard_PerGroupTimeLimit              202840
#define IDH_PC_CPGER_wizard_PerUserTimeLimitpgmaxtimefld   202850
#define IDH_PC_CPGER_wizard_PerUserTimeLimit_pgmaxtime     202860
#define IDH_PC_CPGER_wizard_PerUserTimeLimit_pgterminate   202870
#define IDH_PC_CPGER_wizard_PerUserTimeLimit_pgreport      202880

// process group execution rule wizard - Advanced
#define IDH_PC_CPGER_wizard_EndProcessGroupWhenNoProcess   202910
#define IDH_PC_CPGER_wizard_DieOnUnhandledExceptions       202920
// process group execution rule wizard - Advanced Breakaway
#define IDH_PC_CPGER_wizard_SilentBreakaway                202930
#define IDH_PC_CPGER_wizard_BreakawayOK                    202940
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\processpages.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    ProcessPages.cpp                                                         //
|                                                                                       //
|Description:  Implementation of Process pages                                          //
|                                                                                       //
|Created:      Paul Skoglund 08-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#include "stdafx.h"

#include "ProcessPages.h"
#include "ManagementRuleWizards.h"
#include "ManagementPages.h"  // helper functions

using std::list<tstring>;

static HRESULT ConstructProcDetailPropPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                            CProcDetailContainer *pContainer,
                                            const PCProcDetail &ProcDetail,
                                            const PCSystemParms &SystemParms,
                                            PCid hID);
#if _MSC_VER >= 1200
#pragma warning( push )
#endif
#pragma warning( disable : 4800 ) //warning C4800: 'unsigned long' : forcing value to bool 'true' or 'false' (performance warning)

CProcessIDPage::CProcessIDPage(int nTitle, CProcDetailContainer *pContainer, list<tstring> *jobnames) :
    CMySnapInPropertyPageImpl<CProcessIDPage>(nTitle), 
    m_pProcContainer(pContainer), m_pJobNames(jobnames),
    m_bName(_T("")), m_bComment(_T("")), m_bJob(_T(""))
{
  ASSERT(sizeof(PageFields.on) == sizeof(PageFields));

  PageFields.on   = 0;
  m_bReadOnly     = FALSE;

  m_JobChk = FALSE;
  m_psp.dwFlags |= PSP_HASHELP;

  m_pProcContainer->AddRef();
}

CProcessIDPage::~CProcessIDPage()
{
  m_pProcContainer->Release();
	if (m_pJobNames)
		delete m_pJobNames;
}


LRESULT CProcessIDPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	CComBSTR bTitle;

	PropSheet_SetTitle( GetParent(), PSH_PROPTITLE, FormatSheetTitle(bTitle, m_bName, m_pProcContainer->GetConnectionInfo()));

  UpdateData(FALSE);

  bHandled = FALSE;

  // Setting focus when a property page does not work...

	return TRUE;  // Let the system set the focus
}

LRESULT CProcessIDPage::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HELPINFO *phi = (HELPINFO*) lParam;
	if (phi && phi->iContextType == HELPINFO_WINDOW)
	{
    IDCsToIDHs HelpMap[] = {{IDC_NAME,             HELP_PROCID_NAME}, 
                            {IDC_COMMENT,          HELP_PROCID_COMMENT},
                            {IDC_APPLYGROUP_FRAME, HELP_PROCID_APPLYGROUP_FRAME},
                            {IDC_JOBMEMBER_CHK,    HELP_PROCID_APPLYGROUP_CHK},
                            {IDC_JOB_LIST,         HELP_PROCID_JOB_LIST},
                            {0,0} };

    ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap);
    
		return TRUE;
	}
	bHandled = FALSE;
	return FALSE;
}

BOOL CProcessIDPage::OnHelp()
{
	MMCPropertyHelp(const_cast<TCHAR*>(HELP_ru_proc_name));
	return TRUE;
}

BOOL CProcessIDPage::Validate(BOOL bSave)
{
  CComBSTR bName;
  CComBSTR bComment;
  CComBSTR bJob;
  bool bChecked = (BST_CHECKED == IsDlgButtonChecked(IDC_JOBMEMBER_CHK));
 
  if (!GetDlgItemText( IDC_NAME, bName.m_str ) ||
    !IsValidName(bName, FALSE) )
  {
    HWND hWndCtl = GetDlgItem(IDC_NAME);
		if(hWndCtl)
      ::SetFocus(hWndCtl);

    ITEM_STR strOut;
    LoadStringHelper(strOut, IDS_JOBNAME_WARNING);
    MessageBox(strOut, NULL, MB_OK | MB_ICONWARNING);

    return FALSE;
  }

  if (!GetDlgItemText(IDC_COMMENT, bComment.m_str))
    bComment = _T("");
  if (bComment.Length() > RULE_DESCRIPTION_LEN)
  {
    HWND hWndCtl = GetDlgItem(IDC_COMMENT);
		if(hWndCtl)
      ::SetFocus(hWndCtl);
    MessageBeep(MB_ICONASTERISK);
    return FALSE;
  }

	if (!GetDlgItemText( IDC_JOB_LIST, bJob.m_str) )
		bJob = _T("");
  if (!IsValidName(bJob, !bChecked))
  {
    HWND hWndCtl = NULL;
    if (bChecked)
      hWndCtl = GetDlgItem(IDC_JOB_LIST);
    else 
      hWndCtl = GetDlgItem(IDC_JOBMEMBER_CHK);

		if(hWndCtl)
      ::SetFocus(hWndCtl);

    ITEM_STR strOut;
    LoadStringHelper(strOut, IDS_JOBNAME_WARNING);
    MessageBox(strOut, NULL, MB_OK | MB_ICONWARNING);

    return FALSE;
  }

	if (bSave)
	{
		// everything validated so save 
    _tcscpy(m_pProcContainer->m_new.base.mgmtParms.description, bComment);
		_tcscpy(m_pProcContainer->m_new.base.memberOfJobName,       bJob);
    SetMGMTFlag(m_pProcContainer->m_new.base.mgmtParms.mFlags, PCMFLAG_APPLY_JOB_MEMBERSHIP, bChecked);
	}

  return TRUE;
}


BOOL CProcessIDPage::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
		return Validate(TRUE);
  }
  else
  {
		if (m_pJobNames)
		{
			list<tstring>::const_iterator i;
			for (i = (*m_pJobNames).begin(); i != (*m_pJobNames).end(); i++)
				SendDlgItemMessage(IDC_JOB_LIST, CB_ADDSTRING, 0, (LPARAM) (*i).c_str() );
		}

    VERIFY(SetDlgItemText( IDC_NAME, m_bName.m_str ));
		SendDlgItemMessage( IDC_NAME,     EM_SETLIMITTEXT, PROC_NAME_LEN, 0);

    VERIFY(SetDlgItemText( IDC_COMMENT, m_bComment.m_str ));
    SendDlgItemMessage( IDC_COMMENT,   EM_SETLIMITTEXT,  RULE_DESCRIPTION_LEN, 0);

    VERIFY(SetDlgItemText( IDC_JOB_LIST,  m_bJob.m_str ));
		SendDlgItemMessage( IDC_JOB_LIST, CB_LIMITTEXT,    JOB_NAME_LEN,  0);

    DisableControl(IDC_NAME);

    CheckDlgButton(IDC_JOBMEMBER_CHK, m_JobChk ? BST_CHECKED : BST_UNCHECKED);

    if (m_bReadOnly || !m_JobChk)
      DisableControl(IDC_JOB_LIST);

    if (m_bReadOnly)
    {
      int ids[] = { IDC_NAME, IDC_COMMENT, IDC_JOBMEMBER_CHK, 0 };

      for (int i = 0; ids[i]; i++)
        DisableControl(i);
    }

    return TRUE;
  }
}

LRESULT CProcessIDPage::OnEditChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  CComBSTR bStr;

  switch (wID) {
  case IDC_COMMENT:
    if (wNotifyCode == EN_CHANGE)
    {
      if (! GetDlgItemText(wID, bStr.m_str) )
        bStr = _T("");
      PageFields.Fields.comment = (0 != _tcscmp(bStr, m_bComment));

      SetModified(PageFields.on);
    }
    break;
  case IDC_JOB_LIST:
    if (wNotifyCode == CBN_EDITCHANGE)
	  {
		  // GetDlgItemText returns FALSE, and doesn't create an empty 
      if (! GetDlgItemText(wID, bStr.m_str) )
        bStr = _T("");
      PageFields.Fields.jobName = (0 != _tcscmp(bStr, m_bJob));
  
		  SetModified(PageFields.on);
	  }

	  // caution: CBN_CLOSEUP doesn't get sent when the curser keys are use
    else if (wNotifyCode == CBN_SELCHANGE)
	  {
		  LRESULT nSel = SendDlgItemMessage(IDC_JOB_LIST, CB_GETCURSEL, 0, 0);

		  if (nSel >= 0 && CB_ERR != nSel)
		  {
			  TCHAR newjob[2*JOB_NAME_LEN+2];

			  LRESULT nLen = SendDlgItemMessage(IDC_JOB_LIST, CB_GETLBTEXTLEN, nSel, 0);

			  if (nLen > 0 && CB_ERR != nLen && nLen < (ARRAY_SIZE(newjob) -1) )
			  {
				  if ( SendDlgItemMessage(IDC_JOB_LIST, CB_GETLBTEXT, nSel, (LPARAM) &newjob) > 0)
					  PageFields.Fields.jobName = (0 != _tcscmp(newjob, m_bJob));
			  }  
		  }
		  SetModified(PageFields.on);
	  }
    break;
  default:
    break;
  }
  bHandled = FALSE;
  return 0;
}

LRESULT CProcessIDPage::OnJobChk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID == IDC_JOBMEMBER_CHK )
  {
    bool checked = (BST_CHECKED == IsDlgButtonChecked(IDC_JOBMEMBER_CHK));
    PageFields.Fields.jobChk = (m_JobChk != checked);

  	::EnableWindow(GetDlgItem(IDC_JOB_LIST), checked);

		SetModified(PageFields.on);
  }

  bHandled = FALSE;
  return 0;
}

BOOL CProcessIDPage::OnApply()
{
  if (m_bReadOnly || !PageFields.on)  
    return TRUE;

  if (m_pProcContainer->Apply( GetParent() ))
	{
    PageFields.on = 0;
    m_bComment = m_pProcContainer->m_new.base.mgmtParms.description;
		m_bJob     = m_pProcContainer->m_new.base.memberOfJobName;
    m_JobChk   = (m_pProcContainer->m_new.base.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP);
    return TRUE; 
	}

  return FALSE;
}


///////////////////////////////////////////////////////////////////////////
//  Unmanaged Procees Page Implementation

CProcessUnmanagedPage::CProcessUnmanagedPage(int nTitle, CNewProcDetailContainer *pContainer, const PCSystemParms sysParms, list<tstring> *jobnames) 
    : CMySnapInPropertyPageImpl<CProcessUnmanagedPage>(nTitle), 
    m_pProcContainer(pContainer), m_SystemParms(sysParms), m_bName(_T("")), m_pJobNames(jobnames)
{
  m_bReadOnly = FALSE;
  m_psp.dwFlags |= PSP_HASHELP;

  m_pProcContainer->AddRef();
}

CProcessUnmanagedPage::~CProcessUnmanagedPage()
{
	if (m_pJobNames)
		delete m_pJobNames;

  m_pProcContainer->Release();
}


LRESULT CProcessUnmanagedPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	CComBSTR bTitle;

	PropSheet_SetTitle( GetParent(), PSH_PROPTITLE, FormatSheetTitle(bTitle, m_bName, m_pProcContainer->GetConnectionInfo() ));

  UpdateData(FALSE);

  bHandled = FALSE;

  // Setting focus when a property page does not work...

	return TRUE;  // Let the system set the focus
}

LRESULT CProcessUnmanagedPage::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HELPINFO *phi = (HELPINFO*) lParam;
	if (phi && phi->iContextType == HELPINFO_WINDOW)
	{
    IDCsToIDHs HelpMap[] = {{IDC_NAME,             HELP_PROCDEF_NAME}, 
                            {IDC_ADD,              HELP_PROCDEF_ADD},
                            {0,0} };

    ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap);
    
		return TRUE;
	}
	bHandled = FALSE;
	return FALSE;
}

BOOL CProcessUnmanagedPage::OnHelp()
{
	MMCPropertyHelp(const_cast<TCHAR*>(HELP_ru_proc));
	return TRUE;
}

LRESULT CProcessUnmanagedPage::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wNotifyCode != BN_CLICKED || wID != IDC_ADD)
  {
    bHandled = FALSE;
    return 1;
  }

  PCProcDetail  ProcDetail = { 0 };

  PROC_NAME     pname;

  _tcscpy(pname, m_bName);

	BOOL rc = FALSE;

	if ( m_pJobNames )
		rc = ProcRuleWizard(IDS_PRULE_DEFINE, *m_pJobNames, ProcDetail, m_SystemParms, &pname);
	else
	{
		list<tstring> jobs;
		rc = ProcRuleWizard(IDS_PRULE_DEFINE, jobs, ProcDetail, m_SystemParms, &pname);
	}

  if (rc)
  {
    m_pProcContainer->m_new = ProcDetail;

    ::PostMessage(GetParent(), PSM_PRESSBUTTON, (WPARAM) PSBTN_OK, 0);

    // post ad ok button press...

  }
  return 0;
}

BOOL CProcessUnmanagedPage::Validate(BOOL bSave)
{
	return TRUE;
}

BOOL CProcessUnmanagedPage::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
    return Validate(TRUE);
  }
  else
  {
		// SendDlgItemMessage( IDC_NAME, EM_SETLIMITTEXT, PROC_NAME_LEN, 0);

    VERIFY(SetDlgItemText( IDC_NAME, m_bName.m_str ));
    
    DisableControl(IDC_NAME);

    if (m_bReadOnly)
    {
      int ids[] = { IDC_ADD, 0 };

      for (int i = 0; ids[i]; i++)
        DisableControl(i);
    }

    return TRUE;
  }
}

BOOL CProcessUnmanagedPage::OnApply()
{
  if (m_bReadOnly)  
    return TRUE;

  if ( m_pProcContainer->Apply(GetParent()) )
    return TRUE;

	return FALSE;
}


// Property Page Helper functions...

HRESULT CreatePropertyPagesForProcListItem( const PCProcListItem &ProcListItem,
                                              LPPROPERTYSHEETCALLBACK lpProvider,
                                              LONG_PTR handle,
                                              CBaseNode *BaseNodePtr )
{
  if ( ProcListItem.lFlags & PCLFLAG_IS_DEFINED )
  {
    return CreatePropertyPagesForProcDetail(ProcListItem.procName, lpProvider, handle, BaseNodePtr);
  }

  PCid hID = BaseNodePtr->GetPCid();
  PCSystemInfo sysInfo;

  if (!hID ||
      !PCGetServiceInfo(hID, &sysInfo, sizeof(sysInfo)) )
  {
    BaseNodePtr->ReportPCError();
    return S_OK;
  }

 	COMPUTER_CONNECTION_INFO   ConnInfo;
	BaseNodePtr->GetComputerConnectionInfo(ConnInfo);

  PCProcDetail ProcDetail = { 0 };
  _tcscpy(ProcDetail.base.procName, ProcListItem.procName);

  CNewProcDetailContainer *pContainer = new CNewProcDetailContainer(ProcDetail, BaseNodePtr, handle, hID, ConnInfo, 0, FALSE, -1);
  if (pContainer)
  {
    CProcessUnmanagedPage *pPage = new CProcessUnmanagedPage(NULL, pContainer, sysInfo.sysParms, GetGrpNameList(hID));
    if (pPage)
    {
      pPage->m_bName = ProcListItem.procName;
      lpProvider->AddPage(pPage->Create());
    }
    pContainer->Release();
    pContainer = NULL;
  }

	return S_OK;
}

HRESULT CreatePropertyPagesForProcDetail( const PROC_NAME &procName,                                                              
                                            LPPROPERTYSHEETCALLBACK lpProvider,
                                            LONG_PTR handle,
                                            CBaseNode *BaseNodePtr ) 
{
  PCid hID = BaseNodePtr->GetPCid();
	if (!hID)
	{
    BaseNodePtr->ReportPCError();
    return S_OK;
  }

	COMPUTER_CONNECTION_INFO   ConnInfo;
	BaseNodePtr->GetComputerConnectionInfo(ConnInfo);

  PCSystemInfo sysInfo;

 	list<tstring> jobs;
  PCProcDetail ProcDetail = { 0 };
  _tcscpy(ProcDetail.base.procName, procName);

  PCINT32 nUpdateCtr = 0;

  if (!PCGetProcDetail ( hID, &ProcDetail, sizeof(ProcDetail), &nUpdateCtr) ||
      !PCGetServiceInfo( hID, &sysInfo, sizeof(sysInfo)) )  // || !GetGrpNameList  ( hID, jobs) )
  {
    BaseNodePtr->ReportPCError();
    return S_OK;
  }

  CProcDetailContainer *pContainer = new CProcDetailContainer(ProcDetail, BaseNodePtr, handle, hID, ConnInfo, nUpdateCtr, FALSE, -1);
  if (pContainer)
  {
    ConstructProcDetailPropPages(lpProvider, pContainer, ProcDetail, sysInfo.sysParms, hID);
    pContainer->Release();
    pContainer = NULL;
  }

	return S_OK;
}


HRESULT ConstructProcDetailPropPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                     CProcDetailContainer *pContainer,
                                     const PCProcDetail &ProcDetail,
                                     const PCSystemParms &SystemParms,
                                     PCid hID)
{
  CProcessIDPage *pPage = new CProcessIDPage(NULL, pContainer, GetGrpNameList(hID));
  if (pPage)
  {
    pPage->m_bName    = ProcDetail.base.procName;    
    pPage->m_bComment = ProcDetail.base.mgmtParms.description;    
    pPage->m_JobChk   = (ProcDetail.base.mgmtParms.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP);
    pPage->m_bJob     = ProcDetail.base.memberOfJobName;

    lpProvider->AddPage(pPage->Create());
  }

  CMGMTAffinityPage *pPage2 = new CMGMTAffinityPage(NULL, pContainer, SystemParms.processorMask);
  if (pPage2)
  {
    pPage2->m_affinitychk = (ProcDetail.base.mgmtParms.mFlags & PCMFLAG_APPLY_AFFINITY);
    pPage2->m_affinity    = ProcDetail.base.mgmtParms.affinity;

    lpProvider->AddPage(pPage2->Create());
  }

  CMGMTPriorityPage *pPage3 = new CMGMTPriorityPage(NULL, pContainer);
  if (pPage3)
  {
    pPage3->m_prioritychk = (ProcDetail.base.mgmtParms.mFlags & PCMFLAG_APPLY_PRIORITY);
    pPage3->m_priority    = ProcDetail.base.mgmtParms.priority;

    lpProvider->AddPage(pPage3->Create());
  }

    CMGMTMemoryPage *pPage4 = new CMGMTMemoryPage(NULL, pContainer);
  if (pPage4)
  {
    pPage4->m_WSchk       = (ProcDetail.base.mgmtParms.mFlags & PCMFLAG_APPLY_WS_MINMAX);
    pPage4->m_minWS       = ProcDetail.base.mgmtParms.minWS;
    pPage4->m_maxWS       = ProcDetail.base.mgmtParms.maxWS;

    lpProvider->AddPage(pPage4->Create());
  }

  return S_OK;
}
#if _MSC_VER >= 1200
#pragma warning( pop )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\rootpages.h ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    RootPages.h                                                              //
|                                                                                       //
|Description:  Property page definitions for the root node                              //
|                                                                                       //
|Created:      Paul Skoglund 10-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#include "Globals.h"
#include "ppage.h"
#include "version.h"
#include "container.h"


class CVersion;

class CRootWizard1 :
	public CMySnapInPropertyWizardImpl<CRootWizard1>
{
	public:
		CRootWizard1(WIZ_POSITION pos, int nTitle);

		enum { IDD               = IDD_SNAPIN_ADD_WIZ1       };
    enum { ID_HeaderTitle    = IDS_ADDSNAPIN_HDRTITLE    };
    enum { ID_HeaderSubTitle = IDS_ADDSNAPIN_HDRSUBTITLE };

		BEGIN_MSG_MAP(CRootWizard1)
		  MESSAGE_HANDLER(WM_HELP,       OnWMHelp)
			CHAIN_MSG_MAP(CMySnapInPropertyWizardImpl<CRootWizard1>)
		END_MSG_MAP()

  	LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

  	BOOL OnHelp();
};

class CRootWizard2 :
	public CMySnapInPropertyWizardImpl<CRootWizard2>
{
	public:
		CRootWizard2(WIZ_POSITION pos, int nTitle, CBaseNode* pNode);
		~CRootWizard2();

		enum { IDD               = IDD_SNAPIN_ADD_WIZ2            };
    enum { ID_HeaderTitle    = IDS_SELECTCOMPUTER_HDRTITLE    };
    enum { ID_HeaderSubTitle = IDS_SELECTCOMPUTER_HDRSUBTITLE };

		BEGIN_MSG_MAP(CRootWizard2)
			MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		  MESSAGE_HANDLER(WM_HELP,       OnWMHelp)
			COMMAND_HANDLER(IDC_BROWSE, BN_CLICKED, OnBrowse)
			COMMAND_RANGE_HANDLER(IDC_LOCAL_RD, IDC_ANOTHER_RD, OnConnectType)
			CHAIN_MSG_MAP(CMySnapInPropertyWizardImpl<CRootWizard2>)
		END_MSG_MAP()

		LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  	LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
		LRESULT OnBrowse(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
		LRESULT OnConnectType(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

		BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
		BOOL OnWizardFinish();

   	BOOL OnHelp();

	private:
		BOOL bLocal;
		TCHAR Computer[SNAPIN_MAX_COMPUTERNAME_LENGTH + 1];

		CBaseNode  *m_pNode;
};



class CRootGeneralPage :
	public CMySnapInPropertyPageImpl<CRootGeneralPage>
{
	public :
		CRootGeneralPage(int nTitle);
		~CRootGeneralPage();

		enum { IDD = IDD_SNAPIN_GENERAL_PAGE };
		BEGIN_MSG_MAP(CRootGeneralPage)
			MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
      MESSAGE_HANDLER(WM_HELP,       OnWMHelp)
			CHAIN_MSG_MAP(CMySnapInPropertyPageImpl<CRootGeneralPage>)
		END_MSG_MAP()

		LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  	LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  	BOOL OnHelp();
		BOOL OnSetActive();
};

class CRootVersionPage :
	public CMySnapInPropertyPageImpl<CRootVersionPage>
{
	public :
		CRootVersionPage(int nTitle);

		enum { IDD = IDD_SNAPIN_VERSION_PAGE };
		BEGIN_MSG_MAP(CRootVersionPage)
			MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)	
      MESSAGE_HANDLER(WM_HELP,       OnWMHelp)
      COMMAND_HANDLER(IDC_ITEMS, LBN_SELCHANGE, OnItemsSelection)
			CHAIN_MSG_MAP(CMySnapInPropertyPageImpl<CRootVersionPage>)
		END_MSG_MAP()

		LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);	
  	LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
		LRESULT OnItemsSelection(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

		BOOL OnSetActive();
  	BOOL OnHelp();
	private:
		CVersion VersionObj;
};


class CRootServicePage :
	public CMySnapInPropertyPageImpl<CRootServicePage>
{
	public :
		CRootServicePage(int nTitle, CServicePageContainer *pContainer);
		~CRootServicePage();

		enum { IDD = IDD_SERVICE_INFO_PAGE };
		BEGIN_MSG_MAP(CRootServicePage)
			MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
      MESSAGE_HANDLER(WM_HELP,       OnWMHelp)
			COMMAND_HANDLER(IDC_INTERVAL,    EN_CHANGE, OnEditChange)
      COMMAND_HANDLER(IDC_COMMTIMEOUT, EN_CHANGE, OnEditChange)
      NOTIFY_HANDLER (IDC_COMMTIMEOUT_SPIN, UDN_DELTAPOS, OnSpin)
      COMMAND_HANDLER(IDC_ITEMS, LBN_SELCHANGE, OnItemsSelection)
			CHAIN_MSG_MAP(CMySnapInPropertyPageImpl<CRootServicePage>)
		END_MSG_MAP()

		LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  	LRESULT OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	  LRESULT OnEditChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSpin(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnItemsSelection(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

		BOOL OnSetActive();
  	BOOL OnHelp();

		BOOL OnKillActive()      { return Validate(TRUE); }
		BOOL OnApply();

		BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
		BOOL Validate(BOOL bSave = FALSE);

	  void SetReadOnly()          { m_bReadOnly = TRUE;}

	public:
		PCSystemInfo PCInfo;

	private:
    CServicePageContainer    *m_pContainer;

		BOOL                      m_bReadOnly;

	  union {
			struct
			{
				int manageinterval : 1;
        int timeoutValueMs : 1;
			} Fields;
			int on;
		} PageFields;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\rootfolder.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    RootFolder.cpp                                                           //
|                                                                                       //
|Description:  Class implemention for the root node                                     //
|                                                                                       //
|Created:      Paul Skoglund 07-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/


#include "StdAfx.h"

#include "BaseNode.h"
#include "ProcConLibMsg.h"
#include "RootPages.h"

#include "Container.h"


using std::list<CBaseNode *>;

const GUID         CRootFolder::m_GUID   =   {0xff9baf5f,0x064e,0x11d2,{0x80, 0x14,0x00,0x10,0x4b,0x9a,0x31,0x06} };
const TCHAR *const CRootFolder::m_szGUID = _T("{ff9baf5f-064e-11d2-8014-00104b9a3106}");


///////////////////////////////////////////////////////////////////////////
// CRootFolder

const CONTEXTMENUITEMBYID CRootFolder::TaskMenuItems[] = 
{ 
  { IDS_ROOT_CONNECT, ID_ROOT_CONNECT, ID_ROOT_CONNECT, CCM_INSERTIONPOINTID_PRIMARY_TOP },
  { 0,                0,               0,               0 },
};

CRootFolder::CRootFolder() : CBaseNode(ROOT_NODE), m_ID(0), m_ParentID(0), m_NodeList(0), 
                             m_bUseLocalComputer(TRUE), 
														 m_bDirty(FALSE), 
														 m_hPC(0), m_PCLastError(0), m_ipConsole2(NULL)
{
  LoadStringHelper(m_name, IDS_ROOT_FOLDER);
  m_longname = m_name;

  //LoadStringHelper(m_TypeDescriptionStr, IDS_TYPE_DESCRIPTION);
  LoadStringHelper(m_DescriptionStr,     IDS_DESCRIPTION);

  memset(m_Computer, 0, sizeof(m_Computer));
}

CRootFolder::~CRootFolder()
{
  ATLTRACE( _T("~CRootFolder <%s>\n"), GetNodeName() );

  FreeNodes();
  if (m_hPC)
    VERIFY( PCClose(m_hPC) );

  ATLTRACE( _T("~CRootFolder end\n"));
}

void CRootFolder::FreeNodes()
{
  ATLTRACE( _T("CRootFolder::FreeNodes()\n"));
  for (list<CBaseNode *>::iterator i = m_NodeList.begin(); i != m_NodeList.end(); ++i)
  {
    (*i)->Release();
    //delete *i;
  }  
  m_NodeList.clear();
}

const PCid CRootFolder::GetPCid()
{
  ASSERT(!GetParentNode());

  /*
  if (
      // retry code now in the ProcConLib/service
      m_PCLastError == ERROR_NO_DATA            ||
      m_PCLastError == ERROR_BROKEN_PIPE        ||
      m_PCLastError == ERROR_BAD_PIPE           ||
      m_PCLastError == ERROR_PIPE_NOT_CONNECTED ||
      m_PCLastError == ERROR_NETNAME_DELETED 
      )
  {
    m_PCLastError = 0;
    if (m_hPC)
      VERIFY( PCClose(m_hPC));
    m_hPC = 0;
  }
  */

  if (m_hPC)
    return m_hPC;

  ATLTRACE(_T("Opening %s.\n"), GetComputerDisplayName());

  m_hPC = PCOpen(m_bUseLocalComputer ? NULL : GetComputerName(), NULL, COM_BUFFER_SIZE);

  if (!m_hPC)
  {
    m_PCLastError = PCGetLastError(m_hPC);
    ATLTRACE(_T("Unable to open connection to %s, Error(0x%lX).\n"),
      GetComputerDisplayName(), m_PCLastError );
  }

  return m_hPC;
}

BOOL CRootFolder::ReportPCError(PCULONG32 nLastError)
{
	TCHAR *pMsgBuf = FormatErrorMessageIntoBuffer(nLastError);

  if ( pMsgBuf )
  {
    int ret = 0;
    ATLTRACE( (TCHAR *) pMsgBuf );
    ATLTRACE( _T("\n") );

    if (m_ipConsole2)
      m_ipConsole2->MessageBox(pMsgBuf, NULL, MB_OK | MB_ICONWARNING, &ret);

    LocalFree(pMsgBuf);

    return TRUE;
  }

  ATLTRACE(_T("Message Problem: Error (0x%lX).\n"), nLastError );

  return FALSE;
}

BOOL CRootFolder::ReportPCError()
{
  return ReportPCError( GetLastPCError() );
}

PCULONG32 CRootFolder::GetLastPCError()
{
  if (m_hPC) // don't clear an open error...
    m_PCLastError = PCGetLastError(m_hPC);

  return m_PCLastError;
}

void CRootFolder::GetComputerConnectionInfo(COMPUTER_CONNECTION_INFO &out)
{
  out.bLocalComputer = m_bUseLocalComputer;
	memcpy(out.RemoteComputer, m_Computer, sizeof(m_Computer));
}

void CRootFolder::SetComputerName(TCHAR Computer[SNAPIN_MAX_COMPUTERNAME_LENGTH + 1])
{
  Config((Computer[0] == 0), Computer);
}

void CRootFolder::Config(BOOL bUseLocal, TCHAR Computer[SNAPIN_MAX_COMPUTERNAME_LENGTH + 1])
{
  m_bDirty = TRUE;

  m_bUseLocalComputer = bUseLocal;
  memset(m_Computer, 0, sizeof(m_Computer));
  _tcsncpy(m_Computer, Computer, ARRAY_SIZE(m_Computer) - 1);

  // change the node's display name...
  m_longname = m_name;
  if (m_bUseLocalComputer)
  {
    ITEM_STR tempstr;
    LoadStringHelper(tempstr, IDS_LOCAL);
    m_machinedisplayname = tempstr;
  }
  else
  {
    m_machinedisplayname.reserve((SNAPIN_MAX_COMPUTERNAME_LENGTH + 3) * sizeof(TCHAR));
    m_machinedisplayname = _T(" (");
    m_machinedisplayname+= m_Computer;
    m_machinedisplayname+= _T(")");
  }
  m_longname += m_machinedisplayname;
  // finish change node name...

  if (m_hPC)
    VERIFY( PCClose(m_hPC));
  m_hPC = 0;
}

HRESULT CRootFolder::IsDirty() const
{
  if (m_bDirty)
    return S_OK;
  return S_FALSE;
}

HRESULT CRootFolder::Load(IStream *pStm)
{
  if (!pStm)
    return E_POINTER;

  ASSERT(sizeof(WCHAR) == sizeof(TCHAR));  // conversions need to go to single byte characters

  ULONG BytesRead = 0;
  WCHAR sIn[SNAPIN_MAX_COMPUTERNAME_LENGTH + 1] = { 0 };

  HRESULT hr = pStm->Read(sIn, sizeof(sIn), &BytesRead);

  if (hr == S_OK && BytesRead)
  {
    SetComputerName(sIn);
    m_bDirty = FALSE;
  }

//pStm->Release();

  return hr;
}

HRESULT CRootFolder::Save(IStream *pStm, BOOL fClearDirty)
{
  if (!pStm)
    return E_POINTER;

#ifndef _UNICODE
#error "need to convert output to unicode prior to writing to disk"
#endif
  ULONG BytesWritten = 0;

  HRESULT hr = pStm->Write(GetComputerName(), ((SNAPIN_MAX_COMPUTERNAME_LENGTH + 1) * sizeof(WCHAR)), &BytesWritten);

  if (hr == S_OK && fClearDirty)
    m_bDirty = FALSE;
  
//  pStm->Release();
  return hr;
}

HRESULT CRootFolder::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
  if (!pcbSize)
    return E_POINTER;

  (*pcbSize).LowPart = (SNAPIN_MAX_COMPUTERNAME_LENGTH + 1) * sizeof(WCHAR);
  (*pcbSize).HighPart = 0;

  return S_OK;
}

LPCTSTR CRootFolder::GetNodeName()
{ 
  if (!m_ParentID)
    return m_longname.c_str();
  else
    return m_name;
}

HRESULT CRootFolder::GetDisplayInfo(RESULTDATAITEM &ResultItem)
{
  if (ResultItem.bScopeItem)
  {
    if( ResultItem.mask & RDI_STR )
    {
			if (0 == ResultItem.nCol)
				ResultItem.str = const_cast<LPOLESTR>(GetNodeName());
      //else if (m_ParentID && 1 == ResultItem.nCol)
      //  ResultItem.Str = m_TypeDescriptionStr;
      else if (2 == ResultItem.nCol)
        ResultItem.str = m_DescriptionStr;
      else 
				ResultItem.str = _T("");
    }
    if (ResultItem.mask & RDI_IMAGE)
      ResultItem.nImage = sImage();
    return S_OK;
  }
  return E_UNEXPECTED;
}

LPCTSTR CRootFolder::GetComputerName() const
{
  return m_Computer;
}

LPCTSTR CRootFolder::GetComputerDisplayName() const
{ 
  return m_machinedisplayname.c_str();
}

HRESULT CRootFolder::OnHelpCmd(IDisplayHelp *ipDisplayHelp)
{
	if (!ipDisplayHelp)
		return E_UNEXPECTED;
  
	ipDisplayHelp->ShowTopic(const_cast<TCHAR *>(HELP_overview));

	return S_OK;
}

//IComponentData::Notify -- MNCN_EXPAND
HRESULT CRootFolder::OnParentExpand(
  BOOL         bExpanded,        // [in] TRUE is we are expanding
  HSCOPEITEM   hID,              // [in] Points to the HSCOPEITEM
  IConsoleNameSpace2 *ipConsoleNameSpace2
)
{
  ASSERT(ipConsoleNameSpace2);

  if(!ipConsoleNameSpace2)
    return E_UNEXPECTED; 

  if (bExpanded) 
  {
    ASSERT(m_NodeList.size() == 0);
    ASSERT(m_ID == 0);

    m_ParentID     = hID;

    SCOPEDATAITEM sdi = {0};
 		sdi.mask       =	SDI_STR       |
                      SDI_PARAM     |   // lParam is valid
				              SDI_IMAGE     |   // nImage is valid
				              SDI_OPENIMAGE |   // nOpenImage is valid
                      SDI_CHILDREN  |   // cChildren is valid
				              SDI_PARENT;  
    sdi.displayname = (LPOLESTR)MMC_CALLBACK;
    sdi.nImage      = sImage();
    sdi.nOpenImage  = sOpenImage();
    sdi.cChildren   = GetChildrenCount();
    sdi.lParam      = reinterpret_cast <LPARAM> (this);
    sdi.relativeID  = hID;
    HRESULT hr = ipConsoleNameSpace2->InsertItem(&sdi);
    if (hr == S_OK)
      m_ID = sdi.ID;    
  }

  return S_OK;  // return has no meaning to MMC 

} // end OnParentExpand()


//IComponentData::Notify -- MNCN_EXPAND
HRESULT CRootFolder::OnExpand(
  BOOL         bExpanded,        // [in] TRUE is we are expanding
  HSCOPEITEM   hID,              // [in] Points to the HSCOPEITEM
  IConsoleNameSpace2 *ipConsoleNameSpace2
)
{
  ASSERT(ipConsoleNameSpace2);

  if(!ipConsoleNameSpace2)
    return E_UNEXPECTED; 

  if (bExpanded) 
  {
    ASSERT(m_NodeList.size() == 0);
    ASSERT(m_ID == 0 || m_ID == hID);

    m_ID = hID;   // Cache the root node handle

    // 3/7/2001 (PAS)
    // around 2410 MMC behavior changed and the proccon folder icon 
    // wasn't always displayed correctly...the root node image used to be 
    // handled differently (ISnapinAbout::GetStaticFolderImage()) but 
    // possibly is now handled like other scope items.
    
    SCOPEDATAITEM sdi = {0};
 		sdi.mask        =	SDI_STR       |
				              SDI_IMAGE     |   // nImage is valid
				              SDI_OPENIMAGE;    // nOpenImage is valid
    sdi.ID          = hID;
    sdi.displayname = (LPOLESTR)MMC_CALLBACK;
    sdi.nImage      = sImage();
    sdi.nOpenImage  = sOpenImage();

    VERIFY( S_OK == ipConsoleNameSpace2->SetItem(&sdi) );
    VERIFY( S_OK == AddNodes(ipConsoleNameSpace2) );    
  }

  return S_OK;  // return has no meaning to MMC 

} // end OnExpand()

HRESULT CRootFolder::AddNodes(IConsoleNameSpace2 *ipConsoleNameSpace2)
{ 
  VERIFY( S_OK == AddNode(ipConsoleNameSpace2, new CRuleFolder(this)   ) );

	VERIFY( S_OK == AddNode(ipConsoleNameSpace2, new CProcessFolder(this) ) );

	VERIFY( S_OK == AddNode(ipConsoleNameSpace2, new CJobFolder(this)     ) );

  return S_OK; 
}

HRESULT CRootFolder::AddNode(IConsoleNameSpace2 *ipConsoleNameSpace2, CBaseNode *pSubNode)
{
  HRESULT  hr = S_OK;

  SCOPEDATAITEM sdi = {0};

  if (!pSubNode)
    return E_OUTOFMEMORY;
 
  // Place folder into the scope pane
  sdi.mask        = SDI_STR       |   // Displayname is valid
				            SDI_PARAM     |   // lParam is valid
				            SDI_IMAGE     |   // nImage is valid
				            SDI_OPENIMAGE |   // nOpenImage is valid
                    SDI_CHILDREN  |   // cChildren is valid
				            SDI_PARENT;
  
  sdi.displayname = (LPOLESTR)MMC_CALLBACK;
  sdi.nImage      = pSubNode->sImage();
  sdi.nOpenImage  = pSubNode->sOpenImage();
  //sdi.nState 
  sdi.cChildren   = pSubNode->GetChildrenCount();
  sdi.lParam      = reinterpret_cast <LPARAM> (pSubNode);
  sdi.relativeID  = m_ID;
  
  hr = ipConsoleNameSpace2->InsertItem( &sdi );

  if (SUCCEEDED(hr))
  {
    pSubNode->SetID(sdi.ID);
    m_NodeList.push_front( pSubNode );
  }
  else
  {
    pSubNode->Release();
    //delete pSubNode;
  }

  return hr;
}

//IComponentData::Notify -- MNCN_REMOVE_CHILDREN
HRESULT CRootFolder::OnParentRemoveChildren(HSCOPEITEM hID)
{
  ASSERT(hID == m_ParentID);
  if (hID == m_ParentID)
    return OnRemoveChildren(m_ID);
  return E_UNEXPECTED;
}

HRESULT CRootFolder::OnRemoveChildren(HSCOPEITEM hID)
{
  ASSERT(m_ID == hID);

  FreeNodes();
  m_ID = 0;
  return S_OK;
}

HRESULT CRootFolder::AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long * pInsertionAllowed)
{
  HRESULT hr = S_OK;

  // 10/2/1998 PAS
  // when the snapin is first loaded and the root node has not yet been expanded or 
  // selected than we haven't yet been able to save the ID.
  // The right click context menu can be invoked when the node has no yet been expanded or
  // selected, if we haven't yet gotten the ID we have no way to change the selection 
  // node so the menu command can't be supported yet.
  if (!m_ID)
    return S_FALSE;

  ITEM_STR name;
  ITEM_STR status;
  
  if( *pInsertionAllowed & CCM_INSERTIONALLOWED_TOP )
  {
    CONTEXTMENUITEM m = { 0 };
    for (const CONTEXTMENUITEMBYID *M = TaskMenuItems; M->lCommandID; M++)
    {
      m.strName           = const_cast<TCHAR *>(LoadStringHelper(name,   M->strNameID));
      m.strStatusBarText  = const_cast<TCHAR *>(LoadStringHelper(status, M->strStatusBarTextID));
			m.lCommandID        = M->lCommandID;
			m.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
			m.fFlags            = MF_ENABLED;
 		  //m.fSpecialFlags   = 0;		// currently always 0, initialized to 0

      if (m.lCommandID == ID_ROOT_CONNECT && m_ParentID)
        continue;

      hr = piCallback->AddItem(&m);

      if (FAILED(hr))
        break;
    }
  }

  if( *pInsertionAllowed & CCM_INSERTIONALLOWED_TASK )
  {
    CONTEXTMENUITEM m = { 0 };
    for (const CONTEXTMENUITEMBYID *M = TaskMenuItems; M->lCommandID; M++)
    {
      m.strName           = const_cast<TCHAR *>(LoadStringHelper(name,   M->strNameID));
      m.strStatusBarText  = const_cast<TCHAR *>(LoadStringHelper(status, M->strStatusBarTextID));
			m.lCommandID        = M->lCommandID;
      m.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
			m.fFlags            = MF_ENABLED;
 		  //m.fSpecialFlags   = 0;		// currently always 0, initialized to 0

      if (m.lCommandID == ID_ROOT_CONNECT && m_ParentID)
        continue;

      hr = piCallback->AddItem(&m);

      if (FAILED(hr))
        break;
    }
  }
  return hr;
}

HRESULT CRootFolder::OnMenuCommand(IConsole2 *ipConsole2, long nCommandID )
{
  HRESULT hr = S_FALSE;
  switch(nCommandID)
  {
    case ID_ROOT_CONNECT:
      ATLTRACE(_T("CRootFolder(%s)-OnMenuCommand Connect to another computer\n"), GetNodeName());
      hr = OnChangeComputerConnection();
      break;
    default:
      ATLTRACE(_T("CRootFolder(%s)-OnMenuCommand Unrecognized command 0x%lX\n"), GetNodeName(), nCommandID);
      break;
  }
  return hr; 
}

HRESULT CRootFolder::OnMenuCommand(IConsole2 *ipConsole2, long nCommandID, LPARAM Cookie)
{
  ATLTRACE(_T("CRootFolder(%s)-OnMenuCommand Unrecognized command 0x%lX\n"), GetNodeName(), nCommandID);
  return E_UNEXPECTED;
}

HRESULT CRootFolder::OnChangeComputerConnection()
{
  CRootWizard2 *pPage2 = new CRootWizard2(CRootWizard2::LASTANDONLY_PAGE, IDS_CONNECT_TITLE, this);
  if (!pPage2)
    return S_FALSE;
    
  PROPSHEETHEADER sheet;
	memset(&sheet, 0, sizeof(PROPSHEETHEADER));
  sheet.dwSize = sizeof(PROPSHEETHEADER);
  sheet.dwFlags = PSH_WIZARD | PSH_WIZARDCONTEXTHELP;
  sheet.hwndParent = ::GetActiveWindow();
  sheet.hInstance = _Module.GetResourceInstance();
  sheet.pszIcon = 0;
  sheet.pszCaption = 0;
  sheet.nPages = 1;
  sheet.nStartPage = 0;

#if USE_WIZARD97_WATERMARKS
  sheet.dwFlags        |= PSH_WIZARD97 | PSH_WATERMARK;
  sheet.pszbmWatermark  = MAKEINTRESOURCE(IDB_WATERMARK1);
#endif
#if USE_WIZARD97_HEADERS
  sheet.dwFlags        |= PSH_WIZARD97 | PSH_HEADER;
  sheet.pszbmHeader     = MAKEINTRESOURCE(IDB_HEADER1);
#endif

  HPROPSHEETPAGE hPages[1];

  hPages[0] = pPage2->Create();

  sheet.phpage = &hPages[0];
  sheet.pfnCallback = NULL;

  PropertySheet(&sheet);
  
  return S_OK;
}

// folder selection...
HRESULT CRootFolder::OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb)
{
  ASSERT(bScope);

  if (bSelect) 
  {
		// allow properties verb to work when context menu is used in scope or result pane
		VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE ) == S_OK);
    if (!bScope) // incase the rules are changed again leave !bScope test
    {
		  VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_OPEN, ENABLED, TRUE ) == S_OK);
		  VERIFY( ipConsoleVerb->SetDefaultVerb( MMC_VERB_OPEN ) == S_OK ); 
    }
  }
  return S_OK;
}

HRESULT CRootFolder::OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie)
{
  ASSERT(!bScope);

  if (bSelect) 
  {
		// allow properties verb to work when context menu is used in scope or result pane
		VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_PROPERTIES, ENABLED, TRUE ) == S_OK);

    // why this seems to be a meaningless test
    // changes between MMC 1.1 vs MMC 1.2 (as least in the documentation)
    //   as to whether bScope mean scope pane or scope item 
    //   leave this in for the time being
    if (!bScope) // incase the rules are changed again leave !bScope test
    {
		  VERIFY( ipConsoleVerb->SetVerbState( MMC_VERB_OPEN, ENABLED, TRUE ) == S_OK);
		  VERIFY( ipConsoleVerb->SetDefaultVerb( MMC_VERB_OPEN ) == S_OK ); 
    }
  }
  return S_OK;
}

HRESULT CRootFolder::QueryPagesFor()
{ 
  return S_OK;
}

HRESULT CRootFolder::OnCreatePropertyPages( LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle,  DATA_OBJECT_TYPES context)
{
  if (context == CCT_SNAPIN_MANAGER)
  {
    CRootWizard1 *pPage1 = new CRootWizard1(CRootWizard1::FIRST_PAGE, IDS_ADDSNAPIN_TITLE);
    CRootWizard2 *pPage2 = new CRootWizard2(CRootWizard2::LAST_PAGE,  IDS_ADDSNAPIN_TITLE,	this);
    if (!pPage1 || !pPage2)
      return S_FALSE;

    ASSERT(handle == NULL); // $$ behavior change, better see what's going on...
														// previously context of CCT_SNAPIN_MANAGER, the handle was always null so
			                      // ...access the the folder object directly was assumed to be a valid operation
      
    VERIFY(lpProvider->AddPage(pPage1->Create()) == S_OK);

    return lpProvider->AddPage(pPage2->Create());
  }
  else
  {
		COMPUTER_CONNECTION_INFO   ConnInfo;
		GetComputerConnectionInfo(ConnInfo);

    CRootGeneralPage *pPage1 = new CRootGeneralPage(NULL);
    if (pPage1)   
      lpProvider->AddPage(pPage1->Create());

    CRootVersionPage *pPage2 = new CRootVersionPage(NULL);
    if (pPage2)   
      lpProvider->AddPage(pPage2->Create());

		PCSystemInfo sysInfo; 

    PCid hID = GetPCid();

		if (PCGetServiceInfo( hID, &sysInfo, sizeof(sysInfo) ))
		{
      CServicePageContainer *pContainer = new CServicePageContainer(sysInfo.sysParms, this, handle, hID, ConnInfo, 0, TRUE, -1);
      if (pContainer)
      {
			  CRootServicePage *pPage3 = new CRootServicePage(NULL, pContainer);
			  if (pPage3)
			  {
				  pPage3->PCInfo = sysInfo;
				  lpProvider->AddPage(pPage3->Create());
			  }
        pContainer->Release();
        pContainer = NULL;
      }
		}
    else
    {
      VERIFY(S_OK == MMCFreeNotifyHandle(handle));
    }

    return S_OK;
  }
  return S_FALSE; 
}

HRESULT CRootFolder::OnPropertyChange(PROPERTY_CHANGE_HDR *pUpdate, IConsole2 *ipConsole2)
{
  ATLTRACE(_T("Service Info updated via property page...\n"));
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Snapin.rc
//
#define IDR_PROCCON                     101
#define IDS_PROCCON_SNAPIN_NAME         102
#define IDI_PROCCON                     110
#define IDI_PROCCONSERVICE              111
#define IDI_RULES                       112
#define IDI_ALIASRULES                  113
#define IDI_PROCRULES                   114
#define IDI_JOBRULES                    115
#define IDI_PROCESSES                   116
#define IDI_PROCHASRULE                 117
#define IDI_PROCNORULE                  118
#define IDI_JOBS                        119
#define IDI_JOBHASRULE                  120
#define IDI_JOBNORULE                   121
#define IDI_RARROW                      125
#define IDB_NODES_16x16                 141
#define IDB_NODES_32x32                 142
#define IDB_HEADER1                     143
#define IDB_WATERMARK1                  144
#define IDS_PROJNAME                    201
#define IDS_NRULE_INSERT                205
#define IDS_NRULE_MOVEUP                206
#define IDS_NRULE_MOVEDOWN              207
#define IDS_NRULE_EDIT                  208
#define IDS_NRULE_EDIT_PROPERTIES       209
#define IDS_NRULE_DEFINE_PROPERTIES     210
#define IDS_LOCAL                       211
#define IDS_ROOT_FOLDER                 212
#define IDS_RULES_FOLDER                213
#define IDS_NAMERULE_FOLDER             214
#define IDS_PROCESSRULE_FOLDER          215
#define IDS_JOBRULE_FOLDER              216
#define IDS_JOBS_FOLDER                 217
#define IDS_PROCESSES_FOLDER            218
#define IDS_MATCH_IMAGE                 219
#define IDS_MATCH_DIR                   220
#define IDS_MATCH_STRING                221
#define IDS_UNKNOWN                     222
#define IDS_TYPE_HDR                    223
#define IDS_MATCH_HDR                   224
#define IDS_PROCESS_ALIAS_HDR           225
#define IDS_JOB_HDR                     227
#define IDS_AFFINITY_HDR                228
#define IDS_PRIORITY_HDR                229
#define IDS_CPU_LIMIT_HDR               230
#define IDS_IMAGE_NAME_HDR              231
#define IDS_MINWS_HDR                   232
#define IDS_MAXWS_HDR                   233
#define IDS_NAME_HDR                    234
#define IDS_STATUS_HDR                  235
#define IDS_APPLY_JOB_HDR               236
#define IDS_APPLY_AFFINITY_HDR          237
#define IDS_APPLY_PRIORITY_HDR          238
#define IDS_APPLY_MINMAXWS_HDR          239
#define IDS_PROCESS_ALIAS_RULE_HDR      240
#define IDS_LOW                         241
#define IDS_BELOW_NORMAL                242
#define IDS_NORMAL                      243
#define IDS_ABOVE_NORMAL                244
#define IDS_HIGH                        245
#define IDS_REALTIME                    246
#define IDS_COMPUTER_PROMPT             247
#define IDS_PRULE_NEW                   248
#define IDS_PRULE_DEFINE                249
#define IDS_PROCVIEW_ALL                250
#define IDS_PROCVIEW_RUN                251
#define IDS_PROCVIEW_MANAGED            252
#define IDS_JRULE_NEW                   253
#define IDS_JRULE_DEFINE                254
#define IDS_ROOT_CONNECT                255
#define IDS_BETA                        256
#define IDS_DEBUG                       257
#define IDS_PATCHED                     258
#define IDS_PRIVATE                     259
#define IDS_SPECIAL                     260
#define IDS_INFERRED                    261
#define IDS_RUNNING                     262
#define IDS_YES                         263
#define IDS_NO                          264
#define IDS_JOBVIEW_ALL                 265
#define IDS_JOBVIEW_RUN                 266
#define IDS_JOBVIEW_MANAGED             267
#define IDS_RUNNING_PROCS               268
#define IDS_MANAGED_PROCS               269
#define IDS_RUNNING_JOBS                270
#define IDS_MANAGED_JOBS                271
#define IDS_APPLY_SCHEDULING_CLASS_HDR  272
#define IDS_SCHEDULING_CLASS_HDR        273
#define IDS_PID_HDR                     274
#define IDS_ACTIVE_PROCESS_COUNT_HDR    275
#define IDS_MANAGED                     276
#define IDS_PRULE_TOP                   277
#define IDS_JRULE_TOP                   278
#define IDS_DESCRIPTION                 279
#define IDS_AFFINITY_NOJOBWARNING       280
#define IDS_PRIORITY_NOJOBWARNING       281
#define IDS_DESCRIPTION_HDR             282
#define IDS_AFFINITY_JOBWARNING         283
#define IDS_PRIORITY_JOBWARNING         284
#define IDS_LOCAL_COMPUTER              285
#define IDS_ON                          286
#define IDS_PROCESS_CONTROL             287
#define IDS_JOB_OWNER_HDR               288
#define IDS_ENDPROCESS                  289
#define IDS_ENDJOB                      290
#define IDS_TIMEENTRY                   291
#define IDS_PROCESSALIAS_HDRTITLE       292
#define IDS_PROCESSALIAS_HDRSUBTITLE    293
#define IDS_GRPMEM_HDRTITLE             294
#define IDS_GRPMEM_HDRSUBTITLE          295
#define IDS_GRPNAME_HDRTITLE            296
#define IDS_GRPNAME_HDRSUBTITLE         297
#define IDS_AFFINITY_HDRTITLE           298
#define IDS_AFFINITY_HDRSUBTITLE        299
#define IDS_PRIORITY_HDRTITLE           300
#define IDS_PRIORITY_HDRSUBTITLE        301
#define IDS_SCHEDCLASS_HDRTITLE         302
#define IDS_SCHEDCLASS_HDRSUBTITLE      303
#define IDS_WSET_HDRTITLE               304
#define IDS_WSET_HDRSUBTITLE            305
#define IDS_CMEM_HDRTITLE               306
#define IDS_CMEM_HDRSUBTITLE            307
#define IDS_PROCCOUNT_HDRTITLE          308
#define IDS_PROCCOUNT_HDRSUBTITLE       309
#define IDS_CPUTIME_HDRTITLE            310
#define IDS_CPUTIME_HDRSUBTITLE         311
#define IDS_ADVANCED_HDRTITLE           312
#define IDS_ADVANCED_HDRSUBTITLE        313
#define IDS_SELECTCOMPUTER_HDRTITLE     314
#define IDS_SELECTCOMPUTER_HDRSUBTITLE  315
#define IDS_ADDSNAPIN_HDRTITLE          316
#define IDS_ADDSNAPIN_HDRSUBTITLE       317
#define IDS_ADDSNAPIN_TITLE             318
#define IDS_CONNECT_TITLE               319
#define IDS_PRULE_CREATE_TITLE          320
#define IDS_JRULE_CREATE_TITLE          321
#define IDS_APPLY_PROC_CMEM_LIMIT_HDR   322
#define IDS_PROC_CMEM_LIMIT_HDR         323
#define IDS_APPLY_JOB_CMEM_LIMIT_HDR    324
#define IDS_JOB_CMEM_LIMIT_HDR          325
#define IDS_APPLY_PROCCOUNT_LIMIT_HDR   326
#define IDS_PROCCOUNT_LIMIT_HDR         327
#define IDS_APPLY_PROC_CPUTIME_LIMIT_HDR 328
#define IDS_PROC_CPUTIME_LIMIT_HDR      329
#define IDS_APPLY_JOB_CPUTIME_LIMIT_HDR 330
#define IDS_JOB_CPUTIME_LIMIT_HDR       331
#define IDS_ALLOW_BREAKAWAY_HDR         332
#define IDS_ALLOW_SILENT_BREAKAWAY_HDR  333
#define IDS_DIE_ON_UNHANDLED_EXCEPT_HDR 334
#define IDS_USER_TIME_HDR               335
#define IDS_KERNEL_TIME_HDR             336
#define IDS_CREATE_TIME_HDR             337
#define IDS_PERIOD_USER_TIME_HDR        338
#define IDS_PERIOD_KERNEL_TIME_HDR      339
#define IDS_PAGE_FAULT_COUNT_HDR        340
#define IDS_PROCESS_COUNT_HDR           341
#define IDS_TERMINATED_PROCESS_COUNT_HDR 342
#define IDS_READOP_COUNT_HDR            343
#define IDS_WRITEOP_COUNT_HDR           344
#define IDS_OTHEROP_COUNT_HDR           345
#define IDS_READTRANS_COUNT_HDR         346
#define IDS_WRITETRANS_COUNT_HDR        347
#define IDS_OTHERTRANS_COUNT_HDR        348
#define IDS_PEAK_PROC_MEM_HDR           349
#define IDS_PEAK_JOB_MEM_HDR            350
#define IDS_GROUP_NO_LONGER_EXISTS      351
#define IDS_TYPE_DESCRIPTION            352
#define IDS_ACTION_JOB_CPUTIME_LIMIT_HDR 353
#define IDS_CPUTIMELIMT_ACTION_MSG      354
#define IDS_CPUTIMELIMT_ACTION_TERM     355
#define IDS_NUM_PROCESSORS              356
#define IDS_MEMORY_PAGESIZE             357
#define IDS_MEDIATOR_FILEVERSION        358
#define IDS_MEDIATOR_PRODUCTVERSION     359
#define IDS_WSMINMAX_WARNING            360
#define IDS_AFFINITY_WARNING            361
#define IDS_ADV_BREAKAWAY_HDRTITLE      362
#define IDS_ADV_BREAKAWAY_SUBTITLE      363
#define IDS_ADV_BREAKAWAY_HDRSUBTITLE   363
#define IDS_ENDJOB_ON_NO_PROC_HDR       364
#define IDS_JOBNAME_WARNING             365
#define IDS_COMPANYNAME                 500
#define IDS_FILEDESCRIPTION             501
#define IDS_FILEVERSION                 502
#define IDS_INTERNALNAME                503
#define IDS_LEGALCOPYRIGHT              504
#define IDS_ORIGINALFILENAME            505
#define IDS_PRODUCTNAME                 506
#define IDS_PRODUCTVERSION              507
#define IDS_COMMENTS                    508
#define IDS_LEGALTRADEMARKS             509
#define IDS_PRIVATEBUILD                510
#define IDS_SPECIALBUILD                511
#define IDR_ALIAS_MACRO                 600
#define IDC_DIR                         601
#define IDC_IMAGE                       602
#define IDC_STRING                      603
#define IDC_MATCHMASK                   604
#define IDC_NAME                        605
#define IDC_COMMENT                     606
#define IDC_JOB                         609
#define IDC_JOBMEMBER_CHK               615
#define IDC_AFFINITY_CHK                616
#define IDC_PRIORITY_CHK                617
#define IDC_PROCESSCOUNT_CHK            618
#define IDC_JOBMEMORY_CHK               619
#define IDC_PROCMEMORY_CHK              620
#define IDC_ADD                         629
#define IDC_LOCAL_RD                    630
#define IDC_ANOTHER_RD                  631
#define IDC_COMPUTER                    632
#define IDC_BROWSE                      633
#define IDC_ITEMS                       634
#define IDC_VALUE                       635
#define IDC_PAGE_ICON                   636
#define IDC_FILEVERSION                 638
#define IDC_PRODUCTVERSION              639
#define IDC_DESCRIPTION                 640
#define IDC_COPYRIGHT                   641
#define IDC_BTN_ALIAS                   642
#define IDC_SCHEDULING_CHK              643
#define IDC_SPIN                        644
#define IDC_INTERVAL                    645
#define IDC_SCLASS                      646
#define IDC_PROC_SPIN                   647
#define IDC_JOB_LIST                    648
#define IDC_PRIORITY_PROMPT             649
#define IDC_AFFINITY_PROMPT             650
#define IDC_MINWS_SPIN                  651
#define IDC_MAXWS_SPIN                  652
#define IDC_PROCESSCOUNT                653
#define IDC_PROCMEMORY                  654
#define IDC_JOBMEMORY                   655
#define IDC_JOB_SPIN                    656
#define IDC_WORKINGSET_CHK              657
#define IDC_MINWS                       658
#define IDC_MAXWS                       659
#define IDC_PROCUSERTIME_CHK            660
#define IDC_PROCUSERTIME                661
#define IDC_JOBUSERTIME_CHK             662
#define IDC_JOBUSERTIME                 663
#define IDC_JOBTIMELIMIT_TERM           664
#define IDC_JOBTIMELIMIT_MSG            665
#define IDC_BREAKAWAY_CHK               666
#define IDC_SILENTBREAKAWAY_CHK         667
#define IDC_UNHANDLEDEXCEPT_CHK         668
#define IDC_COMMTIMEOUT                 669
#define IDC_COMMTIMEOUT_SPIN            670
#define IDC_PROCMEM_FRM                 671
#define IDC_JOBMEM_FRM                  672
#define IDC_PROCMEM_LBL                 673
#define IDC_JOBMEM_LBL                  674
#define IDC_ENDJOB_CHK                  675
#define IDC_MATCHTYPE_FRAME             676
#define IDC_SNAPIN_MANAGE_FRAME         677
#define IDC_VERSION_FRAME               678
#define IDC_TARGET_FRAME                679
#define IDC_MGMT_FRAME                  680
#define IDC_APPLYGROUP_FRAME            681
#define IDC_SCHEDULING_FRAME            682
#define IDC_AFFINITY_FRAME              683
#define IDC_PRIORITY_FRAME              684
#define IDC_WORKINGSET_FRAME            685
#define IDC_ADV_FRAME                   686
#define IDC_PROCCOUNT_FRAME             687
#define IDC_PROCUSERTIME_FRAME          688
#define IDC_JOBUSERTIME_FRAME           689
#define IDC_LOW                         894
#define IDC_BELOW_NORMAL                895
#define IDC_NORMAL                      896
#define IDC_ABOVE_NORMAL                897
#define IDC_HIGH                        898
#define IDC_REALTIME                    899
#define IDC_AFFINITY1                   901
#define IDC_AFFINITY2                   902
#define IDC_AFFINITY3                   903
#define IDC_AFFINITY4                   904
#define IDC_AFFINITY5                   905
#define IDC_AFFINITY6                   906
#define IDC_AFFINITY7                   907
#define IDC_AFFINITY8                   908
#define IDC_AFFINITY9                   909
#define IDC_AFFINITY10                  910
#define IDC_AFFINITY11                  911
#define IDC_AFFINITY12                  912
#define IDC_AFFINITY13                  913
#define IDC_AFFINITY14                  914
#define IDC_AFFINITY15                  915
#define IDC_AFFINITY16                  916
#define IDC_AFFINITY17                  917
#define IDC_AFFINITY18                  918
#define IDC_AFFINITY19                  919
#define IDC_AFFINITY20                  920
#define IDC_AFFINITY21                  921
#define IDC_AFFINITY22                  922
#define IDC_AFFINITY23                  923
#define IDC_AFFINITY24                  924
#define IDC_AFFINITY25                  925
#define IDC_AFFINITY26                  926
#define IDC_AFFINITY27                  927
#define IDC_AFFINITY28                  928
#define IDC_AFFINITY29                  929
#define IDC_AFFINITY30                  930
#define IDC_AFFINITY31                  931
#define IDC_AFFINITY32                  932
#define IDC_AFFINITY33                  933
#define IDC_AFFINITY34                  934
#define IDC_AFFINITY35                  935
#define IDC_AFFINITY36                  936
#define IDC_AFFINITY37                  937
#define IDC_AFFINITY38                  938
#define IDC_AFFINITY39                  939
#define IDC_AFFINITY40                  940
#define IDC_AFFINITY41                  941
#define IDC_AFFINITY42                  942
#define IDC_AFFINITY43                  943
#define IDC_AFFINITY44                  944
#define IDC_AFFINITY45                  945
#define IDC_AFFINITY46                  946
#define IDC_AFFINITY47                  947
#define IDC_AFFINITY48                  948
#define IDC_AFFINITY49                  949
#define IDC_AFFINITY50                  950
#define IDC_AFFINITY51                  951
#define IDC_AFFINITY52                  952
#define IDC_AFFINITY53                  953
#define IDC_AFFINITY54                  954
#define IDC_AFFINITY55                  955
#define IDC_AFFINITY56                  956
#define IDC_AFFINITY57                  957
#define IDC_AFFINITY58                  958
#define IDC_AFFINITY59                  959
#define IDC_AFFINITY60                  960
#define IDC_AFFINITY61                  961
#define IDC_AFFINITY62                  962
#define IDC_AFFINITY63                  963
#define IDC_AFFINITY64                  964
#define IDD_SNAPIN_ADD_WIZ1             1001
#define IDD_SNAPIN_ADD_WIZ2             1002
#define IDD_SNAPIN_GENERAL_PAGE         1011
#define IDD_SNAPIN_VERSION_PAGE         1012
#define IDD_SERVICE_INFO_PAGE           1013
#define IDD_NAMERULE_PAGE               1021
#define IDD_PROCDEF_PAGE                1022
#define IDD_JOBDEF_PAGE                 1023
#define IDD_PROCID_PAGE                 1031
#define IDD_PROCNAME_WIZ                1032
#define IDD_PROCJOBMEMBER_WIZ           1033
#define IDD_JOBID_PAGE                  1041
#define IDD_JOBNAME_WIZ                 1042
#define IDD_PROC_COUNT_WIZ              1043
#define IDD_PRIORITY_PAGE               1051
#define IDD_PRIORITY_WIZ                1052
#define IDD_AFFINITY_PAGE               1053
#define IDD_AFFINITY_WIZ                1054
#define IDD_SCHEDULING_CLASS_PAGE       1055
#define IDD_SCHEDULING_CLASS_WIZ        1056
#define IDD_MEMORY_PAGE                 1057
#define IDD_MEMORY_WS_WIZ               1058
#define IDD_MEMORY_COMMIT_WIZ           1059
#define IDD_TIME_PAGE                   1060
#define IDD_TIME_WIZ                    1061
#define IDD_ADVANCED_PAGE               1062
#define IDD_ADVANCED_WIZ                1063
#define IDD_ADV_BREAKAWAY_WIZ           1064
#define ID_NRULE_INSERT                 33284
#define ID_NRULE_MOVEUP                 33285
#define ID_NRULE_MOVEDOWN               33286
#define ID_AFFINITY_VIEW                33287
#define ID_PRIORITY_VIEW                33288
#define ID_RULE_VIEW                    33289
#define ID_ROOT_CONNECT                 33290
#define ID_JRULE_NEW                    33291
#define ID_JRULE_DEFINE                 33292
#define ID_PRULE_NEW                    33293
#define ID_PRULE_DEFINE                 33294
#define ID_JOBVIEW_ALL                  33295
#define ID_JOBVIEW_RUN                  33296
#define ID_JOBVIEW_MANAGED              33297
#define ID_PROCVIEW_ALL                 33298
#define ID_PROCVIEW_RUN                 33299
#define ID_PROCVIEW_MANAGED             33300
#define IDM_IMAGE                       33301
#define IDM_HIDE                        33302
#define IDM_DIR                         33303
#define ID_NRULE_EDIT                   33304
#define ID_ENDPROCESS                   33305
#define ID_ENDJOB                       33306

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        365
#define _APS_NEXT_COMMAND_VALUE         33307
#define _APS_NEXT_CONTROL_VALUE         690
#define _APS_NEXT_SYMED_VALUE           132
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\rootpages.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    RootPages.cpp                                                            //
|                                                                                       //
|Description:  Property page implemention for the root node                             //
|                                                                                       //
|Created:      Paul Skoglund 10-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/


#include "StdAfx.h"
#include "BaseNode.h"
#include "shlobj.h"

#include "RootPages.h"
#include "version.h"
#include "ManagementPages.h" //formating functions...

//////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CRootWizard1::CRootWizard1(WIZ_POSITION pos, int nTitle) 
    : CMySnapInPropertyWizardImpl<CRootWizard1> (pos, nTitle)
{
  m_psp.dwFlags |= PSP_HASHELP;
}

LRESULT CRootWizard1::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HELPINFO *phi = (HELPINFO*) lParam;
	if (phi && phi->iContextType == HELPINFO_WINDOW)
	{
    IDCsToIDHs HelpMap[] = {
                            {0,0} };

    ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap);
    
		return TRUE;
	}
	bHandled = FALSE;
	return FALSE;
}

BOOL CRootWizard1::OnHelp()
{
	MMCPropertyHelp(const_cast<TCHAR*>(HELP_overview));
	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CRootWizard2::CRootWizard2(WIZ_POSITION pos, int nTitle, CBaseNode* pNode) 
    : CMySnapInPropertyWizardImpl<CRootWizard2> (pos, nTitle), m_pNode(pNode)
{
  bLocal = TRUE;
  memset(&Computer, 0, sizeof(Computer));
  //m_psp.dwFlags |= PSP_HASHELP;
}

CRootWizard2::~CRootWizard2()
{
}

LRESULT CRootWizard2::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UpdateData(FALSE);
	return 1;
}

LRESULT CRootWizard2::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HELPINFO *phi = (HELPINFO*) lParam;
	if (phi && phi->iContextType == HELPINFO_WINDOW)
	{
    IDCsToIDHs HelpMap[] = {{IDC_SNAPIN_MANAGE_FRAME, HELP_wizCONNECT_FRAME},
                            {IDC_LOCAL_RD,            HELP_wizCONNECT_LOCAL},
                            {IDC_ANOTHER_RD,          HELP_wizCONNECT_ANOTHER},
                            {IDC_COMPUTER,            HELP_wizCONNECT_COMPUTER},
                            {IDC_BROWSE,              HELP_wizCONNECT_BROWSE},
                            {0,0} };

    ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap);
    
		return TRUE;
	}
	bHandled = FALSE;
	return FALSE;
}

BOOL CRootWizard2::OnHelp()
{
	//MMCPropertyHelp(const_cast<TCHAR*>(HELP_howto_changecomputer));
	return TRUE;
}

BOOL CRootWizard2::UpdateData(BOOL bSaveAndValidate)
{
  if (bSaveAndValidate)
  {
    BOOL bLocalChk = IsDlgButtonChecked(IDC_LOCAL_RD);
    ASSERT(bLocalChk != (BOOL) IsDlgButtonChecked(IDC_ANOTHER_RD));

    CComBSTR bStr;
    if (!GetDlgItemText(IDC_COMPUTER, bStr.m_str))
      bStr = _T("");

    TCHAR *start = bStr;
    while (*start && *start == '\\') start++;
    UINT len = _tcslen(start);

    if (!bLocalChk && ( len < 1 || len > SNAPIN_MAX_COMPUTERNAME_LENGTH) )
    {
      HWND hWndCtl = GetDlgItem(IDC_COMPUTER);
		  if(hWndCtl)
        VERIFY(::SetFocus(hWndCtl));  // $$ why doesn't this work?  works in other cases...
      return FALSE;
    }

    bLocal = bLocalChk;
    _tcscpy(&Computer[0], start);
    return TRUE;
  }
  else
  {
    VERIFY( SetDlgItemText(IDC_COMPUTER,  _T("")) );
    VERIFY( CheckRadioButton(IDC_LOCAL_RD, IDC_ANOTHER_RD, bLocal ? IDC_LOCAL_RD : IDC_ANOTHER_RD) );

    HWND hWndCtl = GetDlgItem(IDC_COMPUTER);
    ASSERT(hWndCtl);
    if (hWndCtl)
      ::EnableWindow(hWndCtl, !bLocal);

    hWndCtl = GetDlgItem(IDC_BROWSE);
    ASSERT(hWndCtl);
    if (hWndCtl)
      ::EnableWindow(hWndCtl, !bLocal);

    return TRUE;
  }
}

LRESULT CRootWizard2::OnConnectType(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wNotifyCode == BN_CLICKED)
  {
    BOOL Remote = FALSE;
    switch (wID) {
    case IDC_ANOTHER_RD:      
      Remote = TRUE;
      break;
    case IDC_LOCAL_RD:      
    default:
      break;
    }
    HWND hWndCtl = GetDlgItem(IDC_COMPUTER);
    ASSERT(hWndCtl);
    if (hWndCtl)
      ::EnableWindow(hWndCtl, Remote);

    hWndCtl = GetDlgItem(IDC_BROWSE);
    ASSERT(hWndCtl);
    if (hWndCtl)
      ::EnableWindow(hWndCtl, Remote);

  }

  bHandled = FALSE;
  return 0;
}

BOOL CRootWizard2::OnWizardFinish()
{
  if (UpdateData(TRUE))
  {
    CRootFolder *Root = dynamic_cast<CRootFolder *>(m_pNode);
    if (Root)
      Root->Config(bLocal, Computer);
    return TRUE; 
  }
  MessageBeep(MB_ICONASTERISK);
  return FALSE;
}


LRESULT CRootWizard2::OnBrowse(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wNotifyCode != BN_CLICKED || wID != IDC_BROWSE)
  {
    bHandled = FALSE;
    return 1;
  }

  ITEM_STR title;

  LoadStringHelper(title, IDS_COMPUTER_PROMPT); 

  LPMALLOC     pMalloc;
  LPITEMIDLIST pidl;
  BROWSEINFO   info = { 0 };


  if (SUCCEEDED(SHGetMalloc(&pMalloc))) 
  {
    LPITEMIDLIST pidl_start = NULL;
    HRESULT res = SHGetSpecialFolderLocation( NULL, CSIDL_NETWORK, &pidl_start);

    TCHAR *lpBuffer = (TCHAR *) (pMalloc->Alloc( MAX_PATH * sizeof(TCHAR) ));

    if (lpBuffer) 
    {
      info.hwndOwner = GetParent();
      info.pidlRoot  = (res == NOERROR) ? pidl_start : NULL;
      info.pszDisplayName = lpBuffer;
      info.lpszTitle      = title;
      info.ulFlags        = BIF_BROWSEFORCOMPUTER;
      // info.lpfn           = NULL;
      // info.lParam         = 0;
      // info.iImage

      memset(lpBuffer, 0, MAX_PATH * sizeof(TCHAR) );
      pidl = SHBrowseForFolder(&info);
      if (pidl)
      {
        VERIFY(SetDlgItemText(IDC_COMPUTER, lpBuffer));
        pMalloc->Free(pidl);
      }
      pMalloc->Free(lpBuffer);
    }

    if (res == NOERROR)
      pMalloc->Free(pidl_start);
    pMalloc->Release();
  }
  return 0;
}


//////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CRootGeneralPage::CRootGeneralPage(int nTitle) 
    : CMySnapInPropertyPageImpl<CRootGeneralPage> (nTitle)
{
  m_psp.dwFlags |= PSP_HASHELP;
}

CRootGeneralPage::~CRootGeneralPage()
{
}

LRESULT CRootGeneralPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	bHandled = FALSE;
	return TRUE;
}

LRESULT CRootGeneralPage::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HELPINFO *phi = (HELPINFO*) lParam;
	if (phi && phi->iContextType == HELPINFO_WINDOW)
	{
    IDCsToIDHs HelpMap[] = {
                            {0,0} };

    ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap);
    
		return TRUE;
	}
	bHandled = FALSE;
	return FALSE;
}

BOOL CRootGeneralPage::OnHelp()
{
	MMCPropertyHelp(const_cast<TCHAR*>(HELP_overview));
	return TRUE;
}

BOOL CRootGeneralPage::OnSetActive()
{
	CComBSTR bName;
	VERIFY(bName.LoadString(IDS_PROCESS_CONTROL));
	if (bName.Length())
		PropSheet_SetTitle( GetParent(), PSH_PROPTITLE, bName.m_str);
	return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CRootVersionPage::CRootVersionPage(int nTitle)
    : CMySnapInPropertyPageImpl<CRootVersionPage>(nTitle), VersionObj(_Module.GetModuleInstance())
{
//  m_psp.dwFlags |= PSP_HASHELP;
}
  
LRESULT CRootVersionPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  SetDlgItemText(IDC_FILEVERSION, VersionObj.GetFileVersion()        );
  SetDlgItemText(IDC_DESCRIPTION, VersionObj.strGetFileDescription() );
  SetDlgItemText(IDC_COPYRIGHT,   VersionObj.strGetLegalCopyright()  );

  struct {
    int id;
    const TCHAR *str;
  } idmap[] = { {IDS_COMPANYNAME,    VersionObj.strGetCompanyName()   }, {IDS_FILEDESCRIPTION,  VersionObj.strGetFileDescription()  },
                {IDS_FILEVERSION,    VersionObj.strGetFileVersion()   }, {IDS_INTERNALNAME,     VersionObj.strGetInternalName()     },
                {IDS_LEGALCOPYRIGHT, VersionObj.strGetLegalCopyright()}, {IDS_ORIGINALFILENAME, VersionObj.strGetOriginalFilename() },

                {IDS_PRODUCTNAME,    VersionObj.strGetProductName()   }, {IDS_PRODUCTVERSION,   VersionObj.strGetProductVersion()   },
                {IDS_COMMENTS,       VersionObj.strGetComments()      }, {IDS_LEGALTRADEMARKS,  VersionObj.strGetLegalTrademarks()  },
                {IDS_PRIVATEBUILD,   VersionObj.strGetPrivateBuild()  }, {IDS_SPECIALBUILD,     VersionObj.strGetSpecialBuild()     },
              };
  LRESULT index;
  ITEM_STR str;
  for (int i=0; i < ARRAY_SIZE(idmap); i++)
  {
    index = SendDlgItemMessage( IDC_ITEMS, LB_ADDSTRING, 0, (LPARAM) LoadStringHelper(str, idmap[i].id) );

    if (index >= 0)
      SendDlgItemMessage(IDC_ITEMS, LB_SETITEMDATA, index, (LPARAM) idmap[i].str);
  }

  index = SendDlgItemMessage( IDC_ITEMS, LB_FINDSTRINGEXACT, -1, (LPARAM) LoadStringHelper(str, IDS_COMPANYNAME));
  SendDlgItemMessage( IDC_ITEMS, LB_SETCURSEL, index, 0);

  SetDlgItemText(IDC_VALUE, VersionObj.strGetCompanyName() );

	return 1;
}

LRESULT CRootVersionPage::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HELPINFO *phi = (HELPINFO*) lParam;
	if (phi && phi->iContextType == HELPINFO_WINDOW)
	{
    IDCsToIDHs HelpMap[] = {{IDC_FILEVERSION,   HELP_VER_FILE},
                            {IDC_DESCRIPTION,   HELP_VER_DESCRIPTION},
                            {IDC_COPYRIGHT,     HELP_VER_COPYRIGHT},
                            {IDC_VERSION_FRAME, HELP_VER_OTHER_FRAME},
                            {IDC_ITEMS,         HELP_VER_ITEM},
                            {IDC_VALUE,         HELP_VER_VALUE},
                            {0,0} };

    ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap);
    
		return TRUE;
	}
	bHandled = FALSE;
	return FALSE;
}

BOOL CRootVersionPage::OnHelp()
{
	//MMCPropertyHelp(const_cast<TCHAR*>(HELP_overview));
	return TRUE;
}

LRESULT CRootVersionPage::OnItemsSelection(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID != IDC_ITEMS || wNotifyCode != LBN_SELCHANGE)
  {
    bHandled = FALSE;
    return 1;
  }
  LRESULT index = SendDlgItemMessage( IDC_ITEMS, LB_GETCURSEL, 0, 0);
  if ( LB_ERR != index )
  {
    LRESULT lResult = SendDlgItemMessage(IDC_ITEMS, LB_GETITEMDATA, index, 0);
    if (LB_ERR != lResult)
      SetDlgItemText(IDC_VALUE, (TCHAR *) lResult);
  }

  return 1;
}

BOOL CRootVersionPage::OnSetActive()
{
	CComBSTR bName;
	VERIFY(bName.LoadString(IDS_PROCESS_CONTROL));
	if (bName.Length())
		PropSheet_SetTitle( GetParent(), PSH_PROPTITLE, bName.m_str);
	return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CRootServicePage::CRootServicePage(int nTitle, CServicePageContainer *pContainer) : CMySnapInPropertyPageImpl<CRootServicePage> (nTitle), m_pContainer(pContainer)
{
  PageFields.on = 0;
  m_bReadOnly   = FALSE;

	memset(&PCInfo, 0, sizeof(PCInfo));
  //m_psp.dwFlags |= PSP_HASHELP;
  m_pContainer->AddRef();
}

CRootServicePage::~CRootServicePage()
{
  m_pContainer->Release();
}

LRESULT CRootServicePage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  UpdateData(FALSE);
	return 1;
}

LRESULT CRootServicePage::OnWMHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HELPINFO *phi = (HELPINFO*) lParam;
	if (phi && phi->iContextType == HELPINFO_WINDOW)
	{
    IDCsToIDHs HelpMap[] = {
                            {IDC_FILEVERSION,      HELP_SERVICE_FILEVER},
                            {IDC_PRODUCTVERSION,   HELP_SERVICE_PRODUCTVER},
                            {IDC_MGMT_FRAME,       HELP_SERVICE_MGMT_FRAME},
                            {IDC_INTERVAL,         HELP_SERVICE_SCANINTERVAL},
                            {IDC_SPIN,             HELP_SERVICE_SCANINTERVAL_SP},
                            {IDC_COMMTIMEOUT,      HELP_SERVICE_REQSTTIMEOUT},
                            {IDC_COMMTIMEOUT_SPIN, HELP_SERVICE_REQSTTIMEOUT_SP},
                            {IDC_TARGET_FRAME,     HELP_SERVICE_TARGET_FRAME},
                            {IDC_ITEMS,            HELP_SERVICE_ITEM},
                            {IDC_VALUE,            HELP_SERVICE_VALUE},
                            {0,0} };

    ::WinHelp((HWND) phi->hItemHandle, ContextHelpFile, HELP_WM_HELP, (DWORD_PTR) &HelpMap);
    
		return TRUE;
	}
	bHandled = FALSE;
	return FALSE;
}

BOOL CRootServicePage::OnHelp()
{
	//MMCPropertyHelp(const_cast<TCHAR*>(HELP_serv_overview));
	return TRUE;
}

BOOL CRootServicePage::OnSetActive()
{
	CComBSTR bName;
	VERIFY(bName.LoadString(IDS_PROCESS_CONTROL));
	if (!bName.Length())
		bName = _T("");

	CComBSTR bTitle;
	PropSheet_SetTitle( GetParent(), PSH_PROPTITLE, 
    FormatSheetTitle(bTitle, bName, m_pContainer->GetConnectionInfo()) );

	return TRUE;
}

BOOL CRootServicePage::UpdateData(BOOL bSaveAndValidate)
{
	if (bSaveAndValidate)
	{
		return Validate(TRUE);
	}
	else
	{
		SetDlgItemText(IDC_FILEVERSION,    PCInfo.fileVersion    );
		SetDlgItemText(IDC_PRODUCTVERSION, PCInfo.productVersion );

    int str_ids[] = { IDS_NUM_PROCESSORS, IDS_MEMORY_PAGESIZE, IDS_MEDIATOR_FILEVERSION, IDS_MEDIATOR_PRODUCTVERSION };
                
    LRESULT index;
    ITEM_STR str;
    for (int i=0; i < ARRAY_SIZE(str_ids); i++)
    {
      index = SendDlgItemMessage( IDC_ITEMS, LB_ADDSTRING, 0, (LPARAM) LoadStringHelper(str, str_ids[i]) );

      if (index >= 0)
        SendDlgItemMessage(IDC_ITEMS, LB_SETITEMDATA, index, (LPARAM) str_ids[i]);
    }
    index = SendDlgItemMessage( IDC_ITEMS, LB_FINDSTRINGEXACT, -1, (LPARAM) LoadStringHelper(str, IDS_NUM_PROCESSORS));
    SendDlgItemMessage( IDC_ITEMS, LB_SETCURSEL, index, 0);
    SetDlgItemText(IDC_VALUE, FormatPCINT32(str, PCInfo.sysParms.numberOfProcessors));


		SendDlgItemMessage(IDC_SPIN, UDM_SETRANGE32, PC_MIN_POLL_DELAY, PC_MAX_POLL_DELAY);

		if (PCInfo.sysParms.manageIntervalSeconds)
			SendDlgItemMessage(IDC_SPIN, UDM_SETPOS32, 0, PCInfo.sysParms.manageIntervalSeconds );

 		SendDlgItemMessage(IDC_COMMTIMEOUT_SPIN, UDM_SETRANGE32, PC_MIN_TIMEOUT, PC_MAX_TIMEOUT);
    SendDlgItemMessage(IDC_COMMTIMEOUT_SPIN, UDM_SETPOS32,   0,              PCInfo.sysParms.timeoutValueMs );

		if ( m_bReadOnly )
		{
			DisableControl(IDC_SPIN);
			DisableControl(IDC_INTERVAL);
      DisableControl(IDC_COMMTIMEOUT_SPIN);
      DisableControl(IDC_COMMTIMEOUT);      
		}

		return TRUE;
	}
}

BOOL CRootServicePage::Validate(BOOL bSave)
{
  LONG_PTR Err = 0;

	LRESULT manageIntervalSeconds = SendDlgItemMessage(IDC_SPIN, UDM_GETPOS32, 0, (LPARAM) &Err);
  if (Err || manageIntervalSeconds < PC_MIN_POLL_DELAY || manageIntervalSeconds > PC_MAX_POLL_DELAY)
  {
	  MessageBeep(MB_ICONASTERISK);
    HWND hWndCtl = GetDlgItem(IDC_SPIN);
	  if(hWndCtl)
      ::SetFocus(hWndCtl);
    return FALSE;
  }

  LRESULT timeoutValueMs = SendDlgItemMessage(IDC_COMMTIMEOUT_SPIN, UDM_GETPOS32, 0, (LPARAM) &Err);
  if (Err || timeoutValueMs < PC_MIN_TIMEOUT || timeoutValueMs > PC_MAX_TIMEOUT)
  {
	  MessageBeep(MB_ICONASTERISK);
    HWND hWndCtl = GetDlgItem(IDC_COMMTIMEOUT_SPIN);
	  if(hWndCtl)
      ::SetFocus(hWndCtl);
    return FALSE;
  }

	if (bSave)
	{
    m_pContainer->m_new.manageIntervalSeconds = (PCINT32) manageIntervalSeconds;
    m_pContainer->m_new.timeoutValueMs        = (PCINT32) timeoutValueMs;
	}
	return TRUE;
}

LRESULT CRootServicePage::OnEditChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  LONG_PTR Err = 0;

  if (wID == IDC_INTERVAL)
	{
    LRESULT manageIntervalSeconds = SendDlgItemMessage(IDC_SPIN, UDM_GETPOS32, 0, (LPARAM) &Err);
		PageFields.Fields.manageinterval = FALSE;		

		if (!Err && manageIntervalSeconds >= PC_MIN_POLL_DELAY && manageIntervalSeconds <= PC_MAX_POLL_DELAY)
			PageFields.Fields.manageinterval = (PCInfo.sysParms.manageIntervalSeconds != (PCINT32) manageIntervalSeconds);
	}

  if (wID == IDC_COMMTIMEOUT)
	{
    LRESULT timeoutValueMs = SendDlgItemMessage(IDC_COMMTIMEOUT_SPIN, UDM_GETPOS32, 0, (LPARAM) &Err);
    PageFields.Fields.timeoutValueMs = FALSE;

		if (!Err && timeoutValueMs >= PC_MIN_TIMEOUT && timeoutValueMs <= PC_MAX_TIMEOUT )
			PageFields.Fields.timeoutValueMs = (PCInfo.sysParms.timeoutValueMs != (PCINT32) timeoutValueMs);
	}
  SetModified(PageFields.on);
  
  bHandled = FALSE;
  return 0;
}

LRESULT CRootServicePage::OnSpin(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
  if (idCtrl == IDC_COMMTIMEOUT_SPIN)
	{
    NMUPDOWN * nmupdown = (NMUPDOWN *) pnmh;
		if ((nmupdown->iPos + 100 * nmupdown->iDelta) >= PC_MIN_TIMEOUT && 
        (nmupdown->iPos + 100 * nmupdown->iDelta) <= PC_MAX_TIMEOUT )
      nmupdown->iDelta *= 100;
	}
  bHandled = FALSE;
  return 0;
}

LRESULT CRootServicePage::OnItemsSelection(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
  if (wID != IDC_ITEMS || wNotifyCode != LBN_SELCHANGE)
  {
    bHandled = FALSE;
    return 1;
  }
  LRESULT index = SendDlgItemMessage( IDC_ITEMS, LB_GETCURSEL, 0, 0);
  if (LB_ERR != index)
  {
    LRESULT lResult = SendDlgItemMessage(IDC_ITEMS, LB_GETITEMDATA, index, 0);
    if (LB_ERR != lResult)
    {
      ITEM_STR str = { 0 };
      switch (lResult)
      {
      case IDS_NUM_PROCESSORS:
        FormatPCINT32(str, PCInfo.sysParms.numberOfProcessors);
        SetDlgItemText(IDC_VALUE, str);
        break;
      case IDS_MEMORY_PAGESIZE:
        FormatPCINT32(str, PCInfo.sysParms.memoryPageSize);
        SetDlgItemText(IDC_VALUE, str);
        break;
      case IDS_MEDIATOR_FILEVERSION:
        SetDlgItemText(IDC_VALUE, PCInfo.medFileVersion);
        break;
      case IDS_MEDIATOR_PRODUCTVERSION:
        SetDlgItemText(IDC_VALUE, PCInfo.medProductVersion);
        break;
      default:
        ASSERT(FALSE);
        SetDlgItemText(IDC_VALUE, _T(""));
        break;
      }
    }
  }

  return 1;
}

BOOL CRootServicePage::OnApply()
{
	if (m_bReadOnly || !PageFields.on)
		return TRUE;

  if ( m_pContainer->Apply(GetParent()) )
  {		
    PageFields.on = 0;
    PCInfo.sysParms = m_pContainer->m_new;
    return TRUE; 
  }

  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D92D1B88_0619_11D2_8014_00104B9A3106__INCLUDED_)
#define AFX_STDAFX_H__D92D1B88_0619_11D2_8014_00104B9A3106__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

//#include <afxwin.h>
//#include <afxdisp.h>


#ifndef _AFX 
#define ASSERT _ASSERT
#if _DEBUG
#define VERIFY(f)  _ASSERT(f)
#else
#define VERIFY(f)  ((void)(f))
#endif
#define AFX_MANAGE_STATE(f)   ((void) 0) 
#endif


#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

// added:
//#include <commctrl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D92D1B88_0619_11D2_8014_00104B9A3106__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\rulefolder.cpp ===
/*======================================================================================//
|  Process Control                                                                      //
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    RuleFolder.cpp                                                           //
|                                                                                       //
|Description:  Implementation of rules node                                             //
|                                                                                       //
|Created:      Paul Skoglund 08-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#include "StdAfx.h"

#include "BaseNode.h"

using std::list<CBaseNode *>;


//////////////////////////////////////////////////////////////////////////////////////////
//
//  The "Rules" folder...
//

const GUID         CRuleFolder::m_GUID   =   {0xff9baf61,0x064e,0x11d2,{0x80, 0x14,0x00,0x10,0x4b,0x9a,0x31,0x06} };
const TCHAR *const CRuleFolder::m_szGUID = _T("{ff9baf61-064e-11d2-8014-00104b9a3106}");


CRuleFolder::CRuleFolder(CBaseNode *pParent) : CBaseNode(MANAGEMENTRULE_NODE, pParent),
                                               m_ID(0), m_NodeList(0)
{
  LoadStringHelper(m_name, IDS_RULES_FOLDER);
}


CRuleFolder::~CRuleFolder()
{
  FreeNodes();
}

void CRuleFolder::FreeNodes()
{
  ATLTRACE(_T("CRuleFolder::FreeNodes()\n") );
  for (list<CBaseNode *>::iterator i = m_NodeList.begin(); i != m_NodeList.end(); ++i)
  {
    (*i)->Release();
    //delete *i;
  }  
  m_NodeList.clear();
}


LPCTSTR CRuleFolder::GetNodeName()    
{ 
  return m_name;
}


HRESULT CRuleFolder::GetDisplayInfo(RESULTDATAITEM &ResultItem)
{
  if (ResultItem.bScopeItem)
  {
    if( ResultItem.mask & RDI_STR )
    {
			if (0 == ResultItem.nCol)
				ResultItem.str = const_cast<LPOLESTR>(GetNodeName());
			else
				ResultItem.str = _T("");
    }
    if (ResultItem.mask & RDI_IMAGE)
      ResultItem.nImage = sImage();
    return S_OK;
  }

  return E_UNEXPECTED;
}


HRESULT CRuleFolder::OnShow(BOOL bSelecting, HSCOPEITEM hItem, IHeaderCtrl2* ipHeaderCtrl, IConsole2* ipConsole2)
{
  ASSERT(hItem == GetID());

  if (!bSelecting)
    return S_OK;

  ITEM_STR  str;

  LoadStringHelper(str, IDS_NAME_HDR);
  VERIFY(S_OK == ipHeaderCtrl->InsertColumn( NAME_COLUMN, str, 0, NAME_COLUMN_WIDTH ));

  return SendViewChange(ipConsole2, NULL, PC_VIEW_UPDATEALL);
}


HRESULT CRuleFolder::OnExpand(BOOL bExpand, HSCOPEITEM hItem, IConsoleNameSpace2 *ipConsoleNameSpace2)
{
  ASSERT(ipConsoleNameSpace2);

  if(!ipConsoleNameSpace2)
    return E_UNEXPECTED; 

  if (bExpand)
  {
    VERIFY( S_OK == AddNode(ipConsoleNameSpace2, new CNameRuleFolder(this) ) );

    VERIFY( S_OK == AddNode(ipConsoleNameSpace2, new CProcessRuleFolder(this) ) );

    VERIFY( S_OK == AddNode(ipConsoleNameSpace2, new CJobRuleFolder(this) ) );
  }
  return S_OK; 
}


HRESULT CRuleFolder::AddNode(IConsoleNameSpace2 *ipConsoleNameSpace2, CBaseNode *pSubNode)
{
  HRESULT  hr = S_OK;

  SCOPEDATAITEM sdi = {0};

  if (!pSubNode)
    return E_OUTOFMEMORY;
 
  // Place our folder into the scope pane
  sdi.mask        = SDI_STR       |   // Displayname is valid
				            SDI_PARAM     |   // lParam is valid
				            SDI_IMAGE     |   // nImage is valid
				            SDI_OPENIMAGE |   // nOpenImage is valid
                    SDI_CHILDREN  |   // cChildren is valid
				            SDI_PARENT;
  
  sdi.displayname = (LPOLESTR)MMC_CALLBACK;
  sdi.nImage      = pSubNode->sImage();
  sdi.nOpenImage  = pSubNode->sOpenImage();
  //sdi.nState = ???
  sdi.cChildren   = pSubNode->GetChildrenCount();
  sdi.lParam      = reinterpret_cast <LPARAM> (pSubNode);
  sdi.relativeID  = m_ID;
  

  hr = ipConsoleNameSpace2->InsertItem( &sdi );

  if (SUCCEEDED(hr))
  {
    pSubNode->SetID(sdi.ID);
    m_NodeList.push_front( pSubNode );
  }
  else
  {
    pSubNode->Release();
    //delete pSubNode;
  }
  return hr;
}

HRESULT CRuleFolder::OnHelpCmd(IDisplayHelp *ipDisplayHelp)
{
	if (!ipDisplayHelp)
		return E_UNEXPECTED;

	ipDisplayHelp->ShowTopic(const_cast<TCHAR *>(HELP_ru_overview));

	return S_OK;
}

HRESULT CRuleFolder::OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb)
{
  ASSERT(bScope);
  return S_OK;
}

HRESULT CRuleFolder::OnSelect(BOOL bScope, BOOL bSelect, IConsoleVerb* ipConsoleVerb, LPARAM Cookie)
{ 
  ASSERT(!bScope);
  return S_OK;
}

HRESULT CRuleFolder::OnViewChange(IResultData *ipResultData, LPARAM thing, LONG_PTR hint)
{
  ASSERT(ipResultData);
  if (!ipResultData)  
    return E_UNEXPECTED;

  VERIFY(ipResultData->ModifyViewStyle(MMC_SINGLESEL, MMC_NOSORTHEADER) == S_OK);

  return ShowAllItems(ipResultData, FALSE);
}

HRESULT CRuleFolder::ShowAllItems(IResultData* ipResultData, BOOL bCacheValid)
{
  // should be nothing to delete...
  return ipResultData->DeleteAllRsltItems();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\version.cpp ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    version.cpp                                                              //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|Created:      Paul Skoglund 09-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/


#include "StdAfx.h"
#include "winver.h"

#include "version.h"
#include "resource.h"

#define ARRAY_SIZE(_X_) (sizeof(_X_)/sizeof(_X_[0]) )




CVersion::CVersion(HINSTANCE hInst) : m_hInst(hInst), m_bInitializedOK(FALSE)
{
  memset(&szFileVersion,       0, sizeof(szFileVersion)       );
  memset(&szProductVersion,    0, sizeof(szProductVersion)    );
  memset(&szFileFlags,         0, sizeof(szFileFlags)         );

  m_bDebug = m_bPatched = m_bPreRelease = m_bPrivateBuild = m_bSpecialBuild = FALSE;

  TCHAR  szFileName[_MAX_PATH + 1] = { 0 };

  DWORD  dwBogus = 0;
  DWORD  dwSize = 0;
  LPVOID hMem = NULL;

  if ( GetModuleFileName(hInst, szFileName, ARRAY_SIZE(szFileName)) && 
       (dwSize = GetFileVersionInfoSize(szFileName, &dwBogus)) &&
       (hMem = new BYTE[dwSize]) )
  {
    if (GetFileVersionInfo(szFileName, NULL, dwSize, hMem) )
    {
      UINT uLen = 0;
      VS_FIXEDFILEINFO *ptr_vs_fixed_info;

      if (VerQueryValue( hMem, _T("\\"), (void **) &ptr_vs_fixed_info, &uLen) )
      {
        m_bInitializedOK = ParseFixedInfo(*ptr_vs_fixed_info, uLen);
      }

      LoadStringFileInfo(hMem);

      delete [] hMem;
    }
  }
}

BOOL CVersion::LoadStringFileInfo(LPVOID hMem)
{
#ifndef UNICODE
#error "what code-page to use?  window-multilingual? 0x04e4"
#endif

  UINT uLen;
  TCHAR buf[128];
  TCHAR *info; 
  // it is my understanding that the string below are identified with the same english string under each language
  // $$ confirm? yes/no
  struct 
  {
    TCHAR   *name;
    tstring *target;
  } table[] = {
    { _T("CompanyName"),    &strCompanyName   }, { _T("FileDescription"), &strFileDescription  },
    { _T("FileVersion"),    &strFileVersion   }, { _T("InternalName"),    &strInternalName     },
    { _T("LegalCopyright"), &strLegalCopyright}, { _T("OriginalFilename"),&strOriginalFilename }, 
    { _T("ProductName"),    &strProductName   }, { _T("ProductVersion"),  &strProductVersion   },
    { _T("Comments"),       &strComments      }, { _T("LegalTrademarks"), &strLegalTrademarks  },
    { _T("PrivateBuild"),   &strPrivateBuild  }, { _T("SpecialBuild"),    &strSpecialBuild     }
  };

  buf[ARRAY_SIZE(buf) - 1] = 0;  //insure null termination
  for (int i = 0; i < ARRAY_SIZE(table); i++)
  { 
     // MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT)
    _sntprintf(buf, ARRAY_SIZE(buf) -1 , _T("\\StringFileInfo\\%04hx04b0\\%s"), GetUserDefaultLangID(), table[i].name);

    if (VerQueryValue( hMem, buf, (void **) &info, &uLen) )
    {
      *(table[i].target) = info; 
    }
  }

  return TRUE;

}

BOOL CVersion::ParseFixedInfo(VS_FIXEDFILEINFO &info, UINT uLen)
{  
  ASSERT( uLen == sizeof(VS_FIXEDFILEINFO) );

  if(uLen != sizeof(VS_FIXEDFILEINFO) )
    return FALSE;

  _stprintf(szFileVersion, _T("%hu.%hu.%hu.%hu"),
      HIWORD(info.dwFileVersionMS),
      LOWORD(info.dwFileVersionMS),
      HIWORD(info.dwFileVersionLS),
      LOWORD(info.dwFileVersionLS));

  _stprintf(szProductVersion, _T("%hu.%hu.%hu.%hu"),
      HIWORD(info.dwProductVersionMS),
      LOWORD(info.dwProductVersionMS),
      HIWORD(info.dwProductVersionLS),
      LOWORD(info.dwProductVersionLS));

  if ((info.dwFileFlagsMask & VS_FF_DEBUG) &&
      (info.dwFileFlags     & VS_FF_DEBUG) )
  {
    m_bDebug = TRUE;
  }
  if ((info.dwFileFlagsMask & VS_FF_PRERELEASE) &&
      (info.dwFileFlags &     VS_FF_PRERELEASE) )
  {
    m_bPreRelease = TRUE;
  }
  if ((info.dwFileFlagsMask & VS_FF_PATCHED ) &&
      (info.dwFileFlags     & VS_FF_PATCHED ) )
  {
    m_bPatched = TRUE;
  }
  if ((info.dwFileFlagsMask & VS_FF_PRIVATEBUILD ) &&
      (info.dwFileFlags     & VS_FF_PRIVATEBUILD ) )
  {
    m_bPrivateBuild = TRUE;
  }

  if ((info.dwFileFlagsMask & VS_FF_SPECIALBUILD ) &&
      (info.dwFileFlags     & VS_FF_SPECIALBUILD) )
  {
    m_bSpecialBuild = TRUE;
  }


  TCHAR *start = szFileFlags;
  int len = 0;
  int remaining_len = ARRAY_SIZE(szFileFlags) - 1;  // length in characters not bytes!

  int flags[] = {VS_FF_PATCHED, VS_FF_DEBUG, VS_FF_PRERELEASE, 0 };
  int ids[]   = {IDS_PATCHED,   IDS_DEBUG,   IDS_BETA,         0 };

  ASSERT(ARRAY_SIZE(flags) == ARRAY_SIZE(ids));

  for (int i = 0; flags[i], ids[i]; i++)
  {
    if ((info.dwFileFlagsMask & flags[i]) &&
        (info.dwFileFlags     & flags[i]) && remaining_len > 1)
    {
        if (remaining_len)
        {
          remaining_len--;
          *start = _T(' ');
          start++;
        }

        // $$ if 4th parameter, maxbuffer = 0, LoadString doesn't return zero as advertised
        // reported to MS 9/29/1998
        len = ::LoadString(m_hInst, ids[i], start, remaining_len);
        start += len;
        remaining_len -= len;
    }
  }

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\svclib\sources.inc ===
TARGETNAME=proccon
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=library

USE_MSVCRT=1

USE_MFC=1
SOURCES=procconsvcmsg.mc \
        procconutility.cpp \
        procconversion.cpp

!IF 0
UMTYPE=console
!ENDIF

UMTYPE=windows
MSC_WARNING_LEVEL=/WX /W3

INCLUDES=..\service
USER_INCLUDES=$(BASEDIR)\private\ntos\inc;$(BASEDIR)\private\ntos\rtl

UMENTRY=winmain

MISCFILES=..\help\apimon.hlp

NTTARGETFILE0=procconsvcmsg.h

TARGETLIBS= \
    $(SDK_LIB_PATH)\comctl32.lib \
    $(SDK_LIB_PATH)\dbghelp.lib \
    $(SDK_LIB_PATH)\comdlg32.lib \
    $(SDK_LIB_PATH)\shell32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\svclib\procconversion.cpp ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    version.cpp                                                              //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|Created:      Paul Skoglund 09-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#include "..\SERVICE\ProcConSvc.h"

CVersion::CVersion(HINSTANCE hInst) : m_hInst(hInst), m_bInitializedOK(FALSE), m_fixedLen( 0 )
{
  memset(&szFileVersion,       0, sizeof(szFileVersion)       );
  memset(&szProductVersion,    0, sizeof(szProductVersion)    );
  memset(&szFileFlags,         0, sizeof(szFileFlags)         );
  memset(&m_fixed_info,        0, sizeof(m_fixed_info)        );

  m_bDebug = m_bPatched = m_bPreRelease = m_bPrivateBuild = m_bSpecialBuild = FALSE;

  TCHAR  szFileName[_MAX_PATH + 1] = { 0 };

  PCULONG32  dwBogus = 0;
  PCULONG32  dwSize = 0;
  LPVOID     hMem = NULL;

  if ( GetModuleFileName(hInst, szFileName, ENTRY_COUNT(szFileName)) && 
       (dwSize = GetFileVersionInfoSize(szFileName, &dwBogus)) &&
       (hMem = new BYTE[dwSize]) )
  {
    if (GetFileVersionInfo(szFileName, NULL, dwSize, hMem) )
    {
      void *p;
      if (VerQueryValue( hMem, _T("\\"), &p, &m_fixedLen) )
      {
        memcpy( &m_fixed_info, p, sizeof(m_fixed_info) );
        m_bInitializedOK = ParseFixedInfo();
      }
      LoadStringFileInfo(hMem);
    }
    delete [] hMem;
  }
}

BOOL CVersion::LoadStringFileInfo(LPVOID hMem)
{
#ifndef UNICODE
#error "what code-page to use?  window-multilingual? 0x04e4"
#endif

  UINT uLen;
  TCHAR buf[128];
  TCHAR *info; 
  // it is my understanding that the string below are identified with the same english string under each language
  // $$ confirm? yes/no
  struct 
  {
    TCHAR   *name;
    tstring *target;
  } table[] = {
    { _T("CompanyName"),    &strCompanyName   }, { _T("FileDescription"), &strFileDescription  },
    { _T("FileVersion"),    &strFileVersion   }, { _T("InternalName"),    &strInternalName     },
    { _T("LegalCopyright"), &strLegalCopyright}, { _T("OriginalFilename"),&strOriginalFilename }, 
    { _T("ProductName"),    &strProductName   }, { _T("ProductVersion"),  &strProductVersion   },
    { _T("Comments"),       &strComments      }, { _T("LegalTrademarks"), &strLegalTrademarks  },
    { _T("PrivateBuild"),   &strPrivateBuild  }, { _T("SpecialBuild"),    &strSpecialBuild     }
  };

  buf[ENTRY_COUNT(buf) - 1] = 0;  //insure null termination
  for (int i = 0; i < ENTRY_COUNT(table); i++)
  { 
     // MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT)
    _sntprintf(buf, ENTRY_COUNT(buf) -1 , _T("\\StringFileInfo\\%04hx04b0\\%s"), GetUserDefaultLangID(), table[i].name);

    if (VerQueryValue( hMem, buf, (void **) &info, &uLen) )
    {
      *(table[i].target) = info; 
    }
  }

  return TRUE;

}

BOOL CVersion::ParseFixedInfo( void )
{  
  assert( m_fixedLen == sizeof(VS_FIXEDFILEINFO) );

  if(m_fixedLen != sizeof(VS_FIXEDFILEINFO) )
    return FALSE;

  _stprintf(szFileVersion, _T("%hu.%hu.%hu.%hu"),
      HIWORD(m_fixed_info.dwFileVersionMS),
      LOWORD(m_fixed_info.dwFileVersionMS),
      HIWORD(m_fixed_info.dwFileVersionLS),
      LOWORD(m_fixed_info.dwFileVersionLS));

  _stprintf(szProductVersion, _T("%hu.%hu.%hu.%hu"),
      HIWORD(m_fixed_info.dwProductVersionMS),
      LOWORD(m_fixed_info.dwProductVersionMS),
      HIWORD(m_fixed_info.dwProductVersionLS),
      LOWORD(m_fixed_info.dwProductVersionLS));

  if ((m_fixed_info.dwFileFlagsMask & VS_FF_DEBUG) &&
      (m_fixed_info.dwFileFlags     & VS_FF_DEBUG) )
  {
    m_bDebug = TRUE;
  }
  if ((m_fixed_info.dwFileFlagsMask & VS_FF_PRERELEASE) &&
      (m_fixed_info.dwFileFlags &     VS_FF_PRERELEASE) )
  {
    m_bPreRelease = TRUE;
  }
  if ((m_fixed_info.dwFileFlagsMask & VS_FF_PATCHED ) &&
      (m_fixed_info.dwFileFlags     & VS_FF_PATCHED ) )
  {
    m_bPatched = TRUE;
  }
  if ((m_fixed_info.dwFileFlagsMask & VS_FF_PRIVATEBUILD ) &&
      (m_fixed_info.dwFileFlags     & VS_FF_PRIVATEBUILD ) )
  {
    m_bPrivateBuild = TRUE;
  }

  if ((m_fixed_info.dwFileFlagsMask & VS_FF_SPECIALBUILD ) &&
      (m_fixed_info.dwFileFlags     & VS_FF_SPECIALBUILD) )
  {
    m_bSpecialBuild = TRUE;
  }


  TCHAR *start = szFileFlags;
  int len = 0;
  int remaining_len = ENTRY_COUNT(szFileFlags) - 1;  // length in characters not bytes!

  int flags[] = {VS_FF_PATCHED, VS_FF_DEBUG, VS_FF_PRERELEASE, 0 };
  int ids[]   = {IDS_PATCHED,   IDS_DEBUG,   IDS_BETA,         0 };

  assert(ENTRY_COUNT(flags) == ENTRY_COUNT(ids));

  for (int i = 0; flags[i], ids[i]; i++)
  {
    if ((m_fixed_info.dwFileFlagsMask & flags[i]) &&
        (m_fixed_info.dwFileFlags     & flags[i]) && remaining_len > 1)
    {
        if (remaining_len)
        {
          remaining_len--;
          *start = _T(' ');
          start++;
        }

        // $$ if 4th parameter, maxbuffer = 0, LoadString doesn't return zero as advertised
        // reported to MS 9/29/1998
        len = ::LoadString(m_hInst, ids[i], start, remaining_len);
        start += len;
        remaining_len -= len;
    }
  }

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\svclib\procconversion.h ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    version.h                                                                //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|Created:      Paul Skoglund 09-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#ifndef __VERSION_H_
#define __VERSION_H_

#pragma warning(push)
#include <string>
#pragma warning(pop)

using std::basic_string;

typedef basic_string<TCHAR> tstring;

class CVersion {
  public:
    CVersion(HINSTANCE hInst);
    ~CVersion() { }

    // retrieve info from the fixed section of the version resource
    LPCTSTR GetFileVersion()           const { return szFileVersion;                   }
    LPCTSTR GetProductVersion()        const { return szProductVersion;                }
    LPCTSTR GetFileFlags()             const { return szFileFlags;                     }
    UINT32  GetFixedSignature()        const { return m_fixed_info.dwSignature;        }     
    UINT32  GetFixedFileVersionMS()    const { return m_fixed_info.dwFileVersionMS;    } 
    UINT32  GetFixedFileVersionLS()    const { return m_fixed_info.dwFileVersionLS;    }     
    UINT32  GetFixedProductVersionMS() const { return m_fixed_info.dwProductVersionMS; } 
    UINT32  GetFixedProductVersionLS() const { return m_fixed_info.dwProductVersionLS; }     
    UINT32  GetFixedFileFlags()        const { return m_fixed_info.dwFileFlags;        } 
    UINT32  GetFixedFileOS()           const { return m_fixed_info.dwFileOS;           }     
    UINT32  GetFixedFileType()         const { return m_fixed_info.dwFileType;         }     
    UINT32  GetFixedFileSubtype()      const { return m_fixed_info.dwFileSubtype;      } 
    UINT32  GetFixedFileDateMS()       const { return m_fixed_info.dwFileDateMS;       }     
    UINT32  GetFixedFileDateLS()       const { return m_fixed_info.dwFileDateLS;       }

    BOOL    IsDebug()                const { return m_bDebug;        }
    BOOL    IsPatched()              const { return m_bPatched;      }
    BOOL    IsPreRelease()           const { return m_bPreRelease;   }
    BOOL    IsPrivateBuild()         const { return m_bPrivateBuild; }
    BOOL    IsSpecialBuild()         const { return m_bSpecialBuild; }

    // retrieve info from StringFileInfo section of the version resource
    LPCTSTR strGetCompanyName()      const { return strCompanyName.c_str();     }
    LPCTSTR strGetFileDescription()  const { return strFileDescription.c_str(); }
    LPCTSTR strGetFileVersion()      const { return strFileVersion.c_str();     }
    LPCTSTR strGetInternalName()     const { return strInternalName.c_str();    }
    LPCTSTR strGetLegalCopyright()   const { return strLegalCopyright.c_str();  }
    LPCTSTR strGetOriginalFilename() const { return strOriginalFilename.c_str();}
    LPCTSTR strGetProductName()      const { return strProductName.c_str();     }
    LPCTSTR strGetProductVersion()   const { return strProductVersion.c_str();  }
    LPCTSTR strGetComments()         const { return strComments.c_str();        }
    LPCTSTR strGetLegalTrademarks()  const { return strLegalTrademarks.c_str(); }
    LPCTSTR strGetPrivateBuild()     const { return strPrivateBuild.c_str();    }
    LPCTSTR strGetSpecialBuild()     const { return strSpecialBuild.c_str();    }

  private:
    HINSTANCE        m_hInst;    
    BOOL             m_bInitializedOK;

    BOOL  m_bDebug, m_bPatched, m_bPreRelease, m_bPrivateBuild, m_bSpecialBuild;

    VS_FIXEDFILEINFO m_fixed_info;
    UINT             m_fixedLen;

    TCHAR szFileVersion[24];
    TCHAR szProductVersion[24];
    TCHAR szFileFlags[64];

    tstring strCompanyName;
    tstring strFileDescription;
    tstring strFileVersion;
    tstring strInternalName;
    tstring strLegalCopyright;
    tstring strOriginalFilename;
    tstring strProductName;
    tstring strProductVersion;
    tstring strComments;
    tstring strLegalTrademarks;
    tstring strPrivateBuild;
    tstring strSpecialBuild;

    BOOL ParseFixedInfo( void );
    BOOL LoadStringFileInfo(LPVOID hMen);

};

#endif // __VERSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\procmon\procmon.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    procmon.c

Abstract:

    Little program for recording the various idle states of a machine

Author:

    John Vert (jvert) 1/14/2000

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <conio.h>

#define DISPLAY_TOTAL 0
#define DISPLAY_DELTA 1
#define DISPLAY_RAW   2
#define DISPLAY_INFO  3
#define DISPLAY_TRANS 4

int Display=DISPLAY_TOTAL;
int LastDisplay=DISPLAY_TOTAL;
LONG DelayTime = 5;

#define printtime(_x_) {                                               \
        ULONGLONG ms = (_x_)/10000;                                    \
        ULONG hours, minutes, seconds;                                 \
        hours = (ULONG)ms/(1000*60*60);                                \
        if (hours) printf("%3d:",(ULONG)(ms/(1000*60*60)));            \
        ms=ms%(1000*60*60);                                            \
        minutes = (ULONG)ms/(1000*60);                                 \
        if (minutes || hours) printf("%02d:",(ULONG)(ms/(1000*60)));   \
        ms=ms%(1000*60);                                               \
        seconds = (ULONG)ms/1000;                                      \
        printf("%02d.",seconds);                                       \
        ms=ms%1000;                                                    \
        printf("%03d",(ULONG)ms);                                      \
    }

__cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    CHAR            Buff[sizeof(SYSTEM_PROCESSOR_POWER_INFORMATION)*MAXIMUM_PROCESSORS];
    PSYSTEM_PROCESSOR_POWER_INFORMATION PowerInfo = (PSYSTEM_PROCESSOR_POWER_INFORMATION)Buff;
    ULONG           Length;
    NTSTATUS        Status;
    UCHAR           LastAdjustedBusyFrequency[MAXIMUM_PROCESSORS];
    UCHAR           LastBusyFrequency[MAXIMUM_PROCESSORS];
    UCHAR           LastC3Frequency[MAXIMUM_PROCESSORS];
    ULONGLONG       LastFrequencyTime[MAXIMUM_PROCESSORS];
    ULONG           PromotionCount[MAXIMUM_PROCESSORS];
    ULONG           DemotionCount[MAXIMUM_PROCESSORS];
    ULONGLONG       LastIdleTime[MAXIMUM_PROCESSORS];
    ULONGLONG       LastKernelTime[MAXIMUM_PROCESSORS];
    ULONGLONG       DeltaTime;
    ULONG           i;
    ULONG           NumProc;
    LARGE_INTEGER   Delay;
    ULONG           Delta;

    for (i = 0; i < MAXIMUM_PROCESSORS; i++) {

        LastFrequencyTime[i] = 0;
        PromotionCount[i] = DemotionCount[i] = 0;

    }

    while (1) {
        if (_kbhit()) {
            int Char=_getch();
            switch (toupper(Char)) {
                case 'T':
                    LastDisplay = Display = DISPLAY_TOTAL;
                    break;
                case 'E':
                    LastDisplay = Display = DISPLAY_TRANS;
                    break;
                case 'D':
                    LastDisplay = Display = DISPLAY_DELTA;
                    break;
                case 'R':
                    LastDisplay = Display = DISPLAY_RAW;
                    break;
                case 'I':
                    LastDisplay = Display;
                    Display = DISPLAY_INFO;
                    break;
                case '+':
                    DelayTime++;
                    printf("New delay is %d seconds.\n",DelayTime);
                    break;
                case '-':
                    if (DelayTime > 2) {
                        DelayTime--;
                        printf("New delay is %d seconds.\n",DelayTime);
                    } else {
                        printf("Delay cannot drop below %d seconds.\n",DelayTime);
                    }
                    break;
                case 'Q':
                    return 0;
                case 'P':
                    printf("Hit a key to continue\n");
                    _getch();
                    break;

                default:
                    printf("Type :\n");
                    printf("\t'T'     - display Total\n");
                    printf("\t'E'     - display Transitions\n");
                    printf("\t'D'     - display Delta\n");
                    printf("\t'R'     - display Raw\n");
                    printf("\t'I'     - display quick info\n");
                    printf("\t'+'/'-' - increase/decrease time pause\n");
                    printf("\t'Q'     - Quit\n");
                    printf("\t'P'     - Pause\n");

            }
        }
        Status = NtQuerySystemInformation(
            SystemProcessorPowerInformation,
            PowerInfo,
            sizeof(Buff),
            &Length
            );
        if (!NT_SUCCESS(Status)) {

            fprintf(stderr, "NtQuerySystemInformation failed: %lx\n",Status);
            return(Status);

        }

        NumProc = Length/sizeof(SYSTEM_PROCESSOR_POWER_INFORMATION);
        for (i=0;i<NumProc;i++) {

            if (NumProc > 1) {

                printf("%2d>",i);

            }

            switch (Display) {
                case DISPLAY_TOTAL:
                    printf("Freq %3d%% (%3d%% %3d%% %3d%%) ",
                           PowerInfo[i].CurrentFrequency,
                           PowerInfo[i].LastAdjustedBusyFrequency,
                           PowerInfo[i].LastBusyFrequency,
                           PowerInfo[i].LastC3Frequency
                           );
                    printtime(PowerInfo[i].CurrentFrequencyTime);
                    printf(" Sys ");
                    printtime(PowerInfo[i].CurrentProcessorTime);
                    printf(" Idle ");
                    printtime(PowerInfo[i].CurrentProcessorIdleTime);
                    break;
                case DISPLAY_TRANS:
                    printf("Freq %3d%% (%3d%% %3d%% %3d%%) ",
                           PowerInfo[i].CurrentFrequency,
                           PowerInfo[i].LastAdjustedBusyFrequency,
                           PowerInfo[i].LastBusyFrequency,
                           PowerInfo[i].LastC3Frequency
                           );
                    printf("#P: %d #D %d #E: %d #R: %d",
                           PowerInfo[i].PromotionCount,
                           PowerInfo[i].DemotionCount,
                           PowerInfo[i].ErrorCount,
                           PowerInfo[i].RetryCount
                           );
                    break;
                case DISPLAY_DELTA:
                    printf("Freq %3d%% (%3d%% %3d%% %3d%%) ",
                           PowerInfo[i].CurrentFrequency,
                           (PowerInfo[i].LastAdjustedBusyFrequency - LastAdjustedBusyFrequency[i]),
                           (PowerInfo[i].LastBusyFrequency - LastBusyFrequency[i]),
                           (PowerInfo[i].LastC3Frequency - LastC3Frequency[i])
                           );
                    DeltaTime = PowerInfo[i].CurrentFrequencyTime - LastFrequencyTime[i];
                    printtime(DeltaTime);
                    printf(" Sys ");
                    printtime((PowerInfo[i].CurrentProcessorTime - LastKernelTime[i]));
                    printf(" Idle ");
                    printtime((PowerInfo[i].CurrentProcessorIdleTime - LastIdleTime[i]));
                    break;

                case DISPLAY_RAW:
                    printf("Freq %3d%% (%3d%% %3d%% %3d%%) %I64X #E %8d #R %8d",
                           PowerInfo[i].CurrentFrequency,
                           PowerInfo[i].LastAdjustedBusyFrequency,
                           PowerInfo[i].LastBusyFrequency,
                           PowerInfo[i].LastC3Frequency,
                           PowerInfo[i].CurrentFrequencyTime,
                           PowerInfo[i].ErrorCount,
                           PowerInfo[i].RetryCount
                           );
                    break;
                case DISPLAY_INFO:
                    printf("Frequencies: Current =%3d%% MaxProc =%3d%% MinProc =%3d%%\n"
                           "Percentages: Adjusted=%3d%% Busy    =%3d%% C3      =%3d%%\n"
                           "Limiters:    Thermal =%3d%% Constant=%3d%% Degraded=%3d%%\n"
                           "Counts:      Promote =%4d Demote =%4d\n"
                           "Status:      Retries =%4d Errors =%4d",
                           PowerInfo[i].CurrentFrequency,
                           PowerInfo[i].ProcessorMaxThrottle,
                           PowerInfo[i].ProcessorMinThrottle,
                           PowerInfo[i].LastAdjustedBusyFrequency,
                           PowerInfo[i].LastBusyFrequency,
                           PowerInfo[i].LastC3Frequency,
                           PowerInfo[i].ThermalLimitFrequency,
                           PowerInfo[i].ConstantThrottleFrequency,
                           PowerInfo[i].DegradedThrottleFrequency,
                           PowerInfo[i].PromotionCount,
                           PowerInfo[i].DemotionCount,
                           PowerInfo[i].RetryCount,
                           PowerInfo[i].ErrorCount
                           );
                    break;
            }

            LastAdjustedBusyFrequency[i] = PowerInfo[i].LastAdjustedBusyFrequency;
            LastBusyFrequency[i] = PowerInfo[i].LastBusyFrequency;
            LastC3Frequency[i] = PowerInfo[i].LastC3Frequency;
            LastFrequencyTime[i] = PowerInfo[i].CurrentFrequencyTime;
            PromotionCount[i] = PowerInfo[i].PromotionCount;
            DemotionCount[i] = PowerInfo[i].DemotionCount;
            LastIdleTime[i] = PowerInfo[i].CurrentProcessorIdleTime;
            LastKernelTime[i] = PowerInfo[i].CurrentProcessorTime;
            printf("\n");
        }

        //
        // Revert Back to whatever we were displaying before...
        //
        if (Display != LastDisplay) {

            Display = LastDisplay;

        }

        Delay.QuadPart = - DelayTime * 1000 * 1000 * 10;
        NtDelayExecution(FALSE, &Delay);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\svclib\procconutility.cpp ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998, 1999 Sequent Computer Systems, Incorporated.  All rights reserved. //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|---------------------------------------------------------------------------------------//            
|   This file contains utility functions: error reporting, etc.                         //
|---------------------------------------------------------------------------------------//            
|                                                                                       //
|Created:                                                                               //
|                                                                                       //
|   Jarl McDonald 04-99 (from earlier code in ProcCon service                           //
|                                                                                       //
|Revision History:                                                                      //
|                                                                                       //
|   Jarl McDonald 03-00 Look up Administrators Name rather than use hard-coded          //
|   Paul Skoglund 04-01 Add formatting functions to support logging of rule edits       //
|                                                                                       //
|=======================================================================================*/
#include "..\SERVICE\ProcConSvc.h"
#include <aclapi.h>

//--------------------------------------------------------------------------------//
// Globals                                                                        //
//--------------------------------------------------------------------------------//
 TCHAR  PROCCON_SVC_DISP_NAME[128]                              
    = { TEXT("Process Control") };          // Service display name
 TCHAR  PROCCON_MEDIATOR_DISP_NAME[128]                         
    = { TEXT("Process Control Mediator") }; // Mediator display name 
 TCHAR  PROCCON_UNKNOWN_PROCESS[32]                             
    = { TEXT("unknown") };                  // Name used for the already terminated process
 TCHAR  PROCCON_SERVICE_DESCRIPTION[256]                        
    = { TEXT("Provides control and grouping of running processes.") };  
 TCHAR  PROCCON_DEFAULT_NAMERULE_DESC[NAME_DESCRIPTION_LEN + 1] 
    = { TEXT("---Default Alias Rule---") }; // Default alias rule desc 
 TCHAR  PROCCON_FLAG_ON[32] 
    = { TEXT("on") };                       // Name used to indicate rule option is on 
 TCHAR  PROCCON_FLAG_OFF[32] 
    = { TEXT("off") };                      // Name used to indicate rule option is off
 TCHAR  PROCCON_SYSTEM_PROCESS[32]                             
    = { TEXT("System") };                   // Name used for the 'System' process
 TCHAR  PROCCON_SYSTEM_IDLE[64]                             
    = { TEXT("System Idle Process") };      // Name used for the 'System Idle Process'
 TCHAR  PROCCON_SERVICE_USAGE[256]                             
#ifdef _DEBUG
    = { TEXT("Usage: proccsvc [-install user_password] [-reinstall user_password] [-remove] [-noService]\n") }             // Debug usage message
#else
    = { TEXT("Usage: proccsvc [-install user_password] [-reinstall user_password] [-remove]\n") }                          // Regular usage message
#endif
    ;

//=======================================================================================//
// Function to load our strings.
//
// Input:   none
// Returns: nothing -- if loads fail default values are set
//
void PCLoadStrings( void ) {

   static struct {
            PCULONG32  stringId;
            TCHAR     *stringLoc;
            PCULONG32  stringLen;
   } ourStrings[] = {
      { IDS_SERVICE_DISP_NAME,   PROCCON_SVC_DISP_NAME,         ENTRY_COUNT(PROCCON_SVC_DISP_NAME)         },
      { IDS_SERVICE_DESCRIPTION, PROCCON_SERVICE_DESCRIPTION,   ENTRY_COUNT(PROCCON_SERVICE_DESCRIPTION)   },
      { IDS_MEDIATOR_DISP_NAME,  PROCCON_MEDIATOR_DISP_NAME,    ENTRY_COUNT(PROCCON_MEDIATOR_DISP_NAME)    },
      { IDS_UNKNOWN_PROCESS,     PROCCON_UNKNOWN_PROCESS,       ENTRY_COUNT(PROCCON_UNKNOWN_PROCESS)       },
      { IDS_DEFAULT_NAMERULE,    PROCCON_DEFAULT_NAMERULE_DESC, ENTRY_COUNT(PROCCON_DEFAULT_NAMERULE_DESC) },
      { IDS_FLAG_ON,             PROCCON_FLAG_ON,               ENTRY_COUNT(PROCCON_FLAG_ON)               },
      { IDS_FLAG_OFF,            PROCCON_FLAG_OFF,              ENTRY_COUNT(PROCCON_FLAG_OFF)              },
      { IDS_SYSTEM_PROCESS,      PROCCON_SYSTEM_PROCESS,        ENTRY_COUNT(PROCCON_SYSTEM_PROCESS)        },
      { IDS_SYSTEM_IDLE,         PROCCON_SYSTEM_IDLE,           ENTRY_COUNT(PROCCON_SYSTEM_IDLE)           },
      { IDS_SERVICE_USAGE,       PROCCON_SERVICE_USAGE,         ENTRY_COUNT(PROCCON_SERVICE_USAGE)         },
   };

   for ( int i = 0; i < ENTRY_COUNT(ourStrings); ++i ) {
      LoadString( GetModuleHandle( NULL ), ourStrings[i].stringId, 
                  ourStrings[i].stringLoc, ourStrings[i].stringLen );
   }
}


//=======================================================================================//
// Function to test if we are running on Windows 2000 Datacenter Server.
//
// Input:   none
// Returns: TRUE if we are on Windows 2000 Datacenter Server, else FALSE
//
BOOL PCTestOSVersion( void ) {

   OSVERSIONINFOEX version;
   memset( &version, 0, sizeof( version ) );              // needed due to bug in Beta 3
   version.dwOSVersionInfoSize = sizeof( version );

   DWORDLONG condition = 0;
   VER_SET_CONDITION( condition, VER_PLATFORMID,   VER_EQUAL );
   VER_SET_CONDITION( condition, VER_MAJORVERSION, VER_GREATER_EQUAL );
   VER_SET_CONDITION( condition, VER_SUITENAME,    VER_AND );

   version.dwPlatformId   = VER_PLATFORM_WIN32_NT;
   version.dwMajorVersion = 5;
   version.wSuiteMask     = VER_SUITE_DATACENTER;

   return VerifyVersionInfo( &version, VER_PLATFORMID + VER_MAJORVERSION + VER_SUITENAME, condition );
}

//=======================================================================================//
// Function to test if an instance of the passed name is running (exists)
//
// Input:   name of exclusion object, display name of requestor or NULL
// Returns: TRUE if an instance of the object exists
//          FALSE if the object was newly created
//
BOOL PCTestIsRunning( const TCHAR *who, const TCHAR *dispName ) {

   HANDLE hEvent = OpenEvent( EVENT_ALL_ACCESS, FALSE, who );
   DWORD  rc     = GetLastError();

   if ( hEvent ) CloseHandle( hEvent );

   if ( !hEvent && rc != ERROR_FILE_NOT_FOUND && dispName ) {
      SetLastError( rc ) ;
      PCLogUnExError( who, TEXT("OpenExclEvent") );
   }

   return hEvent != NULL;
}

//=======================================================================================//
// Function to set exclusive access to the name (via an event)
//
// Input:   name of exclusion object, display name of requestor or NULL
// Returns: TRUE if an instance of an exclusive instance of the object was created
//          FALSE if the object already existed
//
BOOL PCSetIsRunning( const TCHAR *who, const TCHAR *dispName ) {

   DWORD  rc = TRUE;
   HANDLE hEvent;
   SECURITY_ATTRIBUTES secAttr;

   if ( !PCBuildNullSecAttr( secAttr ) ) {     // Everybody can access -- we want universal exclusion
      PCLogUnExError( who, TEXT("BuildNullSecAttr") );
      rc = FALSE;
   }
   
   else {
      hEvent = CreateEvent( &secAttr, TRUE, FALSE, who );
      if ( !hEvent ) {
         PCLogUnExError( who, TEXT("CreateExclEvent") );
         rc = FALSE;
      }
      else if ( GetLastError() == ERROR_ALREADY_EXISTS ) {
         if ( dispName ) PCLogMessage( PC_PROCESS_ALREADY_RUNNING, EVENTLOG_ERROR_TYPE, 1, dispName );
         CloseHandle( hEvent );
         rc = FALSE;
      }
   }

   PCFreeSecAttr( secAttr );
   return rc;
}

//=======================================================================================//
// Functions to build our registry keys.
//
// Input:   location to build key
// Returns: nothing
//
void PCBuildBaseKey( TCHAR *key ) {
   _tcscpy( key, PROCCON_REG_SERVICE_BASE );
   _tcscat( key, PROCCON_SVC_NAME );
}

void PCBuildMsgKey( TCHAR *key ) {
   _tcscpy( key, PROCCON_REG_SERVICE_BASE );
   _tcscat( key, PROCCON_REG_EVENTLOG_SUBKEY );
   _tcscat( key, PROCCON_SVC_NAME );
}

void PCBuildParmKey( TCHAR *key ) {
   PCBuildBaseKey( key );
   _tcscat( key, TEXT("\\") );
   _tcscat( key, PROCCON_REG_PARMS_SUBKEY );
}

//=======================================================================================//
// Functions to verify a name, type, etc.
//
//
#define TBLANK L' '
BOOL PCValidName( const TCHAR *name, const PCULONG32 len, const BOOL nullOK ) {
   for ( PCULONG32 i = 0; i < len; ++i ) {
      // hit terminator -- verify whole name: no leading or trailing blanks, not NULL unless OKed
      if ( !name[i] ) {
         if ( i ) {
            if ( name[0] == TBLANK || name[i - 1] == TBLANK ) return FALSE;     // leading/trailing blnk
            else return TRUE;
         }
         else return nullOK;                                                    // name is null
      }
      if ( _tcschr( TEXT("\\,\""), name[i] ) ) return FALSE;                    // hit invalid character
   }
   return FALSE;                                                                // no terminator
}

BOOL PCValidMatchType( const TCHAR type ) {
   return type == MATCH_PGM || type == MATCH_DIR || type == MATCH_ANY;
}

//=======================================================================================//
// Function to locate first occurrence of one string in another without regard to case.
//
// Input:   location of string to search (here), location of string to find (it) 
// Returns: location of first match or NULL
//
const TCHAR *PCiStrStr( const TCHAR *here, const TCHAR *it ) {
   const TCHAR firstchar = _totupper( *it );
   PCULONG32 len = _tcslen( it );

   for ( const TCHAR *at = here; ; ++at ) {
      while ( *at && firstchar != _totupper( *at ) ) ++at;
      if ( !*at ) return firstchar? NULL : at;
      if ( !_tcsnicmp( at, it, len ) ) return at;
   }

}

//=======================================================================================//
// Functions to convert a hex or decimal number to a PCULONG32 or __int64.
//
// Input:   location of data, location to set to end of data
// Returns: converted number
//
__int64 PCGetParmValue64( TCHAR *loc, TCHAR **end ) {
   PCULONG32 base = 10;
   if ( *(loc + 1) == TEXT('x') || *(loc + 1) == TEXT('X') ) {
      base = 16;
      loc += 2;
   }
   for ( __int64 result = 0; ; ++loc ) {
      TCHAR c = _totupper(*loc);
      if ( c >= TEXT('0') && c <= TEXT('9') ) 
         result = result * base + c - TEXT('0');
      else if ( base == 16 && c >= TEXT('A') && c <= TEXT('F') )
         result = result * base + 10 + c - TEXT('A');
      else { 
         *end = loc;
         break;
      }
   }
   return result;
}

PCULONG32 PCGetParmValue( TCHAR *loc, TCHAR **end ) {
   return (PCULONG32) PCGetParmValue64( loc, end );
}

//=======================================================================================//
// Function to test sign of __int64.
//
// Input:   integer to test
// Returns: +1, -1, or 0 depending on if integer is greater, less, or equal zero
//
int PCSignof64(__int64 x ) {
   return (x > 0)? 1 : (x < 0)? -1 : 0;
}

//=======================================================================================//
// Functions to report one of our errors in the Win2K event log.
//
// Input:   log message parameters: code, type, string count, string ptr, data len, data ptr
// Returns: nothing
//
void PCLogMessage( const PCULONG32  msgCode, 
                   const WORD       msgType, 
                         WORD       numStrings, 
                   const void      *msgStrings, 
                         ULONG      lenData, 
                         void      *msgData ) {

   // If no message data, use NT error as data
   PCULONG32 NTError;
   if ( !lenData && msgType != EVENTLOG_INFORMATION_TYPE ) {
      NTError = GetLastError();
      lenData = sizeof( NTError );
      msgData = &NTError;
   }

   // Make sure we successfully register...
   HANDLE hErrLog = RegisterEventSource( NULL, PROCCON_SVC_NAME );
	if ( !hErrLog ) return;

   // Prepare insertion argument list...
   const TCHAR *strings[64];
   // Make a local copy of string args to allow us to extend it.
   // For a single string just set up single entry table,
   // For a multi-entry table use the passed array.
   if ( numStrings == 1 )              
      strings[0] = (TCHAR *) msgStrings;
   else 
      memcpy( strings, msgStrings, sizeof(TCHAR *) * numStrings );

   // For error meassages add the NT error description to the argument list...
   TCHAR err[1024];
   if ( msgType == EVENTLOG_ERROR_TYPE ) {    
      PCNTErrorText( *(PCULONG32 *)msgData, err, ENTRY_COUNT(err) );
      strings[numStrings++] = err;
   }

   // Report the desired event...
   ReportEvent( hErrLog, msgType, 0, msgCode, NULL, 
                numStrings, lenData, strings, msgData );

   // de-register...
   DeregisterEventSource( hErrLog );
}

// Handle unexpected NT error by:
// 1. Setting up two strings -- an operand and an operation.
// 2. Getting the NT error.
// 3. Calling standard error fcn with strings and NT error.
void PCLogUnExError( const TCHAR *who, const TCHAR *what ) {
   const TCHAR *strings[2] = { who, what };
   DWORD err = GetLastError();

   PCLogMessage( PC_UNEXPECTED_NT_ERROR, EVENTLOG_ERROR_TYPE, 
                 ENTRY_COUNT(strings), strings, sizeof(err), &err );
}

// Handle PID-based unexpected NT error by:
// 1. Setting up two strings -- an operand as "PID nnn" and an operation.
// 2. Getting the NT error.
// 3. Calling standard error fcn with strings and NT error.
void PCLogUnExError( const __int64 pid, const TCHAR *what ) {
   TCHAR pidString[16];
   const TCHAR *strings[2] = { pidString, what };
   DWORD err = GetLastError();

   _tcscpy( pidString, TEXT("PID ") );
   _i64tot( pid, pidString + _tcslen(pidString), 10 );

   PCLogMessage( PC_UNEXPECTED_NT_ERROR, EVENTLOG_ERROR_TYPE, 
                 ENTRY_COUNT(strings), strings, sizeof(err), &err );
}

// Handle insufficient memory by:
// 1. Setting up two strings -- a size string and the passed identifying string.
// 2. Setting an NT error of ERROR_NOT_ENOUGH_MEMORY (no error set by new).
// 3. Calling standard error fcn with strings and NT error.
PCULONG32 PCLogNoMemory( const TCHAR *string, const PCULONG32 len ) {
   TCHAR size[1024]; 
   const TCHAR *strings[2] = { size, string };
   DWORD err = ERROR_NOT_ENOUGH_MEMORY;

   _stprintf( size, TEXT("0x%lx"), len );

   PCLogMessage( PC_CANT_GET_MEMORY, EVENTLOG_ERROR_TYPE, 
                 ENTRY_COUNT(strings), strings, sizeof(err), &err );

   return PC_CANT_GET_MEMORY;
}

//=======================================================================================//
// Function to get text for a Win2K error
//
// Input:   error, buffer pointer, buffer length
// Returns: pointer to buffer
// Note:    trailing returns are stripped from the message.
//
LPTSTR PCNTErrorText( PCULONG32 error, LPTSTR buf, PCULONG32 size )
{
   PCULONG32 dwRet = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | 
                                    FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                    FORMAT_MESSAGE_IGNORE_INSERTS,
                                    NULL, error, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), buf, size, NULL );
   if (!dwRet) {
      if (size)
         buf[size - 1] = 0;
      _sntprintf( buf, size - 1, TEXT("0x%lx"), error );
   } 
   else {
      while ( --dwRet && (buf[dwRet] == TEXT('\n') || buf[dwRet] == TEXT('\r')) ) 
         buf[dwRet] = TEXT('\0');
   }

   return buf;
}

//=======================================================================================//
// Functions to determine if management behavior is requested in a process/job definition
//
// Input:   ref to management definition
// Returns: TRUE if any management behavior would be applied, else FALSE
//
BOOL PCIsProcManaged( MGMT_PARMS &def, JOB_NAME *job ) {
   if      ( def.mFlags & PCMFLAG_APPLY_JOB_MEMBERSHIP &&  job[0] )                 return TRUE;
   else if ( def.mFlags & PCMFLAG_APPLY_AFFINITY       &&  def.affinity )           return TRUE;
   else if ( def.mFlags & PCMFLAG_APPLY_PRIORITY       &&  def.priority )           return TRUE;
   else if ( def.mFlags & PCMFLAG_APPLY_WS_MINMAX      &&  def.minWS && def.maxWS ) return TRUE;

   return FALSE;
}

BOOL PCIsJobManaged( MGMT_PARMS &def ) {
   if      ( def.mFlags & (PCMFLAG_SET_PROC_BREAKAWAY_OK | 
                           PCMFLAG_SET_SILENT_BREAKAWAY  | 
                           PCMFLAG_SET_DIE_ON_UH_EXCEPTION) )                         return TRUE;
   else if ( def.mFlags & PCMFLAG_APPLY_AFFINITY          && def.affinity )           return TRUE;
   else if ( def.mFlags & PCMFLAG_APPLY_PRIORITY          && def.priority )           return TRUE;
   else if ( def.mFlags & PCMFLAG_APPLY_WS_MINMAX         && def.minWS && def.maxWS ) return TRUE;
   else if ( def.mFlags & PCMFLAG_APPLY_SCHEDULING_CLASS  && def.schedClass < 10 )    return TRUE;
   else if ( def.mFlags & PCMFLAG_APPLY_PROC_MEMORY_LIMIT && def.procMemoryLimit )    return TRUE;
   else if ( def.mFlags & PCMFLAG_APPLY_JOB_MEMORY_LIMIT  && def.jobMemoryLimit )     return TRUE;
   else if ( def.mFlags & PCMFLAG_APPLY_JOB_TIME_LIMIT    && def.jobTimeLimitCNS )    return TRUE;
   else if ( def.mFlags & PCMFLAG_APPLY_PROC_TIME_LIMIT   && def.procTimeLimitCNS )   return TRUE;
   else if ( def.mFlags & PCMFLAG_APPLY_PROC_COUNT_LIMIT  && def.procCountLimit )     return TRUE;

   return FALSE;
}

//=======================================================================================//
// Function to return a string representing if a flag is set:
//
// Input:    field and flag value for the field in question
// Returns:  string representation of if a flag is set
LPCTSTR PCIsSetToStr(PC_MGMT_FLAGS field, PCMgmtFlags flag)
{ 
  if (field & flag)
    return TEXT("+");
  else 
    return TEXT("-");
}

//=======================================================================================//
// Functions to determine if one flag setting is opposite another flag setting:
//
// Input:   flag field and flag value for the two fields in question
// Returns:  1 if first flag is set and second flag is unset
//          -1 if first flag is unset and second flag is set
//           0 if both flags are set or unset
//
int PCTestSetUnset( DWORD field1, DWORD flag1, DWORD field2, DWORD flag2 ) {
   if ( field1 & flag1 && !(field2 & flag2) ) return 1;
   if ( !(field1 & flag1) && field2 & flag2 ) return -1;
   return 0;
}

//=======================================================================================//
// Functions to map PC priority (same as toolhelp priority) to NT priority and back
//
// Input:   priority to map
// Returns: mapped priority
//
PCULONG32 PCMapPriorityToNT( PRIORITY prio ) {
   if      ( prio > 15 ) return REALTIME_PRIORITY_CLASS;      // 16 and above
   else if ( prio > 11 ) return HIGH_PRIORITY_CLASS;          // 12-15
   else if ( prio >  9 ) return ABOVE_NORMAL_PRIORITY_CLASS;  // 10-11
   else if ( prio >  7 ) return NORMAL_PRIORITY_CLASS;        // 8-9
   else if ( prio >  5 ) return BELOW_NORMAL_PRIORITY_CLASS;  // 6-7    
   else if ( prio >  0 ) return IDLE_PRIORITY_CLASS;          // 1-5

   return 0;
}

PRIORITY PCMapPriorityToPC( PCULONG32 prio ) {
   if      ( prio & REALTIME_PRIORITY_CLASS      ) return PCPrioRealTime;
   else if ( prio & HIGH_PRIORITY_CLASS          ) return PCPrioHigh;        
   else if ( prio & ABOVE_NORMAL_PRIORITY_CLASS  ) return PCPrioAboveNormal; 
   else if ( prio & NORMAL_PRIORITY_CLASS        ) return PCPrioNormal;     
   else if ( prio & BELOW_NORMAL_PRIORITY_CLASS  ) return PCPrioBelowNormal;    
   else if ( prio & IDLE_PRIORITY_CLASS          ) return PCPrioIdle;         

   return 0;
}

PRIORITY PCMapPriorityForAPI( PRIORITY prio ) {
   if      ( prio > 15 ) return PCPrioRealTime;
   else if ( prio > 11 ) return PCPrioHigh;
   else if ( prio >  9 ) return PCPrioAboveNormal;
   else if ( prio >  7 ) return PCPrioNormal;
   else if ( prio >  5 ) return PCPrioBelowNormal;   
   else if ( prio >  0 ) return PCPrioIdle;

   return 0;
}

//=======================================================================================//
// Functions to map NT defined long numbers to int 64's
//
// Input:   numeric field format to convert
// Returns: int64 version of data
//
__int64 PCLargeIntToInt64( LARGE_INTEGER &in ) {
   return in.QuadPart;
}
__int64 PCFileTimeToInt64( FILETIME &in ) {
   return ((__int64) in.dwHighDateTime << 32) + (__int64) in.dwLowDateTime;
}

//=======================================================================================//
// Function to delete a registry key by deleting all subkeys first
//
// Input:   handle to open key, name of subkey tree to delete
// Returns: NT return code
//
PCULONG32 PCDeleteKeyTree( HKEY hKey, const TCHAR *keyName ) {
   PCULONG32 rc, ourCount;
   HKEY      ourKey;

   // Open the key at top of tree...
   rc = RegOpenKeyEx( hKey, keyName, NULL, KEY_READ + KEY_WRITE, &ourKey );
   if ( rc == ERROR_FILE_NOT_FOUND || rc == ERROR_KEY_DELETED )    // nothing to do
      return ERROR_SUCCESS;   
   else if ( rc != ERROR_SUCCESS ) {
      SetLastError( rc );
     	PCLogUnExError( keyName, TEXT("RegOpenKeyEx") );
      return rc;
   }

   // Determine how many subkeys we have...
   rc = RegQueryInfoKey( ourKey, NULL, NULL, NULL, &ourCount, 
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL );
   if ( rc != ERROR_SUCCESS ) {                    // Should never happen
      SetLastError( rc );
     	PCLogUnExError( keyName, TEXT("RegQueryInfoKey") );
      return rc;
   }

   // For each sub-key delete its sub-tree...
   for ( PCULONG32 i = 0; rc == ERROR_SUCCESS && i < ourCount; ++i ) {

      // Get next subkey...
      TCHAR name[MAX_PATH];
      FILETIME keyLastWrite;
      PCULONG32    nameLen = ENTRY_COUNT(name);
      rc = RegEnumKeyEx( ourKey, ourCount - 1 - i, name, &nameLen, NULL, NULL, NULL, &keyLastWrite );
      if ( rc == ERROR_NO_MORE_ITEMS ) {
         rc = ERROR_SUCCESS;
         break;
      }
      if ( rc != ERROR_SUCCESS ) {                   // Should never happen
         SetLastError( rc );
        	PCLogUnExError( keyName, TEXT("RegEnumKeyEx") );
         return rc;
      }
      rc = PCDeleteKeyTree( ourKey, name );
   }

   // Close the key at top of tree and delete it...
   RegCloseKey( ourKey );
   if ( rc == ERROR_SUCCESS ) 
      rc = RegDeleteKey( hKey, keyName );

   return rc == ERROR_KEY_DELETED? ERROR_SUCCESS : rc;
}

//=======================================================================================//
// Function to enable/disable an NT user privilege
//
// Input:   ptr to name of privilege, enable/disable flag
// Returns: TRUE if successful, else FALSE
//
BOOL PCSetPrivilege( TCHAR *privilege, BOOL enable ) {

   HANDLE hTok = NULL;
   BOOL   ok   = TRUE;

   // Build token to enable or disable the privilege...
   TOKEN_PRIVILEGES priv;
   priv.PrivilegeCount           = 1;
   priv.Privileges[0].Attributes = enable? SE_PRIVILEGE_ENABLED : 0;

   // Get access token handle...
   if ( !OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hTok ) ) {
     	PCLogUnExError( privilege, TEXT("OpenProcessToken") );
      ok = FALSE;
   }

   // Look up privilege to set local ID...
   else if ( !LookupPrivilegeValue( NULL, privilege, &priv.Privileges[0].Luid ) ) {
     	PCLogUnExError( privilege, TEXT("LookupPrivilegeValue") );
      ok = FALSE; 
   }
   
   // Update privilege...
   else if ( !AdjustTokenPrivileges( hTok, FALSE, &priv, sizeof(TOKEN_PRIVILEGES), NULL, NULL ) ) {  
     	PCLogUnExError( privilege, TEXT("Adjustprivileges") );
      ok = FALSE; 
   }
   
   if ( hTok ) CloseHandle( hTok );
   return ok;
}

//=======================================================================================//
// Function to create a security attributes with NULL security descriptor
//
// Input:   reference to security attribue structure to build
// Returns: TRUE if successful, else FALSE
//
PCULONG32 PCBuildNullSecAttr( SECURITY_ATTRIBUTES &secAttr ) {

   BOOL ok = TRUE;

   // Init passed attributes struct...
   secAttr.nLength              = sizeof(secAttr); 
   secAttr.lpSecurityDescriptor = new char[SECURITY_DESCRIPTOR_MIN_LENGTH]; 
   secAttr.bInheritHandle       = TRUE; 

   if ( !secAttr.lpSecurityDescriptor ) {
      PCLogNoMemory( TEXT("AllocSecurityDesc"), SECURITY_DESCRIPTOR_MIN_LENGTH );
      ok = FALSE;
   }
   else if ( !InitializeSecurityDescriptor(secAttr.lpSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION) ) { 
      PCLogUnExError( TEXT("NullAttr"), TEXT("InitializeSecurityDescriptor") ); 
      ok = FALSE;
   } 
 
   // add a NULL discretionary ACL... 
   else if ( !SetSecurityDescriptorDacl(secAttr.lpSecurityDescriptor, TRUE, NULL, FALSE) ) { 
      PCLogUnExError( TEXT("NullAttr"), TEXT("SetSecurityDescriptorDacl") ); 
      ok = FALSE;
   } 
 
   if ( !ok && secAttr.lpSecurityDescriptor ) {  
      delete [] secAttr.lpSecurityDescriptor;  
      secAttr.lpSecurityDescriptor = NULL;  
   }
   return ok;
}
 
//=======================================================================================//
// Function to create a security attributes with ADMINISTRATORS security descriptor
//
// Input:   reference to security attribue structure to build
// Returns: TRUE if successful, else FALSE
//
PCULONG32 PCBuildAdminSecAttr( SECURITY_ATTRIBUTES &secAttr ) {

#define ADMIN_NAME_LEN 256
   BOOL      ok = TRUE;
   TCHAR     AdminName[ADMIN_NAME_LEN+1];
   PCULONG32 AdminNameLen = ADMIN_NAME_LEN;

   // Init passed attributes struct...
   secAttr.nLength              = sizeof(secAttr); 
   secAttr.lpSecurityDescriptor = new char[SECURITY_DESCRIPTOR_MIN_LENGTH]; 
   secAttr.bInheritHandle       = FALSE; 

   if ( !secAttr.lpSecurityDescriptor ) {
      PCLogNoMemory( TEXT("AllocSecurityDesc"), SECURITY_DESCRIPTOR_MIN_LENGTH );
      ok = FALSE;
   }
   else if ( !InitializeSecurityDescriptor(secAttr.lpSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION) ) { 
      PCLogUnExError( TEXT("AdminAttr"), TEXT("InitializeSecurityDescriptor") ); 
      ok = FALSE;
   }
   else if( !PCGetAdminGroupName( AdminName, &AdminNameLen) ) 
      ok = FALSE;
   else {
      EXPLICIT_ACCESS  adminAccess[2];
      ACL             *adminACL = NULL;

      BuildExplicitAccessWithName( &adminAccess[0], 
                                   TEXT("SYSTEM"),                               // access is for system 
                                   STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL,    // access is for all rights
                                   GRANT_ACCESS,                                 // ace grants access
                                   OBJECT_INHERIT_ACE );                         // objects inherit access
      BuildExplicitAccessWithName( &adminAccess[1], 
                                   AdminName,                                    // access is for admins 
                                   STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL,    // access is for all rights
                                   GRANT_ACCESS,                                 // ace grants access
                                   OBJECT_INHERIT_ACE );                         // objects inherit access
      if ( ERROR_SUCCESS != SetEntriesInAcl( 2, adminAccess, NULL, &adminACL ) ) {
         PCLogUnExError( TEXT("AdminAttr"), TEXT("SetEntriesInAcl") ); 
         ok = FALSE;
      }
      else if ( !SetSecurityDescriptorDacl( secAttr.lpSecurityDescriptor, TRUE, adminACL, FALSE ) ) {
         PCLogUnExError( TEXT("AdminAttr"), TEXT("SetSecurityDescriptorDacl") ); 
         ok = FALSE;
      }
   }
 
   if ( !ok && secAttr.lpSecurityDescriptor ) {  
      delete [] secAttr.lpSecurityDescriptor;  
      secAttr.lpSecurityDescriptor = NULL;  
   }
   return ok;
}
 
void PCFreeSecAttr( SECURITY_ATTRIBUTES &secAttr ) {
   if ( secAttr.lpSecurityDescriptor ) {
      if ( ((SECURITY_DESCRIPTOR *)(secAttr.lpSecurityDescriptor))->Dacl )
         LocalFree( ((SECURITY_DESCRIPTOR *)(secAttr.lpSecurityDescriptor))->Dacl );
      delete [] secAttr.lpSecurityDescriptor;
      secAttr.lpSecurityDescriptor = NULL;
   }
}
//=======================================================================================//
// Function to look up local name of ADMINISTRATORS group
//
// Input:   Pointers to name and name length
// Returns: TRUE on success, FALSE on failure with error message logged
//
BOOL PCGetAdminGroupName( TCHAR *Name, PCULONG32 *NameLen ) {

#define DOMAIN_NAME_LEN 256
   SID_IDENTIFIER_AUTHORITY SidIdAuthority = SECURITY_NT_AUTHORITY;
   SID_NAME_USE SidNameUse;
   PSID pSid;
   TCHAR     DomainName[DOMAIN_NAME_LEN+1];
   PCULONG32 DomainNameLen = DOMAIN_NAME_LEN;
   BOOL      ok            = FALSE;

   if ( !AllocateAndInitializeSid( &SidIdAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, 
                                   DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &pSid) )
      PCLogUnExError( TEXT("AdminAttr"), TEXT("AllocateAdminSid") );
   else {
      if ( !LookupAccountSid( NULL, pSid, Name, NameLen, DomainName, &DomainNameLen, &SidNameUse ) )
         PCLogUnExError( TEXT("AdminAttr"), TEXT("LookupAdminSid") );
      else
         ok = TRUE;
      FreeSid(pSid);
   }

   return ok;
}

//=======================================================================================//
// Functions to help format management attributes for use in log, these functions
//   format the values as limits with 
//   '+' => on, enabled, or applied
//   '-' => off, disabed, or not applied
//   the value follows the on/off indicator in square brackets "[]"
//
// Input:   buffer, buffer length in CHARACTERS, management parmaters
// Returns: buffer with string form of attribute
//
void PCFormatAffinityLimit(TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def)
{
   Buffer[BufferLength - 1] = 0;
   _sntprintf(Buffer, BufferLength - 1, TEXT("%s[0x%I64X]"),
      PCIsSetToStr(def.mFlags, PCMFLAG_APPLY_AFFINITY),
      def.affinity );
}

void PCFormatPriorityLimit(TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def)
{
   Buffer[BufferLength - 1] = 0;
   _sntprintf(Buffer, BufferLength - 1, TEXT("%s[%lu]"),
    PCIsSetToStr(def.mFlags, PCMFLAG_APPLY_PRIORITY),
    def.priority );
}

void PCFormatWorkingSetLimit(TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def)
{
   Buffer[BufferLength - 1] = 0;
   _sntprintf(Buffer, BufferLength - 1, TEXT("%s[%I64u,%I64u]"),
    PCIsSetToStr(def.mFlags, PCMFLAG_APPLY_WS_MINMAX),
    def.minWS,
    def.maxWS );
}

void PCFormatSchedClassLimit(TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def)
{  
   Buffer[BufferLength - 1] = 0;
   _sntprintf(Buffer, BufferLength - 1, TEXT("%s[%lu]"),
    PCIsSetToStr(def.mFlags, PCMFLAG_APPLY_SCHEDULING_CLASS),   
    def.schedClass );
}

void PCFormatProcessCountLimit(TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def)
{  
   Buffer[BufferLength - 1] = 0;
   _sntprintf(Buffer, BufferLength - 1 , TEXT("%s[%lu]"),
    PCIsSetToStr(def.mFlags, PCMFLAG_APPLY_PROC_COUNT_LIMIT),   
    def.procCountLimit );
}

void PCFormatProcTimeLimit(TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def)
{  
   Buffer[BufferLength - 1] = 0;
   _sntprintf(Buffer, BufferLength - 1 , TEXT("%s[%I64d]"),
    PCIsSetToStr(def.mFlags, PCMFLAG_APPLY_PROC_TIME_LIMIT),   
    def.procTimeLimitCNS / 10000 );
}

void PCFormatJobTimeLimit(TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def)
{  
   Buffer[BufferLength - 1] = 0;
   _sntprintf(Buffer, BufferLength - 1 , TEXT("%s[%I64d]"),
    PCIsSetToStr(def.mFlags, PCMFLAG_APPLY_JOB_TIME_LIMIT),   
    def.jobTimeLimitCNS / 10000 );
}

void PCFormatProcMemLimit(TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def)
{  
   Buffer[BufferLength - 1] = 0;
   _sntprintf(Buffer, BufferLength - 1 , TEXT("%s[%I64u]"),
    PCIsSetToStr(def.mFlags, PCMFLAG_APPLY_PROC_MEMORY_LIMIT),   
    def.procMemoryLimit );
}

void PCFormatJobMemLimit(TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def)
{  
   Buffer[BufferLength - 1] = 0;
   _sntprintf(Buffer, BufferLength - 1 , TEXT("%s[%I64u]"),
    PCIsSetToStr(def.mFlags, PCMFLAG_APPLY_JOB_MEMORY_LIMIT),   
    def.jobMemoryLimit );   
}

void PCFormatEndofJobAction(TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def)
{
   Buffer[BufferLength - 1] = 0;
   _sntprintf(Buffer, BufferLength - 1 , TEXT("%s[%s]"),
    PCIsSetToStr(def.mFlags, PCMFLAG_APPLY_JOB_TIME_LIMIT),
    (def.mFlags & PCMFLAG_MSG_ON_JOB_TIME_LIMIT_HIT) ? PROCCON_FLAG_ON : PROCCON_FLAG_OFF);
}

void PCFormatOnOrOffLimit(TCHAR *Buffer, UINT BufferLength, const MGMT_PARMS &def, PCMgmtFlags flag)
{
   Buffer[BufferLength - 1] = 0;
   _sntprintf(Buffer, BufferLength - 1 , TEXT("%s"),
      (def.mFlags & flag) ? PROCCON_FLAG_ON : PROCCON_FLAG_OFF);
}

// End of PCUtility.cpp
//============================================================================J McDonald fecit====//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\proccon\snapin\version.h ===
/*======================================================================================//
|                                                                                       //
|Copyright (c) 1998  Sequent Computer Systems, Incorporated.  All rights reserved.      //
|                                                                                       //
|File Name:    version.h                                                                //
|                                                                                       //
|Description:                                                                           //
|                                                                                       //
|Created:      Paul Skoglund 09-1998                                                    //
|                                                                                       //
|Rev History:                                                                           //
|                                                                                       //
|=======================================================================================*/

#ifndef __VERSION_H_
#define __VERSION_H_

#pragma warning(push)
#include <string>
#pragma warning(pop)


using std::basic_string;

typedef basic_string<TCHAR> tstring;


class CVersion {
  public:
    CVersion(HINSTANCE hInst);
    ~CVersion() { }

    // retrive info from the fixed section of the version resource
    LPCTSTR GetFileVersion()         const { return szFileVersion;   }
    LPCTSTR GetProductVersion()      const { return szProductVersion;}
    LPCTSTR GetFileFlags()           const { return szFileFlags;     }
    BOOL    IsDebug()                const { return m_bDebug;        }
    BOOL    IsPatched()              const { return m_bPatched;      }
    BOOL    IsPreRelease()           const { return m_bPreRelease;   }
    BOOL    IsPrivateBuild()         const { return m_bPrivateBuild; }
    BOOL    IsSpecialBuild()         const { return m_bSpecialBuild; }

    // retrieve info from StringFileInfo section of the version resource
    LPCTSTR strGetCompanyName()      const { return strCompanyName.c_str();     }
    LPCTSTR strGetFileDescription()  const { return strFileDescription.c_str(); }
    LPCTSTR strGetFileVersion()      const { return strFileVersion.c_str();     }
    LPCTSTR strGetInternalName()     const { return strInternalName.c_str();    }
    LPCTSTR strGetLegalCopyright()   const { return strLegalCopyright.c_str();  }
    LPCTSTR strGetOriginalFilename() const { return strOriginalFilename.c_str();}
    LPCTSTR strGetProductName()      const { return strProductName.c_str();     }
    LPCTSTR strGetProductVersion()   const { return strProductVersion.c_str();  }
    LPCTSTR strGetComments()         const { return strComments.c_str();        }
    LPCTSTR strGetLegalTrademarks()  const { return strLegalTrademarks.c_str(); }
    LPCTSTR strGetPrivateBuild()     const { return strPrivateBuild.c_str();    }
    LPCTSTR strGetSpecialBuild()     const { return strSpecialBuild.c_str();    }

  private:
    HINSTANCE        m_hInst;    
    BOOL             m_bInitializedOK;

    BOOL  m_bDebug, m_bPatched, m_bPreRelease, m_bPrivateBuild, m_bSpecialBuild;

    TCHAR szFileVersion[24];
    TCHAR szProductVersion[24];
    TCHAR szFileFlags[64];

    tstring strCompanyName;
    tstring strFileDescription;
    tstring strFileVersion;
    tstring strInternalName;
    tstring strLegalCopyright;
    tstring strOriginalFilename;
    tstring strProductName;
    tstring strProductVersion;
    tstring strComments;
    tstring strLegalTrademarks;
    tstring strPrivateBuild;
    tstring strSpecialBuild;

    BOOL ParseFixedInfo(VS_FIXEDFILEINFO &info, UINT uLen);
    BOOL LoadStringFileInfo(LPVOID hMen);

};

#endif // __VERSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profile\profile.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <windows.h>

int
__cdecl main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    LPSTR s;
    LPSTR CommandLine;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL b;
    HANDLE MappingHandle;
    PVOID SharedMemory;

    argv;
    envp;

    if ( argc < 2 ) {
        puts("Usage: profile [/a] [/innn] [/k] name-of-image [parameters]...\n"
             "       /a       All hits\n"
             "       /bnnn    Set profile bucket size to 2 to the nnn bytes\n"
             "       /ffilename Output to filename\n"
             "       /innn    Set profile interval to nnn (in 100ns units)\n"
             "       /k		profile system modules\n"
             "       /s[profilesource] Use profilesource instead of clock interrupt\n"
             "       /S[profilesource] Use profilesource as secondary profile source\n\n"
#if defined (_ALPHA_)
             "Currently supported profile sources are 'align', 'totalissues', 'pipelinedry'\n"
             "  'loadinstructions', 'pipelinefrozen', 'branchinstructions', 'totalnonissues',\n"
             "  'dcachemisses', 'icachemisses', 'branchmispredicts', 'storeinstructions'\n"
#endif
             );
        ExitProcess(1);
        }

    s = CommandLine = GetCommandLine();

    //
    // skip blanks
    //
    while(*s>' ')s++;

    //
    // get to next token
    //
    while(*s<=' ')s++;

    while ((*s == '-') ||
           (*s == '/')) {
        s++;
        while (*s>' '){
            s++;
            }
        //
        // get to next token
        //
        while(*s<=' ')s++;
        }

    //
    // Create named shared memory to pass parameters to psapi
    //
    MappingHandle = CreateFileMapping((HANDLE)-1,
                                      NULL,
                                      PAGE_READWRITE,
                                      0,
                                      4096,
                                      "ProfileStartupParameters");
    if (MappingHandle != NULL) {
        SharedMemory = MapViewOfFile(MappingHandle,
                                     FILE_MAP_WRITE,
                                     0,
                                     0,
                                     0);
        if (SharedMemory) {
            //
            // Copy command line parameters into shared memory
            //
            strncpy(SharedMemory, CommandLine, (size_t)(s-CommandLine));
            UnmapViewOfFile(SharedMemory);
        }
    }

    memset(&StartupInfo,0,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);

    b = CreateProcess(
            NULL,
            s,
            NULL,
            NULL,
            TRUE,
            PROFILE_USER,
            NULL,
            NULL,
            &StartupInfo,
            &ProcessInformation
            );
    if ( !b ) {
        printf("CreateProcess(%s) failed %lx\n",s,GetLastError());
        ExitProcess(GetLastError());
        }
    WaitForSingleObject(ProcessInformation.hProcess, (DWORD)-1);

    if (MappingHandle) {
        if (SharedMemory) {
            UnmapViewOfFile(SharedMemory);
        }
        CloseHandle(MappingHandle);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\86dis.h ===
/********************************** module *********************************/
/*                                                                         */
/*                                 disasmtb                                */
/*                           disassembler for CodeView                     */
/*                                                                         */
/***************************************************************************/
/*                                                                         */
/*    @ Purpose:                                                           */
/*                                                                         */
/*    @ Functions included:                                                */
/*                                                                         */
/*                                                                         */
/*    @ Author: Gerd Immeyer              @ Version:                       */
/*                                                                         */
/*    @ Creation Date: 10.19.89           @ Modification Date:             */
/*                                                                         */
/***************************************************************************/

#ifndef _86DIS_H_
#define _86DIS_H_

/* Strings: Operand mnemonics, Segment overrides, etc. for disasm          */

char dszAAA[]       = "aaa";
char dszAAD[]       = "aad";
char dszAAM[]       = "aam";
char dszAAS[]       = "aas";
char dszADC[]       = "adc";
char dszADD[]       = "add";
char dszADDRPRFX[]  = "";
char dszAND[]       = "and";
char dszARPL[]      = "arpl";
char dszBOUND[]     = "bound";
char dszBSF[]       = "bsf";
char dszBSR[]       = "bsr";
char dszBST[]       = "bst";
char dszBSWAP[]     = "bswap";
char dszBT[]        = "bt";
char dszBTC[]       = "btc";
char dszBTR[]       = "btr";
char dszBTS[]       = "bts";
char dszCALL[]      = "call";
char dszCBW[]       = "cbw";
char dszCDQ[]       = "cdq";
char dszCLC[]       = "clc";
char dszCLD[]       = "cld";
char dszCLI[]       = "cli";
char dszCLTS[]      = "clts";
char dszCMC[]       = "cmc";
char dszCMOVO[]     = "cmovo";
char dszCMOVNO[]    = "cmovno";
char dszCMOVB[]     = "cmovb";
char dszCMOVNB[]    = "cmovnb";
char dszCMOVE[]     = "cmove";
char dszCMOVNE[]    = "cmovne";
char dszCMOVBE[]    = "cmovbe";
char dszCMOVA[]     = "cmova";
char dszCMOVS[]     = "cmovs";
char dszCMOVNS[]    = "cmovns";
char dszCMOVP[]     = "cmovp";
char dszCMOVNP[]    = "cmovnp";
char dszCMOVL[]     = "cmovl";
char dszCMOVGE[]    = "cmovge";
char dszCMOVLE[]    = "cmovle";
char dszCMOVNLE[]   = "cmovnle";
char dszCMP[]       = "cmp";
char dszCMPS[]      = "cmps";
char dszCMPSB[]     = "cmpsb";
char dszCMPSD[]     = "cmpsd";
char dszCMPSW[]     = "cmpsw";
char dszCMPXCHG[]   = "cmpxchg";
char dszCMPXCHG8B[] = "cmpxchg8b";
char dszCPUID[]     = "cpuid";
char dszCS_[]       = "cs:";
char dszCWD[]       = "cwd";
char dszCWDE[]      = "cwde";
char dszDAA[]       = "daa";
char dszDAS[]       = "das";
char dszDEC[]       = "dec";
char dszDIV[]       = "div";
char dszDS_[]       = "ds:";
char dszEMMS[]      = "emms";
char dszENTER[]     = "enter";
char dszES_[]       = "es:";
char dszF2XM1[]     = "f2xm1";
char dszFABS[]      = "fabs";
char dszFADD[]      = "fadd";
char dszFADDP[]     = "faddp";
char dszFBLD[]      = "fbld";
char dszFBSTP[]     = "fbstp";
char dszFCHS[]      = "fchs";
char dszFCLEX[]     = "fclex";
char dszFCMOVB[]    = "fcmovb";
char dszFCMOVE[]    = "fcmove";
char dszFCMOVBE[]   = "fcmovbe";
char dszFCMOVU[]    = "fcmovu";
char dszFCMOVNB[]   = "fcmovnb";
char dszFCMOVNE[]   = "fcmovne";
char dszFCMOVNBE[]  = "fcmovnbe";
char dszFCMOVNU[]   = "fcmovnu";
char dszFCOM[]      = "fcom";
char dszFCOMI[]     = "fcomi";
char dszFCOMIP[]    = "fcomip";
char dszFCOMP[]     = "fcomp";
char dszFCOMPP[]    = "fcompp";
char dszFCOS[]      = "fcos";
char dszFDECSTP[]   = "fdecstp";
char dszFDISI[]     = "fdisi";
char dszFDIV[]      = "fdiv";
char dszFDIVP[]     = "fdivp";
char dszFDIVR[]     = "fdivr";
char dszFDIVRP[]    = "fdivrp";
char dszFENI[]      = "feni";
char dszFFREE[]     = "ffree";
char dszFIADD[]     = "fiadd";
char dszFICOM[]     = "ficom";
char dszFICOMP[]    = "ficomp";
char dszFIDIV[]     = "fidiv";
char dszFIDIVR[]    = "fidivr";
char dszFILD[]      = "fild";
char dszFIMUL[]     = "fimul";
char dszFINCSTP[]   = "fincstp";
char dszFINIT[]     = "finit";
char dszFIST[]      = "fist";
char dszFISTP[]     = "fistp";
char dszFISUB[]     = "fisub";
char dszFISUBR[]    = "fisubr";
char dszFLD[]       = "fld";
char dszFLD1[]      = "fld1";
char dszFLDCW[]     = "fldcw";
char dszFLDENV[]    = "fldenv";
char dszFLDL2E[]    = "fldl2e";
char dszFLDL2T[]    = "fldl2t";
char dszFLDLG2[]    = "fldlg2";
char dszFLDLN2[]    = "fldln2";
char dszFLDPI[]     = "fldpi";
char dszFLDZ[]      = "fldz";
char dszFMUL[]      = "fmul";
char dszFMULP[]     = "fmulp";
char dszFNCLEX[]    = "fnclex";
char dszFNDISI[]    = "fndisi";
char dszFNENI[]     = "fneni";
char dszFNINIT[]    = "fninit";
char dszFNOP[]      = "fnop";
char dszFNSAVE[]    = "fnsave";
char dszFNSTCW[]    = "fnstcw";
char dszFNSTENV[]   = "fnstenv";
char dszFNSTSW[]    = "fnstsw";
char dszFNSTSWAX[]  = "fnstswax";
char dszFPATAN[]    = "fpatan";
char dszFPREM[]     = "fprem";
char dszFPREM1[]    = "fprem1";
char dszFPTAN[]     = "fptan";
char dszFRNDINT[]   = "frndint";
char dszFRSTOR[]    = "frstor";
char dszFSAVE[]     = "fsave";
char dszFSCALE[]    = "fscale";
char dszFSETPM[]    = "fsetpm";
char dszFSIN[]      = "fsin";
char dszFSINCOS[]   = "fsincos";
char dszFSQRT[]     = "fsqrt";
char dszFST[]       = "fst";
char dszFSTCW[]     = "fstcw";
char dszFSTENV[]    = "fstenv";
char dszFSTP[]      = "fstp";
char dszFSTSW[]     = "fstsw";
char dszFSTSWAX[]   = "fstswax";
char dszFSUB[]      = "fsub";
char dszFSUBP[]     = "fsubp";
char dszFSUBR[]     = "fsubr";
char dszFSUBRP[]    = "fsubrp";
char dszFS_[]       = "fs:";
char dszFTST[]      = "ftst";
char dszFUCOM[]     = "fucom";
char dszFUCOMI[]    = "fucomi";
char dszFUCOMIP[]   = "fucomip";
char dszFUCOMP[]    = "fucomp";
char dszFUCOMPP[]   = "fucompp";
char dszFWAIT[]     = "fwait";
char dszFXAM[]      = "fxam";
char dszFXCH[]      = "fxch";
char dszFXTRACT[]   = "fxtract";
char dszFYL2X[]     = "fyl2x";
char dszFYL2XP1[]   = "fyl2xp1";
char dszGS_[]       = "gs:";
char dszHLT[]       = "hlt";
char dszIBTS[]      = "ibts";
char dszIDIV[]      = "idiv";
char dszIMUL[]      = "imul";
char dszIN[]        = "in";
char dszINC[]       = "inc";
char dszINS[]       = "ins";
char dszINSB[]      = "insb";
char dszINSD[]      = "insd";
char dszINSW[]      = "insw";
char dszINT[]       = "int";
char dszINTO[]      = "into";
char dszINVD[]      = "invd";
char dszINVLPG[]    = "invlpg";
char dszIRET[]      = "iret";
char dszIRETD[]     = "iretd";
char dszJA[]        = "ja";
char dszJAE[]       = "jae";
char dszJB[]        = "jb";
char dszJBE[]       = "jbe";
char dszJC[]        = "jc";
char dszJCXZ[]      = "jcxz";
char dszJE[]        = "je";
char dszJECXZ[]     = "jecxz";
char dszJG[]        = "jg";
char dszJGE[]       = "jge";
char dszJL[]        = "jl";
char dszJLE[]       = "jle";
char dszJMP[]       = "jmp";
char dszJNA[]       = "jna";
char dszJNAE[]      = "jnae";
char dszJNB[]       = "jnb";
char dszJNBE[]      = "jnbe";
char dszJNC[]       = "jnc";
char dszJNE[]       = "jne";
char dszJNG[]       = "jng";
char dszJNGE[]      = "jnge";
char dszJNL[]       = "jnl";
char dszJNLE[]      = "jnle";
char dszJNO[]       = "jno";
char dszJNP[]       = "jnp";
char dszJNS[]       = "jns";
char dszJNZ[]       = "jnz";
char dszJO[]        = "jo";
char dszJP[]        = "jp";
char dszJPE[]       = "jpe";
char dszJPO[]       = "jpo";
char dszJS[]        = "js";
char dszJZ[]        = "jz";
char dszLAHF[]      = "lahf";
char dszLAR[]       = "lar";
char dszLDS[]       = "lds";
char dszLEA[]       = "lea";
char dszLEAVE[]     = "leave";
char dszLES[]       = "les";
char dszLFS[]       = "lfs";
char dszLGDT[]      = "lgdt";
char dszLGS[]       = "lgs";
char dszLIDT[]      = "lidt";
char dszLLDT[]      = "lldt";
char dszLMSW[]      = "lmsw";
char dszLOADALL[]   = "loadall";
char dszLOCK[]      = "lock";
char dszLODS[]      = "lods";
char dszLODSB[]     = "lodsb";
char dszLODSD[]     = "lodsd";
char dszLODSW[]     = "lodsw";
char dszLOOP[]      = "loop";
char dszLOOPE[]     = "loope";
char dszLOOPNE[]    = "loopne";
char dszLOOPNZ[]    = "loopnz";
char dszLOOPZ[]     = "loopz";
char dszLSL[]       = "lsl";
char dszLSS[]       = "lss";
char dszLTR[]       = "ltr";
char dszMOV[]       = "mov";
char dszMOVD[]      = "movd";
char dszMOVQ[]      = "movq";
char dszMOVS[]      = "movs";
char dszMOVSB[]     = "movsb";
char dszMOVSD[]     = "movsd";
char dszMOVSW[]     = "movsw";
char dszMOVSX[]     = "movsx";
char dszMOVZX[]     = "movzx";
char dszMUL[]       = "mul";
char dszNEG[]       = "neg";
char dszNOP[]       = "nop";
char dszNOT[]       = "not";
char dszOPPRFX[]    = "";
char dszOR[]        = "or";
char dszOUT[]       = "out";
char dszOUTS[]      = "outs";
char dszOUTSB[]     = "outsb";
char dszOUTSD[]     = "outsd";
char dszOUTSW[]     = "outsw";
char dszPACKSSDW[]  = "packssdw";
char dszPACKSSWB[]  = "packsswb";
char dszPACKUSWB[]  = "packuswb";
char dszPADDB[]     = "paddb";
char dszPADDD[]     = "paddd";
char dszPADDSB[]    = "paddsb";
char dszPADDSW[]    = "paddsw";
char dszPADDUSB[]   = "paddusb";
char dszPADDUSW[]   = "paddusw";
char dszPADDW[]     = "paddw";
char dszPAND[]      = "pand";
char dszPANDN[]     = "pandn";
char dszPCMPEQB[]   = "pcmpeqb";
char dszPCMPEQD[]   = "pcmpeqd";
char dszPCMPEQW[]   = "pcmpeqw";
char dszPCMPGTB[]   = "pcmpgtb";
char dszPCMPGTD[]   = "pcmpgtd";
char dszPCMPGTW[]   = "pcmpgtw";
char dszPMADDWD[]   = "pmaddwd";
char dszPMULHW[]    = "pmulhw";
char dszPMULLW[]    = "pmullw";
char dszPOP[]       = "pop";
char dszPOPA[]      = "popa";
char dszPOPAD[]     = "popad";
char dszPOPF[]      = "popf";
char dszPOPFD[]     = "popfd";
char dszPOR[]       = "por";
char dszPSLLD[]     = "pslld";
char dszPSLLW[]     = "psllw";
char dszPSLLQ[]     = "psllq";
char dszPSRAD[]     = "psrad";
char dszPSRAW[]     = "psraw";
char dszPSRLD[]     = "psrld";
char dszPSRLQ[]     = "psrlq";
char dszPSRLW[]     = "psrlw";
char dszPSUBB[]     = "psubb";
char dszPSUBD[]     = "psubd";
char dszPSUBSB[]    = "psubsb";
char dszPSUBSW[]    = "psubsw";
char dszPSUBUSB[]   = "psubusb";
char dszPSUBUSW[]   = "psubusw";
char dszPSUBW[]     = "psubw";
char dszPUNPCKLBW[] = "punpcklbw";
char dszPUNPCKLDQ[] = "punpckldq";
char dszPUNPCKLWD[] = "punpcklwd";
char dszPUNPCKHBW[] = "punpckhbw";
char dszPUNPCKHDQ[] = "punpckhdq";
char dszPUNPCKHWD[] = "punpckhwd";
char dszPUSH[]      = "push";
char dszPUSHA[]     = "pusha";
char dszPUSHAD[]    = "pushad";
char dszPUSHF[]     = "pushf";
char dszPUSHFD[]    = "pushfd";
char dszPXOR[]      = "pxor";
char dszRCL[]       = "rcl";
char dszRCR[]       = "rcr";
char dszRDTSC[]     = "rdtsc";
char dszRDMSR[]     = "rdmsr";
char dszRDPMC[]     = "rdpmc";
char dszREP[]       = "rep ";
char dszREPE[]      = "repe";
char dszREPNE[]     = "repne ";
char dszREPNZ[]     = "repnz";
char dszREPZ[]      = "repz";
char dszRET[]       = "ret";
char dszRETF[]      = "retf";
char dszRETN[]      = "retn";
char dszROL[]       = "rol";
char dszROR[]       = "ror";
char dszRSM[]       = "rsm";
char dszSAHF[]      = "sahf";
char dszSAL[]       = "sal";
char dszSAR[]       = "sar";
char dszSBB[]       = "sbb";
char dszSCAS[]      = "scas";
char dszSCASB[]     = "scasb";
char dszSCASD[]     = "scasd";
char dszSCASW[]     = "scasw";
char dszSETA[]      = "seta";
char dszSETAE[]     = "setae";
char dszSETB[]      = "setb";
char dszSETBE[]     = "setbe";
char dszSETC[]      = "setc";
char dszSETE[]      = "sete";
char dszSETG[]      = "setg";
char dszSETGE[]     = "setge";
char dszSETL[]      = "setl";
char dszSETLE[]     = "setle";
char dszSETNA[]     = "setna";
char dszSETNAE[]    = "setnae";
char dszSETNB[]     = "setnb";
char dszSETNBE[]    = "setnbe";
char dszSETNC[]     = "setnc";
char dszSETNE[]     = "setne";
char dszSETNG[]     = "setng";
char dszSETNGE[]    = "setnge";
char dszSETNL[]     = "setnl";
char dszSETNLE[]    = "setnle";
char dszSETNO[]     = "setno";
char dszSETNP[]     = "setnp";
char dszSETNS[]     = "setns";
char dszSETNZ[]     = "setnz";
char dszSETO[]      = "seto";
char dszSETP[]      = "setp";
char dszSETPE[]     = "setpe";
char dszSETPO[]     = "setpo";
char dszSETS[]      = "sets";
char dszSETZ[]      = "setz";
char dszSGDT[]      = "sgdt";
char dszSHL[]       = "shl";
char dszSHLD[]      = "shld";
char dszSHR[]       = "shr";
char dszSHRD[]      = "shrd";
char dszSIDT[]      = "sidt";
char dszSLDT[]      = "sldt";
char dszSMSW[]      = "smsw";
char dszSS_[]       = "ss:";
char dszSTC[]       = "stc";
char dszSTD[]       = "std";
char dszSTI[]       = "sti";
char dszSTOS[]      = "stos";
char dszSTOSB[]     = "stosb";
char dszSTOSD[]     = "stosd";
char dszSTOSW[]     = "stosw";
char dszSTR[]       = "str";
char dszSUB[]       = "sub";
char dszTEST[]      = "test";
char dszUD2[]       = "ud2";
char dszVERR[]      = "verr";
char dszVERW[]      = "verw";
char dszWAIT[]      = "wait";
char dszWBINVD[]    = "wbinvd";
char dszWRMSR[]     = "wrmsr";
char dszXADD[]      = "xadd";
char dszXBTS[]      = "xbts";
char dszXCHG[]      = "xchg";
char dszXLAT[]      = "xlat";
char dszXOR[]       = "xor";
char dszRESERVED[]  = "???";
char dszMULTI[]     = "";
char dszDB[]        = "db";

#define MRM        0x40
#define COM        0x80
#define END        0xc0

/* Enumeration of valid actions that can be included in the action table */

enum oprtyp { ADDRP,  ADR_OVR, ALSTR,   ALT,     AXSTR,  BOREG,
              BREG,   BRSTR,   xBYTE,   CHR,     CREG,   xDWORD,
              EDWORD, EGROUPT, FARPTR,  GROUP,   GROUPT, IB,
              IST,    IST_ST,  IV,      IW,      LMODRM, MODRM,
              NOP,    OFFS,    OPC0F,   OPR_OVR, QWORD,  REL16,
              REL8,   REP,     SEG_OVR, SREG2,   SREG3,  ST_IST,
              STROP,  TBYTE,   UBYTE,   VAR,     VOREG,  VREG,
              xWORD,  WREG,    WRSTR,   MMWREG,  MMQWORD
            };

/* Enumeration of indices into the action table for instruction classes */

#define O_DoDB          0
#define O_NoOperands    0
#define O_NoOpAlt5      O_NoOperands+1
#define O_NoOpAlt4      O_NoOpAlt5+2
#define O_NoOpAlt3      O_NoOpAlt4+2
#define O_NoOpAlt1      O_NoOpAlt3+2
#define O_NoOpAlt0      O_NoOpAlt1+2
#define O_NoOpStrSI     O_NoOpAlt0+2
#define O_NoOpStrDI     O_NoOpStrSI+2
#define O_NoOpStrSIDI   O_NoOpStrDI+2
#define O_bModrm_Reg    O_NoOpStrSIDI+2
#define O_vModrm_Reg    O_bModrm_Reg+3
#define O_Modrm_Reg     O_vModrm_Reg+3
#define O_bReg_Modrm    O_Modrm_Reg+3
#define O_fReg_Modrm    O_bReg_Modrm+3
#define O_Reg_Modrm     O_fReg_Modrm+3
#define O_AL_Ib         O_Reg_Modrm+3
#define O_AX_Iv         O_AL_Ib+2
#define O_sReg2         O_AX_Iv+2
#define O_oReg          O_sReg2+1
#define O_DoBound       O_oReg+1
#define O_Iv            O_DoBound+3
#define O_wModrm_Reg    O_Iv+1
#define O_Ib            O_wModrm_Reg+3
#define O_Imulb         O_Ib+1
#define O_Imul          O_Imulb+4
#define O_Rel8          O_Imul+4
#define O_bModrm_Ib     O_Rel8+1
#define O_Modrm_Ib      O_bModrm_Ib+3
#define O_Modrm_Iv      O_Modrm_Ib+3
#define O_Modrm_sReg3   O_Modrm_Iv+3
#define O_sReg3_Modrm   O_Modrm_sReg3+3
#define O_Modrm         O_sReg3_Modrm+3
#define O_FarPtr        O_Modrm+2
#define O_AL_Offs       O_FarPtr+1
#define O_Offs_AL       O_AL_Offs+2
#define O_AX_Offs       O_Offs_AL+2
#define O_Offs_AX       O_AX_Offs+2
#define O_oReg_Ib       O_Offs_AX+2
#define O_oReg_Iv       O_oReg_Ib+2
#define O_Iw            O_oReg_Iv+2
#define O_Enter         O_Iw+1
#define O_Ubyte_AL      O_Enter+2
#define O_Ubyte_AX      O_Ubyte_AL+2
#define O_AL_Ubyte      O_Ubyte_AX+2
#define O_AX_Ubyte      O_AL_Ubyte+2
#define O_DoInAL        O_AX_Ubyte+2
#define O_DoInAX        O_DoInAL+3
#define O_DoOutAL       O_DoInAX+3
#define O_DoOutAX       O_DoOutAL+3
#define O_Rel16         O_DoOutAX+3
#define O_ADR_OVERRIDE  O_Rel16+1
#define O_OPR_OVERRIDE  O_ADR_OVERRIDE+1
#define O_SEG_OVERRIDE  O_OPR_OVERRIDE+1
#define O_DoInt3        O_SEG_OVERRIDE+1

#if (O_DoInt3 != 115)
#error "operand table has been modified!"
#endif
/* #define O_DoInt      O_DoInt3+2 */

#define O_DoInt         117
#define O_OPC0F         O_DoInt+1
#define O_GROUP11       O_OPC0F+1
#define O_GROUP13       O_GROUP11+5
#define O_GROUP12       O_GROUP13+5
#define O_GROUP21       O_GROUP12+5
#define O_GROUP22       O_GROUP21+5
#define O_GROUP23       O_GROUP22+5
#define O_GROUP24       O_GROUP23+6
#define O_GROUP25       O_GROUP24+6
#define O_GROUP26       O_GROUP25+6
#define O_GROUP4        O_GROUP26+6
#define O_GROUP6        O_GROUP4+4
#define O_GROUP8        O_GROUP6+4
#define O_GROUP31       O_GROUP8+5
#define O_GROUP32       O_GROUP31+3
#define O_GROUP5        O_GROUP32+3
#define O_GROUP7        O_GROUP5+3
#define O_x87_ESC       O_GROUP7+3
#define O_bModrm        O_x87_ESC+2
#define O_wModrm        O_bModrm+2
#define O_dModrm        O_wModrm+2
#define O_fModrm        O_dModrm+2
#define O_vModrm        O_fModrm+2
#define O_vModrm_Iv     O_vModrm+2
#define O_Reg_bModrm    O_vModrm_Iv+3
#define O_Reg_wModrm    O_Reg_bModrm+3
#define O_Modrm_Reg_Ib  O_Reg_wModrm+3
#define O_Modrm_Reg_CL  O_Modrm_Reg_Ib+4
#define O_ST_iST        O_Modrm_Reg_CL+5
#define O_iST           O_ST_iST+2
#define O_iST_ST        O_iST+2
#define O_qModrm        O_iST_ST+2
#define O_tModrm        O_qModrm+2
#define O_DoRep         O_tModrm+2
#define O_Modrm_CReg    O_DoRep+1
#define O_CReg_Modrm    O_Modrm_CReg+3
#define O_AX_oReg       O_CReg_Modrm+3
#define O_MmReg_qModrm  O_AX_oReg+2
#define O_qModrm_MmReg  O_MmReg_qModrm+3
#define O_MmReg_dModrm  O_qModrm_MmReg+3
#define O_dModrm_MmReg  O_MmReg_dModrm+3
#define O_qModrm_Ib     O_dModrm_MmReg+3
#define O_PSHimw        O_qModrm_Ib+3
#define O_PSHimd        O_PSHimw+5
#define O_PSHimq        O_PSHimd+5
#define O_length        O_PSHimq+5

typedef unsigned short ActionIndex;

#if( O_length > 65535 )
#error "operand table too large!"
#endif


/* The action table: range of lists of actions to be taken for each possible */
/*   instruction class.                                                      */

static unsigned char actiontbl[] = {
/* NoOperands  */ NOP+END,
/* NoOpAlt5    */ ALT+END,   5,
/* NoOpAlt4    */ ALT+END,   4,
/* NoOpAlt3    */ ALT+END,   3,
/* NoOpAlt1    */ ALT+END,   1,
/* NoOpAlt0    */ ALT+END,   0,
/* NoOpStrSI   */ STROP+END, 1,
/* NoOpStrDI   */ STROP+END, 2,
/* NoOpStrSIDI */ STROP+END, 3,
/* bModrm_Reg  */ xBYTE+MRM, MODRM+COM,  BREG+END,
/* vModrm_Reg  */ VAR+MRM,   LMODRM+COM, BREG+END,
/* Modrm_Reg   */ VAR+MRM,   MODRM+COM,  VREG+END,
/* bReg_Modrm  */ xBYTE+MRM, BREG+COM,   MODRM+END,
/* fReg_Modrm  */ FARPTR+MRM,VREG+COM,   MODRM+END,
/* Reg_Modrm   */ VAR+MRM,   VREG+COM,   MODRM+END,
/* AL_Ib       */ ALSTR+COM, IB+END,
/* AX_Iv       */ AXSTR+COM, IV+END,
/* sReg2       */ SREG2+END,
/* oReg        */ VOREG+END,
/* DoBound     */ VAR+MRM,   VREG+COM,   MODRM+END,
/* Iv          */ IV+END,
/* wModrm_Reg  */ xWORD+MRM, LMODRM+COM, WREG+END,
/* Ib          */ IB+END,
/* Imulb       */ VAR+MRM,   VREG+COM,   MODRM+COM, IB+END,
/* Imul        */ VAR+MRM,   VREG+COM,   MODRM+COM, IV+END,
/* REL8        */ REL8+END,
/* bModrm_Ib   */ xBYTE+MRM, LMODRM+COM, IB+END,
/* Modrm_Ib    */ VAR+MRM,   LMODRM+COM, IB+END,
/* Modrm_Iv    */ VAR+MRM,   LMODRM+COM, IV+END,
/* Modrm_sReg3 */ xWORD+MRM, MODRM+COM,  SREG3+END,
/* sReg3_Modrm */ xWORD+MRM, SREG3+COM,  MODRM+END,
/* Modrm       */ VAR+MRM,   MODRM+END,
/* FarPtr      */ ADDRP+END,
/* AL_Offs     */ ALSTR+COM, OFFS+END,
/* Offs_AL     */ OFFS+COM,  ALSTR+END,
/* AX_Offs     */ AXSTR+COM, OFFS+END,
/* Offs_AX     */ OFFS+COM,  AXSTR+END,
/* oReg_Ib     */ BOREG+COM, IB+END,
/* oReg_Iv     */ VOREG+COM, IV+END,
/* Iw          */ IW+END,
/* enter       */ IW+COM,    IB+END,
/* Ubyte_AL    */ UBYTE+COM, ALSTR+END,
/* Ubyte_AX    */ UBYTE+COM, AXSTR+END,
/* AL_Ubyte    */ ALSTR+COM, UBYTE+END,
/* AX_Ubyte    */ AXSTR+COM, UBYTE+END,
/* DoInAL      */ ALSTR+COM, WRSTR+END,  2,
/* DoInAX      */ AXSTR+COM, WRSTR+END,  2,
/* DoOutAL     */ WRSTR+COM, 2,          ALSTR+END,
/* DoOutAX     */ WRSTR+COM, 2,          AXSTR+END,
/* REL16       */ REL16+END,
/* ADR_OVERRIDE*/ ADR_OVR,
/* OPR_OVERRIDE*/ OPR_OVR,
/* SEG_OVERRIDE*/ SEG_OVR,
/* DoInt3      */ CHR+END,   '3',
/* DoInt       */ UBYTE+END,
/* Opcode0F    */ OPC0F,
/* group1_1    */ xBYTE+MRM, GROUP,      0,         LMODRM+COM, IB+END,
/* group1_3    */ VAR+MRM,   GROUP,      0,         LMODRM+COM, IB+END,
/* group1_2    */ VAR+MRM,   GROUP,      0,         LMODRM+COM, IV+END,
/* group2_1    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, IB+END,
/* group2_2    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, IB+END,
/* group2_3    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, CHR+END, '1',
/* group2_4    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, CHR+END, '1',
/* group2_5    */ xBYTE+MRM, GROUP,      1,         LMODRM+COM, BRSTR+END, 1,
/* group2_6    */ VAR+MRM,   GROUP,      1,         LMODRM+COM, BRSTR+END, 1,
/* group4      */ xBYTE+MRM, GROUP,      2,         LMODRM+END,
/* group6      */ xWORD+MRM, GROUP,      3,         LMODRM+END,
/* group8      */ xWORD+MRM, GROUP,      4,         LMODRM+COM, IB+END,
/* group3_1    */ xBYTE+MRM, GROUPT,     20,
/* group3_2    */ VAR+MRM,   GROUPT,     21,
/* group5      */ VAR+MRM,   GROUPT,     22,
/* group7      */ NOP+MRM,   GROUPT,     23,
/* x87_ESC     */ NOP+MRM,   EGROUPT,
/* bModrm      */ xBYTE+MRM, LMODRM+END,
/* wModrm      */ xWORD+MRM, LMODRM+END,
/* dModrm      */ xDWORD+MRM,LMODRM+END,
/* fModrm      */ FARPTR+MRM,LMODRM+END,
/* vModrm      */ VAR+MRM,   LMODRM+END,
/* vModrm_Iv   */ VAR+MRM,   LMODRM+COM, IV+END,
/* reg_bModrm  */ xBYTE+MRM, VREG+COM,   LMODRM+END,
/* reg_wModrm  */ xWORD+MRM, VREG+COM,   LMODRM+END,
/* Modrm_Reg_Ib*/ VAR+MRM,   MODRM+COM,  VREG+COM,   IB+END,
/* Modrm_Reg_CL*/ VAR+MRM,   MODRM+COM,  VREG+COM,   BRSTR+END, 1,
/* ST_iST      */ NOP+MRM,   ST_IST+END,
/* iST         */ NOP+MRM,   IST+END,
/* iST_ST      */ NOP+MRM,   IST_ST+END,
/* qModrm      */ QWORD+MRM, LMODRM+END,
/* tModrm      */ TBYTE+MRM, LMODRM+END,
/* REP         */ REP,
/* Modrm_CReg  */ EDWORD+MRM,MODRM+COM,  CREG+END,
/* CReg_Modrm  */ EDWORD+MRM,CREG+COM,   MODRM+END,
/* AX_oReg     */ AXSTR+COM, VOREG+END,
/* MmReg_qModrm*/ MMQWORD+MRM, MMWREG+COM, LMODRM+END,
/* qModrm_MmReg*/ MMQWORD+MRM, MODRM+COM,  MMWREG+END,
/* MmReg_dModrm*/ xDWORD+MRM, MMWREG+COM,LMODRM+END,
/* dModrm_MmReg*/ xDWORD+MRM, MODRM+COM, MMWREG+END,
/* qModrm_Ib   */ MMQWORD+MRM, MODRM+COM,IB+END,
/* PSHimw      */ MMQWORD+MRM, GROUP,    5,          LMODRM+COM, IB+END,
/* PSHimd      */ MMQWORD+MRM, GROUP,    6,          LMODRM+COM, IB+END,
/* PSHimq      */ MMQWORD+MRM, GROUP,    7,          LMODRM+COM, IB+END,
                  };

#if defined(_M_IX86)
#define BUILDING_ON_X86 1
#else
#define BUILDING_ON_X86 0
#endif

#if BUILDING_ON_X86 == 1
#pragma pack(1)
#endif

typedef struct Tdistbl{
    char *instruct;
    ActionIndex opr;
    } Tdistbl;

#if BUILDING_ON_X86 == 1
#pragma pack()
#endif

//
// Secondary opcode table is compressed - only "filled" locations are
// allocated space in distbl. Offsets for indexing into the secondary
// opcode table are calculcated as follows and defined below.
//
//  Pack#  Opcodes in Pack  #Ops before   Offset(add to opcode)
//     1     0h -  Bh            0            256 (# of primary opcodes)
//     2    20h - 26h           12        256-32+12 = 236
//     3    30h - 33h           19        256-48+19 = 227
//     4    40h - 4fh           23        256-64+23 = 215
//     5    60h - feh           39        256-96+39 = 199
//

#define SECTAB_OFFSET_1 256
#define SECTAB_OFFSET_2 236
#define SECTAB_OFFSET_3 227
#define SECTAB_OFFSET_4 215
#define SECTAB_OFFSET_5 199
#define SECTAB_OFFSET_UNDEF 260

/* List of ordered pairs for each instruction:                           */
/*    (pointer to string literal mnemonic,                               */
/*     instruction class index for action table)                         */

static Tdistbl distbl[] = {
    dszADD,   O_bModrm_Reg,             /* 00 ADD mem/reg, reg (byte)    */
    dszADD,   O_Modrm_Reg,              /* 01 ADD mem/reg, reg (word)    */
    dszADD,   O_bReg_Modrm,             /* 02 ADD reg, mem/reg (byte)    */
    dszADD,   O_Reg_Modrm,              /* 03 ADD reg, mem/reg (word)    */
    dszADD,   O_AL_Ib,                  /* 04 ADD AL, I                  */
    dszADD,   O_AX_Iv,                  /* 05 ADD AX, I                  */
    dszPUSH,  O_sReg2,                  /* 06 PUSH ES                    */
    dszPOP,   O_sReg2,                  /* 07 POP ES                     */
    dszOR,    O_bModrm_Reg,             /* 08 OR mem/reg, reg (byte)     */
    dszOR,    O_Modrm_Reg,              /* 09 OR mem/reg, reg (word)     */
    dszOR,    O_bReg_Modrm,             /* 0A OR reg, mem/reg (byte)     */
    dszOR,    O_Reg_Modrm,              /* 0B OR reg, mem/reg (word)     */
    dszOR,    O_AL_Ib,                  /* 0C OR AL, I                   */
    dszOR,    O_AX_Iv,                  /* 0D OR AX, I                   */
    dszPUSH,  O_sReg2,                  /* 0E PUSH CS                    */
    dszMULTI, O_OPC0F,                  /* 0F CLTS & protection ctl(286) */
    dszADC,   O_bModrm_Reg,             /* 10 ADC mem/reg, reg (byte)    */
    dszADC,   O_Modrm_Reg,              /* 11 ADC mem/reg, reg (word)    */
    dszADC,   O_bReg_Modrm,             /* 12 ADC reg, mem/reg (byte)    */
    dszADC,   O_Reg_Modrm,              /* 13 ADC reg, mem/reg (word)    */
    dszADC,   O_AL_Ib,                  /* 14 ADC AL, I                  */
    dszADC,   O_AX_Iv,                  /* 15 ADC AX, I                  */
    dszPUSH,  O_sReg2,                  /* 16 PUSH SS                    */
    dszPOP,   O_sReg2,                  /* 17 POP SS                     */
    dszSBB,   O_bModrm_Reg,             /* 18 SBB mem/reg, reg (byte)    */
    dszSBB,   O_Modrm_Reg,              /* 19 SBB mem/reg, reg (word)    */
    dszSBB,   O_bReg_Modrm,             /* 1A SBB reg, mem/reg (byte)    */
    dszSBB,   O_Reg_Modrm,              /* 1B SBB reg, mem/reg (word)    */
    dszSBB,   O_AL_Ib,                  /* 1C SBB AL, I                  */
    dszSBB,   O_AX_Iv,                  /* 1D SBB AX, I                  */
    dszPUSH,  O_sReg2,                  /* 1E PUSH DS                    */
    dszPOP,   O_sReg2,                  /* 1F POP DS                     */
    dszAND,   O_bModrm_Reg,             /* 20 AND mem/reg, reg (byte)    */
    dszAND,   O_Modrm_Reg,              /* 21 AND mem/reg, reg (word)    */
    dszAND,   O_bReg_Modrm,             /* 22 AND reg, mem/reg (byte)    */
    dszAND,   O_Reg_Modrm,              /* 23 AND reg, mem/reg (word)    */
    dszAND,   O_AL_Ib,                  /* 24 AND AL, I                  */
    dszAND,   O_AX_Iv,                  /* 25 AND AX, I                  */
    dszES_,   O_SEG_OVERRIDE,           /* 26 SEG ES:                    */
    dszDAA,   O_NoOperands,             /* 27 DAA                        */
    dszSUB,   O_bModrm_Reg,             /* 28 SUB mem/reg, reg (byte)    */
    dszSUB,   O_Modrm_Reg,              /* 29 SUB mem/reg, reg (word)    */
    dszSUB,   O_bReg_Modrm,             /* 2A SUB reg, mem/reg (byte)    */
    dszSUB,   O_Reg_Modrm,              /* 2B SUB reg, mem/reg (word)    */
    dszSUB,   O_AL_Ib,                  /* 2C SUB AL, I                  */
    dszSUB,   O_AX_Iv,                  /* 2D SUB AX, I                  */
    dszCS_,   O_SEG_OVERRIDE,           /* 2E SEG CS:                    */
    dszDAS,   O_NoOperands,             /* 2F DAS                        */
    dszXOR,   O_bModrm_Reg,             /* 30 XOR mem/reg, reg (byte)    */
    dszXOR,   O_Modrm_Reg,              /* 31 XOR mem/reg, reg (word)    */
    dszXOR,   O_bReg_Modrm,             /* 32 XOR reg, mem/reg (byte)    */
    dszXOR,   O_Reg_Modrm,              /* 33 XOR reg, mem/reg (word)    */
    dszXOR,   O_AL_Ib,                  /* 34 XOR AL, I                  */
    dszXOR,   O_AX_Iv,                  /* 35 XOR AX, I                  */
    dszSS_,   O_SEG_OVERRIDE,           /* 36 SEG SS:                    */
    dszAAA,   O_NoOperands,             /* 37 AAA                        */
    dszCMP,   O_bModrm_Reg,             /* 38 CMP mem/reg, reg (byte)    */
    dszCMP,   O_Modrm_Reg,              /* 39 CMP mem/reg, reg (word)    */
    dszCMP,   O_bReg_Modrm,             /* 3A CMP reg, mem/reg (byte)    */
    dszCMP,   O_Reg_Modrm,              /* 3B CMP reg, mem/reg (word)    */
    dszCMP,   O_AL_Ib,                  /* 3C CMP AL, I                  */
    dszCMP,   O_AX_Iv,                  /* 3D CMP AX, I                  */
    dszDS_,   O_SEG_OVERRIDE,           /* 3E SEG DS:                    */
    dszAAS,   O_NoOperands,             /* 3F AAS                        */
    dszINC,   O_oReg,                   /* 40 INC AX                     */
    dszINC,   O_oReg,                   /* 41 INC CX                     */
    dszINC,   O_oReg,                   /* 42 INC DX                     */
    dszINC,   O_oReg,                   /* 43 INC BX                     */
    dszINC,   O_oReg,                   /* 44 INC SP                     */
    dszINC,   O_oReg,                   /* 45 INC BP                     */
    dszINC,   O_oReg,                   /* 46 INC SI                     */
    dszINC,   O_oReg,                   /* 47 INC DI                     */
    dszDEC,   O_oReg,                   /* 48 DEC AX                     */
    dszDEC,   O_oReg,                   /* 49 DEC CX                     */
    dszDEC,   O_oReg,                   /* 4A DEC DX                     */
    dszDEC,   O_oReg,                   /* 4B DEC BX                     */
    dszDEC,   O_oReg,                   /* 4C DEC SP                     */
    dszDEC,   O_oReg,                   /* 4D DEC BP                     */
    dszDEC,   O_oReg,                   /* 4E DEC SI                     */
    dszDEC,   O_oReg,                   /* 4F DEC DI                     */
    dszPUSH,  O_oReg,                   /* 50 PUSH AX                    */
    dszPUSH,  O_oReg,                   /* 51 PUSH CX                    */
    dszPUSH,  O_oReg,                   /* 52 PUSH DX                    */
    dszPUSH,  O_oReg,                   /* 53 PUSH BX                    */
    dszPUSH,  O_oReg,                   /* 54 PUSH SP                    */
    dszPUSH,  O_oReg,                   /* 55 PUSH BP                    */
    dszPUSH,  O_oReg,                   /* 56 PUSH SI                    */
    dszPUSH,  O_oReg,                   /* 57 PUSH DI                    */
    dszPOP,   O_oReg,                   /* 58 POP AX                     */
    dszPOP,   O_oReg,                   /* 59 POP CX                     */
    dszPOP,   O_oReg,                   /* 5A POP DX                     */
    dszPOP,   O_oReg,                   /* 5B POP BX                     */
    dszPOP,   O_oReg,                   /* 5C POP SP                     */
    dszPOP,   O_oReg,                   /* 5D POP BP                     */
    dszPOP,   O_oReg,                   /* 5E POP SI                     */
    dszPOP,   O_oReg,                   /* 5F POP DI                     */
    dszPUSHA, O_NoOpAlt5,               /* 60 PUSHA (286) / PUSHAD (386) */
    dszPOPA,  O_NoOpAlt4,               /* 61 POPA (286) / POPAD (286)   */
    dszBOUND, O_DoBound,                /* 62 BOUND reg, Modrm (286)     */
    dszARPL,  O_Modrm_Reg,              /* 63 ARPL Modrm, reg (286)      */
    dszFS_,   O_SEG_OVERRIDE,           /* 64                            */
    dszGS_,   O_SEG_OVERRIDE,           /* 65                            */
    dszOPPRFX,O_OPR_OVERRIDE,           /* 66                            */
    dszADDRPRFX,O_ADR_OVERRIDE,         /* 67                            */
    dszPUSH,  O_Iv,                     /* 68 PUSH word (286)            */
    dszIMUL,  O_Imul,                   /* 69 IMUL (286)                 */
    dszPUSH,  O_Ib,                     /* 6A PUSH byte (286)            */
    dszIMUL,  O_Imulb,                  /* 6B IMUL (286)                 */
    dszINSB,  O_NoOperands,             /* 6C INSB (286)                 */
    dszINSW,  O_NoOpAlt3,               /* 6D INSW (286) / INSD (386)    */
    dszOUTSB, O_NoOperands,             /* 6E OUTSB (286)                */
    dszOUTSW, O_NoOpAlt4,               /* 6F OUTSW (286) / OUTSD (386)  */
    dszJO,    O_Rel8,                   /* 70 JO                         */
    dszJNO,   O_Rel8,                   /* 71 JNO                        */
    dszJB,    O_Rel8,                   /* 72 JB or JNAE or JC           */
    dszJNB,   O_Rel8,                   /* 73 JNB or JAE or JNC          */
    dszJZ,    O_Rel8,                   /* 74 JE or JZ                   */
    dszJNZ,   O_Rel8,                   /* 75 JNE or JNZ                 */
    dszJBE,   O_Rel8,                   /* 76 JBE or JNA                 */
    dszJA,    O_Rel8,                   /* 77 JNBE or JA                 */
    dszJS,    O_Rel8,                   /* 78 JS                         */
    dszJNS,   O_Rel8,                   /* 79 JNS                        */
    dszJPE,   O_Rel8,                   /* 7A JP or JPE                  */
    dszJPO,   O_Rel8,                   /* 7B JNP or JPO                 */
    dszJL,    O_Rel8,                   /* 7C JL or JNGE                 */
    dszJGE,   O_Rel8,                   /* 7D JNL or JGE                 */
    dszJLE,   O_Rel8,                   /* 7E JLE or JNG                 */
    dszJG,    O_Rel8,                   /* 7F JNLE or JG                 */
    dszMULTI, O_GROUP11,                /* 80                            */
    dszMULTI, O_GROUP12,                /* 81                            */
    dszRESERVED, O_DoDB,                /* 82                            */
    dszMULTI, O_GROUP13,                /* 83                            */
    dszTEST,  O_bModrm_Reg,             /* 84 TEST reg, mem/reg (byte)   */
    dszTEST,  O_Modrm_Reg,              /* 85 TEST reg, mem/reg (word)   */
    dszXCHG,  O_bModrm_Reg,             /* 86 XCHG reg, mem/reg (byte)   */
    dszXCHG,  O_Modrm_Reg,              /* 87 XCHG reg, mem/reg (word)   */
    dszMOV,   O_bModrm_Reg,             /* 88 MOV mem/reg, reg (byte)    */
    dszMOV,   O_Modrm_Reg,              /* 89 MOV mem/reg, reg (word)    */
    dszMOV,   O_bReg_Modrm,             /* 8A MOV reg, mem/reg (byte)    */
    dszMOV,   O_Reg_Modrm,              /* 8B MOV reg, mem/reg (word)    */
    dszMOV,   O_Modrm_sReg3,            /* 8C MOV mem/reg, segreg        */
    dszLEA,   O_Reg_Modrm,              /* 8D LEA reg, mem               */
    dszMOV,   O_sReg3_Modrm,            /* 8E MOV segreg, mem/reg        */
    dszPOP,   O_Modrm,                  /* 8F POP mem/reg                */
    dszNOP,   O_NoOperands,             /* 90 NOP                        */
    dszXCHG,  O_AX_oReg,                /* 91 XCHG AX,CX                 */
    dszXCHG,  O_AX_oReg,                /* 92 XCHG AX,DX                 */
    dszXCHG,  O_AX_oReg,                /* 93 XCHG AX,BX                 */
    dszXCHG,  O_AX_oReg,                /* 94 XCHG AX,SP                 */
    dszXCHG,  O_AX_oReg,                /* 95 XCHG AX,BP                 */
    dszXCHG,  O_AX_oReg,                /* 96 XCHG AX,SI                 */
    dszXCHG,  O_AX_oReg,                /* 97 XCHG AX,DI                 */
    dszCBW,   O_NoOpAlt0,               /* 98 CBW / CWDE (386)           */
    dszCWD,   O_NoOpAlt1,               /* 99 CWD / CDQ (386)            */
    dszCALL,  O_FarPtr,                 /* 9A CALL seg:off               */
    dszWAIT,  O_NoOperands,             /* 9B WAIT                       */
    dszPUSHF, O_NoOpAlt5,               /* 9C PUSHF / PUSHFD (386)       */
    dszPOPF,  O_NoOpAlt4,               /* 9D POPF / POPFD (386)         */
    dszSAHF,  O_NoOperands,             /* 9E SAHF                       */
    dszLAHF,  O_NoOperands,             /* 9F LAHF                       */
    dszMOV,   O_AL_Offs,                /* A0 MOV AL, mem                */
    dszMOV,   O_AX_Offs,                /* A1 MOV AX, mem                */
    dszMOV,   O_Offs_AL,                /* A2 MOV mem, AL                */
    dszMOV,   O_Offs_AX,                /* A3 MOV mem, AX                */
    dszMOVSB, O_NoOpStrSIDI,            /* A4 MOVSB                      */
    dszMOVSW, O_NoOpStrSIDI,            /* A5 MOVSW / MOVSD (386)        */
    dszCMPSB, O_NoOpStrSIDI,            /* A6 CMPSB                      */
    dszCMPSW, O_NoOpStrSIDI,            /* A7 CMPSW / CMPSD (386)        */
    dszTEST,  O_AL_Ib,                  /* A8 TEST AL, I                 */
    dszTEST,  O_AX_Iv,                  /* A9 TEST AX, I                 */
    dszSTOSB, O_NoOpStrDI,              /* AA STOSB                      */
    dszSTOSW, O_NoOpStrDI,              /* AB STOSW / STOSD (386)        */
    dszLODSB, O_NoOpStrSI,              /* AC LODSB                      */
    dszLODSW, O_NoOpStrSI,              /* AD LODSW / LODSD (386)        */
    dszSCASB, O_NoOpStrDI,              /* AE SCASB                      */
    dszSCASW, O_NoOpStrDI,              /* AF SCASW / SCASD (386)        */
    dszMOV,   O_oReg_Ib,                /* B0 MOV AL, I                  */
    dszMOV,   O_oReg_Ib,                /* B1 MOV CL, I                  */
    dszMOV,   O_oReg_Ib,                /* B2 MOV DL, I                  */
    dszMOV,   O_oReg_Ib,                /* B3 MOV BL, I                  */
    dszMOV,   O_oReg_Ib,                /* B4 MOV AH, I                  */
    dszMOV,   O_oReg_Ib,                /* B5 MOV CH, I                  */
    dszMOV,   O_oReg_Ib,                /* B6 MOV DH, I                  */
    dszMOV,   O_oReg_Ib,                /* B7 MOV BH, I                  */
    dszMOV,   O_oReg_Iv,                /* B8 MOV AX, I                  */
    dszMOV,   O_oReg_Iv,                /* B9 MOV CX, I                  */
    dszMOV,   O_oReg_Iv,                /* BA MOV DX, I                  */
    dszMOV,   O_oReg_Iv,                /* BB MOV BX, I                  */
    dszMOV,   O_oReg_Iv,                /* BC MOV SP, I                  */
    dszMOV,   O_oReg_Iv,                /* BD MOV BP, I                  */
    dszMOV,   O_oReg_Iv,                /* BE MOV SI, I                  */
    dszMOV,   O_oReg_Iv,                /* BF MOV DI, I                  */
    dszMULTI, O_GROUP21,                /* C0 shifts & rotates (286)     */
    dszMULTI, O_GROUP22,                /* C1 shifts & rotates (286)     */
    dszRET,   O_Iw,                     /* C2 RET Rel16                  */
    dszRET,   O_NoOperands,             /* C3 RET                        */
    dszLES,   O_fReg_Modrm,             /* C4 LES reg, mem               */
    dszLDS,   O_fReg_Modrm,             /* C5 LDS reg, mem               */
    dszMOV,   O_bModrm_Ib,              /* C6 MOV mem/reg, I(byte)       */
    dszMOV,   O_Modrm_Iv,               /* C7 MOV mem/reg, I(word)       */
    dszENTER, O_Enter,                  /* C8 ENTER (286)                */
    dszLEAVE, O_NoOperands,             /* C9 LEAVE (286)                */
    dszRETF,  O_Iw,                     /* CA RETF I(word)               */
    dszRETF,  O_NoOperands,             /* CB RETF                       */
    dszINT,   O_DoInt3,                 /* CC INT 3                      */
    dszINT,   O_DoInt,                  /* CD INT                        */
    dszINTO,  O_NoOperands,             /* CE INTO                       */
    dszIRET,  O_NoOpAlt4,               /* CF IRET / IRETD (386)         */
    dszMULTI, O_GROUP23,                /* D0 shifts & rotates,1 (byte)  */
    dszMULTI, O_GROUP24,                /* D1 shifts & rotates,1 (word)  */
    dszMULTI, O_GROUP25,                /* D2 shifts & rotates,CL (byte) */
    dszMULTI, O_GROUP26,                /* D3 shifts & rotates,CL (word) */
    dszAAM,   O_Ib,                     /* D4 AAM                        */
    dszAAD,   O_Ib,                     /* D5 AAD                        */
    dszRESERVED, O_DoDB,                /* D6                            */
    dszXLAT,  O_NoOperands,             /* D7 XLAT                       */
    dszMULTI, O_x87_ESC,                /* D8 ESC                        */
    dszMULTI, O_x87_ESC,                /* D9 ESC                        */
    dszMULTI, O_x87_ESC,                /* DA ESC                        */
    dszMULTI, O_x87_ESC,                /* DB ESC                        */
    dszMULTI, O_x87_ESC,                /* DC ESC                        */
    dszMULTI, O_x87_ESC,                /* DD ESC                        */
    dszMULTI, O_x87_ESC,                /* DE ESC                        */
    dszMULTI, O_x87_ESC,                /* DF ESC                        */
    dszLOOPNE,O_Rel8,                   /* E0 LOOPNE or LOOPNZ           */
    dszLOOPE, O_Rel8,                   /* E1 LOOPE or LOOPZ             */
    dszLOOP,  O_Rel8,                   /* E2 LOOP                       */
    dszJCXZ,  O_Rel8,                   /* E3 JCXZ / JECXZ (386)         */
    dszIN,    O_AL_Ubyte,               /* E4 IN AL, I                   */
    dszIN,    O_AX_Ubyte,               /* E5 IN AX, I                   */
    dszOUT,   O_Ubyte_AL,               /* E6 OUT I, AL                  */
    dszOUT,   O_Ubyte_AX,               /* E7 OUT I, AX                  */
    dszCALL,  O_Rel16,                  /* E8 CALL Rel16                 */
    dszJMP,   O_Rel16,                  /* E9 JMP Rel16                  */
    dszJMP,   O_FarPtr,                 /* EA JMP seg:off                */
    dszJMP,   O_Rel8,                   /* EB JMP Rel8                   */
    dszIN,    O_DoInAL,                 /* EC IN AL, DX                  */
    dszIN,    O_DoInAX,                 /* ED IN AX, DX                  */
    dszOUT,   O_DoOutAL,                /* EE OUT DX, AL                 */
    dszOUT,   O_DoOutAX,                /* EF OUT DX, AX                 */
    dszLOCK,  O_DoRep,                  /* F0 LOCK                       */
    dszRESERVED, O_DoDB,                /* F1                            */
    dszREPNE, O_DoRep,                  /* F2 REPNE or REPNZ             */
    dszREP,   O_DoRep,                  /* F3 REP or REPE or REPZ        */
    dszHLT,   O_NoOperands,             /* F4 HLT                        */
    dszCMC,   O_NoOperands,             /* F5 CMC                        */
    dszMULTI, O_GROUP31,                /* F6 TEST, NOT, NEG, MUL, IMUL, */
    dszMULTI, O_GROUP32,                /* F7 DIv, IDIv F6=Byte F7=Word  */
    dszCLC,   O_NoOperands,             /* F8 CLC                        */
    dszSTC,   O_NoOperands,             /* F9 STC                        */
    dszCLI,   O_NoOperands,             /* FA CLI                        */
    dszSTI,   O_NoOperands,             /* FB STI                        */
    dszCLD,   O_NoOperands,             /* FC CLD                        */
    dszSTD,   O_NoOperands,             /* FD STD                        */
    dszMULTI, O_GROUP4,                 /* FE INC, DEC mem/reg (byte)    */
    dszMULTI, O_GROUP5,                 /* FF INC, DEC, CALL, JMP, PUSH  */

    // secondary opcode table begins. Only "filled" locations are stored
    // to compress the secondary table. Hence while disassembling
    // opcode needs to be displaced appropriately to account for the.
    // The displacements are defined in 86dis.c and need to be reevaluated
    // if new opcodes are added here.

    dszMULTI, O_GROUP6,                 /* 0 MULTI                       */
    dszMULTI, O_GROUP7,                 /* 1 MULTI                       */
    dszLAR,   O_Reg_Modrm,              /* 2 LAR                         */
    dszLSL,   O_Reg_Modrm,              /* 3 LSL                         */
    dszRESERVED, O_DoDB,                /* 4                             */
    dszLOADALL, O_NoOperands,           /* 5 LOADALL                     */
    dszCLTS,  O_NoOperands,             /* 6 CLTS                        */
    dszMULTI, O_GROUP7,                 /* 7 MULTI                       */
    dszINVD,  O_NoOperands,             /* 8 INVD                        */
    dszWBINVD,O_NoOperands,             /* 9 WBINVD                      */
    dszRESERVED, O_DoDB,                /* A                             */
    dszUD2,   O_NoOperands,             /* B UD2 undefined               */
    dszMOV,   O_Modrm_CReg,             /* 20 MOV Rd,Cd                  */
    dszMOV,   O_Modrm_CReg,             /* 21 MOV Rd,Dd                  */
    dszMOV,   O_CReg_Modrm,             /* 22 MOV Cd,Rd                  */
    dszMOV,   O_CReg_Modrm,             /* 23 MOV Dd,Rd                  */
    dszMOV,   O_Modrm_CReg,             /* 24 MOV Rd,Td                  */
    dszRESERVED, O_DoDB,                /* 25                            */
    dszMOV,   O_CReg_Modrm,             /* 26 MOV Td,Rd                  */

    dszWRMSR, O_NoOperands,             /* 30 WRMSR                      */
    dszRDTSC, O_NoOperands,             /* 31 RDTSC                      */
    dszRDMSR, O_NoOperands,             /* 32 RDMSR                      */
    dszRDPMC, O_NoOperands,             /* 33 RDPMC                      */

    dszCMOVO,  O_Reg_Modrm,             /* 40 CMOVO                      */
    dszCMOVNO, O_Reg_Modrm,             /* 41 CMOVNO                     */
    dszCMOVB,  O_Reg_Modrm,             /* 42 CMOVB                      */
    dszCMOVNB, O_Reg_Modrm,             /* 43 CMOVNB                     */
    dszCMOVE,  O_Reg_Modrm,             /* 44 CMOVE                      */
    dszCMOVNE, O_Reg_Modrm,             /* 45 CMOVNE                     */
    dszCMOVBE, O_Reg_Modrm,             /* 46 CMOVBE                     */
    dszCMOVA,  O_Reg_Modrm,             /* 47 CMOVNBE                    */
    dszCMOVS,  O_Reg_Modrm,             /* 48 CMOVS                      */
    dszCMOVNS, O_Reg_Modrm,             /* 49 CMOVNS                     */
    dszCMOVP,  O_Reg_Modrm,             /* 4A CMOVP                      */
    dszCMOVNP, O_Reg_Modrm,             /* 4B CMOVNP                     */
    dszCMOVL,  O_Reg_Modrm,             /* 4C CMOVL                      */
    dszCMOVGE, O_Reg_Modrm,             /* 4D CMOVGE                     */
    dszCMOVLE, O_Reg_Modrm,             /* 4E CMOVLE                     */
    dszCMOVNLE,O_Reg_Modrm,             /* 4F CMOVNLE                    */

    dszPUNPCKLBW,O_MmReg_qModrm,        /* 60 PUNPCKLBW                  */
    dszPUNPCKLWD,O_MmReg_qModrm,        /* 61 PUNPCKLWD                  */
    dszPUNPCKLDQ,O_MmReg_qModrm,        /* 62 PUNPCKLDQ                  */
    dszPACKSSWB, O_MmReg_qModrm,        /* 63 PACKSSWB                   */
    dszPCMPGTB,  O_MmReg_qModrm,        /* 64 PCMPGTB                    */
    dszPCMPGTW,  O_MmReg_qModrm,        /* 65 PCMPGTW                    */
    dszPCMPGTD,  O_MmReg_qModrm,        /* 66 PCMPGTD                    */
    dszPACKUSWB, O_MmReg_qModrm,        /* 67 PACKUSWB                   */
    dszPUNPCKHBW,O_MmReg_qModrm,        /* 68 PUNPCKHBW                  */
    dszPUNPCKHWD,O_MmReg_qModrm,        /* 69 PUNPCKHWD                  */
    dszPUNPCKHDQ,O_MmReg_qModrm,        /* 6A PUNPCKHDQ                  */
    dszPACKSSDW, O_MmReg_qModrm,        /* 6B PACKSSDW                   */
    dszRESERVED, O_DoDB,                /* 6C                            */
    dszRESERVED, O_DoDB,                /* 6D                            */
    dszMOVD,     O_MmReg_dModrm,        /* 6E MOVD                       */
    dszMOVQ,     O_MmReg_qModrm,        /* 6F MOVQ                       */
    dszRESERVED, O_DoDB,                /* 70                            */
    dszMULTI,    O_PSHimw,              /* 71 PS[LR][AL]W immediate      */
    dszMULTI,    O_PSHimd,              /* 72 PS[LR][AL]D immediate      */
    dszMULTI,    O_PSHimq,              /* 73 PS[LR]LQ immediate         */
    dszPCMPEQB,  O_MmReg_qModrm,        /* 74 PCMPEQB                    */
    dszPCMPEQW,  O_MmReg_qModrm,        /* 75 PCMPEQW                    */
    dszPCMPEQD,  O_MmReg_qModrm,        /* 76 PCMPEQD                    */
    dszEMMS,     O_NoOperands,          /* 77 EMMS                       */
    dszRESERVED, O_DoDB,                /* 78                            */
    dszRESERVED, O_DoDB,                /* 79                            */
    dszRESERVED, O_DoDB,                /* 7A                            */
    dszRESERVED, O_DoDB,                /* 7B                            */
    dszRESERVED, O_DoDB,                /* 7C                            */
    dszSETNL,    O_bModrm,              /* 7D SETNL                      */
    dszMOVD,     O_dModrm_MmReg,        /* 7E MOVD                       */
    dszMOVQ,     O_qModrm_MmReg,        /* 7F MOVQ                       */
    dszJO,    O_Rel16,                  /* 80 JO                         */
    dszJNO,   O_Rel16,                  /* 81 JNO                        */
    dszJB,    O_Rel16,                  /* 82 JB                         */
    dszJNB,   O_Rel16,                  /* 83 JNB                        */
    dszJE,    O_Rel16,                  /* 84 JE                         */
    dszJNE,   O_Rel16,                  /* 85 JNE                        */
    dszJBE,   O_Rel16,                  /* 86 JBE                        */
    dszJNBE,  O_Rel16,                  /* 87 JNBE                       */
    dszJS,    O_Rel16,                  /* 88 JS                         */
    dszJNS,   O_Rel16,                  /* 89 JNS                        */
    dszJP,    O_Rel16,                  /* 8A JP                         */
    dszJNP,   O_Rel16,                  /* 8B JNP                        */
    dszJL,    O_Rel16,                  /* 8C JL                         */
    dszJNL,   O_Rel16,                  /* 8D JNL                        */
    dszJLE,   O_Rel16,                  /* 8E JLE                        */
    dszJNLE,  O_Rel16,                  /* 8F JNLE                       */
    dszSETO,  O_bModrm,                 /* 90 SETO                       */
    dszSETNO, O_bModrm,                 /* 91 SETNO                      */
    dszSETB,  O_bModrm,                 /* 92 SETB                       */
    dszSETNB, O_bModrm,                 /* 93 SETNB                      */
    dszSETE,  O_bModrm,                 /* 94 SETE                       */
    dszSETNE, O_bModrm,                 /* 95 SETNE                      */
    dszSETBE, O_bModrm,                 /* 96 SETBE                      */
    dszSETA,  O_bModrm,                 /* 97 SETNBE                     */
    dszSETS,  O_bModrm,                 /* 98 SETS                       */
    dszSETNS, O_bModrm,                 /* 99 SETNS                      */
    dszSETP,  O_bModrm,                 /* 9A SETP                       */
    dszSETNP, O_bModrm,                 /* 9B SETNP                      */
    dszSETL,  O_bModrm,                 /* 9C SETL                       */
    dszSETGE, O_bModrm,                 /* 9D SETGE                      */
    dszSETLE, O_bModrm,                 /* 9E SETLE                      */
    dszSETNLE,O_bModrm,                 /* 9F SETNLE                     */
    dszPUSH,  O_sReg2,                  /* A0 PUSH FS                    */
    dszPOP,   O_sReg2,                  /* A1 POP FS                     */
    dszCPUID, O_NoOperands,             /* A2 CPUID                      */
    dszBT,    O_Modrm_Reg,              /* A3 BT                         */
    dszSHLD,  O_Modrm_Reg_Ib,           /* A4 SHLD                       */
    dszSHLD,  O_Modrm_Reg_CL,           /* A5 SHLD                       */
    dszRESERVED, O_DoDB,                /* A6                            */
    dszRESERVED, O_DoDB,                /* A7                            */
    dszPUSH,  O_sReg2,                  /* A8 PUSH GS                    */
    dszPOP,   O_sReg2,                  /* A9 POP GS                     */
    dszRSM,   O_NoOperands,             /* AA RSM                        */
    dszBTS,   O_vModrm_Reg,             /* AB BTS                        */
    dszSHRD,  O_Modrm_Reg_Ib,           /* AC SHRD                       */
    dszSHRD,  O_Modrm_Reg_CL,           /* AD SHRD                       */
    dszRESERVED, O_DoDB,                /* AE                            */
    dszIMUL,  O_Reg_Modrm,              /* AF IMUL                       */
    dszCMPXCHG,O_bModrm_Reg,            /* B0 CMPXCH                     */
    dszCMPXCHG,O_Modrm_Reg,             /* B1 CMPXCH                     */
    dszLSS,   O_fReg_Modrm,             /* B2 LSS                        */
    dszBTR,   O_Modrm_Reg,              /* B3 BTR                        */
    dszLFS,   O_fReg_Modrm,             /* B4 LFS                        */
    dszLGS,   O_fReg_Modrm,             /* B5 LGS                        */
    dszMOVZX, O_Reg_bModrm,             /* B6 MOVZX                      */
    dszMOVZX, O_Reg_wModrm,             /* B7 MOVZX                      */
    dszRESERVED, O_DoDB,                /* B8                            */
    dszRESERVED, O_DoDB,                /* B9                            */
    dszMULTI, O_GROUP8,                 /* BA MULTI                      */
    dszBTC,   O_Modrm_Reg,              /* BB BTC                        */
    dszBSF,   O_Reg_Modrm,              /* BC BSF                        */
    dszBSR,   O_Reg_Modrm,              /* BD BSR                        */
    dszMOVSX, O_Reg_bModrm,             /* BE MOVSX                      */
    dszMOVSX, O_Reg_wModrm,             /* BF MOVSX                      */
    dszXADD,  O_bModrm_Reg,             /* C0 XADD                       */
    dszXADD,  O_Modrm_Reg,              /* C1 XADD                       */
    dszRESERVED, O_DoDB,                /* C2                            */
    dszRESERVED, O_DoDB,                /* C3                            */
    dszRESERVED, O_DoDB,                /* C4                            */
    dszRESERVED, O_DoDB,                /* C5                            */
    dszRESERVED, O_DoDB,                /* C6                            */
    dszCMPXCHG8B,O_qModrm,              /* C7 CMPXCHG8B                  */
    dszBSWAP,    O_oReg,                /* C8 BSWAP                      */
    dszBSWAP,    O_oReg,                /* C9 BSWAP                      */
    dszBSWAP,    O_oReg,                /* CA BSWAP                      */
    dszBSWAP,    O_oReg,                /* CB BSWAP                      */
    dszBSWAP,    O_oReg,                /* CC BSWAP                      */
    dszBSWAP,    O_oReg,                /* CD BSWAP                      */
    dszBSWAP,    O_oReg,                /* CE BSWAP                      */
    dszBSWAP,    O_oReg,                /* CF BSWAP                      */
    dszRESERVED, O_DoDB,                /* D0                            */
    dszPSRLW,    O_MmReg_qModrm,        /* D1 PSRLW                      */
    dszPSRLD,    O_MmReg_qModrm,        /* D2 PSRLD                      */
    dszPSRLQ,    O_MmReg_qModrm,        /* D3 PSRLQ                      */
    dszRESERVED, O_DoDB,                /* D4                            */
    dszPMULLW,   O_MmReg_qModrm,        /* D5 PMULLW                     */
    dszRESERVED, O_DoDB,                /* D6                            */
    dszRESERVED, O_DoDB,                /* D7                            */
    dszPSUBUSB,  O_MmReg_qModrm,        /* D8 PSUBUSB                    */
    dszPSUBUSW,  O_MmReg_qModrm,        /* D9 PSUBUSW                    */
    dszRESERVED, O_DoDB,                /* DA                            */
    dszPAND,     O_MmReg_qModrm,        /* DB PAND                       */
    dszPADDUSB,  O_MmReg_qModrm,        /* DC PADDUSB                    */
    dszPADDUSW,  O_MmReg_qModrm,        /* DD PADDUSW                    */
    dszRESERVED, O_DoDB,                /* DE                            */
    dszPANDN,    O_MmReg_qModrm,        /* DF PANDN                      */
    dszRESERVED, O_DoDB,                /* E0                            */
    dszPSRAW,    O_MmReg_qModrm,        /* E1 PSRAW                      */
    dszPSRAD,    O_MmReg_qModrm,        /* E2 PSRAD                      */
    dszRESERVED, O_DoDB,                /* E3                            */
    dszRESERVED, O_DoDB,                /* E4                            */
    dszPMULHW,   O_MmReg_qModrm,        /* E5 PMULHW                     */
    dszRESERVED, O_DoDB,                /* E6                            */
    dszRESERVED, O_DoDB,                /* E7                            */
    dszPSUBSB,   O_MmReg_qModrm,        /* E8 PSUBSB                     */
    dszPSUBSW,   O_MmReg_qModrm,        /* E9 PSUBSW                     */
    dszRESERVED, O_DoDB,                /* EA                            */
    dszPOR,      O_MmReg_qModrm,        /* EB POR                        */
    dszPADDSB,   O_MmReg_qModrm,        /* EC PADDSB                     */
    dszPADDSW,   O_MmReg_qModrm,        /* ED PADDSW                     */
    dszRESERVED, O_DoDB,                /* EE                            */
    dszPXOR,     O_MmReg_qModrm,        /* EF PXOR                       */
    dszRESERVED, O_DoDB,                /* F0                            */
    dszPSLLW,    O_MmReg_qModrm,        /* F1 PSLLW                      */
    dszPSLLD,    O_MmReg_qModrm,        /* F2 PSLLD                      */
    dszPSLLQ,    O_MmReg_qModrm,        /* F3 PSLLQ                      */
    dszRESERVED, O_DoDB,                /* F4                            */
    dszPMADDWD,  O_MmReg_qModrm,        /* F5 PMADDWD                    */
    dszRESERVED, O_DoDB,                /* F6                            */
    dszRESERVED, O_DoDB,                /* F7                            */
    dszPSUBB,    O_MmReg_qModrm,        /* F8 PSUBB                      */
    dszPSUBW,    O_MmReg_qModrm,        /* F9 PSUBW                      */
    dszPSUBD,    O_MmReg_qModrm,        /* FA PSUBD                      */
    dszRESERVED, O_DoDB,                /* FB                            */
    dszPADDB,    O_MmReg_qModrm,        /* FC PADDB                      */
    dszPADDW,    O_MmReg_qModrm,        /* FD PADDW                      */
    dszPADDD,    O_MmReg_qModrm,        /* FE PADDD                      */
};

/* Auxilary lists of mnemonics for groups of two byte instructions:      */
/*   All of the instructions within each of these groups are of the same */
/*   class, so only the mnemonic string is needed, the index into the    */
/*   action table is implicit.                                           */

static char *group[][8] = {

/* 00 */    {dszADD,  dszOR,    dszADC,  dszSBB,    /* group 1 */
             dszAND,  dszSUB,   dszXOR,  dszCMP},

/* 01 */    {dszROL,  dszROR,   dszRCL,      dszRCR,    /* group 2 */
             dszSHL,  dszSHR,   dszRESERVED, dszSAR},

/* 02 */    {dszINC,      dszDEC,      dszRESERVED, dszRESERVED, /* group 4 */
             dszRESERVED, dszRESERVED, dszRESERVED, dszRESERVED},

/* 03 */    {dszSLDT, dszSTR,   dszLLDT,     dszLTR,    /* group 6 */
             dszVERR, dszVERW,  dszRESERVED, dszRESERVED},

/* 04 */    {dszRESERVED, dszRESERVED, dszRESERVED, dszRESERVED, /* group 8 */
             dszBT,       dszBTS,      dszBTR,      dszBTC},

/* 05 */    {dszRESERVED, dszRESERVED, dszPSRLW,    dszRESERVED, /* PSHimw */
             dszPSRAW,    dszRESERVED, dszPSLLW,    dszRESERVED},
            
/* 06 */    {dszRESERVED, dszRESERVED, dszPSRLD,    dszRESERVED, /* PSHimd */
             dszPSRAD,    dszRESERVED, dszPSLLD,    dszRESERVED},
            
/* 07 */    {dszRESERVED, dszRESERVED, dszPSRLQ,    dszRESERVED, /* PSHimq */
             dszRESERVED, dszRESERVED, dszPSLLQ,    dszRESERVED},
            
            };

/* Auxilary orderd pairs for groups of two byte instructions structured  */
/*   the same was as distbl above.                                       */

static Tdistbl groupt[][8] = {

/* 00  00                     x87-D8-1                   */
            { dszFADD,     O_dModrm,     /* D8-0 FADD    */
              dszFMUL,     O_dModrm,     /* D8-1 FMUL    */
              dszFCOM,     O_dModrm,     /* D8-2 FCOM    */
              dszFCOMP,    O_dModrm,     /* D8-3 FCOMP   */
              dszFSUB,     O_dModrm,     /* D8-4 FSUB    */
              dszFSUBR,    O_dModrm,     /* D8-5 FSUBR   */
              dszFDIV,     O_dModrm,     /* D8-6 FDIV    */
              dszFDIVR,    O_dModrm },   /* D8-7 FDIVR   */

/* 01                         x87-D8-2                   */
            { dszFADD,     O_ST_iST,     /* D8-0 FADD    */
              dszFMUL,     O_ST_iST,     /* D8-1 FMUL    */
              dszFCOM,     O_iST,        /* D8-2 FCOM    */
              dszFCOMP,    O_iST,        /* D8-3 FCOMP   */
              dszFSUB,     O_ST_iST,     /* D8-4 FSUB    */
              dszFSUBR,    O_ST_iST,     /* D8-5 FSUBR   */
              dszFDIV,     O_ST_iST,     /* D8-6 FDIV    */
              dszFDIVR,    O_ST_iST },   /* D8-7 FDIVR   */

/* 02   01                    x87-D9-1                   */
            { dszFLD,      O_dModrm,     /* D9-0 FLD     */
              dszRESERVED, O_DoDB,       /* D9-1         */
              dszFST,      O_dModrm,     /* D9-2 FST     */
              dszFSTP,     O_dModrm,     /* D9-3 FSTP    */
              dszFLDENV,   O_Modrm,      /* D9-4 FLDENV  */
              dszFLDCW,    O_Modrm,      /* D9-5 FLDCW   */
              dszFSTENV,   O_Modrm,      /* D9-6 FSTENV  */
              dszFSTCW,    O_Modrm },    /* D9-7 FSTCW   */

/* 03   01                    x87-D9-2 TTT=0,1,2,3       */
            { dszFLD,      O_iST,        /* D9-0 FLD     */
              dszFXCH,     O_iST,        /* D9-1 FXCH    */
              dszFNOP,     O_NoOperands, /* D9-2 FNOP    */
              dszFSTP,     O_iST,        /* D9-3 FSTP    */
              dszRESERVED, O_DoDB,       /* D9-4         */
              dszRESERVED, O_DoDB,       /* D9-5         */
              dszRESERVED, O_DoDB,       /* D9-6         */
              dszRESERVED, O_DoDB   },   /* D9-7         */

/* 04  02                     x89-DA-1                   */
            { dszFIADD,    O_dModrm,     /* DA-0 FIADD   */
              dszFIMUL,    O_dModrm,     /* DA-1 FIMUL   */
              dszFICOM,    O_dModrm,     /* DA-2 FICOM   */
              dszFICOMP,   O_dModrm,     /* DA-3 FICOMP  */
              dszFISUB,    O_dModrm,     /* DA-4 FISUB   */
              dszFISUBR,   O_dModrm,     /* DA-5 FISUBR  */
              dszFIDIV,    O_dModrm,     /* DA-6 FIDIV   */
              dszFIDIVR,   O_dModrm },   /* DA-7 FIDIVR  */

/* 05                         x87-DA-2                   */
            { dszFCMOVB,   O_ST_iST,     /* DA-0 FCMOVB  */
              dszFCMOVE,   O_ST_iST,     /* DA-1 FCMOVE  */
              dszFCMOVBE,  O_ST_iST,     /* DA-2 FCMOVBE */
              dszFCMOVU,   O_ST_iST,     /* DA-3 FCMOVU  */
              dszRESERVED, O_DoDB,       /* DA-4         */
              dszFUCOMPP,  O_NoOperands, /* DA-5         */
              dszRESERVED, O_DoDB,       /* DA-6         */
              dszRESERVED, O_DoDB },     /* DA-7         */

/* 06  03                     x87-DB-1                   */
            { dszFILD,     O_dModrm,     /* DB-0 FILD    */
              dszRESERVED, O_DoDB,       /* DB-1         */
              dszFIST,     O_dModrm,     /* DB-2 FIST    */
              dszFISTP,    O_dModrm,     /* DB-3 FISTP   */
              dszRESERVED, O_DoDB,       /* DB-4         */
              dszFLD,      O_tModrm,     /* DB-5 FLD     */
              dszRESERVED, O_DoDB,       /* DB-6         */
              dszFSTP,     O_tModrm },   /* DB-7 FSTP    */

/* 07                      x87-DB-2 ttt=4        */
            { dszFENI,     O_NoOperands, /* DB-0 FENI    */
              dszFDISI,    O_NoOperands, /* DB-1 FDISI   */
              dszFCLEX,    O_NoOperands, /* DB-2 FCLEX   */
              dszFINIT,    O_NoOperands, /* DB-3 FINIT   */
              dszFSETPM,   O_DoDB,       /* DB-4 FSETPM  */
              dszRESERVED, O_DoDB,       /* DB-5         */
              dszRESERVED, O_DoDB,       /* DB-6         */
              dszRESERVED, O_DoDB },     /* DB-7         */

/* 08 04                      x87-DC-1                   */
            { dszFADD,     O_qModrm,     /* DC-0 FADD    */
              dszFMUL,     O_qModrm,     /* DC-1 FMUL    */
              dszFCOM,     O_qModrm,     /* DC-2 FCOM    */
              dszFCOMP,    O_qModrm,     /* DC-3 FCOMP   */
              dszFSUB,     O_qModrm,     /* DC-4 FSUB    */
              dszFSUBR,    O_qModrm,     /* DC-5 FSUBR   */
              dszFDIV,     O_qModrm,     /* DC-6 FDIV    */
              dszFDIVR,    O_qModrm },   /* DC-7 FDIVR   */

/* 09                         x87-DC-2                   */
            { dszFADD,     O_iST_ST,     /* DC-0 FADD    */
              dszFMUL,     O_iST_ST,     /* DC-1 FMUL    */
              dszFCOM,     O_iST,        /* DC-2 FCOM    */
              dszFCOMP,    O_iST,        /* DC-3 FCOMP   */
              dszFSUB,     O_iST_ST,     /* DC-4 FSUB    */
              dszFSUBR,    O_iST_ST,     /* DC-5 FSUBR   */
              dszFDIV,     O_iST_ST,     /* DC-6 FDIVR   */
              dszFDIVR,    O_iST_ST },   /* DC-7 FDIV    */

/* 10  05                     x87-DD-1                   */
            { dszFLD,      O_qModrm,     /* DD-0 FLD     */
              dszRESERVED, O_DoDB,       /* DD-1         */
              dszFST,      O_qModrm,     /* DD-2 FST     */
              dszFSTP,     O_qModrm,     /* DD-3 FSTP    */
              dszFRSTOR,   O_Modrm,      /* DD-4 FRSTOR  */
              dszRESERVED, O_DoDB,       /* DD-5         */
              dszFSAVE,    O_Modrm,      /* DD-6 FSAVE   */
              dszFSTSW,    O_Modrm },    /* DD-7 FSTSW   */

/* 11                         x87-DD-2                   */
            { dszFFREE,    O_iST,        /* DD-0 FFREE   */
              dszFXCH,     O_iST,        /* DD-1 FXCH    */
              dszFST,      O_iST,        /* DD-2 FST     */
              dszFSTP,     O_iST,        /* DD-3 FSTP    */
              dszFUCOM,    O_iST,        /* DD-4 FUCOM   */
              dszFUCOMP,   O_iST,        /* DD-5 FUCOMP  */
              dszRESERVED, O_DoDB,       /* DD-6         */
              dszRESERVED, O_DoDB },     /* DD-7         */

/* 12  06                     x87-DE-1                   */
            { dszFIADD,    O_wModrm,     /* DE-0 FIADD   */
              dszFIMUL,    O_wModrm,     /* DE-1 FIMUL   */
              dszFICOM,    O_wModrm,     /* DE-2 FICOM   */
              dszFICOMP,   O_wModrm,     /* DE-3 FICOMP  */
              dszFISUB,    O_wModrm,     /* DE-4 FISUB   */
              dszFISUBR,   O_wModrm,     /* DE-5 FISUBR  */
              dszFIDIV,    O_wModrm,     /* DE-6 FIDIV   */
              dszFIDIVR,   O_wModrm },   /* DE-7 FIDIVR  */

/* 13                         x87-DE-2                   */
            { dszFADDP,    O_iST_ST,     /* DE-0 FADDP   */
              dszFMULP,    O_iST_ST,     /* DE-1 FMULP   */
              dszFCOMP,    O_iST,        /* DE-2 FCOMP   */
              dszFCOMPP,   O_NoOperands, /* DE-3 FCOMPP  */
              dszFSUBP,    O_iST_ST,     /* DE-4 FSUBP   */
              dszFSUBRP,   O_iST_ST,     /* DE-5 FSUBRP  */
              dszFDIVP,    O_iST_ST,     /* DE-6 FDIVP   */
              dszFDIVRP,   O_iST_ST },   /* DE-7 FDIVRP  */

/* 14  07                     x87-DF-1                   */
            { dszFILD,     O_wModrm,     /* DF-0 FILD    */
              dszRESERVED, O_DoDB,       /* DF-1         */
              dszFIST,     O_wModrm,     /* DF-2 FIST    */
              dszFISTP,    O_wModrm,     /* DF-3 FISTP   */
              dszFBLD,     O_tModrm,     /* DF-4 FBLD    */
              dszFILD,     O_qModrm,     /* DF-5 FILD    */
              dszFBSTP,    O_tModrm,     /* DF-6 FBSTP   */
              dszFISTP,    O_qModrm },   /* DF-7 FISTP   */

/* 15                         x87-DF-2                   */
            { dszFFREE,    O_iST,        /* DF-0 FFREE   */
              dszFXCH,     O_iST,        /* DF-1 FXCH    */
              dszFST,      O_iST,        /* DF-2 FST     */
              dszFSTP,     O_iST,        /* DF-3 FSTP    */
              dszFSTSW,    O_NoOperands, /* DF-4 FSTSW   */
              dszFUCOMIP,  O_ST_iST,     /* DF-5 FUCOMIP */
              dszFCOMIP,   O_ST_iST,     /* DF-6 FCOMIP  */
              dszRESERVED, O_DoDB },     /* DF-7         */

/* 16   01            x87-D9 Mod=3 TTT=4                 */
            { dszFCHS,     O_NoOperands, /* D9-0 FCHS    */
              dszFABS,     O_NoOperands,  /* D9-1 FABS   */
              dszRESERVED, O_DoDB,       /* D9-2         */
              dszRESERVED, O_DoDB,       /* D9-3         */
              dszFTST,     O_NoOperands, /* D9-4 FTST    */
              dszFXAM,     O_NoOperands, /* D9-5 FXAM    */
              dszRESERVED, O_DoDB,       /* D9-6         */
              dszRESERVED, O_DoDB },     /* D9-7         */

/* 17   01            x87-D9 Mod=3 TTT=5                 */
            { dszFLD1,     O_NoOperands, /* D9-0 FLD1    */
              dszFLDL2T,   O_NoOperands, /* D9-1 FLDL2T  */
              dszFLDL2E,   O_NoOperands, /* D9-2 FLDL2E  */
              dszFLDPI,    O_NoOperands, /* D9-3 FLDPI   */
              dszFLDLG2,   O_NoOperands, /* D9-4 FLDLG2  */
              dszFLDLN2,   O_NoOperands, /* D9-5 FLDLN2  */
              dszFLDZ,     O_NoOperands, /* D9-6 FLDZ    */
              dszRESERVED, O_DoDB },     /* D9-7         */

/* 18   01            x87-D9 Mod=3 TTT=6                   */
            { dszF2XM1,    O_NoOperands,   /* D9-0 F2XM1   */
              dszFYL2X,    O_NoOperands,   /* D9-1 FYL2X   */
              dszFPTAN,    O_NoOperands,   /* D9-2 FPTAN   */
              dszFPATAN,   O_NoOperands,   /* D9-3 FPATAN  */
              dszFXTRACT,  O_NoOperands,   /* D9-4 FXTRACT */
              dszFPREM1,   O_NoOperands,   /* D9-5 FPREM1  */
              dszFDECSTP,  O_NoOperands,   /* D9-6 FDECSTP */
              dszFINCSTP,  O_NoOperands }, /* D9-7 FINCSTP */

/* 19   01            x87-D9 Mod=3 TTT=7                   */
            { dszFPREM,    O_NoOperands,   /* D9-0 FPREM   */
              dszFYL2XP1,  O_NoOperands,   /* D9-1 FYL2XP1 */
              dszFSQRT,    O_NoOperands,   /* D9-2 FSQRT   */
              dszFSINCOS,  O_NoOperands,   /* D9-3 FSINCOS */
              dszFRNDINT,  O_NoOperands,   /* D9-4 FRNDINT */
              dszFSCALE,   O_NoOperands,   /* D9-5 FSCALE  */
              dszFSIN,     O_NoOperands,   /* D9-6 FSIN    */
              dszFCOS,     O_NoOperands }, /* D9-7 FCOS    */

/* 20                  group 3                             */
            { dszTEST,     O_bModrm_Ib,    /* F6-0 TEST    */
              dszRESERVED, O_DoDB,         /* F6-1         */
              dszNOT,      O_bModrm,       /* F6-2 NOT     */
              dszNEG,      O_bModrm,       /* F6-3 NEG     */
              dszMUL,      O_bModrm,       /* F6-4 MUL     */
              dszIMUL,     O_bModrm,       /* F6-5 IMUL    */
              dszDIV,      O_bModrm,       /* F6-6 DIV     */
              dszIDIV,     O_bModrm },     /* F6-7 IDIV    */

/* 21                  group 3                             */
            { dszTEST,     O_vModrm_Iv,    /* F7-0 TEST    */
              dszRESERVED, O_DoDB,         /* F7-1         */
              dszNOT,      O_vModrm,       /* F7-2 NOT     */
              dszNEG,      O_vModrm,       /* F7-3 NEG     */
              dszMUL,      O_vModrm,       /* F7-4 MUL     */
              dszIMUL,     O_vModrm,       /* F7-5 IMUL    */
              dszDIV,      O_vModrm,       /* F7-6 DIV     */
              dszIDIV,     O_vModrm },     /* F7-7 IDIV    */

/* 22                  group 5                             */
            { dszINC,      O_vModrm,     /* FF-0 INC       */
              dszDEC,      O_vModrm,     /* FF-1 DEC       */
              dszCALL,     O_vModrm,     /* FF-2 CALL      */
              dszCALL,     O_fModrm,     /* FF-3 CALL      */
              dszJMP,      O_vModrm,     /* FF-4 JMP       */
              dszJMP,      O_fModrm,     /* FF-5 JMP       */
              dszPUSH,     O_vModrm,     /* FF-6 PUSH      */
              dszRESERVED, O_DoDB },     /* FF-7           */

/* 23                  group 7                             */
            { dszSGDT,     O_Modrm,      /* 0F-0 SGDT      */
              dszSIDT,     O_Modrm,      /* 0F-1 SIDT      */
              dszLGDT,     O_Modrm,      /* 0F-2 LGDT      */
              dszLIDT,     O_Modrm,      /* 0F-3 LIDT      */
              dszSMSW,     O_wModrm,     /* 0F-4 MSW       */
              dszRESERVED, O_DoDB,       /* 0F-5           */
              dszLMSW,     O_wModrm,     /* 0F-6 LMSW      */
              dszINVLPG,   O_Modrm },    /* 0F-7 INVLPG    */

/* 24                 x87-DB Mod=3 TTT != 4                */
            { dszFCMOVNB,  O_ST_iST,     /* DB-0 FCMOVNB   */
              dszFCMOVNE,  O_ST_iST,     /* DB-1 FCMOVNE   */
              dszFCMOVNBE, O_ST_iST,     /* DB-2 FCMOVNBE  */
              dszFCMOVNU,  O_ST_iST,     /* DB-3 FCMOVNU   */
              dszRESERVED, O_DoDB,       /* DB-4           */
              dszFUCOMI,   O_ST_iST,     /* DB-5 FUCOMI    */
              dszFCOMI,    O_ST_iST,     /* DB-6 FCOMI     */
              dszRESERVED, O_DoDB }      /* DB-7           */

            };

typedef struct _ADDR {
    USHORT      type;
    USHORT      seg;
    ULONG       off;
    union {
        ULONG flat;
        ULONGLONG flat64;
    };
} ADDR, *PADDR;

#endif //_86DIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\86dis.c ===
/*    @ Author: Gerd Immeyer              @ Version:                       */
/*                                                                         */
/*    @ Creation Date: 10.19.89           @ Modification Date:             */
/*                                                                         */
/***************************************************************************/

//
// Munged for my purposes on 10/20/99 (v-johnwh)
//
#include <string.h>

typedef unsigned long       DWORD;
typedef unsigned long ULONG;
typedef unsigned short USHORT;
typedef unsigned __int64 ULONGLONG;
typedef int                 BOOL;
typedef ULONG *PULONG;
typedef void * PVOID;
#define ADDR_V86        ((USHORT)0x0002)
#define ADDR_16         ((USHORT)0x0004)
#define FALSE               0
#define TRUE                1
#define BIT20(b) (b & 0x07)
#define BIT53(b) (b >> 3 & 0x07)
#define BIT76(b) (b >> 6 & 0x03)
#define MAXL     16
#define MAXOPLEN 10
#define REGDS           3
#define REGSS           15
#define REGEBX          6
#define REGEBP          10
#define REGEDI          4
#define REGESI          5
#define REGEAX          9
#define REGECX          8
#define REGEDX          7
#define REGESP          14
#define Off(x)          ((x).off)
#define Type(x)         ((x).type)

#define OBOFFSET 26
#define OBOPERAND 34
#define OBLINEEND 77
#define MAX_SYMNAME_SIZE  1024

#include "86dis.h"

ULONG      X86BrkptLength = 1L;
ULONG      X86TrapInstr = 0xcc;

/*****                     static tables and variables                 *****/
static char regtab[] = "alcldlblahchdhbhaxcxdxbxspbpsidi";  /* reg table */
static char *mrmtb16[] = { "bx+si",  /* modRM string table (16-bit) */
                           "bx+di",
                           "bp+si",
                           "bp+di",
                           "si",
                           "di",
                           "bp",
                           "bx"
                         };

static char *mrmtb32[] = { "eax",       /* modRM string table (32-bit) */
                           "ecx",
                           "edx",
                           "ebx",
                           "esp",
                           "ebp",
                           "esi",
                           "edi"
                         };

static char seg16[8]   = { REGDS,  REGDS,  REGSS,  REGSS,
                           REGDS,  REGDS,  REGSS,  REGDS };
static char reg16[8]   = { REGEBX, REGEBX, REGEBP, REGEBP,
                           REGESI, REGEDI, REGEBP, REGEBX };
static char reg16_2[4] = { REGESI, REGEDI, REGESI, REGEDI };

static char seg32[8]   = { REGDS,  REGDS,  REGDS,  REGDS,
                           REGSS,  REGSS,  REGDS,  REGDS };
static char reg32[8]   = { REGEAX, REGECX, REGEDX, REGEBX,
                           REGESP, REGEBP, REGESI, REGEDI };

static char sregtab[] = "ecsdfg";  // first letter of ES, CS, SS, DS, FS, GS

char    hexdigit[] = { '0', '1', '2', '3', '4', '5', '6', '7',
                       '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

typedef struct _DECODEDATA
{
  int              mod;            /* mod of mod/rm byte */
  int              rm;             /* rm of mod/rm byte */
  int              ttt;            /* return reg value (of mod/rm) */
  unsigned char    *pMem;          /* current position in instruction */
  ADDR             EAaddr[2];      //  offset of effective address
  int              EAsize[2];      //  size of effective address item
  char             *pchEAseg[2];   //  normal segment for operand
  BOOL             fMovX;          // indicates a MOVSX or MOVZX
  BOOL             fMmRegEa;       // Use mm? registers in reg-only EA.
} DECODEDATA;
/*...........................internal function..............................*/
/*                                                                          */
/*                       generate a mod/rm string                           */
/*                                                                          */

void DIdoModrm (char **ppchBuf, int segOvr, DECODEDATA *decodeData)
{
    int     mrm;                        /* modrm byte */
    char    *src;                       /* source string */
    int     sib;
    int     ss;
    int     ind;
    int     oldrm;

    mrm = *(decodeData->pMem)++;                      /* get the mrm byte from instruction */
    decodeData->mod = BIT76(mrm);                   /* get mod */
    decodeData->ttt = BIT53(mrm);                   /* get reg - used outside routine */
    decodeData->rm  = BIT20(mrm);                   /* get rm */

    if (decodeData->mod == 3) {                     /* register only mode */
        if (decodeData->fMmRegEa) {
            *(*ppchBuf)++ = 'm';
            *(*ppchBuf)++ = 'm';
            *(*ppchBuf)++ = decodeData->rm + '0';
        } else {
            src = &regtab[decodeData->rm * 2];          /* point to 16-bit register */
            if (decodeData->EAsize[0] > 1) {
                src += 16;                  /* point to 16-bit register */
                if (!(decodeData->fMovX))
                    *(*ppchBuf)++ = 'e';    /* make it a 32-bit register */
            }
            *(*ppchBuf)++ = *src++;         /* copy register name */
            *(*ppchBuf)++ = *src;
        }
        decodeData->EAsize[0] = 0;                  //  no EA value to output
        return;
        }

    if (1) {                       /* 32-bit addressing mode */
        oldrm = decodeData->rm;
        if (decodeData->rm == 4) {                  /* rm == 4 implies sib byte */
            sib = *(decodeData->pMem)++;              /* get s_i_b byte */
            decodeData->rm = BIT20(sib);            /* return base */
            }

        *(*ppchBuf)++ = '[';
        if (decodeData->mod == 0 && decodeData->rm == 5) {
            decodeData->pMem += 4;
            }

        if (oldrm == 4) {               //  finish processing sib
            ind = BIT53(sib);
            if (ind != 4) {
                *(*ppchBuf)++ = '+';
                ss = 1 << BIT76(sib);
                if (ss != 1) {
                    *(*ppchBuf)++ = '*';
                    *(*ppchBuf)++ = (char)(ss + '0');
                    }
            }
        }
	}

    //  output any displacement

    if (decodeData->mod == 1) {
        decodeData->pMem++;
        }
    else if (decodeData->mod == 2) {
        long tmp = 0;
        if (1) {
            decodeData->pMem += 4;
            }
        else {
            decodeData->pMem += 2;
            }
        }
}

DWORD GetInstructionLengthFromAddress(PVOID paddr)
{
    PULONG  pOffset = 0;
    int     G_mode_32;
    int     mode_32;                    /* local addressing mode indicator */
    int     opsize_32;                  /* operand size flag */
    int     opcode;                     /* current opcode */
    int     olen = 2;                   /* operand length */
    int     alen = 2;                   /* address length */
    int     end = FALSE;                /* end of instruction flag */
    int     mrm = FALSE;                /* indicator that modrm is generated*/
    unsigned char *action;              /* action for operand interpretation*/
    long    tmp;                        /* temporary storage field */
    int     indx;                       /* temporary index */
    int     action2;                    /* secondary action */
    int     instlen;                    /* instruction length */
    int     segOvr = 0;                 /* segment override opcode */
    unsigned char *membuf;              /* current instruction buffer */
    char    *pEAlabel = "";             /* optional label for operand */
    char    RepPrefixBuffer[32];        /* rep prefix buffer */
    char    *pchRepPrefixBuf = RepPrefixBuffer; /* pointer to prefix buffer */
    char    OpcodeBuffer[8];            /* opcode buffer */
    char    *pchOpcodeBuf = OpcodeBuffer; /*  pointer to opcode buffer */
    char    OperandBuffer[MAX_SYMNAME_SIZE + 20]; /*  operand buffer */
    char    *pchOperandBuf = OperandBuffer; /* pointer to operand buffer */
    char    ModrmBuffer[MAX_SYMNAME_SIZE + 20];   /* modRM buffer */
    char    *pchModrmBuf = ModrmBuffer; /* pointer to modRM buffer */
    char    EABuffer[42];               /* effective address buffer */
    char    *pchEABuf = EABuffer;       /* pointer to EA buffer */

    unsigned char BOPaction;
    int     subcode;                    /* bop subcode */
    DECODEDATA decodeData;

    decodeData.fMovX = FALSE;
    decodeData.fMmRegEa = FALSE;
    decodeData.EAsize[0] = decodeData.EAsize[1] = 0;          //  no effective address
    decodeData.pchEAseg[0] = dszDS_;
    decodeData.pchEAseg[1] = dszES_;

    G_mode_32 = 1;

    mode_32 = opsize_32 = (G_mode_32 == 1); /* local addressing mode */
    olen = alen = (1 + mode_32) << 1;   //  set operand/address lengths
                                        //  2 for 16-bit and 4 for 32-bit
#if MULTIMODE
    if (paddr->type & (ADDR_V86 | ADDR_16)) {
        mode_32 = opsize_32 = 0;
        olen = alen = 2;
        }
#endif

    membuf = (unsigned char *)paddr;
                                
    decodeData.pMem = membuf;                      /* point to begin of instruction */
    opcode = *(decodeData.pMem)++;                   /* get opcode */

    if ( opcode == 0xc4 && *(decodeData.pMem) == 0xC4 ) {
        (decodeData.pMem)++;
        action = &BOPaction;
        BOPaction = IB | END;
        subcode =  *(decodeData.pMem);
        if ( subcode == 0x50 || subcode == 0x52 || subcode == 0x53 || subcode == 0x54 || subcode == 0x57 || subcode == 0x58 || subcode == 0x58 ) {
            BOPaction = IW | END;
        }
    } else {
        action = actiontbl + distbl[opcode].opr; /* get operand action */
    }

/*****          loop through all operand actions               *****/

    do {
        action2 = (*action) & 0xc0;
        switch((*action++) & 0x3f) {
            case ALT:                   /* alter the opcode if 32-bit */
                if (opsize_32) {
                    indx = *action++;
                    pchOpcodeBuf = &OpcodeBuffer[indx];
                    if (indx == 0)
                       ;
                    else {
                        *pchOpcodeBuf++ = 'd';
                        if (indx == 1)
                            *pchOpcodeBuf++ = 'q';
                        }
                    }
                break;

            case STROP:
                //  compute size of operands in indx
                //  also if dword operands, change fifth
                //  opcode letter from 'w' to 'd'.

                if (opcode & 1) {
                    if (opsize_32) {
                        indx = 4;
                        OpcodeBuffer[4] = 'd';
                        }
                    else
                        indx = 2;
                    }
                else
                    indx = 1;

                if (*action & 1) {
                    }
                if (*action++ & 2) {
                    }
                break;

            case CHR:                   /* insert a character */
                *pchOperandBuf++ = *action++;
                break;

            case CREG:                  /* set debug, test or control reg */
                if ((opcode - SECTAB_OFFSET_2)&0x04) //remove bias from opcode
                    *pchOperandBuf++ = 't';
                else if ((opcode - SECTAB_OFFSET_2) & 0x01)
                    *pchOperandBuf++ = 'd';
                else
                    *pchOperandBuf++ = 'c';
                *pchOperandBuf++ = 'r';
                *pchOperandBuf++ = (char)('0' + decodeData.ttt);
                break;

            case SREG2:                 /* segment register */
                // Handle special case for fs/gs (OPC0F adds SECTAB_OFFSET_5
                // to these codes)
                if (opcode > 0x7e)
                    decodeData.ttt = BIT53((opcode-SECTAB_OFFSET_5));
                else
                decodeData.ttt = BIT53(opcode);    //  set value to fall through

            case SREG3:                 /* segment register */
                *pchOperandBuf++ = sregtab[decodeData.ttt];  // reg is part of modrm
                *pchOperandBuf++ = 's';
                break;

            case BRSTR:                 /* get index to register string */
                decodeData.ttt = *action++;        /*    from action table */
                goto BREGlabel;

            case BOREG:                 /* byte register (in opcode) */
                decodeData.ttt = BIT20(opcode);    /* register is part of opcode */
                goto BREGlabel;

            case ALSTR:
                decodeData.ttt = 0;                /* point to AL register */
BREGlabel:
            case BREG:                  /* general register */
                *pchOperandBuf++ = regtab[decodeData.ttt * 2];
                *pchOperandBuf++ = regtab[decodeData.ttt * 2 + 1];
                break;

            case WRSTR:                 /* get index to register string */
                decodeData.ttt = *action++;        /*    from action table */
                goto WREGlabel;

            case VOREG:                 /* register is part of opcode */
                decodeData.ttt = BIT20(opcode);
                goto VREGlabel;

            case AXSTR:
                decodeData.ttt = 0;                /* point to eAX register */
VREGlabel:
            case VREG:                  /* general register */
                if (opsize_32)          /* test for 32bit mode */
                    *pchOperandBuf++ = 'e';
WREGlabel:
            case WREG:                  /* register is word size */
                *pchOperandBuf++ = regtab[decodeData.ttt * 2 + 16];
                *pchOperandBuf++ = regtab[decodeData.ttt * 2 + 17];
                break;

            case MMWREG:
                *pchOperandBuf++ = 'm';
                *pchOperandBuf++ = 'm';
                *pchOperandBuf++ = decodeData.ttt + '0';
                break;

            case IST_ST:
                *(pchOperandBuf - 5) += (char)decodeData.rm;
                break;

            case ST_IST:
                ;
            case IST:
                ;
                *(pchOperandBuf - 2) += (char)decodeData.rm;
                break;

            case xBYTE:                 /* set instruction to byte only */
                decodeData.EAsize[0] = 1;
                break;

            case VAR:
                if (opsize_32)
                    goto DWORDlabel;

            case xWORD:
                decodeData.EAsize[0] = 2;
                break;

            case EDWORD:
                opsize_32 = 1;    //  for control reg move, use eRegs
            case xDWORD:
DWORDlabel:
                decodeData.EAsize[0] = 4;
                break;

            case MMQWORD:
                decodeData.fMmRegEa = TRUE;

            case QWORD:
                decodeData.EAsize[0] = 8;
                break;

            case TBYTE:
                decodeData.EAsize[0] = 10;
                break;

            case FARPTR:
                if (opsize_32) {
                    decodeData.EAsize[0] = 6;
                    }
                else {
                    decodeData.EAsize[0] = 4;
                    }
                break;

            case LMODRM:                //  output modRM data type
                if (decodeData.mod != 3)
                    ;
                else
                    decodeData.EAsize[0] = 0;

            case MODRM:                 /* output modrm string */
                if (segOvr)             /* in case of segment override */
                    0;
                break;

            case ADDRP:                 /* address pointer */
                decodeData.pMem += olen + 2;
                break;

            case REL8:                  /* relative address 8-bit */
                if (opcode == 0xe3 && mode_32) {
                    pchOpcodeBuf = OpcodeBuffer;
                    }
                tmp = (long)*(char *)(decodeData.pMem)++; /* get the 8-bit rel offset */
                goto DoRelDispl;

            case REL16:                 /* relative address 16-/32-bit */
                tmp = 0;
                if (mode_32)
                    memmove(&tmp,decodeData.pMem,sizeof(long));
                else
                    memmove(&tmp,decodeData.pMem,sizeof(short));
                decodeData.pMem += alen;           /* skip over offset */
DoRelDispl:
//                tmp += *pOffset + (decodeData.pMem - membuf); /* calculate address */
                                                   // address
                break;

            case UBYTE:                 //  unsigned byte for int/in/out
                decodeData.pMem++;
                break;

            case IB:                    /* operand is immediate byte */
                if ((opcode & ~1) == 0xd4) {  // postop for AAD/AAM is 0x0a
                    if (*(decodeData.pMem)++ != 0x0a) // test post-opcode byte
                        0;
                    break;
                    }
                olen = 1;               /* set operand length */
                goto DoImmed;

            case IW:                    /* operand is immediate word */
                olen = 2;               /* set operand length */

            case IV:                    /* operand is word or dword */
DoImmed:
                decodeData.pMem += olen;
                break;

            case OFFS:                  /* operand is offset */
                decodeData.EAsize[0] = (opcode & 1) ? olen : 1;

                if (segOvr)             /* in case of segment override */
                   0;

                decodeData.pMem += alen;
                break;

            case GROUP:                 /* operand is of group 1,2,4,6 or 8 */
                                        /* output opcode symbol */
				action++;
                break;

            case GROUPT:                /* operand is of group 3,5 or 7 */
                indx = *action;         /* get indx into group from action */
                goto doGroupT;

            case EGROUPT:               /* x87 ESC (D8-DF) group index */
                indx = BIT20(opcode) * 2; /* get group index from opcode */
                if (decodeData.mod == 3) {         /* some operand variations exists */
                                        /* for x87 and mod == 3 */
                    ++indx;             /* take the next group table entry */
                    if (indx == 3) {    /* for x87 ESC==D9 and mod==3 */
                        if (decodeData.ttt > 3) {  /* for those D9 instructions */
                            indx = 12 + decodeData.ttt; /* offset index to table by 12 */
                            decodeData.ttt = decodeData.rm;   /* set secondary index to rm */
                            }
                        }
                    else if (indx == 7) { /* for x87 ESC==DB and mod==3 */
                        if (decodeData.ttt == 4) {   /* if ttt==4 */
                            decodeData.ttt = decodeData.rm;     /* set secondary group table index */
                        } else if ((decodeData.ttt<4)||(decodeData.ttt>4 && decodeData.ttt<7)) {
                            // adjust for pentium pro opcodes
                            indx = 24;   /* offset index to table by 24*/
                        }
                    }
                }
doGroupT:
                /* handle group with different types of operands */
                action = actiontbl + groupt[indx][decodeData.ttt].opr;
                                                        /* get new action */
                break;
            //
            // The secondary opcode table has been compressed in the
            // original design. Hence while disassembling the 0F sequence,
            // opcode needs to be displaced by an appropriate amount depending
            // on the number of "filled" entries in the secondary table.
            // These displacements are used throughout the code.
            //

            case OPC0F:              /* secondary opcode table (opcode 0F) */
                opcode = *(decodeData.pMem)++;    /* get real opcode */
                decodeData.fMovX  = (BOOL)(opcode == 0xBF || opcode == 0xB7);
                if (opcode < 12) /* for the first 12 opcodes */
                    opcode += SECTAB_OFFSET_1; // point to begin of sec op tab
                else if (opcode > 0x1f && opcode < 0x27)
                    opcode += SECTAB_OFFSET_2; // adjust for undefined opcodes
                else if (opcode > 0x2f && opcode < 0x34)
                    opcode += SECTAB_OFFSET_3; // adjust for undefined opcodes
                else if (opcode > 0x3f && opcode < 0x50)
                    opcode += SECTAB_OFFSET_4; // adjust for undefined opcodes
                else if (opcode > 0x5f && opcode < 0xff)
                    opcode += SECTAB_OFFSET_5; // adjust for undefined opcodes
                else
                    opcode = SECTAB_OFFSET_UNDEF; // all non-existing opcodes
                goto getNxtByte1;

            case ADR_OVR:               /* address override */
                mode_32 = !G_mode_32;   /* override addressing mode */
                alen = (mode_32 + 1) << 1; /* toggle address length */
                goto getNxtByte;

            case OPR_OVR:               /* operand size override */
                opsize_32 = !G_mode_32; /* override operand size */
                olen = (opsize_32 + 1) << 1; /* toggle operand length */
                goto getNxtByte;

            case SEG_OVR:               /* handle segment override */
                segOvr = opcode;        /* save segment override opcode */
                pchOpcodeBuf = OpcodeBuffer;  // restart the opcode string
                goto getNxtByte;

            case REP:                   /* handle rep/lock prefixes */
                if (pchRepPrefixBuf != RepPrefixBuffer)
                    *pchRepPrefixBuf++ = ' ';
                pchOpcodeBuf = OpcodeBuffer;
getNxtByte:
                opcode = *(decodeData.pMem)++;        /* next byte is opcode */
getNxtByte1:
                action = actiontbl + distbl[opcode].opr;

            default:                    /* opcode has no operand */
                break;
            }
        switch (action2) {              /* secondary action */
            case MRM:                   /* generate modrm for later use */
                if (!mrm) {             /* ignore if it has been generated */
					DIdoModrm(&pchModrmBuf, segOvr, &decodeData);
                    mrm = TRUE;         /* remember its generation */
                    }
                break;

            case COM:                   /* insert a comma after operand */
                break;

            case END:                   /* end of instruction */
                end = TRUE;
                break;
            }
 } while (!end);                        /* loop til end of instruction */

  instlen = (decodeData.pMem) - membuf;

  return instlen;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\cap.c ===
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ctype.h>
#include <stdio.h>
#include <windows.h>
#include "view.h"
#include "thread.h"
#include "dump.h"
#include "memory.h"
#include "cap.h"

BOOL
AddToCap(PCAPFILTER pCapFilter,
         DWORD dwAddress)
{
    DWORD dwIndexCounter;
    DWORD dwCounter;
    PDWORD pdwArray;
    DWORD dwEndRun;
    DWORD dwRunLength = 0;
    DWORD dwRun1Start;
    DWORD dwRun2Start;
    DWORD dwRepeatIndex = 0;
    DWORD dwBeginIndex;

    //
    // Take a pointer to the array
    //
    pdwArray = pCapFilter->dwArray;

    //
    // Increment cursor
    //
    if (0 == pCapFilter->dwCursor) {
       pdwArray[pCapFilter->dwCursor] = dwAddress;
       pCapFilter->dwCursor++;

       return TRUE;
    }

    if (pCapFilter->dwCursor >= CAP_BUFFER_SIZE) {
       //
       // Ran out of room in the buffer, slide everyone down
       //
       MoveMemory((PVOID)pdwArray, (PVOID)(pdwArray + 1), (CAP_BUFFER_SIZE - 1) * sizeof(DWORD));

       pCapFilter->dwCursor = CAP_BUFFER_SIZE - 1;
    }

    //
    // Add address to array
    //
    pdwArray[pCapFilter->dwCursor] = dwAddress;

    //
    // If we're at the initial level, scan for a repeat
    //
    if (0 == pCapFilter->dwIterationLevel) {
       //
       // Do a reverse search looking for patterns up to MAX_CAP_LEVEL
       //
       dwEndRun = pCapFilter->dwCursor - 1;

       if (dwEndRun < MAX_CAP_LEVEL) {
	  dwBeginIndex = 0;
       }
       else {
	  dwBeginIndex = (MAX_CAP_LEVEL - 1);
       }

       for (dwIndexCounter = dwEndRun; dwIndexCounter >= dwBeginIndex; dwIndexCounter--) {
           //
           // Check for overflow
           //
           if (dwIndexCounter > CAP_BUFFER_SIZE) {
              break;
           }

           if (pdwArray[dwIndexCounter] == dwAddress) {
              //
              // Verify the run exists
              //
              dwRun1Start = pCapFilter->dwCursor;
              dwRun2Start = dwIndexCounter;

              //
              // Find the distance for the start of this potential run
              //
              dwRunLength = pCapFilter->dwCursor - dwIndexCounter;

              //
              // If run length falls off the beginning of the array we can stop there
              //
              if ((dwRun2Start - dwRunLength + 1) > CAP_BUFFER_SIZE) {
                 //
                 // We overflowed which means we're done
                 //
                 dwRunLength = 0;

		 break;
              }

	      if (dwRunLength >= 1) {
                 //
                 // Compare it
                 //
                 for (dwCounter = dwRunLength; dwCounter > 0; dwCounter--) {
                     if (pdwArray[dwRun1Start-dwCounter+1] != pdwArray[dwRun2Start-dwCounter+1]) {
                        dwRunLength = 0;
                        break;
                     }
		 }

                 //
                 // Set the run length
                 //
		 if (0 != dwRunLength) {
                    pCapFilter->dwRunLength = dwRunLength;
		 }
             }
          }
       }

       dwRunLength = pCapFilter->dwRunLength;

       //
       // Set the run length if we found one, and shift the entire run to the beginning of the buffer
       //
       if (dwRunLength != 0) {
          //
          // Raise the iteration level
          //
          pCapFilter->dwIterationLevel++;

	  //
	  // Set the lock level
	  //
	  pCapFilter->dwIterationLock = 1 + ((pCapFilter->dwIterationLevel - 1) / pCapFilter->dwRunLength);
       }
    }
    else {
       //
       // Look for repeats and increment the iteration level
       //
       dwRunLength = pCapFilter->dwRunLength;
       dwRun1Start = pCapFilter->dwCursor;
       dwRun2Start = dwRun1Start - dwRunLength;

       //
       // Compare it
       //
       for (dwCounter = dwRunLength; dwCounter > 0; dwCounter--) {
           if (pdwArray[dwRun1Start-dwCounter+1] != pdwArray[dwRun2Start-dwCounter+1]) {
              dwRunLength = 0;

              break;
           }
       }

       if (dwRunLength != 0) {
          //
          // Raise the iteration level
          //
          pCapFilter->dwIterationLevel++;
	  pCapFilter->dwIterationLock = 1 + ((pCapFilter->dwIterationLevel - 1) / pCapFilter->dwRunLength);
       }
       else {
	  pCapFilter->dwIterationLock = 0;
          pCapFilter->dwIterationLevel = 0;
          pCapFilter->dwRunLength = 0;
       }
    }

    //
    // Move the cursor to the next position
    //
    pCapFilter->dwCursor++;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\cap.h ===
#ifndef _CAP_H_
#define _CAP_H_

//
// Constant declarations
//
#define MAX_CAP_LEVEL 0x10
#define MAX_CAP_ITERATION 0x03
#define CAP_BUFFER_SIZE MAX_CAP_LEVEL * 2

//
// Structure definitions
//
typedef struct _CAPFILTER
{
    DWORD dwIterationLock;
    DWORD dwIterationLevel;
    DWORD dwRunLength;
    DWORD dwCursor;
    DWORD dwArray[CAP_BUFFER_SIZE];
} CAPFILTER, *PCAPFILTER; 

//
// Function definitions
//
BOOL
AddToCap(PCAPFILTER pCapFilter,
         DWORD dwAddress);

#endif //_CAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\clevel.c ===
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ctype.h>
#include <stdio.h>
#include <windows.h>
#include "view.h"
#include "thread.h"
#include "dump.h"
#include "memory.h"
#include "clevel.h"

FIXUPRETURN g_fnFixupReturn[1];
DWORD g_dwCallArray[2];

BOOL
PushCaller(PVOID ptfInfo,
           PVOID pEsp)
{
    PTHREADFAULT ptFault = (PTHREADFAULT)ptfInfo;
    PCALLRETSTUB pCallStub = 0;
    PCALLERINFO pCallerTemp = 0;

    //
    // Allocate a unique return stub for this call
    //
    pCallStub = AllocateReturnStub(ptfInfo);
    if (0 == pCallStub) {
       return FALSE;
    }

    //
    // Allocate caller data for the restore
    //
    pCallerTemp = AllocMem(sizeof(CALLERINFO));
    if (0 == pCallerTemp) {
       return FALSE;
    }

    pCallerTemp->dwIdentifier = ptFault->dwCallMarker;
    pCallerTemp->dwCallLevel = ptFault->dwCallLevel;
    pCallerTemp->pReturn = (PVOID)(*(DWORD *)pEsp);
    pCallerTemp->pCallRetStub = pCallStub;
    pCallerTemp->pNextChain = 0;

    //
    // Increment the call count
    //
    ptFault->dwCallLevel++;

    //
    // Replace stack return value with the custom return stub
    //
    *(DWORD *)pEsp = (DWORD)pCallStub;

    //
    // Finally, chain up the return info to the rest of them
    //
    if (ptFault->pCallStackList) {
       pCallerTemp->pNextChain = ptFault->pCallStackList;
       ptFault->pCallStackList = pCallerTemp;
    }
    else {
       ptFault->pCallStackList = pCallerTemp;
    }

    return TRUE;
}

PCALLRETSTUB
AllocateReturnStub(PVOID ptfInfo)
{
    PCALLRETSTUB pRetStub = 0;
    PTHREADFAULT ptFault = (PTHREADFAULT)ptfInfo;

    pRetStub = AllocMem(sizeof(CALLRETSTUB));
    if (0 == pRetStub) {
       return 0;
    }

    //
    // Increment the return marker
    //
    ptFault->dwCallMarker++;

    //
    // Initialize the stub asm
    //
    pRetStub->PUSHDWORD[0] = 0x68;             //push xxxxxxxx (68 dword)
    *(DWORD *)(&(pRetStub->PUSHDWORD[1])) = ptFault->dwCallMarker;
    pRetStub->JMPDWORD[0] = 0xff;              //jmp dword ptr [xxxxxxxx] (ff 25 dword address)
    pRetStub->JMPDWORD[1] = 0x25;
    *(DWORD *)(&(pRetStub->JMPDWORD[2])) = (DWORD)&(g_dwCallArray[1]);

    return pRetStub;
}

PVOID
PopCaller(DWORD dwIdentifier)
{
    PTHREADFAULT pThreadFault = 0;
    PCALLERINFO pCallerTemp;
    PCALLERINFO pCallerPrev = 0;
    PVOID pReturn = 0;

    pThreadFault = GetProfilerThreadData();

    //
    // Find the entry in the caller list
    //
    pCallerTemp = (PCALLERINFO)pThreadFault->pCallStackList;
    while(pCallerTemp) {
        if (pCallerTemp->dwIdentifier == dwIdentifier) {
           break;
        }

        pCallerPrev = pCallerTemp;
        pCallerTemp = pCallerTemp->pNextChain;
    }

    //
    // Yank the entry from the list
    //
    if (0 == pCallerPrev) {
       pThreadFault->pCallStackList = pCallerTemp->pNextChain;
    }
    else {
       pCallerPrev->pNextChain = pCallerTemp->pNextChain;
    }

    //
    // Restore call level for the thread
    //
    pReturn = pCallerTemp->pReturn;
    pThreadFault->dwCallLevel = pCallerTemp->dwCallLevel;

    //
    // Cleanup the allocations
    //
    FreeMem(pCallerTemp->pCallRetStub);
    FreeMem(pCallerTemp);

    return pReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\disasm.h ===
#ifndef _DISASM_H_
#define _DISASM_H_

//
// Constant declarations
//

//
// Structure definitions
//

//
// Function definitions
//
extern
DWORD 
GetInstructionLengthFromAddress(PVOID paddr);

#endif //_DISASM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\dump.h ===
#ifndef _DUMP_H_
#define _DUMP_H_

//
// Constant declarations
//
#define DUMP_BUFFER_SIZE 200 * 1024
#define DUMP_LOG_NAME "Profiler.dump"

typedef enum _DUMPTYPES
{
    ThreadStartId = 0,
    ExeFlowId,
    DllBaseInfoId,
    MapInfoId,
    ErrorInfoId,
} DUMPTYPES;

//
// Structure definitions
//
typedef struct _THREADSTART
{
    DUMPTYPES dwType;
    DWORD dwThreadId;
    DWORD dwStartAddress;
} THREADSTART, *PTHREADSTART;

typedef struct _EXEFLOW
{
    DUMPTYPES dwType;
    DWORD dwThreadId;
    DWORD dwAddress;
    DWORD dwCallLevel;
} EXEFLOW, *PEXEFLOW;

typedef struct _DLLBASEINFO
{
    DUMPTYPES dwType;
    DWORD dwBase;
    DWORD dwLength;
    CHAR  szDLLName[32];
} DLLBASEINFO, *PDLLBASEINFO;

typedef struct _MAPINFO
{
    DUMPTYPES dwType;
    DWORD dwAddress;
    DWORD dwMaxMapLength;
} MAPINFO, *PMAPINFO;

typedef struct _ERRORINFO
{
    DWORD dwType;
    CHAR szMessage[MAX_PATH];
} ERRORINFO, *PERRORINFO;

//
// Function definitions
//
BOOL
InitializeDumpData(VOID);

BOOL
AddToDump(PBYTE pBuffer,
          DWORD dwLength,
          BOOL bFlushImmediate);

BOOL
FlushBuffer(VOID);

VOID
FlushForTermination(VOID);

BOOL
WriteThreadStart(DWORD dwThreadId,
                 DWORD dwStartAddress);

BOOL
WriteExeFlow(DWORD dwThreadId,
             DWORD dwAddress,
             DWORD dwCallLevel);

BOOL
WriteDllInfo(CHAR *szDLL,
             DWORD dwBaseAddress,
             DWORD dwLength);

BOOL
WriteMapInfo(DWORD dwAddress,
             DWORD dwMaxMapLength);

BOOL
WriteError(CHAR *szMessage);

#endif //_DUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\except.h ===
#ifndef _EXCEPT_H_
#define _EXCEPT_H_

//
// Constant declarations
//
typedef PVOID     (*pfnRtlAddVectoredExceptionHandler)(ULONG FirstHandler, 
                                                       PVOID VectoredHandler);

typedef ULONG     (*pfnRtlRemoveVectoredExceptionHandler)(PVOID VectoredHandlerHandle);

typedef VOID      (*pfnExContinue)(PCONTEXT pContext);

#define SET_CONTEXT() {_asm int 3 \
                       _asm int 3 \
                       _asm ret \
                       _asm ret \
                       _asm ret }

//
// Structure definitions
//

//
// Function definitions
//
LONG 
ExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);

BOOL
HookUnchainableExceptionFilter(VOID);

VOID
Win9XExceptionDispatcher(struct _EXCEPTION_POINTERS *ExceptionInfo);

#endif //_EXCEPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\clevel.h ===
#ifndef _CLEVEL_H_
#define _CLEVEL_H_

//
// Constant declarations
//

//
// Structure definitions
//
typedef struct _CALLRETSTUB
{
    CHAR PUSHDWORD[5];          //push xxxxxxxx (68 dword)
    CHAR JMPDWORD[6];           //jmp dword ptr [xxxxxxxx] (ff 25 dword address)
} CALLRETSTUB, *PCALLRETSTUB;

typedef struct _FIXUPRETURN
{
   BYTE  PUSHAD;                //pushad   (60)
   BYTE  PUSHFD;                //pushfd   (9c)
   BYTE  PUSHDWORDESPPLUS24[4]; //push dword ptr [esp+24] (ff 74 24 24)
   BYTE  CALLROUTINE[6];        //call [address] (ff15 dword address)
   BYTE  MOVESPPLUS24EAX[4];    //mov [esp+0x24],eax (89 44 24 24)
   BYTE  POPFD;                 //popfd   (9d)
   BYTE  POPAD;                 //popad (61)
   BYTE  RET;                   //ret (c3)
} FIXUPRETURN, *PFIXUPRETURN;

typedef struct _CALLERINFO
{
   DWORD dwIdentifier;
   DWORD dwCallLevel;
   PVOID pCallRetStub;
   PVOID pReturn;
   struct _CALLERINFO *pNextChain;
} CALLERINFO, *PCALLERINFO;

//
// Function definitions
//
BOOL
PushCaller(PVOID ptfInfo,
           PVOID pEsp); 

PVOID
PopCaller(DWORD dwIdentifier);

PCALLRETSTUB
AllocateReturnStub(PVOID ptfInfo);

#endif //_CLEVEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\except.c ===
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ctype.h>
#include <stdio.h>
#include <windows.h>
#include "profiler.h"
#include "view.h"
#include "thread.h"
#include "dump.h"
#include "except.h"
#include "memory.h"
#include "clevel.h"
#include "cap.h"

extern BOOL g_bIsWin9X;
CAPFILTER g_execFilter;
pfnExContinue g_pfnExContinue = 0;

BOOL
HookUnchainableExceptionFilter(VOID)
{
    BOOL bResult;
    pfnRtlAddVectoredExceptionHandler pfnAddExceptionHandler = 0;
    PVOID pvResult;
    HANDLE hTemp;
    DWORD dwExceptionHandler;
    DWORD dwResultSize;
    PVOID pAlternateHeap;

    //
    // If we're NT - try for the unchainable filter in ntdll
    //
    if (FALSE == g_bIsWin9X) {
       pfnAddExceptionHandler = (pfnRtlAddVectoredExceptionHandler)GetProcAddress(GetModuleHandleA("NTDLL.DLL"), 
                                                                                  "RtlAddVectoredExceptionHandler");
       if (0 == pfnAddExceptionHandler) {
          return FALSE;
       }

       pvResult = (*pfnAddExceptionHandler)(1, 
                                            (PVOID)ExceptionFilter);
       if (0 == pvResult) {
          return FALSE;
       }
    }
    else {
       //
       // Set up exception handler
       //
       hTemp = CreateFileA(NAME_OF_EXCEPTION_VXD,
                           0,
                           0,
                           0,
                           0,
                           FILE_FLAG_DELETE_ON_CLOSE,
                           0);
       if (INVALID_HANDLE_VALUE == hTemp) {
          return FALSE;
       }
 
       _asm mov dwExceptionHandler, offset Win9XExceptionDispatcher

       bResult = DeviceIoControl(hTemp,
                                 INSTALL_RING_3_HANDLER,
                                 &dwExceptionHandler,
                                 sizeof(DWORD),
                                 0,
                                 0,
                                 &dwResultSize,
                                 0);
       if (FALSE == bResult) {
          return FALSE;
       }     

       //
       // Get function pointer for ExContinue
       //
       g_pfnExContinue = (pfnExContinue)0xbff76702;
    }

    return TRUE;
}

LONG 
ExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
    DWORD dwThreadId;
    DWORD dwCounter;
    BOOL bResult;
    LONG lRet;
    PCONTEXT pContext = ExceptionInfo->ContextRecord;
    PEXCEPTION_RECORD pRecord = ExceptionInfo->ExceptionRecord;
    PVIEWCHAIN pView = 0;
    PTHREADFAULT pThreadFault = 0;
    CHAR szBuffer[MAX_PATH];

    //
    // Retrieve thread data
    //
    dwThreadId = GetCurrentThreadId();

    pThreadFault = GetProfilerThreadData();
    if (0 == pThreadFault) {
       //
       // NT only code path
       //
       pThreadFault = AllocateProfilerThreadData();
       if (0 == pThreadFault) {
          //
          // This wasn't suppose to happen
          //
          ExitProcess(-1);
       }
    }
    
    //
    // Rehook the view
    //
    if (STATUS_SINGLE_STEP == pRecord->ExceptionCode) {
       //
       // Trace is used to map into call or jumps types we can't forward map
       //
       if (pThreadFault->dwPrevBP) {
          //
          // If we're a call - patch the return address so we can maintain call level
          //
          if (pThreadFault->prevBPType == Call) {
             //
             // Push the return level hook
             //
             bResult = PushCaller((PVOID)pThreadFault,
                                  (PVOID)pContext->Esp);
             if (FALSE == bResult) {
                //
                // Ooops
                //
                ExitProcess(-1);
             }
          }

          RestoreAddressFromView(pThreadFault->dwPrevBP,
                                 FALSE);

          if ((pThreadFault->prevBPType == Call) ||
              (pThreadFault->prevBPType == Jump)) {
             //
             // Profile this routine if it hasn't been mapped
             //
             pView = FindView((DWORD)pRecord->ExceptionAddress);
             if (0 == pView) {
                //
                // Add this address as a mapping breakpoint
                //
                pView = AddViewToMonitor((DWORD)pRecord->ExceptionAddress,
                                         Map);
                if (pView) {
                   bResult = MapCode(pView);
                   if (FALSE == bResult) {
                      //
                      // This is fatal
                      //
                      ExitProcess(-1);
                   }
                }
             }
          }

          pThreadFault->dwPrevBP = 0;
          pThreadFault->prevBPType = None;

          return EXCEPTION_CONTINUE_EXECUTION;
       }

       //
       // Trace exception wasn't generated by us
       //
       sprintf(szBuffer, "Unhandled Trace %08X\r\n", (DWORD)pRecord->ExceptionAddress);
       WriteError(szBuffer);

       return EXCEPTION_CONTINUE_SEARCH;
    }
 
    //
    // Restore the view
    //
    if (STATUS_BREAKPOINT == pRecord->ExceptionCode) {
       //
       // Restore any BP that hasn't been restored
       //
       if (pThreadFault->dwPrevBP) {
          RestoreAddressFromView(pThreadFault->dwPrevBP,
                                 FALSE);

          if ((DWORD)pRecord->ExceptionAddress == pThreadFault->dwPrevBP) {
             pThreadFault->dwPrevBP = 0;
             pThreadFault->prevBPType = None;

             return EXCEPTION_CONTINUE_EXECUTION;
          }
       }

/*
       //
       // Add address to the execution filter
       //
       bResult = AddToCap(&g_execFilter,
                          (DWORD)pRecord->ExceptionAddress);
       if (FALSE == bResult) {
          //
          // This is fatal
          //
          ExitProcess(-1);
       }

       //
       // If we've hit iteration - disable this and the previous breakpoints
       //
       if (0 != g_execFilter.dwIterationLock) {
          for (dwCounter = 0; dwCounter < g_execFilter.dwRunLength; dwCounter++) {
              //
              // Replace the munged code
              //
              pView = RestoreAddressFromView(g_execFilter.dwArray[g_execFilter.dwCursor - dwCounter - 1],
                                             TRUE);

              //
              // Add runtime event to log
              //
              sprintf(szBuffer, "CAP'ed %08X\r\n", g_execFilter.dwArray[g_execFilter.dwCursor - dwCounter - 1]);
              AddToDump(szBuffer, 
                        strlen(szBuffer), 
                        FALSE);
          }

          //
          // Clear breakpoint monitor flags
          //
          pThreadFault->dwPrevBP = 0;
          pThreadFault->prevBPType = None;

          return EXCEPTION_CONTINUE_EXECUTION;
       }
*/

       //
       // Replace the munged code
       //
       pView = RestoreAddressFromView((DWORD)pRecord->ExceptionAddress,
                                      TRUE);
       if (pView) {
          //
          // See if we've mapped this address range in yet
          //
          if (FALSE == pView->bMapped) {
             //
             // See if this address is already mapped
             //
             bResult = MapCode(pView);
             if (FALSE == bResult) {
                //
                // This is fatal
                //
                ExitProcess(-1);
             }
          }

          //
          // Set the trace so the last bp can be rehooked (unless we just executed a map bp)
          //          
          pContext->EFlags |= 0x00000100;
          pThreadFault->dwPrevBP = (DWORD)pRecord->ExceptionAddress;
          pThreadFault->prevBPType = pView->bpType;

          //
          // Add runtime event to log
          //
          if (pView->bpType != ThreadStart) {
              WriteExeFlow(dwThreadId,
                           (DWORD)pRecord->ExceptionAddress,
                           pThreadFault->dwCallLevel);
          }
          else {
              WriteThreadStart(dwThreadId,
                               (DWORD)pRecord->ExceptionAddress);
          }

          return EXCEPTION_CONTINUE_EXECUTION;
       }

       //
       // BP exception wasn't generated by us
       //
       sprintf(szBuffer, "Unhandled BP %08X\r\n", (DWORD)pRecord->ExceptionAddress);
       WriteError(szBuffer);

       return EXCEPTION_CONTINUE_SEARCH;
    }

    //
    // Continue searching the chain
    //

    return EXCEPTION_CONTINUE_SEARCH;
}

VOID
Win9XExceptionDispatcher(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
    LONG lResult;

    //
    // Call exception handler
    //
    lResult = ExceptionFilter(ExceptionInfo);
    if (lResult != EXCEPTION_CONTINUE_EXECUTION) {
       //
       // Fault not handled - page fault will terminate app
       //
       return;
    }

    //
    // Set the context results
    //
    SET_CONTEXT();

    //
    // This code path is never executed (unless the above call fails)
    //
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\dump.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "view.h"
#include "dump.h"
#include "memory.h"

static CRITICAL_SECTION tCritSec;
static PBYTE pDumpBuffer;
static DWORD dwDumpBufferSize;
static HANDLE hDump = INVALID_HANDLE_VALUE;

BOOL
InitializeDumpData(VOID)
{
    DWORD dwCounter;
    DWORD dwResult;

    InitializeCriticalSection(&tCritSec);

    //
    // Allocate memory for the logging
    //
    pDumpBuffer = AllocMem(DUMP_BUFFER_SIZE);
    if (0 == pDumpBuffer) {
       return FALSE;
    }

    dwDumpBufferSize = 0;

    //
    // Get our file ready for dumping
    //
    hDump = CreateFileA(DUMP_LOG_NAME,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        0,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        0);
    if (INVALID_HANDLE_VALUE == hDump) {
       return FALSE;
    }

    return TRUE;
}

BOOL
AddToDump(PBYTE pBuffer,
          DWORD dwLength,
          BOOL bFlushImmediate)
{
    BOOL bResult;

    EnterCriticalSection(&tCritSec);

    //
    // See if our write would cause overflow
    //
    if (TRUE == bFlushImmediate ||
        (dwDumpBufferSize + dwLength) >= DUMP_BUFFER_SIZE) {

       //
       // If we're doing an immediate flush, do the memory copy and buffer update
       //
       if (TRUE == bFlushImmediate) {
          MoveMemory((PVOID)(pDumpBuffer + dwDumpBufferSize), pBuffer, dwLength);    

          dwDumpBufferSize += dwLength;
       }

       //
       // Do the flush
       //
       bResult = FlushBuffer();
       if (FALSE == bResult) {
          return FALSE;
       }

       dwDumpBufferSize = 0;
    }

    if (FALSE == bFlushImmediate) {
       MoveMemory((PVOID)(pDumpBuffer + dwDumpBufferSize), pBuffer, dwLength);    

       dwDumpBufferSize += dwLength;
    }

    LeaveCriticalSection(&tCritSec);

    return TRUE;
}          

VOID
FlushForTermination(VOID)
{
    DWORD dwCounter;

    EnterCriticalSection(&tCritSec);

    //
    // Flush the buffer
    //
    FlushBuffer();

    //
    // Flush the buffer
    //
    FlushFileBuffers(hDump);

    //
    // Close the file dump handle
    //
    if (INVALID_HANDLE_VALUE != hDump) {
       CloseHandle(hDump);
       hDump = INVALID_HANDLE_VALUE;
    }

    LeaveCriticalSection(&tCritSec);
}

BOOL
FlushBuffer(VOID)
{
    BOOL bResult;
    DWORD dwBytesWritten;

    bResult = WriteFile(hDump,
                        pDumpBuffer,
                        dwDumpBufferSize,
                        &dwBytesWritten,
                        0);
    if (FALSE == bResult) {
       return FALSE;
    }

/*
    bResult = FlushFileBuffers(hDump);
    if (FALSE == bResult) {
       return FALSE;
    }
*/

    return TRUE;
}
 
BOOL
WriteThreadStart(DWORD dwThreadId,
                 DWORD dwStartAddress)
{
    THREADSTART threadStart;
    BOOL bResult = FALSE;

    threadStart.dwType = ThreadStartId;
    threadStart.dwThreadId = dwThreadId;
    threadStart.dwStartAddress = dwStartAddress;

    bResult = AddToDump((PVOID)&threadStart,
                        sizeof(THREADSTART),
                        FALSE);

    return bResult;    
}

BOOL
WriteExeFlow(DWORD dwThreadId,
             DWORD dwAddress,
             DWORD dwCallLevel)
{
    EXEFLOW exeFlow;
    BOOL bResult = FALSE;

    exeFlow.dwType = ExeFlowId;
    exeFlow.dwThreadId = dwThreadId;
    exeFlow.dwAddress = dwAddress;
    exeFlow.dwCallLevel = dwCallLevel;

    bResult = AddToDump((PVOID)&exeFlow,
                        sizeof(EXEFLOW),
                        FALSE);

    return bResult;    
}

BOOL
WriteDllInfo(CHAR *szDLL,
             DWORD dwBaseAddress,
             DWORD dwLength)
{
    DLLBASEINFO dllBaseInfo;
    BOOL bResult = FALSE;
    CHAR szFile[_MAX_FNAME];


    //
    // Trim off any directory information
    //
    _splitpath(szDLL, 0, 0, szFile, 0);

    strcpy(dllBaseInfo.szDLLName, szFile);
    dllBaseInfo.dwType = DllBaseInfoId;
    dllBaseInfo.dwBase = dwBaseAddress;
    dllBaseInfo.dwLength = dwLength;

    bResult = AddToDump((PVOID)&dllBaseInfo,
                        sizeof(DLLBASEINFO),
                        FALSE);

    return bResult;    
}

BOOL
WriteMapInfo(DWORD dwAddress,
             DWORD dwMaxMapLength)
{
    MAPINFO mapInfo;
    BOOL bResult = FALSE;

    mapInfo.dwType = MapInfoId;
    mapInfo.dwAddress = dwAddress;
    mapInfo.dwMaxMapLength = dwMaxMapLength;

    bResult = AddToDump((PVOID)&mapInfo,
                        sizeof(MAPINFO),
                        FALSE);

    return bResult;    
}

BOOL
WriteError(CHAR *szMessage)
{
    ERRORINFO errorInfo;
    BOOL bResult = FALSE;

    errorInfo.dwType = ErrorInfoId;
    strcpy(errorInfo.szMessage, szMessage);

    bResult = AddToDump((PVOID)&errorInfo,
                        sizeof(ERRORINFO),
                        TRUE);

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\filter.h ===
#ifndef _FILTER_H_
#define _FILTER_H_

//
// Constant declarations
//

//
// Structure definitions
//
typedef struct _MODULEFILTER
{
   DWORD dwModuleStart;      // Starting address of the module to filter
   DWORD dwModuleEnd;        // Ending address of the module to filter  
   CHAR  szModuleName[64];
   struct _MODULEFILTER *pNextFilter;    // Used to iterate the module filter normally
} MODULEFILTER, *PMODULEFILTER;

//
// Function definitions
//
BOOL
InitializeFilterList(VOID);

BOOL
AddModuleToFilterList(CHAR *pszModuleName, 
                      DWORD dwStartAddress, 
                      DWORD dwEndAddress,
                      BOOL bLateBound);

BOOL
IsAddressFiltered(DWORD dwAddress);

VOID
RefreshFilterList(VOID);

#endif //_FILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\filter.c ===
#include <windows.h>
#include "view.h"
#include "except.h"
#include "thread.h"
#include "dump.h"
#include "memory.h"
#include "profiler.h"
#include "filter.h"

static CRITICAL_SECTION filterCritSec;
static PMODULEFILTER pFilterHead = 0;
static PMODULEFILTER pLBFilterHead = 0;
static char *pszModules[] = {"ntdll.dll",
                             "kernel32.dll",
                             "gdi32.dll",
                             "user32.dll",
                             "shell32.dll",
                             "shlwapi.dll",
                             "msvcrt.dll",
                             "msvcirt.dll",
                             "advapi32.dll",
                             "ddraw.dll",
                             "dsound.dll",
                             "ole32.dll",
                             "rpcrt4.dll",
                             "oleaut32.dll",
                             "winmm.dll",
                             "comctl32.dll",
                             "comdlg32.dll",
                             "riched20.dll",
                             "dinput.dll",
                             "wdmaud.drv",
                             NAME_OF_DLL_TO_INJECT};

BOOL
InitializeFilterList(VOID)
{
    HMODULE hTemp;
    PIMAGE_NT_HEADERS pHeaders;
    DWORD dwModStart;
    DWORD dwModEnd;
    DWORD dwCounter;
    DWORD dwCount;
    BOOL bResult;

    InitializeCriticalSection(&filterCritSec);

    dwCount = sizeof(pszModules) / sizeof(char *);

    for (dwCounter = 0; dwCounter < dwCount; dwCounter++) {
        //
        // Build the filter list
        //   
        hTemp = GetModuleHandleA(pszModules[dwCounter]);
    

        if (0 == hTemp) {
           bResult = AddModuleToFilterList(pszModules[dwCounter],
                                           0,
                                           0,
                                           TRUE);
           if (FALSE == bResult) {
              return FALSE;
           }
        }
        else {
           //
           // Dig out the PE information
           //
           pHeaders = ImageNtHeader2((PVOID)hTemp);

           dwModStart = (DWORD)hTemp;
           dwModEnd = dwModStart + pHeaders->OptionalHeader.SizeOfImage;

           bResult = AddModuleToFilterList(pszModules[dwCounter],
                                           dwModStart,
                                           dwModEnd,
                                           FALSE);
           if (FALSE == bResult) {
              return FALSE;
           }
        }
    }

    return TRUE;
}

BOOL
AddModuleToFilterList(CHAR *pszModuleName, 
                      DWORD dwStartAddress, 
                      DWORD dwEndAddress,
                      BOOL bLateBound)
{
    PMODULEFILTER pModuleFilter;

    //
    // Allocate entry
    //
    pModuleFilter = AllocMem(sizeof(MODULEFILTER));
    if (0 == pModuleFilter) {
       return FALSE;
    }

    if (pszModuleName) {
       strcpy(pModuleFilter->szModuleName, pszModuleName);
    }
    pModuleFilter->dwModuleStart = dwStartAddress;
    pModuleFilter->dwModuleEnd = dwEndAddress;
    pModuleFilter->pNextFilter = 0;

    EnterCriticalSection(&filterCritSec);

    if (FALSE == bLateBound) {
       //
       // Add DLL to the normal filter list
       //
       if (0 == pFilterHead) {
          pFilterHead = pModuleFilter;
       }
       else {
          pModuleFilter->pNextFilter = pFilterHead;
          pFilterHead = pModuleFilter;
       }
    }
    else {
       //
       // Add DLL to the late bound list
       //
       if (0 == pLBFilterHead) {
          pLBFilterHead = pModuleFilter;
       }
       else {
          pModuleFilter->pNextFilter = pLBFilterHead;
          pLBFilterHead = pModuleFilter;
       }
    }

    LeaveCriticalSection(&filterCritSec);

    return TRUE;
}

BOOL
IsAddressFiltered(DWORD dwAddress)
{
    PMODULEFILTER pModuleFilter;

    EnterCriticalSection(&filterCritSec);

    //
    // Walk both lists and see if we have an address to filter
    //
    pModuleFilter = pFilterHead;
    while (pModuleFilter) {
       if ((dwAddress >= pModuleFilter->dwModuleStart) && 
           (dwAddress <= pModuleFilter->dwModuleEnd)) {
          LeaveCriticalSection(&filterCritSec);

          return TRUE;
       }

       pModuleFilter = pModuleFilter->pNextFilter;
    }

    pModuleFilter = pLBFilterHead;
    while (pModuleFilter) {
       if ((dwAddress >= pModuleFilter->dwModuleStart) && 
           (dwAddress <= pModuleFilter->dwModuleEnd)) {
          LeaveCriticalSection(&filterCritSec);

          return TRUE;
       }

       pModuleFilter = pModuleFilter->pNextFilter;
    }

    LeaveCriticalSection(&filterCritSec);

    return FALSE;
}

VOID
RefreshFilterList(VOID)
{
    PMODULEFILTER pModuleFilter;
    HMODULE hTemp;
    PIMAGE_NT_HEADERS pHeaders;
    DWORD dwModStart;
    DWORD dwModEnd;

    //
    // Walk the LB list and refresh the start and end module addresses
    //

    EnterCriticalSection(&filterCritSec);

    pModuleFilter = pLBFilterHead;
    while (pModuleFilter) {
       //
       // Grab the module base address
       //
       hTemp = GetModuleHandleA(pModuleFilter->szModuleName);
       if (hTemp) {
          //
          // This module is loaded - do refresh
          //
          pHeaders = ImageNtHeader2((PVOID)hTemp);

          dwModStart = (DWORD)hTemp;
          dwModEnd = dwModStart + pHeaders->OptionalHeader.SizeOfImage;
 
          pModuleFilter->dwModuleStart = dwModStart;
          pModuleFilter->dwModuleEnd = dwModEnd;
       }
       
       pModuleFilter = pModuleFilter->pNextFilter;
    }

    LeaveCriticalSection(&filterCritSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\hooks.c ===
#include <windows.h>
#include <stdlib.h>
#include <psapi.h>
#include <tlhelp32.h>
#include <imagehlp.h>
#include <stdio.h>
#include "shimdb.h"
#include "shim2.h"
#include "hooks.h"
#include "dump.h"
#include "view.h"
#include "filter.h"
#include "except.h"
#include "profiler.h"

//
// API hook externs
//
extern BOOL g_bIsWin9X;
extern HANDLE g_hSnapshot;
extern HANDLE g_hValidationSnapshot;
extern LONG g_nShimDllCount;
extern LONG g_nHookedModuleCount;
extern HMODULE g_hHookedModules[MAX_MODULES];
extern HMODULE g_hShimDlls[MAX_MODULES];
extern PHOOKAPI g_rgpHookAPIs[MAX_MODULES];
extern LONG g_rgnHookAPICount[MAX_MODULES];

//
// Global array of hooked functions
//
HOOKAPI g_rgBaseHookAPIs[SHIM_BASE_APIHOOK_COUNT];

PVOID StubGetProcAddress(
    HMODULE hMod,
    char*   pszProc)
{
    char  szModName[MAX_PATH];
    char* pszShortName;
    UINT  ind;
    DWORD dwSize;
    PVOID pfn;
    LONG  i,j;
    PHOOKAPI pTopHookAPI = NULL;

    PFNGETPROCADDRESS pfnOld;
    pfnOld = g_rgBaseHookAPIs[ hookGetProcAddress ].pfnOld;

    if( pfn = (*pfnOld)(hMod, pszProc) )
    {    
        for (i = 0; i < g_nShimDllCount; i++)
        {            
            for (j = 0; j < g_rgnHookAPICount[i]; j++)
            {        
                if( g_rgpHookAPIs[i][j].pfnOld == pfn)
                {
                    pTopHookAPI = ConstructChain( pfn, &dwSize );
//maybe use the include exclude function here as well
                    return pTopHookAPI->pfnNew;
                }
            }
        }
    }
    
    return pfn;
} // StubGetProcAddress

HMODULE StubLoadLibraryA(
    LPCSTR pszModule)
{
    HMODULE hMod;
    PFNLOADLIBRARYA pfnOld;
    PIMAGE_NT_HEADERS pHeaders;

    pfnOld = g_rgBaseHookAPIs[ hookLoadLibraryA ].pfnOld;
    hMod = (*pfnOld)(pszModule);

    if (hMod != NULL) {
       RefreshFilterList();

       Shim2PatchNewModules();

       //
       // Rescan DLLs and add updated base information
       //
       WriteImportDLLTableInfo();
    }
    
    return hMod;
} // StubLoadLibraryA

HMODULE StubLoadLibraryW(
    WCHAR* pwszModule)
{
    HMODULE hMod;
    CHAR szModuleName[MAX_PATH];
    PIMAGE_NT_HEADERS pHeaders;
    INT nResult;

    PFNLOADLIBRARYW pfnOld;
    pfnOld = g_rgBaseHookAPIs[ hookLoadLibraryW ].pfnOld;

    hMod = (*pfnOld)(pwszModule);

    if (hMod != NULL) {
       RefreshFilterList();

       Shim2PatchNewModules();


       //
       // Rescan DLLs and add updated base information
       //
       WriteImportDLLTableInfo();
    }
    
    return hMod;
} // StubLoadLibraryW

HMODULE StubLoadLibraryExA(
    LPCSTR pszModule,
    HANDLE  hFile,
    DWORD  dwFlags)
{
    HMODULE hMod;
    PFNLOADLIBRARYEXA pfnOld;
    PIMAGE_NT_HEADERS pHeaders;

    pfnOld = g_rgBaseHookAPIs[ hookLoadLibraryExA ].pfnOld;
    hMod = (*pfnOld)(pszModule, hFile, dwFlags);

    if (hMod != NULL) {
       RefreshFilterList();

       Shim2PatchNewModules();

       //
       // Rescan DLLs and add updated base information
       //
       WriteImportDLLTableInfo();
    }
    
    return hMod;
} // StubLoadLibraryExA

HMODULE StubLoadLibraryExW(
    WCHAR* pwszModule,
    HANDLE  hFile,
    DWORD  dwFlags)
{
    HMODULE hMod;
    PIMAGE_NT_HEADERS pHeaders;
    INT nResult;

    PFNLOADLIBRARYEXW pfnOld;
    pfnOld = g_rgBaseHookAPIs[ hookLoadLibraryExW ].pfnOld;

    hMod = (*pfnOld)(pwszModule, hFile, dwFlags);

    if (hMod != NULL) {
       RefreshFilterList();

       Shim2PatchNewModules();

       //
       // Rescan DLLs and add updated base information
       //
       WriteImportDLLTableInfo();
    }
    
    return hMod;
} // StubLoadLibraryExW

BOOL StubFreeLibrary(
  HMODULE hLibModule   // handle to loaded library module
)
{
    BOOL bRet, bFound;
    PFNFREELIBRARY pfnOld;
    MODULEENTRY32 ModuleEntry32;
    long i, j;

    pfnOld = (PFNFREELIBRARY) g_rgBaseHookAPIs[ hookFreeLibrary ].pfnOld;

    bRet = (*pfnOld)(hLibModule);

    g_hSnapshot = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, 0 );

    ModuleEntry32.dwSize = sizeof( ModuleEntry32 );
    for( i = 0; i < g_nHookedModuleCount; i++ )
    {
        bFound = FALSE;
        bRet = Module32First( g_hSnapshot, &ModuleEntry32 );

        while( bRet )
        {
            if( g_hHookedModules[i] == ModuleEntry32.hModule )
            {
                bFound = TRUE;
                break;
            }
            bRet = Module32Next( g_hSnapshot, &ModuleEntry32 );
        }

        if( ! bFound )
        {
            // Take out of list
            for( j = i; j < g_nHookedModuleCount - 1; j++ )
                g_hHookedModules[j] = g_hHookedModules[j+1];

            g_hHookedModules[j] = NULL;
            g_nHookedModuleCount--;
        }
    }

    if( g_hSnapshot )
    {
        CloseHandle( g_hSnapshot );
        g_hSnapshot = NULL;
    }

    return bRet;
}

VOID StubExitProcess(UINT uExitCode)
{
    PFNEXITPROCESS pfnOld;

    //
    // Process is terminating - flush ourselves
    //
    FlushForTermination();

    pfnOld = g_rgBaseHookAPIs[ hookExitProcess ].pfnOld;
    (*pfnOld)(uExitCode);
} // StubExitProcess

HANDLE StubCreateThread(
  LPSECURITY_ATTRIBUTES lpThreadAttributes,
  DWORD dwStackSize,
  LPTHREAD_START_ROUTINE lpStartAddress,
  LPVOID lpParameter,
  DWORD dwCreationFlags,
  LPDWORD lpThreadId)
{
    PFNCREATETHREAD pfnOld;
    PVIEWCHAIN pvTemp;

    pfnOld = g_rgBaseHookAPIs[ hookCreateThread ].pfnOld;

    //
    // Add a mapping breakpoint for the thread entrypoint
    //
    pvTemp = AddViewToMonitor((DWORD)lpStartAddress,
                              ThreadStart);

    return (*pfnOld)(lpThreadAttributes,
                     dwStackSize,
                     lpStartAddress,
                     lpParameter,
                     dwCreationFlags,
                     lpThreadId);
} // StubCreateThread

VOID
InitializeBaseHooks(HINSTANCE hInstance)
{
        g_hSnapshot = NULL;
        g_hValidationSnapshot = NULL;

        g_nShimDllCount = 0;
        g_nHookedModuleCount = 0;
        ZeroMemory( g_hHookedModules, sizeof( g_hHookedModules ) );
        ZeroMemory( g_hShimDlls, sizeof( g_hShimDlls ) );
        ZeroMemory( g_rgpHookAPIs, sizeof( g_rgpHookAPIs ) );
        ZeroMemory( g_rgnHookAPICount, sizeof( g_rgnHookAPICount ) );
        ZeroMemory( g_rgBaseHookAPIs, sizeof( g_rgBaseHookAPIs ) );
    
        g_rgBaseHookAPIs[ hookGetProcAddress ].pszModule = "kernel32.dll";
        g_rgBaseHookAPIs[ hookGetProcAddress ].pszFunctionName = "GetProcAddress";
        g_rgBaseHookAPIs[ hookGetProcAddress ].pfnNew = (PVOID)StubGetProcAddress;
    
        g_rgBaseHookAPIs[ hookLoadLibraryA ].pszModule = "kernel32.dll";
        g_rgBaseHookAPIs[ hookLoadLibraryA ].pszFunctionName = "LoadLibraryA";
        g_rgBaseHookAPIs[ hookLoadLibraryA ].pfnNew = (PVOID)StubLoadLibraryA;
    
        g_rgBaseHookAPIs[ hookLoadLibraryW ].pszModule = "kernel32.dll";
        g_rgBaseHookAPIs[ hookLoadLibraryW ].pszFunctionName = "LoadLibraryW";
        g_rgBaseHookAPIs[ hookLoadLibraryW ].pfnNew = (PVOID)StubLoadLibraryW;
    
        g_rgBaseHookAPIs[ hookLoadLibraryExA ].pszModule = "kernel32.dll";
        g_rgBaseHookAPIs[ hookLoadLibraryExA ].pszFunctionName = "LoadLibraryExA";
        g_rgBaseHookAPIs[ hookLoadLibraryExA ].pfnNew = (PVOID)StubLoadLibraryExA;
    
        g_rgBaseHookAPIs[ hookLoadLibraryExW ].pszModule = "kernel32.dll";
        g_rgBaseHookAPIs[ hookLoadLibraryExW ].pszFunctionName = "LoadLibraryExW";
        g_rgBaseHookAPIs[ hookLoadLibraryExW ].pfnNew = (PVOID)StubLoadLibraryExW;

        g_rgBaseHookAPIs[ hookFreeLibrary ].pszModule = "kernel32.dll";
        g_rgBaseHookAPIs[ hookFreeLibrary ].pszFunctionName = "FreeLibrary";
        g_rgBaseHookAPIs[ hookFreeLibrary ].pfnNew = (PVOID)StubFreeLibrary;

        g_rgBaseHookAPIs[ hookExitProcess ].pszModule = "kernel32.dll";
        g_rgBaseHookAPIs[ hookExitProcess ].pszFunctionName = "ExitProcess";
        g_rgBaseHookAPIs[ hookExitProcess ].pfnNew = (PVOID)StubExitProcess;

        g_rgBaseHookAPIs[ hookCreateThread ].pszModule = "kernel32.dll";
        g_rgBaseHookAPIs[ hookCreateThread ].pszFunctionName = "CreateThread";
        g_rgBaseHookAPIs[ hookCreateThread ].pfnNew = (PVOID)StubCreateThread;

        AddHookAPIs(hInstance, g_rgBaseHookAPIs, SHIM_BASE_APIHOOK_COUNT, NULL);

        Shim2PatchNewModules();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\memory.h ===
#ifndef _MEMORY_H_
#define _MEMORY_H_

//
// Constant declarations
//
#define HEAP_DEFAULT_SIZE 100 * 1024 //20k of initial stack

//
// Structure definitions
//

//
// Function definitions
//
BOOL
InitializeHeap(VOID);

LPVOID
AllocMem(DWORD dwBytes);

BOOL
FreeMem(LPVOID lpMem);

#endif //_MEMORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\inject.c ===
#include <windows.h>
#include "inject.h"
#include "profiler.h"

BOOL g_bIsWin9X = FALSE;
CHAR g_fnFinalizeInjection[MAX_PATH];
HINSTANCE g_hProfileDLL = 0;

HANDLE
InjectDLL(DWORD dwEntryPoint,
          HANDLE hProcess,
          LPSTR  pszDLLName)
{
    CHAR szTempPath[MAX_PATH];
    HMODULE hKernel32;
    BOOL bResult = FALSE;
    INJECTIONSTUB injStub;
    DWORD dwLoadLibrary;
    DWORD dwGetProcAddress;
    DWORD dwBytesWritten;
    DWORD dwBytesRead;
    DWORD dwOldProtect;
    DWORD dwOldProtect2;
    PBYTE pSharedMem = 0;
    HANDLE hFileMap = 0;

    hKernel32 =  GetModuleHandle("KERNEL32.DLL");
    dwLoadLibrary = (DWORD)GetProcAddress(hKernel32,
                                          "LoadLibraryA");
    if (0 == dwLoadLibrary) {
       bResult = FALSE;
       goto handleerror;
    }

    dwGetProcAddress = (DWORD)GetProcAddress(hKernel32,
                                             "GetProcAddress");
    if (0 == dwGetProcAddress) {
       bResult = FALSE;
       goto handleerror;
    }

    //
    // Initialize the asm for the stub
    //
    injStub.pCode[0] = 0x90;  // int 3 or nop
    injStub.pCode[1] = 0x60;  // pushad
    injStub.pCode[2] = 0x8d;  // lea eax, [xxxxxxxx]
    injStub.pCode[3] = 0x05;
    *(DWORD *)(&(injStub.pCode[4])) = dwEntryPoint + (DWORD)&(injStub.szDLLName) - (DWORD)&injStub;
    injStub.pCode[8] = 0x50;  // push eax
    injStub.pCode[9] = 0xff;  // call dword ptr [xxxxxxxx] - LoadLibraryA
    injStub.pCode[10] = 0x15;
    *(DWORD *)(&(injStub.pCode[11])) = dwEntryPoint + 50;
    injStub.pCode[15] = 0x50; // push eax
    injStub.pCode[16] = 0x5b; // pop ebx
    injStub.pCode[17] = 0x8d; // lea eax, [xxxxxxxx]
    injStub.pCode[18] = 0x05;
    *(DWORD *)(&(injStub.pCode[19])) = dwEntryPoint + (DWORD)&(injStub.szEntryPoint) - (DWORD)&injStub;
    injStub.pCode[23] = 0x50; // push eax  // module base
    injStub.pCode[24] = 0x53; // push ebx  // function name
    injStub.pCode[25] = 0xff; // call dword ptr [xxxxxxxx] - GetProcAddress
    injStub.pCode[26] = 0x15;
    *(DWORD *)(&(injStub.pCode[27])) = dwEntryPoint + 54;
    injStub.pCode[31] = 0xff;
    injStub.pCode[32] = 0xd0;
    *(DWORD *)(&(injStub.pCode[50])) = dwLoadLibrary;
    *(DWORD *)(&(injStub.pCode[54])) = dwGetProcAddress;

    //
    // Create the file mapping object from the paging file
    //
    hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE,
                                 NULL,
                                 PAGE_READWRITE,
                                 0,
                                 sizeof(INJECTIONSTUB),
                                 "ProfilerSharedMem");
    if (0 == hFileMap) {
       bResult = FALSE;
       goto handleerror;
    }

    pSharedMem = (PBYTE)MapViewOfFile(hFileMap,
                                      FILE_MAP_ALL_ACCESS,
                                      0,
                                      0,
                                      sizeof(INJECTIONSTUB));
    if (0 == pSharedMem) {
       bResult = FALSE;
       goto handleerror;
    }

    //
    // Initialize injection stub
    //
    strcpy(injStub.szDLLName, pszDLLName);
    strcpy(injStub.szEntryPoint, DEFAULT_ENTRY_POINT);

    bResult = ReadProcessMemory(hProcess,
 	                       (LPVOID)dwEntryPoint,
 			       (PVOID)pSharedMem,
			       sizeof(INJECTIONSTUB),
			       &dwBytesRead);	                  
    if (FALSE == bResult) {
       bResult = FALSE;
       goto handleerror;
    }  

    //
    // Write the stub code into the entry point
    //
    bResult = WriteProcessMemory(hProcess,
 	                        (LPVOID)dwEntryPoint,
 				(PVOID)&injStub,
				sizeof(INJECTIONSTUB),
 				&dwBytesWritten);	                  
    if (FALSE == bResult) {
       bResult = FALSE;
       goto handleerror;
    }

handleerror:

    return hFileMap;
}

VOID
RestoreImageFromInjection(VOID)
{
    PIMAGE_NT_HEADERS pHeaders = 0;
    BOOL bResult;
    BOOL bError = FALSE;
    PVOID pBase = 0;
    DWORD dwEntryPoint;
    DWORD dwBytesRead;
    DWORD dwBytesWritten;
    PINJECTIONSTUB pInjStub;
    HANDLE hFileMap = 0;
    PBYTE pSharedMem = 0;
    OSVERSIONINFO verInfo;

    //
    // Get the entry point from the headers
    //
    pBase = (PVOID)GetModuleHandle(0);
    if (0 == pBase) {
       bError = TRUE;
       goto handleerror;
    }

    //
    // Dig out the PE information
    //
    pHeaders = ImageNtHeader2(pBase);
    if (0 == pHeaders) {
       bError = TRUE;
       goto handleerror;
    }

    dwEntryPoint = pHeaders->OptionalHeader.ImageBase + pHeaders->OptionalHeader.AddressOfEntryPoint;
    pInjStub = (PINJECTIONSTUB)dwEntryPoint;

    //
    // Open the memory mapped file and get the bits
    //
    hFileMap = OpenFileMapping(FILE_MAP_ALL_ACCESS,
                               FALSE,
                               "ProfilerSharedMem");

    if (0 == hFileMap) {
       bError = TRUE;
       goto handleerror;
    }

    pSharedMem = (PBYTE)MapViewOfFile(hFileMap,
                                      FILE_MAP_ALL_ACCESS,
                                      0,
                                      0,
                                      0);
    if (0 == pSharedMem) {
       bError = TRUE;
       goto handleerror;
    }

    //
    // Replace the bits
    //
    bResult = WriteProcessMemory(GetCurrentProcess(),
                                 (PVOID)dwEntryPoint,
                                 (PVOID)pSharedMem,
                                 sizeof(INJECTIONSTUB),
                                 &dwBytesWritten);
    if (FALSE == bResult) {
       bError = TRUE;
       goto handleerror;
    }

    //
    // Set the OS information
    //
    ZeroMemory(&verInfo, sizeof(OSVERSIONINFO));
    
    verInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    bResult = GetVersionExA(&verInfo);
    if (FALSE == bResult) {
       bError = TRUE;
       goto handleerror;
    }

    if (VER_PLATFORM_WIN32_NT == verInfo.dwPlatformId) {
       g_bIsWin9X = FALSE;
    }
    else if (VER_PLATFORM_WIN32_WINDOWS == verInfo.dwPlatformId) {
       g_bIsWin9X = TRUE;
    }
    else {
       //
       // Unsupported platform
       //
       ExitProcess(-1);
    }

    //
    // Finish profiler initializations
    //
    bResult = InitializeProfiler();
    if (FALSE == bResult) {
       bError = TRUE;
       goto handleerror;
    }
    
handleerror:

    if (TRUE == bError) {
       ExitProcess(-1);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\inject.h ===
#ifndef _INJECT_H_
#define _INJECT_H_

//
// Constant declarations
//
#define DEFAULT_ENTRY_POINT "g_fnFinalizeInjection"

//
// Structure definitions
//
typedef struct _INJECTIONSTUB
{
  CHAR  pCode[MAX_PATH];
  CHAR  szDLLName[MAX_PATH];
  CHAR  szEntryPoint[MAX_PATH];
} INJECTIONSTUB, *PINJECTIONSTUB;

//
// Function definitions
//
HANDLE
InjectDLL(DWORD dwEntryPoint,
          HANDLE hProcess,
          LPSTR  pszDLLName);

VOID
RestoreImageFromInjection(VOID);

#endif //_INJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\profiler.h ===
#ifndef _PROFILER_H_
#define _PROFILER_H_

//
// Constant declarations
//
#define NAME_OF_DLL_TO_INJECT "profiler.dll"
#define NAME_OF_EXCEPTION_VXD "\\\\.\\EXVECTOR.VXD"
#define INSTALL_RING_3_HANDLER 0x42424242

//
// Function definitions
//
DWORD
GetExeEntryPoint(LPSTR pszExePath);

PIMAGE_NT_HEADERS
ImageNtHeader2 (PVOID Base);

BOOL 
InitializeProfiler(VOID);

HANDLE
AttachToEXVectorVXD(VOID);

VOID
DetachFromEXVectorVXD(HANDLE hDevice);

BOOL
WriteImportDLLTableInfo(VOID);

#endif //_PROFILER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\hooks.h ===
#ifndef _HOOKS_H_
#define _HOOKS_H_

//
// Constant declarations
//
#define HAF_RESOLVED        0x0001
#define HAF_BOTTOM_OF_CHAIN 0x0002
#define MAX_MODULES             512
#define SHIM_GETHOOKAPIS        "GetHookAPIs"

typedef PHOOKAPI    (*PFNNEWGETHOOKAPIS)(DWORD dwGetProcAddress, DWORD dwLoadLibraryA, DWORD dwFreeLibrary, DWORD* pdwHookAPICount);
typedef LPSTR       (*PFNGETCOMMANDLINEA)(VOID);
typedef LPWSTR      (*PFNGETCOMMANDLINEW)(VOID);
typedef PVOID       (*PFNGETPROCADDRESS)(HMODULE hMod, char* pszProc);
typedef HINSTANCE   (*PFNLOADLIBRARYA)(LPCSTR lpLibFileName);
typedef HINSTANCE   (*PFNLOADLIBRARYW)(LPCWSTR lpLibFileName);
typedef HINSTANCE   (*PFNLOADLIBRARYEXA)(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
typedef HINSTANCE   (*PFNLOADLIBRARYEXW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
typedef BOOL        (*PFNFREELIBRARY)(HMODULE hLibModule);
typedef VOID        (*PFNEXITPROCESS)(UINT uExitCode);
typedef HANDLE      (*PFNCREATETHREAD)(LPSECURITY_ATTRIBUTES lpThreadAttributes, DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
 

 
//number of the base hook apis used by init.c and shim2.c
#define SHIM_BASE_APIHOOK_COUNT 8

enum
{
   hookGetProcAddress,
   hookLoadLibraryA,
   hookLoadLibraryW,
   hookLoadLibraryExA,
   hookLoadLibraryExW,
   hookFreeLibrary,
   hookExitProcess,
   hookCreateThread,
};

extern PHOOKAPI ConstructChain( PVOID pfnOld ,DWORD* DllListIndex);
extern void __stdcall Shim2PatchNewModules( VOID );
extern void AddHookAPIs( HMODULE hShimDll, PHOOKAPI pHookAPIs, DWORD dwCount,LPTSTR szIncExclDllList);

//
// Structure definitions
//

//
// Function definitions
//
VOID
InitializeBaseHooks(HINSTANCE hInstance);

#endif //_HOOKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\memory.c ===
#include <windows.h>
#include <stdio.h>
#include "memory.h"

static HANDLE hHeap = 0;

BOOL
InitializeHeap(VOID)
{
    HANDLE hResult;

    hResult = HeapCreate(HEAP_GENERATE_EXCEPTIONS,
                         HEAP_DEFAULT_SIZE,
                         0);
    if (0 == hResult) {
       return FALSE;
    }

    hHeap = hResult;

    return TRUE;
}

LPVOID
AllocMem(DWORD dwBytes)
{
    LPVOID lpResult = 0;

    lpResult = HeapAlloc(hHeap,
                         HEAP_ZERO_MEMORY,
                         dwBytes);

    return lpResult;
}

BOOL
FreeMem(LPVOID lpMem)
{
    BOOL bResult = FALSE;

    bResult = HeapFree(hHeap,
                       0,
                       lpMem);

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\profiler.c ===
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <tlhelp32.h>
#include "profiler.h"
#include "inject.h"
#include "view.h"
#include "except.h"
#include "thread.h"
#include "dump.h"
#include "shimdb.h"
#include "shim2.h"
#include "hooks.h"
#include "memory.h"
#include "filter.h"
#include "clevel.h"
#include "cap.h"

extern CHAR g_fnFinalizeInjection[MAX_PATH];
extern HINSTANCE g_hProfileDLL;
extern FIXUPRETURN g_fnFixupReturn[1];
extern DWORD g_dwCallArray[2];
extern CAPFILTER g_execFilter;

int 
WINAPI
WinMain(
    HINSTANCE hInst,
    HINSTANCE hInstPrev,
    LPSTR     lpszCmd,
    int       swShow)
{
    HANDLE hFile = 0;
    BOOL bResult = FALSE;
    STARTUPINFO sInfo;
    PCHAR pszToken;
    PCHAR pszEnd;
    PROCESS_INFORMATION pInfo;
    DWORD dwEntry = 0;
    OSVERSIONINFO verInfo;
    BOOL bIsWin9X = FALSE;
    HANDLE hDevice = INVALID_HANDLE_VALUE;

    //
    // Get the OS information
    //
    ZeroMemory(&verInfo, sizeof(OSVERSIONINFO));
    
    verInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    bResult = GetVersionExA(&verInfo);
    if (FALSE == bResult) {
       return -1;
    }

    if (VER_PLATFORM_WIN32_NT == verInfo.dwPlatformId) {
       bIsWin9X = FALSE;
    }
    else if (VER_PLATFORM_WIN32_WINDOWS == verInfo.dwPlatformId) {
       bIsWin9X = TRUE;
    }

    //
    // Initialize my working heap
    //
    bResult = InitializeHeap();
    if (FALSE == bResult) {
       return -1;
    }

    //
    // Parse the command line
    //
    pszToken = strstr(lpszCmd, "\"");
    if (pszToken) {
       pszToken++;

       pszEnd = strstr(pszToken, "\"");
       *pszEnd = '\0';
    }

    if (0 == pszToken) {
       pszToken = strstr(lpszCmd, " ");
       if (0 == pszToken) {
          pszToken = strstr(lpszCmd, "\t");
          if (0 == pszToken) {
             pszToken = lpszCmd;
          }
       }
    }

    //
    // Initialize our process information struct
    //
    ZeroMemory(&sInfo, sizeof(STARTUPINFO));
    ZeroMemory(&pInfo, sizeof(PROCESS_INFORMATION));
    sInfo.cb = sizeof(STARTUPINFO);

    dwEntry = GetExeEntryPoint(pszToken);
    if (0 == dwEntry) {
       return -1;
    }

    //
    // Get our exe ready for DLL injection
    //
    bResult = CreateProcessA(0,
                             pszToken,
                             0,
                             0,
                             FALSE,
                             CREATE_SUSPENDED,
                             0,
                             0, //should make this a setable param sooner rather than later
                             &sInfo,
                             &pInfo);
    if (FALSE == bResult) {
       return -1;
    }

    //
    // If we're 9x - bring in the VxD
    //
    if (TRUE == bIsWin9X) {
       hDevice = AttachToEXVectorVXD();
       if (INVALID_HANDLE_VALUE == hDevice) {
          return -1;
       }
    }

    //
    // Inject our dll into the target
    //
    hFile = InjectDLL(dwEntry,
                      pInfo.hProcess,
                      NAME_OF_DLL_TO_INJECT);
    if (0 == hFile) {
       return -1;
    }

    //
    // Turn the process loose
    //
    bResult = ResumeThread(pInfo.hThread);
    if (FALSE == bResult) {
       return -1;
    }

    //
    // Wait for target termination
    //    
    WaitForSingleObject(pInfo.hThread,
                        INFINITE);

    //
    // If we're 9x - close our handle to the vxd (this will unload the vxd from memory)
    //
    if (TRUE == bIsWin9X) {
       if (INVALID_HANDLE_VALUE != hDevice) {
          DetachFromEXVectorVXD(hDevice);
       }
    }

    return 0;
}

DWORD
GetExeEntryPoint(LPSTR pszExePath)
{
    PIMAGE_NT_HEADERS pHeaders;
    BOOL bResult;
    PCHAR pEXEBits = 0;
    DWORD dwEntry = 0;
    DWORD dwNumberBytesRead;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    pEXEBits = (PCHAR)AllocMem(4096 * 1);  //allocate a page for reading the PE entry point
    if (0 == pEXEBits) {
       return dwEntry;
    }

    hFile = CreateFileA(pszExePath,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        0,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        0);
    if (INVALID_HANDLE_VALUE == hFile) {
       goto handleerror;
    }

    bResult = ReadFile(hFile,
                       pEXEBits,
                       4096, //read one page
                       &dwNumberBytesRead,
                       0);
    if (FALSE == bResult) {
       goto handleerror;
    }

    //
    // Dig out the PE information
    //
    pHeaders = ImageNtHeader2((PVOID)pEXEBits);
    if (0 == pHeaders) {
       goto handleerror;
    }

    dwEntry = pHeaders->OptionalHeader.ImageBase + pHeaders->OptionalHeader.AddressOfEntryPoint;
                    
handleerror:

    if (pEXEBits) {
       FreeMem(pEXEBits);
    }

    if (INVALID_HANDLE_VALUE != hFile) {
       CloseHandle(hFile);
    }
   
    return dwEntry;
}

PIMAGE_NT_HEADERS
ImageNtHeader2 (PVOID Base)
{
    PIMAGE_NT_HEADERS NtHeaders = NULL;

    if (Base != NULL && Base != (PVOID)-1) {
        if (((PIMAGE_DOS_HEADER)Base)->e_magic == IMAGE_DOS_SIGNATURE) {
            NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);

            if (NtHeaders->Signature != IMAGE_NT_SIGNATURE) {
                NtHeaders = NULL;
            }
        }
    }

    return NtHeaders;
}

BOOL
WINAPI 
DllMain (
  HINSTANCE hinstDLL,
  DWORD fdwReason,
  LPVOID lpvReserved)
{
    PIMAGE_NT_HEADERS pHeaders;
    PVOID pBase = 0;
    DWORD dwEntryPoint;
    BOOL bResult = FALSE;

    //
    // Return true for everything coming through here
    //
    if (DLL_PROCESS_ATTACH == fdwReason) {
       //
       // Initialize my working heap
       //
       bResult = InitializeHeap();
       if (FALSE == bResult) {
          return FALSE;
       }

       //
       // Initialize the asm for the fixup return
       //

       //
       // Get the entry point from the headers
       //
       pBase = (PVOID)GetModuleHandle(0);
       if (0 == pBase) {
          return FALSE;
       }

       //
       // Dig out the PE information
       //
       pHeaders = ImageNtHeader2(pBase);
       if (0 == pHeaders) {
          return FALSE;
       }

       dwEntryPoint = pHeaders->OptionalHeader.ImageBase + pHeaders->OptionalHeader.AddressOfEntryPoint;

       //
       // Initialize stub asm for cleanup
       //
       g_fnFinalizeInjection[0] = 0x90; // int 3
       g_fnFinalizeInjection[1] = 0xff; // call dword ptr [xxxxxxxx] - RestoreImageFromInjection
       g_fnFinalizeInjection[2] = 0x15;
       *(DWORD *)(&(g_fnFinalizeInjection[3])) = (DWORD)g_fnFinalizeInjection + 50;
       g_fnFinalizeInjection[7] = 0x83;
       g_fnFinalizeInjection[8] = 0xc4;
       g_fnFinalizeInjection[9] = 0x04;
       g_fnFinalizeInjection[10] = 0x61;
       g_fnFinalizeInjection[11] = 0xa1;
       *(DWORD *)(&(g_fnFinalizeInjection[12])) = (DWORD)g_fnFinalizeInjection + 54;
       g_fnFinalizeInjection[16] = 0xff;
       g_fnFinalizeInjection[17] = 0xe0; 

       *(DWORD *)(&(g_fnFinalizeInjection[50])) = (DWORD)RestoreImageFromInjection;
       *(DWORD *)(&(g_fnFinalizeInjection[54])) = dwEntryPoint;

       //
       // Initialize the call return code
       //
       g_dwCallArray[0] = (DWORD)PopCaller;
       g_dwCallArray[1] = (DWORD)g_fnFixupReturn;

       g_fnFixupReturn->PUSHAD = 0x60;                //pushad   (60)
       g_fnFixupReturn->PUSHFD = 0x9c;                //pushfd   (9c)
       g_fnFixupReturn->PUSHDWORDESPPLUS24[0] = 0xff; //push dword ptr [esp+24] (ff 74 24 24)
       g_fnFixupReturn->PUSHDWORDESPPLUS24[1] = 0x74;
       g_fnFixupReturn->PUSHDWORDESPPLUS24[2] = 0x24;
       g_fnFixupReturn->PUSHDWORDESPPLUS24[3] = 0x24;
       g_fnFixupReturn->CALLROUTINE[0] = 0xff;        //call [address] (ff15 dword address)
       g_fnFixupReturn->CALLROUTINE[1] = 0x15;
       *(DWORD *)(&(g_fnFixupReturn->CALLROUTINE[2])) = (DWORD)&(g_dwCallArray[0]);
       g_fnFixupReturn->MOVESPPLUS24EAX[0] = 0x89;    //mov [esp+0x24],eax (89 44 24 24)
       g_fnFixupReturn->MOVESPPLUS24EAX[1] = 0x44;
       g_fnFixupReturn->MOVESPPLUS24EAX[2] = 0x24; 
       g_fnFixupReturn->MOVESPPLUS24EAX[3] = 0x24;
       g_fnFixupReturn->POPFD = 0x9d;                 //popfd   (9d)
       g_fnFixupReturn->POPAD = 0x61;                 //popad   (61)
       g_fnFixupReturn->RET = 0xc3;                   //ret (c3)

       //
       // Store the DLL base address
       //
       g_hProfileDLL = hinstDLL;
    }
 
    return TRUE;
}

BOOL 
InitializeProfiler(VOID)
{
    BOOL bResult = TRUE;
    PIMAGE_NT_HEADERS pHeaders;
    PVOID pBase = 0;
    DWORD dwEntryPoint;
    PVIEWCHAIN pvTemp;

    //
    // Get the entry point from the headers
    //
    pBase = (PVOID)GetModuleHandle(0);
    if (0 == pBase) {
       return FALSE;
    }

    //
    // Dig out the PE information
    //
    pHeaders = ImageNtHeader2(pBase);
    if (0 == pHeaders) {
       return FALSE;
    }

    dwEntryPoint = pHeaders->OptionalHeader.ImageBase + pHeaders->OptionalHeader.AddressOfEntryPoint;

    //
    // Tag the entry point so it'll start profiling with the initial view
    //
    bResult = InitializeViewData();
    if (FALSE == bResult) {
       //
       // Something unexpected happened
       //
       ExitProcess(-1);
    }

    //
    // Initialize execution filter data
    //
    ZeroMemory(&g_execFilter, sizeof(CAPFILTER));

    //
    // Initialize thread context data
    //
    InitializeThreadData();

    //
    // Get the debug logging setup
    //
    bResult = InitializeDumpData();
    if (FALSE == bResult) {
       //
       // Something unexpected happened
       //
       ExitProcess(-1);
    }

    //
    // Initialize the module filtering
    //
    bResult = InitializeFilterList();
    if (FALSE == bResult) {
       //
       // Something unexpected happened
       //
       ExitProcess(-1);
    }

    //
    // Set up exception trap mechanism
    //
    bResult = HookUnchainableExceptionFilter();
    if (FALSE == bResult) {
       //
       // Something unexpected happened while chaining exception filter
       //
       ExitProcess(-1);
    }

    //
    // Fixup the module list now that everything is restored
    //
    //
    InitializeBaseHooks(g_hProfileDLL);

    //
    // Write out import table base info
    //
    bResult = WriteImportDLLTableInfo();
    if (FALSE == bResult) {
       ExitProcess(-1);
    }

    //
    // Add our entrypoint to the view monitor
    //
    pvTemp = AddViewToMonitor(dwEntryPoint,
                              ThreadStart);
    if (0 == pvTemp) {
       ExitProcess(-1);
    }

    //
    // We're done
    // 
    return TRUE;
}

BOOL
WriteImportDLLTableInfo(VOID)
{
    HANDLE hSnapshot = INVALID_HANDLE_VALUE;
    MODULEENTRY32 ModuleEntry32;
    BOOL bResult;

    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE,
                                         0);
    if (INVALID_HANDLE_VALUE == hSnapshot) {
       return FALSE;
    }

    //
    // Walk the DLL imports
    //
    ModuleEntry32.dwSize = sizeof(ModuleEntry32);

    bResult = Module32First(hSnapshot, 
                            &ModuleEntry32);
    if (FALSE == bResult) {
       return bResult;
    }

    while(bResult) {
        //
        // Dump the module information to disk
        //

        if ((DWORD)(ModuleEntry32.modBaseAddr) != (DWORD)g_hProfileDLL) {                         
           bResult = WriteDllInfo(ModuleEntry32.szModule,
                                  (DWORD)(ModuleEntry32.modBaseAddr),
                                  (DWORD)(ModuleEntry32.modBaseSize));
           if (FALSE == bResult) {
              CloseHandle(hSnapshot);

              return FALSE;
           }
        }

        bResult = Module32Next(hSnapshot, 
                               &ModuleEntry32);
    }

    if (INVALID_HANDLE_VALUE != hSnapshot) {
      CloseHandle(hSnapshot);
    }

    return TRUE;
}

HANDLE
AttachToEXVectorVXD(VOID)
{
    HANDLE hFile;

    hFile = CreateFileA(NAME_OF_EXCEPTION_VXD,
                        0,
                        0,
                        0,
                        0,
                        FILE_FLAG_DELETE_ON_CLOSE,
                        0);

    return hFile;
}

VOID
DetachFromEXVectorVXD(HANDLE hDevice)
{
    CloseHandle(hDevice);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\shimhapi.h ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    shim.h
//
// History:    May-99   clupu       Created.
//             Aug-99   v-johnwh    Various bug fixes.
//          23-Nov-99   markder     Support for multiple shim DLLs, chaining
//                                  of hooks. General clean-up.
//          11-Feb-00   markder     Reverted to W2K shipped shim structures.
// 
// Desc:    Contains all structure and function definitions for the shim mechanism.
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef __SHIM_H__
#define __SHIM_H__

typedef struct tagHOOKAPI {
    
    char*   pszModule;            // the name of the module
    char*   pszFunctionName;      // the name of the API in the module
    PVOID   pfnNew;               // pointer to the new stub API
    PVOID   pfnOld;               // pointer to the old API
    DWORD   dwFlags;              // used internally
    struct tagHOOKAPI *pNextHook; // used internally
} HOOKAPI, *PHOOKAPI;

/*
 * If the hook DLL ever patches LoadLibraryA/W it must call PatchNewModules
 * so that the shim knows to patch any new loaded DLLs
 */
typedef VOID (*PFNPATCHNEWMODULES)(VOID);

typedef PHOOKAPI (*PFNGETHOOKAPIS)(LPSTR pszCmdLine,
                                   PFNPATCHNEWMODULES pfnPatchNewModules,
                                   DWORD* pdwHooksCount);

#define SHIM_COMMAND_LINE_MAX_BUFFER 1024

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\view.c ===
#include <windows.h>
#include <stdio.h>
#include "view.h"
#include "except.h"
#include "disasm.h"
#include "dump.h"
#include "profiler.h"
#include "memory.h"
#include "filter.h"

static PVIEWCHAIN *ppViewHead = 0;
static CRITICAL_SECTION viewCritSec;
static CRITICAL_SECTION mapCritSec;
static PTAGGEDADDRESS pTagHead = 0;
static PBRANCHADDRESS pBranchHead = 0;

BOOL
InitializeViewData(VOID)
{
    InitializeCriticalSection(&viewCritSec);
    InitializeCriticalSection(&mapCritSec); 

    //
    // Allocate hashing data
    //
    ppViewHead = (PVIEWCHAIN *)AllocMem(sizeof(PVIEWCHAIN) * (MAX_MAP_SIZE >> MAP_STRIDE_BITS));
    if (0 == ppViewHead) {
       return FALSE;
    }

    return TRUE;
}

PVIEWCHAIN
AddViewToMonitor(DWORD dwAddress,
                 BPType bpType)
{
    PVIEWCHAIN pView;
    DWORD dwHash;

    //
    // If address is higher than the map size, fail it
    //
    if (dwAddress >= MAX_MAP_SIZE) {
       return 0;
    }

    //
    // This occurs when a call tries to map over an existing trace breakpoint
    //
    if (*(BYTE *)dwAddress == X86_BREAKPOINT) {
       return 0;
    }

    //
    // Check if we're filtering this address
    //
    if (TRUE == IsAddressFiltered(dwAddress)) {
       return 0;
    }

    //
    // Allocate a chain entry
    //
    pView = AllocMem(sizeof(VIEWCHAIN));
    if (0 == pView) {
       return 0;
    }

    pView->bMapped = FALSE;
    pView->bTraced = FALSE;
    pView->dwAddress = dwAddress;
    pView->dwMapExtreme = dwAddress;
    pView->jByteReplaced = *(BYTE *)dwAddress;
    pView->bpType = bpType;

    //
    // Set a breakpoint at the top of the code
    //
    WRITEBYTE(dwAddress, X86_BREAKPOINT);

    EnterCriticalSection(&viewCritSec);

    //
    // Add view point to monitor list
    //
    dwHash = dwAddress >> MAP_STRIDE_BITS;
    if (0 == ppViewHead[dwHash]) {
       ppViewHead[dwHash] = pView;
    }
    else {
       //
       // Chain to head
       //
       pView->pNext = ppViewHead[dwHash];
       ppViewHead[dwHash] = pView;
    }

    LeaveCriticalSection(&viewCritSec);

    return pView;
}

PVIEWCHAIN
RestoreAddressFromView(DWORD dwAddress,
                       BOOL bResetData)
{
    BOOL bResult = FALSE;
    PVIEWCHAIN pTemp;

    EnterCriticalSection(&viewCritSec);

    pTemp = ppViewHead[dwAddress >> MAP_STRIDE_BITS];
    while (pTemp) {
        //
        // Is this our entry
        //
        if (dwAddress == pTemp->dwAddress) {
           //
           // Set a breakpoint at the top of the code
           //
           if (TRUE == bResetData) {
              WRITEBYTE(dwAddress, pTemp->jByteReplaced);
           }
           else {
              WRITEBYTE(dwAddress, X86_BREAKPOINT);
           }

           //
           // Return with modified data
           //
           break;
        }

        pTemp = pTemp->pNext;
    }

    LeaveCriticalSection(&viewCritSec);
    
    return pTemp;
}

PVIEWCHAIN
FindView(DWORD dwAddress) {
    PVIEWCHAIN pTemp;

    if (dwAddress >= MAX_MAP_SIZE) {
       return 0;
    }

    EnterCriticalSection(&viewCritSec);

    pTemp = ppViewHead[dwAddress >> MAP_STRIDE_BITS];
    while (pTemp) {
        //
        // See if address is mapped
        //
        if (dwAddress == pTemp->dwAddress) {
           LeaveCriticalSection(&viewCritSec);

           return pTemp;
        }

        pTemp = pTemp->pNext;
    }

    LeaveCriticalSection(&viewCritSec);

    return 0;
}

BOOL
MapCode(PVIEWCHAIN pvMap) {
    BOOL bResult;
    DWORD dwCurrent;
    DWORD *pdwAddress;
    DWORD *pdwTemp;
    PCHAR pCode;
    PVIEWCHAIN pvTemp;
    DWORD dwLength;
    DWORD dwJumpEIP;
    LONG lOffset;
    DWORD dwInsLength;
    DWORD dwTemp;
    BYTE  tempCode[32];
    BYTE  jOperand;
    DWORD dwProfileEnd = 0;
    CHAR szBuffer[MAX_PATH];

    //
    // Map termination through all conditionals
    //
    dwCurrent = pvMap->dwAddress;

    //
    // Take the mapping lock
    //
    LockMapper();

    //
    // Forward scan through code to find termination
    //
    while(1) {
       strncpy(tempCode, (PCHAR)dwCurrent, 32);

       //
       // Make sure the instruction is unmodified
       //
       if (tempCode[0] == (BYTE)X86_BREAKPOINT) {
          //
          // Rebuild instruction without breakpoints
          //
          pvTemp = FindView(dwCurrent);
          if (pvTemp) {
             //
             // Replace the bytes if we have a match
             //
             tempCode[0] = pvTemp->jByteReplaced;
          }
       }

       //
       // Calculate instruction length
       //
       dwInsLength = GetInstructionLengthFromAddress((PVOID)tempCode);

       //
       // Follow a forward trace through jumps to the ret
       //
       if ((tempCode[0] >= (BYTE)0x70) && (tempCode[0] <= (BYTE)0x7f)) {
          //
          // Update the end of the region marker
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }

          //
          // Relative branch
          //
          dwJumpEIP = (dwCurrent + 2 + (CHAR)(tempCode[1]));

          //
          // Mark this branch as executed
          //
          bResult = AddTaggedAddress(dwCurrent);
          if (FALSE == bResult) {
             return FALSE;
          }

          if (dwJumpEIP > dwCurrent) {
             //
             // Push the opposite branch
             //
             bResult = PushBranch(dwCurrent + dwInsLength);
             if (FALSE == bResult) {
                return FALSE;
             }

             dwCurrent = dwJumpEIP;
          }
          else {
             //
             // Push the opposite branch
             //
             bResult = PushBranch(dwJumpEIP);
             if (FALSE == bResult) {
                return FALSE;
             }

             dwCurrent += dwInsLength;
          }

          continue;
       }

       if (tempCode[0] == (BYTE)0x0f) {
          if ((tempCode[1] >= (BYTE)0x80) && (tempCode[1] <= (BYTE)0x8f)) {
             //
             // Update the end of the region marker
             //
             if (dwCurrent > dwProfileEnd) {
                dwProfileEnd = dwCurrent;
             }

             //
             // Relative branch
             //
             dwJumpEIP = (dwCurrent + 6 + *(LONG *)(&(tempCode[2])));             

             //
             // Mark this branch as executed
             //
             bResult = AddTaggedAddress(dwCurrent);
             if (FALSE == bResult) {
                return FALSE;
             }

             if (dwJumpEIP > dwCurrent) {
                //
                // Push the opposite branch
                //
                bResult = PushBranch(dwCurrent + dwInsLength);
                if (FALSE == bResult) {
                   return FALSE;
                }
 
                dwCurrent = dwJumpEIP;
             }
             else {
                //
                // Push the opposite branch
                //
                bResult = PushBranch(dwJumpEIP);
                if (FALSE == bResult) {
                   return FALSE;
                }

                dwCurrent += dwInsLength;
             }

             continue;
          }
       }

       if (tempCode[0] == (BYTE)0xe3) {
          //
          // Update the end of the region marker
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }

          //
          // Relative branch
          //
          dwJumpEIP = (dwCurrent + 2 + (CHAR)(tempCode[1]));

          //
          // Mark this branch as executed
          //
          bResult = AddTaggedAddress(dwCurrent);
          if (FALSE == bResult) {
             return FALSE;
          }

          if (dwJumpEIP > dwCurrent) {
             //
             // Push the opposite branch
             //
             bResult = PushBranch(dwCurrent + dwInsLength);
             if (FALSE == bResult) {
                return FALSE;
             }

             dwCurrent = dwJumpEIP;
          }
          else {
             //
             // Push the opposite branch
             //
             bResult = PushBranch(dwJumpEIP);
             if (FALSE == bResult) {
                return FALSE;
             }

             dwCurrent += dwInsLength;
          }

          continue;
       }

       if (tempCode[0] == (BYTE)0xeb) {
          //
          // Update the end of the region marker
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }

          //
          // Jump relative
          //
          dwJumpEIP = (dwCurrent + 2 + (CHAR)(tempCode[1]));

          //
          // Mark this branch as executed
          //
          bResult = AddTaggedAddress(dwCurrent);
          if (FALSE == bResult) {
             return FALSE;
          }
          
          //
          // Jmp must always be followed
          //
          dwCurrent = dwJumpEIP;
          continue;
       }

       if (tempCode[0] == (BYTE)0xe9) {
          //
          // Update the end of the region marker
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }

          //
          // Jump relative
          //
          dwJumpEIP = (dwCurrent + 5 + *(LONG *)(&(tempCode[1])));

          //
          // Mark this branch as executed
          //
          bResult = AddTaggedAddress(dwCurrent);
          if (FALSE == bResult) {
             return FALSE;
          }
          
          //
          // Jump must always be followed
          //
          dwCurrent = dwJumpEIP;
          continue;
       }
       
       //
       // Probe for calls and jumps
       //
       if (tempCode[0] == (BYTE)0xff) {
          //
          // Tests for whether this is a call or not
          //
          jOperand = (tempCode[1] >> 3) & 7;
          if ((jOperand == 2) || 
              (jOperand == 3) ||
              (jOperand == 4) ||
              (jOperand == 5)) {
             //
             // Update the end of the region marker
             //
             if (dwCurrent > dwProfileEnd) {
                dwProfileEnd = dwCurrent;
             }

             //
             // Add our mapping breakpoint with the appropriate type
             //
             if ((jOperand == 2) ||
                 (jOperand == 3)) {
                 pvTemp = AddViewToMonitor(dwCurrent,
                                           Call);
                 if (pvTemp) {
                    pvTemp->bMapped = TRUE;
                 }
             }
             else {
                 //
                 // These kinds of jumps are always a break (there's no way to forward trace them)
                 //
                 pvTemp = AddViewToMonitor(dwCurrent,
                                           Jump);
                 if (pvTemp) {
                    pvTemp->bMapped = TRUE;
                 }
                 else {
                    //
                    // Special case for mapping breakpoints which really are just jumps
                    //
                    pvTemp = FindView(dwCurrent);
                    if (pvTemp) {
                       pvTemp->bMapped = TRUE;
                       pvTemp->bpType = Jump;
                    }
                 }
          
                 //
                 // Mark this branch as executed
                 //
                 bResult = AddTaggedAddress(dwCurrent);
                 if (FALSE == bResult) {
                    return FALSE;
                 }

                 //
                 // Dump the tree
                 //
                 dwTemp = PopBranch();
                 if (dwTemp) {
                    dwCurrent = dwTemp;
                    continue;
                 }

                 break;
             }
          }
       }

       if (tempCode[0] == (BYTE)0xe8) {
          //
          // Update the end of the region marker
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }

          //
          // Add this top call to the view
          //
          pvTemp = AddViewToMonitor(dwCurrent,
                                    Call);
          if (pvTemp) {
             pvTemp->bMapped = TRUE;
          }
       }

       if (tempCode[0] == (BYTE)0x9a) {
          //
          // Update the end of the region marker
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }

          //
          // Add this top call to the view
          //
          pvTemp = AddViewToMonitor(dwCurrent,
                                    Call);
          if (pvTemp) {
             pvTemp->bMapped = TRUE;
          }
       }

       if (tempCode[0] == (BYTE)0xea) {
          //
          // Update the end of the region marker
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }

          //
          // Absolute far jumps are a terminating condition - flush all branches
          //
          pvTemp = AddViewToMonitor(dwCurrent,
                                    Jump);
          if (pvTemp) {
             pvTemp->bMapped = TRUE;
          }
          
          //
          // Mark this branch as executed
          //
          bResult = AddTaggedAddress(dwCurrent);
          if (FALSE == bResult) {
             return FALSE;
          }

          //
          // Dump the tree
          //
          dwTemp = PopBranch();
          if (dwTemp) {
             dwCurrent = dwTemp;
             continue;
          }

          break;
       }

       if (*(WORD *)(&(tempCode[0])) == 0xffff) {
          //
          // Update the end of the region marker
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }

          //
          // This is also a trace path terminator - see if we need to trace more conditions
          //
          dwTemp = PopBranch();
          if (dwTemp) {
             //
             // We have a branch to follow
             //
             dwCurrent = dwTemp;
             continue;
          }

          //
          // Update the end of the address range
          //
          break;
       }

       if (tempCode[0] == (BYTE)0xc3) {
          //
          // This is also a trace path terminator - see if we need to trace more conditions
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }
          
          dwTemp = PopBranch();
          if (dwTemp) {
             //
             // We have a branch to follow
             //
             dwCurrent = dwTemp;
             continue;
          }

          break;
       }

       if (tempCode[0] == (BYTE)0xc2) {
          //
          // This is also a trace path terminator - see if we need to trace more conditions
          //
          if (dwCurrent > dwProfileEnd) {
             dwProfileEnd = dwCurrent;
          }
          
          dwTemp = PopBranch();
          if (dwTemp) {
             //
             // We have a branch to follow
             //
             dwCurrent = dwTemp;
             continue;
          }

          break;
       } 

       dwCurrent += dwInsLength;
    }    

    if (dwProfileEnd) {
       pvMap->dwMapExtreme = dwProfileEnd;
    }
    else {
       pvMap->dwMapExtreme = dwCurrent;
    }

    bResult = WriteMapInfo(pvMap->dwAddress,
                           pvMap->dwMapExtreme);
    if (!bResult) {
       return FALSE;
    }

    //
    // Restore the code we've whacked around
    //
    bResult = RestoreTaggedAddresses();
    if (FALSE == bResult) {
       return FALSE;
    }

    //
    // Assert if this _ever_ happens
    //
    if (pBranchHead != 0) {
       Sleep(20000);
       _asm int 3
    }

    //
    // We're mapped
    //
    pvMap->bMapped = TRUE;

    //
    // Release the mapping lock
    //
    UnlockMapper();

    return TRUE;    
}

//
// Trace helpers
//
BOOL
AddTaggedAddress(DWORD dwAddress)
{
    PTAGGEDADDRESS pTagTemp;
    DWORD dwTempAddress;

    //
    // Make sure we haven't addressed this tag
    //
    if (*(WORD *)dwAddress == 0xFFFF) {
       //
       // No need since it's already tagged
       //
       return TRUE;
    }

    //
    // Store off the bytes we are tagging
    //
    pTagTemp = AllocMem(sizeof(TAGGEDADDRESS));
    if (0 == pTagTemp) {
       return FALSE;
    }

    pTagTemp->dwAddress = dwAddress;
    pTagTemp->wBytesReplaced = *(WORD *)dwAddress;

    //
    // Chain the entry
    //
    if (0 == pTagHead) {
       pTagHead = pTagTemp;
    }
    else {
       pTagTemp->pNext = pTagHead;
       pTagHead = pTagTemp;
    }

    //
    // Mark this branch as executed
    //
    WRITEWORD(dwAddress, 0xFFFF);
    
    return TRUE;
}

BOOL
RestoreTaggedAddresses(VOID)
{
    PTAGGEDADDRESS pTagTemp;
    PTAGGEDADDRESS pTagTemp2;

    //
    // Walk the tag list and replace the marked branches with their original bytes
    //
    pTagTemp = pTagHead;
    while(pTagTemp) {
        //
        // Dirty up the code now so the branches can auto terminate
        //
        WRITEWORD(pTagTemp->dwAddress, pTagTemp->wBytesReplaced);

        pTagTemp2 = pTagTemp;

        pTagTemp = pTagTemp->pNext;

        //
        // Dump the old allocated memory
        //
        FreeMem(pTagTemp2);
    }

    pTagHead = 0;
    
    return TRUE;
}

BOOL
PushBranch(DWORD dwAddress)
{
    PBRANCHADDRESS pBranchTemp;

    pBranchTemp = AllocMem(sizeof(BRANCHADDRESS));
    if (0 == pBranchTemp) {
       return FALSE;
    }

    pBranchTemp->dwAddress = dwAddress;

    if (0 == pBranchHead) {
       pBranchHead = pBranchTemp;
    }
    else {
       pBranchTemp->pNext = pBranchHead;
       pBranchHead = pBranchTemp;
    }

    return TRUE;
}

DWORD
PopBranch(VOID)
{
    PBRANCHADDRESS pBranchTemp;
    DWORD dwAddress = 0;

    pBranchTemp = pBranchHead;

    if (0 == pBranchTemp) {
       return 0;
    }

    dwAddress = pBranchTemp->dwAddress;
    pBranchHead = pBranchHead->pNext;

    FreeMem(pBranchTemp);

    return dwAddress;
}

VOID
LockMapper(VOID)
{
    EnterCriticalSection(&mapCritSec);
}

VOID
UnlockMapper(VOID)
{
    LeaveCriticalSection(&mapCritSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\view.h ===
#ifndef _VIEW_H_
#define _VIEW_H_

//
// Constant declarations
//
#define X86_BREAKPOINT 0xcc

#define MAX_MAP_SIZE    0x80000000
#define MAP_STRIDE_BITS 10

typedef enum
{
  None = 0,
  Call,
  Jump,
  Map,
  ThreadStart,
} BPType;

//
// Structure definitions
//
typedef struct _VIEWCHAIN
{
  BOOL bMapped;
  BOOL bTraced;
  BPType bpType;
  DWORD dwAddress;
  DWORD dwMapExtreme;
  BYTE jByteReplaced;
  struct _VIEWCHAIN *pNext;
} VIEWCHAIN, *PVIEWCHAIN;

//
// Macros
//
#define WRITEBYTE(x, y) \
{                    \
{                                   \
DWORD dwOldProtect;  \
                     \
VirtualProtect((LPVOID)(x),  \
               sizeof(BYTE), \
               PAGE_READWRITE, \
               &dwOldProtect); \
*(PBYTE)(x) = (y);   \
}                    \
                     \
}

#define WRITEWORD(x, y) \
{                    \
{                                   \
DWORD dwOldProtect;  \
                     \
VirtualProtect((LPVOID)(x),  \
               sizeof(WORD), \
               PAGE_READWRITE, \
               &dwOldProtect); \
*(WORD *)(x) = (y);   \
}                    \
                     \
}


/*
#define WRITEBYTE(x, y) \
{                    \
__try                \
{                    \
*(PBYTE)(x) = (y);   \
}                    \
__except(EXCEPTION_EXECUTE_HANDLER) \
{                                   \
DWORD dwOldProtect;  \
                     \
VirtualProtect((LPVOID)(x),  \
               sizeof(BYTE), \
               PAGE_READWRITE, \
               &dwOldProtect); \
*(PBYTE)(x) = (y);   \
}                    \
                     \
}

#define WRITEWORD(x, y) \
{                    \
__try                \
{                    \
*(WORD *)(x) = (y);   \
}                    \
__except(EXCEPTION_EXECUTE_HANDLER) \
{                                   \
DWORD dwOldProtect;  \
                     \
VirtualProtect((LPVOID)(x),  \
               sizeof(WORD), \
               PAGE_READWRITE, \
               &dwOldProtect); \
*(WORD *)(x) = (y);   \
}                    \
                     \
}
*/

//
// Structure definitions
//
typedef struct _TAGGEDADDRESS
{
  DWORD dwAddress;
  WORD wBytesReplaced;
  struct _TAGGEDADDRESS *pNext;
} TAGGEDADDRESS, *PTAGGEDADDRESS;

typedef struct _BRANCHADDRESS
{
  DWORD dwAddress;
  struct _BRANCHADDRESS *pNext;
} BRANCHADDRESS, *PBRANCHADDRESS;

//
// Function definitions
//
PVIEWCHAIN
AddViewToMonitor(DWORD dwAddress,
                 BPType bpType);

BOOL
InitializeViewData(VOID);

PVIEWCHAIN
RestoreAddressFromView(DWORD dwAddress,
                       BOOL bResetData);

PVIEWCHAIN
FindMappedView(DWORD dwAddress);

PVIEWCHAIN
FindView(DWORD dwAddress);

BOOL
MapCode(PVIEWCHAIN pvMap);

BOOL
PushBranch(DWORD dwAddress);

DWORD
PopBranch(VOID);

BOOL
AddTaggedAddress(DWORD dwAddress);

BOOL
RestoreTaggedAddresses(VOID);

VOID
LockMapper(VOID);

VOID
UnlockMapper(VOID);

#endif //_VIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\shim2.h ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    shim2.h
//
// History:    Mar-00   a-batjar       Created.
// 
// Desc:    Contains common declarations for shim2
//          
//
////////////////////////////////////////////////////////////////////////////////////


//defined in shim2.c used by init.c GetHookApis.
//loads the shim dll and initializes global structures necessary to hook 

extern BOOL _LoadPatchDll(LPWSTR szPatchDll,LPSTR szCmdLine,LPSTR szModToPatch);

//defined in shim2.c used by init.c GetHookApis
//shim2's hook mechanism, redirects import table of the loaded dll to
//shim functions.

extern void __stdcall PatchNewModules( VOID );


//memory patch tags used by mempatch.c and shim2.c

#define SHIM_MP_UNPROCESSED 0x00
#define SHIM_MP_PROCESSED   0x01
#define SHIM_MP_APPLIED     0x02

typedef struct tagSHIM_MEMORY_PATCH
{
    LPWSTR  pszModule;
    DWORD   dwOffset;
    DWORD   dwSize;
    LPVOID  pOld;
    LPVOID  pNew;
    DWORD   dwStatus;

} SHIM_MEMORY_PATCH, *PSHIM_MEMORY_PATCH;

//defined in init.c used by mempatch.c 


#define MEMPATCHTAG   "PATCH"


//defined in mempatch.c used by shim2.c PatchNewModules
extern void AttemptPatches();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\thread.c ===
#include <stdio.h>
#include <windows.h>
#include "view.h"
#include "thread.h"
#include "dump.h"
#include "except.h"
#include "memory.h"

extern BOOL g_bIsWin9X;
static CRITICAL_SECTION tCritSec;
static PTHREADFAULT pThreadHead = 0;

VOID
InitializeThreadData(VOID)
{
    InitializeCriticalSection(&tCritSec);
}

PVOID
GetProfilerThreadData(VOID)
{
    PVOID pData;
    PTHREADFAULT pTemp = 0;
    DWORD dwThreadId;

    dwThreadId = GetCurrentThreadId();

    EnterCriticalSection(&tCritSec);

    pTemp = pThreadHead;
    while(pTemp) {
       if (pTemp->dwThreadId == dwThreadId) {
          break;
       }

       pTemp = pTemp->pNext;
    }

    LeaveCriticalSection(&tCritSec);

    return pTemp;
}

VOID
SetProfilerThreadData(PVOID pData)
{
    PTHREADFAULT pTemp;

    EnterCriticalSection(&tCritSec);

    pTemp = (PTHREADFAULT)pData;

    pTemp->dwThreadId = GetCurrentThreadId();
    pTemp->pNext = pThreadHead;
    pThreadHead = pTemp;

    LeaveCriticalSection(&tCritSec);
}

PTHREADFAULT
AllocateProfilerThreadData(VOID)
{
    PTHREADFAULT pTemp = 0;

    pTemp = AllocMem(sizeof(THREADFAULT));
    if (0 == pTemp) {
       return 0;
    }

    pTemp->dwCallLevel = 0;
    pTemp->dwPrevBP = 0;
    pTemp->pCallStackList = 0;
    pTemp->dwCallMarker = 0;
    pTemp->pNext = 0;

    //
    // Set thread data
    //
    SetProfilerThreadData(pTemp);

    return pTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\makediff\dump.h ===
#ifndef _DUMP_H_
#define _DUMP_H_

typedef enum _DUMPTYPES
{
    ThreadStartId = 0,
    ExeFlowId,
    DllBaseInfoId,
    MapInfoId,
    ErrorInfoId,
} DUMPTYPES;

//
// Structure definitions
//
typedef struct _THREADSTART
{
    DUMPTYPES dwType;
    DWORD dwThreadId;
    DWORD dwStartAddress;
} THREADSTART, *PTHREADSTART;

typedef struct _EXEFLOW
{
    DUMPTYPES dwType;
    DWORD dwThreadId;
    DWORD dwAddress;
    DWORD dwCallLevel;
} EXEFLOW, *PEXEFLOW;

typedef struct _DLLBASEINFO
{
    DUMPTYPES dwType;
    DWORD dwBase;
    DWORD dwLength;
    CHAR  szDLLName[32];
} DLLBASEINFO, *PDLLBASEINFO;

typedef struct _MAPINFO
{
    DUMPTYPES dwType;
    DWORD dwAddress;
    DWORD dwMaxMapLength;
} MAPINFO, *PMAPINFO;

typedef struct _ERRORINFO
{
    DWORD dwType;
    CHAR szMessage[MAX_PATH];
} ERRORINFO, *PERRORINFO;

#endif //_DUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\thread.h ===
#ifndef _THREAD_H_
#define _THREAD_H_

//
// Constant declarations
//

//
// Structure definitions
//
typedef struct _THREADFAULT
{
  DWORD dwCallLevel;
  DWORD dwPrevBP;
  BPType prevBPType;
  PVOID pCallStackList;
  DWORD dwCallMarker;
  DWORD dwThreadId;
  struct _THREADFAULT *pNext;
} THREADFAULT, *PTHREADFAULT;

//
// Function definitions
//
PVOID
GetProfilerThreadData(VOID);

VOID
SetProfilerThreadData(PVOID pData);

PTHREADFAULT
AllocateProfilerThreadData(VOID);

VOID
InitializeThreadData(VOID);

#endif //_THREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\shim2.c ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    shim2.c
//
// History:    May-99   clupu       Created.
//             Aug-99   v-johnwh    Various bug fixes.
//          23-Nov-99   markder     Support for multiple shim DLLs, chaining
//                                  of hooks, DLL loads/unloads. General clean-up.
//             Jan-00   markder     Windows 9x support added.
//             Mar-00   a-batjar    Changed to support whistler format on w2k
//             May-00   v-johnwh    Modified to work in the profiler
// Desc:    Contains all code to facilitate hooking of APIs by replacing entries
//          in the import tables of loaded modules.
//
////////////////////////////////////////////////////////////////////////////////////


#include <windows.h>
#include <stdlib.h>
#include <psapi.h>
#include <tlhelp32.h>
#include <imagehlp.h>
#include <stdio.h>
#include "shimdb.h"
#include "shim2.h"

#define HAF_RESOLVED        0x0001
#define HAF_BOTTOM_OF_CHAIN 0x0002

typedef PHOOKAPI   (*PFNNEWGETHOOKAPIS)(DWORD dwGetProcAddress, DWORD dwLoadLibraryA, DWORD dwFreeLibrary, DWORD* pdwHookAPICount);
typedef LPSTR       (*PFNGETCOMMANDLINEA)(VOID);
typedef LPWSTR      (*PFNGETCOMMANDLINEW)(VOID);
typedef PVOID       (*PFNGETPROCADDRESS)(HMODULE hMod, char* pszProc);
typedef HINSTANCE   (*PFNLOADLIBRARYA)(LPCSTR lpLibFileName);
typedef HINSTANCE   (*PFNLOADLIBRARYW)(LPCWSTR lpLibFileName);
typedef HINSTANCE   (*PFNLOADLIBRARYEXA)(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
typedef HINSTANCE   (*PFNLOADLIBRARYEXW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
typedef BOOL        (*PFNFREELIBRARY)(HMODULE hLibModule);

// Global Variables

// Disable build warnings due to Print macro in free builds
#pragma warning( disable : 4002 )

#define MAX_MODULES             512
#define SHIM_GETHOOKAPIS        "GetHookAPIs"

////////////////////////////////////////////////////////////////////////////////////
//          API hook count & indices
////////////////////////////////////////////////////////////////////////////////////



enum
{
   hookGetProcAddress,
   hookLoadLibraryA,
   hookLoadLibraryW,
   hookLoadLibraryExA,
   hookLoadLibraryExW,
   hookFreeLibrary,
   hookGetCommandLineA,
   hookGetCommandLineW
};

////////////////////////////////////////////////////////////////////////////////////
//          Global variables
////////////////////////////////////////////////////////////////////////////////////

//  This array contains information used by the shim mechanism to describe 
//  what API to hook with a particular stub function.
LONG            g_nShimDllCount;
HMODULE         g_hShimDlls[MAX_MODULES];
PHOOKAPI        g_rgpHookAPIs[MAX_MODULES];
LONG            g_rgnHookAPICount[MAX_MODULES];
LPTSTR          g_rgnHookDllList[MAX_MODULES];

HMODULE         g_hHookedModules[MAX_MODULES];
LONG            g_nHookedModuleCount;

extern BOOL     g_bIsWin9X;
HANDLE          g_hSnapshot                   = NULL;
HANDLE          g_hValidationSnapshot         = NULL;




////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   ValidateAddress
//
//  Params: pfnOld              Original API function pointer to validate.
//
//  Return:                     Potentially massaged pfnOld.
//
//  Desc:   Win9x thunks system API entry points for some reason. The
//          shim mechanism has to work around this to get to the
//          'real' pointer so that it can make valid comparisons.
//
PVOID ValidateAddress( PVOID pfnOld )
{
    MODULEENTRY32   ModuleEntry32;
    BOOL            bRet;
    long            i, j;

    // Make sure the address isn't a shim thunk
    for( i = g_nShimDllCount - 1; i >= 0; i-- )
    {
        for( j = 0; j < g_rgnHookAPICount[i]; j++ )
        {
            if( g_rgpHookAPIs[i][j].pfnOld == pfnOld )
            {
                if( pfnOld == g_rgpHookAPIs[i][j].pfnNew )
                    return pfnOld;
            }
        }
    }

    ModuleEntry32.dwSize = sizeof( ModuleEntry32 );
    bRet = Module32First( g_hValidationSnapshot, &ModuleEntry32 );

    while( bRet )
    {
        if( pfnOld >= (PVOID) ModuleEntry32.modBaseAddr &&
            pfnOld <= (PVOID) ( ModuleEntry32.modBaseAddr + ModuleEntry32.modBaseSize ) )
        {
            return pfnOld;
        }

        bRet = Module32Next( g_hValidationSnapshot, &ModuleEntry32 );
    }

    // Hack for Win9x
    return *(PVOID *)( ((PBYTE)pfnOld)+1);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   ConstructChain
//
//  Params: pfnOld              Original API function pointer to resolve.
//
//  Return:                     Top-of-chain PHOOKAPI structure.
//
//  Desc:   Scans HookAPI arrays for pfnOld and either constructs the
//          chain or returns the top-of-chain PHOOKAPI if the chain
//          already exists.
//
PHOOKAPI ConstructChain( PVOID pfnOld ,DWORD* DllListIndex)
{
    LONG                        i, j;
    PHOOKAPI                    pTopHookAPI;
    PHOOKAPI                    pBottomHookAPI;

    pTopHookAPI = NULL;
    pBottomHookAPI = NULL;

    *DllListIndex=0;
    // Scan all HOOKAPI entries for corresponding function pointer
    for( i = g_nShimDllCount - 1; i >= 0; i-- )
    {
        for( j = 0; j < g_rgnHookAPICount[i]; j++ )
        {
            if( g_rgpHookAPIs[i][j].pfnOld == pfnOld )
            {
                if( pTopHookAPI )
                {
                    // Already hooked! Chain them together.
                    pBottomHookAPI->pfnOld = g_rgpHookAPIs[i][j].pfnNew;

                    pBottomHookAPI = &( g_rgpHookAPIs[i][j] );
                    pBottomHookAPI->pNextHook =   pTopHookAPI;
                    pBottomHookAPI->dwFlags = HAF_RESOLVED;
                }
                else
                {
                    if( g_rgpHookAPIs[i][j].pNextHook )
                    {
                        // Chaining has already been constructed.
                        pTopHookAPI = (PHOOKAPI) g_rgpHookAPIs[i][j].pNextHook;
                        *DllListIndex=i;
                        return pTopHookAPI;
                    }

                    // Not hooked yet. Set to top of chain.
                    pTopHookAPI = &( g_rgpHookAPIs[i][j] );
                    pTopHookAPI->pNextHook = pTopHookAPI;
                    pTopHookAPI->dwFlags = HAF_RESOLVED;

                    pBottomHookAPI = pTopHookAPI;
                }

                break;
            }        
        }
    }

    if( pBottomHookAPI )
    {
        pBottomHookAPI->dwFlags = HAF_BOTTOM_OF_CHAIN;
    }
    *DllListIndex=i;
    return pTopHookAPI;
} // ConstructChain

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   HookImports
//
//  Params: dwBaseAddress       Base address of module image to hook.
//
//          szModName           Name of module (for debug purposes only).
//
//  Desc:   This function is the workhorse of the shim: It scans the import
//          table of a module (specified by dwBaseAddress) looking for
//          function pointers that require hooking (according to HOOKAPI
//          entries in g_rgpHookAPIs). It then overwrites hooked function
//          pointers with the first stub function in the chain.
//
VOID HookImports(
    DWORD dwBaseAddress,
    LPTSTR szModName )
{
    BOOL                        bAnyHooked          = FALSE;
    PIMAGE_DOS_HEADER           pIDH                = (PIMAGE_DOS_HEADER) dwBaseAddress;
    PIMAGE_NT_HEADERS           pINTH;
    PIMAGE_IMPORT_DESCRIPTOR    pIID;
    PIMAGE_NT_HEADERS           NtHeaders;
    DWORD                       dwTemp;
    DWORD                       dwImportTableOffset;
    PHOOKAPI                    pTopHookAPI;
    DWORD                       dwOldProtect;
    LONG                        i, j;
    PVOID                       pfnOld;
            
    // Get the import table    
    pINTH = (PIMAGE_NT_HEADERS)(dwBaseAddress + pIDH->e_lfanew);

    dwImportTableOffset = pINTH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    
    if( dwImportTableOffset == 0 )
        return;
    
    pIID = (PIMAGE_IMPORT_DESCRIPTOR)(dwBaseAddress + dwImportTableOffset);
    // Loop through the import table and search for the APIs that we want to patch
    while( TRUE )
    {
        
        LPTSTR             pszModule;
        PIMAGE_THUNK_DATA pITDA;


        // Return if no first thunk
        if (pIID->FirstThunk == 0) // (terminating condition)
           break;

        pszModule = (LPTSTR) ( dwBaseAddress + pIID->Name );
        
        // If we're not interested in this module jump to the next.
        bAnyHooked = FALSE;
        for( i = 0; i < g_nShimDllCount; i++ )
        {            
            for( j = 0; j < g_rgnHookAPICount[i]; j++ )
            {
                if( lstrcmpi( g_rgpHookAPIs[i][j].pszModule, pszModule ) == 0 )
                {
                    bAnyHooked = TRUE;
                    goto ScanDone;
                }
            }
        }

ScanDone:
        if( !bAnyHooked )
        {
            pIID++;
            continue;
        }
        
        // We have APIs to hook for this module!        
        pITDA = (PIMAGE_THUNK_DATA)( dwBaseAddress + (DWORD)pIID->FirstThunk );

        while( TRUE )
        {
            DWORD DllListIndex = 0;

            pfnOld = (PVOID) pITDA->u1.Function;

            // Done with all the imports from this module? 
            if( pITDA->u1.Ordinal == 0 ) // (terminating condition)
                break;

            if( g_bIsWin9X )
                pfnOld = ValidateAddress( pfnOld );

            pTopHookAPI = ConstructChain( (PVOID) pfnOld,&DllListIndex );
            

            if( ! pTopHookAPI )
            {
                pITDA++;
                continue;
            }                        


            /*
             * Check if we want to patch this API for this particular loaded module
             */
            if (NULL != g_rgnHookDllList[DllListIndex])
            {

                LPTSTR  pszMod = g_rgnHookDllList[DllListIndex];
                BOOL    b = FALSE;  //gets set to true if the list is an exclude list

                while (*pszMod != 0) {
                    if (lstrcmpi(pszMod, szModName) == 0)
                        break;
                    if(lstrcmpi(pszMod,TEXT("%")) == 0)
                        b=TRUE;
                    if(b && lstrcmpi(pszMod,TEXT("*")) == 0)
                    {
                        //this means it is exclude all and we already checked include list
                        //skip this api
                        break;
                    }                       
                    pszMod = pszMod + lstrlen(pszMod) + 1;
                }
                if(b && *pszMod != 0) 
                {
                    pITDA++;
                    continue;
                }
                if (!b && *pszMod == 0) 
                {
                    pITDA++;
                    continue;
                }
            }
            
            // Make the code page writable and overwrite new function pointer in import table
            if ( VirtualProtect(  &pITDA->u1.Function,
                                  sizeof(DWORD),
                                  PAGE_READWRITE,
                                  &dwOldProtect) )
            {
                pITDA->u1.Function = (ULONG) pTopHookAPI->pfnNew;
            
                VirtualProtect(   &pITDA->u1.Function,
                                  sizeof(DWORD),
                                  dwOldProtect,
                                  &dwTemp );
            }

            pITDA++;

        }

        pIID++;
    }

} // HookImports


////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   ResolveAPIs
//
//  Desc:   Each time a module is loaded, the pfnOld members of each HOOKAPI
//          structure in g_rgpHookAPIs are resolved (by calling GetProcAddress).
//
VOID ResolveAPIs()
{
    LONG            i, j;
    PVOID           pfnOld          = NULL;
    PIMAGE_NT_HEADERS NtHeaders;

    for (i = 0; i < g_nShimDllCount; i++) 
    {

        for (j = 0; j < g_rgnHookAPICount[i]; j++ ) 
        {

            HMODULE hMod;

            // We only care about HOOKAPIs at the bottom of a chain.
            if( ( g_rgpHookAPIs[i][j].dwFlags & HAF_RESOLVED ) &&
              ! ( g_rgpHookAPIs[i][j].dwFlags & HAF_BOTTOM_OF_CHAIN ) )
                continue;

            if( ( hMod = GetModuleHandle(g_rgpHookAPIs[i][j].pszModule) ) != NULL)
            {
            
                pfnOld = GetProcAddress( hMod, g_rgpHookAPIs[i][j].pszFunctionName );

                if( pfnOld == NULL ) 
                {
                
                    // This is an ERROR. The hook DLL asked to patch a function
                    // that doesn't exist !!!
                }
                else
                {                    
                    if( g_bIsWin9X )
                        pfnOld = ValidateAddress( pfnOld );

                    g_rgpHookAPIs[i][j].pfnOld = pfnOld;
                }
            }
        }
    }

} // ResolveAPIs

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   PatchNewModules
//
//  Desc:   This function is called at initialization and then each time a module
//          is loaded. It enumerates all loaded processes and calls HookImports
//          to overwrite appropriate function pointers.
//
void __stdcall Shim2PatchNewModules( VOID )
{
    DWORD   i;
    LONG    j;
    BOOL    bRet;
    HMODULE hMod;

    MODULEENTRY32 ModuleEntry32;

    // Enumerate all the loaded modules and hook their import tables
    g_hSnapshot = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, 0 );
    g_hValidationSnapshot = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, 0 );

    if( g_hSnapshot == NULL ) 
    {
        return;
    }

    // Resolve old APIs for loaded modules
    ResolveAPIs();
    
    ModuleEntry32.dwSize = sizeof( ModuleEntry32 );
    bRet = Module32First( g_hSnapshot, &ModuleEntry32 );

    while( bRet )
    {
        hMod = ModuleEntry32.hModule;

        if( hMod >= (HMODULE) 0x80000000 )
        {
            bRet = Module32Next( g_hSnapshot, &ModuleEntry32 );
            continue;
        }

        // we need to make sure we are not trying to shim ourselves
        for (j = 0; j < g_nShimDllCount; j++ )
        {
            if( hMod == g_hShimDlls[j] )
            {
                hMod = NULL;
                break;
            }
        }

        for (j = 0; j < g_nHookedModuleCount; j++ )
        {
            if( hMod == g_hHookedModules[ j ] )
            {
                hMod = NULL;
                break;
            }
        }

        if( hMod )
        {
            HookImports( (DWORD) hMod, ModuleEntry32.szModule );

            g_hHookedModules[ g_nHookedModuleCount++ ] = hMod;
        }

        bRet = Module32Next( g_hSnapshot, &ModuleEntry32 );
    }

    if( g_hSnapshot )
    {
        CloseHandle( g_hSnapshot );
        g_hSnapshot = NULL;
    }

    if( g_hValidationSnapshot )
    {
        CloseHandle( g_hValidationSnapshot );
        g_hValidationSnapshot = NULL;
    }
} //PatchNewModules

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   AddHookAPIs
//
//  Params: hShimDll            Handle of new shim DLL.
//
//          pHookAPIs           Pointer to new HOOKAPI array.
//
//          dwCount             Number of entries in pHookAPIs.
//
//  Desc:   Stores away the pointer returned by a shim DLL's GetHookAPIs
//          function in our global arrays.
//
void AddHookAPIs( HMODULE hShimDll, PHOOKAPI pHookAPIs, DWORD dwCount,LPTSTR szIncExclDllList)
{
    DWORD i;

    for( i = 0; i < dwCount; i++ )
    {
        pHookAPIs[i].dwFlags = 0;
        pHookAPIs[i].pNextHook = NULL;
    }

    g_rgpHookAPIs[ g_nShimDllCount ] = pHookAPIs;
    g_rgnHookAPICount[ g_nShimDllCount ] = dwCount;
    g_hShimDlls[ g_nShimDllCount ] = hShimDll;

    g_rgnHookDllList[g_nShimDllCount ] = szIncExclDllList;

    g_nShimDllCount++;
} // AddHookAPIs

////////////////////////////////////////////////////////////////////////////////////
//
//  Func:   _LoadPatchDll
//
//  Params: pwszPatchDll        Name of shim DLL to be loaded.
//
//  Return:                     TRUE if successful, FALSE if not.
//
//  Desc:   Loads a shim DLL and retrieves the hooking information via GetHookAPIs.
//
BOOL _LoadPatchDll(
    LPWSTR szPatchDll,LPSTR szCmdLine,LPSTR szIncExclDllList)
{
    PHOOKAPI pHookAPIs = NULL;
    DWORD dwHookAPICount = 0;
    HMODULE hModHookDll;
    PFNGETHOOKAPIS pfnGetHookAPIs;

    hModHookDll = LoadLibraryW(szPatchDll);

    if (hModHookDll == NULL) 
    {
        return FALSE;
    }
    
    pfnGetHookAPIs = (PFNGETHOOKAPIS) GetProcAddress( hModHookDll, SHIM_GETHOOKAPIS );

    if( pfnGetHookAPIs == NULL )
    {
        FreeLibrary( hModHookDll );
        return FALSE;
    }

    pHookAPIs = (*pfnGetHookAPIs)(szCmdLine, Shim2PatchNewModules, &dwHookAPICount );

    if( dwHookAPICount == 0  || pHookAPIs == NULL )
    {
        FreeLibrary( hModHookDll );
        return FALSE;
    }

    AddHookAPIs( hModHookDll, pHookAPIs, dwHookAPICount,szIncExclDllList);
    
    return TRUE;
} // _LoadPatchDll

// Re-enable build warnings.
#pragma warning( default : 4002 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\vxd\debug.c ===
#include <basedef.h>
#include <vmm.h>
#include <vwin32.h>

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

VOID
DbgPrint(PCHAR pszString)
{
    _asm pushfd                              ; save flags on stack
    _asm pushad                              ; save registers on stack
    _asm mov esi,pszString                   ; points to string to write
    VMMCall( Out_Debug_String );
    _asm popad
    _asm popfd
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\vxd\dispatch.c ===
#include <basedef.h>
#include <vmm.h>
#include <vwin32.h>
#include "ntddpack.h"
#include "except.h"
#include "exvector.h"

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

extern PVOID C_Handle_Trap_1;
extern PVOID C_Handle_Trap_3;
extern DWORD pfnHandler;
extern PVOID pProcessHandle;

BOOL
DriverControl(DWORD dwMessage)
{
    switch (dwMessage)
    {
        case 0:
             _asm mov eax, 1
             _asm mov esi, offset C_Handle_Trap_1
             VMMCall( Hook_PM_Fault );

             _asm mov eax, 3
             _asm mov esi, offset C_Handle_Trap_3
             VMMCall( Hook_PM_Fault );

             break;

        case 1:
             _asm mov eax, 1
             _asm mov esi, offset C_Handle_Trap_1
             VMMCall( Unhook_PM_Fault );
   
             _asm mov eax, 3
             _asm mov esi, offset C_Handle_Trap_3
             VMMCall( Unhook_PM_Fault );
             
             break;

        default:
             0;
    }

    return STATUS_SUCCESS;
}

DWORD 
_stdcall 
DriverIOControl(DWORD dwService,
                DWORD dwDDB,
                DWORD hDevice,
                PDIOCPARAMETERS pDiocParms) 
/*++

Routine Description:

    This is the dispatch routine for create/open and close requests.
    These requests complete successfully.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{  
    PVOID pInputParams;

    switch ( dwService )
    {
	case DIOC_OPEN:
             //
             // Nothing to do
             //
	     break;

	case DIOC_CLOSEHANDLE:
             //
             // If our client for the except handler is going away, initialize the exception handler data
             //
             if (pProcessHandle == VWIN32_GetCurrentProcessHandle()) {
                pfnHandler = 0;
                pProcessHandle = 0;                
             }

             break;
 
        case INSTALL_RING_3_HANDLER:
             //
             // See if we already have a client
             //
             if (pProcessHandle) {
                return STATUS_UNSUCCESSFUL;
             }

             pProcessHandle = VWIN32_GetCurrentProcessHandle();

             //
             // Copy the handler into our global
             //
             pInputParams = (PVOID)(pDiocParms->lpvInBuffer);
             _asm mov eax, pInputParams
             _asm mov eax, [eax]
             _asm mov pfnHandler, eax

             break;

        default:   
             //
             // Error, Unrecognized IOCTL
             //
	     *(DWORD *)(pDiocParms->lpcbBytesReturned) = 0;

	     break;
    }

    return STATUS_SUCCESS;
}

//
// Helper function for maintaining context information between ring levels
//
VOID
FillContextRecord(PCRS pcrs,
                  PCONTEXT pContext)
{
    DWORD dwDebugRegister;

    //
    // Clear trace and direction flags for the exception dispatcher
    //
    pcrs->Client_EFlags &= ~(TF_MASK | DF_MASK);

    //
    // Fill context record
    //
    pContext->Eax = pcrs->Client_EAX;
    pContext->Ebx = pcrs->Client_EBX;
    pContext->Ecx = pcrs->Client_ECX;
    pContext->Edx = pcrs->Client_EDX;
    pContext->Esi = pcrs->Client_ESI;
    pContext->Edi = pcrs->Client_EDI;
    pContext->Eip = pcrs->Client_EIP;
    pContext->Ebp = pcrs->Client_EBP;
    pContext->Esp = pcrs->Client_ESP;
    pContext->SegGs = pcrs->Client_GS;
    pContext->SegFs = pcrs->Client_FS;
    pContext->SegEs = pcrs->Client_ES;
    pContext->SegDs = pcrs->Client_DS;
    pContext->SegCs = pcrs->Client_CS;
    pContext->EFlags = pcrs->Client_EFlags;

    //
    // Store the debug registers
    //
    _asm mov eax, dr0
    _asm mov dwDebugRegister, eax
    pContext->Dr0 = dwDebugRegister;
    _asm mov eax, dr1
    _asm mov dwDebugRegister, eax
    pContext->Dr1 = dwDebugRegister;
    _asm mov eax, dr2
    _asm mov dwDebugRegister, eax
    pContext->Dr2 = dwDebugRegister;
    _asm mov eax, dr3
    _asm mov dwDebugRegister, eax
    pContext->Dr3 = dwDebugRegister;
    _asm mov eax, dr6
    _asm mov dwDebugRegister, eax
    pContext->Dr6 = dwDebugRegister;
    _asm mov eax, dr7
    _asm mov dwDebugRegister, eax
    pContext->Dr7 = dwDebugRegister;

    //
    // This is a full context
    //
    pContext->ContextFlags = (DWORD)-1;
}

VOID
RestorePCRS(PCRS pcrs,
            PCONTEXT pContext)
{
    DWORD dwDebugRegister;

    //
    // Restore pcrs
    //
    pcrs->Client_EAX = pContext->Eax;
    pcrs->Client_EBX = pContext->Ebx;
    pcrs->Client_ECX = pContext->Ecx;
    pcrs->Client_EDX = pContext->Edx;
    pcrs->Client_ESI = pContext->Esi;
    pcrs->Client_EDI = pContext->Edi;
    pcrs->Client_EIP = pContext->Eip;
    pcrs->Client_EBP = pContext->Ebp;
    pcrs->Client_ESP = pContext->Esp;
    pcrs->Client_GS = pContext->SegGs;
    pcrs->Client_FS = pContext->SegFs;
    pcrs->Client_ES = pContext->SegEs;
    pcrs->Client_DS = pContext->SegDs;
    pcrs->Client_CS = pContext->SegCs;
    pcrs->Client_EFlags = pContext->EFlags;

    //
    // Restore the debug registers
    //
    dwDebugRegister = pContext->Dr0;
    _asm mov eax, dwDebugRegister
    _asm mov dr0, eax
    dwDebugRegister = pContext->Dr1;
    _asm mov eax, dwDebugRegister
    _asm mov dr1, eax
    dwDebugRegister = pContext->Dr2;
    _asm mov eax, dwDebugRegister
    _asm mov dr2, eax
    dwDebugRegister = pContext->Dr3;
    _asm mov eax, dwDebugRegister
    _asm mov dr3, eax
    dwDebugRegister = pContext->Dr6;
    _asm mov eax, dwDebugRegister
    _asm mov dr6, eax
    dwDebugRegister = pContext->Dr7;
    _asm mov eax, dwDebugRegister
    _asm mov dr7, eax
}

//
// Exception dispatching routine
//
BOOL
__cdecl
C_Trap_Exception_Handler(ULONG ExceptionNumber,
                         PCRS pcrs)
{
    DWORD dwException = ExceptionNumber >> 2;
    PEXCEPTION_RECORD pExceptionRecord;
    PCONTEXT pContextRecord;
    PSTACKFRAME pStackFrame;
    ULONG Result;
    ULONG StackTop;
    ULONG Length;

    //
    // Make sure our current thread is Win32
    //
    if (FALSE == VWIN32_IsClientWin32()) {
       return FALSE;
    }

    //
    // Make sure we only handle exceptions for our controlling "process"
    //
    if (pProcessHandle != VWIN32_GetCurrentProcessHandle()) {
       return FALSE;
    }

    //
    // If selector isn't flat, we can't handle this exception
    //
    if ((pcrs->Client_SS != pcrs->Client_DS) ||
        (pcrs->Client_SS != pcrs->Client_ES)){
       return FALSE;
    }

    //
    // See if this is a context set
    //
    if (SET_CONTEXT == *(DWORD *)(pcrs->Client_EIP)) {
       //
       // Set the context data
       //
       pContextRecord = *(DWORD *)(pcrs->Client_ESP + 0x10);
  
       RestorePCRS(pcrs,
                   pContextRecord);
           
       return TRUE;
    }

    //
    // Move stack pointer down one context record length
    //
    StackTop = (pcrs->Client_ESP & ~3) - ((sizeof(CONTEXT) + 3) & ~3);
    pContextRecord = (PCONTEXT) StackTop;

    FillContextRecord(pcrs,
                      pContextRecord);

    //
    // Adjust eip for breakpoint exceptions
    //
    if (3 == dwException) {
       pContextRecord->Eip -= 1;
    }

    Length = (sizeof(EXCEPTION_RECORD) - (EXCEPTION_MAXIMUM_PARAMETERS - 2) *
             sizeof(*pExceptionRecord->ExceptionInformation) + 3) & ~3;

    //
    // We are now at the Exception Record
    //
    StackTop = StackTop - Length;
    pExceptionRecord = (PEXCEPTION_RECORD)StackTop;

    pExceptionRecord->ExceptionFlags = 0;
    pExceptionRecord->ExceptionRecord = 0;
    pExceptionRecord->ExceptionAddress = (PVOID)pcrs->Client_EIP;
    pExceptionRecord->NumberParameters = 0;

    switch (dwException) {
        case 1:
            pExceptionRecord->ExceptionCode = STATUS_SINGLE_STEP;
            break;

        case 3:
            pExceptionRecord->ExceptionCode = STATUS_BREAKPOINT;
            pExceptionRecord->NumberParameters = 1;
            pExceptionRecord->ExceptionInformation[0] = BREAKPOINT_BREAK;
            pExceptionRecord->ExceptionAddress = (PVOID)pContextRecord->Eip;            
            break;

        default:
            0;
    }

    //
    // Setup the exception call frame
    //
    StackTop = StackTop - sizeof(STACKFRAME);
    pStackFrame = (PSTACKFRAME) StackTop;

    pStackFrame->ExceptPointers.ExceptionRecord = pExceptionRecord;
    pStackFrame->ExceptPointers.ContextRecord = pContextRecord;
    pStackFrame->pExceptPointers = (PVOID)(StackTop + 0x08);
    pStackFrame->RetAddress = (PVOID)0xffecbad7;  // App will page fault out if unexpected exception occurs

    //
    // Transfer control to Ring 3 handler
    //
    pcrs->Client_ESP = (ULONG)pStackFrame;
    pcrs->Client_EIP = (ULONG)pfnHandler;

    return TRUE;

SkipHandler:

    //
    // We didn't process the exception give it to the next handler
    //
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\vxd\exvector.asm ===
.LALL

    TITLE $EXVECTOR
    .386P

INCLUDE VMM.INC
INCLUDE EXVECTOR.INC

; the following equate makes the VXD dynamically loadable.
%DEVICE_DYNAMIC EQU 1

DECLARE_VIRTUAL_DEVICE %DEVICE, 1, 0, <%DEVICE>_Control, Undefined_Device_Id, Vmm_init_order

;
; LData
;
VxD_LOCKED_DATA_SEG

Public bInitAlready	
	bInitAlready	 DB 0
Public _pPrevHook1
	_pPrevHook1      DD 0
Public _pPrevHook3
	_pPrevHook3      DD 0
Public _pfnHandler
	_pfnHandler      DD 0
Public _pProcessHandle
        _pProcessHandle  DD 0

VxD_LOCKED_DATA_ENDS


;
; LCode
;
VxD_LOCKED_CODE_SEG

Begin_Control_Dispatch %DEVICE

    Control_Dispatch Sys_Dynamic_Device_Init,	_C_Device_Init
    Control_Dispatch Sys_Dynamic_Device_Exit,	_C_Device_Exit
    Control_Dispatch W32_DEVICEIOCONTROL,    	DriverIOControl, sCall, <ecx, ebx, edx, esi>

End_Control_Dispatch %DEVICE

BeginProc _C_Device_Init

IFDEF _STDCALL
	extern _DriverControl@4:NEAR
ELSE
	extern _DriverControl:NEAR
ENDIF

   mov  		al, bInitAlready
   cmp  		al, 0					; Make sure we' haven't been called already.
   jnz  		Succeed_Init_Phase
   inc  		bInitAlready			; Set the "Called Already" Flag

   push 		0

IFDEF _STDCALL
   call 		_DriverControl@4
ELSE
   call 		_DriverControl
   add  		esp,4
ENDIF

   cmp  		eax, 1
   jz  		        Fail_Init_Phase

Succeed_Init_Phase:
   clc
   ret

Fail_Init_Phase:
   stc
   ret

EndProc _C_Device_Init
 
BeginProc _C_Device_Exit

IFDEF _STDCALL
	extern _DriverControl@4:NEAR
ELSE
	extern _DriverControl:NEAR
ENDIF

   push 		1

IFDEF _STDCALL
   call 		_DriverControl@4
ELSE
   call 		_DriverControl
   add  		esp,4
ENDIF

   cmp  		eax, 1
   jz  		        Fail_Exit_Phase

Succeed_Exit_Phase:
   clc
   ret

Fail_Exit_Phase:
   stc
   ret

EndProc _C_Device_Exit

BeginProc _C_Handle_Trap_1, HOOK_PROC, _pPrevHook1, LOCKED

    extern _C_Trap_Exception_Handler:NEAR

    pushfd
    pushad

    cli

    cCall _C_Trap_Exception_Handler, <esi, ebp>

    sti

    cmp eax, 0
    jnz Trap1_Handled

    ;Try the next handler
    cmp [_pPrevHook1], 0
    jz Trap1_Handled

    ;Here we go
    popad
    popfd
    jmp [_pPrevHook1]
    
Trap1_Handled:
    popad
    popfd
    ret
EndProc _C_Handle_Trap_1

BeginProc _C_Handle_Trap_3, HOOK_PROC, _pPrevHook3, LOCKED

    extern _C_Trap_Exception_Handler:NEAR

    pushfd
    pushad

    cli

    cCall _C_Trap_Exception_Handler, <esi, ebp>

    sti

    cmp eax, 0
    jnz Trap3_Handled

    ;Try the next handler
    cmp [_pPrevHook3], 0
    jz Trap3_Handled

    ;Here we go
    popad
    popfd
    jmp [_pPrevHook3]
    
Trap3_Handled:
    popad
    popfd
    ret
EndProc _C_Handle_Trap_3

VxD_LOCKED_CODE_ENDS

;
; Not using IData or ICode
;

;
; Or RCode
;

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\vxd\exvector.inc ===
ifndef _EXVECT_

_EXVECT_	EQU	1

EXVECT_WIN	EQU	1
EXPORT	EQU	1
EXVECT_MAJOR_VERSION	EQU	01H
EXVECT_MINOR_VERSION	EQU	00H

LCODE_SEG   TEXTEQU <VXD_LOCKED_CODE_SEG>
LCODE_ENDS  TEXTEQU <VXD_LOCKED_CODE_ENDS>
LDATA_SEG   TEXTEQU <VXD_LOCKED_DATA_SEG>
LDATA_ENDS  TEXTEQU <VXD_LOCKED_DATA_ENDS>

IFDEF DEBUG
    PCODE_SEG   TEXTEQU <LCODE_SEG>
    PCODE_ENDS  TEXTEQU <LCODE_ENDS>
    PDATA_SEG   TEXTEQU <LDATA_SEG>
    PDATA_ENDS  TEXTEQU <LDATA_ENDS>
ELSE
    PCODE_SEG   TEXTEQU <VXD_PAGEABLE_CODE_SEG>
    PCODE_ENDS  TEXTEQU <VXD_PAGEABLE_CODE_ENDS>
    PDATA_SEG   TEXTEQU <VXD_PAGEABLE_DATA_SEG>
    PDATA_ENDS  TEXTEQU <VXD_PAGEABLE_DATA_ENDS>
ENDIF

ICODE_SEG   TEXTEQU <PCODE_SEG>
ICODE_ENDS  TEXTEQU <PCODE_ENDS>
IDATA_SEG   TEXTEQU <PDATA_SEG>
IDATA_ENDS  TEXTEQU <PDATA_ENDS>

HIGH_LEVEL	EQU	31
PDRIVER_OBJECT	EQU	<PVOID>
PUNICODE_STRING	EQU	<PVOID>
PDEVICE_OBJECT	EQU	<PVOID>
PKDPC	EQU	<PVOID>
STATUS_SUCCESS EQU 0

ifndef i386
i386	EQU	1
endif

ifndef TRUE
TRUE	EQU	1
FALSE	EQU	0
endif

endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\vxd\except.h ===
#ifndef _EXCEPT_
#define _EXCEPT_

typedef LONG (*PFNUNHANDLEDEXCEPTION)(struct _EXCEPTION_POINTERS *ExceptionInfo);
#define EXCEPTION_MAXIMUM_PARAMETERS 15 // maximum number of exception parameters
#define SIZE_OF_80387_REGISTERS      80
#define MAXIMUM_SUPPORTED_EXTENSION     512
#define BREAKPOINT_BREAK 0

typedef struct _FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[SIZE_OF_80387_REGISTERS];
    DWORD   Cr0NpxState;
} FLOATING_SAVE_AREA;

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;

//
// Context Frame
//

typedef struct _CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              // MUST BE SANITIZED
    DWORD   EFlags;             // MUST BE SANITIZED
    DWORD   Esp;
    DWORD   SegSs;

    //
    // This section is specified/returned if the ContextFlags word
    // contains the flag CONTEXT_EXTENDED_REGISTERS.
    // The format and contexts are processor specific
    //

    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];

} CONTEXT;

typedef CONTEXT *PCONTEXT;

//
// Exception record definition.
//

typedef struct _EXCEPTION_RECORD {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    UINT ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
    } EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;

typedef struct _STACKFRAME {
  PVOID RetAddress;
  PVOID pExceptPointers;
  EXCEPTION_POINTERS ExceptPointers;
} STACKFRAME, *PSTACKFRAME;

#define STATUS_WAIT_0                    ((DWORD   )0x00000000L)    
#define STATUS_ABANDONED_WAIT_0          ((DWORD   )0x00000080L)    
#define STATUS_USER_APC                  ((DWORD   )0x000000C0L)    
#define STATUS_TIMEOUT                   ((DWORD   )0x00000102L)    
#define STATUS_PENDING                   ((DWORD   )0x00000103L)    
#define STATUS_SEGMENT_NOTIFICATION      ((DWORD   )0x40000005L)    
#define STATUS_GUARD_PAGE_VIOLATION      ((DWORD   )0x80000001L)    
#define STATUS_DATATYPE_MISALIGNMENT     ((DWORD   )0x80000002L)    
#define STATUS_BREAKPOINT                ((DWORD   )0x80000003L)    
#define STATUS_SINGLE_STEP               ((DWORD   )0x80000004L)    
#define STATUS_ACCESS_VIOLATION          ((DWORD   )0xC0000005L)    
#define STATUS_IN_PAGE_ERROR             ((DWORD   )0xC0000006L)    
#define STATUS_INVALID_HANDLE            ((DWORD   )0xC0000008L)    
#define STATUS_NO_MEMORY                 ((DWORD   )0xC0000017L)    
#define STATUS_ILLEGAL_INSTRUCTION       ((DWORD   )0xC000001DL)    
#define STATUS_NONCONTINUABLE_EXCEPTION  ((DWORD   )0xC0000025L)    
#define STATUS_INVALID_DISPOSITION       ((DWORD   )0xC0000026L)    
#define STATUS_ARRAY_BOUNDS_EXCEEDED     ((DWORD   )0xC000008CL)    
#define STATUS_FLOAT_DENORMAL_OPERAND    ((DWORD   )0xC000008DL)    
#define STATUS_FLOAT_DIVIDE_BY_ZERO      ((DWORD   )0xC000008EL)    
#define STATUS_FLOAT_INEXACT_RESULT      ((DWORD   )0xC000008FL)    
#define STATUS_FLOAT_INVALID_OPERATION   ((DWORD   )0xC0000090L)    
#define STATUS_FLOAT_OVERFLOW            ((DWORD   )0xC0000091L)    
#define STATUS_FLOAT_STACK_CHECK         ((DWORD   )0xC0000092L)    
#define STATUS_FLOAT_UNDERFLOW           ((DWORD   )0xC0000093L)    
#define STATUS_INTEGER_DIVIDE_BY_ZERO    ((DWORD   )0xC0000094L)    
#define STATUS_INTEGER_OVERFLOW          ((DWORD   )0xC0000095L)    
#define STATUS_PRIVILEGED_INSTRUCTION    ((DWORD   )0xC0000096L)    
#define STATUS_STACK_OVERFLOW            ((DWORD   )0xC00000FDL)    
#define STATUS_CONTROL_C_EXIT            ((DWORD   )0xC000013AL)    
#define STATUS_FLOAT_MULTIPLE_FAULTS     ((DWORD   )0xC00002B4L)    
#define STATUS_FLOAT_MULTIPLE_TRAPS      ((DWORD   )0xC00002B5L)    
#define STATUS_ILLEGAL_VLM_REFERENCE     ((DWORD   )0xC00002C0L)     

/*
 *  EFLAGs bit assignments
 */
#define CF_BIT	    0
#define CF_MASK     (1 << CF_BIT)
#define PF_BIT	    2
#define PF_MASK     (1 << PF_BIT)
#define AF_BIT	    4
#define AF_MASK     (1 << AF_BIT)
#define ZF_BIT	    6
#define ZF_MASK     (1 << ZF_BIT)
#define SF_BIT	    7
#define SF_MASK     (1 << SF_BIT)
#define TF_BIT	    8
#define TF_MASK     (1 << TF_BIT)
#define IF_BIT	    9
#define IF_MASK     (1 << IF_BIT)
#define DF_BIT	    10
#define DF_MASK     (1 << DF_BIT)
#define OF_BIT	    11	/* Overflow flag */
#define OF_MASK     (1 << OF_BIT)
#define IOPL_MASK   0x3000  /* IOPL flags */
#define IOPL_BIT0   12
#define IOPL_BIT1   13
#define NT_BIT	    14	/* Nested task flag */
#define NT_MASK     (1 << NT_BIT)
#define RF_BIT	    16	/* Resume flag */
#define RF_MASK     (1 << RF_BIT)
#define VM_BIT	    17	/* Virtual Mode flag */
#define VM_MASK     (1 << VM_BIT)
#define AC_BIT	    18	/* Alignment check */
#define AC_MASK     (1 << AC_BIT)
#define VIF_BIT     19	/* Virtual Interrupt flag */
#define VIF_MASK    (1 << VIF_BIT)
#define VIP_BIT     20	/* Virtual Interrupt pending */
#define VIP_MASK    (1 << VIP_BIT)

#endif  //_EXCEPT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\makediff\main.h ===
#ifndef _MAIN_H_
#define _MAIN_H_

//
// Structure definitions
//
typedef struct _BASEINFO
{
	CHAR szModule[32];
	DWORD dwStartAddress;
	DWORD dwEndAddress;
	struct _BASEINFO *pNext;
} BASEINFO, *PBASEINFO;

typedef struct _THREADINFO
{
	DWORD dwThreadId;
	HANDLE hFile;
	struct _THREADINFO *pNext;
} THREADINFO, *PTHREADINFO;

//
// Function definitions
//
VOID
CloseThreadHandles(VOID);

BOOL
ProcessRuntimeData(PCHAR pszFile, PCHAR pszBaseFileName);

BOOL
FillBufferWithRelocationInfo(PCHAR pszDestination,
							 DWORD dwAddress);

BOOL
AddThreadInformation(PCHAR pszBaseFileName,
					 PTHREADSTART pThreadStart);

BOOL
AddExeFlowInformation(PEXEFLOW pExeFlow);

BOOL
AddToBaseInformation(PDLLBASEINFO pDLLBaseInfo);

BOOL
AddMappedInformation(PCHAR pszBaseFileName,
					 PMAPINFO pMapInfo);

BOOL
AddErrorInformation(PCHAR pszBaseFileName,
					PERRORINFO pErrorInfo);

#endif //_MAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\vxd\exvector.h ===
#ifndef _EXVECTOR_
#define _EXVECTOR_

#define NDIS_WIN     1
#define EXPORT

/* NOINC */

#ifndef _STDCALL
#define _STDCALL    1
#endif

#ifdef _STDCALL
#define _API __stdcall
#else
#define _API
#endif

//
//    Segment definition macros.  These assume the segment groupings used by
//    Chicago/MS-DOS 7.
//

#define _LCODE code_seg("_LTEXT", "LCODE")
#define _LDATA data_seg("_LDATA", "LCODE")


#ifdef DEBUG
    #define _PCODE NDIS_LCODE
    #define _PDATA NDIS_LDATA
#else
    #define _PCODE code_seg("_PTEXT", "PCODE")
    #define _PDATA data_seg("_PDATA", "PCODE")
#endif

#define _ICODE NDIS_PCODE
#define _IDATA NDIS_PDATA

#ifndef _SEG_MACROS
    #define ICODE   NDIS_ICODE
    #define IDATA   NDIS_IDATA
    #define PCODE   NDIS_PCODE
    #define PDATA   NDIS_PDATA
    #define LCODE   NDIS_LCODE
    #define LDATA   NDIS_LDATA
#endif

#define _INIT_FUNCTION(f)       alloc_text(_ITEXT,f)
#define _PAGEABLE_FUNCTION(f)   alloc_text(_PTEXT,f)
#define _LOCKED_FUNCTION(f)     alloc_text(_LTEXT,f)

/* INC */
#define _MAJOR_VERSION          0x01
#define _MINOR_VERSION          0x00
/* NOINC */

/* INC */
/* ASM
;===========================================================================
;    Segment definition macros.  These assume the segment groupings used by
;    Chicago/MS-DOS 7.
;
;===========================================================================

LCODE_SEG   TEXTEQU <VXD_LOCKED_CODE_SEG>
LCODE_ENDS  TEXTEQU <VXD_LOCKED_CODE_ENDS>
LDATA_SEG   TEXTEQU <VXD_LOCKED_DATA_SEG>
LDATA_ENDS  TEXTEQU <VXD_LOCKED_DATA_ENDS>

IFDEF DEBUG
    PCODE_SEG   TEXTEQU <LCODE_SEG>
    PCODE_ENDS  TEXTEQU <LCODE_ENDS>
    PDATA_SEG   TEXTEQU <LDATA_SEG>
    PDATA_ENDS  TEXTEQU <LDATA_ENDS>
ELSE
	PCODE_SEG   TEXTEQU <VXD_PAGEABLE_CODE_SEG>
	PCODE_ENDS  TEXTEQU <VXD_PAGEABLE_CODE_ENDS>
	PDATA_SEG   TEXTEQU <VXD_PAGEABLE_DATA_SEG>
	PDATA_ENDS  TEXTEQU <VXD_PAGEABLE_DATA_ENDS>
ENDIF

ICODE_SEG   TEXTEQU <PCODE_SEG>
ICODE_ENDS  TEXTEQU <PCODE_ENDS>
IDATA_SEG   TEXTEQU <PDATA_SEG>
IDATA_ENDS  TEXTEQU <PDATA_ENDS>


*/

#ifndef i386
#define i386
#endif

/* NOINC */

#ifdef DEBUG
    #define DEVL             1
#endif

/* INC */

#ifndef TRUE
#define TRUE  1
#define FALSE 0
#endif

/* NOINC */
#include <basedef.h>

#define ASSERT(a)       if (!(a)) DbgBreakPoint()

#ifdef DEBUG
#define DbgBreakPoint() __asm { \
			 __asm int  3 \
			 }
void __cdecl DbgPrint();
#define DBG_PRINTF(A) DbgPrint A
#else
#define DbgBreakPoint()
#define DBG_PRINTF(A)
#endif

//
// Macros required by DOS to compensate for differences with NT.
//

#define IN
#define OUT
#define OPTIONAL
#define INTERNAL
#define UNALIGNED

typedef INT NDIS_SPIN_LOCK, * PNDIS_SPIN_LOCK;

typedef UCHAR BOOLEAN, *PBOOLEAN;

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

typedef signed short WCH, *PWCH;

typedef char CCHAR, *PCCHAR;

typedef PVOID NDIS_HANDLE, *PNDIS_HANDLE;

typedef DWORD                   DEVNODE;

typedef ULONG _STATUS;
typedef _STATUS *_PSTATUS;

// BUGBUG for compatibility with NT, ask them to remove it from
// Their drivers
typedef _STATUS NTSTATUS;
typedef CCHAR KIRQL;
typedef KIRQL *PKIRQL;
#define HIGH_LEVEL 31
#define PDRIVER_OBJECT PVOID
#define PUNICODE_STRING PVOID
#define PDEVICE_OBJECT PVOID
#define PKDPC PVOID

#define STATUS_SUCCESS 0
#define STATUS_UNSUCCESSFUL 0xC0000001
#define INSTALL_RING_3_HANDLER 0x42424242
#define SET_CONTEXT 0xc3c3c3cc

BOOL
VXDINLINE
VWIN32_IsClientWin32( VOID )
{
	VxDCall( _VWIN32_IsClientWin32 );
}

PVOID
VXDINLINE
VWIN32_GetCurrentProcessHandle( VOID )
{
	VxDCall( VWIN32_GetCurrentProcessHandle );
}

PVOID
VXDINLINE
VWIN32_Set_Thread_Context(PVOID pR0ThreadHandle,
                          PCONTEXT pContext)
{
	VxDCall( _VWIN32_Set_Thread_Context );
}

#endif  // _EXVECTOR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\makediff\main.c ===
#include <windows.h>
#include <stdio.h>
#include "dump.h"
#include "main.h"

PBASEINFO g_BaseHead = 0;
PTHREADINFO g_ThreadHead = 0;
DWORD g_dwThreadCount = 0;
HANDLE g_MapInformation = INVALID_HANDLE_VALUE;
HANDLE g_ErrorInformation = INVALID_HANDLE_VALUE;

int
_cdecl
main(int argc, char *argv[])
{
    PCHAR pszFile;
    PCHAR pszBaseFileName;
    BOOL bResult;

    if (argc < 3) {
	   return -1;
    }

    pszFile = argv[1]; //1st parameter
    pszBaseFileName = argv[2]; //2nd parameter

    bResult = ProcessRuntimeData(pszFile, pszBaseFileName);
    if (FALSE == bResult) {
       return -1;
    }

    //
    // Close any open file handles
    //
    if (INVALID_HANDLE_VALUE != g_MapInformation) {
       CloseHandle(g_MapInformation);
    }

    if (INVALID_HANDLE_VALUE != g_ErrorInformation) {
       CloseHandle(g_ErrorInformation);
    }

    CloseThreadHandles();

    return 0;
}

BOOL
ProcessRuntimeData(PCHAR pszFile, PCHAR pszBaseFileName)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = 0;
    BOOL bResult = FALSE;
    PVOID pFileBits = 0;
    PBYTE pMappedBits;
    LONG lFileSize;
	 
    //
    // Get our file online and start the data processing
    //
    hFile = CreateFileA(pszFile,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        0,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        0);						
    if (INVALID_HANDLE_VALUE == hFile) {
       bResult = FALSE;

       goto HandleError;
    }

    lFileSize = GetFileSize(hFile,
	                    0);

    //
    // Process the data stream
    //
    hMap = CreateFileMapping(hFile,
	                     0,
                             PAGE_READWRITE,
                             0,
                             0,
                             0);
    if (0 == hMap) {
       bResult = FALSE;

       goto HandleError;
    }

    pFileBits = MapViewOfFile(hMap,
	                      FILE_MAP_READ,
                              0,
                              0,
                              0);
    if (0 == pFileBits) {
       bResult = FALSE;

       goto HandleError;
    }

    pMappedBits = (PBYTE)pFileBits;

    //
    // Process stream data
    //
    while (lFileSize > 0) {
        switch(*pMappedBits) {
	        case ThreadStartId:
				bResult = AddThreadInformation(pszBaseFileName,
					                           (PTHREADSTART)pMappedBits);
				if (FALSE == bResult) {
				   goto HandleError;
				}

				lFileSize -= sizeof(THREADSTART);
				pMappedBits += sizeof(THREADSTART);
			    break;

		    case ExeFlowId:
				bResult = AddExeFlowInformation((PEXEFLOW)pMappedBits);
			//	if (FALSE == bResult) {
			//	   goto HandleError;
			//	}

				lFileSize -= sizeof(EXEFLOW);
				pMappedBits += sizeof(EXEFLOW);
			    break;

		    case DllBaseInfoId:
				bResult = AddToBaseInformation((PDLLBASEINFO)pMappedBits);
				if (FALSE == bResult) {
				   goto HandleError;
				}
				
				lFileSize -= sizeof(DLLBASEINFO);
				pMappedBits += sizeof(DLLBASEINFO);
			    break;

		    case MapInfoId:
				bResult = AddMappedInformation(pszBaseFileName,
					                           (PMAPINFO)pMappedBits);
				if (FALSE == bResult) {
				   goto HandleError;
				}

				lFileSize -= sizeof(MAPINFO);
				pMappedBits += sizeof(MAPINFO);
			    break;

		    case ErrorInfoId:
				bResult = AddErrorInformation(pszBaseFileName,
					                          (PERRORINFO)pMappedBits);
				if (FALSE == bResult) {
				   goto HandleError;
				}

				lFileSize -= sizeof(ERRORINFO);
				pMappedBits += sizeof(ERRORINFO);
			    break;

		    default:
			    0;
		}
    }

	//
	// No problems in processing log
	//
	bResult = TRUE;

HandleError:
	
	if (pFileBits) {
	   UnmapViewOfFile(pFileBits);
	}

	if (hMap) {
	   CloseHandle(hMap);
	}

	if (INVALID_HANDLE_VALUE != hFile) {
	   CloseHandle(hFile);
	}
    
	return bResult;
}

BOOL
AddThreadInformation(PCHAR pszBaseFileName,
					 PTHREADSTART pThreadStart)
{
	PTHREADINFO ptTemp = 0;
	BOOL bResult;
	DWORD dwBytesWritten;
	CHAR szBuffer[MAX_PATH];
	CHAR szAddress[MAX_PATH];

	//
	// Allocate some memory for the new thread data
	//
	ptTemp = LocalAlloc(LPTR,
		                sizeof(THREADINFO));
	if (0 == ptTemp) {
	   return FALSE;
	}

	//
	// Initialize file data
	//
	ptTemp->dwThreadId = pThreadStart->dwThreadId;

	sprintf(szBuffer,"%s.thread%ld", pszBaseFileName, g_dwThreadCount);
    ptTemp->hFile = CreateFileA(szBuffer,
                                GENERIC_READ | GENERIC_WRITE,
					            0,
					            0,
					            CREATE_ALWAYS,
					            FILE_ATTRIBUTE_NORMAL,
					            0);
	if (INVALID_HANDLE_VALUE == ptTemp->hFile) {
	   return FALSE;
	}
	
	//
	// Add thread base information to new thread log
	//
	bResult = FillBufferWithRelocationInfo(szAddress, 
		                                   pThreadStart->dwStartAddress);
	if (FALSE == bResult) {
	   return bResult;
	}

	sprintf(szBuffer,"Thread started at %s\r\n", szAddress);
    
	bResult = WriteFile(ptTemp->hFile,
		                szBuffer,
						strlen(szBuffer),
						&dwBytesWritten,
						0);
	if (FALSE == bResult) {
	   return FALSE;
	}

	//
	// Chain up thread data
	//
	if (0 == g_ThreadHead) {
	   ptTemp->pNext = 0;
	   g_ThreadHead = ptTemp;
	}
	else {
	   ptTemp->pNext = g_ThreadHead;
	   g_ThreadHead = ptTemp;
	}

	return TRUE;
}

VOID
CloseThreadHandles(VOID)
{
    PTHREADINFO ptTemp = 0;

	ptTemp = g_ThreadHead;

	while(ptTemp) {
		if (ptTemp->hFile != INVALID_HANDLE_VALUE) {
		   CloseHandle(ptTemp->hFile);
		}

		ptTemp = ptTemp->pNext;
	}
}

BOOL
AddExeFlowInformation(PEXEFLOW pExeFlow)
{
	PTHREADINFO ptTemp = 0;
	BOOL bResult;
	DWORD dwBytesWritten;
	CHAR szAddress[MAX_PATH];
	CHAR szBuffer[MAX_PATH];

	//
	// Locate thread for this point of execution
	//
	ptTemp = g_ThreadHead;
	while(ptTemp) {
		if (ptTemp->dwThreadId == pExeFlow->dwThreadId) {
			break;
		}

		ptTemp = ptTemp->pNext;
	}

	if (0 == ptTemp) {
	   //
	   // Couldn't locate thread info
	   //
	   return FALSE;
	}

  	bResult = FillBufferWithRelocationInfo(szAddress, 
		                                   pExeFlow->dwAddress);
	if (FALSE == bResult) {
	   return bResult;
	}  

	sprintf(szBuffer, "%s : %ld\r\n", szAddress, pExeFlow->dwCallLevel);

    bResult = WriteFile(ptTemp->hFile,
		                szBuffer,
						strlen(szBuffer),
						&dwBytesWritten,
						0);
	if (FALSE == bResult) {
	   return FALSE;
	}

	return TRUE;
}

BOOL
AddErrorInformation(PCHAR pszBaseFileName,
					PERRORINFO pErrorInfo)
{
	BOOL bResult;
	DWORD dwBytesWritten;
	CHAR szBuffer[MAX_PATH];

	if (INVALID_HANDLE_VALUE == g_ErrorInformation) {
	   strcpy(szBuffer, pszBaseFileName);
	   strcat(szBuffer, ".err");

	   g_ErrorInformation = CreateFileA(szBuffer,
                                        GENERIC_READ | GENERIC_WRITE,
						                0,
						                0,
						                CREATE_ALWAYS,
						                FILE_ATTRIBUTE_NORMAL,
						                0);
	   if (INVALID_HANDLE_VALUE == g_ErrorInformation) {
		  return FALSE;
	   }               
	}

	//
	// Write out error message
	//
    bResult = WriteFile(g_ErrorInformation,
		                pErrorInfo->szMessage,
						strlen(pErrorInfo->szMessage),
						&dwBytesWritten,
						0);
	if (FALSE == bResult) {
	   return FALSE;
	}

	return TRUE;
}

BOOL
AddMappedInformation(PCHAR pszBaseFileName,
					 PMAPINFO pMapInfo)
{
	BOOL bResult;
	CHAR szBuffer[MAX_PATH];
	CHAR szAddress[MAX_PATH];
	CHAR szAddress2[MAX_PATH];
	DWORD dwBytesWritten;

	if (INVALID_HANDLE_VALUE == g_MapInformation) {
	   strcpy(szBuffer, pszBaseFileName);
	   strcat(szBuffer, ".map");

	   g_MapInformation = CreateFileA(szBuffer,
                                      GENERIC_READ | GENERIC_WRITE,
						              0,
						              0,
						              CREATE_ALWAYS,
						              FILE_ATTRIBUTE_NORMAL,
						              0);
	   if (INVALID_HANDLE_VALUE == g_MapInformation) {
		  return FALSE;
	   }               
	}

	//
	// Write out the mapping information
	//
	bResult = FillBufferWithRelocationInfo(szAddress, 
		                                   pMapInfo->dwAddress);
	if (FALSE == bResult) {
	   return bResult;
	}

	bResult = FillBufferWithRelocationInfo(szAddress2, 
		                                   pMapInfo->dwMaxMapLength);
	if (FALSE == bResult) {
	   return bResult;
	}

	sprintf(szBuffer, "%s -> %s\r\n", szAddress, szAddress2);

    bResult = WriteFile(g_MapInformation,
		                szBuffer,
						strlen(szBuffer),
						&dwBytesWritten,
						0);
	if (FALSE == bResult) {
	   return FALSE;
	}

	return TRUE;
}

BOOL
FillBufferWithRelocationInfo(PCHAR pszDestination,
							 DWORD dwAddress)
{
	PBASEINFO pTemp;

	//
	// Find the address in the module info
	//
	pTemp = g_BaseHead;
    while (pTemp) {
		//
		// Did we find the address?
		//
        if ((dwAddress >= pTemp->dwStartAddress) &&
            (dwAddress <= pTemp->dwEndAddress)) {
		   break;
		}

		pTemp = pTemp->pNext;
	}

	if (pTemp) {
	   sprintf(pszDestination, "%s+%08X", pTemp->szModule, (dwAddress - pTemp->dwStartAddress));
	}
	else {
	   sprintf(pszDestination, "%08X", dwAddress);
	}

	return TRUE;
}

BOOL
AddToBaseInformation(PDLLBASEINFO pDLLBaseInfo)
{
	PBASEINFO pTemp;

	if (0 == g_BaseHead) {
	   //
	   // Store off the base information
	   //
	   pTemp = LocalAlloc(LPTR,
		                  sizeof(BASEINFO));
	   if (0 == pTemp) {
		  return FALSE;
	   }
 
	   pTemp->dwStartAddress = pDLLBaseInfo->dwBase;
	   pTemp->dwEndAddress = pTemp->dwStartAddress + pDLLBaseInfo->dwLength;
	   strcpy(pTemp->szModule, pDLLBaseInfo->szDLLName);
	   _strupr(pTemp->szModule);

	   pTemp->pNext = 0;

	   g_BaseHead = pTemp;
	}
	else {
	   //
	   // See if our module has already been mapped, and if so update module base info
	   //
       pTemp = g_BaseHead;

	   while(pTemp) {
		   if (0 == _stricmp(pDLLBaseInfo->szDLLName, pTemp->szModule)) {
			  break;
		   }

		   pTemp = pTemp->pNext;
	   }

	   if (pTemp) {
		   //
		   // Found the DLL already in the list, update
		   //
           pTemp->dwStartAddress = pDLLBaseInfo->dwBase;
	       pTemp->dwEndAddress = pTemp->dwStartAddress + pDLLBaseInfo->dwLength;
	   }
	   else {
		    //
     	    // New DLL
	        //
	        pTemp = LocalAlloc(LPTR,
		                       sizeof(BASEINFO));
	        if (0 == pTemp) {
		       return FALSE;
			}

	        pTemp->dwStartAddress = pDLLBaseInfo->dwBase;
	        pTemp->dwEndAddress = pTemp->dwStartAddress + pDLLBaseInfo->dwLength;
	        strcpy(pTemp->szModule, pDLLBaseInfo->szDLLName);
            _strupr(pTemp->szModule);

			//
			// Chain up the new DLL
			//
			pTemp->pNext = g_BaseHead;
			g_BaseHead = pTemp;
	   }
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\vxd\inc\packon.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    packon.h

Abstract:

    This file turns packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    The file packoff.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(_lint))

#ifdef i386
#pragma warning(disable:4103)
#endif
#pragma pack(1)                 // x86, MS compiler; MIPS, MIPS compiler
#endif // ! (defined(lint) || defined(_lint))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\vxd\inc\devioctl.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    devioctl.h

Revision History:


--*/

// begin_winioctl

#ifndef _DEVIOCTL_
#define _DEVIOCTL_

// begin_ntddk begin_nthal begin_ntifs
//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//


#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

// end_ntddk end_nthal end_ntifs

#endif // _DEVIOCTL_

// end_winioctl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\vxd\inc\packoff.h ===
/*++

Copyright (c) 1990-95  Microsoft Corporation

Module Name:

    packoff.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    packoff.h is the complement to packon.h.  An inclusion of packoff.h
    MUST ALWAYS be preceded by an inclusion of packon.h, in one-to-one
    correspondence.

--*/

#if ! (defined(lint) || defined(_lint))

#ifdef i386
#pragma warning(disable:4103)
#endif
#pragma pack()                  // x86, MS compiler; MIPS, MIPS compiler
#endif // ! (defined(lint) || defined(_lint))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\profiler\vxd\inc\ntddpack.h ===
#ifndef __NTDDPACKET
#define __NTDDPACKET 1

#include <devioctl.h>

#include <packon.h>

typedef struct _PACKET_OID_DATA 
{
    ULONG           Oid;
    ULONG           Length;
    UCHAR           Data[1];
}   
PACKET_OID_DATA, *PPACKET_OID_DATA;

#include <packoff.h>

#define FILE_DEVICE_PROTOCOL        0x8000


#define IOCTL_PROTOCOL_QUERY_OID    CTL_CODE(FILE_DEVICE_PROTOCOL, 0 , METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PROTOCOL_SET_OID      CTL_CODE(FILE_DEVICE_PROTOCOL, 1 , METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PROTOCOL_STATISTICS   CTL_CODE(FILE_DEVICE_PROTOCOL, 2 , METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PROTOCOL_RESET        CTL_CODE(FILE_DEVICE_PROTOCOL, 3 , METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PROTOCOL_READ         CTL_CODE(FILE_DEVICE_PROTOCOL, 4 , METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PROTOCOL_WRITE        CTL_CODE(FILE_DEVICE_PROTOCOL, 5 , METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PROTOCOL_MACNAME      CTL_CODE(FILE_DEVICE_PROTOCOL, 6 , METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\psapi\module.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "psapi.h"


BOOL
FindModule(
    IN HANDLE hProcess,
    IN HMODULE hModule,
    OUT PLDR_DATA_TABLE_ENTRY LdrEntryData
    )

/*++

Routine Description:

    This function retrieves the loader table entry for the specified
    module.  The function copies the entry into the buffer pointed to
    by the LdrEntryData parameter.

Arguments:

    hProcess - Supplies the target process.

    hModule - Identifies the module whose loader entry is being
        requested.  A value of NULL references the module handle
        associated with the image file that was used to create the
        process.

    LdrEntryData - Returns the requested table entry.

Return Value:

    TRUE if a matching entry was found.

--*/

{
    PROCESS_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;
    PPEB Peb;
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
    }

    Peb = BasicInfo.PebBaseAddress;


    if ( !ARGUMENT_PRESENT( hModule )) {
        if (!ReadProcessMemory(hProcess, &Peb->ImageBaseAddress, &hModule, sizeof(hModule), NULL)) {
            return(FALSE);
        }
    }

    //
    // Ldr = Peb->Ldr
    //

    if (!ReadProcessMemory(hProcess, &Peb->Ldr, &Ldr, sizeof(Ldr), NULL)) {
        return (FALSE);
    }

    if (!Ldr) {
        // Ldr might be null (for instance, if the process hasn't started yet).
        SetLastError(ERROR_INVALID_HANDLE);
        return (FALSE);
    }


    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    if (!ReadProcessMemory(hProcess, &LdrHead->Flink, &LdrNext, sizeof(LdrNext), NULL)) {
        return(FALSE);
    }

    while (LdrNext != LdrHead) {
        PLDR_DATA_TABLE_ENTRY LdrEntry;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if (!ReadProcessMemory(hProcess, LdrEntry, LdrEntryData, sizeof(*LdrEntryData), NULL)) {
            return(FALSE);
        }

        if ((HMODULE) LdrEntryData->DllBase == hModule) {
            return(TRUE);
        }

        LdrNext = LdrEntryData->InMemoryOrderLinks.Flink;
    }

    SetLastError(ERROR_INVALID_HANDLE);
    return(FALSE);
}


BOOL
WINAPI
EnumProcessModules(
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    )
{
    PROCESS_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;
    PPEB Peb;
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;
    DWORD chMax;
    DWORD ch;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
        }

    Peb = BasicInfo.PebBaseAddress;

    //
    // Ldr = Peb->Ldr
    //

    if (!ReadProcessMemory(hProcess, &Peb->Ldr, &Ldr, sizeof(Ldr), NULL)) {
        return(FALSE);
        }

    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    if (!ReadProcessMemory(hProcess, &LdrHead->Flink, &LdrNext, sizeof(LdrNext), NULL)) {
        return(FALSE);
        }

    chMax = cb / sizeof(HMODULE);
    ch = 0;

    while (LdrNext != LdrHead) {
        PLDR_DATA_TABLE_ENTRY LdrEntry;
        LDR_DATA_TABLE_ENTRY LdrEntryData;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if (!ReadProcessMemory(hProcess, LdrEntry, &LdrEntryData, sizeof(LdrEntryData), NULL)) {
            return(FALSE);
            }

        if (ch < chMax) {
            try {
                   lphModule[ch] = (HMODULE) LdrEntryData.DllBase;
                }
            except (EXCEPTION_EXECUTE_HANDLER) {
                SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
                return(FALSE);
                }
            }

        ch++;

        LdrNext = LdrEntryData.InMemoryOrderLinks.Flink;
        }

    try {
        *lpcbNeeded = ch * sizeof(HMODULE);
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
        return(FALSE);
        }

    return(TRUE);
}


DWORD
WINAPI
GetModuleFileNameExW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    )

/*++

Routine Description:

    This function retrieves the full pathname of the executable file
    from which the specified module was loaded.  The function copies the
    null-terminated filename into the buffer pointed to by the
    lpFilename parameter.

Routine Description:

    hModule - Identifies the module whose executable file name is being
        requested.  A value of NULL references the module handle
        associated with the image file that was used to create the
        process.

    lpFilename - Points to the buffer that is to receive the filename.

    nSize - Specifies the maximum number of characters to copy.  If the
        filename is longer than the maximum number of characters
        specified by the nSize parameter, it is truncated.

Return Value:

    The return value specifies the actual length of the string copied to
    the buffer.  A return value of zero indicates an error and extended
    error status is available using the GetLastError function.

Arguments:

--*/

{
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    DWORD cb;

    if (!FindModule(hProcess, hModule, &LdrEntryData)) {
        return(0);
        }

    nSize *= sizeof(WCHAR);

    cb = LdrEntryData.FullDllName.Length + sizeof (WCHAR);
    if ( nSize < cb ) {
        cb = nSize;
        }

    if (!ReadProcessMemory(hProcess, LdrEntryData.FullDllName.Buffer, lpFilename, cb, NULL)) {
        return(0);
        }

    if (cb == LdrEntryData.FullDllName.Length + sizeof (WCHAR)) {
        cb -= sizeof(WCHAR);
        }

    return(cb / sizeof(WCHAR));
}



DWORD
WINAPI
GetModuleFileNameExA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    )
{
    LPWSTR lpwstr;
    DWORD cwch;
    DWORD cch;

    lpwstr = (LPWSTR) LocalAlloc(LMEM_FIXED, nSize * 2);

    if (lpwstr == NULL) {
        return(0);
        }

    cwch = cch = GetModuleFileNameExW(hProcess, hModule, lpwstr, nSize);

    if (cwch < nSize) {
        //
        // Include NULL terminator
        //

        cwch++;
        }

    if (!WideCharToMultiByte(CP_ACP, 0, lpwstr, cwch, lpFilename, nSize, NULL, NULL)) {
        cch = 0;
        }

    LocalFree((HLOCAL) lpwstr);

    return(cch);
}


DWORD
WINAPI
GetModuleBaseNameW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    )

/*++

Routine Description:

    This function retrieves the full pathname of the executable file
    from which the specified module was loaded.  The function copies the
    null-terminated filename into the buffer pointed to by the
    lpFilename parameter.

Routine Description:

    hModule - Identifies the module whose executable file name is being
        requested.  A value of NULL references the module handle
        associated with the image file that was used to create the
        process.

    lpFilename - Points to the buffer that is to receive the filename.

    nSize - Specifies the maximum number of characters to copy.  If the
        filename is longer than the maximum number of characters
        specified by the nSize parameter, it is truncated.

Return Value:

    The return value specifies the actual length of the string copied to
    the buffer.  A return value of zero indicates an error and extended
    error status is available using the GetLastError function.

Arguments:

--*/

{
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    DWORD cb;

    if (!FindModule(hProcess, hModule, &LdrEntryData)) {
        return(0);
        }

    nSize *= sizeof(WCHAR);

    cb = LdrEntryData.BaseDllName.Length + sizeof (WCHAR);
    if ( nSize < cb ) {
        cb = nSize;
        }

    if (!ReadProcessMemory(hProcess, LdrEntryData.BaseDllName.Buffer, lpFilename, cb, NULL)) {
        return(0);
        }

    if (cb == LdrEntryData.BaseDllName.Length + sizeof (WCHAR)) {
        cb -= sizeof(WCHAR);
        }

    return(cb / sizeof(WCHAR));
}



DWORD
WINAPI
GetModuleBaseNameA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    )
{
    LPWSTR lpwstr;
    DWORD cwch;
    DWORD cch;

    lpwstr = (LPWSTR) LocalAlloc(LMEM_FIXED, nSize * 2);

    if (lpwstr == NULL) {
        return(0);
        }

    cwch = cch = GetModuleBaseNameW(hProcess, hModule, lpwstr, nSize);

    if (cwch < nSize) {
        //
        // Include NULL terminator
        //

        cwch++;
        }

    if (!WideCharToMultiByte(CP_ACP, 0, lpwstr, cwch, lpFilename, nSize, NULL, NULL)) {
        cch = 0;
        }

    LocalFree((HLOCAL) lpwstr);

    return(cch);
}


BOOL
WINAPI
GetModuleInformation(
    HANDLE hProcess,
    HMODULE hModule,
    LPMODULEINFO lpmodinfo,
    DWORD cb
    )
{
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    MODULEINFO modinfo;

    if (cb < sizeof(MODULEINFO)) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return(FALSE);
        }

    if (!FindModule(hProcess, hModule, &LdrEntryData)) {
        return(0);
        }

    modinfo.lpBaseOfDll = (PVOID) hModule;
    modinfo.SizeOfImage = LdrEntryData.SizeOfImage;
    modinfo.EntryPoint  = LdrEntryData.EntryPoint;

    try {
        *lpmodinfo = modinfo;
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
        return(FALSE);
        }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\psapi\mapfile.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "psapi.h"


DWORD
WINAPI
GetMappedFileNameW(
    HANDLE hProcess,
    LPVOID lpv,
    LPWSTR lpFilename,
    DWORD nSize
    )
{
    struct {
        OBJECT_NAME_INFORMATION ObjectNameInfo;
        WCHAR FileName[MAX_PATH];
    } s;
    NTSTATUS Status;
    DWORD cb;
    SIZE_T ReturnLength;

    //
    // See if we can figure out the name associated with
    // this mapped region
    //

    Status = NtQueryVirtualMemory(hProcess,
                                  lpv,
                                  MemoryMappedFilenameInformation,
                                  &s.ObjectNameInfo,
                                  sizeof(s),
                                  &ReturnLength
                                  );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(0);
        }

    nSize *= sizeof(WCHAR);

    cb = s.ObjectNameInfo.Name.MaximumLength;
    if ( nSize < cb ) {
        cb = nSize;
        }

    CopyMemory(lpFilename, s.ObjectNameInfo.Name.Buffer, cb);

    if (cb == s.ObjectNameInfo.Name.MaximumLength) {
        cb -= sizeof(WCHAR);
        }

    return(cb / sizeof(WCHAR));
}


DWORD
WINAPI
GetMappedFileNameA(
    HANDLE hProcess,
    LPVOID lpv,
    LPSTR lpFilename,
    DWORD nSize
    )
{
    LPWSTR lpwstr;
    DWORD cwch;
    DWORD cch;

    lpwstr = (LPWSTR) LocalAlloc(LMEM_FIXED, nSize * 2);

    if (lpwstr == NULL) {
        return(0);
        }

    cch = cwch = GetMappedFileNameW(hProcess, lpv, lpwstr, nSize);

    if (cwch < nSize) {
        //
        // Include NULL terminator
        //

        cwch++;
        }

    if (!WideCharToMultiByte(CP_ACP, 0, lpwstr, cwch, lpFilename, nSize, NULL, NULL)) {
        cch = 0;
        }

    LocalFree((HLOCAL) lpwstr);

    return(cch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\psapi\perf.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    psenum.c

Abstract:

    This module returns various performance values

Author:

    Neill clift (NeillC) 23-Jul-2000


Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "psapi.h"

BOOL
WINAPI
GetPerformanceInfo (
    PPERFORMACE_INFORMATION pPerformanceInformation,
    DWORD cb
    )
/*++

Routine Description:

    The routine gets some performance values.

Arguments:

    pPerformanceInformation - A block out performance values that are returned.

Return Value:

    BOOL - Returns TRUE is the function was successfull FALSE otherwise

--*/
{
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    SYSTEM_FILECACHE_INFORMATION FileCache;
    PSYSTEM_PROCESS_INFORMATION ProcInfo, tProcInfo;
    ULONG BufferLength, RetLen;
    ULONG Processes;
    ULONG Threads;
    ULONG Handles;


    if (cb < sizeof (PERFORMACE_INFORMATION)) {
        SetLastError (RtlNtStatusToDosError (STATUS_INFO_LENGTH_MISMATCH));
        return FALSE;
    }
    Status = NtQuerySystemInformation (SystemBasicInformation,
                                       &BasicInfo,
                                       sizeof(BasicInfo),
                                       NULL);
    if (!NT_SUCCESS (Status)) {
        SetLastError (RtlNtStatusToDosError (Status));
        return FALSE;
    }

    Status = NtQuerySystemInformation (SystemPerformanceInformation,
                                       &PerfInfo,
                                       sizeof(PerfInfo),
                                       NULL);
    if (!NT_SUCCESS (Status)) {
        SetLastError (RtlNtStatusToDosError (Status));
        return FALSE;
    }

    Status = NtQuerySystemInformation (SystemFileCacheInformation,
                                       &FileCache,
                                       sizeof(FileCache),
                                       NULL);
    if (!NT_SUCCESS (Status)) {
        SetLastError (RtlNtStatusToDosError (Status));
        return FALSE;
    }

    BufferLength = 4096;
    while (1) {
        ProcInfo = LocalAlloc (LMEM_FIXED, BufferLength);
        if (ProcInfo == NULL) {
            SetLastError (RtlNtStatusToDosError (STATUS_INSUFFICIENT_RESOURCES));
            return FALSE;
        }
        Status = NtQuerySystemInformation (SystemProcessInformation,
                                           ProcInfo,
                                           BufferLength,
                                           &RetLen);
        if (NT_SUCCESS (Status)) {
            break;
        }
        LocalFree (ProcInfo);
        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            if (RetLen > BufferLength) {
                BufferLength = RetLen;
            } else {
                BufferLength += 4096;
            }
        } else {
            SetLastError (RtlNtStatusToDosError (Status));
            return FALSE;
        }
    }

    Processes = 0;
    Threads = 0;
    Handles = 0;

    tProcInfo = ProcInfo;
    while (RetLen > sizeof (SYSTEM_PROCESS_INFORMATION)) {
        Processes += 1;
        Threads += tProcInfo->NumberOfThreads;
        Handles += tProcInfo->HandleCount;
        if (tProcInfo->NextEntryOffset == 0 || tProcInfo->NextEntryOffset > RetLen) {
            break;
        }
        RetLen -= tProcInfo->NextEntryOffset;
        tProcInfo = (PSYSTEM_PROCESS_INFORMATION) ((PUCHAR) tProcInfo + tProcInfo->NextEntryOffset);
    }
    LocalFree (ProcInfo);

    pPerformanceInformation->cb                = sizeof (PERFORMACE_INFORMATION);
    pPerformanceInformation->CommitTotal       = PerfInfo.CommittedPages;
    pPerformanceInformation->CommitLimit       = PerfInfo.CommitLimit;
    pPerformanceInformation->CommitPeak        = PerfInfo.PeakCommitment;
    pPerformanceInformation->PhysicalTotal     = BasicInfo.NumberOfPhysicalPages;
    pPerformanceInformation->PhysicalAvailable = PerfInfo.AvailablePages;
    pPerformanceInformation->SystemCache       = FileCache.CurrentSizeIncludingTransitionInPages;
    pPerformanceInformation->KernelTotal       = PerfInfo.PagedPoolPages + PerfInfo.NonPagedPoolPages;
    pPerformanceInformation->KernelPaged       = PerfInfo.PagedPoolPages;
    pPerformanceInformation->KernelNonpaged    = PerfInfo.NonPagedPoolPages;
    pPerformanceInformation->PageSize          = BasicInfo.PageSize;
    pPerformanceInformation->HandleCount       = Handles;
    pPerformanceInformation->ProcessCount      = Processes;
    pPerformanceInformation->ThreadCount       = Threads;

    return TRUE;
}

BOOL
WINAPI
EnumPageFilesW (
    PENUM_PAGE_FILE_CALLBACKW pCallBackRoutine,
    LPVOID pContext
    )
/*++

Routine Description:

    The routine calls the callback routine for each installed page file in the system

Arguments:

    pCallBackRoutine - Routine called for each pagefile
    pContext - Context value provided by the user and passed to the call back routine.

Return Value:

    BOOL - Returns TRUE is the function was successfull FALSE otherwise

--*/
{
    NTSTATUS Status;
    ULONG BufferLength, RetLen;
    PSYSTEM_PAGEFILE_INFORMATION PageFileInfo, tPageFileInfo;

    BufferLength = 4096;
    while (1) {
        PageFileInfo = LocalAlloc (LMEM_FIXED, BufferLength);
        if (PageFileInfo == NULL) {
            SetLastError (RtlNtStatusToDosError (STATUS_INSUFFICIENT_RESOURCES));
            return FALSE;
        }
        Status = NtQuerySystemInformation (SystemPageFileInformation,
                                           PageFileInfo,
                                           BufferLength,
                                           &RetLen);
        if (NT_SUCCESS (Status)) {
            break;
        }
        LocalFree (PageFileInfo);
        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            if (RetLen > BufferLength) {
                BufferLength = RetLen;
            } else {
                BufferLength += 4096;
            }
        } else {
            SetLastError (RtlNtStatusToDosError (Status));
            return FALSE;
        }
    }

    tPageFileInfo = PageFileInfo;
    while (RetLen > sizeof (SYSTEM_PAGEFILE_INFORMATION)) {
        ENUM_PAGE_FILE_INFORMATION pfi;
        PWCHAR pWc;

        pfi.cb         = sizeof (ENUM_PAGE_FILE_INFORMATION);
        pfi.Reserved   = 0;
        pfi.TotalSize  = tPageFileInfo->TotalSize;
        pfi.TotalInUse = tPageFileInfo->TotalInUse;
        pfi.PeakUsage  = tPageFileInfo->PeakUsage;

        pWc = wcschr (tPageFileInfo->PageFileName.Buffer, L':');
        if (pWc != NULL && pWc > tPageFileInfo->PageFileName.Buffer) {
            pWc--;
            pCallBackRoutine (pContext, &pfi, pWc);
        }
        if (tPageFileInfo->NextEntryOffset == 0 || tPageFileInfo->NextEntryOffset > RetLen) {
            break;
        }
        RetLen -= tPageFileInfo->NextEntryOffset;
        tPageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION) ((PUCHAR) tPageFileInfo +
                                                                 tPageFileInfo->NextEntryOffset);
    }
    LocalFree (PageFileInfo);
    return TRUE;
}

typedef struct _ENUM_PAGE_FILE_CONV_CTX {
    LPVOID Ctx;
    PENUM_PAGE_FILE_CALLBACKA CallBack;
    DWORD LastError;
} ENUM_PAGE_FILE_CONV_CTX, *PENUM_PAGE_FILE_CONV_CTX;

BOOL
CallBackConvertToAscii (
    LPVOID pContext,
    PENUM_PAGE_FILE_INFORMATION pPageFileInfo,
    LPCWSTR lpFilename
    )
{
    DWORD Len;
    LPSTR AsciiStr;
    PENUM_PAGE_FILE_CONV_CTX Ctx = pContext;
    BOOL RetVal;

    Len = wcslen (lpFilename) + 1;

    AsciiStr = LocalAlloc (LMEM_FIXED, Len);
    if (AsciiStr == NULL) {
        Ctx->LastError = RtlNtStatusToDosError (STATUS_INSUFFICIENT_RESOURCES);
        return FALSE;
    }

    if (WideCharToMultiByte (CP_ACP, 0, lpFilename, -1, AsciiStr, Len, NULL, NULL)) {
        RetVal = Ctx->CallBack (Ctx->Ctx, pPageFileInfo, AsciiStr);
    } else {
        Ctx->LastError = GetLastError ();
        RetVal = FALSE;
    }

    LocalFree (AsciiStr);

    return RetVal;
}

BOOL
WINAPI
EnumPageFilesA (
    PENUM_PAGE_FILE_CALLBACKA pCallBackRoutine,
    LPVOID pContext
    )
/*++

Routine Description:

    The routine calls the callback routine for each installed page file in the system

Arguments:

    pCallBackRoutine - Routine called for each pagefile
    pContext - Context value provided by the user and passed to the call back routine.

Return Value:

    BOOL - Returns TRUE is the function was successfull FALSE otherwise

--*/
{
    ENUM_PAGE_FILE_CONV_CTX Ctx;
    BOOL RetVal;

    Ctx.Ctx = pContext;
    Ctx.CallBack = pCallBackRoutine;
    Ctx.LastError = 0;

    RetVal = EnumPageFilesW (CallBackConvertToAscii,
                             &Ctx);
    if (RetVal) {
        //
        // See if our conversion routine encountered an error. If it doid then return this to the caller
        //
        if (Ctx.LastError != 0) {
            RetVal = FALSE;
            SetLastError (Ctx.LastError);
        }
    }
    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\psapi\driver.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "psapi.h"

#include <stddef.h>

BOOL
FindDeviceDriver(
    LPVOID ImageBase,
    PRTL_PROCESS_MODULE_INFORMATION Module
    )

/*++

Routine Description:

    This function retrieves the full pathname of the executable file
    from which the specified module was loaded.  The function copies the
    null-terminated filename into the buffer pointed to by the
    lpFilename parameter.

Routine Description:

    ImageBase - Identifies the driver whose executable file name is being
        requested.

Return Value:

    The return value specifies the actual length of the string copied to
    the buffer.  A return value of zero indicates an error and extended
    error status is available using the GetLastError function.

Arguments:

--*/

{
    RTL_PROCESS_MODULES ModuleInformation;
    NTSTATUS Status;
    DWORD cbModuleInformation;
    PRTL_PROCESS_MODULES pModuleInformation;
    DWORD i, ReturnedLength;

    Status = NtQuerySystemInformation(
                SystemModuleInformation,
                &ModuleInformation,
                sizeof(ModuleInformation),
                &ReturnedLength
                );

    if ( !NT_SUCCESS(Status) && (Status != STATUS_INFO_LENGTH_MISMATCH) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
        }

    cbModuleInformation = offsetof(RTL_PROCESS_MODULES, Modules);
    cbModuleInformation += ModuleInformation.NumberOfModules * sizeof(RTL_PROCESS_MODULE_INFORMATION);

    pModuleInformation = (PRTL_PROCESS_MODULES) LocalAlloc(LMEM_FIXED, cbModuleInformation);

    if (pModuleInformation == NULL) {
        return(FALSE);
        }

    Status = NtQuerySystemInformation(
                SystemModuleInformation,
                pModuleInformation,
                cbModuleInformation,
                &ReturnedLength
                );

    if ( !NT_SUCCESS(Status) ) {
        LocalFree((HLOCAL) pModuleInformation);

        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
        }

    for (i = 0; i < ModuleInformation.NumberOfModules; i++) {
        if (pModuleInformation->Modules[i].ImageBase == ImageBase) {
            *Module = pModuleInformation->Modules[i];

            LocalFree((HLOCAL) pModuleInformation);

            return(TRUE);
            }
        }

    LocalFree((HLOCAL) pModuleInformation);

    SetLastError(ERROR_INVALID_HANDLE);
    return(FALSE);
}


BOOL
WINAPI
EnumDeviceDrivers(
    LPVOID *lpImageBase,
    DWORD cb,
    LPDWORD lpcbNeeded
    )
{
    RTL_PROCESS_MODULES ModuleInformation;
    NTSTATUS Status;
    DWORD cbModuleInformation;
    PRTL_PROCESS_MODULES pModuleInformation;
    DWORD cpvMax;
    DWORD i, ReturnedLength;

    Status = NtQuerySystemInformation(
                SystemModuleInformation,
                &ModuleInformation,
                sizeof(ModuleInformation),
                &ReturnedLength
                );

    if ( !NT_SUCCESS(Status) && (Status != STATUS_INFO_LENGTH_MISMATCH) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
        }

    cbModuleInformation = offsetof(RTL_PROCESS_MODULES, Modules);
    cbModuleInformation += ModuleInformation.NumberOfModules * sizeof(RTL_PROCESS_MODULE_INFORMATION);

    pModuleInformation = (PRTL_PROCESS_MODULES) LocalAlloc(LMEM_FIXED, cbModuleInformation);

    if (pModuleInformation == NULL) {
        return(FALSE);
        }

    Status = NtQuerySystemInformation(
                SystemModuleInformation,
                pModuleInformation,
                cbModuleInformation,
                &ReturnedLength
                );

    if ( !NT_SUCCESS(Status) ) {
        LocalFree((HLOCAL) pModuleInformation);

        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
        }

    cpvMax = cb / sizeof(LPVOID);

    for (i = 0; i < ModuleInformation.NumberOfModules; i++) {
        if (i == cpvMax) {
            break;
            }

        try {
               lpImageBase[i] = pModuleInformation->Modules[i].ImageBase;
            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            LocalFree((HLOCAL) pModuleInformation);

            SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
            return(FALSE);
            }
        }

    try {
        *lpcbNeeded = ModuleInformation.NumberOfModules * sizeof(LPVOID);
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        LocalFree((HLOCAL) pModuleInformation);

        SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
        return(FALSE);
        }

    LocalFree((HLOCAL) pModuleInformation);

    return(TRUE);
}


DWORD
WINAPI
GetDeviceDriverFileNameW(
    LPVOID ImageBase,
    LPWSTR lpFilename,
    DWORD nSize
    )

/*++

Routine Description:

    This function retrieves the full pathname of the executable file
    from which the specified module was loaded.  The function copies the
    null-terminated filename into the buffer pointed to by the
    lpFilename parameter.

Routine Description:

    ImageBase - Identifies the driver whose executable file name is being
        requested.

    lpFilename - Points to the buffer that is to receive the filename.

    nSize - Specifies the maximum number of characters to copy.  If the
        filename is longer than the maximum number of characters
        specified by the nSize parameter, it is truncated.

Return Value:

    The return value specifies the actual length of the string copied to
    the buffer.  A return value of zero indicates an error and extended
    error status is available using the GetLastError function.

Arguments:

--*/

{
    LPSTR lpstr;
    DWORD cch;
    DWORD cchT;

    lpstr = (LPSTR) LocalAlloc(LMEM_FIXED, nSize);

    if (lpstr == NULL) {
        return(0);
        }

    cchT = cch = GetDeviceDriverFileNameA(ImageBase, lpstr, nSize);

    if (!cch) {
        LocalFree((HLOCAL) lpstr);
        return 0;
    }

    if (cchT < nSize) {
        //
        // Include NULL terminator
        //

        cchT++;
        }

    if (!MultiByteToWideChar(CP_ACP, 0, lpstr, cchT, lpFilename, nSize)) {
        cch = 0;
        }

    LocalFree((HLOCAL) lpstr);

    return(cch);
}



DWORD
WINAPI
GetDeviceDriverFileNameA(
    LPVOID ImageBase,
    LPSTR lpFilename,
    DWORD nSize
    )
{
    RTL_PROCESS_MODULE_INFORMATION Module;
    DWORD cchT;
    DWORD cch;

    if (!FindDeviceDriver(ImageBase, &Module)) {
        return(0);
        }

    cch = cchT = (DWORD) (strlen(Module.FullPathName) + 1);
    if ( nSize < cch ) {
        cch = nSize;
        }

    CopyMemory(lpFilename, Module.FullPathName, cch);

    if (cch == cchT) {
        cch--;
        }

    return(cch);
}


DWORD
WINAPI
GetDeviceDriverBaseNameW(
    LPVOID ImageBase,
    LPWSTR lpFilename,
    DWORD nSize
    )

/*++

Routine Description:

    This function retrieves the full pathname of the executable file
    from which the specified module was loaded.  The function copies the
    null-terminated filename into the buffer pointed to by the
    lpFilename parameter.

Routine Description:

    ImageBase - Identifies the driver whose executable file name is being
        requested.

    lpFilename - Points to the buffer that is to receive the filename.

    nSize - Specifies the maximum number of characters to copy.  If the
        filename is longer than the maximum number of characters
        specified by the nSize parameter, it is truncated.

Return Value:

    The return value specifies the actual length of the string copied to
    the buffer.  A return value of zero indicates an error and extended
    error status is available using the GetLastError function.

Arguments:

--*/

{
    LPSTR lpstr;
    DWORD cch;
    DWORD cchT;

    lpstr = (LPSTR) LocalAlloc(LMEM_FIXED, nSize);

    if (lpstr == NULL) {
        return(0);
        }

    cchT = cch = GetDeviceDriverBaseNameA(ImageBase, lpstr, nSize);

    if (!cch) {
        LocalFree((HLOCAL) lpstr);
        return 0;
    }

    if (cchT < nSize) {
        //
        // Include NULL terminator
        //

        cchT++;
        }

    if (!MultiByteToWideChar(CP_ACP, 0, lpstr, cchT, lpFilename, nSize)) {
        cch = 0;
        }

    LocalFree((HLOCAL) lpstr);

    return(cch);
}



DWORD
WINAPI
GetDeviceDriverBaseNameA(
    LPVOID ImageBase,
    LPSTR lpFilename,
    DWORD nSize
    )
{
    RTL_PROCESS_MODULE_INFORMATION Module;
    DWORD cchT;
    DWORD cch;

    if (!FindDeviceDriver(ImageBase, &Module)) {
        return(0);
        }

    cch = cchT = (DWORD) (strlen(Module.FullPathName + Module.OffsetToFileName) + 1);
    if ( nSize < cch ) {
        cch = nSize;
        }

    CopyMemory(lpFilename, Module.FullPathName + Module.OffsetToFileName, cch);

    if (cch == cchT) {
        cch--;
        }

    return(cch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\psapi\process.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "psapi.h"

#include <stddef.h>


BOOL
WINAPI
EnumProcesses(
  DWORD * lpidProcess,
  DWORD cb,
  LPDWORD lpcbNeeded
  )
{
  DWORD  cbProcessInformation;
  LPVOID  pvProcessInformation;
  NTSTATUS Status;
  DWORD  ibCur, i;
  DWORD  cdwMax;
  DWORD  TotalOffset;

  cbProcessInformation = 32768;
Retry:
  pvProcessInformation = LocalAlloc(LMEM_FIXED, cbProcessInformation);

  if (pvProcessInformation == NULL) {
        return(FALSE);
        }

  Status = NtQuerySystemInformation(
                SystemProcessInformation,
                pvProcessInformation,
                cbProcessInformation,
                NULL
                );

  if ( Status == STATUS_INFO_LENGTH_MISMATCH ) {
        LocalFree((HLOCAL) pvProcessInformation);

        cbProcessInformation += 32768;
        goto Retry;
        }

  if ( !NT_SUCCESS(Status) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
        }

  TotalOffset = 0;
  ibCur = 0;

  cdwMax = cb / sizeof(DWORD);
  i = 0;

  for (;;) {
        PSYSTEM_PROCESS_INFORMATION pProcessInformation;

        pProcessInformation = (PSYSTEM_PROCESS_INFORMATION)
                           ((BYTE *) pvProcessInformation + TotalOffset);

        if (i < cdwMax) {
          try {
                lpidProcess[i] = HandleToUlong(pProcessInformation->UniqueProcessId);
                }
          except (EXCEPTION_EXECUTE_HANDLER) {
                LocalFree((HLOCAL) pvProcessInformation);

                SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
                return(FALSE);
                }
          i++;
          }

        ibCur = pProcessInformation->NextEntryOffset;
        TotalOffset += ibCur;

        if (ibCur == 0) {
          break;
          }
        };

  try {
        *lpcbNeeded = i * sizeof(DWORD);
        }
  except (EXCEPTION_EXECUTE_HANDLER) {
        LocalFree((HLOCAL) pvProcessInformation);

        SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
        return(FALSE);
        }

  LocalFree((HLOCAL) pvProcessInformation);

  return(TRUE);
}


BOOL
WINAPI
GetProcessMemoryInfo (
  HANDLE hProcess,
  PPROCESS_MEMORY_COUNTERS ppsmemCounters,
  DWORD cb
  )

/*++

Routine Description:

  This function returns all the PSVM_COUNTERS for a process.

Arguments:

  hProcess - Handle for the process being queried.

  ppsmemCounters - Points to buffer that will receive the PROCESS_MEMORY_COUNTERS.

  cb - size of ppsmemCounters

Return Value:

  The return value is TRUE or FALSE.

--*/

{
  NTSTATUS Status;
  VM_COUNTERS_EX VmCounters;
  BOOL fEx;

  // Try to feel if the ptr passed is NULL and if not,
  // is it long enough for us.

  try {
         ppsmemCounters->PeakPagefileUsage = 0;
        }
  except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( RtlNtStatusToDosError( GetExceptionCode() ) );
        return(FALSE);
        }

  if (cb < sizeof(PROCESS_MEMORY_COUNTERS)) {
    SetLastError( ERROR_INSUFFICIENT_BUFFER );
    return(FALSE);
  } else if (cb < sizeof(PROCESS_MEMORY_COUNTERS_EX)) {
    fEx = FALSE;
  } else {
    fEx = TRUE;
  }

  Status = NtQueryInformationProcess(
                hProcess,
                ProcessVmCounters,
                &VmCounters,
                sizeof(VmCounters),
                NULL
                );

  if ( !NT_SUCCESS(Status) )
  {
   SetLastError( RtlNtStatusToDosError( Status ) );
   return( FALSE );
  }

  if (fEx) {
    ppsmemCounters->cb = sizeof(PROCESS_MEMORY_COUNTERS_EX);
  } else {
    ppsmemCounters->cb = sizeof(PROCESS_MEMORY_COUNTERS);
  }
  ppsmemCounters->PageFaultCount             = VmCounters.PageFaultCount;
  ppsmemCounters->PeakWorkingSetSize         = VmCounters.PeakWorkingSetSize;
  ppsmemCounters->WorkingSetSize             = VmCounters.WorkingSetSize;
  ppsmemCounters->QuotaPeakPagedPoolUsage    = VmCounters.QuotaPeakPagedPoolUsage;
  ppsmemCounters->QuotaPagedPoolUsage        = VmCounters.QuotaPagedPoolUsage;
  ppsmemCounters->QuotaPeakNonPagedPoolUsage = VmCounters.QuotaPeakNonPagedPoolUsage;
  ppsmemCounters->QuotaNonPagedPoolUsage     = VmCounters.QuotaNonPagedPoolUsage;
  ppsmemCounters->PagefileUsage              = VmCounters.PagefileUsage;
  ppsmemCounters->PeakPagefileUsage          = VmCounters.PeakPagefileUsage;

  if (fEx) {
    ((PPROCESS_MEMORY_COUNTERS_EX)ppsmemCounters)->PrivateUsage = VmCounters.PrivateUsage;
  }

  return(TRUE);
}


BOOL
WINAPI
InitializeProcessForWsWatch(
    HANDLE hProcess
    )
{
    NTSTATUS Status;

    Status = NtSetInformationProcess(
                hProcess,
                ProcessWorkingSetWatch,
                NULL,
                0
                );
    if ( NT_SUCCESS(Status) || Status == STATUS_PORT_ALREADY_SET || Status == STATUS_ACCESS_DENIED ) {
        return TRUE;
        }
    else {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return FALSE;
        }
}

BOOL
WINAPI
GetWsChanges(
    HANDLE hProcess,
    PPSAPI_WS_WATCH_INFORMATION lpWatchInfo,
    DWORD cb
    )
{
    NTSTATUS Status;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessWorkingSetWatch,
                (PVOID *)lpWatchInfo,
                cb,
                NULL
                );
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return FALSE;
        }
}

DWORD
WINAPI
GetProcessImageFileNameW(
    HANDLE hProcess,
    LPWSTR lpImageFileName,
    DWORD nSize
    )
{
    PUNICODE_STRING Buffer;
    ULONG           BufferSize,
                    ReturnLength;
    NTSTATUS        Status;

    BufferSize = sizeof(UNICODE_STRING) + nSize * 2;

    Buffer = LocalAlloc(LMEM_FIXED, BufferSize);

    if (! Buffer) {
        ReturnLength = 0;
        goto cleanup;
    }

    Status = NtQueryInformationProcess(hProcess,
                                       ProcessImageFileName,
                                       Buffer,
                                       BufferSize,
                                       NULL);

    if (Status == STATUS_INFO_LENGTH_MISMATCH) {
        Status = STATUS_BUFFER_TOO_SMALL;
    }

    if (! NT_SUCCESS(Status)) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        ReturnLength = 0;
        goto cleanup_buffer;
    }

    RtlCopyMemory(lpImageFileName,
                  Buffer->Buffer,
                  Buffer->Length);

    ReturnLength = Buffer->Length >> 1;

    if (ReturnLength < nSize) {
        lpImageFileName[ReturnLength] = UNICODE_NULL;
    }

 cleanup_buffer:
    LocalFree((HLOCAL) Buffer);

 cleanup:
    return ReturnLength;
}

DWORD
WINAPI
GetProcessImageFileNameA(
    HANDLE hProcess,
    LPSTR lpImageFileName,
    DWORD nSize
    )
{
    PUNICODE_STRING Buffer;
    ULONG           BufferSize,
                    ReturnLength;
    NTSTATUS        Status;

    BufferSize = sizeof(UNICODE_STRING) + nSize * 2;

    Buffer = LocalAlloc(LMEM_FIXED, BufferSize);

    if (! Buffer) {
        ReturnLength = 0;
        goto cleanup;
    }

    Status = NtQueryInformationProcess(hProcess,
                                       ProcessImageFileName,
                                       Buffer,
                                       BufferSize,
                                       NULL);

    if (Status == STATUS_INFO_LENGTH_MISMATCH) {
        Status = STATUS_BUFFER_TOO_SMALL;
    }

    if (! NT_SUCCESS(Status)) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        ReturnLength = 0;
        goto cleanup_buffer;
    }

    ReturnLength = WideCharToMultiByte(CP_ACP,
                                       0,
                                       Buffer->Buffer,
                                       Buffer->Length,
                                       lpImageFileName,
                                       nSize,
                                       NULL,
                                       NULL);

    if (ReturnLength) {
        //
        // WideCharToMultiByte includes the trailing NULL in its
        // count; we do not.
        //
        --ReturnLength;
    }

 cleanup_buffer:
    LocalFree((HLOCAL) Buffer);

 cleanup:
    return ReturnLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\psapi\ws.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "psapi.h"


BOOL
WINAPI
EmptyWorkingSet(
    HANDLE hProcess
    )
{
    NTSTATUS Status;
    QUOTA_LIMITS QuotaLimits;
    SYSTEM_INFO SystemInfo;

    GetSystemInfo(&SystemInfo);

    Status = NtQueryInformationProcess(hProcess,
                                       ProcessQuotaLimits,
                                       &QuotaLimits,
                                       sizeof(QuotaLimits),
                                       NULL);

    if ( !NT_SUCCESS(Status) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
        }

    // The following signals a desire to empty the working set

    QuotaLimits.MinimumWorkingSetSize = (SIZE_T)-1;
    QuotaLimits.MaximumWorkingSetSize = (SIZE_T)-1;

    Status = NtSetInformationProcess(hProcess,
                                     ProcessQuotaLimits,
                                     &QuotaLimits,
                                     sizeof(QuotaLimits));

    if ( !NT_SUCCESS(Status) && Status != STATUS_PRIVILEGE_NOT_HELD ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
        }

    return(TRUE);
}


BOOL
WINAPI
QueryWorkingSet(
    HANDLE hProcess,
    PVOID pv,
    DWORD cb
    )
{
    NTSTATUS Status;

    Status = NtQueryVirtualMemory(hProcess,
                                  NULL,
                                  MemoryWorkingSetInformation,
                                  pv,
                                  cb,
                                  NULL);

    if ( !NT_SUCCESS(Status) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
        }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\psapi\psapi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994-1999  Microsoft Corporation

Module Name:

    psapi.h

Abstract:

    Include file for APIs provided by PSAPI.DLL

Author:

    Richard Shupak   [richards]  06-Jan-1994

Revision History:

--*/

#ifndef _PSAPI_H_
#define _PSAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

BOOL
WINAPI
EnumProcesses(
    DWORD * lpidProcess,
    DWORD   cb,
    DWORD * cbNeeded
    );

BOOL
WINAPI
EnumProcessModules(
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    );

DWORD
WINAPI
GetModuleBaseNameA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpBaseName,
    DWORD nSize
    );

DWORD
WINAPI
GetModuleBaseNameW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpBaseName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetModuleBaseName  GetModuleBaseNameW
#else
#define GetModuleBaseName  GetModuleBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetModuleFileNameExA(
    HANDLE hProcess,
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetModuleFileNameExW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetModuleFileNameEx  GetModuleFileNameExW
#else
#define GetModuleFileNameEx  GetModuleFileNameExA
#endif // !UNICODE


typedef struct _MODULEINFO {
    LPVOID lpBaseOfDll;
    DWORD SizeOfImage;
    LPVOID EntryPoint;
} MODULEINFO, *LPMODULEINFO;


BOOL
WINAPI
GetModuleInformation(
    HANDLE hProcess,
    HMODULE hModule,
    LPMODULEINFO lpmodinfo,
    DWORD cb
    );


BOOL
WINAPI
EmptyWorkingSet(
    HANDLE hProcess
    );


BOOL
WINAPI
QueryWorkingSet(
    HANDLE hProcess,
    PVOID pv,
    DWORD cb
    );

BOOL
WINAPI
InitializeProcessForWsWatch(
    HANDLE hProcess
    );


typedef struct _PSAPI_WS_WATCH_INFORMATION {
    LPVOID FaultingPc;
    LPVOID FaultingVa;
} PSAPI_WS_WATCH_INFORMATION, *PPSAPI_WS_WATCH_INFORMATION;

BOOL
WINAPI
GetWsChanges(
    HANDLE hProcess,
    PPSAPI_WS_WATCH_INFORMATION lpWatchInfo,
    DWORD cb
    );

DWORD
WINAPI
GetMappedFileNameW(
    HANDLE hProcess,
    LPVOID lpv,
    LPWSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetMappedFileNameA(
    HANDLE hProcess,
    LPVOID lpv,
    LPSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetMappedFileName  GetMappedFileNameW
#else
#define GetMappedFileName  GetMappedFileNameA
#endif // !UNICODE

BOOL
WINAPI
EnumDeviceDrivers(
    LPVOID *lpImageBase,
    DWORD cb,
    LPDWORD lpcbNeeded
    );


DWORD
WINAPI
GetDeviceDriverBaseNameA(
    LPVOID ImageBase,
    LPSTR lpBaseName,
    DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverBaseNameW(
    LPVOID ImageBase,
    LPWSTR lpBaseName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameW
#else
#define GetDeviceDriverBaseName  GetDeviceDriverBaseNameA
#endif // !UNICODE


DWORD
WINAPI
GetDeviceDriverFileNameA(
    LPVOID ImageBase,
    LPSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
GetDeviceDriverFileNameW(
    LPVOID ImageBase,
    LPWSTR lpFilename,
    DWORD nSize
    );

#ifdef UNICODE
#define GetDeviceDriverFileName  GetDeviceDriverFileNameW
#else
#define GetDeviceDriverFileName  GetDeviceDriverFileNameA
#endif // !UNICODE

// Structure for GetProcessMemoryInfo()

typedef struct _PROCESS_MEMORY_COUNTERS {
    DWORD cb;
    DWORD PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
} PROCESS_MEMORY_COUNTERS;
typedef PROCESS_MEMORY_COUNTERS *PPROCESS_MEMORY_COUNTERS;

#if (_WIN32_WINNT >= 0x0501)

typedef struct _PROCESS_MEMORY_COUNTERS_EX {
    DWORD cb;
    DWORD PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivateUsage;
} PROCESS_MEMORY_COUNTERS_EX;
typedef PROCESS_MEMORY_COUNTERS_EX *PPROCESS_MEMORY_COUNTERS_EX;

#endif

BOOL
WINAPI
GetProcessMemoryInfo(
    HANDLE Process,
    PPROCESS_MEMORY_COUNTERS ppsmemCounters,
    DWORD cb
    );

typedef struct _PERFORMACE_INFORMATION {
    DWORD cb;
    SIZE_T CommitTotal;
    SIZE_T CommitLimit;
    SIZE_T CommitPeak;
    SIZE_T PhysicalTotal;
    SIZE_T PhysicalAvailable;
    SIZE_T SystemCache;
    SIZE_T KernelTotal;
    SIZE_T KernelPaged;
    SIZE_T KernelNonpaged;
    SIZE_T PageSize;
    DWORD HandleCount;
    DWORD ProcessCount;
    DWORD ThreadCount;
} PERFORMACE_INFORMATION, *PPERFORMACE_INFORMATION;

BOOL
WINAPI
GetPerformanceInfo (
    PPERFORMACE_INFORMATION pPerformanceInformation,
    DWORD cb
    );

typedef struct _ENUM_PAGE_FILE_INFORMATION {
    DWORD cb;
    DWORD Reserved;
    SIZE_T TotalSize;
    SIZE_T TotalInUse;
    SIZE_T PeakUsage;
} ENUM_PAGE_FILE_INFORMATION, *PENUM_PAGE_FILE_INFORMATION;

typedef BOOL (*PENUM_PAGE_FILE_CALLBACKW) (LPVOID pContext, PENUM_PAGE_FILE_INFORMATION pPageFileInfo, LPCWSTR lpFilename);

typedef BOOL (*PENUM_PAGE_FILE_CALLBACKA) (LPVOID pContext, PENUM_PAGE_FILE_INFORMATION pPageFileInfo, LPCSTR lpFilename);

BOOL
WINAPI
EnumPageFilesW (
    PENUM_PAGE_FILE_CALLBACKW pCallBackRoutine,
    LPVOID pContext
    );

BOOL
WINAPI
EnumPageFilesA (
    PENUM_PAGE_FILE_CALLBACKA pCallBackRoutine,
    LPVOID pContext
    );

#ifdef UNICODE
#define PENUM_PAGE_FILE_CALLBACK PENUM_PAGE_FILE_CALLBACKW
#define EnumPageFiles EnumPageFilesW
#else
#define PENUM_PAGE_FILE_CALLBACK PENUM_PAGE_FILE_CALLBACKA
#define EnumPageFiles EnumPageFilesA
#endif // !UNICODE

DWORD
WINAPI
GetProcessImageFileNameA(
    HANDLE hProcess,
    LPSTR lpImageFileName,
    DWORD nSize
    );

DWORD
WINAPI
GetProcessImageFileNameW(
    HANDLE hProcess,
    LPWSTR lpImageFileName,
    DWORD nSize
    );

#ifdef UNICODE
#define GetProcessImageFileName  GetProcessImageFileNameW
#else
#define GetProcessImageFileName  GetProcessImageFileNameA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\psapi\profile.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <imagehlp.h>
#include <psapi.h>
#include <stdlib.h>
#include <stdio.h>


#define MAX_SYMNAME_SIZE  1024
CHAR symBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL ThisSymbol = (PIMAGEHLP_SYMBOL) symBuffer;

CHAR LastSymBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL LastSymbol = (PIMAGEHLP_SYMBOL) LastSymBuffer;

CHAR BadSymBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE];
PIMAGEHLP_SYMBOL BadSymbol = (PIMAGEHLP_SYMBOL)BadSymBuffer;

BOOL UseLastSymbol;


typedef struct _PROFILE_BLOCK {
    HANDLE Handle;
    HANDLE SecondaryHandle;
    PVOID ImageBase;
    BOOL SymbolsLoaded;
    PULONG CodeStart;
    ULONG CodeLength;
    PULONG Buffer;
    PULONG SecondaryBuffer;
    ULONG BufferSize;
    ULONG TextNumber;
    ULONG BucketSize;
    PUNICODE_STRING ImageName;
    char *ImageFileName;
} PROFILE_BLOCK;

ULONG ProfilePageSize;


#define MAX_BYTE_PER_LINE       72
#define MAX_PROFILE_COUNT 100
#define SYM_HANDLE ((HANDLE)UlongToPtr(0xffffffff))

PROFILE_BLOCK ProfileObject[MAX_PROFILE_COUNT+1];

ULONG NumberOfProfileObjects = 0;

ULONG ProfileInterval = 4882;

#define BUCKETSIZE 4
int PowerOfBytesCoveredPerBucket = 2;
CHAR SymbolSearchPathBuf[4096];
LPSTR SymbolSearchPath = SymbolSearchPathBuf;
BOOLEAN ShowAllHits = FALSE;
BOOLEAN fKernel = FALSE;

PCHAR OutputFile = "profile.out";

KPROFILE_SOURCE ProfileSource = ProfileTime;
KPROFILE_SOURCE SecondaryProfileSource = ProfileTime;
BOOLEAN UseSecondaryProfile = FALSE;

//
// define the mappings between arguments and KPROFILE_SOURCE types
//

typedef struct _PROFILE_SOURCE_MAPPING {
    PCHAR   Name;
    KPROFILE_SOURCE Source;
} PROFILE_SOURCE_MAPPING, *PPROFILE_SOURCE_MAPPING;

PROFILE_SOURCE_MAPPING ProfileSourceMapping[] = {
    {NULL,0}
    };

VOID
PsParseCommandLine(
    VOID
    );

VOID
PsWriteProfileLine(
    IN HANDLE ProfileHandle,
    IN PSZ Line,
    IN int nbytes
    )
{
    IO_STATUS_BLOCK IoStatusBlock;

    NtWriteFile(
        ProfileHandle,
        NULL,
        NULL,
        NULL,
        &IoStatusBlock,
        Line,
        (ULONG)nbytes,
        NULL,
        NULL
        );

}

NTSTATUS
PsInitializeAndStartProfile(
    VOID
    )
{
    HANDLE CurrentProcessHandle;
    SIZE_T BufferSize;
    PVOID ImageBase;
    PULONG CodeStart;
    ULONG CodeLength;
    PULONG Buffer;
    PPEB Peb;
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry;
    PUNICODE_STRING ImageName;
    PLIST_ENTRY Next;
    SYSTEM_BASIC_INFORMATION SystemInfo;
    NTSTATUS status;
    ULONG i;
    CHAR Bogus[256];
    CHAR *ImageFileName;
    SIZE_T WsMin, WsMax;
    ULONG ModuleNumber;
    CHAR ModuleInfoBuffer[64000];
    ULONG ReturnedLength;
    PRTL_PROCESS_MODULES Modules;
    PRTL_PROCESS_MODULE_INFORMATION Module;
    BOOLEAN PreviousProfilePrivState;
    BOOLEAN PreviousQuotaPrivState;
    BOOLEAN Done = FALSE;
    BOOLEAN DuplicateObject = FALSE;


    //
    // Get the page size.
    //

    status = NtQuerySystemInformation (SystemBasicInformation,
                                       &SystemInfo,
                                       sizeof(SystemInfo),
                                       NULL);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Load kernel modules
    //
    if (fKernel) {
        status = NtQuerySystemInformation (
                        SystemModuleInformation,
                        ModuleInfoBuffer,
                        sizeof( ModuleInfoBuffer ),
                        &ReturnedLength);
        if (!NT_SUCCESS(status)) {
            DbgPrint("query system info failed status - %lx\n",status);
            fKernel = FALSE;
        } else {
            Modules = (PRTL_PROCESS_MODULES)ModuleInfoBuffer;
            Module = &Modules->Modules[ 0 ];
                ModuleNumber = 0;

            status = RtlAdjustPrivilege(
                         SE_SYSTEM_PROFILE_PRIVILEGE,
                         TRUE,              //Enable
                         FALSE,             //not impersonating
                         &PreviousProfilePrivState
                         );

            if (!NT_SUCCESS(status) || status == STATUS_NOT_ALL_ASSIGNED) {
                DbgPrint("Enable system profile privilege failed - status 0x%lx\n",
                                status);
            }

            status = RtlAdjustPrivilege(
                         SE_INCREASE_QUOTA_PRIVILEGE,
                         TRUE,              //Enable
                         FALSE,             //not impersonating
                         &PreviousQuotaPrivState
                         );

            if (!NT_SUCCESS(status) || status == STATUS_NOT_ALL_ASSIGNED) {
                DbgPrint("Unable to increase quota privilege (status=0x%lx)\n",
                                status);
            }
        }
    }

    ProfilePageSize = SystemInfo.PageSize;

    //
    // Locate all the executables in the address and create a
    // seperate profile object for each one.
    //

    CurrentProcessHandle = NtCurrentProcess();

    Peb = NtCurrentPeb();

    Next = Peb->Ldr->InMemoryOrderModuleList.Flink;
    while (!Done) {
        if ( Next != &Peb->Ldr->InMemoryOrderModuleList) {
            LdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY) (CONTAINING_RECORD(
                                Next,
                                LDR_DATA_TABLE_ENTRY,
                                InMemoryOrderLinks
                                ));

            Next = Next->Flink;

            ImageBase = LdrDataTableEntry->DllBase;
            ImageName = &LdrDataTableEntry->BaseDllName;
            CodeLength = LdrDataTableEntry->SizeOfImage;
            CodeStart = (PULONG)ImageBase;

            ImageFileName = HeapAlloc(GetProcessHeap(), 0, 256);
            if (!ImageFileName) {
                status = STATUS_NO_MEMORY;
                return status;
            }
            status = RtlUnicodeToOemN( ImageFileName,
                                       256,
                                       &i,
                                       ImageName->Buffer,
                                       ImageName->Length
                                     );
            ImageFileName[i] = 0;

            if (status != STATUS_SUCCESS) {
                HeapFree(GetProcessHeap(), 0, ImageFileName);
                continue;
            }
        } else
        if (fKernel && (ModuleNumber < Modules->NumberOfModules)) {
            ULONG cNameMBLength = lstrlen(&Module->FullPathName[Module->OffsetToFileName]) + 1;
            ULONG cNameUCLength = cNameMBLength * sizeof(WCHAR);
            ULONG cNameSize = cNameUCLength + sizeof(UNICODE_STRING);

            ImageFileName = HeapAlloc(GetProcessHeap(), 0, cNameMBLength);
            if (!ImageFileName) {
                status = STATUS_NO_MEMORY;
                return status;
            }
            lstrcpy(ImageFileName, &Module->FullPathName[Module->OffsetToFileName]);

            ImageBase = Module->ImageBase;
            CodeLength = Module->ImageSize;
            CodeStart = (PULONG)ImageBase;
            ImageName = HeapAlloc(GetProcessHeap(), 0, cNameSize);
            if (!ImageName) {
                status = STATUS_NO_MEMORY;
                return status;
            }

            ImageName->Buffer = (WCHAR *)((PBYTE)ImageName + sizeof(UNICODE_STRING));
            RtlMultiByteToUnicodeN(ImageName->Buffer, cNameUCLength, &i,
                                   &Module->FullPathName[Module->OffsetToFileName],
                                   cNameMBLength);
            ImageName->Length = (USHORT)i;
            Module++;
            ModuleNumber++;
        } else {
            Done = TRUE;
            break;
        }

        DuplicateObject = FALSE;

        for (i = 0; i < NumberOfProfileObjects ; i++ ) {
            if (ImageBase == ProfileObject[i].ImageBase)
                DuplicateObject = TRUE;
        }

        if (DuplicateObject) {
            continue;
        }

        ProfileObject[NumberOfProfileObjects].ImageBase = ImageBase;
        ProfileObject[NumberOfProfileObjects].ImageName = ImageName;
        ProfileObject[NumberOfProfileObjects].ImageFileName = ImageFileName;

        ProfileObject[NumberOfProfileObjects].CodeLength = CodeLength;
        ProfileObject[NumberOfProfileObjects].CodeStart = CodeStart;
        ProfileObject[NumberOfProfileObjects].TextNumber = 1;

        //
        // Analyze the size of the code and create a reasonably sized
        // profile object.
        //

        BufferSize = ((CodeLength * BUCKETSIZE) >> PowerOfBytesCoveredPerBucket) + 4;
        Buffer = NULL;

        status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                          (PVOID *)&Buffer,
                                          0,
                                          &BufferSize,
                                          MEM_RESERVE | MEM_COMMIT,
                                          PAGE_READWRITE);

        if (!NT_SUCCESS(status)) {
            DbgPrint ("RtlInitializeProfile : alloc VM failed %lx\n",status);
            return status;
        }

        ProfileObject[NumberOfProfileObjects].Buffer = Buffer;
        ProfileObject[NumberOfProfileObjects].BufferSize = (ULONG)BufferSize;
        ProfileObject[NumberOfProfileObjects].BucketSize = PowerOfBytesCoveredPerBucket;

        status = NtCreateProfile (
                    &ProfileObject[NumberOfProfileObjects].Handle,
                    CurrentProcessHandle,
                    ProfileObject[NumberOfProfileObjects].CodeStart,
                    ProfileObject[NumberOfProfileObjects].CodeLength,
                    ProfileObject[NumberOfProfileObjects].BucketSize,
                    ProfileObject[NumberOfProfileObjects].Buffer ,
                    ProfileObject[NumberOfProfileObjects].BufferSize,
                    ProfileSource,
                    (KAFFINITY)-1);

        if (status != STATUS_SUCCESS) {
            DbgPrint("create profile %wZ failed - status %lx\n",
                   ProfileObject[NumberOfProfileObjects].ImageName,status);
            return status;
        }

        if (UseSecondaryProfile) {
            Buffer = NULL;
            status = NtAllocateVirtualMemory (CurrentProcessHandle,
                                              (PVOID *)&Buffer,
                                              0,
                                              &BufferSize,
                                              MEM_RESERVE | MEM_COMMIT,
                                              PAGE_READWRITE);

            if (!NT_SUCCESS(status)) {
                DbgPrint ("RtlInitializeProfile : secondary alloc VM failed %lx\n",status);
                return status;
            }

            ProfileObject[NumberOfProfileObjects].SecondaryBuffer = Buffer;

            status = NtCreateProfile (
                        &ProfileObject[NumberOfProfileObjects].SecondaryHandle,
                        CurrentProcessHandle,
                        ProfileObject[NumberOfProfileObjects].CodeStart,
                        ProfileObject[NumberOfProfileObjects].CodeLength,
                        ProfileObject[NumberOfProfileObjects].BucketSize,
                        ProfileObject[NumberOfProfileObjects].SecondaryBuffer,
                        ProfileObject[NumberOfProfileObjects].BufferSize,
                        SecondaryProfileSource,
                        (KAFFINITY)-1);

            if (status != STATUS_SUCCESS) {
                DbgPrint("create profile %wZ failed - status %lx\n",
                       ProfileObject[NumberOfProfileObjects].ImageName,status);
                return status;
            }
        }

        NumberOfProfileObjects++;

        if (NumberOfProfileObjects == MAX_PROFILE_COUNT) {
            break;
        }
    }

    NtSetIntervalProfile(ProfileInterval,ProfileSource);
    if (UseSecondaryProfile) {
        NtSetIntervalProfile(ProfileInterval,SecondaryProfileSource);
    }

    for (i = 0; i < NumberOfProfileObjects; i++) {

        status = NtStartProfile (ProfileObject[i].Handle);

        if (status == STATUS_WORKING_SET_QUOTA) {

            //
            // Increase the working set to lock down a bigger buffer.
            //

            GetProcessWorkingSetSize(CurrentProcessHandle,&WsMin,&WsMax);

            WsMax += 10*ProfilePageSize + ProfileObject[i].BufferSize;
            WsMin += 10*ProfilePageSize + ProfileObject[i].BufferSize;

            SetProcessWorkingSetSize(CurrentProcessHandle,WsMin,WsMax);

            status = NtStartProfile (ProfileObject[i].Handle);
        }

        if (status != STATUS_SUCCESS) {
            DbgPrint("start profile %wZ failed - status %lx\n",
                ProfileObject[i].ImageName, status);
            return status;
        }

        if (UseSecondaryProfile) {
            status = NtStartProfile (ProfileObject[i].SecondaryHandle);

            if (status == STATUS_WORKING_SET_QUOTA) {

                //
                // Increase the working set to lock down a bigger buffer.
                //

                GetProcessWorkingSetSize(CurrentProcessHandle,&WsMin,&WsMax);

                WsMax += 10*ProfilePageSize + ProfileObject[i].BufferSize;
                WsMin += 10*ProfilePageSize + ProfileObject[i].BufferSize;

                SetProcessWorkingSetSize(CurrentProcessHandle,WsMin,WsMax);

                status = NtStartProfile (ProfileObject[i].SecondaryHandle);
            }

            if (status != STATUS_SUCCESS) {
                DbgPrint("start secondary profile %wZ failed - status %lx\n",
                    ProfileObject[i].ImageName, status);
                return status;
            }
        }
    }
    return status;
}


unsigned long
Percent(
    unsigned long arg1,
    unsigned long arg2,
    unsigned long * Low
    )
{
    unsigned long iarg1 = arg1;
    unsigned __int64 iarg2 = arg2 * 100000;
    unsigned long diff, High;

    diff = (unsigned long) (iarg2 / iarg1);
    while (diff > 100000) {
        diff /= 100000;
    }
    High = diff / 1000;
    *Low = diff % 1000;
    return(High);
}

NTSTATUS
PsStopAndAnalyzeProfile(
    VOID
    )
{
    NTSTATUS status;
    ULONG CountAtSymbol;
    ULONG SecondaryCountAtSymbol;
    NTSTATUS Status;
    ULONG_PTR Va;
    HANDLE ProfileHandle;
    CHAR Line[512];
    ULONG i, n, High, Low;
    PULONG Buffer, BufferEnd, Counter, InitialCounter;
    PULONG SecondaryBuffer;
    PULONG SecondaryInitialCounter;
    ULONG TotalCounts;
    ULONG ByteCount;
    IMAGEHLP_MODULE ModuleInfo;
    SIZE_T dwDisplacement;

    ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);

    __try {
        // If there's a problem faulting in the symbol handler, just return.

        //
        // initialize the symbol handler
        //
        ThisSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
        ThisSymbol->MaxNameLength = MAX_SYMNAME_SIZE;
        LastSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
        LastSymbol->MaxNameLength = MAX_SYMNAME_SIZE;
        SymSetOptions( SYMOPT_UNDNAME | SYMOPT_CASE_INSENSITIVE | SYMOPT_OMAP_FIND_NEAREST);
        SymInitialize( SYM_HANDLE, NULL, FALSE );
        SymGetSearchPath( SYM_HANDLE, SymbolSearchPathBuf, sizeof(SymbolSearchPathBuf) );

        ZeroMemory( BadSymBuffer, sizeof(BadSymBuffer) );
        BadSymbol->Name[0] = (BYTE)lstrlen("No Symbol Found");
        lstrcpy( &BadSymbol->Name[1], "No Symbol Found" );
        BadSymbol->SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
        BadSymbol->MaxNameLength = MAX_SYMNAME_SIZE;

        ProfileHandle = CreateFile(
                            OutputFile,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );

        if ( ProfileHandle == INVALID_HANDLE_VALUE ) {
            return STATUS_UNSUCCESSFUL;
        }

        for (i = 0; i < NumberOfProfileObjects; i++) {
            Status = NtStopProfile (ProfileObject[i].Handle);
        }

        if (MAX_PROFILE_COUNT == NumberOfProfileObjects) {
            n = sprintf(Line,"Overflowed the maximum number of "
                            "modules: %d\n",
                        MAX_PROFILE_COUNT
                        );
            PsWriteProfileLine(ProfileHandle,Line,n);
        }

        //
        // The new profiler
        //
        for (i = 0; i < NumberOfProfileObjects; i++)  {

            UseLastSymbol = FALSE;
            CountAtSymbol = 0;
            SecondaryCountAtSymbol = 0;

            //
            // Sum the total number of cells written.
            //
            BufferEnd = ProfileObject[i].Buffer + (
                        ProfileObject[i].BufferSize / sizeof(ULONG));
            Buffer = ProfileObject[i].Buffer;
            Counter = BufferEnd;

            if (UseSecondaryProfile) {
                SecondaryBuffer = ProfileObject[i].SecondaryBuffer;
            }

            TotalCounts = 0;
            while (Counter > Buffer) {
                Counter -= 1;
                TotalCounts += *Counter;
            }

            if (!TotalCounts) {
                // Don't bother wasting time loading symbols
                continue;
            }

            if (SymLoadModule( SYM_HANDLE, NULL, ProfileObject[i].ImageFileName, NULL,
                                                    (DWORD_PTR)ProfileObject[i].ImageBase, 0)
                    && SymGetModuleInfo(SYM_HANDLE, (DWORD_PTR)ProfileObject[i].ImageBase, &ModuleInfo)
                    && (ModuleInfo.SymType != SymNone)
                )
            {
                ProfileObject[i].SymbolsLoaded = TRUE;
            } else {
                ProfileObject[i].SymbolsLoaded = FALSE;
            }

            n= sprintf(Line,"%d,%wZ,Total%s\n",
                    TotalCounts,
                    ProfileObject[i].ImageName,
                    (ProfileObject[i].SymbolsLoaded) ? "" : " (NO SYMBOLS)"
                    );
            PsWriteProfileLine(ProfileHandle,Line,n);

            if (ProfileObject[i].SymbolsLoaded) {

                InitialCounter = Buffer;
                if (UseSecondaryProfile) {
                    SecondaryInitialCounter = SecondaryBuffer;
                }
                for ( Counter = Buffer; Counter < BufferEnd; Counter += 1 ) {
                    if ( *Counter ) {

                        //
                        // Now we have an an address relative to the buffer
                        // base.
                        //

                        Va = ((PUCHAR)Counter - (PUCHAR)Buffer);
                        Va = Va * ( 1 << (ProfileObject[i].BucketSize - 2));

                        //
                        // Add in the image base and the base of the
                        // code to get the Va in the image
                        //

                        Va = Va + (ULONG_PTR)ProfileObject[i].CodeStart;

                        if (SymGetSymFromAddr( SYM_HANDLE, Va, &dwDisplacement, ThisSymbol )) {
                            if ( UseLastSymbol && LastSymbol->Address == ThisSymbol->Address ) {
                                CountAtSymbol += *Counter;
                                if (UseSecondaryProfile) {
                                    SecondaryCountAtSymbol += *(SecondaryBuffer + (Counter-Buffer));
                                }
                            } else {
                                if ( UseLastSymbol && LastSymbol->Address ) {
                                    if ( CountAtSymbol || SecondaryCountAtSymbol) {
                                        if (!UseSecondaryProfile) {
                                            n= sprintf(Line,"%d,%wZ,%s (%08lx)\n",
                                                        CountAtSymbol,
                                                        ProfileObject[i].ImageName,
                                                        LastSymbol->Name,
                                                        LastSymbol->Address
                                                        );
                                        } else {
                                            if (SecondaryCountAtSymbol != 0) {
                                                High = Percent(CountAtSymbol, SecondaryCountAtSymbol, &Low);
                                                n = sprintf(Line,"%d,%d,%2.2d.%3.3d,%wZ,%s (%08lx)\n",
                                                            CountAtSymbol,
                                                            SecondaryCountAtSymbol,
                                                            High, Low,
                                                            ProfileObject[i].ImageName,
                                                            LastSymbol->Name,
                                                            LastSymbol->Address
                                                            );
                                            } else {
                                                n = sprintf(Line,"%d,%d, -- ,%wZ,%s (%08lx)\n",
                                                            CountAtSymbol,
                                                            SecondaryCountAtSymbol,
                                                            ProfileObject[i].ImageName,
                                                            LastSymbol->Name,
                                                            LastSymbol->Address
                                                            );
                                            }
                                        }
                                        PsWriteProfileLine(ProfileHandle,Line,n);
                                        if (ShowAllHits) {
                                            while (InitialCounter < Counter) {
                                                if (*InitialCounter) {
                                                    Va = ((PUCHAR)InitialCounter - (PUCHAR)Buffer);
                                                    Va = Va * (1 << (ProfileObject[i].BucketSize - 2));
                                                    Va = Va + (ULONG_PTR)ProfileObject[i].CodeStart;
                                                    if (!UseSecondaryProfile) {
                                                        n = sprintf(Line, "\t%p:%d\n",
                                                                    Va,
                                                                    *InitialCounter);
                                                    } else {
                                                        if (*SecondaryInitialCounter != 0) {
                                                            High = Percent(*InitialCounter, *SecondaryInitialCounter, &Low);
                                                            n = sprintf(Line, "\t%p:%d, %d, %2.2d.%3.3d\n",
                                                                        Va,
                                                                        *InitialCounter,
                                                                        *SecondaryInitialCounter,
                                                                        High, Low);
                                                        } else {
                                                            n = sprintf(Line, "\t%p:%d, %d, --\n",
                                                                        Va,
                                                                        *InitialCounter,
                                                                        *SecondaryInitialCounter);
                                                        }
                                                    }
                                                    PsWriteProfileLine(ProfileHandle, Line, n);
                                                }
                                                ++InitialCounter;
                                                ++SecondaryInitialCounter;
                                            }
                                        }

                                    }
                                }
                                InitialCounter = Counter;
                                CountAtSymbol = *Counter;
                                if (UseSecondaryProfile) {
                                    SecondaryInitialCounter = SecondaryBuffer + (Counter-Buffer);
                                    SecondaryCountAtSymbol += *(SecondaryBuffer + (Counter-Buffer));
                                }
                                memcpy( LastSymBuffer, symBuffer, sizeof(symBuffer) );
                                UseLastSymbol = TRUE;
                            }
                        } else {
                            if (CountAtSymbol || SecondaryCountAtSymbol) {
                                if (!UseSecondaryProfile) {
                                    n= sprintf(Line,"%d,%wZ,%s (%08lx)\n",
                                                CountAtSymbol,
                                                ProfileObject[i].ImageName,
                                                LastSymbol->Name,
                                                LastSymbol->Address
                                                );
                                } else {
                                    if (SecondaryCountAtSymbol != 0) {
                                        High = Percent(CountAtSymbol, SecondaryCountAtSymbol, &Low);
                                        n = sprintf(Line,"%d,%d,%2.2d.%3.3d,%wZ,%s (%08lx)\n",
                                                    CountAtSymbol,
                                                    SecondaryCountAtSymbol,
                                                    High, Low,
                                                    ProfileObject[i].ImageName,
                                                    LastSymbol->Name,
                                                    LastSymbol->Address
                                                    );
                                    } else {
                                        n = sprintf(Line,"%d,%d, -- ,%wZ,%s (%08lx)\n",
                                                    CountAtSymbol,
                                                    SecondaryCountAtSymbol,
                                                    ProfileObject[i].ImageName,
                                                    LastSymbol->Name,
                                                    LastSymbol->Address
                                                    );
                                    }
                                }
                                PsWriteProfileLine(ProfileHandle,Line,n);
                                if (ShowAllHits) {
                                    while (InitialCounter < Counter) {
                                        if (*InitialCounter) {
                                            Va = ((PUCHAR)InitialCounter - (PUCHAR)Buffer);
                                            Va = Va * (1 << (ProfileObject[i].BucketSize - 2));
                                            Va = Va + (ULONG_PTR)ProfileObject[i].CodeStart;
                                            if (!UseSecondaryProfile) {
                                                n = sprintf(Line, "\t%p:%d\n",
                                                            Va,
                                                            *InitialCounter);
                                            } else {
                                                if (*SecondaryInitialCounter != 0) {
                                                    High = Percent(*InitialCounter, *SecondaryInitialCounter, &Low);
                                                    n = sprintf(Line, "\t%p:%d, %d, %2.2d.%3.3d\n",
                                                                Va,
                                                                *InitialCounter,
                                                                *SecondaryInitialCounter,
                                                                High,Low);
                                                } else {
                                                    n = sprintf(Line, "\t%p:%d, %d, --\n",
                                                                Va,
                                                                *InitialCounter,
                                                                *SecondaryInitialCounter);
                                                }
                                            }
                                            PsWriteProfileLine(ProfileHandle, Line, n);
                                        }
                                        ++InitialCounter;
                                        ++SecondaryInitialCounter;
                                    }
                                }

                                InitialCounter = Counter;
                                CountAtSymbol = *Counter;
                                if (UseSecondaryProfile) {
                                    SecondaryInitialCounter = SecondaryBuffer + (Counter-Buffer);
                                    SecondaryCountAtSymbol += *(SecondaryBuffer + (Counter-Buffer));
                                }
                                memcpy( LastSymBuffer, BadSymBuffer, sizeof(BadSymBuffer) );
                                UseLastSymbol = TRUE;
                            }
                            else {
                                n = sprintf(Line,"%d,%wZ,Unknown (%p)\n",
                                            CountAtSymbol,
                                            ProfileObject[i].ImageName,
                                            Va
                                            );
                                PsWriteProfileLine(ProfileHandle, Line, n);
                            }
                        }
                    }
                }

                if ( CountAtSymbol || SecondaryCountAtSymbol ) {
                    if (!UseSecondaryProfile) {
                        n= sprintf(Line,"%d,%wZ,%s (%08lx)\n",
                                    CountAtSymbol,
                                    ProfileObject[i].ImageName,
                                    LastSymbol->Name,
                                    LastSymbol->Address
                                    );
                    } else {
                        if (SecondaryCountAtSymbol != 0) {
                            High = Percent(CountAtSymbol, SecondaryCountAtSymbol, &Low);
                            n = sprintf(Line,"%d,%d,%2.2d.%3.3d,%wZ,%s (%08lx)\n",
                                        CountAtSymbol,
                                        SecondaryCountAtSymbol,
                                        High, Low,
                                        ProfileObject[i].ImageName,
                                        LastSymbol->Name,
                                        LastSymbol->Address
                                        );
                        } else {
                            n = sprintf(Line,"%d,%d, -- ,%wZ,%s (%08lx)\n",
                                        CountAtSymbol,
                                        SecondaryCountAtSymbol,
                                        ProfileObject[i].ImageName,
                                        LastSymbol->Name,
                                        LastSymbol->Address
                                        );
                        }
                    }
                    PsWriteProfileLine(ProfileHandle,Line,n);
                    if (ShowAllHits) {
                        while (InitialCounter < Counter) {
                            if (*InitialCounter) {
                                Va = ((PUCHAR)InitialCounter - (PUCHAR)Buffer);
                                Va = Va * (1 << (ProfileObject[i].BucketSize - 2));
                                Va = Va + (ULONG_PTR)ProfileObject[i].CodeStart;
                                if (!UseSecondaryProfile) {
                                    n = sprintf(Line, "\t%p:%d\n",
                                                Va,
                                                *InitialCounter);
                                } else {
                                    if (*SecondaryInitialCounter != 0) {
                                        High = Percent(*InitialCounter, *SecondaryInitialCounter, &Low);
                                        n = sprintf(Line, "\t%p:%d, %d, %2.2d.%3.3d\n",
                                                    Va,
                                                    *InitialCounter,
                                                    *SecondaryInitialCounter,
                                                    High, Low);
                                    } else {
                                        n = sprintf(Line, "\t%p:%d, %d, --\n",
                                                    Va,
                                                    *InitialCounter,
                                                    *SecondaryInitialCounter);
                                    }
                                }
                                PsWriteProfileLine(ProfileHandle, Line, n);
                            }
                            ++InitialCounter;
                            ++SecondaryInitialCounter;
                        }
                    }
                }
                SymUnloadModule( SYM_HANDLE, (DWORD_PTR)ProfileObject[i].ImageBase);
            }
        }

        for (i = 0; i < NumberOfProfileObjects; i++) {
            Buffer = ProfileObject[i].Buffer;
            RtlZeroMemory(Buffer,ProfileObject[i].BufferSize);
        }
        CloseHandle(ProfileHandle);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
    }

    return STATUS_SUCCESS;
}

BOOLEAN
DllMain(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )

{
    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(DllHandle);
        if ( NtCurrentPeb()->ProcessParameters->Flags & RTL_USER_PROC_PROFILE_USER ) {
            PsParseCommandLine();
            PsInitializeAndStartProfile();
        }
        break;

    case DLL_PROCESS_DETACH:
        if ( NtCurrentPeb()->ProcessParameters->Flags & RTL_USER_PROC_PROFILE_USER ) {
            PsStopAndAnalyzeProfile();
        }
        break;

    }

    return TRUE;
}


char *
Mystrtok (
    char * string,
    const char * control
    )
{
    unsigned char *str;
    const unsigned char *ctrl = control;

    unsigned char map[32];
    int count;

    static char *nextoken;

    /* Clear control map */
    for (count = 0; count < 32; count++)
        map[count] = 0;

    /* Set bits in delimiter table */
    do {
        map[*ctrl >> 3] |= (1 << (*ctrl & 7));
    } while (*ctrl++);

    /* Initialize str. If string is NULL, set str to the saved
     * pointer (i.e., continue breaking tokens out of the string
     * from the last strtok call) */
    if (string)
        str = string;
    else
        str = nextoken;

    /* Find beginning of token (skip over leading delimiters). Note that
     * there is no token iff this loop sets str to point to the terminal
     * null (*str == '\0') */
    while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
        str++;

    string = str;

    /* Find the end of the token. If it is not the end of the string,
     * put a null there. */
    for ( ; *str ; str++ )
        if ( map[*str >> 3] & (1 << (*str & 7)) ) {
            *str++ = '\0';
            break;
        }

    /* Update nextoken (or the corresponding field in the per-thread data
     * structure */
    nextoken = str;

    /* Determine if a token has been found. */
    if ( string == str )
        return NULL;
    else
        return string;
}


VOID
PsParseCommandLine(
    VOID
    )
{
    PCHAR CommandLine;
    PCHAR Argument;
    HANDLE MappingHandle;
    PPROFILE_SOURCE_MAPPING ProfileMapping;

    //
    // The original command line is in a shared memory section
    // named "ProfileStartupParameters"
    //
    MappingHandle = OpenFileMapping(FILE_MAP_WRITE,
                                    FALSE,
                                    "ProfileStartupParameters");
    if (MappingHandle != NULL) {
        CommandLine = MapViewOfFile(MappingHandle,
                                    FILE_MAP_WRITE,
                                    0,
                                    0,
                                    0);
        if (!CommandLine) {
            CloseHandle(MappingHandle);
            return;
        }
    } else {
        return;
    }

    Argument = Mystrtok(CommandLine," \t");

    while (Argument != NULL) {
        if ((Argument[0] == '-') ||
            (Argument[0] == '/')) {
            switch (Argument[1]) {
                case 'a':
                case 'A':
                    ShowAllHits = TRUE;
                    break;

                case 'b':
                case 'B':
                    PowerOfBytesCoveredPerBucket = atoi(&Argument[2]);
                    break;

                case 'f':
                case 'F':
                        //
                        // The arg area is unmapped so we copy the string
                                        //
                    OutputFile = HeapAlloc(GetProcessHeap(), 0,
                                            lstrlen(&Argument[2]) + 1);
                    lstrcpy(OutputFile, &Argument[2]);

                case 'i':
                case 'I':
                    ProfileInterval = atoi(&Argument[2]);
                    break;

                case 'k':
                case 'K':
                    fKernel = TRUE;
                    break;

                case 's':
                    ProfileMapping = ProfileSourceMapping;
                    while (ProfileMapping->Name != NULL) {
                        if (_stricmp(ProfileMapping->Name, &Argument[2])==0) {
                            ProfileSource = ProfileMapping->Source;
                            break;
                        }
                        ++ProfileMapping;
                    }
                    break;

                case 'S':
                    ProfileMapping = ProfileSourceMapping;
                    while (ProfileMapping->Name != NULL) {
                        if (_stricmp(ProfileMapping->Name, &Argument[2])==0) {
                            SecondaryProfileSource = ProfileMapping->Source;
                            UseSecondaryProfile = TRUE;
                            break;
                        }
                        ++ProfileMapping;
                    }
                    break;

            }
        }

        Argument = Mystrtok(NULL," \t");
    }

    UnmapViewOfFile(CommandLine);
    CloseHandle(MappingHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pstat\makefile.inc ===
$(O)\win32k\services.tab: $(WINDOWS_INC_PATH)\services.tab
    @-mkdir $(O)\win32k
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

$(O)\kernel\services.tab: $(BASE_INC_PATH)\services.tab
    @-mkdir $(O)\kernel
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

syssvc.h: $(O)\kernel\services.tab syssvc.stb
    gensrv -d . -e c -g . -stubs syssvc.h -sstb syssvc.stb -B $(O)\kernel

w32svc.h: $(O)\win32k\services.tab w32svc.stb
    gensrv -d . -e c -g . -stubs w32svc.h -sstb w32svc.stb -B -R $(O)\win32k

svcnames.c: syssvc.h w32svc.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pstat\svcnames.c ===
#include <nt.h>

#include "syssvc.h"
#include "w32svc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pstat\sortcall.c ===
#include <nt.h>

VOID
SortUlongData (
    IN ULONG Count,
    IN ULONG Index[],
    IN ULONG Data[]
    )

{

    LONG i;
    LONG j;
    ULONG k;

    //
    // Initialize the index array.
    //

    i = 0;
    do {
        Index[i] = i;
        i += 1;
    } while (i < (LONG)Count);

    //
    // Perform an indexed bubble sort on long data.
    //

    i = 0;
    do {
        for (j = i; j >= 0; j -= 1) {
            if (Data[Index[j]] >= Data[Index[j + 1]]) {
                break;
            }

            k = Index[j];
            Index[j] = Index[j + 1];
            Index[j + 1] = k;
        }

        i += 1;
    } while (i < (LONG)(Count - 1));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pstat\ntimer.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <..\ztools\inc\tools.h>

#define NUMBER_SERVICE_TABLES 2
#define BUFFER_SIZE 1024

VOID
SortUlongData (
    IN ULONG Count,
    IN ULONG Index[],
    IN ULONG Data[]
    );

extern UCHAR *CallTable[];

ULONG SystemCallBufferStart[BUFFER_SIZE];
ULONG SystemCallBufferDone[BUFFER_SIZE];
ULONG Index[BUFFER_SIZE];
ULONG CallData[BUFFER_SIZE];

#define MAX_PROCESSOR 16
SYSTEM_BASIC_INFORMATION BasicInfo;
SYSTEM_PERFORMANCE_INFORMATION SystemInfoStart;
SYSTEM_PERFORMANCE_INFORMATION SystemInfoDone;
SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION    ProcessorInfoStart[MAX_PROCESSOR];
SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION    ProcessorInfoDone[MAX_PROCESSOR];

#define vdelta(FLD) (VdmInfoDone.FLD - VdmInfoStart.FLD)

#ifdef i386
    SYSTEM_VDM_INSTEMUL_INFO VdmInfoStart;
    SYSTEM_VDM_INSTEMUL_INFO VdmInfoDone;
#endif

HANDLE
GetServerProcessHandle( VOID )
{
    HANDLE Process;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING Unicode;
    NTSTATUS Status;

    RtlInitUnicodeString(&Unicode, L"\\WindowsSS");
    InitializeObjectAttributes(
        &Obja,
        &Unicode,
        0,
        NULL,
        NULL
        );
    Status = NtOpenProcess(
                &Process,
                PROCESS_ALL_ACCESS,
                &Obja,
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        printf("OpenProcess Failed %lx\n",Status);
        Process = NULL;
        }
    return Process;
}

BOOL WINAPI
CtrlcHandler(
    ULONG CtrlType
    )
{
    //
    // Ignore control C interrupts.  Let child process deal with them
    // if it wants.  If it doesn't then it will terminate and we will
    // get control and terminate ourselves
    //
    return TRUE;
}


int
__cdecl main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    LPSTR s;
    BOOL bFull;
    BOOL bOneLine;
    BOOL bSyscall;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL b;
    VM_COUNTERS ServerVmInfoStart, ServerVmInfoDone, ProcessVmInfoStart, ProcessVmInfoDone;
    KERNEL_USER_TIMES Times, ServerStart, ServerDone, ProcessStart, ProcessDone;
    NTSTATUS Status;
    TIME_FIELDS Etime,Utime,Ktime,Itime;
    LARGE_INTEGER RunTime;
    LARGE_INTEGER IdleTime;
    HANDLE OtherProcess;
    ULONG i;
    CHAR ch;
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG Temp;
    ULONG ContextSwitches;
    ULONG FirstLevelFills;
    ULONG SecondLevelFills;
    PSYSTEM_CALL_COUNT_INFORMATION SystemCallInfoStart;
    PSYSTEM_CALL_COUNT_INFORMATION SystemCallInfoDone;
    PULONG SystemCallTableStart;
    PULONG SystemCallTableDone;
    ULONG NumberOfCounts;
    PULONG p;
    BOOL bShowHelpMsg = FALSE;

    argv;
    envp;

    ConvertAppToOem( argc, argv );
    OtherProcess = NULL;
    ProcessHandle = NULL;
    if ( (argc < 2) ) {
        bShowHelpMsg = TRUE;
    }

    SetConsoleCtrlHandler( CtrlcHandler, TRUE );

    ProcessId = 0;

    s = GetCommandLine();
    if( s != NULL ) {
        CharToOem( s, s );
    }
    bFull = FALSE;
    bOneLine = FALSE;
    bSyscall = FALSE;

    //
    // skip blanks
    //
    while(*s>' ')s++;

    //
    // get to next token
    //
    while(*s<=' ')s++;

    while (( *s == '-' ) || ( *s == '/' )) {
        s++;
        while (*s > ' ') {
            switch (*s) {
                case '1' :
                    bOneLine = TRUE;
                    break;

                case 'c' :
                case 'C' :
                    bSyscall = TRUE;
                    break;

                case 'f' :
                case 'F' :
                    bFull = TRUE;
                    break;

                case 's' :
                case 'S' :
                    OtherProcess = GetServerProcessHandle();
                    break;

                case 'P':
                case 'p':
                    // pid takes decimal argument
                    s++;
                    do
                        ch = *s++;
                    while (ch == ' ' || ch == '\t');

                    while (ch >= '0' && ch <= '9') {
                        Temp = ProcessId * 10 + ch - '0';
                        if (Temp < ProcessId) {
                                printf("pid number overflow\n");
                                ExitProcess(1);
                                }
                        ProcessId = Temp;
                        ch = *s++;
                        }
                    if (!ProcessId) {
                        printf("bad pid '%ld'\n", ProcessId);
                        ExitProcess(1);
                        }
                    s--;
                    if ( *s == ' ' ) s--;
                    break;

                case 'h':
                case 'H':
                case '?':
                    bShowHelpMsg = TRUE;
                    break;

                default :
                    break;
                }
            s++;
            }
        //
        // get to next token
        //
        while(*s<=' ')s++;
        }

    // see if this is just a request for command line help.

    if ( bShowHelpMsg ) {
        puts("\n"
             "Usage: ntimer [-1 -f -s] name-of-image [parameters]...\n"
             "\n"
             "    Displays the Elapsed, Kernel, User and Idle time of the\n"
             "    image specified in the command line\n"
             "\n"
             "         -1  displays output on one line\n"
             "         -f  displays the process page faults, total\n"
             "             system interrupts, context switches and system\n"
             "             calls\n"
             "         -s  indicates the name of the image is that of a\n"
             "             server process. Press Ctrl-C to get the times.");
        ExitProcess(1);
    }

    if ( ProcessId ) {
        ProcessHandle = OpenProcess(PROCESS_ALL_ACCESS,FALSE,ProcessId);
        }
    memset(&StartupInfo,0,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);

    if (bOneLine) {
        bSyscall = FALSE;
    }

    if (bSyscall) {
        Status = NtQuerySystemInformation(SystemCallCountInformation,
                                          (PVOID)SystemCallBufferStart,
                                          BUFFER_SIZE * sizeof(ULONG),
                                          NULL);

        bSyscall = FALSE;
        if (!NT_SUCCESS(Status)) {
            printf("Failed to query system call performance information: %x\n", Status);
        } else {

            SystemCallInfoStart = (PVOID)SystemCallBufferStart;
            SystemCallInfoDone = (PVOID)SystemCallBufferDone;

            //
            // Make sure that the number of tables reported by the kernel matches
            // our list.
            //

            if (SystemCallInfoStart->NumberOfTables != NUMBER_SERVICE_TABLES) {
                printf("System call table count (%d) doesn't match NTIMER's count (%d)\n",
                        SystemCallInfoStart->NumberOfTables, NUMBER_SERVICE_TABLES);
            } else {

                //
                // Make sure call count information is available for base services.
                //

                p = (PULONG)(SystemCallInfoStart + 1);

                SystemCallTableStart = (PULONG)(SystemCallInfoStart + 1) + NUMBER_SERVICE_TABLES;
                SystemCallTableDone = (PULONG)(SystemCallInfoDone + 1) + NUMBER_SERVICE_TABLES;

                if (p[0] == 0) {
                    printf("No system call count information available for base services\n");
                } else {

                    //
                    // If there is a hole in the count information (i.e., one set of services
                    // doesn't have counting enabled, but a subsequent one does, then our
                    // indexes will be off, and we'll display the wrong service names.
                    //

                    i = 2;
                    for ( ; i < NUMBER_SERVICE_TABLES; i++ ) {
                        if ((p[i] != 0) && (p[i-1] == 0)) {
                            printf("One or more call count tables empty.  NTIMER can't report\n");
                            break;
                        }
                    }
                    if ( i >= NUMBER_SERVICE_TABLES ) {
                        bSyscall = TRUE;
                        NumberOfCounts = SystemCallInfoStart->Length
                                            - sizeof(SYSTEM_CALL_COUNT_INFORMATION)
                                            - NUMBER_SERVICE_TABLES * sizeof(ULONG);
                    }
                }
            }
        }
    }


    if ( OtherProcess ) {
        Status = NtQueryInformationProcess(
                    OtherProcess,
                    ProcessTimes,
                    &ServerStart,
                    sizeof(Times),
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            ExitProcess((DWORD)Status);
            }
        }

    if ( ProcessHandle ) {
        Status = NtQueryInformationProcess(
                    ProcessHandle,
                    ProcessTimes,
                    &ProcessStart,
                    sizeof(Times),
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            ExitProcess((DWORD)Status);
            }
        }

    if ( bFull ) {

        if ( OtherProcess ) {
            Status = NtQueryInformationProcess(
                        OtherProcess,
                        ProcessVmCounters,
                        &ServerVmInfoStart,
                        sizeof(VM_COUNTERS),
                        NULL
                        );
            if ( !NT_SUCCESS(Status) ) {
                ExitProcess((DWORD)Status);
                }
            }

        if ( ProcessHandle ) {
            Status = NtQueryInformationProcess(
                        ProcessHandle,
                        ProcessVmCounters,
                        &ProcessVmInfoStart,
                        sizeof(VM_COUNTERS),
                        NULL
                        );
            if ( !NT_SUCCESS(Status) ) {
                ExitProcess((DWORD)Status);
                }
            }
        else {
            ZeroMemory(&ProcessVmInfoStart,sizeof(VM_COUNTERS));
            }
#ifdef i386
        Status = NtQuerySystemInformation(
                    SystemVdmInstemulInformation,
                    &VdmInfoStart,
                    sizeof(VdmInfoStart),
                    NULL
                    );

        if (!NT_SUCCESS(Status)) {
            printf("Failed to query vdm information\n");
            ExitProcess((DWORD)Status);
            }
#endif
        Status = NtQuerySystemInformation(
           SystemBasicInformation,
           &BasicInfo,
           sizeof(BasicInfo),
           NULL
        );

        if (!NT_SUCCESS(Status)) {
            printf("Failed to query basic information\n");
            ExitProcess((DWORD)Status);
            }

        Status = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                        (PVOID)&ProcessorInfoStart,
                        sizeof (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * MAX_PROCESSOR,
                        NULL);

        if (!NT_SUCCESS(Status)) {
            printf("Failed to query preocessor performance information\n");
            ExitProcess((DWORD)Status);
            }

        }


    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfoStart,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    ContextSwitches = SystemInfoStart.ContextSwitches;
    FirstLevelFills = SystemInfoStart.FirstLevelTbFills;
    SecondLevelFills = SystemInfoStart.SecondLevelTbFills;
    b = CreateProcess(
            NULL,
            s,
            NULL,
            NULL,
            TRUE,
            0,
            NULL,
            NULL,
            &StartupInfo,
            &ProcessInformation
            );

    if ( !b ) {
        printf("CreateProcess(%s) failed %lx\n",s,GetLastError());
        ExitProcess(GetLastError());
        }

    WaitForSingleObject(ProcessInformation.hProcess,(DWORD)-1);

    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfoDone,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (!bOneLine) {
        printf("\nContextSwitches - %d\nFirst level fills = %d\nSecond level fills = %d\n",
               SystemInfoDone.ContextSwitches - ContextSwitches,
               SystemInfoDone.FirstLevelTbFills - FirstLevelFills,
               SystemInfoDone.SecondLevelTbFills - SecondLevelFills);
    }

    if ( OtherProcess ) {
        Status = NtQueryInformationProcess(
                    OtherProcess,
                    ProcessTimes,
                    &ServerDone,
                    sizeof(Times),
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            ExitProcess((DWORD)Status);
            }
        }

    if ( ProcessHandle ) {
        Status = NtQueryInformationProcess(
                    ProcessHandle,
                    ProcessTimes,
                    &ProcessDone,
                    sizeof(Times),
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            ExitProcess((DWORD)Status);
            }
        }
    else {

        Status = NtQueryInformationProcess(
                    ProcessInformation.hProcess,
                    ProcessTimes,
                    &Times,
                    sizeof(Times),
                    NULL
                    );

        if ( !NT_SUCCESS(Status) ) {
            ExitProcess((DWORD)Status);
            }
        }

    if ( bFull ) {
        if ( OtherProcess ) {
            Status = NtQueryInformationProcess(
                        OtherProcess,
                        ProcessVmCounters,
                        &ServerVmInfoDone,
                        sizeof(VM_COUNTERS),
                        NULL
                        );
            if ( !NT_SUCCESS(Status) ) {
                ExitProcess((DWORD)Status);
                }
            }

        if ( ProcessHandle ) {
            Status = NtQueryInformationProcess(
                        ProcessHandle,
                        ProcessVmCounters,
                        &ProcessVmInfoDone,
                        sizeof(VM_COUNTERS),
                        NULL
                        );
            if ( !NT_SUCCESS(Status) ) {
                ExitProcess((DWORD)Status);
                }
            }
        else {
            Status = NtQueryInformationProcess(
                        ProcessInformation.hProcess,
                        ProcessVmCounters,
                        &ProcessVmInfoDone,
                        sizeof(VM_COUNTERS),
                        NULL
                        );
            if ( !NT_SUCCESS(Status) ) {
                ExitProcess((DWORD)Status);
                }
            }
#ifdef i386
        Status = NtQuerySystemInformation(
                    SystemVdmInstemulInformation,
                    &VdmInfoDone,
                    sizeof(VdmInfoStart),
                    NULL
                    );

        if (!NT_SUCCESS(Status)) {
            printf("Failed to query vdm information\n");
            ExitProcess((DWORD)Status);
            }
#endif

        Status = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                        (PVOID)&ProcessorInfoDone,
                        sizeof (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * MAX_PROCESSOR,
                        NULL);

        if (!NT_SUCCESS(Status)) {
            printf("Failed to query preocessor performance information\n");
            ExitProcess((DWORD)Status);
            }

        }

    if ( bSyscall ) {
        Status = NtQuerySystemInformation(SystemCallCountInformation,
                                          (PVOID)SystemCallBufferDone,
                                          BUFFER_SIZE * sizeof(ULONG),
                                          NULL);

        if (!NT_SUCCESS(Status)) {
            printf("Failed to query system call performance information: %x\n", Status);
            bSyscall = FALSE;
            }
        }

    RunTime.QuadPart = Times.ExitTime.QuadPart - Times.CreateTime.QuadPart;
    IdleTime.QuadPart = SystemInfoDone.IdleProcessTime.QuadPart -
                        SystemInfoStart.IdleProcessTime.QuadPart;
    RtlTimeToTimeFields ( (PLARGE_INTEGER)&IdleTime, &Itime);
    if ( ProcessHandle ) {
        RunTime.QuadPart = ProcessDone.UserTime.QuadPart -
                                                ProcessStart.UserTime.QuadPart;

        RtlTimeToTimeFields ( (PLARGE_INTEGER)&RunTime, &Utime);
        RunTime.QuadPart = ProcessDone.KernelTime.QuadPart -
                                                ProcessStart.KernelTime.QuadPart;

        RtlTimeToTimeFields ( (PLARGE_INTEGER)&RunTime, &Ktime);

        if (bOneLine) {
            printf("%3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld",
                    Utime.Hour,
                    Utime.Minute,
                    Utime.Second,
                    Utime.Milliseconds,
                    Ktime.Hour,
                    Ktime.Minute,
                    Ktime.Second,
                    Ktime.Milliseconds,
                    Itime.Hour,
                    Itime.Minute,
                    Itime.Second,
                    Itime.Milliseconds
                    );
            }
        else {
            printf("ProcessTimes            ");

            printf("UTime( %3ld:%02ld:%02ld.%03ld ) ",
                    Utime.Hour,
                    Utime.Minute,
                    Utime.Second,
                    Utime.Milliseconds
                    );
            printf("KTime( %3ld:%02ld:%02ld.%03ld ) ",
                    Ktime.Hour,
                    Ktime.Minute,
                    Ktime.Second,
                    Ktime.Milliseconds
                    );
            printf("ITime( %3ld:%02ld:%02ld.%03ld )\n",
                    Itime.Hour,
                    Itime.Minute,
                    Itime.Second,
                    Itime.Milliseconds
                    );
            }
        }
    else {
        RtlTimeToTimeFields((PLARGE_INTEGER) &RunTime, &Etime);
        RtlTimeToTimeFields(&Times.UserTime, &Utime);
        RtlTimeToTimeFields(&Times.KernelTime, &Ktime);

        if (bOneLine) {
            printf("%3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld",
                    Etime.Hour,
                    Etime.Minute,
                    Etime.Second,
                    Etime.Milliseconds,
                    Utime.Hour,
                    Utime.Minute,
                    Utime.Second,
                    Utime.Milliseconds,
                    Ktime.Hour,
                    Ktime.Minute,
                    Ktime.Second,
                    Ktime.Milliseconds,
                    Itime.Hour,
                    Itime.Minute,
                    Itime.Second,
                    Itime.Milliseconds
                    );
            }
        else {
            printf("\nETime( %3ld:%02ld:%02ld.%03ld ) ",
                    Etime.Hour,
                    Etime.Minute,
                    Etime.Second,
                    Etime.Milliseconds
                    );
            printf("UTime( %3ld:%02ld:%02ld.%03ld ) ",
                    Utime.Hour,
                    Utime.Minute,
                    Utime.Second,
                    Utime.Milliseconds
                    );
            printf("KTime( %3ld:%02ld:%02ld.%03ld )\n",
                    Ktime.Hour,
                    Ktime.Minute,
                    Ktime.Second,
                    Ktime.Milliseconds
                    );
            printf("ITime( %3ld:%02ld:%02ld.%03ld )\n",
                    Itime.Hour,
                    Itime.Minute,
                    Itime.Second,
                    Itime.Milliseconds
                    );
            }
        }

    if ( OtherProcess ) {
        RunTime.QuadPart = ServerDone.UserTime.QuadPart -
                                                ServerStart.UserTime.QuadPart;

        RtlTimeToTimeFields ( (PLARGE_INTEGER)&RunTime, &Utime);
        RunTime.QuadPart = ServerDone.KernelTime.QuadPart -
                                                ServerStart.KernelTime.QuadPart;

        RtlTimeToTimeFields ( (PLARGE_INTEGER)&RunTime, &Ktime);
        printf("ServerTimes             ");


        if (bOneLine) {
            printf("%3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld",
                    Utime.Hour,
                    Utime.Minute,
                    Utime.Second,
                    Utime.Milliseconds,
                    Ktime.Hour,
                    Ktime.Minute,
                    Ktime.Second,
                    Ktime.Milliseconds,
                    Itime.Hour,
                    Itime.Minute,
                    Itime.Second,
                    Itime.Milliseconds
                    );
            }
        else {
            printf("UTime( %3ld:%02ld:%02ld.%03ld ) ",
                    Utime.Hour,
                    Utime.Minute,
                    Utime.Second,
                    Utime.Milliseconds
                    );
            printf("KTime( %3ld:%02ld:%02ld.%03ld )\n",
                    Ktime.Hour,
                    Ktime.Minute,
                    Ktime.Second,
                    Ktime.Milliseconds
                    );
            printf("ITime( %3ld:%02ld:%02ld.%03ld )\n",
                    Itime.Hour,
                    Itime.Minute,
                    Itime.Second,
                    Itime.Milliseconds
                    );
            }
        }

    if ( bFull ) {
        ULONG InterruptCount;
        ULONG PreviousInterruptCount;
#ifdef i386
        ULONG EmulationTotal;
#endif

        PreviousInterruptCount = 0;
        for (i=0; i < (ULONG)BasicInfo.NumberOfProcessors; i++) {
            PreviousInterruptCount += ProcessorInfoStart[i].InterruptCount;
            }

        InterruptCount = 0;
        for (i=0; i < (ULONG)BasicInfo.NumberOfProcessors; i++) {
            InterruptCount += ProcessorInfoDone[i].InterruptCount;
            }

        if (bOneLine) {
            printf(" %ld",ProcessVmInfoDone.PageFaultCount - ProcessVmInfoStart.PageFaultCount);
            if (OtherProcess) {
                printf(" %ld",ServerVmInfoDone.PageFaultCount - ServerVmInfoStart.PageFaultCount);
                }
            printf(" %ld", InterruptCount - PreviousInterruptCount);
            printf(" %ld", SystemInfoDone.ContextSwitches - SystemInfoStart.ContextSwitches);
            printf(" %ld", SystemInfoDone.SystemCalls - SystemInfoStart.SystemCalls);
            }
        else {
            printf("\n");
            printf("Process PageFaultCount      %ld\n",ProcessVmInfoDone.PageFaultCount - ProcessVmInfoStart.PageFaultCount);
            if (OtherProcess) {
                printf("Server  PageFaultCount      %ld\n",ServerVmInfoDone.PageFaultCount - ServerVmInfoStart.PageFaultCount);
                }
            printf("Total Interrupts            %ld\n", InterruptCount - PreviousInterruptCount);
            printf("Total Context Switches      %ld\n", SystemInfoDone.ContextSwitches - SystemInfoStart.ContextSwitches);
            printf("Total System Calls          %ld\n", SystemInfoDone.SystemCalls - SystemInfoStart.SystemCalls);
        }

        if (ProcessHandle) {
#ifdef i386
            printf("\n");
            printf("Total OpcodeHLT             %ld\n", vdelta(OpcodeHLT         ));
            printf("Total OpcodeCLI             %ld\n", vdelta(OpcodeCLI         ));
            printf("Total OpcodeSTI             %ld\n", vdelta(OpcodeSTI         ));
            printf("Total BopCount              %ld\n", vdelta(BopCount          ));
            printf("Total SegmentNotPresent     %ld\n", vdelta(SegmentNotPresent ));
            printf("Total OpcodePUSHF           %ld\n", vdelta(OpcodePUSHF       ));
            printf("Total OpcodePOPF            %ld\n", vdelta(OpcodePOPF        ));
            printf("Total VdmOpcode0F           %ld\n", vdelta(VdmOpcode0F       ));
            printf("Total OpcodeINSB            %ld\n", vdelta(OpcodeINSB        ));
            printf("Total OpcodeINSW            %ld\n", vdelta(OpcodeINSW        ));
            printf("Total OpcodeOUTSB           %ld\n", vdelta(OpcodeOUTSB       ));
            printf("Total OpcodeOUTSW           %ld\n", vdelta(OpcodeOUTSW       ));
            printf("Total OpcodeINTnn           %ld\n", vdelta(OpcodeINTnn       ));
            printf("Total OpcodeINTO            %ld\n", vdelta(OpcodeINTO        ));
            printf("Total OpcodeIRET            %ld\n", vdelta(OpcodeIRET        ));
            printf("Total OpcodeINBimm          %ld\n", vdelta(OpcodeINBimm      ));
            printf("Total OpcodeINWimm          %ld\n", vdelta(OpcodeINWimm      ));
            printf("Total OpcodeOUTBimm         %ld\n", vdelta(OpcodeOUTBimm     ));
            printf("Total OpcodeOUTWimm         %ld\n", vdelta(OpcodeOUTWimm     ));
            printf("Total OpcodeINB             %ld\n", vdelta(OpcodeINB         ));
            printf("Total OpcodeINW             %ld\n", vdelta(OpcodeINW         ));
            printf("Total OpcodeOUTB            %ld\n", vdelta(OpcodeOUTB        ));
            printf("Total OpcodeOUTW            %ld\n", vdelta(OpcodeOUTW        ));

            EmulationTotal = vdelta(OpcodeHLT         )+
                             vdelta(OpcodeCLI         )+
                             vdelta(OpcodeSTI         )+
                             vdelta(BopCount          )+
                             vdelta(SegmentNotPresent )+
                             vdelta(OpcodePUSHF       )+
                             vdelta(OpcodePOPF        )+
                             vdelta(VdmOpcode0F       )+
                             vdelta(OpcodeINSB        )+
                             vdelta(OpcodeINSW        )+
                             vdelta(OpcodeOUTSB       )+
                             vdelta(OpcodeOUTSW       )+
                             vdelta(OpcodeINTnn       )+
                             vdelta(OpcodeINTO        )+
                             vdelta(OpcodeIRET        )+
                             vdelta(OpcodeINBimm      )+
                             vdelta(OpcodeINWimm      )+
                             vdelta(OpcodeOUTBimm     )+
                             vdelta(OpcodeOUTWimm     )+
                             vdelta(OpcodeINB         )+
                             vdelta(OpcodeINW         )+
                             vdelta(OpcodeOUTB        )+
                             vdelta(OpcodeOUTW        )
                             ;

            if (bOneLine) {
                printf(" %ld %ld", EmulationTotal, EmulationTotal*515);
                }
            else {
                printf("\n");
                printf("Total Emulation             %ld * 515clocks = %ld cycles\n", EmulationTotal, EmulationTotal*515);
                }
#endif
        }

        if (bSyscall) {
            for (i = 0; i < NumberOfCounts; i += 1) {
                CallData[i] = SystemCallTableDone[i] - SystemCallTableStart[i];
            }

            SortUlongData(NumberOfCounts, Index, CallData);

            for (i = 0; i < NumberOfCounts; i += 1) {
                if (CallData[Index[i]] == 0) {
                    break;
                }
                printf("%8ld calls to %s\n", CallData[Index[i]], CallTable[Index[i]]);
            }
        }

        if (bOneLine) {
            printf("\n");
            }
    } else {
        printf("\n");
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pstat\pcall.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    pcall.c

Abstract:

    This module contains the Windows NT system call display status.

Author:

    Lou Perazzoli (LouP) 5-feb-1992.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define NUMBER_SERVICE_TABLES 2

//
// Define forward referenced routine prototypes.
//

VOID
SortUlongData (
    IN ULONG Count,
    IN ULONG Index[],
    IN ULONG Data[]
    );

#define BUFFER_SIZE 1024
#define DELAY_TIME 1000
#define TOP_CALLS 15

extern UCHAR *CallTable[];

ULONG Index[BUFFER_SIZE];
ULONG CountBuffer1[BUFFER_SIZE];
ULONG CountBuffer2[BUFFER_SIZE];
ULONG CallData[BUFFER_SIZE];

SYSTEM_CONTEXT_SWITCH_INFORMATION SystemSwitchInformation1;
SYSTEM_CONTEXT_SWITCH_INFORMATION SystemSwitchInformation2;

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{

    BOOLEAN Active;
    BOOLEAN CountSort;
    NTSTATUS status;
    ULONG i;
    COORD dest,cp;
    SMALL_RECT Sm;
    CHAR_INFO ci;
    CONSOLE_SCREEN_BUFFER_INFO sbi;
    KPRIORITY SetBasePriority;
    INPUT_RECORD InputRecord;
    HANDLE ScreenHandle;
    DWORD NumRead;
    SMALL_RECT Window;
    PSYSTEM_CALL_COUNT_INFORMATION CallCountInfo[2];
    PSYSTEM_CALL_COUNT_INFORMATION CurrentCallCountInfo;
    PSYSTEM_CALL_COUNT_INFORMATION PreviousCallCountInfo;
    PULONG CallCountTable[2];
    PULONG CurrentCallCountTable;
    PULONG PreviousCallCountTable;
    PSYSTEM_CONTEXT_SWITCH_INFORMATION SwitchInfo[2];
    PSYSTEM_CONTEXT_SWITCH_INFORMATION CurrentSwitchInfo;
    PSYSTEM_CONTEXT_SWITCH_INFORMATION PreviousSwitchInfo;
    ULONG Current;
    ULONG Previous;
    LARGE_INTEGER TimeDifference;
    ULONG ContextSwitches;
    ULONG FindAny;
    ULONG FindLast;
    ULONG IdleAny;
    ULONG IdleCurrent;
    ULONG IdleLast;
    ULONG PreemptAny;
    ULONG PreemptCurrent;
    ULONG PreemptLast;
    ULONG SwitchToIdle;
    ULONG TotalSystemCalls;
    ULONG SleepTime=1000;
    BOOLEAN ConsoleMode=TRUE;
    ULONG TopCalls=TOP_CALLS;
    BOOLEAN LoopMode = FALSE;
    BOOLEAN ShowSwitches = TRUE;
    PULONG p;
    ULONG NumberOfCounts;

    while (argc > 1) {
        argv++;
        if (_stricmp(argv[0],"-l") == 0) {
            LoopMode = TRUE;
            ConsoleMode = FALSE;
            TopCalls = BUFFER_SIZE;
            argc--;
            continue;
        }
        if (_stricmp(argv[0],"-s") == 0) {
            ShowSwitches = FALSE;
            argc--;
            continue;
        }
        SleepTime = atoi(argv[0]) * 1000;
        ConsoleMode = FALSE;
        TopCalls = BUFFER_SIZE;
        argc--;
    }

    SetBasePriority = (KPRIORITY)12;

    NtSetInformationProcess(
        NtCurrentProcess(),
        ProcessBasePriority,
        (PVOID) &SetBasePriority,
        sizeof(SetBasePriority)
        );

    Current = 0;
    Previous = 1;

    CallCountInfo[0] = (PVOID)CountBuffer1;
    CallCountInfo[1] = (PVOID)CountBuffer2;
    CallCountTable[0] = (PULONG)(CallCountInfo[0] + 1) + NUMBER_SERVICE_TABLES;
    CallCountTable[1] = (PULONG)(CallCountInfo[1] + 1) + NUMBER_SERVICE_TABLES;
    SwitchInfo[0] = &SystemSwitchInformation1;
    SwitchInfo[1] = &SystemSwitchInformation2;

    Current = 0;
    Previous = 1;
    CurrentCallCountInfo = CallCountInfo[0];
    CurrentCallCountTable = CallCountTable[0];
    CurrentSwitchInfo = SwitchInfo[0];
    PreviousCallCountInfo = CallCountInfo[1];
    PreviousCallCountTable = CallCountTable[1];
    PreviousSwitchInfo = SwitchInfo[1];

    //
    // Query system information and get the initial call count data.
    //

    status = NtQuerySystemInformation(SystemCallCountInformation,
                                      (PVOID)PreviousCallCountInfo,
                                      BUFFER_SIZE * sizeof(ULONG),
                                      NULL);

    if (NT_SUCCESS(status) == FALSE) {
        printf("Query count information failed %lx\n",status);
        return(status);
    }

    //
    // Make sure that the number of tables reported by the kernel matches
    // our list.
    //

    if (PreviousCallCountInfo->NumberOfTables != NUMBER_SERVICE_TABLES) {
        printf("System call table count (%d) doesn't match PCALL's count (%d)\n",
                PreviousCallCountInfo->NumberOfTables, NUMBER_SERVICE_TABLES);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Make sure call count information is available for base services.
    //

    p = (PULONG)(PreviousCallCountInfo + 1);

    if (p[0] == 0) {
        printf("No system call count information available for base services\n");
        return STATUS_UNSUCCESSFUL;
    }

    //
    // If there is a hole in the count information (i.e., one set of services
    // doesn't have counting enabled, but a subsequent one does, then our
    // indexes will be off, and we'll display the wrong service names.
    //

    for ( i = 2; i < NUMBER_SERVICE_TABLES; i++ ) {
        if ((p[i] != 0) && (p[i-1] == 0)) {
            printf("One or more call count tables empty.  PCALL can't run\n");
            return STATUS_UNSUCCESSFUL;
        }
    }

    NumberOfCounts = (PreviousCallCountInfo->Length
                        - sizeof(SYSTEM_CALL_COUNT_INFORMATION)
                        - NUMBER_SERVICE_TABLES * sizeof(ULONG)) / sizeof(ULONG);

    //
    // Query system information and get the performance data.
    //

    if (ShowSwitches) {
        status = NtQuerySystemInformation(SystemContextSwitchInformation,
                                          (PVOID)PreviousSwitchInfo,
                                          sizeof(SYSTEM_CONTEXT_SWITCH_INFORMATION),
                                          NULL);

        if (NT_SUCCESS(status) == FALSE) {
            printf("Query context switch information failed %lx\n",status);
            return(status);
        }
    }

    if (ConsoleMode) {
        GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &sbi);

        Window.Left = 0;
        Window.Top = 0;
        Window.Right = 79;
        Window.Bottom = 23;

        dest.X = 0;
        dest.Y = 23;

        ci.Char.AsciiChar = ' ';
        ci.Attributes = sbi.wAttributes;

        SetConsoleWindowInfo(GetStdHandle(STD_OUTPUT_HANDLE),
                             TRUE,
                             &Window);

        cp.X = 0;
        cp.Y = 0;

        Sm.Left      = 0;
        Sm.Top       = 0;
        Sm.Right     = 79;
        Sm.Bottom    = 22;

        ScrollConsoleScreenBuffer(GetStdHandle(STD_OUTPUT_HANDLE),
                                  &Sm,
                                  NULL,
                                  dest,
                                  &ci);

        SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cp);
    }


    //
    // Display title.
    //

    printf( "   Count   System Service\n");
    printf( "_______________________________________________________________\n");

    cp.X = 0;
    cp.Y = 2;

    Sm.Left      = 0;
    Sm.Top       = 2;
    Sm.Right     = 79;
    Sm.Bottom    = 22;

    ScreenHandle = GetStdHandle(STD_INPUT_HANDLE);

    Active = TRUE;
    CountSort = TRUE;
    while(TRUE) {

        Sleep(SleepTime);

        while (PeekConsoleInput (ScreenHandle, &InputRecord, 1, &NumRead) && NumRead != 0) {
            if (!ReadConsoleInput (ScreenHandle, &InputRecord, 1, &NumRead)) {
                break;
            }

            if (InputRecord.EventType == KEY_EVENT) {

                switch (InputRecord.Event.KeyEvent.uChar.AsciiChar) {

                case 'p':
                case 'P':
                    Active = FALSE;
                    break;

                case 'q':
                case 'Q':
                    ExitProcess(0);
                    break;

                default:
                    Active = TRUE;
                    break;
                }
            }
        }

        //
        // If not active, then sleep for 1000ms and attempt to get input
        // from the keyboard again.
        //

        if (Active == FALSE) {
            Sleep(1000);
            continue;
        }

        if (ConsoleMode) {
            //
            // Scroll the screen buffer down to make room for the next display.
            //

            ScrollConsoleScreenBuffer(GetStdHandle(STD_OUTPUT_HANDLE),
                                      &Sm,
                                      NULL,
                                      dest,
                                      &ci);

            SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cp);
        }

        //
        // Query system information and get the call count data.
        //

        status = NtQuerySystemInformation(SystemCallCountInformation,
                                          (PVOID)CurrentCallCountInfo,
                                          BUFFER_SIZE * sizeof(ULONG),
                                          NULL);

        if (NT_SUCCESS(status) == FALSE) {
            printf("Query count information failed %lx\n",status);
            return(status);
        }

        //
        // Query system information and get the performance data.
        //

        if (ShowSwitches) {
            status = NtQuerySystemInformation(SystemContextSwitchInformation,
                                              (PVOID)CurrentSwitchInfo,
                                              sizeof(SYSTEM_CONTEXT_SWITCH_INFORMATION),
                                              NULL);

            if (NT_SUCCESS(status) == FALSE) {
                printf("Query context switch information failed %lx\n",status);
                return(status);
            }
        }

        //
        // Compute number of system calls for each service, the total
        // number of system calls, and the total time for each serviced.
        //

        TotalSystemCalls = 0;
        for (i = 0; i < NumberOfCounts; i += 1) {
            CallData[i] = CurrentCallCountTable[i] - PreviousCallCountTable[i];
            TotalSystemCalls += CallData[i];
        }

        //
        // Sort the system call data.
        //

        SortUlongData(NumberOfCounts, Index, CallData);

        //
        // Compute context switch information.
        //

        if (ShowSwitches) {
            ContextSwitches =
                CurrentSwitchInfo->ContextSwitches - PreviousSwitchInfo->ContextSwitches;

            FindAny = CurrentSwitchInfo->FindAny - PreviousSwitchInfo->FindAny;
            FindLast = CurrentSwitchInfo->FindLast - PreviousSwitchInfo->FindLast;
            IdleAny = CurrentSwitchInfo->IdleAny - PreviousSwitchInfo->IdleAny;
            IdleCurrent = CurrentSwitchInfo->IdleCurrent - PreviousSwitchInfo->IdleCurrent;
            IdleLast = CurrentSwitchInfo->IdleLast - PreviousSwitchInfo->IdleLast;
            PreemptAny = CurrentSwitchInfo->PreemptAny - PreviousSwitchInfo->PreemptAny;
            PreemptCurrent = CurrentSwitchInfo->PreemptCurrent - PreviousSwitchInfo->PreemptCurrent;
            PreemptLast = CurrentSwitchInfo->PreemptLast - PreviousSwitchInfo->PreemptLast;
            SwitchToIdle = CurrentSwitchInfo->SwitchToIdle - PreviousSwitchInfo->SwitchToIdle;
        }

        //
        // Display the top services.
        //

        printf("\n");
        for (i = 0; i < TopCalls; i += 1) {
            if (CallData[Index[i]] == 0) {
                break;
            }

            printf("%8ld    %s\n",
                   CallData[Index[i]],
                   CallTable[Index[i]]);
        }

        printf("\n");
        printf("Total System Calls            %6ld\n", TotalSystemCalls);

        if (ShowSwitches) {
            printf("\n");
            printf("Context Switch Information\n");
            printf("    Find any processor        %6ld\n", FindAny);
            printf("    Find last processor       %6ld\n", FindLast);
            printf("    Idle any processor        %6ld\n", IdleAny);
            printf("    Idle current processor    %6ld\n", IdleCurrent);
            printf("    Idle last processor       %6ld\n", IdleLast);
            printf("    Preempt any processor     %6ld\n", PreemptAny);
            printf("    Preempt current processor %6ld\n", PreemptCurrent);
            printf("    Preempt last processor    %6ld\n", PreemptLast);
            printf("    Switch to idle            %6ld\n", SwitchToIdle);
            printf("\n");
            printf("    Total context switches    %6ld\n", ContextSwitches);
        }

        //
        // Delay for the sleep interval swap the information buffers and
        // perform another iteration.
        //

        if (!ConsoleMode) {
            _flushall();
        }

        if ((ConsoleMode == FALSE) && (LoopMode == FALSE)) {
            ExitProcess(0);
        }

        Current = 1 - Current;
        Previous = 1 - Previous;
        CurrentCallCountInfo = CallCountInfo[Current];
        CurrentCallCountTable = CallCountTable[Current];
        CurrentSwitchInfo = SwitchInfo[Current];
        PreviousCallCountInfo = CallCountInfo[Previous];
        PreviousCallCountTable = CallCountTable[Previous];
        PreviousSwitchInfo = SwitchInfo[Previous];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pstat\pstat.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    pstat.c

Abstract:

    This module contains the Windows NT process/thread status display.

Author:

    Lou Perazzoli (LouP) 25-Oct-1991

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <stdlib.h>

#define BUFFER_SIZE 64*1024
#define MAX_BUFFER_SIZE 10*1024*1024

VOID
PrintLoadedDrivers(
    VOID
    );

ULONG CurrentBufferSize;

UCHAR *StateTable[] = {
    "Initialized",
    "Ready",
    "Running",
    "Standby",
    "Terminated",
    "Wait:",
    "Transition",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown",
    "Unknown"
};

UCHAR *WaitTable[] = {
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "Executive",
    "FreePage",
    "PageIn",
    "PoolAllocation",
    "DelayExecution",
    "Suspended",
    "UserRequest",
    "EventPairHigh",
    "EventPairLow",
    "LpcReceive",
    "LpcReply",
    "VirtualMemory",
    "PageOut",
    "Spare1",
    "Spare2",
    "Spare3",
    "Spare4",
    "Spare5",
    "Spare6",
    "Spare7",
    "Unknown",
    "Unknown",
    "Unknown"
};

UCHAR *Empty = " ";

BOOLEAN fUserOnly = TRUE;
BOOLEAN fSystemOnly = TRUE;
BOOLEAN fVerbose = FALSE;
BOOLEAN fPrintIt;

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{

    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PUCHAR LargeBuffer1;
    NTSTATUS status;
    NTSTATUS Status;
    ULONG i;
    ULONG TotalOffset = 0;
    TIME_FIELDS UserTime;
    TIME_FIELDS KernelTime;
    TIME_FIELDS UpTime;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDayInfo;
    PSYSTEM_PAGEFILE_INFORMATION PageFileInfo;
    LARGE_INTEGER Time;
    LPSTR lpstrCmd;
    CHAR ch;
    ANSI_STRING pname;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    SYSTEM_FILECACHE_INFORMATION FileCache;
    SIZE_T SumCommit;
    SIZE_T SumWorkingSet;

    SetFileApisToOEM();
    lpstrCmd = GetCommandLine();
    if( lpstrCmd != NULL ) {
        CharToOem( lpstrCmd, lpstrCmd );
    }


    LargeBuffer1 = VirtualAlloc (NULL,
                                 MAX_BUFFER_SIZE,
                                 MEM_RESERVE,
                                 PAGE_READWRITE);
    if (LargeBuffer1 == NULL) {
        printf("Memory allocation failed\n");
        return 0;
    }

    if (VirtualAlloc (LargeBuffer1,
                      BUFFER_SIZE,
                      MEM_COMMIT,
                      PAGE_READWRITE) == NULL) {
        printf("Memory commit failed\n");
        return 0;
    }

    CurrentBufferSize = BUFFER_SIZE;

    do
        ch = *lpstrCmd++;
    while (ch != ' ' && ch != '\t' && ch != '\0');
    while (ch == ' ' || ch == '\t')
        ch = *lpstrCmd++;
    while (ch == '-') {
        ch = *lpstrCmd++;

        //  process multiple switch characters as needed

        do {
            switch (ch) {

                case 'U':
                case 'u':
                    fUserOnly = TRUE;
                    fSystemOnly = FALSE;
                    ch = *lpstrCmd++;
                    break;

                case 'S':
                case 's':
                    fUserOnly = FALSE;
                    fSystemOnly = TRUE;
                    ch = *lpstrCmd++;
                    break;

                case 'V':
                case 'v':
                    fVerbose = TRUE;
                    ch = *lpstrCmd++;
                    break;

                default:
                    printf("bad switch '%c'\n", ch);
                    ExitProcess(1);
                }
            }
        while (ch != ' ' && ch != '\t' && ch != '\0');

        //  skip over any following white space

        while (ch == ' ' || ch == '\t')
            ch = *lpstrCmd++;
        }


    status = NtQuerySystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(SYSTEM_BASIC_INFORMATION),
                NULL
                );

    if (!NT_SUCCESS(status)) {
        printf("Query info failed %lx\n",status);
        return(status);
        }

    status = NtQuerySystemInformation(
                SystemTimeOfDayInformation,
                &TimeOfDayInfo,
                sizeof(SYSTEM_TIMEOFDAY_INFORMATION),
                NULL
                );

    if (!NT_SUCCESS(status)) {
        printf("Query info failed %lx\n",status);
        return(status);
        }

    Time.QuadPart = TimeOfDayInfo.CurrentTime.QuadPart -
                                    TimeOfDayInfo.BootTime.QuadPart;

    RtlTimeToElapsedTimeFields ( &Time, &UpTime);

    printf("Pstat version 0.3:  memory: %4ld kb  uptime:%3ld %2ld:%02ld:%02ld.%03ld \n\n",
                BasicInfo.NumberOfPhysicalPages * (BasicInfo.PageSize/1024),
                UpTime.Day,
                UpTime.Hour,
                UpTime.Minute,
                UpTime.Second,
                UpTime.Milliseconds);

    PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)LargeBuffer1;
    status = NtQuerySystemInformation(
                SystemPageFileInformation,
                PageFileInfo,
                CurrentBufferSize,
                NULL
                );

    if (NT_SUCCESS(status)) {

        //
        // Print out the page file information.
        //

        if (PageFileInfo->TotalSize == 0) {
            printf("no page files in use\n");
        } else {
            for (; ; ) {
                printf("PageFile: %wZ\n", &PageFileInfo->PageFileName);
                printf("\tCurrent Size: %6ld kb  Total Used: %6ld kb   Peak Used %6ld kb\n",
                        PageFileInfo->TotalSize*(BasicInfo.PageSize/1024),
                        PageFileInfo->TotalInUse*(BasicInfo.PageSize/1024),
                        PageFileInfo->PeakUsage*(BasicInfo.PageSize/1024));
                if (PageFileInfo->NextEntryOffset == 0) {
                    break;
                }
                PageFileInfo = (PSYSTEM_PAGEFILE_INFORMATION)(
                          (PCHAR)PageFileInfo + PageFileInfo->NextEntryOffset);
            }
        }
    }

retry:
    status = NtQuerySystemInformation(
                SystemProcessInformation,
                LargeBuffer1,
                CurrentBufferSize,
                NULL
                );

    if (status == STATUS_INFO_LENGTH_MISMATCH) {

        //
        // Increase buffer size.
        //

        CurrentBufferSize += 8192;

        if (VirtualAlloc (LargeBuffer1,
                          CurrentBufferSize,
                          MEM_COMMIT,
                          PAGE_READWRITE) == NULL) {
            printf("Memory commit failed\n");
            return 0;
        }
        goto retry;
    }

    if (!NT_SUCCESS(status)) {
        printf("Query info failed %lx\n",status);
        return(status);
    }

    //
    // display pmon style process output, then detailed output that includes
    // per thread stuff
    //

    TotalOffset = 0;
    SumCommit = 0;
    SumWorkingSet = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)LargeBuffer1;
    while (TRUE) {
        SumCommit += ProcessInfo->PrivatePageCount / 1024;
        SumWorkingSet += ProcessInfo->WorkingSetSize / 1024;
        if (ProcessInfo->NextEntryOffset == 0) {
            break;
            }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
        }

    Status = NtQuerySystemInformation(
                SystemPerformanceInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        printf("Query perf Failed %lx\n",Status);
        return 0;
    }

    Status = NtQuerySystemInformation(
                SystemFileCacheInformation,
                &FileCache,
                sizeof(FileCache),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        printf("Query file cache Failed %lx\n",Status);
        return 0;
    }

    NtQuerySystemInformation(
        SystemBasicInformation,
        &BasicInfo,
        sizeof(BasicInfo),
        NULL
        );

    SumWorkingSet += FileCache.CurrentSize/1024;
    printf (
         "\n Memory:%7ldK Avail:%7ldK  TotalWs:%7ldK InRam Kernel:%5ldK P:%5ldK\n",
                              BasicInfo.NumberOfPhysicalPages*(BasicInfo.PageSize/1024),
                              PerfInfo.AvailablePages*(BasicInfo.PageSize/1024),
                              SumWorkingSet,
                              (PerfInfo.ResidentSystemCodePage + PerfInfo.ResidentSystemDriverPage)*(BasicInfo.PageSize/1024),
                              (PerfInfo.ResidentPagedPoolPage)*(BasicInfo.PageSize/1024)
                              );
    printf(
         " Commit:%7ldK/%7ldK Limit:%7ldK Peak:%7ldK  Pool N:%5ldK P:%5ldK\n",
                              PerfInfo.CommittedPages*(BasicInfo.PageSize/1024),
                              SumCommit,
                              PerfInfo.CommitLimit*(BasicInfo.PageSize/1024),
                              PerfInfo.PeakCommitment*(BasicInfo.PageSize/1024),
                              PerfInfo.NonPagedPoolPages*(BasicInfo.PageSize/1024),
                              PerfInfo.PagedPoolPages*(BasicInfo.PageSize/1024)
                              );
    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)LargeBuffer1;
    printf("\n");


    printf("    User Time   Kernel Time    Ws   Faults  Commit Pri Hnd Thd Pid Name\n");

    printf("                           %6ld %8ld                         %s\n",
        FileCache.CurrentSize/1024,
        FileCache.PageFaultCount,
        "File Cache"
        );
    while (TRUE) {

        pname.Buffer = NULL;
        if ( ProcessInfo->ImageName.Buffer ) {
            RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
            }

        RtlTimeToElapsedTimeFields ( &ProcessInfo->UserTime, &UserTime);
        RtlTimeToElapsedTimeFields ( &ProcessInfo->KernelTime, &KernelTime);

        printf("%3ld:%02ld:%02ld.%03ld %3ld:%02ld:%02ld.%03ld",
            UserTime.Hour,
            UserTime.Minute,
            UserTime.Second,
            UserTime.Milliseconds,
            KernelTime.Hour,
            KernelTime.Minute,
            KernelTime.Second,
            KernelTime.Milliseconds
            );

        printf("%6ld %8ld %7ld",
            ProcessInfo->WorkingSetSize / 1024,
            ProcessInfo->PageFaultCount,
            ProcessInfo->PrivatePageCount / 1024
            );

        printf(" %2ld %4ld %3ld %3ld %s\n",
            ProcessInfo->BasePriority,
            ProcessInfo->HandleCount,
            ProcessInfo->NumberOfThreads,
            HandleToUlong(ProcessInfo->UniqueProcessId),
            ProcessInfo->UniqueProcessId == 0 ? "Idle Process" : (
            ProcessInfo->ImageName.Buffer ? pname.Buffer : "System")
            );

        if ( pname.Buffer ) {
            RtlFreeAnsiString(&pname);
            }

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
            }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
        }


    //
    // Beginning of normal old style pstat output
    //

    TotalOffset = 0;
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)LargeBuffer1;
    printf("\n");
    while (TRUE) {
        fPrintIt = FALSE;
        if ( (ProcessInfo->ImageName.Buffer && fUserOnly) ||
             (ProcessInfo->ImageName.Buffer==NULL && fSystemOnly) ) {

            fPrintIt = TRUE;

            pname.Buffer = NULL;
            if ( ProcessInfo->ImageName.Buffer ) {
                RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
                }
            printf("pid:%3lx pri:%2ld Hnd:%5ld Pf:%7ld Ws:%7ldK %s\n",
                HandleToUlong(ProcessInfo->UniqueProcessId),
                ProcessInfo->BasePriority,
                ProcessInfo->HandleCount,
                ProcessInfo->PageFaultCount,
                ProcessInfo->WorkingSetSize / 1024,
                ProcessInfo->UniqueProcessId == 0 ? "Idle Process" : (
                ProcessInfo->ImageName.Buffer ? pname.Buffer : "System")
                );

            if ( pname.Buffer ) {
                RtlFreeAnsiString(&pname);
                }

            }
        i = 0;
        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        if (ProcessInfo->NumberOfThreads) {
            printf(" tid pri Ctx Swtch StrtAddr    User Time  Kernel Time  State\n");
            }
        while (i < ProcessInfo->NumberOfThreads) {
            RtlTimeToElapsedTimeFields ( &ThreadInfo->UserTime, &UserTime);

            RtlTimeToElapsedTimeFields ( &ThreadInfo->KernelTime, &KernelTime);
            if ( fPrintIt ) {

                printf(" %3lx  %2ld %9ld %p",
                    ProcessInfo->UniqueProcessId == 0 ? 0 : HandleToUlong(ThreadInfo->ClientId.UniqueThread),
                    ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->Priority,
                    ThreadInfo->ContextSwitches,
                    ProcessInfo->UniqueProcessId == 0 ? 0 : ThreadInfo->StartAddress
                    );

                printf(" %2ld:%02ld:%02ld.%03ld %2ld:%02ld:%02ld.%03ld",
                    UserTime.Hour,
                    UserTime.Minute,
                    UserTime.Second,
                    UserTime.Milliseconds,
                    KernelTime.Hour,
                    KernelTime.Minute,
                    KernelTime.Second,
                    KernelTime.Milliseconds
                    );

                printf(" %s%s\n",
                    StateTable[ThreadInfo->ThreadState],
                    (ThreadInfo->ThreadState == 5) ?
                            WaitTable[ThreadInfo->WaitReason] : Empty
                    );
                }
            ThreadInfo += 1;
            i += 1;
            }
        if (ProcessInfo->NextEntryOffset == 0) {
            break;
            }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&LargeBuffer1[TotalOffset];
        if ( fPrintIt ) {
            printf("\n");
            }
        }

    PrintLoadedDrivers();

    return 0;
}


typedef struct _MODULE_DATA {
    ULONG CodeSize;
    ULONG DataSize;
    ULONG BssSize;
    ULONG RoDataSize;
    ULONG ImportDataSize;
    ULONG ExportDataSize;
    ULONG ResourceDataSize;
    ULONG PagedSize;
    ULONG InitSize;
    ULONG CheckSum;
    ULONG TimeDateStamp;
} MODULE_DATA, *PMODULE_DATA;

typedef struct _LOADED_IMAGE {
    PUCHAR MappedAddress;
    PIMAGE_NT_HEADERS FileHeader;
    PIMAGE_SECTION_HEADER LastRvaSection;
    int NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
} LOADED_IMAGE, *PLOADED_IMAGE;


VOID
SumModuleData(
    PMODULE_DATA Sum,
    PMODULE_DATA Current
    )
{
    Sum->CodeSize           += Current->CodeSize;
    Sum->DataSize           += Current->DataSize;
    Sum->BssSize            += Current->BssSize;
    Sum->RoDataSize         += Current->RoDataSize;
    Sum->ImportDataSize     += Current->ImportDataSize;
    Sum->ExportDataSize     += Current->ExportDataSize;
    Sum->ResourceDataSize   += Current->ResourceDataSize;
    Sum->PagedSize          += Current->PagedSize;
    Sum->InitSize           += Current->InitSize;
}
VOID
PrintModuleSeperator(
    VOID
    )
{
    printf("------------------------------------------------------------------------------\n");
}

VOID
PrintModuleHeader(
    VOID
    )
{
    printf("  ModuleName Load Addr   Code    Data   Paged           LinkDate\n");
    PrintModuleSeperator();
}

VOID
PrintModuleLine(
    LPSTR ModuleName,
    PMODULE_DATA Current,
    PRTL_PROCESS_MODULE_INFORMATION Module
    )
{
    if ( Module ) {
        printf("%12s %p %7d %7d %7d %s",
            ModuleName,
            Module->ImageBase,
            Current->CodeSize,
            Current->DataSize,
            Current->PagedSize,
            Current->TimeDateStamp ? ctime((time_t *)&Current->TimeDateStamp) : "\n"
            );
        }
    else {
        printf("%12s          %7d %7d %7d\n",
            ModuleName,
            Current->CodeSize,
            Current->DataSize,
            Current->PagedSize
            );
        }
}

VOID
GetModuleData(
    HANDLE hFile,
    PMODULE_DATA Mod
    )
{
    HANDLE hMappedFile;
    PIMAGE_DOS_HEADER DosHeader;
    LOADED_IMAGE LoadedImage;
    ULONG SectionAlignment;
    PIMAGE_SECTION_HEADER Section;
    int i;
    ULONG Size;

    hMappedFile = CreateFileMapping(
                    hFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    0,
                    NULL
                    );
    if ( !hMappedFile ) {
        return;
        }

    LoadedImage.MappedAddress = MapViewOfFile(
                                    hMappedFile,
                                    FILE_MAP_READ,
                                    0,
                                    0,
                                    0
                                    );
    CloseHandle(hMappedFile);

    if ( !LoadedImage.MappedAddress ) {
        return;
        }

    //
    // Everything is mapped. Now check the image and find nt image headers
    //

    DosHeader = (PIMAGE_DOS_HEADER)LoadedImage.MappedAddress;

    if ( DosHeader->e_magic != IMAGE_DOS_SIGNATURE ) {
        UnmapViewOfFile(LoadedImage.MappedAddress);
        return;
        }

    LoadedImage.FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

    if ( LoadedImage.FileHeader->Signature != IMAGE_NT_SIGNATURE ) {
        UnmapViewOfFile(LoadedImage.MappedAddress);
        return;
        }

    LoadedImage.NumberOfSections = LoadedImage.FileHeader->FileHeader.NumberOfSections;
    LoadedImage.Sections = (PIMAGE_SECTION_HEADER)((ULONG_PTR)LoadedImage.FileHeader + sizeof(IMAGE_NT_HEADERS));
    LoadedImage.LastRvaSection = LoadedImage.Sections;

    //
    // Walk through the sections and tally the dater
    //

    SectionAlignment = LoadedImage.FileHeader->OptionalHeader.SectionAlignment;

    for(Section = LoadedImage.Sections,i=0; i<LoadedImage.NumberOfSections; i++,Section++) {
        Size = Section->Misc.VirtualSize;

        if (Size == 0) {
            Size = Section->SizeOfRawData;
        }

        Size = (Size + SectionAlignment - 1) & ~(SectionAlignment - 1);

        if (!_strnicmp(Section->Name,"PAGE", 4 )) {
            Mod->PagedSize += Size;
            }
        else if (!_stricmp(Section->Name,"INIT" )) {
            Mod->InitSize += Size;
            }
        else if (!_stricmp(Section->Name,".bss" )) {
            Mod->BssSize = Size;
            }
        else if (!_stricmp(Section->Name,".edata" )) {
            Mod->ExportDataSize = Size;
            }
        else if (!_stricmp(Section->Name,".idata" )) {
            Mod->ImportDataSize = Size;
            }
        else if (!_stricmp(Section->Name,".rsrc" )) {
            Mod->ResourceDataSize = Size;
            }
        else if (Section->Characteristics & IMAGE_SCN_MEM_EXECUTE) {
            Mod->CodeSize += Size;
            }
        else if (Section->Characteristics & IMAGE_SCN_MEM_WRITE) {
            Mod->DataSize += Size;
            }
        else if (Section->Characteristics & IMAGE_SCN_MEM_READ) {
            Mod->RoDataSize += Size;
            }
        else {
            Mod->DataSize += Size;
            }
        }

    Mod->CheckSum = LoadedImage.FileHeader->OptionalHeader.CheckSum;
    Mod->TimeDateStamp = LoadedImage.FileHeader->FileHeader.TimeDateStamp;

    UnmapViewOfFile(LoadedImage.MappedAddress);
    return;

}

VOID
PrintLoadedDrivers(
    VOID
    )
{

    ULONG i;
    PCHAR s;
    HANDLE FileHandle;
    CHAR KernelPath[MAX_PATH];
    CHAR DriversPath[MAX_PATH];
    PCHAR ModuleInfo;
    ULONG ModuleInfoLength;
    ULONG ReturnedLength;
    PRTL_PROCESS_MODULES Modules;
    PRTL_PROCESS_MODULE_INFORMATION Module;
    NTSTATUS Status;
    MODULE_DATA Sum;
    MODULE_DATA Current;

    printf("\n");
    //
    // Locate system drivers.
    //

    ModuleInfoLength = 64000;
    while (1) {
        ModuleInfo = malloc (ModuleInfoLength);
        if (ModuleInfo == NULL) {
            printf ("Failed to allocate memory for module information buffer of size %d\n",
                    ModuleInfoLength);
            return;
        }
        Status = NtQuerySystemInformation (
                        SystemModuleInformation,
                        ModuleInfo,
                        ModuleInfoLength,
                        &ReturnedLength);

        if (!NT_SUCCESS(Status)) {
            free (ModuleInfo);
            if (Status == STATUS_INFO_LENGTH_MISMATCH &&
                ReturnedLength > ModuleInfoLength) {
                ModuleInfoLength = ReturnedLength;
                continue;
            }
            printf("query system info failed status - %lx\n",Status);
            return;
        }
        break;
    }
    GetSystemDirectory(KernelPath,sizeof(KernelPath));
    strcpy(DriversPath,KernelPath);
    strcat(DriversPath,"\\Drivers");
    ZeroMemory(&Sum,sizeof(Sum));
    PrintModuleHeader();

    Modules = (PRTL_PROCESS_MODULES)ModuleInfo;
    Module = &Modules->Modules[ 0 ];
    for (i=0; i<Modules->NumberOfModules; i++) {

        ZeroMemory(&Current,sizeof(Current));
        s = &Module->FullPathName[ Module->OffsetToFileName ];

        //
        // try to open the file
        //

        SetCurrentDirectory(KernelPath);

        FileHandle = CreateFile(
                        s,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

        if ( FileHandle == INVALID_HANDLE_VALUE ) {
            SetCurrentDirectory(DriversPath);

            FileHandle = CreateFile(
                            s,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL
                            );

            }

        if ( FileHandle != INVALID_HANDLE_VALUE ) {
            GetModuleData(FileHandle,&Current);
            CloseHandle(FileHandle);
            }

        SumModuleData(&Sum,&Current);
        PrintModuleLine(s,&Current,Module);
        Module++;
        }
    PrintModuleSeperator();
    PrintModuleLine("Total",&Sum,NULL);
    free (ModuleInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pview\acledit.h ===
BOOL
InitializeAclEditor(
    VOID
    );

BOOL
EditNtObjectSecurity(
    HWND    hwndOwner,
    HANDLE  Object,
    LPWSTR  ObjectName
    );


BOOL
EditTokenDefaultDacl(
    HWND    hwndOwner,
    HANDLE  Token,
    LPWSTR  ObjectName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pview\lsa.h ===
BOOL    LsaInit(VOID);
BOOL    LsaTerminate(VOID);
BOOL    SID2Name(PSID, LPSTR, USHORT);
BOOL    PRIV2Name(LUID, LPSTR, UINT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pstat\timeit.c ===
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <search.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <..\ztools\inc\tools.h>

#define MAX_PROCESSOR 16
SYSTEM_BASIC_INFORMATION BasicInfo;
SYSTEM_PERFORMANCE_INFORMATION SystemInfoStart;
SYSTEM_PERFORMANCE_INFORMATION SystemInfoDone;
SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION    ProcessorInfoStart[MAX_PROCESSOR];

BOOLEAN IgnoreNonZeroExitCodes;
BOOLEAN ForceSort;
BOOLEAN RemoveKeys;
LPSTR KeyNameToRemove;
LONG KeyEntriesToTrim;

BOOL WINAPI
CtrlcHandler(
    ULONG CtrlType
    )
{
    //
    // Ignore control C interrupts.  Let child process deal with them
    // if it wants.  If it doesn't then it will terminate and we will
    // get control and terminate ourselves
    //
    return TRUE;
}


void
Usage( void )
{
    fprintf( stderr, "Usage: TIMEIT [-f filename] [-a] [-c] [-i] [-d] [-s] [-t] [-k keyname | -r keyname] [commandline...]\n" );
    fprintf( stderr, "where:        -f specifies the name of the database file where TIMEIT\n" );
    fprintf( stderr, "                 keeps a history of previous timings.  Default is .\\timeit.dat\n" );
    fprintf( stderr, "              -k specifies the keyname to use for this timing run\n" );
    fprintf( stderr, "              -r specifies the keyname to remove from the database.  If\n" );
    fprintf( stderr, "                 keyname is followed by a comma and a number then it will\n" );
    fprintf( stderr, "                 remove the slowest (positive number) or fastest (negative)\n" );
    fprintf( stderr, "                 times for that keyname.\n" );
    fprintf( stderr, "              -a specifies that timeit should display average of all timings\n" );
    fprintf( stderr, "                 for the specified key.\n" );
    fprintf( stderr, "              -i specifies to ignore non-zero return codes from program\n" );
    fprintf( stderr, "              -d specifies to show detail for average\n" );
    fprintf( stderr, "              -s specifies to suppress system wide counters\n" );
    fprintf( stderr, "              -t specifies to tabular output\n" );
    fprintf( stderr, "              -c specifies to force a resort of the data base\n" );
    exit( 1 );
}

typedef struct _TIMEIT_RECORD {
    UCHAR KeyName[ 24 ];
    ULONG GetVersionNumber;
    LARGE_INTEGER ExitTime;
    ULONG ExitCode;
    USHORT Flags;
    USHORT NumberOfRecordsInAverage;

    LARGE_INTEGER ElapsedTime;
    LARGE_INTEGER ProcessTime;

    ULONG SystemCalls;
    ULONG ContextSwitches;
    ULONG InterruptCount;
    ULONG PageFaultCount;

    LARGE_INTEGER IoReadTransferCount;
    LARGE_INTEGER IoWriteTransferCount;
    LARGE_INTEGER IoOtherTransferCount;
} TIMEIT_RECORD, *PTIMEIT_RECORD;


#define TIMEIT_RECORD_SYSTEMINFO 0x0001


#define TIMEIT_VERSION 1

typedef struct _TIMEIT_FILE {
    ULONG VersionNumber;
    ULONG NumberOfRecords;
    TIMEIT_RECORD Records[ 1 ];
} TIMEIT_FILE, *PTIMEIT_FILE;


void
DisplayRecord(
    PTIMEIT_RECORD p,
    PTIMEIT_RECORD pavg
    );

int
__cdecl
TimeitSortRoutine(
    const void *arg1,
    const void *arg2
    )
{
    PTIMEIT_RECORD p1 = (PTIMEIT_RECORD)arg1;
    PTIMEIT_RECORD p2 = (PTIMEIT_RECORD)arg2;
    int cmp;


    cmp = _stricmp( p1->KeyName, p2->KeyName );
    if (cmp == 0) {
        if (p1->ElapsedTime.QuadPart < p2->ElapsedTime.QuadPart) {
            cmp = -1;
            }
        else
        if (p1->ElapsedTime.QuadPart > p2->ElapsedTime.QuadPart) {
            cmp = 1;
            }
        }

    return cmp;
}

void
UnmapDataBase(
    PTIMEIT_FILE pf
    )
{
    FlushViewOfFile( pf, 0 );
    UnmapViewOfFile( pf );
}

PTIMEIT_FILE
MapDataBase(
    LPSTR DataBaseFileName,
    BOOLEAN WriteAccess,
    PTIMEIT_RECORD p,
    PULONG ActualNumberOfRecords
    )
{
    DWORD BytesWritten;
    HANDLE hf, hm;
    TIMEIT_FILE Temp;
    PTIMEIT_FILE pf;
    ULONG i;
    BOOLEAN RecordsDeleted;
    DWORD FileSize;
    BOOLEAN DeleteRecord, BackupFlag;
    LONG KeyEntriesLeftToTrim;

    hf = CreateFile( DataBaseFileName,
                     WriteAccess ? GENERIC_READ | GENERIC_WRITE : GENERIC_READ,
                     FILE_SHARE_READ,
                     NULL,
                     p != NULL ? OPEN_ALWAYS : OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                   );
    if (hf == INVALID_HANDLE_VALUE) {
        return NULL;
        }
    if (p != NULL && GetLastError() != ERROR_ALREADY_EXISTS) {
        Temp.VersionNumber = TIMEIT_VERSION;
        Temp.NumberOfRecords = 0;
        WriteFile( hf, &Temp, FIELD_OFFSET( TIMEIT_FILE, Records ), &BytesWritten, NULL );
        }

    FileSize = SetFilePointer( hf, 0, NULL, FILE_END );
    if (p != NULL) {
        if (!WriteFile( hf, p, sizeof( *p ), &BytesWritten, NULL )) {
            CloseHandle( hf );
            return NULL;
            }

        SetEndOfFile( hf );
        FileSize += BytesWritten;
        }

retrymap:
    hm = CreateFileMapping( hf,
                            NULL,
                            WriteAccess ? PAGE_READWRITE | SEC_COMMIT : PAGE_READONLY,
                            0,
                            0,
                            NULL
                          );
    if (hm == NULL) {
        CloseHandle( hf );
        return NULL;
        }

    pf = MapViewOfFile( hm, WriteAccess ? FILE_MAP_WRITE : FILE_MAP_READ, 0, 0, 0 );
    if (pf != NULL) {
        if (p != NULL) {
            pf->NumberOfRecords += 1;
            }

        if (FileSize > FIELD_OFFSET( TIMEIT_FILE, Records )) {
            *ActualNumberOfRecords = (FileSize - FIELD_OFFSET( TIMEIT_FILE, Records )) / sizeof( TIMEIT_RECORD );
            }
        else {
            *ActualNumberOfRecords = 0;
            }

        if (WriteAccess && RemoveKeys && KeyNameToRemove != NULL) {
            if (pf->NumberOfRecords != *ActualNumberOfRecords) {
                pf->NumberOfRecords = *ActualNumberOfRecords;
                }

            KeyEntriesLeftToTrim = KeyEntriesToTrim;
            RecordsDeleted = FALSE;
            for (i=0; i<pf->NumberOfRecords; i++) {
                if ((*KeyNameToRemove == '\0'&& pf->Records[i].KeyName[0] == '\0') ||
                    !_strnicmp( KeyNameToRemove, pf->Records[i].KeyName, 24 )) {
                    DeleteRecord = FALSE;
                    BackupFlag = FALSE;
                    if (KeyEntriesToTrim) {
                        if (KeyEntriesLeftToTrim < 0) {
                            DeleteRecord = TRUE;
                            KeyEntriesLeftToTrim += 1;
                            }
                        else
                        if (KeyEntriesLeftToTrim > 0) {
                            if ((i+1) == pf->NumberOfRecords ||
                                _strnicmp( KeyNameToRemove, pf->Records[i+1].KeyName, 24 )
                               ) {
                                DeleteRecord = TRUE;
                                KeyEntriesLeftToTrim -= 1;
                                BackupFlag = TRUE;
                                }
                            }
                        }
                    else {
                        DeleteRecord = TRUE;
                        }

                    if (DeleteRecord) {
                        RecordsDeleted = TRUE;
                        FileSize -= sizeof( TIMEIT_RECORD );
                        if (i < --(pf->NumberOfRecords)) {
                            memmove( &pf->Records[i],
                                     &pf->Records[i+1],
                                     (pf->NumberOfRecords - i + 1) * sizeof( TIMEIT_RECORD )
                                   );
                            }
                        i -= 1;
                        if (BackupFlag) {
                            i -= 1;
                            }
                        }
                    }
                }

            if (RecordsDeleted) {
                RemoveKeys = FALSE;
                CloseHandle( hm );
                UnmapDataBase( pf );
                SetFilePointer( hf, FileSize, NULL, FILE_BEGIN );
                SetEndOfFile( hf );
                goto retrymap;
                }
            }

        if (WriteAccess) {
            qsort( pf->Records,
                   pf->NumberOfRecords,
                   sizeof( TIMEIT_RECORD ),
                   TimeitSortRoutine
                 );
            }
        }

    CloseHandle( hm );
    CloseHandle( hf );

    return pf;
}


void
AccumulateRecord(
    PTIMEIT_RECORD pavg,
    PTIMEIT_RECORD p
    )
{
    ULONG n;

    if (p != NULL) {
        if (!IgnoreNonZeroExitCodes || p->ExitCode != 0) {
            pavg->ElapsedTime.QuadPart += p->ElapsedTime.QuadPart;
            pavg->ProcessTime.QuadPart += p->ProcessTime.QuadPart;

            if (p->Flags & TIMEIT_RECORD_SYSTEMINFO) {
                pavg->Flags |= TIMEIT_RECORD_SYSTEMINFO;
                pavg->SystemCalls     += p->SystemCalls;
                pavg->ContextSwitches += p->ContextSwitches;
                pavg->InterruptCount  += p->InterruptCount;
                pavg->PageFaultCount  += p->PageFaultCount;

                pavg->IoReadTransferCount.QuadPart  += p->IoReadTransferCount.QuadPart;
                pavg->IoWriteTransferCount.QuadPart += p->IoWriteTransferCount.QuadPart;
                pavg->IoOtherTransferCount.QuadPart += p->IoOtherTransferCount.QuadPart;
                }

            pavg->NumberOfRecordsInAverage += 1;
            }
        }
    else {
        n = pavg->NumberOfRecordsInAverage;
        if (n > 1 && n != 0xFFFF) {
            pavg->ElapsedTime.QuadPart /= n;
            pavg->ProcessTime.QuadPart /= n;

            if (pavg->Flags & TIMEIT_RECORD_SYSTEMINFO) {
                pavg->SystemCalls /= n;
                pavg->ContextSwitches /= n;
                pavg->InterruptCount /= n;
                pavg->PageFaultCount /= n;

                pavg->IoReadTransferCount.QuadPart /= n;
                pavg->IoWriteTransferCount.QuadPart /= n;
                pavg->IoOtherTransferCount.QuadPart /= n;
                }
            }
        }

    return;
}


void
UpdateDataBase(
    LPSTR DataBaseFileName,
    PTIMEIT_RECORD p,
    PTIMEIT_RECORD pavg
    )
{
    PTIMEIT_FILE pf;
    PTIMEIT_RECORD p1;
    ULONG i, NumberOfRecords;


    pf = MapDataBase( DataBaseFileName, TRUE, p, &NumberOfRecords );
    if (pf == NULL) {
        fprintf( stderr, "Unable to access data base file '%s' (%u)\n",
                 DataBaseFileName, GetLastError()
               );
        return;
        }

    if (pf->VersionNumber != TIMEIT_VERSION) {
        fprintf( stderr, "Invalid version number (%u) in data base file '%s'\n",
                 pf->VersionNumber, DataBaseFileName
               );
        exit( 1 );
        }

    if (pavg != NULL) {
        memset( pavg, 0, sizeof( *pavg ) );
        pavg->GetVersionNumber = GetVersion();
        for (i=0; i<pf->NumberOfRecords; i++) {
            p1 = &pf->Records[ i ];
            if (!_stricmp( p1->KeyName, p->KeyName )) {
                AccumulateRecord( pavg, p1 );
                }
            }
        AccumulateRecord( pavg, NULL );
        }

    UnmapDataBase( pf );

    DisplayRecord( p, pavg );
    return;
}

char *PlatformStrings[] = {
    "Windows NT",
    "Win32s",
    "Windows 95",
    "unknown"
};

char *Days[] = {
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
};

char *Months[] = {
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
};

void
DisplayRecord(
    PTIMEIT_RECORD p,
    PTIMEIT_RECORD pavg
    )
{
    LARGE_INTEGER LocalExitTime;
    TIME_FIELDS ExitTime, ElapsedTime, ProcessTime;

    fprintf( stderr, "\n" );
    fprintf( stderr,
             "Version Number:   %s %u.%u (Build %u)\n",
             PlatformStrings[ (p->GetVersionNumber >> 30) & 0x3 ],
             p->GetVersionNumber & 0xFF,
             (p->GetVersionNumber >> 8) & 0xFF,
             (p->GetVersionNumber >> 16) & 0x3FFF
           );
    if (pavg != NULL) {
        fprintf( stderr, "Average is for %u runs\n", pavg->NumberOfRecordsInAverage );
        }

    FileTimeToLocalFileTime( (LPFILETIME)&p->ExitTime, (LPFILETIME)&LocalExitTime );
    RtlTimeToTimeFields( &LocalExitTime, &ExitTime );
    fprintf( stderr,
             "Exit Time:        %u:%02u %s, %s, %s %u %u\n",
             ExitTime.Hour > 12 ? ExitTime.Hour - 12 : ExitTime.Hour,
             ExitTime.Minute,
             ExitTime.Hour > 12 ? "pm" : "am",
             Days[ ExitTime.Weekday ],
             Months[ ExitTime.Month-1 ],
             ExitTime.Day,
             ExitTime.Year
           );

    RtlTimeToTimeFields( &p->ElapsedTime, &ElapsedTime );
    fprintf( stderr,
             "Elapsed Time:     %u:%02u:%02u.%03u",
             ElapsedTime.Hour,
             ElapsedTime.Minute,
             ElapsedTime.Second,
             ElapsedTime.Milliseconds
           );
    if (pavg != NULL) {
        RtlTimeToTimeFields( &pavg->ElapsedTime, &ElapsedTime );
        fprintf( stderr,
                 "  Average: %u:%02u:%02u.%03u",
                 ElapsedTime.Hour,
                 ElapsedTime.Minute,
                 ElapsedTime.Second,
                 ElapsedTime.Milliseconds
               );
        }
    fprintf( stderr, "\n" );

    RtlTimeToTimeFields( &p->ProcessTime, &ProcessTime );
    fprintf( stderr,
             "Process Time:     %u:%02u:%02u.%03u",
             ProcessTime.Hour,
             ProcessTime.Minute,
             ProcessTime.Second,
             ProcessTime.Milliseconds
           );
    if (pavg != NULL) {
        RtlTimeToTimeFields( &pavg->ProcessTime, &ProcessTime );
        fprintf( stderr,
                 "  Average: %u:%02u:%02u.%03u",
                 ProcessTime.Hour,
                 ProcessTime.Minute,
                 ProcessTime.Second,
                 ProcessTime.Milliseconds
               );
        }
    fprintf( stderr, "\n" );    

    if (p->Flags & TIMEIT_RECORD_SYSTEMINFO) {
        fprintf( stderr, "System Calls:     %-11u", p->SystemCalls );
        if (pavg != NULL) {
            fprintf( stderr, "  Average: %u", pavg->SystemCalls );
            }
        fprintf( stderr, "\n" );

        fprintf( stderr, "Context Switches: %-11u", p->ContextSwitches );
        if (pavg != NULL) {
            fprintf( stderr, "  Average: %u", pavg->ContextSwitches );
            }
        fprintf( stderr, "\n" );

        fprintf( stderr, "Page Faults:      %-11u", p->PageFaultCount );
        if (pavg != NULL) {
            fprintf( stderr, "  Average: %u", pavg->PageFaultCount );
            }
        fprintf( stderr, "\n" );

        fprintf( stderr, "Bytes Read:       %-11u", p->IoReadTransferCount.QuadPart );
        if (pavg != NULL) {
            fprintf( stderr, "  Average: %u", pavg->IoReadTransferCount.QuadPart );
            }
        fprintf( stderr, "\n" );

        fprintf( stderr, "Bytes Written:    %-11u", p->IoWriteTransferCount.QuadPart );
        if (pavg != NULL) {
            fprintf( stderr, "  Average: %u", pavg->IoReadTransferCount.QuadPart );
            }
        fprintf( stderr, "\n" );

        fprintf( stderr, "Bytes Other:      %-11u", p->IoOtherTransferCount.QuadPart );
        if (pavg != NULL) {
            fprintf( stderr, "  Average: %u", pavg->IoOtherTransferCount.QuadPart );
            }
        fprintf( stderr, "\n" );
        }

}

BOOLEAN DisplayDataBaseFirstTime;

void
DisplayDataBaseAverage(
    PTIMEIT_RECORD p,
    BOOLEAN ShowDetailForAverage,
    BOOLEAN TabularOutput
    )
{
    LARGE_INTEGER LocalExitTime;
    TIME_FIELDS ExitTime, ElapsedTime, ProcessTime;

    AccumulateRecord( p, NULL );

    if (DisplayDataBaseFirstTime) {
        if (TabularOutput) {
            fprintf( stderr, "Runs Name                      Elapsed Time   Process Time    System   Context    Page    Total I/O\n" );
            fprintf( stderr, "                                                               Calls  Switches   Faults\n" );
            }

        DisplayDataBaseFirstTime = FALSE;
        }
    else
    if (!TabularOutput) {
        fprintf( stderr, "\n\n" );
        }

    if (TabularOutput) {
        if (p->KeyName[0] == '\0') {
            FileTimeToLocalFileTime( (LPFILETIME)&p->ExitTime, (LPFILETIME)&LocalExitTime );
            RtlTimeToTimeFields( &LocalExitTime, &ExitTime );
            sprintf( p->KeyName,
                     "%02u/%02u/%4u %02u:%02u %s",
                     ExitTime.Month,
                     ExitTime.Day,
                     ExitTime.Year,
                     ExitTime.Hour > 12 ? ExitTime.Hour - 12 : ExitTime.Hour,
                     ExitTime.Minute,
                     ExitTime.Hour > 12 ? "pm" : "am"
                   );
            }

        if (p->NumberOfRecordsInAverage == 0) {
            fprintf( stderr, "    " );
            }
        else
        if (p->NumberOfRecordsInAverage == 0xFFFF) {
            fprintf( stderr, "EXCL" );
            }
        else {
            fprintf( stderr, "%-4u", p->NumberOfRecordsInAverage );
            }
        RtlTimeToTimeFields( &p->ElapsedTime, &ElapsedTime );
        fprintf( stderr, " %-24s %3u:%02u:%02u.%03u",
                 p->KeyName,
                 ElapsedTime.Hour,
                 ElapsedTime.Minute,
                 ElapsedTime.Second,
                 ElapsedTime.Milliseconds
               );

        RtlTimeToTimeFields( &p->ProcessTime, &ProcessTime );
        fprintf( stderr, " %3u:%02u:%02u.%03u",
                 ProcessTime.Hour,
                 ProcessTime.Minute,
                 ProcessTime.Second,
                 ProcessTime.Milliseconds
               );

        if (p->Flags & TIMEIT_RECORD_SYSTEMINFO) {
            fprintf( stderr, " %9u %9u %8u%12u",
                     p->SystemCalls,
                     p->ContextSwitches,
                     p->PageFaultCount,
                     p->IoReadTransferCount.QuadPart +
                        p->IoWriteTransferCount.QuadPart +
                        p->IoOtherTransferCount.QuadPart
                   );
            }
        fprintf( stderr, "\n" );
        if (ShowDetailForAverage &&
            p->NumberOfRecordsInAverage != 0 &&
            p->NumberOfRecordsInAverage != 0xFFFF
           ) {
            fprintf( stderr, "\n" );
            }
        }
    else {
        if (p->NumberOfRecordsInAverage == 0) {
            fprintf( stderr, "Detail Record included in average below\n" );
            }
        else
        if (p->NumberOfRecordsInAverage == 0xFFFF) {
            fprintf( stderr, "Detail Record excluded from average below\n" );
            }
        else {
            fprintf( stderr,
                     "Average for %s key over %u runs\n",
                     p->KeyName,
                     p->NumberOfRecordsInAverage
                   );
            }

        DisplayRecord( p, NULL );
        }
}

void
DisplayDataBase(
    LPSTR DataBaseFileName,
    LPSTR KeyName,
    BOOLEAN ShowDetailForAverage,
    BOOLEAN TabularOutput
    )
{
    TIMEIT_RECORD Averages, Detail;
    PTIMEIT_RECORD p, pPrev, pNext;
    PTIMEIT_FILE pf;
    ULONG i, j;
    ULONG NumberOfRecords, NumberOfRecordsInGroup, CurrentRecordInGroup, NumberOfRecordsToTrim;

    pf = MapDataBase( DataBaseFileName,
                      (BOOLEAN)(ForceSort | RemoveKeys),
                      NULL,
                      &NumberOfRecords
                    );
    if (pf == NULL) {
        fprintf( stderr, "Unable to access data base file '%s' (%u)\n",
                 DataBaseFileName, GetLastError()
               );
        exit( 1 );
        }

    if (pf->VersionNumber != TIMEIT_VERSION) {
        fprintf( stderr, "Invalid version number (%u) in data base file '%s'\n",
                 pf->VersionNumber, DataBaseFileName
               );
        exit( 1 );
        }

    pPrev = NULL;
    DisplayDataBaseFirstTime = TRUE;
    for (i=0; i<NumberOfRecords; i++) {
        p = &pf->Records[ i ];
        if (i == 0 || _stricmp( p->KeyName, Averages.KeyName )) {
            if (i != 0 && (KeyName == NULL || !_stricmp( KeyName, Averages.KeyName ))) {
                DisplayDataBaseAverage( &Averages, ShowDetailForAverage, TabularOutput );
                }

            pNext = p+1;
            NumberOfRecordsInGroup = 1;
            for (j=i+1; j<NumberOfRecords; j++) {
                if (!_stricmp( p->KeyName, pNext->KeyName )) {
                    NumberOfRecordsInGroup += 1;
                    }
                else {
                    break;
                    }

                pNext += 1;
                }

            CurrentRecordInGroup = 0;
            NumberOfRecordsToTrim = NumberOfRecordsInGroup / 10;
            memset( &Averages, 0, sizeof( Averages ) );
            strcpy( Averages.KeyName, p->KeyName );
            Averages.GetVersionNumber = p->GetVersionNumber;
            }

        Detail = *p;
        Detail.KeyName[0] = '\0';

        CurrentRecordInGroup += 1;
        if (CurrentRecordInGroup <= NumberOfRecordsToTrim ||
            CurrentRecordInGroup > (NumberOfRecordsInGroup-NumberOfRecordsToTrim)
           ) {
            //
            // Ignore fastest and slowest records
            //
            Detail.NumberOfRecordsInAverage = 0xFFFF;
            }
        else {
            Detail.NumberOfRecordsInAverage = 0;
            }

        if (ShowDetailForAverage && (KeyName == NULL || !_stricmp( KeyName, p->KeyName ))) {
            DisplayDataBaseAverage( &Detail, ShowDetailForAverage, TabularOutput );
            }

        if (Detail.NumberOfRecordsInAverage != 0xFFFF) {
            AccumulateRecord( &Averages, p );
            }
        }

    if (i != 0 && (KeyName == NULL || !_stricmp( KeyName, Averages.KeyName ))) {
        DisplayDataBaseAverage( &Averages, ShowDetailForAverage, TabularOutput );
        }
}


int
__cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    LPSTR s, s1, KeyName, CommandLine, DataBaseFileName;
    BOOL b;
    NTSTATUS Status;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    KERNEL_USER_TIMES Times;
    TIMEIT_RECORD t, Averages;
    BOOLEAN DisplayAverage;
    BOOLEAN ShowDetailForAverage;
    BOOLEAN TabularOutput;
    BOOLEAN SuppressSystemInfo;


    //
    // Console API's are OEM, so make it so for us as well
    //
    ConvertAppToOem( argc, argv );

    // printf( "sizeof( TIMEIT_RECORD ) == 0x%x\n", sizeof( TIMEIT_RECORD ) );

    IgnoreNonZeroExitCodes = FALSE;
    ShowDetailForAverage = FALSE;
    SuppressSystemInfo = FALSE;
    TabularOutput = FALSE;
    DisplayAverage = FALSE;
    DataBaseFileName = "timeit.dat";
    CommandLine = NULL;
    KeyName = NULL;
    RemoveKeys = FALSE;
    while (--argc) {
        s = *++argv;
        if (*s == '-') {
            while (*++s) {
                switch(tolower( *s )) {
                    case 'd':
                        ShowDetailForAverage = TRUE;
                        break;

                    case 's':
                        SuppressSystemInfo = TRUE;
                        break;

                    case 't':
                        TabularOutput = TRUE;
                        break;

                    case 'a':
                        DisplayAverage = TRUE;
                        break;

                    case 'f':
                        if (--argc) {
                            DataBaseFileName = *++argv;
                            }
                        else {
                            fprintf( stderr, "Missing parameter to -f switch\n" );
                            Usage();
                            }
                        break;

                    case 'i':
                        IgnoreNonZeroExitCodes = TRUE;
                        break;

                    case 'k':
                        if (--argc) {
                            KeyName = *++argv;
                            }
                        else {
                            fprintf( stderr, "Missing parameter to -k switch\n" );
                            Usage();
                            }
                        break;

                    case 'c':
                        ForceSort = TRUE;
                        break;

                    case 'r':
                        RemoveKeys = TRUE;
                        if (--argc) {
                            KeyNameToRemove = *++argv;
                            if (s1 = strchr(KeyNameToRemove, ',')) {
                                *s1++ = '\0';
                                KeyEntriesToTrim = atoi(s1);
                                }
                            }
                        else {
                            fprintf( stderr, "Missing parameter to -r switch\n" );
                            Usage();
                            }
                        break;

                    default:
                        fprintf( stderr, "Invalid switch -%c\n", *s );
                        Usage();
                        break;
                    }
                }
            }
        else {
            if (KeyName == NULL) {
                KeyName = s;
                }

            CommandLine = GetCommandLine();
            while (*CommandLine && *CommandLine <= ' ') {
                CommandLine += 1;
                }
            while (*CommandLine && *CommandLine > ' ') {
                CommandLine += 1;
                }

            CommandLine = strstr( CommandLine, s );
            break;
            }
        }

    if (CommandLine == NULL) {
        DisplayDataBase( DataBaseFileName, KeyName, ShowDetailForAverage, TabularOutput );
        exit( 0 );
        }

    memset( &StartupInfo,0,sizeof( StartupInfo ) );
    StartupInfo.cb = sizeof(StartupInfo);

    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       &BasicInfo,
                                       sizeof( BasicInfo ),
                                       NULL
                                     );
    if (!NT_SUCCESS( Status )) {
        fprintf( stderr, "Unable to query basic system information (%x)\n", Status );
        exit( RtlNtStatusToDosError( Status ) );
        }

    if (!SuppressSystemInfo) {
        Status = NtQuerySystemInformation( SystemPerformanceInformation,
                                           (PVOID)&SystemInfoStart,
                                           sizeof( SystemInfoStart ),
                                           NULL
                                         );
        if (!NT_SUCCESS( Status )) {
            fprintf( stderr, "Unable to query system performance data (%x)\n", Status );
            exit( RtlNtStatusToDosError( Status ) );
            }
        }

    if (!CreateProcess( NULL,
                        CommandLine,
                        NULL,
                        NULL,
                        TRUE,
                        0,
                        NULL,
                        NULL,
                        &StartupInfo,
                        &ProcessInformation
                      )
       ) {
        fprintf( stderr,
                 "CreateProcess( '%s' ) failed (%u)\n",
                 CommandLine,
                 GetLastError()
               );
        exit( GetLastError() );
        }

    SetConsoleCtrlHandler( CtrlcHandler, TRUE );

    WaitForSingleObject( ProcessInformation.hProcess, INFINITE );

    Status = NtQueryInformationProcess( ProcessInformation.hProcess,
                                        ProcessTimes,
                                        &Times,
                                        sizeof( Times ),
                                        NULL
                                      );

    if (!NT_SUCCESS( Status )) {
        fprintf( stderr, "Unable to query process times (%x)\n", Status );
        exit( RtlNtStatusToDosError( Status ) );
        }

    if (!SuppressSystemInfo) {
        Status = NtQuerySystemInformation( SystemPerformanceInformation,
                                           (PVOID)&SystemInfoDone,
                                           sizeof( SystemInfoDone ),
                                           NULL
                                         );
        if (!NT_SUCCESS( Status )) {
            fprintf( stderr, "Unable to query system performance data (%x)\n", Status );
            exit( RtlNtStatusToDosError( Status ) );
            }
        }

    memset( &t, 0, sizeof( t ) );
    strcpy( t.KeyName, KeyName );
    t.GetVersionNumber = GetVersion();
    GetExitCodeProcess( ProcessInformation.hProcess, &t.ExitCode );
    t.ExitTime.QuadPart = Times.ExitTime.QuadPart;
    t.ElapsedTime.QuadPart = Times.ExitTime.QuadPart - Times.CreateTime.QuadPart;

    // total process time ...
    t.ProcessTime.QuadPart = Times.KernelTime.QuadPart + Times.UserTime.QuadPart;

    if (!SuppressSystemInfo) {
        t.SystemCalls = SystemInfoDone.SystemCalls - SystemInfoStart.SystemCalls;
        t.ContextSwitches = SystemInfoDone.ContextSwitches - SystemInfoStart.ContextSwitches;
        t.PageFaultCount = SystemInfoDone.PageFaultCount - SystemInfoStart.PageFaultCount;

        t.IoReadTransferCount.QuadPart = SystemInfoDone.IoReadTransferCount.QuadPart -
                                         SystemInfoStart.IoReadTransferCount.QuadPart;
        t.IoReadTransferCount.QuadPart += (SystemInfoDone.PageReadCount -
                                           SystemInfoStart.PageReadCount) * BasicInfo.PageSize;
        t.IoReadTransferCount.QuadPart += (SystemInfoDone.CacheReadCount -
                                           SystemInfoStart.CacheReadCount) * BasicInfo.PageSize;

        t.IoWriteTransferCount.QuadPart = SystemInfoDone.IoWriteTransferCount.QuadPart -
                                          SystemInfoStart.IoWriteTransferCount.QuadPart;
        t.IoWriteTransferCount.QuadPart += (SystemInfoDone.DirtyPagesWriteCount -
                                            SystemInfoStart.DirtyPagesWriteCount) * BasicInfo.PageSize;
        t.IoWriteTransferCount.QuadPart += (SystemInfoDone.MappedPagesWriteCount -
                                            SystemInfoStart.MappedPagesWriteCount) * BasicInfo.PageSize;

        t.IoOtherTransferCount.QuadPart = SystemInfoDone.IoOtherTransferCount.QuadPart -
                                          SystemInfoStart.IoOtherTransferCount.QuadPart;

        t.Flags |= TIMEIT_RECORD_SYSTEMINFO;
        }

    UpdateDataBase( DataBaseFileName, &t, DisplayAverage ? &Averages : NULL );

    exit( t.ExitCode );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pview\makefile.inc ===
pviewrc.rc: explode.dlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pview\acledit.c ===
/****************************************************************************

   PROGRAM: ACLEDIT.C

   PURPOSE: Contains routines that edit security on Nt objects

****************************************************************************/

#include "pviewp.h"
#include <sedapi.h>


//
// Define the type of a pointer to the DACL editor fn
//

typedef DWORD (*LPFNDACLEDITOR) (   HWND,
                                    HANDLE,
                                    LPWSTR,
                                    PSED_OBJECT_TYPE_DESCRIPTOR,
                                    PSED_APPLICATION_ACCESSES,
                                    LPWSTR,
                                    PSED_FUNC_APPLY_SEC_CALLBACK,
                                    ULONG_PTR,
                                    PSECURITY_DESCRIPTOR,
                                    BOOLEAN,
                                    BOOLEAN,    // CantWriteDacl
                                    LPDWORD,
                                    DWORD  );


//
// Declare globals used to reference dynamically loaded ACLEditor module
//

HMODULE hModAclEditor = NULL;
LPFNDACLEDITOR lpfnDaclEditor = NULL;






//
// Define security information for each type of object
//



//
// Define the maximum number of accesses per object type
//

#define MAX_ACCESSES    30


//
// Define structure to contain the security information for
// an object type
//

typedef struct _OBJECT_TYPE_SECURITY_INFO {
    LPWSTR  TypeName;
    SED_HELP_INFO HelpInfo ;
    SED_OBJECT_TYPE_DESCRIPTOR SedObjectTypeDescriptor;
    GENERIC_MAPPING GenericMapping;
    SED_APPLICATION_ACCESSES AppAccesses ;
    SED_APPLICATION_ACCESS AppAccess[MAX_ACCESSES];

} OBJECT_TYPE_SECURITY_INFO, *POBJECT_TYPE_SECURITY_INFO;


//
// Define name of help file
//

#define HELP_FILENAME   L"pview.hlp"



//
// Define dummy access (used as filler)
//

#define DUMMY_ACCESS                                                \
    {                                                               \
        0,                                                          \
        0,                                                          \
        0,                                                          \
        NULL                                                        \
    }



//
// Define generic accesses
//

#define GENERIC_ACCESSES_5(Type)                                    \
    {                                                               \
        Type,                                                       \
        GENERIC_ALL,                                                \
        0,                                                          \
        L"All Access"                                               \
    },                                                              \
    {                                                               \
        Type,                                                       \
        GENERIC_READ,                                               \
        0,                                                          \
        L"Read"                                                     \
    },                                                              \
    {                                                               \
        Type,                                                       \
        GENERIC_WRITE,                                              \
        0,                                                          \
        L"Write"                                                    \
    },                                                              \
    {                                                               \
        Type,                                                       \
        GENERIC_EXECUTE,                                            \
        0,                                                          \
        L"Execute"                                                  \
    },                                                              \
    {                                                               \
        Type,                                                       \
        0,                                                          \
        0,                                                          \
        L"None"                                                     \
    }


//
// Define generic accesses to be shown in special access dialog
//

#define SPECIAL_GENERIC_ACCESSES_4(Type)                            \
    {                                                               \
        Type,                                                       \
        GENERIC_ALL,                                                \
        0,                                                          \
        L"Generic All"                                              \
    },                                                              \
    {                                                               \
        Type,                                                       \
        GENERIC_READ,                                               \
        0,                                                          \
        L"Generic Read"                                             \
    },                                                              \
    {                                                               \
        Type,                                                       \
        GENERIC_WRITE,                                              \
        0,                                                          \
        L"Generic Write"                                            \
    },                                                              \
    {                                                               \
        Type,                                                       \
        GENERIC_EXECUTE,                                            \
        0,                                                          \
        L"Generic Execute"                                          \
    }


//
// Define standard accesses
//

#define STANDARD_ACCESSES_5(Type)                                   \
    {                                                               \
        Type,                                                       \
        DELETE,                                                     \
        0,                                                          \
        L"Delete"                                                   \
    },                                                              \
    {                                                               \
        Type,                                                       \
        READ_CONTROL,                                               \
        0,                                                          \
        L"Read Control"                                             \
    },                                                              \
    {                                                               \
        Type,                                                       \
        WRITE_DAC,                                                  \
        0,                                                          \
        L"Write DAC"                                                \
    },                                                              \
    {                                                               \
        Type,                                                       \
        WRITE_OWNER,                                                \
        0,                                                          \
        L"Write Owner"                                              \
    },                                                              \
    {                                                               \
        Type,                                                       \
        SYNCHRONIZE,                                                \
        0,                                                          \
        L"Synchronize"                                              \
    }




//
// Define security info for 'DEFAULT' ACLs found in tokens
//

OBJECT_TYPE_SECURITY_INFO DefaultSecurityInfo = {

    //
    // Type name
    //

    L"DEFAULT",

    //
    // Help info
    //

    {
        HELP_FILENAME,
        {0, 0, 0, 0, 0, 0, 0}
    },



    //
    // Acleditor object type descriptor
    //

    {
        SED_REVISION1,          // Revision
        FALSE,                  // Is container
        FALSE,                  // AllowNewObjectPermissions
        FALSE,                  // MapSpecificPermsToGeneric
        NULL,                   // Pointer to generic mapping
        NULL,                   // Pointer to generic mapping for new objects
        L"Default",             // Object type name
        NULL,                   // Pointer to help info
        NULL,                   // ApplyToSubContainerTitle
        NULL,                   // ApplyToObjectsTitle
        NULL,                   // ApplyToSubContainerConfirmation
        L"Special...",          // SpecialObjectAccessTitle
        NULL                    // SpecialNewObjectAccessTitle
    },



    //
    // Generic mapping
    //

    {
        STANDARD_RIGHTS_READ,
        STANDARD_RIGHTS_WRITE,
        STANDARD_RIGHTS_EXECUTE,
        STANDARD_RIGHTS_ALL
    },


    //
    // Application access structure
    //

    {
        14,                 // Access count (must match list below)
        NULL,               // Pointer to accesses
        L"Read",            // Default new access
    },


    //
    // Application accesses
    //

    {
        GENERIC_ACCESSES_5(SED_DESC_TYPE_RESOURCE),
        STANDARD_ACCESSES_5(SED_DESC_TYPE_RESOURCE_SPECIAL),
        SPECIAL_GENERIC_ACCESSES_4(SED_DESC_TYPE_RESOURCE_SPECIAL),

        DUMMY_ACCESS, // 15
        DUMMY_ACCESS, // 16
        DUMMY_ACCESS, // 17
        DUMMY_ACCESS, // 18
        DUMMY_ACCESS, // 19
        DUMMY_ACCESS, // 20
        DUMMY_ACCESS, // 21
        DUMMY_ACCESS, // 22
        DUMMY_ACCESS, // 23
        DUMMY_ACCESS, // 24
        DUMMY_ACCESS, // 25
        DUMMY_ACCESS, // 26
        DUMMY_ACCESS, // 27
        DUMMY_ACCESS, // 28
        DUMMY_ACCESS, // 29
        DUMMY_ACCESS  // 30
    }
};





//
// Define security info for each type of object
//

OBJECT_TYPE_SECURITY_INFO ObjectTypeSecurityInfo[] = {

    //
    // PROCESS
    //

    {
        //
        // Type name
        //

        L"Process",

        //
        // Help info
        //

        {
            HELP_FILENAME,
            {0, 0, 0, 0, 0, 0, 0}
        },



        //
        // Acleditor object type descriptor
        //

        {
            SED_REVISION1,          // Revision
            FALSE,                  // Is container
            FALSE,                  // AllowNewObjectPermissions
            FALSE,                  // MapSpecificPermsToGeneric
            NULL,                   // Pointer to generic mapping
            NULL,                   // Pointer to generic mapping for new objects
            L"Process",             // Object type name
            NULL,                   // Pointer to help info
            NULL,                   // ApplyToSubContainerTitle
            NULL,                   // ApplyToObjectsTitle
            NULL,                   // ApplyToSubContainerConfirmation
            L"Special...",          // SpecialObjectAccessTitle
            NULL                    // SpecialNewObjectAccessTitle
        },



        //
        // Generic mapping
        //

        {
            PROCESS_QUERY_INFORMATION | STANDARD_RIGHTS_READ,
            PROCESS_SET_INFORMATION | STANDARD_RIGHTS_WRITE,
            STANDARD_RIGHTS_EXECUTE,
            PROCESS_ALL_ACCESS
        },


        //
        // Application access structure
        //

        {
            21,                 // Access count (must match list below)
            NULL,               // Pointer to accesses
            L"Read",            // Default new access
        },


        //
        // Application accesses
        //

        {
            GENERIC_ACCESSES_5(SED_DESC_TYPE_RESOURCE),
            STANDARD_ACCESSES_5(SED_DESC_TYPE_RESOURCE_SPECIAL),

            { // 11
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_TERMINATE,
                0,
                L"Terminate"
            },
            { // 12
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_CREATE_THREAD,
                0,
                L"Create thread"
            },
            { // 13
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_VM_OPERATION,
                0,
                L"VM Operation"
            },
            { // 14
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_VM_READ,
                0,
                L"VM Read"
            },
            { // 15
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_VM_WRITE,
                0,
                L"VM Write"
            },
            { // 16
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_DUP_HANDLE,
                0,
                L"Duplicate handle"
            },
            { // 17
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_CREATE_PROCESS,
                0,
                L"Create process",
            },
            { // 18
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_SET_QUOTA,
                0,
                L"Set quota"
            },
            { // 19
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_SET_INFORMATION,
                0,
                L"Set information"
            },
            { // 20
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_QUERY_INFORMATION,
                0,
                L"Query information"
            },
            { // 21
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                PROCESS_SET_PORT,
                0,
                L"Set port"
            },

            DUMMY_ACCESS, // 22
            DUMMY_ACCESS, // 23
            DUMMY_ACCESS, // 24
            DUMMY_ACCESS, // 25
            DUMMY_ACCESS, // 26
            DUMMY_ACCESS, // 27
            DUMMY_ACCESS, // 28
            DUMMY_ACCESS, // 29
            DUMMY_ACCESS  // 30
        }
    },







    //
    // THREAD
    //

    {
        //
        // Type name
        //

        L"Thread",

        //
        // Help info
        //

        {
            HELP_FILENAME,
            {0, 0, 0, 0, 0, 0, 0}
        },



        //
        // Acleditor object type descriptor
        //

        {
            SED_REVISION1,          // Revision
            FALSE,                  // Is container
            FALSE,                  // AllowNewObjectPermissions
            FALSE,                  // MapSpecificPermsToGeneric
            NULL,                   // Pointer to generic mapping
            NULL,                   // Pointer to generic mapping for new objects
            L"Thread",              // Object type name
            NULL,                   // Pointer to help info
            NULL,                   // ApplyToSubContainerTitle
            NULL,                   // ApplyToObjectsTitle
            NULL,                   // ApplyToSubContainerConfirmation
            L"Special...",          // SpecialObjectAccessTitle
            NULL                    // SpecialNewObjectAccessTitle
        },



        //
        // Generic mapping
        //

        {
            THREAD_QUERY_INFORMATION | STANDARD_RIGHTS_READ,
            THREAD_SET_INFORMATION | STANDARD_RIGHTS_WRITE,
            STANDARD_RIGHTS_EXECUTE,
            THREAD_ALL_ACCESS
        },


        //
        // Application access structure
        //

        {
            20,                 // Access count (must match list below)
            NULL,               // Pointer to accesses
            L"Read",            // Default new access
        },


        //
        // Application accesses
        //

        {
            GENERIC_ACCESSES_5(SED_DESC_TYPE_RESOURCE),
            STANDARD_ACCESSES_5(SED_DESC_TYPE_RESOURCE_SPECIAL),

            { // 11
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_TERMINATE,
                0,
                L"Terminate"
            },
            { // 12
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_SUSPEND_RESUME,
                0,
                L"Suspend/Resume"
            },
            { // 13
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_ALERT,
                0,
                L"Alert"
            },
            { // 14
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_GET_CONTEXT,
                0,
                L"Get context"
            },
            { // 15
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_SET_CONTEXT,
                0,
                L"Set context"
            },
            { // 16
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_SET_INFORMATION,
                0,
                L"Set information"
            },
            { // 17
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_QUERY_INFORMATION,
                0,
                L"Query information"
            },
            { // 18
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_SET_THREAD_TOKEN,
                0,
                L"Set token"
            },
            { // 19
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_IMPERSONATE,
                0,
                L"Impersonate"
            },
            { // 20
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                THREAD_DIRECT_IMPERSONATION,
                0,
                L"Direct impersonation"
            },

            DUMMY_ACCESS, // 21
            DUMMY_ACCESS, // 22
            DUMMY_ACCESS, // 23
            DUMMY_ACCESS, // 24
            DUMMY_ACCESS, // 25
            DUMMY_ACCESS, // 26
            DUMMY_ACCESS, // 27
            DUMMY_ACCESS, // 28
            DUMMY_ACCESS, // 29
            DUMMY_ACCESS  // 30
        }
    },





    //
    // TOKEN
    //

    {
        //
        // Type name
        //

        L"Token",

        //
        // Help info
        //

        {
            HELP_FILENAME,
            {0, 0, 0, 0, 0, 0, 0}
        },



        //
        // Acleditor object type descriptor
        //

        {
            SED_REVISION1,          // Revision
            FALSE,                  // Is container
            FALSE,                  // AllowNewObjectPermissions
            FALSE,                  // MapSpecificPermsToGeneric
            NULL,                   // Pointer to generic mapping
            NULL,                   // Pointer to generic mapping for new objects
            L"Token",               // Object type name
            NULL,                   // Pointer to help info
            NULL,                   // ApplyToSubContainerTitle
            NULL,                   // ApplyToObjectsTitle
            NULL,                   // ApplyToSubContainerConfirmation
            L"Special...",          // SpecialObjectAccessTitle
            NULL                    // SpecialNewObjectAccessTitle
        },



        //
        // Generic mapping
        //

        {
            TOKEN_READ,
            TOKEN_WRITE,
            TOKEN_EXECUTE,
            TOKEN_ALL_ACCESS
        },


        //
        // Application access structure
        //

        {
            18,                 // Access count (must match list below)
            NULL,               // Pointer to accesses
            L"Read",            // Default new access
        },


        //
        // Application accesses
        //

        {
            GENERIC_ACCESSES_5(SED_DESC_TYPE_RESOURCE),
            STANDARD_ACCESSES_5(SED_DESC_TYPE_RESOURCE_SPECIAL),

            { // 11
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                TOKEN_ASSIGN_PRIMARY,
                0,
                L"Assign primary"
            },
            { // 12
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                TOKEN_DUPLICATE,
                0,
                L"Duplicate"
            },
            { // 13
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                TOKEN_IMPERSONATE,
                0,
                L"Impersonate"
            },
            { // 14
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                TOKEN_QUERY,
                0,
                L"Query"
            },
            { // 15
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                TOKEN_QUERY_SOURCE,
                0,
                L"Query source"
            },
            { // 16
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                TOKEN_ADJUST_PRIVILEGES,
                0,
                L"Adjust Privileges"
            },
            { // 17
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                TOKEN_ADJUST_GROUPS,
                0,
                L"Adjust Groups"
            },
            { // 18
                SED_DESC_TYPE_RESOURCE_SPECIAL,
                TOKEN_ADJUST_DEFAULT,
                0,
                L"Adjust Default"
            },

            DUMMY_ACCESS, // 19
            DUMMY_ACCESS, // 20
            DUMMY_ACCESS, // 21
            DUMMY_ACCESS, // 22
            DUMMY_ACCESS, // 23
            DUMMY_ACCESS, // 24
            DUMMY_ACCESS, // 25
            DUMMY_ACCESS, // 26
            DUMMY_ACCESS, // 27
            DUMMY_ACCESS, // 28
            DUMMY_ACCESS, // 29
            DUMMY_ACCESS  // 30
        }
    }

};


/***************************************************************************\
* InitializeACLEditor
*
* Purpose : Initializes this module.
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

BOOL
InitializeAclEditor(
    VOID
    )
{
    //
    // Load the acleditor module and get the proc addresses we need
    //

    hModAclEditor = LoadLibrary(TEXT("acledit.dll"));
    if (hModAclEditor == NULL) {
        return(FALSE);
    }

    lpfnDaclEditor = (LPFNDACLEDITOR)GetProcAddress(hModAclEditor,
                            TEXT("SedDiscretionaryAclEditor"));
    if (lpfnDaclEditor == NULL) {
        return(FALSE);
    }

    return(TRUE);
}


/***************************************************************************\
* FindObjectSecurityInfo
*
* Purpose : Searches for object type in our security info table and
*           returns pointer to security info if found.
*           Any pointers in the security info are initialized by this routine.
*
* Returns pointer to security info or NULL on failure
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

POBJECT_TYPE_SECURITY_INFO
FindObjectSecurityInfo(
    HANDLE  Object
    )
{
    NTSTATUS Status;
    POBJECT_TYPE_SECURITY_INFO SecurityInfo;
    POBJECT_TYPE_INFORMATION TypeInfo;
    ULONG Length;
    BOOL Found;
    ULONG i;

    //
    // Get the object type
    //

    Status = NtQueryObject(
                            Object,
                            ObjectTypeInformation,
                            NULL,
                            0,
                            &Length
                            );
    if (Status != STATUS_INFO_LENGTH_MISMATCH) {
        DbgPrint("NtQueryObject failed, status = 0x%lx\n", Status);
        return(NULL);
    }

    TypeInfo = Alloc(Length);
    if (TypeInfo == NULL) {
        DbgPrint("Failed to allocate %ld bytes for object type\n", Length);
        return(NULL);
    }


    Status = NtQueryObject(
                            Object,
                            ObjectTypeInformation,
                            TypeInfo,
                            Length,
                            NULL
                            );
    if (!NT_SUCCESS(Status)) {
        DbgPrint("NtQueryObject failed, status = 0x%lx\n", Status);
        Free(TypeInfo);
        return(NULL);
    }


    //
    // Search for the type in our array of security info
    //

    Found = FALSE;
    for ( i=0;
          i < (sizeof(ObjectTypeSecurityInfo) / sizeof(*ObjectTypeSecurityInfo));
          i++
          ) {

        UNICODE_STRING FoundType;

        SecurityInfo = &ObjectTypeSecurityInfo[i];

        RtlInitUnicodeString(&FoundType, SecurityInfo->TypeName);

        if (RtlEqualUnicodeString(&TypeInfo->TypeName, &FoundType, TRUE)) {
            Found = TRUE;
            break;
        }
    }

    Free(TypeInfo);

    return(Found ? SecurityInfo : NULL);
}




/***************************************************************************\
* EditObjectDacl
*
* Purpose : Displays and allows the user to edit the Dacl on an object
*
* Returns TRUE on success, FALSE on failure (Use GetLastError for detail)
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

BOOL
EditObjectDacl(
    HWND Owner,
    LPWSTR ObjectName,
    HANDLE Object,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    POBJECT_TYPE_SECURITY_INFO SecurityInfo,
    PSED_FUNC_APPLY_SEC_CALLBACK SetSecurityCallback,
    DWORD *EditResult
    )
{
    DWORD Result;
    HANDLE Instance;

    //
    // Initialize the pointer fields in the security info structure
    //

    SecurityInfo->AppAccesses.AccessGroup = SecurityInfo->AppAccess;
    SecurityInfo->SedObjectTypeDescriptor.GenericMapping =
                                    &SecurityInfo->GenericMapping;
    SecurityInfo->SedObjectTypeDescriptor.GenericMappingNewObjects =
                                    &SecurityInfo->GenericMapping;
    SecurityInfo->SedObjectTypeDescriptor.HelpInfo =
                                    &SecurityInfo->HelpInfo;

    //
    // Get the application instance handle
    //

    Instance = (HANDLE)(NtCurrentPeb()->ImageBaseAddress);
    ASSERT(Instance != 0);


    //
    // Call the ACL editor, it will call our ApplyNtObjectSecurity function
    // to store any ACL changes in the token.
    //

    Result = (*lpfnDaclEditor)(
                        Owner,
                        Instance,
                        NULL,               // server
                        &SecurityInfo->SedObjectTypeDescriptor, // object type
                        &SecurityInfo->AppAccesses, // application accesses
                        ObjectName,
                        SetSecurityCallback, // Callback
                        (ULONG_PTR)Object,    // Context
                        SecurityDescriptor,
                        (BOOLEAN)(SecurityDescriptor == NULL), // Couldn't read DACL
                        FALSE, // CantWriteDacl
                        EditResult,
                        0
                        );

    if (Result != ERROR_SUCCESS) {
        DbgPrint("DAcleditor failed, error = %d\n", Result);
        SetLastError(Result);
    }

    return (Result == ERROR_SUCCESS);

}








/***************************************************************************\
* ApplyNtObjectSecurity
*
* Purpose : Called by ACL editor to set new security on an object
*
* Returns ERROR_SUCCESS or win error code.
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

DWORD
ApplyNtObjectSecurity(
    HWND    hwndParent,
    HANDLE  hInstance,
    ULONG_PTR   CallbackContext,
    PSECURITY_DESCRIPTOR SecDesc,
    PSECURITY_DESCRIPTOR SecDescNewObjects,
    BOOLEAN ApplyToSubContainers,
    BOOLEAN ApplyToSubObjects,
    LPDWORD StatusReturn
    )
{
    HANDLE Object = (HANDLE)CallbackContext;
    NTSTATUS Status;

    *StatusReturn = SED_STATUS_FAILED_TO_MODIFY;

    //
    // Set the new DACL on the object
    //

    Status = NtSetSecurityObject(Object,
                                 DACL_SECURITY_INFORMATION,
                                 SecDesc);
    if (NT_SUCCESS(Status)) {
        *StatusReturn = SED_STATUS_MODIFIED;
    } else {
        DbgPrint("Failed to set new ACL on object, status = 0x%lx\n", Status);
        if (Status == STATUS_ACCESS_DENIED) {
            MessageBox(hwndParent,
                       "You do not have permission to set the permissions on this object",
                       NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        } else {
            MessageBox(hwndParent,
                       "Unable to set object security",
                       NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }
    }

    return(ERROR_SUCCESS);
}


/***************************************************************************\
* EditNtObjectDacl
*
* Purpose : Displays and allows the user to edit the Dacl on an NT object
*
* Returns TRUE on success, FALSE on failure (Use GetLastError for detail)
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

BOOL
EditNtObjectDacl(
    HWND Owner,
    LPWSTR ObjectName,
    HANDLE Object,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD *EditResult
    )
{
    BOOL Result;
    POBJECT_TYPE_SECURITY_INFO SecurityInfo;


    //
    // Lookup our security info for an object of this type
    //

    SecurityInfo = FindObjectSecurityInfo(Object);
    if (SecurityInfo == NULL) {
        MessageBox(Owner, "Unable to edit the security on an object of this type",
                                NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        return(FALSE);
    }


    //
    // Edit the ACL. Our callback function will be called to change the
    // new permissions
    //

    Result = EditObjectDacl(
                        Owner,
                        ObjectName,
                        Object,
                        SecurityDescriptor,
                        SecurityInfo,
                        ApplyNtObjectSecurity,
                        EditResult
                        );
    return (Result);

}


/***************************************************************************\
* EditNtObjectSecurity
*
* Purpose : Displays and allows the user to edit the protection on an NT object
*
* Parameters:
*
*   hwndOwner - Owner window for dialog
*   Object - handle to NT object. Should have been opened for MAXIMUM_ALLOWED
*   Name - Name of object
*
* Returns TRUE on success, FALSE on failure (Use GetLastError for detail)
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

BOOL
EditNtObjectSecurity(
    HWND    hwndOwner,
    HANDLE  Object,
    LPWSTR  ObjectName
    )
{
    NTSTATUS Status;
    BOOL Success = FALSE;
    DWORD EditResult;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    ULONG Length;

    //
    // If we don't have an address for the DACL editor, we can't do anything
    //

    if (lpfnDaclEditor == NULL) {
        DbgPrint("EditNtObjectSecurity - no ACL editor loaded\n");
        return(FALSE);
    }

    //
    // Read the existing security from the object
    //

    Status = NtQuerySecurityObject(Object,
                                   OWNER_SECURITY_INFORMATION |
                                   GROUP_SECURITY_INFORMATION |
                                   DACL_SECURITY_INFORMATION,
                                   NULL,
                                   0,
                                   &Length);
    ASSERT(!NT_SUCCESS(Status));

    if (Status != STATUS_BUFFER_TOO_SMALL) {
        DbgPrint("Failed to query object security, status = 0x%lx\n", Status);
    } else {

        SecurityDescriptor = Alloc(Length);
        if (SecurityDescriptor == NULL) {
            DbgPrint("Failed to allocate %ld bytes for object SD\n", Length);
            goto CleanupAndExit;
        }

        Status = NtQuerySecurityObject(Object,
                                       OWNER_SECURITY_INFORMATION |
                                       GROUP_SECURITY_INFORMATION |
                                       DACL_SECURITY_INFORMATION,
                                       SecurityDescriptor,
                                       Length,
                                       &Length);
        if (!NT_SUCCESS(Status)) {
            DbgPrint("Failed to query object security, status = 0x%lx\n", Status);
            goto CleanupAndExit;
        }

        ASSERT(RtlValidSecurityDescriptor(SecurityDescriptor));
    }

    //
    // Call the ACL editor, it will call our ApplyNtObjectSecurity function
    // to store any ACL changes in the object.
    //

    Success = EditNtObjectDacl(
                        hwndOwner,
                        ObjectName,
                        Object,
                        SecurityDescriptor,
                        &EditResult
                        );
    if (!Success) {
        DbgPrint("PVIEW: Failed to edit object DACL\n");
    }

CleanupAndExit:

    if (SecurityDescriptor != NULL) {
        Free(SecurityDescriptor);
    }

    return(Success);
}





/***************************************************************************\
* ApplyTokenDefaultDacl
*
* Purpose : Called by ACL editor to set new security on an object
*
* Returns ERROR_SUCCESS or win error code.
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

DWORD
ApplyTokenDefaultDacl(
    HWND    hwndParent,
    HANDLE  hInstance,
    ULONG_PTR   CallbackContext,
    PSECURITY_DESCRIPTOR SecDesc,
    PSECURITY_DESCRIPTOR SecDescNewObjects,
    BOOLEAN ApplyToSubContainers,
    BOOLEAN ApplyToSubObjects,
    LPDWORD StatusReturn
    )
{
    HANDLE Token = (HANDLE)CallbackContext;
    TOKEN_DEFAULT_DACL DefaultDacl;
    NTSTATUS Status;
    BOOLEAN DaclPresent;
    BOOLEAN DaclDefaulted;

    Status = RtlGetDaclSecurityDescriptor (
                    SecDesc,
                    &DaclPresent,
                    &DefaultDacl.DefaultDacl,
                    &DaclDefaulted
                    );
    ASSERT(NT_SUCCESS(Status));

    ASSERT(DaclPresent);


    Status = NtSetInformationToken(
                 Token,                    // Handle
                 TokenDefaultDacl,         // TokenInformationClass
                 &DefaultDacl,             // TokenInformation
                 sizeof(DefaultDacl)       // TokenInformationLength
                 );
    if (NT_SUCCESS(Status)) {
        *StatusReturn = SED_STATUS_MODIFIED;
    } else {
        DbgPrint("SetInformationToken failed, status = 0x%lx\n", Status);
        *StatusReturn = SED_STATUS_FAILED_TO_MODIFY;

        if (Status == STATUS_ACCESS_DENIED) {
            MessageBox(hwndParent,
                       "You do not have permission to set the default ACL in this token",
                       NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        } else {
            MessageBox(hwndParent,
                       "Unable to set default ACL in token",
                       NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }
    }

    return(ERROR_SUCCESS);
}


/***************************************************************************\
* EditTokenDefaultAcl
*
* Purpose : Displays and allows the user to edit the default ACL in a token
*
* Parameters:
*
*   hwndOwner - Owner window for dialog
*   Object - handle to token - opened for TOKEN_QUERY access
*   Name - Name of token
*
* Returns TRUE on success, FALSE on failure (Use GetLastError for detail)
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

BOOL
EditTokenDefaultDacl(
    HWND    hwndOwner,
    HANDLE  Token,
    LPWSTR  ObjectName
    )
{
    NTSTATUS Status;
    BOOL Result = FALSE;
    DWORD EditResult;
    PTOKEN_DEFAULT_DACL DefaultDacl = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    ULONG   InfoLength;

    //
    // If we don't have an address for the DACL editor, we can't do anything
    //

    if (lpfnDaclEditor == NULL) {
        DbgPrint("EditNtObjectSecurity - no ACL editor loaded\n");
        return(FALSE);
    }

    //
    // Read the default DACL from the token
    //

    Status = NtQueryInformationToken(
                 Token,                    // Handle
                 TokenDefaultDacl,         // TokenInformationClass
                 NULL,                     // TokenInformation
                 0,                        // TokenInformationLength
                 &InfoLength               // ReturnLength
                 );

    ASSERT(!NT_SUCCESS(Status));

    if (Status == STATUS_BUFFER_TOO_SMALL) {

        DefaultDacl = Alloc(InfoLength);
        if (DefaultDacl == NULL) {
            goto CleanupAndExit;
        }

        Status = NtQueryInformationToken(
                     Token,                    // Handle
                     TokenDefaultDacl,         // TokenInformationClass
                     DefaultDacl,              // TokenInformation
                     InfoLength,               // TokenInformationLength
                     &InfoLength               // ReturnLength
                     );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("NtQueryInformationToken failed, status = 0x%lx\n", Status);
            goto CleanupAndExit;
        }


        //
        // Create a security descriptor
        //

        SecurityDescriptor = Alloc(SECURITY_DESCRIPTOR_MIN_LENGTH);

        if (SecurityDescriptor == NULL) {
            DbgPrint("Failed to allocate security descriptor\n");
            goto CleanupAndExit;
        }

        Status = RtlCreateSecurityDescriptor(SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
        ASSERT(NT_SUCCESS(Status));


        //
        // Set the DACL on the security descriptor
        //

        Status = RtlSetDaclSecurityDescriptor(
                            SecurityDescriptor,
                            TRUE,   // DACL present
                            DefaultDacl->DefaultDacl,
                            FALSE   // DACL defaulted
                            );
        ASSERT(NT_SUCCESS(Status));

        ASSERT(RtlValidSecurityDescriptor(SecurityDescriptor));
    }



    //
    // Call the ACL editor, it will call our ApplyTokenDefaultAcl function
    // to store any default ACL changes in the token.
    //

    Result = EditObjectDacl(
                        hwndOwner,
                        ObjectName,
                        Token,
                        SecurityDescriptor,
                        &DefaultSecurityInfo,
                        ApplyTokenDefaultDacl,
                        &EditResult
                        );
    if (!Result) {
        DbgPrint("Failed to edit token default ACL\n");
    }

CleanupAndExit:

    if (SecurityDescriptor != NULL) {
        Free(SecurityDescriptor);
    }
    if (DefaultDacl != NULL) {
        Free(DefaultDacl);
    }

    return(Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pview\lsa.c ===
/****************************************************************************

   PROGRAM: LSA.C

   PURPOSE: Utility routines that access the LSA.

****************************************************************************/

#include "pviewp.h"
#include <ntlsa.h>
#include <string.h>


// Module global that holds handle to LSA once it has been opened.
static LSA_HANDLE  LsaHandle = NULL;

LSA_HANDLE OpenLsa(VOID);
VOID    CloseLsa(LSA_HANDLE);


/****************************************************************************

   FUNCTION: LsaInit

   PURPOSE:  Does any initialization required for this module

   RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL LsaInit(VOID)
{

    LsaHandle = OpenLsa();

    return (LsaHandle != NULL);

    return (TRUE);
}


/****************************************************************************

   FUNCTION: LsaTerminate

   PURPOSE:  Does any cleanup required for this module

   RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL LsaTerminate(VOID)
{

    if (LsaHandle != NULL) {
        CloseLsa(LsaHandle);
    }

    LsaHandle = NULL;

    return(TRUE);
}


/****************************************************************************

   FUNCTION: OpenLsa

   PURPOSE:  Opens the Lsa
             Returns handle to Lsa or NULL on failure

****************************************************************************/
LSA_HANDLE OpenLsa(VOID)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE ConnectHandle = NULL;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    //
    // Set up the Security Quality Of Service
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0L,
                               (HANDLE)NULL,
                               NULL);

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the SecurityQualityOfService field, so we must manually copy that
    // structure for now.
    //

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open a handle to the LSA.  Specifying NULL for the Server means that the
    // server is the same as the client.
    //

    Status = LsaOpenPolicy(NULL,
                        &ObjectAttributes,
                        POLICY_LOOKUP_NAMES,
                        &ConnectHandle
                        );

    if (!NT_SUCCESS(Status)) {
        DbgPrint("LSM - Lsa Open failed 0x%lx\n", Status);
        return NULL;
    }

    return(ConnectHandle);
}


/****************************************************************************

    FUNCTION: CloseLsa

    PURPOSE:  Closes the Lsa

****************************************************************************/
VOID CloseLsa(
    LSA_HANDLE LsaHandle)
{
    NTSTATUS Status;

    Status = LsaClose(LsaHandle);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("LSM - Lsa Close failed 0x%lx\n", Status);
    }

    return;
}


/****************************************************************************

   FUNCTION: SID2Name

   PURPOSE: Converts a SID into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL SID2Name(
    PSID    Sid,
    LPSTR   String,
    USHORT  MaxStringBytes)
{
    NTSTATUS    Status;
    ANSI_STRING    AnsiName;
    PLSA_REFERENCED_DOMAIN_LIST DomainList;
    PLSA_TRANSLATED_NAME NameList;

    if (LsaHandle == NULL) {
        DbgPrint("SECEDIT : Lsa not open yet\n");
        return(FALSE);
    }



    Status = LsaLookupSids(LsaHandle, 1, &Sid, &DomainList, &NameList);

    if (NT_SUCCESS(Status)) {

        // Convert to ansi string
        RtlUnicodeStringToAnsiString(&AnsiName, &NameList->Name, TRUE);

        // Free up the returned data
        LsaFreeMemory((PVOID)DomainList);
        LsaFreeMemory((PVOID)NameList);

        // Copy the ansi string into our local variable
        strncpy(String, AnsiName.Buffer, MaxStringBytes);

        // Free up the ansi string
        RtlFreeAnsiString(&AnsiName);

    } else {

        UNICODE_STRING UnicodeName;

        if (NT_SUCCESS(RtlConvertSidToUnicodeString(&UnicodeName, Sid, TRUE))) {
            DbgPrint("LsaLookupSids failed for sid <%wZ>, error = 0x%lx\n", &UnicodeName, Status);

            AnsiName.Buffer = String;
            AnsiName.MaximumLength = MaxStringBytes;
            RtlUnicodeStringToAnsiString(&AnsiName, &UnicodeName, FALSE);

            RtlFreeUnicodeString(&UnicodeName);
        } else {
            DbgPrint("LsaLookupSids failed, error = 0x%lx\n", Status);
            return(FALSE);
        }

    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: PRIV2Name

   PURPOSE: Converts a PRIVILEGE into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL PRIV2Name(
    LUID    Privilege,
    LPSTR   lpstr,
    UINT    MaxStringBytes)
{
    NTSTATUS        Status;
    STRING          String;
    PUNICODE_STRING UString;

    if (LsaHandle == NULL) {
        DbgPrint("SECEDIT : Lsa not open yet\n");
        return(FALSE);
    }

    Status = LsaLookupPrivilegeName(LsaHandle, &Privilege, &UString);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("SECEDIT: LsaLookupPrivilegeName failed, status = 0x%lx\n", Status);
        strcpy(lpstr, "<Unknown>");
    } else {

        //
        // Convert it to ANSI - because that's what the rest of the app is.
        //

        if (UString->Length > (USHORT)MaxStringBytes) {
            DbgPrint("SECEDIT: Truncating returned privilege name: *%S*\n", UString);
            UString->Length = (USHORT)MaxStringBytes;
            DbgPrint("                                         To: *%S*\n", UString);
        }

        String.Length = 0;
        String.MaximumLength = (USHORT)MaxStringBytes;
        String.Buffer = lpstr;
        Status = RtlUnicodeStringToAnsiString( &String, UString, FALSE );
        ASSERT(NT_SUCCESS(Status));
        LsaFreeMemory( UString );

    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pview\explode.h ===
#define PXPLODEDLG                  200
#define PXPLODE_PROCESS_ID          202
#define PXPLODE_PRIORITY_NORMAL     207
#define PXPLODE_PRIORITY_HIGH       208
#define PXPLODE_PRIORITY_IDL        206
#define PXPLODE_IMAGENAME           209
#define PXPLODE_TOTALIMAGE_COMMIT   212
#define PXPLODE_IMAGE_NOACCESS      214
#define PXPLODE_IMAGE_READONLY      216
#define PXPLODE_IMAGE_WRITECOPY     218
#define PXPLODE_IMAGE_EXECUTE       222
#define PXPLODE_IMAGE_READWRITE     225
#define PXPLODE_TOTALMAPPED_COMMIT  223
#define PXPLODE_MAPPED_NOACCESS     226
#define PXPLODE_MAPPED_READONLY     228
#define PXPLODE_MAPPED_READWRITE    230
#define PXPLODE_MAPPED_WRITECOPY    232
#define PXPLODE_MAPPED_EXECUTE      234
#define PXPLODE_TOTALPRIVATE_COMMIT 236
#define PXPLODE_PRIVATE_NOACCESS    238
#define PXPLODE_PRIVATE_READONLY    240
#define PXPLODE_PRIVATE_READWRITE   242
#define PXPLODE_PRIVATE_WRITECOPY   244
#define PXPLODE_PRIVATE_EXECUTE     246
#define PXPLODE_KERNEL_TIME         253
#define PXPLODE_USER_TIME           254
#define PXPLODE_ELAPSED_TIME        255
#define PXPLODE_READ_XFER           276
#define PXPLODE_WRITE_XFER          278
#define PXPLODE_OTHER_XFER          280
#define PXPLODE_READ_OPS            282
#define PXPLODE_WRITE_OPS           284
#define PXPLODE_OTHER_OPS           286
#define PXPLODE_PEAK_VSIZE          289
#define PXPLODE_VSIZE               291
#define PXPLODE_PFCOUNT             293
#define PXPLODE_PEAK_WS             295
#define PXPLODE_WS                  297
#define PXPLODE_PEAK_PF             299
#define PXPLODE_PF                  301
#define PXPLODE_PRIVATE_PAGE        303
#define PXPLODE_PEAK_PAGED          305
#define PXPLODE_PAGED               307
#define PXPLODE_PEAK_NONPAGED       309
#define PXPLODE_NONPAGED            311
#define PXPLODE_TERMINATE           312
#define PXPLODE_EXIT                314
#define PXPLODE_THREAD_LIST         315
#define PXPLODE_THREADELAPSED_TIME  321
#define PXPLODE_THREADKERNEL_TIME   322
#define PXPLODE_THREADUSER_TIME     323
#define PXPLODE_THREAD_HIGHEST      325
#define PXPLODE_THREAD_ABOVE        326
#define PXPLODE_THREAD_NORMAL       327
#define PXPLODE_THREAD_BELOW        328
#define PXPLODE_THREAD_LOWEST       329
#define PXPLODE_THREAD_DYNAMIC      331
#define PXPLODE_THREAD_SWITCHES     317
#define PXPLODE_PROCESS_LIST        257
#define PXPLODE_REFRESH             258
#define PXPLODE_REFRESH_TIME        260
#define PXPLODE_PROCESS_OBJECT      263
#define PXPLODE_THREAD_OBJECT       0x010A
#define PXPLODE_EVENT_OBJECT        0x010C
#define PXPLODE_SEMAPHORE_OBJECT    0x010E
#define PXPLODE_MUTEX_OBJECT        0x0110
#define PXPLODE_SECTION_OBJECT      0x0144
#define PXPLODE_HIDE                252
#define PXPLODE_IMAGE_COMMIT        211
#define PXPLODE_THREAD_COUNT        262
#define PXPLODE_SHOWHEAPS           264
#define PXPLODE_DUMPTOFILE          267
#define PXPLODE_THREAD_START        269
#define PXPLODE_POOLED_LIMITS       273
#define PXPLODE_QPGPEAK             277
#define PXPLODE_QPGCUR              281
#define PXPLODE_QPGLIM              285
#define PXPLODE_QNONPEAK            332
#define PXPLODE_QNONCUR             334
#define PXPLODE_QNONLIM             336
#define PXPLODE_QPFPEAK             338
#define PXPLODE_QPFCUR              340
#define PXPLODE_QPFLIM              342
#define PXPLODE_THREAD_PC           343
#define PXPLODE_PROCESS_ACL         347
#define PXPLODE_THREAD_ACL          348
#define PXPLODE_PROCESS_TOKEN       346
#define PXPLODE_THREAD_TOKEN        349
#define PXPLODE_PROCESS_TOKEN_ACL   350
#define PXPLODE_THREAD_TOKEN_ACL    351


#define IDD_MAIN                    1100
#define IDS_USERID                  1102
#define IDS_LOGONSESSION            1104
#define IDC_DEFAULTOWNER            1106
#define IDL_DISABLEDGROUPS          1111
#define IDB_DISABLEPRIVILEGE        1112
#define IDB_ENABLEPRIVILEGE         1113
#define IDL_ENABLEDPRIVILEGES       1117
#define IDL_DISABLEDPRIVILEGES      1118
#define IDL_ENABLEDGROUPS           1123
#define IDB_DISABLEGROUP            1124
#define IDB_ENABLEGROUP             1125
#define IDC_PRIMARYGROUP            1126
#define IDB_MORE                    1110
#define IDS_TOKENID                 1208
#define IDS_EXPIRATIONTIME          1209
#define IDS_TOKENTYPE               1210
#define IDS_IMPERSONATION           1211
#define IDS_DYNAMICCHARGED          1212
#define IDS_DYNAMICAVAILABLE        1213
#define IDS_MODIFIEDID              1214
#define IDS_RESTRICTEDSIDS          1215
#define IDD_MORE                    1101
#define IDB_DEFAULT_DACL            1108

#define PXPLODE_SECURITY_GROUP      345
#define PXPLODE_TOKEN_GROUP         467
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pview\mytoken.h ===
typedef struct {
    HANDLE                  Token;
    LPWSTR                  Name;

    PTOKEN_USER             UserId;
    PTOKEN_GROUPS           Groups;
    PTOKEN_OWNER            DefaultOwner;
    PTOKEN_PRIMARY_GROUP    PrimaryGroup;
    PTOKEN_PRIVILEGES       Privileges;
    PTOKEN_STATISTICS       TokenStats;
    PTOKEN_GROUPS           RestrictedSids ;

} MYTOKEN;
typedef MYTOKEN *PMYTOKEN;

HANDLE  OpenMyToken(HANDLE, LPWSTR);
BOOL    CloseMyToken(HWND, HANDLE, BOOL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pview\pviewp.h ===
#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <explode.h>

/*--------------------------------------------------------------------------*/
/*                                                                                  */
/*  Function Templates                                                            */
/*                                                                                  */
/*--------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------*/
/*                                                                                  */
/*  Defines                                                                        */
/*                                                                                  */
/*--------------------------------------------------------------------------*/

BOOL
ComputeVaSpace(
    HWND hDlg,
    HANDLE hProcess
    );

VOID
UpdateImageCommit(
    HWND hDlg
    );

#define LBS_MYSTYLE     (LBS_NOTIFY | LBS_OWNERDRAWFIXED | WS_VSCROLL)

#define SHOVEIT(x)      (MAKELONG((x),0))

#define MAXTASKNAMELEN      40

#define PROCESSVIEWDLG      10


// Define the maximum length of a string
#define MAX_STRING_LENGTH       255
#define MAX_STRING_BYTES        ((MAX_STRING_LENGTH + 1) * sizeof(TCHAR))

#ifndef RC_INVOKED
#include "lsa.h"
#include "util.h"
#include "mytoken.h"
#include "acledit.h"
#include "tokedit.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pview\mytoken.c ===
/****************************************************************************

   PROGRAM: MYTOKEN.C

   PURPOSE: Contains routines that manipulate tokens

****************************************************************************/

#include "PVIEWP.h"

typedef PVOID   *PPVOID;


HANDLE OpenToken(
    HANDLE      hMyToken,
    ACCESS_MASK DesiredAccess);

BOOL CloseToken(
    HANDLE  Token);

BOOL GetTokenInfo(
    HANDLE  Token,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PPVOID   pBuffer);

BOOL SetTokenInfo(
    HANDLE  Token,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PVOID   Buffer);

BOOL FreeTokenInfo(
    PVOID   Buffer);

HANDLE  AllocMyToken(VOID);
BOOL    ReadMyToken(HANDLE);
BOOL    WriteMyToken(HWND, HANDLE);
BOOL    FreeMyToken(HANDLE);
PVOID   AllocTokenInfo(HANDLE, TOKEN_INFORMATION_CLASS);


/****************************************************************************

   FUNCTION: OpenMyToken

   PURPOSE: Opens the token of the specified process or thread.

   RETURNS : Handle to mytoken on success, or NULL on failure.

****************************************************************************/

HANDLE OpenMyToken(
    HANDLE  Token,
    LPWSTR  Name
    )
{
    PMYTOKEN    pMyToken;
    HANDLE      hMyToken;

    //
    // Build a MYTOKEN structure.

    hMyToken = AllocMyToken();
    if (hMyToken == NULL) {
        return(NULL);
    }

    pMyToken = (PMYTOKEN)hMyToken;

    pMyToken->Token = Token;

    pMyToken->Name = Alloc((lstrlenW(Name) + 1) * sizeof(WCHAR));
    if (pMyToken->Name == NULL) {
        Free(pMyToken);
        return(NULL);
    }
    lstrcpyW(pMyToken->Name, Name);


    if (!ReadMyToken(hMyToken)) {
        DbgPrint("PVIEW : Failed to read token info\n");
        Free(pMyToken->Name);
        Free(pMyToken);
        return(NULL);
    }

    return(hMyToken);
}


/****************************************************************************

   FUNCTION: ReadMyToken

   PURPOSE: Reads the token info and stores in mytoken structure

   RETURNS : TRUE on success, FALSE on failure

****************************************************************************/

BOOL ReadMyToken(
    HANDLE  hMyToken)
{
    HANDLE      Token;
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;

    Token = OpenToken(hMyToken, TOKEN_QUERY);

    if (Token == NULL) {
        DbgPrint("PVIEW : Failed to open the token with TOKEN_QUERY access\n");
        return(FALSE);
    }

    if (!GetTokenInfo(Token, TokenStatistics, (PPVOID)&(pMyToken->TokenStats))) {
        DbgPrint("PVIEW : Failed to read token statistics from token\n");
    }

    if (!GetTokenInfo(Token, TokenGroups, (PPVOID)&(pMyToken->Groups))) {
        DbgPrint("PVIEW : Failed to read group info from token\n");
    }

    if (!GetTokenInfo(Token, TokenUser, (PPVOID)&(pMyToken->UserId))) {
        DbgPrint("PVIEW : Failed to read userid from token\n");
    }

    if (!GetTokenInfo(Token, TokenOwner, (PPVOID)&(pMyToken->DefaultOwner))) {
        DbgPrint("PVIEW : Failed to read default owner from token\n");
    }

    if (!GetTokenInfo(Token, TokenPrimaryGroup, (PPVOID)&(pMyToken->PrimaryGroup))) {
        DbgPrint("PVIEW : Failed to read primary group from token\n");
    }

    if (!GetTokenInfo(Token, TokenPrivileges, (PPVOID)&(pMyToken->Privileges))) {
        DbgPrint("PVIEW : Failed to read privilege info from token\n");
    }

    if ( !GetTokenInfo( Token, TokenRestrictedSids, (PPVOID) &(pMyToken->RestrictedSids) ) )
    {
        pMyToken->RestrictedSids = NULL ;
    }


    CloseToken(Token);

    return(TRUE);
}


/****************************************************************************

   FUNCTION: CloseMyToken

   PURPOSE: Closes the specified mytoken handle
            If fSaveChanges = TRUE, the token information is saved,
            otherwise it is discarded.

   RETURNS : TRUE on success, FALSE on failure.

****************************************************************************/

BOOL CloseMyToken(
    HWND    hDlg,
    HANDLE  hMyToken,
    BOOL    fSaveChanges)
{
    if (fSaveChanges) {
        WriteMyToken(hDlg, hMyToken);
    }

    return FreeMyToken(hMyToken);
}

/****************************************************************************

   FUNCTION: AllocMyToken

   PURPOSE: Allocates space for mytoken structure.

   RETURNS : HANDLE to mytoken or NULL on failure.

****************************************************************************/

HANDLE AllocMyToken(VOID)
{
    PMYTOKEN    pMyToken;

    pMyToken = (PMYTOKEN)Alloc(sizeof(MYTOKEN));

    return((HANDLE)pMyToken);
}


/****************************************************************************

   FUNCTION: FreeMyToken

   PURPOSE: Frees the memory allocated to mytoken structure.

   RETURNS : TRUE on success, FALSE on failure.

****************************************************************************/

BOOL FreeMyToken(
    HANDLE  hMyToken)
{
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;

    if (pMyToken->TokenStats != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->TokenStats));
    }

    if (pMyToken->UserId != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->UserId));
    }

    if (pMyToken->PrimaryGroup != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->PrimaryGroup));
    }

    if (pMyToken->DefaultOwner != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->DefaultOwner));
    }

    if (pMyToken->Groups != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->Groups));
    }

    if (pMyToken->Privileges != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->Privileges));
    }

    if (pMyToken->Name != NULL) {
        Free((PVOID)pMyToken->Name);
    }

    Free((PVOID)pMyToken);

    return(TRUE);
}


/****************************************************************************

   FUNCTION: WriteMyToken

   PURPOSE: Writes the token information out to the token

   RETURNS : TRUE on success, FALSE on failure.

****************************************************************************/

BOOL WriteMyToken(
    HWND    hDlg,
    HANDLE  hMyToken)
{
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;
    HANDLE      Token;

    //
    // Save default owner and primary group
    //

    Token = OpenToken(hMyToken, TOKEN_ADJUST_DEFAULT);

    if (Token == NULL) {

        DbgPrint("PVIEW: Failed to open token with TOKEN_ADJUST_DEFAULT access\n");
        MessageBox(hDlg, "Failed to open token with access required\nUnable to change default owner or primary group", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);

    } else {

        // Set default owner
        //
        if ((pMyToken->DefaultOwner != NULL) &&
           (!SetTokenInfo(Token, TokenOwner, (PVOID)(pMyToken->DefaultOwner)))) {
            MessageBox(hDlg, "Failed to set default owner", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }

        // Set primary group
        //
        if ((pMyToken->PrimaryGroup != NULL) &&
           (!SetTokenInfo(Token, TokenPrimaryGroup, (PVOID)(pMyToken->PrimaryGroup)))) {
            MessageBox(hDlg, "Failed to set primary group", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }

        CloseToken(Token);
    }

    //
    // Save group info
    //

    Token = OpenToken(hMyToken, TOKEN_ADJUST_GROUPS);

    if (Token == NULL) {

        DbgPrint("PVIEW: Failed to open token with TOKEN_ADJUST_GROUPS access\n");
        MessageBox(hDlg, "Failed to open token with access required\nUnable to change group settings", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);

    } else {

        if ((pMyToken->Groups != NULL) &&
           (!SetTokenInfo(Token, TokenGroups, (PVOID)(pMyToken->Groups)))) {
            MessageBox(hDlg, "Failed to change group settings", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }

        CloseToken(Token);
    }


    //
    // Change privileges
    //

    Token = OpenToken(hMyToken, TOKEN_ADJUST_PRIVILEGES);

    if (Token == NULL) {

        DbgPrint("PVIEW: Failed to open token with TOKEN_ADJUST_PRIVILEGES access\n");
        MessageBox(hDlg, "Failed to open token with access required\nUnable to change privilege settings", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);

    } else {

        if ((pMyToken->Privileges != NULL) &&
           (!SetTokenInfo(Token, TokenPrivileges, (PVOID)(pMyToken->Privileges)))) {
            MessageBox(hDlg, "Failed to change privilege settings", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }

        CloseToken(Token);
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: OpenToken

   PURPOSE: Opens the token with the specified access

   RETURNS : Handle to token on success, or NULL on failure.

****************************************************************************/

HANDLE OpenToken(
    HANDLE      hMyToken,
    ACCESS_MASK DesiredAccess)
{
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;

    return(pMyToken->Token);
}


/****************************************************************************

   FUNCTION: CloseToken

   PURPOSE: Closes the specified token handle

   RETURNS : TRUE on success, FALSE on failure.

****************************************************************************/

BOOL CloseToken(
    HANDLE  Token)
{
    return(TRUE);
}


/****************************************************************************

   FUNCTION: AllocTokenInfo

   PURPOSE: Allocates memory to hold the parameter that
            NTQueryInformationToken will return.
            Memory should be freed later using FreeTokenInfo

   RETURNS : Pointer to allocated memory or NULL on failure

****************************************************************************/

PVOID AllocTokenInfo(
    HANDLE  Token,
    TOKEN_INFORMATION_CLASS TokenInformationClass)
{
    NTSTATUS Status;
    ULONG   InfoLength;

    Status = NtQueryInformationToken(
                 Token,                    // Handle
                 TokenInformationClass,    // TokenInformationClass
                 NULL,                     // TokenInformation
                 0,                        // TokenInformationLength
                 &InfoLength               // ReturnLength
                 );

    if (Status != STATUS_BUFFER_TOO_SMALL) {
        DbgPrint("PVIEW: NtQueryInformationToken did NOT return buffer_too_small, status = 0x%lx\n", Status);
        return(NULL);
    }

    return Alloc(InfoLength);
}


/****************************************************************************

   FUNCTION: FreeTokenInfo

   PURPOSE: Frees the memory previously allocated with AllocTokenInfo

   RETURNS : TRUE on success, otherwise FALSE

****************************************************************************/

BOOL FreeTokenInfo(
    PVOID   Buffer)
{
    return(Free(Buffer));
}


/****************************************************************************

   FUNCTION: GetTokenInfo

   PURPOSE: Allocates a buffer and reads the specified data
            out of the token and into it.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/

BOOL GetTokenInfo(
    HANDLE  Token,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PPVOID   pBuffer)
{
    NTSTATUS Status;
    ULONG   BufferSize;
    ULONG   InfoLength;
    PVOID   Buffer;

    *pBuffer = NULL;    // Prepare for failure

    Buffer = AllocTokenInfo(Token, TokenInformationClass);
    if (Buffer == NULL) {
        return(FALSE);
    }

    BufferSize = GetAllocSize(Buffer);

    Status = NtQueryInformationToken(
                 Token,                    // Handle
                 TokenInformationClass,    // TokenInformationClass
                 Buffer,                   // TokenInformation
                 BufferSize,               // TokenInformationLength
                 &InfoLength               // ReturnLength
                 );

    if (!NT_SUCCESS(Status)) {
        DbgPrint("PVIEW: NtQueryInformationToken failed, status = 0x%lx\n", Status);
        FreeTokenInfo(Buffer);
        return(FALSE);
    }

    if (InfoLength > BufferSize) {
        DbgPrint("PVIEW: NtQueryInformationToken failed, DataSize > BufferSize");
        FreeTokenInfo(Buffer);
        return(FALSE);
    }

    *pBuffer = Buffer;

    return(TRUE);
}


/****************************************************************************

   FUNCTION: SetTokenInfo

   PURPOSE: Sets the specified information in the given token.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/

BOOL SetTokenInfo(
    HANDLE  Token,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PVOID   Buffer)
{
    NTSTATUS Status;
    ULONG   BufferSize;

    BufferSize = GetAllocSize(Buffer);

    switch (TokenInformationClass) {

    case TokenOwner:
    case TokenPrimaryGroup:
    case TokenDefaultDacl:

        Status = NtSetInformationToken(
                     Token,                    // Handle
                     TokenInformationClass,    // TokenInformationClass
                     Buffer,                   // TokenInformation
                     BufferSize                // TokenInformationLength
                     );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("PVIEW: NtSetInformationToken failed, info class = 0x%x, status = 0x%lx\n",
                                TokenInformationClass, Status);
            return(FALSE);
        }
        break;


    case TokenGroups:

        Status = NtAdjustGroupsToken(
                    Token,                      // Handle
                    FALSE,                      // Reset to default
                    (PTOKEN_GROUPS)Buffer,      // New State
                    BufferSize,                 // Buffer Length
                    NULL,                       // Previous State
                    NULL                        // Return Length
                    );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("PVIEW: NtAdjustGroupsToken failed, status = 0x%lx\n", Status);
            return(FALSE);
        }
        break;


    case TokenPrivileges:

        Status = NtAdjustPrivilegesToken(
                    Token,                      // Handle
                    FALSE,                      // Disable all privileges
                    (PTOKEN_PRIVILEGES)Buffer,  // New State
                    BufferSize,                 // Buffer Length
                    NULL,                       // Previous State
                    NULL                        // Return Length
                    );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("PVIEW: NtAdjustPrivilegesToken failed, status = 0x%lx\n", Status);
            return(FALSE);
        }
        break;


    default:

        // Unrecognised information type
        DbgPrint("PVIEW: SetTokenInfo passed unrecognised infoclass, class = 0x%x\n", TokenInformationClass);

        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pview\pview.c ===
#include "pviewp.h"
#include <port1632.h>
#include <string.h>
#include <stdlib.h>

ULONG PageSize = 4096;

#ifdef DBG
#define ODS OutputDebugString
#else
#define ODS
#endif

#define BUFSIZE 64*1024

LONG
ExplodeDlgProc(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
SetProcessFields(
    PSYSTEM_PROCESS_INFORMATION ProcessInfo,
    HWND hwnd
    );

VOID
SetThreadFields(
    PSYSTEM_THREAD_INFORMATION ThreadInfo,
    HWND hwnd
    );

VOID
InitProcessList(HWND hwnd);

int MyX = 0;
int MyY = 0;
int dxSuperTaskman;
int dySuperTaskman;
int dxScreen;
int dyScreen;
PSYSTEM_PROCESS_INFORMATION DlgProcessInfo;
BOOL Refresh = TRUE;

PUCHAR g_pLargeBuffer; // UCHAR LargeBuffer1[64*1024];
DWORD g_dwBufSize;

SYSTEM_TIMEOFDAY_INFORMATION RefreshTimeOfDayInfo;
HANDLE hEvent;
HANDLE hMutex;
HANDLE hSemaphore;
HANDLE hSection;

CHAR LastProcess[256];
CHAR LastThread[256];
CHAR LastModule[256];
CHAR Buffer[512];


LONG
ExplodeDlgProc(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int nIndex;
    HWND ThreadList;
    HWND ProcessList;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    HANDLE hProcess;

    switch (wMsg) {

    case WM_INITDIALOG:

        g_dwBufSize = BUFSIZE;

        g_pLargeBuffer = ( PUCHAR )malloc( sizeof( UCHAR ) * g_dwBufSize );

        if( g_pLargeBuffer == NULL )
        {
            EndDialog(hwnd, 0);
            return FALSE;
        }

        if (!RegisterHotKey(hwnd, 1, MOD_CONTROL | MOD_ALT, VK_ESCAPE) ) {
            EndDialog(hwnd, 0);
            return(FALSE);
        }

        ProcessInfo = NULL;
        DlgProcessInfo = ProcessInfo;
        wParam = 1;

        //
        // Tidy up the system menu
        //

        DeleteMenu(GetSystemMenu(hwnd, FALSE), SC_MAXIMIZE, MF_BYCOMMAND);
        DeleteMenu(GetSystemMenu(hwnd, FALSE), SC_SIZE, MF_BYCOMMAND);

        //
        // Hide acleditting controls if we can't handle them
        //

        if (!InitializeAclEditor()) {

            DbgPrint("PVIEW: Acl editor failed to initialize, ACL editting disabled\n");

            ShowWindow(GetDlgItem(hwnd, PXPLODE_SECURITY_GROUP), SW_HIDE);
            ShowWindow(GetDlgItem(hwnd, PXPLODE_PROCESS_ACL), SW_HIDE);
            ShowWindow(GetDlgItem(hwnd, PXPLODE_THREAD_ACL), SW_HIDE);
            ShowWindow(GetDlgItem(hwnd, PXPLODE_PROCESS_TOKEN_ACL), SW_HIDE);
            ShowWindow(GetDlgItem(hwnd, PXPLODE_THREAD_TOKEN_ACL), SW_HIDE);

            ShowWindow(GetDlgItem(hwnd, PXPLODE_TOKEN_GROUP), SW_HIDE);
            ShowWindow(GetDlgItem(hwnd, PXPLODE_PROCESS_TOKEN), SW_HIDE);
            ShowWindow(GetDlgItem(hwnd, PXPLODE_THREAD_TOKEN), SW_HIDE);
        }

        //
        // fall thru
        //

    case WM_HOTKEY:

        if ( wParam == 1 ) {
            PSYSTEM_PROCESS_INFORMATION ProcessInfo;
            NTSTATUS status;
            ULONG TotalOffset = 0;

            do
            {
                // re-read systemprocess info until we get the entire buffer ( if possible )

                status = NtQuerySystemInformation(
                            SystemProcessInformation,
                            ( PVOID )g_pLargeBuffer, // LargeBuffer1,
                            g_dwBufSize, //sizeof(LargeBuffer1),
                            NULL
                            );

                if( status != STATUS_INFO_LENGTH_MISMATCH )
                {
                    break;
                }

                ODS( "OnHotKey resizing g_pLargeBuffer\n" );

                g_dwBufSize *= 2;

                if( g_pLargeBuffer != NULL )
                {
                    free( g_pLargeBuffer );
                }

                g_pLargeBuffer = ( PUCHAR )malloc( sizeof( UCHAR ) * g_dwBufSize );

                if( g_pLargeBuffer == NULL )
                {
                    ODS( "Failed to re allocate mem in OnHotKey\n" );                    

                    EndDialog( hwnd , 0 );

                    return FALSE;
                }


            }while( 1 );
                
            if (!NT_SUCCESS(status)) {
                EndDialog(hwnd, 0);
                return(FALSE);
                }

            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)g_pLargeBuffer;
            DlgProcessInfo = ProcessInfo;
            Refresh = TRUE;
            InitProcessList(hwnd);
            Refresh = FALSE;

            ProcessList = GetDlgItem(hwnd, PXPLODE_PROCESS_LIST);
            nIndex = (int)SendMessage(ProcessList, CB_GETCURSEL, 0, 0);
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)SendMessage(
                                                        ProcessList,
                                                        CB_GETITEMDATA,
                                                        nIndex,
                                                        0
                                                        );
            if ( !ProcessInfo || CB_ERR == (LONG_PTR)ProcessInfo ) {
                ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)g_pLargeBuffer;
                }
            DlgProcessInfo = ProcessInfo;
            SetProcessFields(ProcessInfo,hwnd);

            SetForegroundWindow(hwnd);
            ShowWindow(hwnd, SW_NORMAL);
            }
        return FALSE;

    case WM_SYSCOMMAND:
        switch (wParam & 0xfff0) {
        case SC_CLOSE:
            EndDialog(hwnd, 0);
            return(TRUE);
        }
        return(FALSE);

    case WM_COMMAND:
        switch(LOWORD(wParam)) {

        case PXPLODE_THREAD_LIST:
            switch ( HIWORD(wParam) ) {
            case LBN_DBLCLK:
            case LBN_SELCHANGE:
                ThreadList = GetDlgItem(hwnd, PXPLODE_THREAD_LIST);
                nIndex = (int)SendMessage(ThreadList, LB_GETCURSEL, 0, 0);
                ThreadInfo = (PSYSTEM_THREAD_INFORMATION)SendMessage(
                                                            ThreadList,
                                                            LB_GETITEMDATA,
                                                            nIndex,
                                                            0
                                                            );
                if ( !ThreadInfo || LB_ERR == (LONG_PTR)ThreadInfo ) {
                    break;
                    }

                SetThreadFields(ThreadInfo,hwnd);
                break;
            }
            break;

        case PXPLODE_IMAGE_COMMIT:
            switch ( HIWORD(wParam) ) {
            case CBN_DBLCLK:
            case CBN_SELCHANGE:
                UpdateImageCommit(hwnd);
                break;
            }
            break;

        case PXPLODE_PROCESS_LIST:

            ProcessList = GetDlgItem(hwnd, PXPLODE_PROCESS_LIST);
            switch ( HIWORD(wParam) ) {
            case CBN_DBLCLK:
            case CBN_SELCHANGE:
                nIndex = (int)SendMessage(ProcessList, CB_GETCURSEL, 0, 0);
                SendMessage(ProcessList, CB_GETLBTEXT, nIndex, (LPARAM)LastProcess);
                ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)SendMessage(
                                                            ProcessList,
                                                            CB_GETITEMDATA,
                                                            nIndex,
                                                            0
                                                            );
                if ( !ProcessInfo || CB_ERR == (LONG_PTR)ProcessInfo ) {
                    break;
                    }

                DlgProcessInfo = ProcessInfo;
                SetProcessFields(ProcessInfo,hwnd);
                break;
            }
            break;

        case PXPLODE_EXIT:
            EndDialog(hwnd, 0);
            break;

        case PXPLODE_PRIORITY_NORMAL:
            hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,HandleToUlong(DlgProcessInfo->UniqueProcessId));
            SetPriorityClass(hProcess,NORMAL_PRIORITY_CLASS);
            CloseHandle(hProcess);
            goto refresh;
            break;

        case PXPLODE_PRIORITY_HIGH:
            hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,HandleToUlong(DlgProcessInfo->UniqueProcessId));
            SetPriorityClass(hProcess,HIGH_PRIORITY_CLASS);
            CloseHandle(hProcess);
            goto refresh;
            break;

        case PXPLODE_PRIORITY_IDL:
            hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,HandleToUlong(DlgProcessInfo->UniqueProcessId));
            SetPriorityClass(hProcess,IDLE_PRIORITY_CLASS);
            CloseHandle(hProcess);
            goto refresh;
            break;

        case PXPLODE_HIDE:
            ShowWindow(hwnd,SW_HIDE);
            break;

        case PXPLODE_SHOWHEAPS:
        case PXPLODE_DUMPTOFILE:
            MessageBox(hwnd,"This function not implemented yet","Not Implemented",MB_ICONSTOP|MB_OK);
            break;

        case PXPLODE_PROCESS_ACL:
        case PXPLODE_PROCESS_TOKEN_ACL:
        case PXPLODE_PROCESS_TOKEN:
        {
            WCHAR Name[100];
            HANDLE Process;
            HANDLE Token;

            ProcessList = GetDlgItem(hwnd, PXPLODE_PROCESS_LIST);
            nIndex = (int)SendMessage(ProcessList, CB_GETCURSEL, 0, 0);

            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)SendMessage(
                                                            ProcessList,
                                                            CB_GETITEMDATA,
                                                            nIndex,
                                                            0
                                                            );
            if ( !ProcessInfo || CB_ERR == (LONG_PTR)ProcessInfo ) {
                break;
                }

            SendMessageW(ProcessList, CB_GETLBTEXT, nIndex, (LPARAM)Name);

            switch(LOWORD(wParam)) {
            case PXPLODE_PROCESS_ACL:

                Process = OpenProcess(MAXIMUM_ALLOWED, FALSE, HandleToUlong(ProcessInfo->UniqueProcessId));
                if (Process != NULL) {
                    EditNtObjectSecurity(hwnd, Process, Name);
                    CloseHandle(Process);
                } else {
                    DbgPrint("Failed to open process for max allowed, error = %d\n", GetLastError());
                }
                break;

            default:

                Process = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, HandleToUlong(ProcessInfo->UniqueProcessId));
                if (Process != NULL) {

                    if (OpenProcessToken(Process, MAXIMUM_ALLOWED, &Token)) {
                        if (LOWORD(wParam) == PXPLODE_PROCESS_TOKEN_ACL) {
                            EditNtObjectSecurity(hwnd, Token, Name);
                        } else {
                            HANDLE Token2;
                            if (OpenProcessToken(Process, TOKEN_QUERY, &Token2)) {
                                CloseHandle(Token2);
                                EditToken(hwnd, Token, Name);
                            } else {
                                MessageBox(hwnd,
                                   "You do not have permission to view the token on this process",
                                   "Access Denied", MB_ICONSTOP | MB_OK);
                            }
                        }
                        CloseHandle(Token);
                    } else {
                        MessageBox(hwnd,
                           "You do not have permission to access the token on this process",
                           "Access Denied", MB_ICONSTOP | MB_OK);
                    }
                    CloseHandle(Process);
                } else {
                    DbgPrint("Failed to open process for query information, error = %d\n", GetLastError());
                }
                break;
            }


            break;
        }

        case PXPLODE_THREAD_ACL:
        case PXPLODE_THREAD_TOKEN_ACL:
        case PXPLODE_THREAD_TOKEN:
        {
            WCHAR Name[100];
            HANDLE Thread;
            HANDLE Token;

            ThreadList = GetDlgItem(hwnd, PXPLODE_THREAD_LIST);
            nIndex = (int)SendMessage(ThreadList, LB_GETCURSEL, 0, 0);
            ThreadInfo = (PSYSTEM_THREAD_INFORMATION)SendMessage(
                                                        ThreadList,
                                                        LB_GETITEMDATA,
                                                        nIndex,
                                                        0
                                                        );
            if ( !ThreadInfo || LB_ERR == (LONG_PTR)ThreadInfo ) {
                break;
                }

            SendMessageW(ThreadList, LB_GETTEXT, nIndex, (LPARAM)Name);

            switch(LOWORD(wParam)) {
            case PXPLODE_THREAD_ACL:

                Thread = OpenThread(MAXIMUM_ALLOWED, FALSE, HandleToUlong(ThreadInfo->ClientId.UniqueThread));
                if (Thread != NULL) {
                    EditNtObjectSecurity(hwnd, Thread, Name);
                    CloseHandle(Thread);
                } else {
                    DbgPrint("Failed to open thread for max allowed, error = %d\n", GetLastError());
                }
                break;

            default:

                Thread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, HandleToUlong(ThreadInfo->ClientId.UniqueThread));
                if (Thread != NULL) {
                    if (OpenThreadToken(Thread, MAXIMUM_ALLOWED, TRUE, &Token)) {
                        if (LOWORD(wParam) == PXPLODE_THREAD_TOKEN_ACL) {
                            EditNtObjectSecurity(hwnd, Token, Name);
                        } else {
                            HANDLE Token2;
                            if (OpenThreadToken(Thread, TOKEN_QUERY, TRUE, &Token2)) {
                                CloseHandle(Token2);
                                EditToken(hwnd, Token, Name);
                            } else {
                                MessageBox(hwnd,
                                   "You do not have permission to view the token on this thread",
                                   "Access Denied", MB_ICONSTOP | MB_OK);
                            }
                        }
                        CloseHandle(Token);
                    } else {
                        DbgPrint("Failed to open thread token for max allowed, error = %d\n", GetLastError());
                    }
                    CloseHandle(Thread);
                } else {
                    DbgPrint("Failed to open thread for query information, error = %d\n", GetLastError());
                }
                break;
            }
            break;
        }

        case PXPLODE_TERMINATE:
            hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,HandleToUlong(DlgProcessInfo->UniqueProcessId));
            wsprintf(Buffer,"Selecting OK will terminate %s... Do you really want to do this ?",LastProcess);
            if ( MessageBox(hwnd,Buffer,"Terminate Process",MB_ICONSTOP|MB_OKCANCEL) == IDOK ) {
                TerminateProcess(hProcess,99);
                }
            CloseHandle(hProcess);

            //
            // fall thru
            //

        case PXPLODE_REFRESH:
refresh:
            {
                PSYSTEM_PROCESS_INFORMATION ProcessInfo;
                NTSTATUS status;
                ULONG TotalOffset = 0;

                ProcessList = GetDlgItem(hwnd, PXPLODE_PROCESS_LIST);

                do
                {
                    status = NtQuerySystemInformation(
                                SystemProcessInformation,
                                ( PVOID )g_pLargeBuffer,
                                g_dwBufSize,
                                NULL
                                );

                    if( status != STATUS_INFO_LENGTH_MISMATCH )
                    {
                        break;
                    }                    

                    if( g_pLargeBuffer != NULL )
                    {
                        free( g_pLargeBuffer );
                    }

                    g_dwBufSize *= 2;

                    g_pLargeBuffer = ( PUCHAR )malloc( sizeof( UCHAR ) * g_dwBufSize );

                    if( g_pLargeBuffer == NULL )
                    {
                        ODS( "Failed to re allocate mem in OnPXPLODE_REFRESH\n" );

                        EndDialog( hwnd , 0 );

                        return FALSE;
                    }


                }while( 1 );

                if (!NT_SUCCESS(status)) {
                    ExitProcess(status);
                    }

                ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)g_pLargeBuffer;
                DlgProcessInfo = ProcessInfo;
                Refresh = TRUE;
                InitProcessList(hwnd);
                Refresh = FALSE;
                nIndex = (int)SendMessage(ProcessList, CB_GETCURSEL, 0, 0);
                ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)SendMessage(
                                                            ProcessList,
                                                            CB_GETITEMDATA,
                                                            nIndex,
                                                            0
                                                            );
                if ( !ProcessInfo || CB_ERR == (LONG_PTR)ProcessInfo ) {
                    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)g_pLargeBuffer;
                    }
                DlgProcessInfo = ProcessInfo;
                SetProcessFields(ProcessInfo,hwnd);
            }
            return FALSE;
        }
    default:
        return FALSE;
    }

    return TRUE;
}

int __cdecl main(
    int argc,
    char *argv[],
    char *envp[])
{
    hEvent = CreateEvent(NULL,TRUE,TRUE,NULL);
    hSemaphore = CreateSemaphore(NULL,1,256,NULL);
    hMutex = CreateMutex(NULL,FALSE,NULL);
    hSection = CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE,0,8192,NULL);

    DialogBoxParam(NULL,
                   MAKEINTRESOURCE(PXPLODEDLG),
                   NULL,
                   (DLGPROC)ExplodeDlgProc,
                   (LPARAM)0
                   );


    if( g_pLargeBuffer != NULL )
    {
        ODS( "Freeing buffer\n" );
        free( g_pLargeBuffer );
    }

    return 0;

    argc;
    argv;
    envp;
}

VOID
SetProcessFields(
    PSYSTEM_PROCESS_INFORMATION ProcessInfo,
    HWND hwnd
    )
{

    TIME_FIELDS UserTime;
    TIME_FIELDS KernelTime;
    TIME_FIELDS RunTime;
    LARGE_INTEGER Time;
    CHAR TimeString[15];
    CHAR szTempField[MAXTASKNAMELEN];
    CHAR szTemp[80];
    HANDLE hProcess;
    HWND ThreadList,ProcessList;
    int i, nIndex;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    PCHAR p;
    ANSI_STRING pname;

    pname.Buffer = NULL;
    hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,HandleToUlong(ProcessInfo->UniqueProcessId));

    //
    // Set process name and process id
    //

    if ( ProcessInfo->ImageName.Buffer ) {
        RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
        p = strrchr(pname.Buffer,'\\');
        if ( p ) {
            p++;
            }
        else {
            p = pname.Buffer;
            }
        }
    else {
        p = "System Process";
        }
    SetDlgItemText(
        hwnd,
        PXPLODE_IMAGENAME,
        p
        );

    SetDlgItemInt(
        hwnd,
        PXPLODE_PROCESS_ID,
        (UINT)HandleToUlong(ProcessInfo->UniqueProcessId),
        FALSE
        );

    if ( pname.Buffer ) {
        RtlFreeAnsiString(&pname);
        }

    //
    // Set process priority
    //

    if ( ProcessInfo->BasePriority < 7 ) {
        CheckRadioButton(hwnd,PXPLODE_PRIORITY_IDL,PXPLODE_PRIORITY_HIGH,PXPLODE_PRIORITY_IDL);
        }
    else if ( ProcessInfo->BasePriority < 10 ) {
        CheckRadioButton(hwnd,PXPLODE_PRIORITY_IDL,PXPLODE_PRIORITY_HIGH,PXPLODE_PRIORITY_NORMAL);
        }
    else {
        CheckRadioButton(hwnd,PXPLODE_PRIORITY_IDL,PXPLODE_PRIORITY_HIGH,PXPLODE_PRIORITY_HIGH);
        }

    //
    // Compute address space utilization
    //

    ComputeVaSpace(hwnd,hProcess);

    //
    // Compute runtimes
    //

    RtlTimeToTimeFields ( &ProcessInfo->UserTime, &UserTime);
    RtlTimeToTimeFields ( &ProcessInfo->KernelTime, &KernelTime);

    RtlTimeToTimeFields ( &ProcessInfo->UserTime, &UserTime);
    RtlTimeToTimeFields ( &ProcessInfo->KernelTime, &KernelTime);
    Time.QuadPart = RefreshTimeOfDayInfo.CurrentTime.QuadPart - ProcessInfo->CreateTime.QuadPart;
    RtlTimeToTimeFields ( &Time, &RunTime);
    wsprintf(TimeString,"%3ld:%02ld:%02ld.%03ld",
                RunTime.Hour,
                RunTime.Minute,
                RunTime.Second,
                RunTime.Milliseconds
                );
    SetDlgItemText(
        hwnd,
        PXPLODE_ELAPSED_TIME,
        TimeString
        );

    wsprintf(TimeString,"%3ld:%02ld:%02ld.%03ld",
                UserTime.Hour,
                UserTime.Minute,
                UserTime.Second,
                UserTime.Milliseconds
                );
    SetDlgItemText(
        hwnd,
        PXPLODE_USER_TIME,
        TimeString
        );

    wsprintf(TimeString,"%3ld:%02ld:%02ld.%03ld",
                KernelTime.Hour,
                KernelTime.Minute,
                KernelTime.Second,
                KernelTime.Milliseconds
                );
    SetDlgItemText(
        hwnd,
        PXPLODE_KERNEL_TIME,
        TimeString
        );

    //
    // Set I/O Counts
    //
#if 0
    SetDlgItemInt(
        hwnd,
        PXPLODE_READ_XFER,
        ProcessInfo->ReadTransferCount.LowPart,
        FALSE
        );
    SetDlgItemInt(
        hwnd,
        PXPLODE_WRITE_XFER,
        ProcessInfo->WriteTransferCount.LowPart,
        FALSE
        );
    SetDlgItemInt(
        hwnd,
        PXPLODE_OTHER_XFER,
        ProcessInfo->OtherTransferCount.LowPart,
        FALSE
        );
    SetDlgItemInt(
        hwnd,
        PXPLODE_READ_OPS,
        ProcessInfo->ReadOperationCount,
        FALSE
        );
    SetDlgItemInt(
        hwnd,
        PXPLODE_WRITE_OPS,
        ProcessInfo->WriteOperationCount,
        FALSE
        );
    SetDlgItemInt(
        hwnd,
        PXPLODE_OTHER_OPS,
        ProcessInfo->OtherOperationCount,
        FALSE
        );
#endif
    //
    // Set memory management stats
    //

    wsprintf(szTemp,"%d Kb",ProcessInfo->PeakVirtualSize/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PEAK_VSIZE,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",ProcessInfo->VirtualSize/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_VSIZE,
        szTemp
        );

    SetDlgItemInt(
        hwnd,
        PXPLODE_PFCOUNT,
        ProcessInfo->PageFaultCount,
        FALSE
        );

    wsprintf(szTemp,"%d Kb",(ProcessInfo->PeakWorkingSetSize)/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PEAK_WS,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",(ProcessInfo->WorkingSetSize)/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_WS,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",(ProcessInfo->PeakPagefileUsage)/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PEAK_PF,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",(ProcessInfo->PagefileUsage)/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PF,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",(ProcessInfo->PrivatePageCount)/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PRIVATE_PAGE,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",ProcessInfo->QuotaPeakPagedPoolUsage/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PEAK_PAGED,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",ProcessInfo->QuotaPagedPoolUsage/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PAGED,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",ProcessInfo->QuotaPeakNonPagedPoolUsage/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PEAK_NONPAGED,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",ProcessInfo->QuotaNonPagedPoolUsage/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_NONPAGED,
        szTemp
        );
    wsprintf(szTemp,"%d Kb",ProcessInfo->QuotaPeakPagedPoolUsage/1024);
    SetDlgItemText(
        hwnd,
        PXPLODE_PEAK_PAGED,
        szTemp
        );

    //
    // Get the usage and limits
    //

    {
        NTSTATUS Status;
        POOLED_USAGE_AND_LIMITS PooledInfo;

            Status = NtQueryInformationProcess(
                        hProcess,
                        ProcessPooledUsageAndLimits,
                        &PooledInfo,
                        sizeof(PooledInfo),
                        NULL
                        );
            if ( !NT_SUCCESS(Status) ) {
                RtlZeroMemory(&PooledInfo,sizeof(PooledInfo));
                }
            //
            // non paged
            //

            wsprintf(szTempField,"%d Kb",
                PooledInfo.PeakNonPagedPoolUsage/1024
                );
            SetDlgItemText(
                hwnd,
                PXPLODE_QNONPEAK,
                szTempField
                );


            wsprintf(szTempField,"%d Kb",
                PooledInfo.NonPagedPoolUsage/1024
                );
            SetDlgItemText(
                hwnd,
                PXPLODE_QNONCUR,
                szTempField
                );

            if (PooledInfo.NonPagedPoolLimit != (SIZE_T)-1 ) {
                wsprintf(szTempField,"%d Kb",
                    PooledInfo.NonPagedPoolLimit/1024
                    );
                }
            else {
                strcpy(szTempField,"Unlimited");
                }
            SetDlgItemText(
                hwnd,
                PXPLODE_QNONLIM,
                szTempField
                );


            //
            // paged
            //

            wsprintf(szTempField,"%d Kb",
                PooledInfo.PeakPagedPoolUsage/1024
                );
            SetDlgItemText(
                hwnd,
                PXPLODE_QPGPEAK,
                szTempField
                );

            wsprintf(szTempField,"%d Kb",
                PooledInfo.PagedPoolUsage/1024
                );
            SetDlgItemText(
                hwnd,
                PXPLODE_QPGCUR,
                szTempField
                );

            if (PooledInfo.PagedPoolLimit != (SIZE_T)-1) {
                wsprintf(szTempField,"%d Kb",
                    PooledInfo.PagedPoolLimit/1024
                    );
                }
            else {
                strcpy(szTempField,"Unlimited");
                }
            SetDlgItemText(
                hwnd,
                PXPLODE_QPGLIM,
                szTempField
                );

            //
            // page file
            //

            wsprintf(szTempField,"%d Kb",
                PooledInfo.PeakPagefileUsage*4
                );
            SetDlgItemText(
                hwnd,
                PXPLODE_QPFPEAK,
                szTempField
                );

            wsprintf(szTempField,"%d Kb",
                PooledInfo.PagefileUsage*4
                );
            SetDlgItemText(
                hwnd,
                PXPLODE_QPFCUR,
                szTempField
                );

            if (PooledInfo.PagefileLimit != (SIZE_T)-1) {
                wsprintf(szTempField,"%d Kb",
                    PooledInfo.PagefileLimit*4
                    );
                }
            else {
                strcpy(szTempField,"Unlimited");
                }
            SetDlgItemText(
                hwnd,
                PXPLODE_QPFLIM,
                szTempField
                );
    }
    //
    // Locate the thread list box
    // and clear it
    //

    i = 0;
    ThreadList = GetDlgItem(hwnd, PXPLODE_THREAD_LIST);

//    SendMessage(ThreadList, WM_SETREDRAW, FALSE, 0);
    SendMessage(ThreadList, LB_RESETCONTENT, 0, 0);
    SendMessage(ThreadList, LB_SETITEMDATA, 0L, 0L);

    ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
    while (i < (int)ProcessInfo->NumberOfThreads) {

        wsprintf(szTempField,"%d",
            ThreadInfo->ClientId.UniqueThread
            );

        nIndex = (int)SendMessage(
                        ThreadList,
                        LB_ADDSTRING,
                        0,
                        (LPARAM)(LPSTR)szTempField
                        );
        SendMessage(
            ThreadList,
            LB_SETITEMDATA,
            nIndex,
            (LPARAM)ThreadInfo
            );

        if ( i == 0 ) {
            SetThreadFields(ThreadInfo,hwnd);
            }
        ThreadInfo += 1;
        i += 1;
        }
    SendMessage(ThreadList, LB_SETCURSEL, 0, 0);

    SetDlgItemInt(
        hwnd,
        PXPLODE_THREAD_COUNT,
        ProcessInfo->NumberOfThreads,
        FALSE
        );

    // Redraw the list now that all items have been inserted.

//    SendMessage(ThreadList, WM_SETREDRAW, TRUE, 0);
//    InvalidateRect(ThreadList, NULL, TRUE);

    ProcessList = GetDlgItem(hwnd, PXPLODE_PROCESS_LIST);
    SetFocus(ProcessList);
    if ( hProcess ) {
        CloseHandle(hProcess);
        }

    //
    // If we can't get at the process (maybe it's process 0?)
    // then don't let people try and edit the security on it or it's token.
    //

    hProcess = OpenProcess(MAXIMUM_ALLOWED,FALSE,HandleToUlong(ProcessInfo->UniqueProcessId));
    EnableWindow(GetDlgItem(hwnd, PXPLODE_PROCESS_ACL), hProcess != NULL);
    EnableWindow(GetDlgItem(hwnd, PXPLODE_PROCESS_TOKEN), hProcess != NULL);
    EnableWindow(GetDlgItem(hwnd, PXPLODE_PROCESS_TOKEN_ACL), hProcess != NULL);
    if (hProcess) {
        CloseHandle(hProcess);
    }


}

VOID
SetThreadFields(
    PSYSTEM_THREAD_INFORMATION ThreadInfo,
    HWND hwnd
    )
{
    TIME_FIELDS UserTime;
    TIME_FIELDS KernelTime;
    TIME_FIELDS RunTime;
    LARGE_INTEGER Time;
    CHAR TimeString[15];
    CHAR StartString[32];
    HANDLE hThread;
    CONTEXT ThreadContext;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    ULONG_PTR PcValue;

    //
    // Display the selected thread information
    //

    //
    // Compute runtimes
    //

    RtlTimeToTimeFields ( &ThreadInfo->UserTime, &UserTime);
    RtlTimeToTimeFields ( &ThreadInfo->KernelTime, &KernelTime);

    RtlTimeToTimeFields ( &ThreadInfo->UserTime, &UserTime);
    RtlTimeToTimeFields ( &ThreadInfo->KernelTime, &KernelTime);
    Time.QuadPart = RefreshTimeOfDayInfo.CurrentTime.QuadPart - ThreadInfo->CreateTime.QuadPart;
    RtlTimeToTimeFields ( &Time, &RunTime);
    wsprintf(TimeString,"%3ld:%02ld:%02ld.%03ld",
                RunTime.Hour,
                RunTime.Minute,
                RunTime.Second,
                RunTime.Milliseconds
                );
    SetDlgItemText(
        hwnd,
        PXPLODE_THREADELAPSED_TIME,
        TimeString
        );

    wsprintf(TimeString,"%3ld:%02ld:%02ld.%03ld",
                UserTime.Hour,
                UserTime.Minute,
                UserTime.Second,
                UserTime.Milliseconds
                );
    SetDlgItemText(
        hwnd,
        PXPLODE_THREADUSER_TIME,
        TimeString
        );

    wsprintf(TimeString,"%3ld:%02ld:%02ld.%03ld",
                KernelTime.Hour,
                KernelTime.Minute,
                KernelTime.Second,
                KernelTime.Milliseconds
                );
    SetDlgItemText(
        hwnd,
        PXPLODE_THREADKERNEL_TIME,
        TimeString
        );

    wsprintf(StartString,"0x%p",
                ThreadInfo->StartAddress
                );
    SetDlgItemText(
        hwnd,
        PXPLODE_THREAD_START,
        StartString
        );

    //
    // Do the priority Group
    //

    SetDlgItemInt(
        hwnd,
        PXPLODE_THREAD_DYNAMIC,
        ThreadInfo->Priority,
        FALSE
        );
    switch ( ThreadInfo->BasePriority - DlgProcessInfo->BasePriority ) {

        case 2:
            CheckRadioButton(
                hwnd,
                PXPLODE_THREAD_HIGHEST,
                PXPLODE_THREAD_LOWEST,
                PXPLODE_THREAD_HIGHEST
                );
            break;

        case 1:
            CheckRadioButton(
                hwnd,
                PXPLODE_THREAD_HIGHEST,
                PXPLODE_THREAD_LOWEST,
                PXPLODE_THREAD_ABOVE
                );
            break;

        case -1:
            CheckRadioButton(
                hwnd,
                PXPLODE_THREAD_HIGHEST,
                PXPLODE_THREAD_LOWEST,
                PXPLODE_THREAD_BELOW
                );
            break;
        case -2:
            CheckRadioButton(
                hwnd,
                PXPLODE_THREAD_HIGHEST,
                PXPLODE_THREAD_LOWEST,
                PXPLODE_THREAD_LOWEST
                );
            break;
        case 0:
        default:
            CheckRadioButton(
                hwnd,
                PXPLODE_THREAD_HIGHEST,
                PXPLODE_THREAD_LOWEST,
                PXPLODE_THREAD_NORMAL
                );
            break;
        }
    //
    // Complete thread information
    //

    SetDlgItemInt(
        hwnd,
        PXPLODE_THREAD_SWITCHES,
        ThreadInfo->ContextSwitches,
        FALSE
        );

    PcValue = 0;
    InitializeObjectAttributes(&Obja, NULL, 0, NULL, NULL);
    Status = NtOpenThread(
                &hThread,
                THREAD_GET_CONTEXT,
                &Obja,
                &ThreadInfo->ClientId
                );
    if ( NT_SUCCESS(Status) ) {
        ThreadContext.ContextFlags = CONTEXT_CONTROL;
        Status = NtGetContextThread(hThread,&ThreadContext);
        NtClose(hThread);
        if ( NT_SUCCESS(Status) ) {
            PcValue = (ULONG_PTR) CONTEXT_TO_PROGRAM_COUNTER(&ThreadContext);
            }
        }
    if ( PcValue ) {
        wsprintf(StartString,"0x%p",
                    PcValue
                    );
        SetDlgItemText(
            hwnd,
            PXPLODE_THREAD_PC,
            StartString
            );
        }
    else {
        SetDlgItemText(
            hwnd,
            PXPLODE_THREAD_PC,
            "Unknown"
            );
        }


    //
    // Disable the thread buttons if we can't get at the thread or it's token
    //

    {
        HANDLE Thread;
        HANDLE Token;
        BOOL ThreadOK = FALSE;
        BOOL GotToken = FALSE;

        Thread = OpenThread(MAXIMUM_ALLOWED, FALSE, HandleToUlong(ThreadInfo->ClientId.UniqueThread));
        if (Thread != NULL) {

            ThreadOK = TRUE;

            if (OpenThreadToken(Thread, MAXIMUM_ALLOWED, TRUE, &Token)) {
                GotToken = TRUE;
                CloseHandle(Token);
            }
            CloseHandle(Thread);
        }

        EnableWindow(GetDlgItem(hwnd, PXPLODE_THREAD_ACL), ThreadOK);

        EnableWindow(GetDlgItem(hwnd, PXPLODE_THREAD_TOKEN), GotToken);
        EnableWindow(GetDlgItem(hwnd, PXPLODE_THREAD_TOKEN_ACL), GotToken);
    }
}


VOID
InitProcessList(HWND hwnd)
{
    int nIndex,i,sel;
    HWND ProcessList;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    PSYSTEM_THREAD_INFORMATION ThreadInfo;
    char szTempField[MAXTASKNAMELEN];
    POBJECT_TYPE_INFORMATION ObjectInfo;
    WCHAR Buffer[ 256 ];
    ULONG TotalOffset;
    TIME_FIELDS RefreshTime;
    CHAR TimeString[15];
    PCHAR p;
    ANSI_STRING pname;

    NtQuerySystemInformation(
        SystemTimeOfDayInformation,
        &RefreshTimeOfDayInfo,
        sizeof(SYSTEM_TIMEOFDAY_INFORMATION),
        NULL
        );

    RtlTimeToTimeFields ( &RefreshTimeOfDayInfo.CurrentTime, &RefreshTime);
    wsprintf(TimeString,"%3ld:%02ld:%02ld.%03ld",
                RefreshTime.Hour,
                RefreshTime.Minute,
                RefreshTime.Second,
                RefreshTime.Milliseconds
                );
    SetDlgItemText(
        hwnd,
        PXPLODE_REFRESH_TIME,
        TimeString
        );

    //
    // Compute ObjectCounts
    //

    ObjectInfo = (POBJECT_TYPE_INFORMATION)Buffer;
    NtQueryObject( NtCurrentProcess(),
                   ObjectTypeInformation,
                   ObjectInfo,
                   sizeof( Buffer ),
                   NULL
                 );
    wsprintf(szTempField,"Process Objects    %d",ObjectInfo->TotalNumberOfObjects);
    SetDlgItemText(
        hwnd,
        PXPLODE_PROCESS_OBJECT,
        szTempField
        );

    NtQueryObject( NtCurrentThread(),
                   ObjectTypeInformation,
                   ObjectInfo,
                   sizeof( Buffer ),
                   NULL
                 );
    wsprintf(szTempField,"Thread Objects     %d",ObjectInfo->TotalNumberOfObjects);
    SetDlgItemText(
        hwnd,
        PXPLODE_THREAD_OBJECT,
        szTempField
        );

    NtQueryObject( hEvent,
                   ObjectTypeInformation,
                   ObjectInfo,
                   sizeof( Buffer ),
                   NULL
                 );
    wsprintf(szTempField,"Event  Objects     %d",ObjectInfo->TotalNumberOfObjects);
    SetDlgItemText(
        hwnd,
        PXPLODE_EVENT_OBJECT,
        szTempField
        );

    NtQueryObject( hSemaphore,
                   ObjectTypeInformation,
                   ObjectInfo,
                   sizeof( Buffer ),
                   NULL
                 );
    wsprintf(szTempField,"Semaphore Objects  %d",ObjectInfo->TotalNumberOfObjects);
    SetDlgItemText(
        hwnd,
        PXPLODE_SEMAPHORE_OBJECT,
        szTempField
        );

    NtQueryObject( hMutex,
                   ObjectTypeInformation,
                   ObjectInfo,
                   sizeof( Buffer ),
                   NULL
                 );
    wsprintf(szTempField,"Mutex Objects      %d",ObjectInfo->TotalNumberOfObjects);
    SetDlgItemText(
        hwnd,
        PXPLODE_MUTEX_OBJECT,
        szTempField
        );

    NtQueryObject( hSection,
                   ObjectTypeInformation,
                   ObjectInfo,
                   sizeof( Buffer ),
                   NULL
                 );
    wsprintf(szTempField,"Section Objects    %d",ObjectInfo->TotalNumberOfObjects);
    SetDlgItemText(
        hwnd,
        PXPLODE_SECTION_OBJECT,
        szTempField
        );

    ProcessList = GetDlgItem(hwnd, PXPLODE_PROCESS_LIST);

    // Don't redraw the list as items are deleted/inserted.

//    SendMessage(ProcessList, WM_SETREDRAW, FALSE, 0);
    SendMessage(ProcessList, CB_RESETCONTENT, 0, 0);
    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)g_pLargeBuffer;
    SendMessage(ProcessList, CB_SETITEMDATA, 0L, 0L);
    sel = -1;
    TotalOffset = 0;
    while (TRUE) {

        pname.Buffer = NULL;
        if ( ProcessInfo->ImageName.Buffer ) {
            RtlUnicodeStringToAnsiString(&pname,(PUNICODE_STRING)&ProcessInfo->ImageName,TRUE);
            p = strrchr(pname.Buffer,'\\');
            if ( p ) {
                p++;
                }
            else {
                p = pname.Buffer;
                }
            }
        else {
            p = "System Process";
            }

        wsprintf(szTempField,"%d %s",
            ProcessInfo->UniqueProcessId,
            p
            );

        RtlFreeAnsiString(&pname);
        nIndex = (int)SendMessage(
                        ProcessList,
                        CB_ADDSTRING,
                        0,
                        (LPARAM)(LPSTR)szTempField
                        );
        if ( DlgProcessInfo ) {
            if ( ProcessInfo == DlgProcessInfo ) {
                sel = nIndex;
                }
            }
        else {
            sel = 0;
            }
        SendMessage(
            ProcessList,
            CB_SETITEMDATA,
            nIndex,
            (LPARAM)ProcessInfo
            );

        i = 0;
        ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);
        while (i < (int)ProcessInfo->NumberOfThreads) {
            ThreadInfo += 1;
            i += 1;
            }
        if (ProcessInfo->NextEntryOffset == 0) {
            break;
            }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&g_pLargeBuffer[TotalOffset];
        }
    if ( LastProcess[0] ) {
        nIndex = (int)SendMessage(ProcessList, CB_FINDSTRING, (WPARAM)-1, (LPARAM)LastProcess);
        if ( nIndex != CB_ERR ) {
            sel = nIndex;
            }
        }
    SendMessage(ProcessList, CB_SETCURSEL, sel, 0);
    SendMessage(ProcessList, CB_GETLBTEXT, sel, (LPARAM)LastProcess);

    DlgProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&g_pLargeBuffer[0];
    // Redraw the list now that all items have been inserted.

//    SendMessage(ProcessList, WM_SETREDRAW, TRUE, 0);
//    InvalidateRect(ProcessList, NULL, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pview\tokedit.c ===
/****************************************************************************

   PROGRAM: TOKEDIT.C

   PURPOSE: Displays and allows the user to edit the contents of a token

****************************************************************************/


#include "PVIEWP.h"
#include "string.h"


INT_PTR APIENTRY TokenEditDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY MoreDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL    TokenEditDlgInit(HWND);
BOOL    TokenEditDlgEnd(HWND, BOOL);
BOOL    EnablePrivilege(HWND, BOOL);
BOOL    EnableGroup(HWND, BOOL);
BOOL    SetDefaultOwner(HWND);
BOOL    SetPrimaryGroup(HWND);
BOOL    MoreDlgInit(HWND hDlg, LPARAM lParam);
BOOL    DisplayMyToken(HWND);


/****************************************************************************

    FUNCTION: EditToken

    PURPOSE:  Displays and allows the user to edit a token

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/

BOOL EditToken(
    HWND hwndParent,
    HANDLE Token,
    LPWSTR Name
    )
{
    DLGPROC lpProc;
    int     Result;
    HANDLE  hMyToken;
    HANDLE  Instance;

    hMyToken = OpenMyToken(Token, Name);
    if (hMyToken == NULL) {
        return(FALSE);
    }
    //
    // Get the application instance handle
    //

    Instance = (HANDLE)(NtCurrentPeb()->ImageBaseAddress);
    ASSERT(Instance != 0);

    lpProc = (DLGPROC)MakeProcInstance(TokenEditDlgProc, Instance);
    Result = (int)DialogBoxParam(Instance,(LPSTR)IDD_MAIN, hwndParent, lpProc, (LPARAM)hMyToken);
    FreeProcInstance(lpProc);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: TokenEditDlgProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

    MESSAGES:

    WM_COMMAND     - application menu (About dialog box)
    WM_DESTROY     - destroy window

    COMMENTS:

****************************************************************************/

INT_PTR APIENTRY TokenEditDlgProc(hDlg, message, wParam, lParam)
HWND hDlg;
UINT message;
WPARAM wParam;
LPARAM lParam;
{
    DLGPROC lpProc;
    HANDLE hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (message) {

    case WM_INITDIALOG:

        SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);

        if (!TokenEditDlgInit(hDlg)) {
            // Failed to initialize dialog, get out
            EndDialog(hDlg, FALSE);
        }

        return (TRUE);

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            // we're done, drop through to quit dialog....

        case IDCANCEL:

            TokenEditDlgEnd(hDlg, LOWORD(wParam) == IDOK);

            EndDialog(hDlg, TRUE);
            return TRUE;

        case IDB_DISABLEPRIVILEGE:
        case IDB_ENABLEPRIVILEGE:
            EnablePrivilege(hDlg, LOWORD(wParam) == IDB_ENABLEPRIVILEGE);
            return(TRUE);

        case IDB_DISABLEGROUP:
        case IDB_ENABLEGROUP:
            EnableGroup(hDlg, LOWORD(wParam) == IDB_ENABLEGROUP);
            return(TRUE);

        case IDC_DEFAULTOWNER:
            SetDefaultOwner(hDlg);
            return(TRUE);

        case IDC_PRIMARYGROUP:
            SetPrimaryGroup(hDlg);
            return(TRUE);

        case IDB_MORE:
        {
            HANDLE  Instance = (HANDLE)(NtCurrentPeb()->ImageBaseAddress);

            lpProc = (DLGPROC)MakeProcInstance(MoreDlgProc, Instance);
            DialogBoxParam(Instance,(LPSTR)IDD_MORE, hDlg, lpProc, (LPARAM)hMyToken);
            FreeProcInstance(lpProc);
            return(TRUE);
        }

        case IDB_DEFAULT_DACL:
        {
            HANDLE Token = ((PMYTOKEN)hMyToken)->Token;
            LPWSTR Name = ((PMYTOKEN)hMyToken)->Name;

            EditTokenDefaultDacl(hDlg, Token, Name);
            return(TRUE);
        }


        default:
            // We didn't process this message
            return FALSE;
        }
        break;

    default:
        // We didn't process this message
        return FALSE;

    }

    // We processed the message
    return TRUE;
}


/****************************************************************************

    FUNCTION: TokenEditDlgInit(HWND)

    PURPOSE:  Initialises the controls in the main dialog window.

    RETURNS:   TRUE on success, FALSE if dialog should be terminated.

****************************************************************************/
BOOL TokenEditDlgInit(
    HWND    hDlg
    )
{
    HANDLE hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    WCHAR string[MAX_STRING_LENGTH];
    HCURSOR OldCursor;

    if (!LsaInit()) {
        DbgPrint("PVIEW - LsaInit failed\n");
        return(FALSE);
    }

    OldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    DisplayMyToken(hDlg);
    SetCursor(OldCursor);

    //
    // Set the dialog caption appropriately
    //

    GetWindowTextW(hDlg, string, sizeof(string)/sizeof(*string));
    lstrcatW(string, L" for <");
    lstrcatW(string, ((PMYTOKEN)hMyToken)->Name);
    lstrcatW(string, L">");
    SetWindowTextW(hDlg, string);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: TokenEditDlgEnd(HWND)

    PURPOSE:  Do whatever we have to do to clean up when dialog ends

    RETURNS:  TRUE on success, FALSE on failure.

****************************************************************************/
BOOL TokenEditDlgEnd(
    HWND    hDlg,
    BOOL    fSaveChanges)
{
    HANDLE hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    BOOL Success;

    Success = CloseMyToken(hDlg, hMyToken, fSaveChanges);

    LsaTerminate();

    return(Success);
}


/****************************************************************************

    FUNCTION: DisplayMyToken

    PURPOSE:  Reads data out of mytoken and puts in dialog controls.

    RETURNS:   TRUE on success, FALSE on failure

****************************************************************************/
BOOL DisplayMyToken(
    HWND    hDlg
    )
{
    HANDLE      hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;
    CHAR        string[MAX_STRING_BYTES];
    UINT        GroupIndex;
    UINT        PrivIndex;

    //
    // Groups
    //
    if (pMyToken->Groups != NULL) {

        for (GroupIndex=0; GroupIndex < pMyToken->Groups->GroupCount; GroupIndex++ ) {

            PSID Sid = pMyToken->Groups->Groups[GroupIndex].Sid;
            ULONG Attributes = pMyToken->Groups->Groups[GroupIndex].Attributes;
            USHORT  ControlID;

            if (Attributes & SE_GROUP_ENABLED) {
                ControlID = IDL_ENABLEDGROUPS;
            } else {
                ControlID = IDL_DISABLEDGROUPS;
            }

            if (SID2Name(Sid, string, MAX_STRING_BYTES)) {

                // Add to disable or enabled group box
                AddLBItem(hDlg, ControlID, string, GroupIndex);

                // Add this group to default owner combo box if it's valid
                if (Attributes & SE_GROUP_OWNER) {
                    AddCBItem(hDlg, IDC_DEFAULTOWNER, string, (LPARAM)Sid);
                }

                // Add this group to primary group combo box
                AddCBItem(hDlg, IDC_PRIMARYGROUP, string, (LPARAM)Sid);

            } else {
                DbgPrint("PVIEW: Failed to convert Group sid to string\n");
            }
        }
    } else {
        DbgPrint("PVIEW : No group info in mytoken\n");
    }


    //
    // User ID
    //
    if (pMyToken->UserId != NULL) {

        PSID    Sid = pMyToken->UserId->User.Sid;

        if (SID2Name(Sid, string, MAX_STRING_BYTES)) {

            // Set user-name static text
            SetDlgItemText(hDlg, IDS_USERID, string);

            // Add to default owner combo box
            AddCBItem(hDlg, IDC_DEFAULTOWNER, string, (LPARAM)Sid);

            // Add to primary group combo box
            AddCBItem(hDlg, IDC_PRIMARYGROUP, string, (LPARAM)Sid);

        } else {
            DbgPrint("PVIEW: Failed to convert User ID SID to string\n");
        }

    } else {
        DbgPrint("PVIEW: No user id in mytoken\n");
    }


    //
    // Default Owner
    //
    if (pMyToken->DefaultOwner != NULL) {

        PSID    Sid = pMyToken->DefaultOwner->Owner;

        if (SID2Name(Sid, string, MAX_STRING_BYTES)) {

            INT     iItem;

            iItem = FindCBSid(hDlg, IDC_DEFAULTOWNER, Sid);

            if (iItem >= 0) {
                SendMessage(GetDlgItem(hDlg, IDC_DEFAULTOWNER), CB_SETCURSEL, iItem, 0);
            } else {
                DbgPrint("PVIEW: Default Owner is not userID or one of our groups\n");
            }

        } else {
            DbgPrint("PVIEW: Failed to convert Default Owner SID to string\n");
        }
    } else {
        DbgPrint("PVIEW: No default owner in mytoken\n");
    }


    //
    // Primary group
    //

    if (pMyToken->PrimaryGroup != NULL) {

        PSID    Sid = pMyToken->PrimaryGroup->PrimaryGroup;

        if (SID2Name(Sid, string, MAX_STRING_BYTES)) {
            INT     iItem;

            iItem = FindCBSid(hDlg, IDC_PRIMARYGROUP, Sid);

            if (iItem < 0) {
                // Group is not already in combo-box, add it
                iItem = AddCBItem(hDlg, IDC_PRIMARYGROUP, string, (LPARAM)Sid);
            }

            // Select the primary group
            SendMessage(GetDlgItem(hDlg, IDC_PRIMARYGROUP), CB_SETCURSEL, iItem, 0);

        } else {
            DbgPrint("PVIEW: Failed to convert primary group SID to string\n");
        }
    } else {
        DbgPrint("PVIEW: No primary group in mytoken\n");
    }


    //
    // Privileges
    //

    if (pMyToken->Privileges != NULL) {

        for (PrivIndex=0; PrivIndex < pMyToken->Privileges->PrivilegeCount; PrivIndex++ ) {

            LUID Privilege = pMyToken->Privileges->Privileges[PrivIndex].Luid;
            ULONG Attributes = pMyToken->Privileges->Privileges[PrivIndex].Attributes;
            USHORT  ControlID;

            if (Attributes & SE_PRIVILEGE_ENABLED) {
                ControlID = IDL_ENABLEDPRIVILEGES;
            } else {
                ControlID = IDL_DISABLEDPRIVILEGES;
            }

            if (PRIV2Name(Privilege, string, MAX_STRING_BYTES)) {

                // Add this privelege to the appropriate list-box
                AddLBItem(hDlg, ControlID, string, PrivIndex);

            } else {
                DbgPrint("PVIEW: Failed to convert privilege to string\n");
            }
        }
    } else {
        DbgPrint("PVIEW: No privilege info in mytoken\n");
    }

    return(TRUE);
}


/****************************************************************************

    FUNCTION: EnablePrivilege(HWND, fEnable)

    PURPOSE:  Enables or disables one or more privileges.
              If fEnable = TRUE, the selected privileges in the disabled
              privilege control are enabled.
              Vice versa for fEnable = FALSE

    RETURNS:    TRUE on success, FALSE on failure

****************************************************************************/
BOOL EnablePrivilege(
    HWND    hDlg,
    BOOL    fEnable)
{
    HANDLE  hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    HWND    hwndFrom;
    HWND    hwndTo;
    USHORT  idFrom;
    USHORT  idTo;
    INT     cItems;
    PINT    pItems;
    PTOKEN_PRIVILEGES Privileges;


    Privileges = pMyToken->Privileges;
    if (Privileges == NULL) {
        return(FALSE);
    }

    // Calculate source and destination controls
    //
    if (fEnable) {
        idFrom = IDL_DISABLEDPRIVILEGES;
        idTo   = IDL_ENABLEDPRIVILEGES;
    } else {
        idFrom = IDL_ENABLEDPRIVILEGES;
        idTo   = IDL_DISABLEDPRIVILEGES;
    }
    hwndFrom = GetDlgItem(hDlg, idFrom);
    hwndTo   = GetDlgItem(hDlg, idTo);


    // Find how many items are selected
    //
    cItems = (INT)SendMessage(hwndFrom, LB_GETSELCOUNT, 0, 0);
    if (cItems <= 0) {
        // No items selected
        return(TRUE);
    }

    // Allocate space for the item array
    //
    pItems = Alloc(cItems * sizeof(*pItems));
    if (pItems == NULL) {
        return(FALSE);
    }

    // Read the selected items into the array
    //
    cItems = (INT)SendMessage(hwndFrom, LB_GETSELITEMS, (WPARAM)cItems, (LPARAM)pItems);
    if (cItems == LB_ERR) {
        // Something went wrong
        Free(pItems);
        return(FALSE);
    }


    while (cItems-- > 0) {

        INT     iItem;
        UINT    PrivIndex;
        UCHAR   PrivilegeName[MAX_STRING_BYTES];

        iItem = pItems[cItems];  // Read the item index from the selected item array

        // Read the text and data from the source item
        //
        PrivIndex = (UINT)SendMessage(hwndFrom, LB_GETITEMDATA, iItem, 0);
        SendMessage(hwndFrom, LB_GETTEXT, iItem, (LPARAM)PrivilegeName);


        // Delete item from source control
        //
        SendMessage(hwndFrom, LB_DELETESTRING, iItem, 0);


        // Add privilege to destination control
        //
        iItem = (INT)SendMessage(hwndTo, LB_ADDSTRING, 0, (LPARAM)PrivilegeName);
        SendMessage(hwndTo, LB_SETITEMDATA, iItem, (LPARAM)PrivIndex);


        // Modify global data structure to reflect change
        //
        if (fEnable) {
            Privileges->Privileges[PrivIndex].Attributes |= SE_PRIVILEGE_ENABLED;
        } else {
            Privileges->Privileges[PrivIndex].Attributes &= ~SE_PRIVILEGE_ENABLED;
        }
    }

    // Free up space allocated for selected item array
    Free(pItems);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: EnableGroup(HWND, fEnable)

    PURPOSE:  Enables or disables one or more selected groups.
              If fEnable = TRUE, the selected groups in the disabled
              group control are enabled.
              If fEnable = FALSE the selected groups in the enabled
              group control are disabled.

    RETURNS:    TRUE on success, FALSE on failure

****************************************************************************/
BOOL EnableGroup(
    HWND    hDlg,
    BOOL    fEnable)
{
    HANDLE  hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    HWND    hwndFrom;
    HWND    hwndTo;
    USHORT  idFrom;
    USHORT  idTo;
    INT     cItems;
    PINT    pItems;
    PTOKEN_GROUPS Groups;


    Groups = pMyToken->Groups;
    if (Groups == NULL) {
        return(FALSE);
    }

    // Calculate source and destination controls
    //
    if (fEnable) {
        idFrom = IDL_DISABLEDGROUPS;
        idTo   = IDL_ENABLEDGROUPS;
    } else {
        idFrom = IDL_ENABLEDGROUPS;
        idTo   = IDL_DISABLEDGROUPS;
    }
    hwndFrom = GetDlgItem(hDlg, idFrom);
    hwndTo   = GetDlgItem(hDlg, idTo);

    // Find how many items are selected
    //
    cItems = (INT)SendMessage(hwndFrom, LB_GETSELCOUNT, 0, 0);
    if (cItems <= 0) {
        // No items selected
        return(TRUE);
    }

    // Allocate space for the item array
    //
    pItems = Alloc(cItems * sizeof(*pItems));
    if (pItems == NULL) {
        return(FALSE);
    }

    // Read the selected items into the array
    //
    cItems = (INT)SendMessage(hwndFrom, LB_GETSELITEMS, (WPARAM)cItems, (LPARAM)pItems);
    if (cItems == LB_ERR) {
        // Something went wrong
        Free(pItems);
        return(FALSE);
    }


    while (cItems-- > 0) {

        INT     iItem;
        UINT    GroupIndex;
        UCHAR   GroupName[MAX_STRING_BYTES];

        iItem = pItems[cItems];  // Read the item index from the selected item array

        // Read the text and data from the source item
        //
        GroupIndex = (UINT)SendMessage(hwndFrom, LB_GETITEMDATA, iItem, 0);
        SendMessage(hwndFrom, LB_GETTEXT, iItem, (LPARAM)GroupName);

        // Check it's not a mandatory group (Can-not be disabled)
        //
        if (Groups->Groups[GroupIndex].Attributes & SE_GROUP_MANDATORY) {
            CHAR    buf[256];
            strcpy(buf, "'");
            strcat(buf, GroupName);
            strcat(buf, "' is a mandatory group and cannot be disabled");
            MessageBox(hDlg, buf, NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
            continue;   // skip to next group
        }

        // Delete item from source control
        //
        SendMessage(hwndFrom, LB_DELETESTRING, iItem, 0);


        // Add item to destination control
        //
        iItem = (INT)SendMessage(hwndTo, LB_ADDSTRING, 0, (LPARAM)GroupName);
        SendMessage(hwndTo, LB_SETITEMDATA, iItem, (LONG)GroupIndex);


        // Modify global data structure to reflect change
        //
        if (fEnable) {
            Groups->Groups[GroupIndex].Attributes |= SE_GROUP_ENABLED;
        } else {
            Groups->Groups[GroupIndex].Attributes &= ~SE_GROUP_ENABLED;
        }
    }

    // Free up space allocated for selected item array
    Free(pItems);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: SetDefaultOwner()

    PURPOSE:  Sets the default owner to the new value selected by the user.

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL SetDefaultOwner(
    HWND    hDlg)
{
    HANDLE  hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    HWND    hwnd;
    INT     iItem;
    PTOKEN_OWNER DefaultOwner;


    DefaultOwner = pMyToken->DefaultOwner;
    if (DefaultOwner == NULL) {
        return(FALSE);
    }

    hwnd = GetDlgItem(hDlg, IDC_DEFAULTOWNER);

    iItem = (INT)SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    if (iItem == CB_ERR) {
        // No selection ?
        return(FALSE);
    }

    // Modify global data structure to reflect change
    DefaultOwner->Owner = (PSID)SendMessage(hwnd, CB_GETITEMDATA, iItem, 0);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: SetPrimaryGroup()

    PURPOSE:  Sets the primary group to the new value selected by the user.

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL SetPrimaryGroup(
    HWND    hDlg)
{
    HANDLE  hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    HWND    hwnd;
    INT     iItem;
    PTOKEN_PRIMARY_GROUP PrimaryGroup;


    PrimaryGroup = pMyToken->PrimaryGroup;
    if (PrimaryGroup == NULL) {
        return(FALSE);
    }

    hwnd = GetDlgItem(hDlg, IDC_PRIMARYGROUP);

    iItem = (INT)SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    if (iItem == CB_ERR) {
        // No selection ?
        return(FALSE);
    }

    // Modify global data structure to reflect change
    PrimaryGroup->PrimaryGroup = (PSID)SendMessage(hwnd, CB_GETITEMDATA, iItem, 0);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: MoreDlgProc(HWND, UINT, WPARAM, LPARAM)

    PURPOSE:  Processes messages

****************************************************************************/

INT_PTR APIENTRY MoreDlgProc(hDlg, message, wParam, lParam)
    HWND hDlg;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
{
    HANDLE  hMyToken = (HANDLE)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (message) {

    case WM_INITDIALOG:

        if (!MoreDlgInit(hDlg, lParam)) {
            // Failed to initialize dialog, get out
            EndDialog(hDlg, FALSE);
        }

        return (TRUE);

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:

            // we're done, drop through to quit dialog....

        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            return TRUE;
            break;

        default:
            // We didn't process this message
            return FALSE;
            break;
        }
        break;

    default:
        // We didn't process this message
        return FALSE;

    }

    // We processed the message
    return TRUE;
}


/****************************************************************************

    FUNCTION: MoreDlgInit(HWND)

    PURPOSE:  Initialises the controls in the more dialog window.

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL MoreDlgInit(
    HWND    hDlg,
    LPARAM  lParam
    )
{
    TCHAR string[MAX_STRING_LENGTH];
    HANDLE  hMyToken = (HANDLE)lParam;
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    PTOKEN_STATISTICS Statistics;
    PTOKEN_GROUPS Restrictions ;
    UINT        GroupIndex;


    Statistics = pMyToken->TokenStats;
    if (Statistics == NULL) {
        DbgPrint("PVIEW: No token statistics in mytoken\n");
        return(FALSE);
    }

    wsprintf(string, "0x%lx-%lx",
             pMyToken->TokenStats->AuthenticationId.HighPart,
             pMyToken->TokenStats->AuthenticationId.LowPart);
    SetDlgItemText(hDlg, IDS_LOGONSESSION, string);

    if (LUID2String(Statistics->TokenId, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_TOKENID, string);
    } else {
        DbgPrint("PVIEW: Failed to convert tokenid luid to string\n");
    }

    if (Time2String(Statistics->ExpirationTime, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_EXPIRATIONTIME, string);
    } else {
        DbgPrint("PVIEW: Failed to convert expiration time to string\n");
    }

    if (TokenType2String(Statistics->TokenType, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_TOKENTYPE, string);
    } else {
        DbgPrint("PVIEW: Failed to convert token type to string\n");
    }

    if (Statistics->TokenType == TokenPrimary) {
        SetDlgItemText(hDlg, IDS_IMPERSONATION, "N/A");
    } else {
        if (ImpersonationLevel2String(Statistics->ImpersonationLevel, string, MAX_STRING_BYTES)) {
            SetDlgItemText(hDlg, IDS_IMPERSONATION, string);
        } else {
            DbgPrint("PVIEW: Failed to convert impersonation level to string\n");
        }
    }

    if (Dynamic2String(Statistics->DynamicCharged, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_DYNAMICCHARGED, string);
    } else {
        DbgPrint("PVIEW: Failed to convert dynamic charged to string\n");
    }

    if (Dynamic2String(Statistics->DynamicAvailable, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_DYNAMICAVAILABLE, string);
    } else {
        DbgPrint("PVIEW: Failed to convert dynamic available to string\n");
    }

    if (LUID2String(Statistics->ModifiedId, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_MODIFIEDID, string);
    } else {
        DbgPrint("PVIEW: Failed to convert modifiedid luid to string\n");
    }

    Restrictions = pMyToken->RestrictedSids ;

    if ( Restrictions && (Restrictions->GroupCount) )
    {
        for (GroupIndex=0; GroupIndex < Restrictions->GroupCount; GroupIndex++ ) {

            PSID Sid = Restrictions->Groups[GroupIndex].Sid;
            ULONG Attributes = Restrictions->Groups[GroupIndex].Attributes;

            if (SID2Name(Sid, string, MAX_STRING_BYTES)) {

                // Add to disable or enabled group box
                AddLBItem(hDlg, IDS_RESTRICTEDSIDS, string, GroupIndex);

            } else {
                DbgPrint("PVIEW: Failed to convert Group sid to string\n");
            }

        }
    }
    else
    {
        AddLBItem( hDlg, IDS_RESTRICTEDSIDS, TEXT("None"), 0 );
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pview\util.h ===
PVOID   Alloc(ULONG);
ULONG   GetAllocSize(PVOID);
BOOL    Free(PVOID);

BOOL    LUID2String(LUID, LPSTR, UINT);
BOOL    Time2String(TIME, LPSTR, UINT);
BOOL    TokenType2String(TOKEN_TYPE, LPSTR, UINT);
BOOL    ImpersonationLevel2String(SECURITY_IMPERSONATION_LEVEL, LPSTR, UINT);
BOOL    Dynamic2String(ULONG, LPSTR, UINT);
INT     AddItem(HWND, INT, LPSTR, LPARAM, BOOL);
INT     FindSid(HWND, INT, PSID, BOOL);
BOOL    SetHooks(HWND);
BOOL    ReleaseHooks(HWND);


// Useful macros

#define AddLBItem(hDlg, ControlID, string, data) \
        (AddItem(hDlg, ControlID, string, data, FALSE))

#define AddCBItem(hDlg, ControlID, string, data) \
        (AddItem(hDlg, ControlID, string, data, TRUE))

#define FindLBSid(hDlg, ControlID, data) \
        (FindSid(hDlg, ControlID, data, FALSE))

#define FindCBSid(hDlg, ControlID, data) \
        (FindSid(hDlg, ControlID, data, TRUE))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pview\util.c ===
/****************************************************************************

   PROGRAM: UTIL.C

   PURPOSE: System utility routines

****************************************************************************/

#include "PVIEWP.h"
#include <string.h>


/****************************************************************************

   FUNCTION: Alloc

   PURPOSE: Allocates memory to hold the specified number of bytes

   RETURNS : Pointer to allocated memory or NULL on failure

****************************************************************************/

PVOID Alloc(
    ULONG   Bytes)
{
    HANDLE  hMem;
    PVOID   Buffer;

    hMem = LocalAlloc(LMEM_MOVEABLE, Bytes + sizeof(hMem));

    if (hMem == NULL) {
        return(NULL);
    }

    // Lock down the memory
    //
    Buffer = LocalLock(hMem);
    if (Buffer == NULL) {
        LocalFree(hMem);
        return(NULL);
    }

    //
    // Store the handle at the start of the memory block and return
    // a pointer to just beyond it.
    //

    *((PHANDLE)Buffer) = hMem;

    return (PVOID)(((PHANDLE)Buffer)+1);
}


/****************************************************************************

   FUNCTION:  GetAllocSize

   PURPOSE: Returns the allocated size of the specified memory block.
            The block must have been previously allocated using Alloc

   RETURNS : Size of memory block in bytes or 0 on error

****************************************************************************/

ULONG GetAllocSize(
    PVOID   Buffer)
{
    HANDLE  hMem;

    hMem = *(((PHANDLE)Buffer) - 1);

    return (ULONG)(LocalSize(hMem) - sizeof(hMem));
}


/****************************************************************************

   FUNCTION: Free

   PURPOSE: Frees the memory previously allocated with Alloc

   RETURNS : TRUE on success, otherwise FALSE

****************************************************************************/

BOOL Free(
    PVOID   Buffer)
{
    HANDLE  hMem;

    hMem = *(((PHANDLE)Buffer) - 1);

    LocalUnlock(hMem);

    return(LocalFree(hMem) == NULL);
}


/****************************************************************************

   FUNCTION: LUID2String

   PURPOSE: Converts a LUID into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL LUID2String(
    LUID    Luid,
    LPSTR   String,
    UINT    MaxStringBytes)
{

    if (Luid.HighPart == 0) {
        wsprintf(String, "0x%lx", Luid.LowPart);
    } else {
        wsprintf(String, "0x%lx%08lx", Luid.HighPart, Luid.LowPart);
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: Time2String

   PURPOSE: Converts a time into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL Time2String(
    TIME    Time,
    LPSTR   String,
    UINT    MaxStringBytes)
{
    TIME_FIELDS TimeFields;

    RtlTimeToTimeFields(&Time, &TimeFields);

    if (TimeFields.Year > 2900) {
        strcpy(String, "Never");
    } else {
        wsprintf(String, "%d/%d/%d  %02d:%02d:%02d",
                    TimeFields.Year, TimeFields.Month, TimeFields.Day,
                    TimeFields.Hour, TimeFields.Minute, TimeFields.Second);
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: TokenType2String

   PURPOSE: Converts a tokentype into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL TokenType2String(
    TOKEN_TYPE TokenType,
    LPSTR   String,
    UINT    MaxStringBytes)
{

    switch (TokenType) {

    case TokenPrimary:
        strcpy(String, "Primary");
        break;

    case TokenImpersonation:
        strcpy(String, "Impersonation");
        break;

    default:
        DbgPrint("SECEDIT: TokenType2String fed unrecognised token type : 0x%x\n", TokenType);
        return(FALSE);
        break;
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: ImpersonationLevel2String

   PURPOSE: Converts an impersonation level into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL ImpersonationLevel2String(
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    LPSTR   String,
    UINT    MaxStringBytes)
{

    switch (ImpersonationLevel) {

    case SecurityAnonymous:
        strcpy(String, "Anonymous");
        break;

    case SecurityIdentification:
        strcpy(String, "Identification");
        break;

    case SecurityImpersonation:
        strcpy(String, "Impersonation");
        break;

    case SecurityDelegation:
        strcpy(String, "Delegation");
        break;

    default:
        DbgPrint("SECEDIT: ImpersonationLevel2String fed unrecognised impersonation level : 0x%x\n", ImpersonationLevel);
        return(FALSE);
        break;
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: Dynamic2String

   PURPOSE: Converts an dynamic quota level into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL Dynamic2String(
    ULONG   Dynamic,
    LPSTR   String,
    UINT    MaxStringBytes)
{
    wsprintf(String, "%ld", Dynamic);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: AddItem

    PURPOSE:  Adds the item string and data to the specified control
              The control is assumed to be a list-box unless fCBox == TRUE
              in which case the control is assumed to be a ComboBox

    RETURNS:  Index at which the item was added or < 0 on error

****************************************************************************/
INT AddItem(
    HWND    hDlg,
    INT     ControlID,
    LPSTR   String,
    LPARAM  Data,
    BOOL    fCBox)
{
    HWND    hwnd;
    LRESULT iItem;
    USHORT  AddStringMsg = LB_ADDSTRING;
    USHORT  SetDataMsg = LB_SETITEMDATA;

    if (fCBox) {
        AddStringMsg = CB_ADDSTRING;
        SetDataMsg = CB_SETITEMDATA;
    }

    hwnd = GetDlgItem(hDlg, ControlID);

    iItem = SendMessage(hwnd, AddStringMsg, 0, (LPARAM)String);

    if (iItem >= 0) {
        SendMessage(hwnd, SetDataMsg, iItem, Data);
    }

    return((INT)iItem);
}


/****************************************************************************

    FUNCTION: FindSid

    PURPOSE:  Searches for the specified Sid in a control.

    RETURNS:  Index of matching item or < 0 on error

****************************************************************************/
INT FindSid(
    HWND    hDlg,
    INT     ControlID,
    PSID    Sid,
    BOOL    fCBox)
{
    HWND    hwnd;
    INT     cItems;
    USHORT  GetCountMsg = LB_GETCOUNT;
    USHORT  GetDataMsg = LB_GETITEMDATA;

    if (fCBox) {
        GetCountMsg = CB_GETCOUNT;
        GetDataMsg = CB_GETITEMDATA;
    }

    hwnd = GetDlgItem(hDlg, ControlID);

    cItems = (INT)SendMessage(hwnd, GetCountMsg, 0, 0);

    if (cItems >= 0) {

        INT     iItem;
        PSID    ItemSid;

        for (iItem =0; iItem < cItems; iItem ++) {

            ItemSid = (PSID)SendMessage(hwnd, GetDataMsg, (WPARAM)iItem, 0);
            if (RtlEqualSid(ItemSid, Sid)) {
                return(iItem);
            }
        }
    }

    return(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pview\tokedit.h ===
//
// Function prototypes
//

BOOL EditToken(
    HWND hwndParent,
    HANDLE Token,
    LPWSTR Name
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pview\vastat.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <pviewp.h>
#include <explode.h>

#define DEFAULT_INCR (64*1024)

LIST_ENTRY VaList;

typedef struct _VAINFO {
    LIST_ENTRY Links;
    LIST_ENTRY AllocationBaseHead;
    MEMORY_BASIC_INFORMATION BasicInfo;
} VAINFO, *PVAINFO;

PVAINFO LastAllocationBase;

SIZE_T CommitedBytes;
SIZE_T ReservedBytes;
SIZE_T FreeBytes;
SIZE_T ImageCommitedBytes;
SIZE_T ImageReservedBytes;
SIZE_T ImageFreeBytes;

#define NOACCESS            0
#define READONLY            1
#define READWRITE           2
#define WRITECOPY           3
#define EXECUTE             4
#define EXECUTEREAD         5
#define EXECUTEREADWRITE    6
#define EXECUTEWRITECOPY    7
#define MAXPROTECT          8

ULONG_PTR MappedCommit[MAXPROTECT];
ULONG_PTR PrivateCommit[MAXPROTECT];

typedef struct _MODINFO {
    PVOID BaseAddress;
    SIZE_T VirtualSize;
    ANSI_STRING Name;
    ANSI_STRING FullName;
    ULONG_PTR CommitVector[MAXPROTECT];
} MODINFO, *PMODINFO;
#define MODINFO_SIZE 64
ULONG ModInfoNext;
MODINFO ModInfo[MODINFO_SIZE];
MODINFO TotalModInfo;

PMODINFO
LocateModInfo(
    PVOID Address
    )
{
    int i;
    for (i=0;i<(int)ModInfoNext;i++){
        if ( Address >= ModInfo[i].BaseAddress &&
             Address <= (PVOID)((ULONG_PTR)ModInfo[i].BaseAddress+ModInfo[i].VirtualSize) ) {
            return &ModInfo[i];
            }
        }
    return NULL;
}

VOID
ComputeModInfo(
    HWND hDlg,
    HANDLE Process
    )
{
    PPEB Peb;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION BasicInfo;
    PLDR_DATA_TABLE_ENTRY LdrEntry;
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    PLIST_ENTRY LdrHead,LdrNext;
    PPEB_LDR_DATA Ldr;
    UNICODE_STRING us;
    int i,nIndex;
    HWND ComboList;
    HANDLE hFile;
    HANDLE hMappedFile;
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS FileHeader;
    LPSTR p;
    PVOID MappedAddress;

    for (i=0;i<(int)ModInfoNext;i++){
        if ( ModInfo[i].BaseAddress &&
             ModInfo[i].BaseAddress != (PVOID) (-1) &&
             ModInfo[i].Name.Buffer
             ) {
            RtlFreeAnsiString(&ModInfo[i].Name);
            }
        }
    ModInfoNext = 0;
    RtlZeroMemory(ModInfo,sizeof(ModInfo));
    RtlInitAnsiString(&TotalModInfo.Name," TotalImageCommit");

    ComboList = GetDlgItem(hDlg, PXPLODE_IMAGE_COMMIT);
    SendMessage(ComboList, CB_RESETCONTENT, 0, 0);
    SendMessage(ComboList, CB_SETITEMDATA, 0L, 0L);
    nIndex = (int)SendMessage(
                    ComboList,
                    CB_ADDSTRING,
                    0,
                    (LPARAM)TotalModInfo.Name.Buffer
                    );
    SendMessage(
        ComboList,
        CB_SETITEMDATA,
        nIndex,
        (LPARAM)&TotalModInfo
        );

    Status = NtQueryInformationProcess(
                Process,
                ProcessBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INFO_LENGTH_MISMATCH ) {
            Status = NtQueryInformationProcess(
                        Process,
                        ProcessBasicInformation,
                        &BasicInfo,
                        sizeof(BasicInfo)-4,
                        NULL
                        );
            if ( !NT_SUCCESS(Status) ) {
                return;
                }
            }
        else {
            return;
            }
        }

    Peb = BasicInfo.PebBaseAddress;

    //
    // Ldr = Peb->Ldr
    //

    Status = NtReadVirtualMemory(
                Process,
                &Peb->Ldr,
                &Ldr,
                sizeof(Ldr),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return;
        }

    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    Status = NtReadVirtualMemory(
                Process,
                &LdrHead->Flink,
                &LdrNext,
                sizeof(LdrNext),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return;
        }

    while ( LdrNext != LdrHead ) {
        LdrEntry = CONTAINING_RECORD(LdrNext,LDR_DATA_TABLE_ENTRY,InMemoryOrderLinks);
        Status = NtReadVirtualMemory(
                    Process,
                    LdrEntry,
                    &LdrEntryData,
                    sizeof(LdrEntryData),
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            return;
            }
        ModInfo[ModInfoNext].BaseAddress = LdrEntryData.DllBase;

        us.Length = LdrEntryData.BaseDllName.Length;
        us.MaximumLength = LdrEntryData.BaseDllName.MaximumLength;
        us.Buffer = LocalAlloc(LMEM_ZEROINIT,us.MaximumLength);
        if ( !us.Buffer ) {
            return;
            }
        Status = NtReadVirtualMemory(
                    Process,
                    LdrEntryData.BaseDllName.Buffer,
                    us.Buffer,
                    us.MaximumLength,
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            return;
            }
        RtlUnicodeStringToAnsiString(
            &ModInfo[ModInfoNext].Name,
            &us,
            TRUE
            );
        LocalFree(us.Buffer);

        us.Length = LdrEntryData.FullDllName.Length;
        us.MaximumLength = LdrEntryData.FullDllName.MaximumLength;
        us.Buffer = LocalAlloc(LMEM_ZEROINIT,us.MaximumLength);
        if ( !us.Buffer ) {
            return;
            }
        Status = NtReadVirtualMemory(
                    Process,
                    LdrEntryData.FullDllName.Buffer,
                    us.Buffer,
                    us.MaximumLength,
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            return;
            }
        RtlUnicodeStringToAnsiString(
            &ModInfo[ModInfoNext].FullName,
            &us,
            TRUE
            );
        LocalFree(us.Buffer);

        if ( p = strchr(ModInfo[ModInfoNext].FullName.Buffer,':') ) {
            ModInfo[ModInfoNext].FullName.Buffer = p - 1;
            }

        hFile = CreateFile(
                    ModInfo[ModInfoNext].FullName.Buffer,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
        if ( hFile == INVALID_HANDLE_VALUE ) {
            return;
            }
        hMappedFile = CreateFileMapping(
                        hFile,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );
        CloseHandle(hFile);
        if ( !hMappedFile ) {
            return;
            }
        MappedAddress = MapViewOfFile(
                            hMappedFile,
                            FILE_MAP_READ,
                            0,
                            0,
                            0
                            );

        CloseHandle(hMappedFile);

        if ( !MappedAddress ) {
            UnmapViewOfFile(MappedAddress);
            return;
            }

        DosHeader = (PIMAGE_DOS_HEADER)MappedAddress;

        if ( DosHeader->e_magic != IMAGE_DOS_SIGNATURE ) {
            UnmapViewOfFile(MappedAddress);
            return;
            }

        FileHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)DosHeader + DosHeader->e_lfanew);

        if ( FileHeader->Signature != IMAGE_NT_SIGNATURE ) {
            UnmapViewOfFile(MappedAddress);
            return;
            }
        ModInfo[ModInfoNext].VirtualSize = FileHeader->OptionalHeader.SizeOfImage;
        UnmapViewOfFile(MappedAddress);

        nIndex = (int)SendMessage(
                        ComboList,
                        CB_ADDSTRING,
                        0,
                        (LPARAM)ModInfo[ModInfoNext].Name.Buffer
                        );
        SendMessage(
            ComboList,
            CB_SETITEMDATA,
            nIndex,
            (LPARAM)&ModInfo[ModInfoNext]
            );

        ModInfoNext++;
        ModInfo[ModInfoNext].BaseAddress = (PVOID) (-1);

        LdrNext = LdrEntryData.InMemoryOrderLinks.Flink;
        }
    SendMessage(ComboList, CB_SETCURSEL, 0, 0);
}

ProtectionToIndex(
    ULONG Protection
    )
{
    Protection &= ~PAGE_GUARD;

    switch ( Protection ) {

        case PAGE_NOACCESS:
                return NOACCESS;

        case PAGE_READONLY:
                return READONLY;

        case PAGE_READWRITE:
                return READWRITE;

        case PAGE_WRITECOPY:
                return WRITECOPY;

        case PAGE_EXECUTE:
                return EXECUTE;

        case PAGE_EXECUTE_READ:
                return EXECUTEREAD;

        case PAGE_EXECUTE_READWRITE:
                return EXECUTEREADWRITE;

        case PAGE_EXECUTE_WRITECOPY:
                return EXECUTEWRITECOPY;
        default:
            printf("Unknown Protection 0x%lx\n",Protection);
            return 0;
        }
}

VOID
DumpImageCommit(
    HWND hDlg,
    PULONG_PTR CommitVector
    )
{
    SIZE_T TotalCommitCount;
    ULONG i;
    CHAR szTemp[80];

    TotalCommitCount = 0;
    for ( i=0;i<MAXPROTECT;i++){
        TotalCommitCount += CommitVector[i];
        }

    wsprintf(szTemp,"%d Kb",TotalCommitCount/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_TOTALIMAGE_COMMIT,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[NOACCESS]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_IMAGE_NOACCESS,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[READONLY]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_IMAGE_READONLY,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[READWRITE]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_IMAGE_READWRITE,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[WRITECOPY]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_IMAGE_WRITECOPY,
        szTemp
        );


    wsprintf(szTemp,"%d Kb",
        (CommitVector[EXECUTE] +
            CommitVector[EXECUTEREAD] +
            CommitVector[EXECUTEREADWRITE] +
            CommitVector[EXECUTEWRITECOPY])/1024);

    SetDlgItemText(
        hDlg,
        PXPLODE_IMAGE_EXECUTE,
        szTemp
        );
}

VOID
DumpMappedCommit(
    HWND hDlg,
    PULONG_PTR CommitVector
    )
{
    SIZE_T TotalCommitCount;
    ULONG i;
    CHAR szTemp[80];

    TotalCommitCount = 0;
    for ( i=0;i<MAXPROTECT;i++){
        TotalCommitCount += CommitVector[i];
        }

    wsprintf(szTemp,"%d Kb",TotalCommitCount/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_TOTALMAPPED_COMMIT,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[NOACCESS]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_MAPPED_NOACCESS,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[READONLY]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_MAPPED_READONLY,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[READWRITE]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_MAPPED_READWRITE,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[WRITECOPY]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_MAPPED_WRITECOPY,
        szTemp
        );


    wsprintf(szTemp,"%d Kb",
        (CommitVector[EXECUTE] +
            CommitVector[EXECUTEREAD] +
            CommitVector[EXECUTEREADWRITE] +
            CommitVector[EXECUTEWRITECOPY])/1024);

    SetDlgItemText(
        hDlg,
        PXPLODE_MAPPED_EXECUTE,
        szTemp
        );
}

VOID
DumpPrivateCommit(
    HWND hDlg,
    PULONG_PTR CommitVector
    )
{
    SIZE_T TotalCommitCount;
    ULONG i;
    CHAR szTemp[80];

    TotalCommitCount = 0;
    for ( i=0;i<MAXPROTECT;i++){
        TotalCommitCount += CommitVector[i];
        }

    wsprintf(szTemp,"%d Kb",TotalCommitCount/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_TOTALPRIVATE_COMMIT,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[NOACCESS]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_PRIVATE_NOACCESS,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[READONLY]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_PRIVATE_READONLY,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[READWRITE]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_PRIVATE_READWRITE,
        szTemp
        );

    wsprintf(szTemp,"%d Kb",CommitVector[WRITECOPY]/1024);
    SetDlgItemText(
        hDlg,
        PXPLODE_PRIVATE_WRITECOPY,
        szTemp
        );


    wsprintf(szTemp,"%d Kb",
        (CommitVector[EXECUTE] +
            CommitVector[EXECUTEREAD] +
            CommitVector[EXECUTEREADWRITE] +
            CommitVector[EXECUTEWRITECOPY])/1024);

    SetDlgItemText(
        hDlg,
        PXPLODE_PRIVATE_EXECUTE,
        szTemp
        );
}

VOID
CaptureVaSpace(
    IN HANDLE Process
    )
{

    NTSTATUS Status;
    PVOID BaseAddress;
    PVAINFO VaInfo;
    PMODINFO Mod;
    ULONG_PTR SystemRangeStart;

    Status = NtQuerySystemInformation(SystemRangeStartInformation,
                                      &SystemRangeStart,
                                      sizeof(SystemRangeStart),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        return;
    }

    BaseAddress = NULL;
    LastAllocationBase = NULL;
    InitializeListHead(&VaList);

    VaInfo = LocalAlloc(LMEM_ZEROINIT,sizeof(*VaInfo));
    while ( (ULONG_PTR)BaseAddress < SystemRangeStart ) {
        Status = NtQueryVirtualMemory(
                    Process,
                    BaseAddress,
                    MemoryBasicInformation,
                    &VaInfo->BasicInfo,
                    sizeof(VaInfo->BasicInfo),
                    NULL
                    );
        if ( !NT_SUCCESS(Status) ) {
            LocalFree(VaInfo);
            return;
            }
        else {
            switch (VaInfo->BasicInfo.State ) {

                case MEM_COMMIT :
                    if ( VaInfo->BasicInfo.Type == MEM_IMAGE ) {
                        TotalModInfo.CommitVector[ProtectionToIndex(VaInfo->BasicInfo.Protect)] += VaInfo->BasicInfo.RegionSize;
                        Mod = LocateModInfo(BaseAddress);
                        if ( Mod ) {
                            Mod->CommitVector[ProtectionToIndex(VaInfo->BasicInfo.Protect)] += VaInfo->BasicInfo.RegionSize;
                            }
                        }
                    else {
                        if ( VaInfo->BasicInfo.Type == MEM_MAPPED ) {
                            MappedCommit[ProtectionToIndex(VaInfo->BasicInfo.Protect)] += VaInfo->BasicInfo.RegionSize;
                            }
                        else {
                            PrivateCommit[ProtectionToIndex(VaInfo->BasicInfo.Protect)] += VaInfo->BasicInfo.RegionSize;
                            }
                        }
                    break;
                case MEM_RESERVE :
                    if ( VaInfo->BasicInfo.Type == MEM_IMAGE ) {
                        ImageReservedBytes += VaInfo->BasicInfo.RegionSize;
                        }
                    else {
                        ReservedBytes += VaInfo->BasicInfo.RegionSize;
                        }
                    break;
                case MEM_FREE :
                    if ( VaInfo->BasicInfo.Type == MEM_IMAGE ) {
                        ImageFreeBytes += VaInfo->BasicInfo.RegionSize;
                        }
                    else {
                        FreeBytes += VaInfo->BasicInfo.RegionSize;
                        }
                    break;
                }

            BaseAddress = (PVOID)((ULONG_PTR)BaseAddress + VaInfo->BasicInfo.RegionSize);
        }
    }
}

BOOL
ComputeVaSpace(
    HWND hDlg,
    HANDLE hProcess
    )
{
    memset(TotalModInfo.CommitVector,0,sizeof(TotalModInfo.CommitVector));
    memset(MappedCommit,0,sizeof(MappedCommit));
    memset(PrivateCommit,0,sizeof(PrivateCommit));
    ComputeModInfo(hDlg,hProcess);
    if ( hProcess) {
        CaptureVaSpace(hProcess);
        }
    DumpImageCommit(hDlg,&TotalModInfo.CommitVector[0]);
    DumpMappedCommit(hDlg,MappedCommit);
    DumpPrivateCommit(hDlg,PrivateCommit);
    return TRUE;
}


VOID
UpdateImageCommit(
    HWND hDlg
    )
{
    HWND ComboList;
    int nIndex;
    PMODINFO ModInfo;

    ComboList = GetDlgItem(hDlg, PXPLODE_IMAGE_COMMIT);
    nIndex = (int)SendMessage(ComboList, CB_GETCURSEL, 0, 0);
    ModInfo = (PMODINFO)SendMessage(
                            ComboList,
                            CB_GETITEMDATA,
                            nIndex,
                            0
                            );
    if ( ModInfo ) {
        DumpImageCommit(hDlg,&ModInfo->CommitVector[0]);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pviewer\cntrdata.c ===
/******************************************************************************

                            C O U N T E R   D A T A

    Name:       cntrdata.c

    Description:
        This module contains functions that access counters of an instance
        of object in performance data.

    Functions:
        FirstCounter
        NextCounter
        FindCounter
        CounterData

******************************************************************************/

#include <windows.h>
#include <winperf.h>
#include "perfdata.h"




//*********************************************************************
//
//  FirstCounter
//
//      Find the first counter in pObject.
//
//      Returns a pointer to the first counter.  If pObject is NULL
//      then NULL is returned.
//
PPERF_COUNTER FirstCounter (PPERF_OBJECT pObject)
{
    if (pObject)
        return (PPERF_COUNTER)((PCHAR) pObject + pObject->HeaderLength);
    else
        return NULL;
}




//*********************************************************************
//
//  NextCounter
//
//      Find the next counter of pCounter.
//
//      If pCounter is the last counter of an object type, bogus data
//      maybe returned.  The caller should do the checking.
//
//      Returns a pointer to a counter.  If pCounter is NULL then
//      NULL is returned.
//
PPERF_COUNTER NextCounter (PPERF_COUNTER pCounter)
{
    if (pCounter)
        return (PPERF_COUNTER)((PCHAR) pCounter + pCounter->ByteLength);
    else
        return NULL;
}




//*********************************************************************
//
//  FindCounter
//
//      Find a counter specified by TitleIndex.
//
//      Returns a pointer to the counter.  If counter is not found
//      then NULL is returned.
//
PPERF_COUNTER FindCounter (PPERF_OBJECT pObject, DWORD TitleIndex)
{
PPERF_COUNTER pCounter;
DWORD         i = 0;

    if (pCounter = FirstCounter (pObject))
        while (i < pObject->NumCounters)
            {
            if (pCounter->CounterNameTitleIndex == TitleIndex)
                return pCounter;

            pCounter = NextCounter (pCounter);
            i++;
            }

    return NULL;

}




//*********************************************************************
//
//  CounterData
//
//      Returns counter data for an object instance.  If pInst or pCount
//      is NULL then NULL is returne.
//
PVOID CounterData (PPERF_INSTANCE pInst, PPERF_COUNTER pCount)
{
PPERF_COUNTER_BLOCK pCounterBlock;

    if (pCount && pInst)
        {
        pCounterBlock = (PPERF_COUNTER_BLOCK)((PCHAR)pInst + pInst->ByteLength);
        return (PVOID)((PCHAR)pCounterBlock + pCount->CounterOffset);
        }
    else
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pviewer\instdata.c ===
/******************************************************************************

                            I N S T A N C E   D A T A

    Name:       instdata.c

    Description:
        This module contains functions that access instances of an object
        type in performance data.

    Functions:
        FirstInstance
        NextInstance
        FindInstanceN
        FindInstanceParent
        InstanceName


******************************************************************************/

#include <windows.h>
#include <winperf.h>
#include "perfdata.h"




//*********************************************************************
//
//  FirstInstance
//
//      Returns pointer to the first instance of pObject type.
//      If pObject is NULL then NULL is returned.
//
PPERF_INSTANCE   FirstInstance (PPERF_OBJECT pObject)
{
    if (pObject)
        return (PPERF_INSTANCE)((PCHAR) pObject + pObject->DefinitionLength);
    else
        return NULL;
}




//*********************************************************************
//
//  NextInstance
//
//      Returns pointer to the next instance following pInst.
//
//      If pInst is the last instance, bogus data maybe returned.
//      The caller should do the checking.
//
//      If pInst is NULL, then NULL is returned.
//
PPERF_INSTANCE   NextInstance (PPERF_INSTANCE pInst)
{
PERF_COUNTER_BLOCK *pCounterBlock;

    if (pInst)
        {
        pCounterBlock = (PERF_COUNTER_BLOCK *)((PCHAR) pInst + pInst->ByteLength);
        return (PPERF_INSTANCE)((PCHAR) pCounterBlock + pCounterBlock->ByteLength);
        }
    else
        return NULL;
}




//*********************************************************************
//
//  FindInstanceN
//
//      Returns the Nth instance of pObject type.  If not found, NULL is
//      returned.  0 <= N <= NumInstances.
//

PPERF_INSTANCE FindInstanceN (PPERF_OBJECT pObject, DWORD N)
{
PPERF_INSTANCE pInst;
DWORD          i = 0;

    if (!pObject)
        return NULL;
    else if (N >= (DWORD)(pObject->NumInstances))
        return NULL;
    else
        {
        pInst = FirstInstance (pObject);

        while (i != N)
            {
            pInst = NextInstance (pInst);
            i++;
            }

        return pInst;
        }
}




//*********************************************************************
//
//  FindInstanceParent
//
//      Returns the pointer to an instance that is the parent of pInst.
//
//      If pInst is NULL or the parent object is not found then NULL is
//      returned.
//
PPERF_INSTANCE FindInstanceParent (PPERF_INSTANCE pInst, PPERF_DATA pData)
{
PPERF_OBJECT    pObject;

    if (!pInst)
        return NULL;
    else if (!(pObject = FindObject (pData, pInst->ParentObjectTitleIndex)))
        return NULL;
    else
        return FindInstanceN (pObject, pInst->ParentObjectInstance);
}




//*********************************************************************
//
//  InstanceName
//
//      Returns the name of the pInst.
//
//      If pInst is NULL then NULL is returned.
//
LPTSTR  InstanceName (PPERF_INSTANCE pInst)
{
    if (pInst)
        return (LPTSTR) ((PCHAR) pInst + pInst->NameOffset);
    else
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pviewer\pviewdat.c ===
/******************************************************************************

                            P V I E W   D A T A

    Name:       pviewdat.c

    Description:
        This module collects the data to be displayed in pview.

******************************************************************************/

#include    <windows.h>
#include    <winperf.h>
#include    "perfdata.h"
#include    "pviewdat.h"
#include    "pviewdlg.h"
#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>
#include    <tchar.h>


#define NODATA  TEXT("--------")





void    FormatTimeFields
(double      fTime,
 PTIME_FIELD pTimeFld);

DWORD   PutCounterDWKB
(HWND            hWnd,
 DWORD           dwItemID,
 PPERF_INSTANCE  pInst,
 PPERF_OBJECT    pObj,
 DWORD           dwCounterIdx);

DWORD   PutCounterHEX
(HWND            hWnd,
 DWORD           dwItemID,
 PPERF_INSTANCE  pInst,
 PPERF_OBJECT    pObj,
 DWORD           dwCounterIdx);

DWORD   PutCounterDW
(HWND            hWnd,
 DWORD           dwItemID,
 PPERF_INSTANCE  pInst,
 PPERF_OBJECT    pObj,
 DWORD           dwCounterIdx);

void    PaintAddressSpace
(HWND            hMemDlg,
 PPERF_INSTANCE  pInst,
 PPERF_OBJECT    pObj,
 DWORD           TotalID,
 DWORD           NoAccessID,
 DWORD           NoAccessIndex,
 DWORD           ReadOnlyID,
 DWORD           ReadOnlyIndex,
 DWORD           ReadWriteID,
 DWORD           ReadWriteIndex,
 DWORD           WriteCopyID,
 DWORD           WriteCopyIndex,
 DWORD           ExecuteID,
 DWORD           ExecuteIndex1,
 DWORD           ExecuteIndex2,
 DWORD           ExecuteIndex3,
 DWORD           ExecuteIndex4);

void    PaintMemDlgAddrData
(HWND            hMemDlg,
 PPERF_INSTANCE  pInst,
 PPERF_OBJECT    pObj);

void    PaintMemDlgVMData
(HWND            hMemDlg,
 PPERF_INSTANCE  pInst,
 PPERF_OBJECT    pObj);

void    PaintPviewDlgMemoryData
(HWND            hPviewDlg,
 PPERF_INSTANCE  pInst,
 PPERF_OBJECT    pObj);

void    RefreshMemoryDlgImageList
(HWND            hImageList,
 DWORD           ParentIndex,
 PPERF_OBJECT    pImageObj);

WORD    ProcessPriority
(PPERF_OBJECT    pObject,
 PPERF_INSTANCE  pInstance);

void    SetProcessListText
(PPERF_INSTANCE pInst,
 PPERF_COUNTER  pCPU,
 PPERF_COUNTER  pPRIV,
 PPERF_COUNTER  pProcID,
 double         fTime,
 LPTSTR         str);

void    SetThreadListText
(PPERF_INSTANCE  pInst,
 PPERF_COUNTER   pCPU,
 PPERF_COUNTER   pPRIV,
 double          fTime,
 LPTSTR          str);




//*********************************************************************
//
//      FormatTimeFields
//
//  Formats a double value to time fields.
//
void FormatTimeFields   (double      fTime,
                         PTIME_FIELD pTimeFld)
{
    INT     i;
    double   f;

    f = fTime/3600;

    pTimeFld->Hours = i = (int)f;

    f = f - i;
    pTimeFld->Mins = i = (int)(f = f * 60);

    f = f - i;
    pTimeFld->Secs = i = (int)(f = f * 60);

    f = f - i;
    pTimeFld->mSecs = (int)(f * 1000);
}




//*********************************************************************
//
//      PutCounterDWKB
//
//  Display a DWORD counter's data in KB units.
//
DWORD   PutCounterDWKB (HWND            hWnd,
                        DWORD           dwItemID,
                        PPERF_INSTANCE  pInst,
                        PPERF_OBJECT    pObj,
                        DWORD           dwCounterIdx)
{
    PPERF_COUNTER   pCounter;
    DWORD           *pdwData;
    TCHAR           szTemp[20];

    if (pCounter = FindCounter (pObj, dwCounterIdx)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            wsprintf (szTemp, TEXT("%ld KB"), *pdwData/1024);
            SetDlgItemText (hWnd, dwItemID, szTemp);
            return *pdwData;
        } else {
            return 0;
        }
    } else {
        SetDlgItemText (hWnd, dwItemID, NODATA);
        return 0;
    }
}




//*********************************************************************
//
//      PutCounterHEX
//
//  Display a DWORD counter's data in hex.
//
DWORD   PutCounterHEX  (HWND            hWnd,
                        DWORD           dwItemID,
                        PPERF_INSTANCE  pInst,
                        PPERF_OBJECT    pObj,
                        DWORD           dwCounterIdx)
{
    PPERF_COUNTER   pCounter;
    DWORD           *pdwData;
    TCHAR           szTemp[20];

    if (pCounter = FindCounter (pObj, dwCounterIdx)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            wsprintf (szTemp, TEXT("0x%08x"), *pdwData);
            SetDlgItemText (hWnd, dwItemID, szTemp);
            return *pdwData;
        } else {
            return 0;
        }
    } else {
        SetDlgItemText (hWnd, dwItemID, NODATA);
        return 0;
    }

}




//*********************************************************************
//
//      PutCounterDWKB
//
//  Display a DWORD counter's data.
//
DWORD   PutCounterDW   (HWND            hWnd,
                        DWORD           dwItemID,
                        PPERF_INSTANCE  pInst,
                        PPERF_OBJECT    pObj,
                        DWORD           dwCounterIdx)
{
    PPERF_COUNTER   pCounter;
    DWORD           *pdwData;

    if (pCounter = FindCounter (pObj, dwCounterIdx)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            SetDlgItemInt (hWnd, dwItemID, *pdwData, FALSE);
            return *pdwData;
        } else {
            return 0;
        }
    } else {
        SetDlgItemText (hWnd, dwItemID, NODATA);
        return 0;
    }

}




//*********************************************************************
//
//      PaintAddressSpace
//
//
void    PaintAddressSpace  (HWND            hMemDlg,
                            PPERF_INSTANCE  pInst,
                            PPERF_OBJECT    pObj,
                            DWORD           TotalID,
                            DWORD           NoAccessID,
                            DWORD           NoAccessIndex,
                            DWORD           ReadOnlyID,
                            DWORD           ReadOnlyIndex,
                            DWORD           ReadWriteID,
                            DWORD           ReadWriteIndex,
                            DWORD           WriteCopyID,
                            DWORD           WriteCopyIndex,
                            DWORD           ExecuteID,
                            DWORD           ExecuteIndex1,
                            DWORD           ExecuteIndex2,
                            DWORD           ExecuteIndex3,
                            DWORD           ExecuteIndex4)
{
    PPERF_COUNTER   pCounter;
    DWORD           *pdwData;
    TCHAR           szTemp[20];

    DWORD           dwTotal = 0;
    DWORD           dwExecute = 0;
    BOOL            bCounter = FALSE;


    dwTotal += PutCounterDWKB (hMemDlg, NoAccessID,  pInst, pObj, NoAccessIndex);
    dwTotal += PutCounterDWKB (hMemDlg, ReadOnlyID,  pInst, pObj, ReadOnlyIndex);
    dwTotal += PutCounterDWKB (hMemDlg, ReadWriteID, pInst, pObj, ReadWriteIndex);
    dwTotal += PutCounterDWKB (hMemDlg, WriteCopyID, pInst, pObj, WriteCopyIndex);


    // execute is the sum of the following
    //
    if (pCounter = FindCounter (pObj, ExecuteIndex1)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwTotal += *pdwData;
            dwExecute += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, ExecuteIndex2)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData)