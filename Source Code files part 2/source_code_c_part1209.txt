AGE,
    		    L"insufficient diff area storage detected while calling EndPrepareAllSnapshots. Provider ID = " WSTR_GUID_FMT,
    		    GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
    		ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND,
    		    L"'Object not found' detected in provider call. Provider ID = " WSTR_GUID_FMT,
    		    GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
		else if ( ft.HrFailed() )
			ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
			    L"EndPrepareSnapshots("WSTR_GUID_FMT L")",
			    GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()));

		// Test if an Cancel occured
		TestIfCancelNeeded(ft);
    }
}


void CVssSnapshotSetObject::PreCommitAllSnapshots() throw(HRESULT)
/*++

Routine description:

    Call PreCommitSnapshots for each provider involved in the snapshot set.

Error codes:

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Invalid number of prepared snapshots

    [PreCommitSnapshots() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point then abort
            snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::PreCommitAllSnapshots" );
		
	// On each involved provider, call PreCommitSnapshots for all prepared snapshots.
	for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
	{
		// Pre-commit
		CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->PreCommitSnapshots(
                    CVssGlobalSnapshotSetId::GetID());
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
    		ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND,
    		    L"'Object not found' detected in provider call. Provider ID = " WSTR_GUID_FMT,
    		    GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
		else if ( ft.HrFailed() )
			ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
			    L"PreCommitSnapshots("WSTR_GUID_FMT L")",
			    GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()));
		
		// Test if an Cancel occured
		TestIfCancelNeeded(ft);
    }
}


void CVssSnapshotSetObject::CommitAllSnapshots() throw(HRESULT)
/*++

Routine description:

    Call CommitSnapshots for each provider involved in the snapshot set.

Error codes:

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Invalid number of prepared snapshots

    [CommitSnapshots() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point then abort
            snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::CommitAllSnapshots" );

	// On each involved provider, call CommitSnapshots for all prepared snapshots.
	for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
	{
		// Commit
		CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->CommitSnapshots(
                    CVssGlobalSnapshotSetId::GetID());
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
    		ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND,
    		    L"'Object not found' detected in provider call. Provider ID = " WSTR_GUID_FMT,
    		    GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
		else if ( ft.HrFailed() )
			ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
			    L"CommitSnapshots("WSTR_GUID_FMT L")",
			    GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()));

		// Test if an Cancel occured
		TestIfCancelNeeded(ft);
    }
}


void CVssSnapshotSetObject::PostCommitAllSnapshots() throw (HRESULT)
/*++

Routine description:

    Call PostCommitSnapshots for each provider involved in the snapshot set.

Error codes:

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Invalid number of prepared snapshots

    [PostCommitSnapshots() failures]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point then abort
            snapshot creation process amd throw VSS_E_OBJECT_NOT_FOUND (Bug 227375)

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::PostCommitAllSnapshots" );
		
	// On each involved provider, call PostCommitSnapshots for all committed snapshots.
	for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
	{
		CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);
        ft.hr = pProviderItf->PostCommitSnapshots( CVssGlobalSnapshotSetId::GetID(), m_lSnapshotsCount );
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
    		ft.Throw(VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND,
    		    L"'Object not found' detected in provider call. Provider ID = " WSTR_GUID_FMT,
    		    GUID_PRINTF_ARG(m_mapProviderItfInSnapSet.GetKeyAt(nIndex)));
		else if ( ft.HrFailed() )
			ft.TranslateProviderError( VSSDBG_COORD, m_mapProviderItfInSnapSet.GetKeyAt(nIndex),
			    L"PostCommitSnapshots("WSTR_GUID_FMT L", %ld)",
			    GUID_PRINTF_ARG(CVssGlobalSnapshotSetId::GetID()), m_lSnapshotsCount);

		// Test if an Cancel occured
		TestIfCancelNeeded(ft);
    }
}


void CVssSnapshotSetObject::AbortAllSnapshots()
/*++

Routine description:

    Call AbortSnapshots for each provider involved in the snapshot set.

--*/
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::AbortAllSnapshots" );

    try
    {
	    for(int nIndex = 0; nIndex < m_mapProviderItfInSnapSet.GetSize(); nIndex++ )
	    {
		    CComPtr<IVssSnapshotProvider> pProviderItf = m_mapProviderItfInSnapSet.GetValueAt(nIndex);

		    ft.hr = pProviderItf->AbortSnapshots(CVssGlobalSnapshotSetId::GetID());
		    if (ft.HrFailed())
			    ft.Trace( VSSDBG_COORD, L"AbortSnapshots failed at one writer. hr = 0x%08lx", ft.hr);
	    }
    }
    VSS_STANDARD_CATCH(ft)
}


void CVssSnapshotSetObject::TestIfCancelNeeded(
	IN	CVssFunctionTracer& ft
    ) throw(HRESULT)
{
	if (m_bCancel)
        ft.Throw( VSSDBG_COORD, VSS_S_ASYNC_CANCELLED, L"Cancel detected.");
}


void CVssSnapshotSetObject::OnDeactivate() throw(HRESULT)

/*++

Routine Description:

	Called by CVssProviderManager::Deactivate in order to remove the state of the object.

Warning:

    - The local cache interfaces are not released since are needed in the auto-delete case
    - The Reset function may throw...

Thrown errors:

    E_OUTOFMEMORY.

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::OnDeactivate" );

	// Remove state from the coordinator interface
    // This will release the interfaces also but not completely
    // since a copy is stored in the local cache.
	m_mapProviderItfInSnapSet.RemoveAll();

    // Remove all volumes from the snapshot set.
    m_VolumesList.Reset();

    m_lSnapshotsCount = 0;

   	CVssGlobalSnapshotSetId::ResetID();
	
    m_lCoordState = VSSC_Initialized;
}


void CVssSnapshotSetObject::GetSupportedProviderId(
	IN	LPWSTR wszVolumeName,
    OUT VSS_ID* pProviderId
	) throw(HRESULT)

/*++

Routine Description:

	Called by CVssSnapshotSetObject::AddToSnapshotSet in order to establish the provider
    that will be used for snapshotting this volume

Algorithm:

    for $ProvType in the following order (Hardware, Software, System)
        for $Provider in all providers of type $ProvType
            if ($Provider supports Volume) then
                return the ID of $Provider
    return VSS_E_VOLUME_NOT_SUPPORTED

Remarks:

    We impose no rule for choosing between providers of the same type. The mechanishm of
    choosing is intentionally arbitrarily.

Arguments:
    wszVolumeName - expected to be in the \\\\\?\\Volume{00000000-0000-0000-0000-000000000000}\\ format.

Return values:

    None.

Throws:

    E_OUTOFMEMORY
    E_INVALIDARG
        - if the volume is not in the correct format.
    VSS_E_VOLUME_NOT_SUPPORTED
        - If the given volume is not supported by any provider

    [QuerySupportedProvidersIntoArray() failures]
        E_OUTOFMEMORY

        VSS_E_UNEXPECTED_PROVIDER_ERROR
            Unexpected provider error on calling IsVolumeSupported

        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [GetProviderInterface failures]
            [lockObj failures]
                E_OUTOFMEMORY

            [GetProviderInterfaceInternal() failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.

                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. An error log entry is added describing the error.

                [OnLoad() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.

                [SetContext() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.

        [InitializeAsProvider() failures]
            E_OUTOFMEMORY

        [IVssSnapshotProvider::IsVolumeSupported() failures]
            E_INVALIDARG
                NULL pointers passed as parameters or a volume name in an invalid format.
            E_OUTOFMEMORY
                Out of memory or other system resources
            VSS_E_PROVIDER_VETO
                An error occured while opening the IOCTL channel. The error is logged.
            VSS_E_OBJECT_NOT_FOUND
                If the volume name does not correspond to an existing mount point

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::GetSupportedProviderId" );

    VSS_ID VolumeId;

    // Assert parameters
    BS_ASSERT(pProviderId);
    BS_ASSERT(*pProviderId == GUID_NULL);
    BS_ASSERT(wszVolumeName);

    // Get the volume GUID
    if (!::GetVolumeGuid(wszVolumeName, VolumeId)) {
        // We assert since the check was already done
        BS_ASSERT(false);
        ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"Cannot convert volume name %s to a GUID", wszVolumeName);
    }

    //
    // Get all providers that supports this volume into an array
    //

    // Create the collection object. Initial reference count is 0.
    VSS_OBJECT_PROP_Array* pFilteredProvidersArray = new VSS_OBJECT_PROP_Array;
    if (pFilteredProvidersArray == NULL)
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

    // Get the pointer to the IUnknown interface.
	// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
	// Now pFilteredProvidersArray's reference count becomes 1 (because of the smart pointer).
    CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pFilteredProvidersArray);
    BS_ASSERT(pArrayItf);

    // Insert property structures into the array.
    // Only providers that supports tha volume will be chosen.
	CVssProviderManager::QuerySupportedProvidersIntoArray(
	    GetContextInternal(), false, wszVolumeName, pFilteredProvidersArray );

    //
    //  Search a provider that supports that volume (i.e. from the above list),
    //  in the correct priority order.
    //

    // For each provider type, in the correct priority order
    bool bFound = false;
    for(int nPriority = 0; !bFound && arrProviderTypesOrder[nPriority] ; nPriority++) {

        // Get the current provider type
        VSS_PROVIDER_TYPE nCurrentType = arrProviderTypesOrder[nPriority];

        // For all providers of that type search one that supports the volume
        for(int nIndex = 0; !bFound && (nIndex < pFilteredProvidersArray->GetSize()); nIndex++) {

	        // Get the structure object from the array
	        VSS_OBJECT_PROP_Ptr& ptrProperties = (*pFilteredProvidersArray)[nIndex];

	        // Get the provider structure
            BS_ASSERT(ptrProperties.GetStruct());
	        BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
	        VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;

            // Skip providers with the wrong type
            if (ProviderProp.m_eProviderType != nCurrentType)
                continue;

            // We found a good provider
            (*pProviderId) = ProviderProp.m_ProviderId;
            bFound = true;
        }
    }

    if (!bFound) {
        BS_ASSERT(false); // The "Volume not supported should be detected already by the IsVolumeSupported() call in coord.cxx
        ft.Throw(VSSDBG_COORD, VSS_E_VOLUME_NOT_SUPPORTED, L"Volume %s not supported by any provider", wszVolumeName);
    }
}


/////////////////////////////////////////////////////////////////////////////
// Life-management related methods


STDMETHODIMP CVssSnapshotSetObject::QueryInterface(
	IN	REFIID iid,
	OUT	void** pp
	)
{
    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
	return S_OK;
}


ULONG CVssSnapshotSetObject::AddRef()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::AddRef");
	
    return ::InterlockedIncrement(&m_lRef);
}


ULONG CVssSnapshotSetObject::Release()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::Release");
	
    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        delete this; // We suppose that we always allocate this object on the heap!
    return l;
}


CVssSnapshotSetObject* CVssSnapshotSetObject::CreateInstance() throw(HRESULT)
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::CreateInstance");
	
	CVssSnapshotSetObject* pObj = new CVssSnapshotSetObject;
	if (pObj == NULL)
		ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

	if (FAILED(pObj->FinalConstructInternal()))
		ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Error initializing the object");

	return pObj;
}


HRESULT CVssSnapshotSetObject::FinalConstructInternal()
{
	return S_OK;
}


CVssSnapshotSetObject::CVssSnapshotSetObject():
	m_bCancel(false),
	m_lSnapshotsCount(0),
    m_lCoordState(VSSC_Initialized),
	m_bHasAcquiredSem(false),
	m_lRef(0),
	m_rgWriterInstances(NULL),
	m_cWriterInstances(0)
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnapshotSetObject::CVssSnapshotSetObject");
}


CVssSnapshotSetObject::~CVssSnapshotSetObject()
{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSnapshotSetObject::~CVssSnapshotSetObject");

	try
	{
    	// Release aborts all prepared snapshots
    	Deactivate();

		delete m_rgWriterInstances;

	}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
	    ft.Trace( VSSDBG_COORD, L"Exception catched 0x%08lx", ft.hr);

	if (m_bHasAcquiredSem)
		InterlockedCompareExchange(&g_hSemSnapshotSets, 0, 1);

}


/////////////////////////////////////////////////////////////////////////////
//  CVssGlobalSnapshotSetId


//  Static data members
//

// Global snapshot set Id
VSS_ID CVssGlobalSnapshotSetId::m_SnapshotSetID = GUID_NULL;

// Global lock
CVssCriticalSection  CVssGlobalSnapshotSetId::m_cs;


//  Implementation
//

// Get the current Snasphot set ID
VSS_ID CVssGlobalSnapshotSetId::GetID() throw(HRESULT)
{
    // (Simplify tracing: do not declare a function tracer)

    // Acquire the critical section. This may throw.
    CVssAutomaticLock2 lock(m_cs);

    return m_SnapshotSetID;
}


// Allocate a new Snapshot Set ID
VSS_ID CVssGlobalSnapshotSetId::NewID() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssGlobalSnapshotSetId::NewID" );

    try
    {
        // Acquire the critical section. This may throw.
        CVssAutomaticLock2 lock(m_cs);

        // Create the new Snapshot Set ID
        BS_ASSERT(m_SnapshotSetID == GUID_NULL);
        ft.hr = ::CoCreateGuid( &m_SnapshotSetID );
        if ( ft.HrFailed() )
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr, L"CoCreateGuid" );

        // Broadcast the new snapshot set ID. This may throw.
    	CVssSnasphotSetIdObserver::BroadcastSSID(m_SnapshotSetID);
    }
    VSS_STANDARD_CATCH(ft)

    // Re-throw error, if needed
    if (ft.HrFailed()) {
        m_SnapshotSetID = GUID_NULL;
        ft.Throw( VSSDBG_COORD, ft.hr, L"Re-throw error 0x%08lx", ft.hr);
    }

    // Return the created SSID
    return m_SnapshotSetID;
}


// Clear the current snapshot Set ID
void CVssGlobalSnapshotSetId::ResetID() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssGlobalSnapshotSetId::ResetID" );

    // Acquire the critical section. This may throw.
    CVssAutomaticLock2 lock(m_cs);

    // Set the new Snapshot Set ID
    m_SnapshotSetID = GUID_NULL;
}


// Record the current SSID in the given observer
void CVssGlobalSnapshotSetId::InitializeObserver(
    IN CVssSnasphotSetIdObserver* pObserver
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssGlobalSnapshotSetId::InitializeObserver" );

    // Acquire the critical section. This may throw.
    CVssAutomaticLock2 lock(m_cs);

    // Record the current Snapshot Set ID. This may throw.
    if (m_SnapshotSetID != GUID_NULL)
        pObserver->RecordSSID(m_SnapshotSetID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\provmgr.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module ProvMgr.cxx | Implementation of the CVssProviderManager methods
    @end

Author:

    Adi Oltean  [aoltean]  09/27/1999

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/27/1999  Created
    aoltean     09/09/1999  Adding AddVolumeTointernalList from coord.cxx
    aoltean     09/09/1999  dss -> vss
    aoltean     09/15/1999  Returning only volume names to the writers.
    aoltean     09/21/1999  Rewriting GetProviderProperties in accordance with the new enumerator.
    aoltean     09/22/1999  Add TransferEnumeratorContentsToArray

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "cfgmgr32.h"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "reg_util.hxx"
#include "provmgr.hxx"
#include "softwrp.hxx"
#include "hardwrp.hxx"
#include "vs_reg.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORPRVMC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssProviderManager static members

VSS_OBJECT_PROP_Array* CVssProviderManager::m_pProvidersArray = NULL;
CVssProviderManager* CVssProviderManager::m_pStatefulObjList = NULL;
CVssCriticalSection CVssProviderManager::m_GlobalCS;
CVssCtxSnapshotProviderItfMap CVssProviderManager::m_mapProviderMapGlobalCache;
CVssProviderNotificationsItfMap  CVssProviderManager::m_mapProviderItfOnLoadCache;


/////////////////////////////////////////////////////////////////////////////
//  Query methods



void CVssProviderManager::TransferEnumeratorContentsToArray(
    IN  VSS_ID ProviderId,
    IN  IVssEnumObject* pEnum,
    IN  VSS_OBJECT_PROP_Array* pArray
    )

/*++

Routine Description:

    Append to the array the objects returned by this enumerator

Arguments:

    IN  IVssEnumObject* pEnum,          - The enumerator interface used for query
    IN  VSS_OBJECT_PROP_Array* pArray   - The array that will contain the results
    IN  VSS_ID  ProviderID              - The provider ID (for logging in case of errors)

Throw values:

    E_OUTOFMEMORY

    [InitializeAsEmpty failed]
        E_OUTOFMEMORY

    [IVssEnumObject::Next() failed]
        E_OUTOFMEMORY
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - unexpected provider error when calling Next. An error log entry is added describing the error.
        VSS_E_PROVIDER_VETO
            - provider error when calling Next

Warning:

    The array remains filled partially on error! It is the responsibility of caller to take care.

--*/
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::TransferEnumeratorContentsToArray");

    BS_ASSERT(pEnum);
    BS_ASSERT(pArray);

    ULONG ulFetched;
    VSS_OBJECT_PROP_Ptr ptrObjectProp;
    while (true)
    {
        // Allocate the new structure object, but with zero contents.
        // The internal pointer must not be NULL.
        // WARNING: This might throw E_OUTOFMEMORY
        ptrObjectProp.InitializeAsEmpty(ft);

        // Get the Next object in the newly allocated structure object.
        // This will fill up hte object's type and fields in the union
        // The pointer fields will refer some CoTaskMemAlloc buffers
        // that must be deallocated by us, after the structure is useless.
        VSS_OBJECT_PROP* pProp = ptrObjectProp.GetStruct();
        BS_ASSERT(pProp);
        ft.hr = pEnum->Next(1, pProp, &ulFetched);
        if (ft.hr == S_FALSE) // end of enumeration
        {
            BS_ASSERT(ulFetched == 0);
            break; // This will destroy the last allocated structure in the VSS_OBJECT_PROP_Ptr destructor
        }
        if (ft.HrFailed())
            ft.TranslateProviderError( VSSDBG_COORD, ProviderId, L"IVssEnumObject::Next" );

        // Add the element to the array.
        // If fails then VSS_OBJECT_PROP_Ptr::m_pStruct will be correctly deallocated
        // by the VSS_OBJECT_PROP_Ptr destructor
        if (!pArray->Add(ptrObjectProp))
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot add element to the array");

        // Reset the current pointer to NULL
        ptrObjectProp.Reset(); // The internal pointer was detached into pArray.
    }
}


void CVssProviderManager::QuerySupportedProvidersIntoArray(
    IN      LONG lContext,
    IN      bool bQueryAllProviders,
    IN      VSS_PWSZ pwszVolumeName,
    IN      VSS_OBJECT_PROP_Array* pArray
    )

/*++

Routine Description:

    Fill the array with all providers

Arguments:

    IN      LONG lContext,
    BOOL    bQueryAllProviders         // If false then query only the providers who supports the volume name below.
    VSS_PWSZ    pwszVolumeName      // The volume name that must be checked.
    VSS_OBJECT_PROP_Array* pArray   // where to put the result.

Throws:

    E_OUTOFMEMORY

    VSS_E_UNEXPECTED_PROVIDER_ERROR
        Unexpected provider error on calling IsVolumeSupported

    [lockObj failures]
        E_OUTOFMEMORY

    [LoadInternalProvidersArray() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

    [GetProviderInterface failures]
        [lockObj failures]
            E_OUTOFMEMORY

        [GetProviderInterfaceInternal() failures]
            E_OUTOFMEMORY

            [CoCreateInstance() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - The provider interface couldn't be created. An error log entry is added describing the error.

            [QueryInterface failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. An error log entry is added describing the error.

            [OnLoad() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.
                VSS_E_PROVIDER_VETO
                    - Expected provider error. The provider already did the logging.

            [SetContext() failures]
                VSS_E_UNEXPECTED_PROVIDER_ERROR
                    - Unexpected provider error. The error code is logged into the event log.

    [InitializeAsProvider() failures]
        E_OUTOFMEMORY

    [IVssSnapshotProvider::IsVolumeSupported() failures]
        E_INVALIDARG
            NULL pointers passed as parameters or a volume name in an invalid format.
        E_OUTOFMEMORY
            Out of memory or other system resources
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        VSS_E_OBJECT_NOT_FOUND
            If the volume name does not correspond to an existing mount point

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::QuerySupportedProvidersIntoArray");
    VSS_OBJECT_PROP_Ptr ptrProviderProperties;

    BS_ASSERT(bQueryAllProviders || pwszVolumeName );
    BS_ASSERT(!bQueryAllProviders || !pwszVolumeName );
    BS_ASSERT(pArray);
    BS_ASSERT(IsContextValid(lContext));

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw E_OUTOFMEMORY
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    // Load m_pProvidersArray, if needed.
    LoadInternalProvidersArray();
    BS_ASSERT(m_pProvidersArray);

    // Add elements to the collection
    for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
    {
        // Get the structure object from the array
        VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

        // Get the provider structure
        BS_ASSERT(ptrProperties.GetStruct());
        BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
        VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;

        // Check if we aplying a filter
        if (!bQueryAllProviders)
        {
            // Create the IVssSnapshotProvider interface, if needed
            CComPtr<IVssSnapshotProvider> ptrProvider;
            if (!GetProviderInterface( ProviderProp.m_ProviderId,
                    lContext,
                    ptrProvider,
                    ProviderProp.m_ClassId,
                    ProviderProp.m_eProviderType ))
                continue;

            // Check if the volume is supported by this provider
            BOOL bIsSupported = FALSE;
            BS_ASSERT(ptrProvider);
            ft.hr = ptrProvider->IsVolumeSupported( pwszVolumeName, &bIsSupported );
            if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
                ft.Throw(VSSDBG_COORD,
                    VSS_E_OBJECT_NOT_FOUND, L"Volume % not found", pwszVolumeName);
            if (ft.HrFailed())
                ft.TranslateProviderError( VSSDBG_COORD, ProviderProp.m_ProviderId,
                    L"IVssSnapshotProvider::IsVolumeSupported() failed with 0x%08lx", ft.hr );

            // If the provider does not support this volume then continue the enumeration.
            if (!bIsSupported)
                continue;
        }

        // Build the structure
        // This might throw E_OUTOFMEMORY
        ptrProviderProperties.InitializeAsProvider( ft,
            ProviderProp.m_ProviderId,
            ProviderProp.m_pwszProviderName,
            ProviderProp.m_eProviderType,
            ProviderProp.m_pwszProviderVersion,
            ProviderProp.m_ProviderVersionId,
            ProviderProp.m_ClassId);

        // Insert provider into the array.
        // If fails then ptrProviderProperties::m_pStruct will be correctly deallocated.
        if (!pArray->Add(ptrProviderProperties))
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Cannot add element to the array");

        // Reset the current pointer to NULL since the internal pointer was detached into pArray.
        ptrProviderProperties.Reset();
    }
}


void CVssProviderManager::GetProviderItfArrayInternal(
    IN      LONG lContext,
    OUT     CVssSnapshotProviderItfMap** ppMap
    )
/*++

Routine Description:

    Returns the unfilled provider map associated with that context.

Arguments:

    IN      LONG lContext,
    OUT     CVssSnapshotProviderItfMap* pMap

Throws:

    E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderItfArrayInternal");

    BS_ASSERT(IsContextValid(lContext));
    BS_ASSERT(ppMap);

    (*ppMap) = NULL;

    // If the provider map is not found, create one
    CVssSnapshotProviderItfMap* pMapTmp = m_mapProviderMapGlobalCache.Lookup(lContext);
    if (pMapTmp == NULL)
    {
        // Allocate a new map
        pMapTmp = new CVssSnapshotProviderItfMap;
        if (pMapTmp == NULL)
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

        if (!m_mapProviderMapGlobalCache.Add(lContext, pMapTmp))
        {
            delete pMapTmp;
            ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
        }
    }

    (*ppMap) = pMapTmp;
}


void CVssProviderManager::UnloadGlobalProviderItfCache()
/*++

Routine Description:

    Removes all caches corresponding to global provider interfaces.

--*/
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::UnloadGlobalProviderItfCache");

    for (int nIndex = 0; nIndex < m_mapProviderMapGlobalCache.GetSize(); nIndex++ )
    {
        CVssSnapshotProviderItfMap* pMapTmp = m_mapProviderMapGlobalCache.GetValueAt(nIndex);
        delete pMapTmp;
    }

    m_mapProviderMapGlobalCache.RemoveAll();
}


BOOL CVssProviderManager::GetProviderInterfaceInternal(
    IN CVssSnapshotProviderItfMap& providerItfMap,
    IN VSS_ID ProviderId,
    IN LONG lContext,
    IN CLSID ClassId,
    IN VSS_PROVIDER_TYPE eProviderType,
    OUT CComPtr<IVssSnapshotProvider> &ptrProviderInterface
    )

/*++

Routine Description:

    Create the interface corresponding to this provider ClassId.
    Calls also OnLoad/SetContext on that provider if the interface is obtained for the first time.

    Places the interface in various caches for better usage.

Arguments:

    IN CVssSnapshotProviderItfMap& providerItfMap,
    IN VSS_ID ProviderId,
    IN LONG lContext,
    IN CLSID ClassId,
    OUT CComPtr<IVssSnapshotProvider> &ptrProviderInterface

Returns:
    TRUE - The interface pointer, if we found a provider that accepted the context.
    FALSE - Oterwise. In the OUT parameter we have NULL if the provider does not accept the context.

Throws:

    E_OUTOFMEMORY

    [CoCreateInstance() failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - The provider interface couldn't be created. An error log entry is added describing the error.

    [QueryInterface failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. An error log entry is added describing the error.

    [OnLoad() failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.

    [SetContext() failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderInterfaceInternal");

    // Reset the interface pointer
    ptrProviderInterface = NULL;

    // Use only Babbage provider for Timewarp Multilayer snapshots
    if ((lContext == VSS_CTX_CLIENT_ACCESSIBLE) && (ProviderId != VSS_SWPRV_ProviderId))
        return FALSE;

    //
    // Try to get the cached provider interface.
    // If we found the interface in the map, return it.
    // (it may be NULL, hovewer, if the provider doesn't support the context),
    //

    CComPtr<IVssSnapshotProvider> ptrInternalProviderItf;
    int nItfIndex = providerItfMap.FindKey(ProviderId);
    if (nItfIndex != -1)
    {
        ptrInternalProviderItf = providerItfMap.Lookup(ProviderId);

        // If the provider was found, but does not support that context, return NULL
        if (ptrInternalProviderItf == NULL)
            return FALSE;

        ptrProviderInterface = ptrInternalProviderItf;
        return TRUE;
    }

    //
    // Create the IVssSnapshotProvider interface and set it to the correct context.
    //

    // Get the class ID, if not already provided.
    if (ClassId == GUID_NULL)
    {
        BS_ASSERT(eProviderType == VSS_PROV_UNKNOWN);
        bool bFound = false;

        // Load m_pProvidersArray, if needed.
        LoadInternalProvidersArray();
        BS_ASSERT(m_pProvidersArray);

        for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
        {
            // Get the structure object from the array
            VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

            // Get the provider structure
            BS_ASSERT(ptrProperties.GetStruct());
            BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
            VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;

            // Check if provider was found.
            if (ProviderProp.m_ProviderId != ProviderId)
                continue;

            bFound = true;
            ClassId = ProviderProp.m_ClassId;
            eProviderType = ProviderProp.m_eProviderType;

            // Exit from the loop
            break;
        }

        // Check if we found a provider
        if (!bFound)
            return FALSE;
    }

    // Create the IVssSnapshotProvider instance
    switch(eProviderType)
    {
    case VSS_PROV_SYSTEM:
    case VSS_PROV_SOFTWARE:
        ptrInternalProviderItf.Attach(CVssSoftwareProviderWrapper::CreateInstance(ProviderId, ClassId));
        break;
    case VSS_PROV_HARDWARE:
        ptrInternalProviderItf.Attach(CVssHardwareProviderWrapper::CreateInstance(ProviderId, ClassId));
        break;
    default:
        BS_ASSERT(false);
        ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"Unexpected provider type %d", eProviderType);
    }
    BS_ASSERT(ptrInternalProviderItf);

    // Check if we called OnLoad on that provider and if not, load the provider.
    int nOnLoadIndex = m_mapProviderItfOnLoadCache.FindKey(ProviderId);
    if ( nOnLoadIndex == -1 )
    {
        // Call the OnLoad routine
        ft.hr = ptrInternalProviderItf->OnLoad(NULL);
        if (ft.HrFailed())
            ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"IVssProviderNotifications::OnLoad");

        // If everything is OK then add the interface to the array.
        if (!m_mapProviderItfOnLoadCache.Add(ProviderId, ptrInternalProviderItf))
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");
    }

    //
    //  Check if the provider supports the given context. By default the context is Backup.
    //

    if (lContext == VSS_CTX_BACKUP)
    {
        // The backup context must be supported by all providers. We do not even call SetContext.
        // Add the provider to the proper cache.
        if (!providerItfMap.Add(ProviderId, ptrInternalProviderItf))
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");
    }
    else
    {
        BS_ASSERT(ptrInternalProviderItf);
        ft.hr = ptrInternalProviderItf->SetContext(lContext);

        // If the context is not supported, then return nothing.
        // Do not ask twice the same provider for this context.
        if (ft.hr == VSS_E_UNSUPPORTED_CONTEXT)
        {
            if (!providerItfMap.Add(ProviderId, NULL))
                ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");
            return FALSE;
        }

        // Check for other failures
        if (ft.HrFailed())
            ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"IVssSnapshotProvider::SetContext");

        // The context is supported. Add the provider to the proper cache.
        if (!providerItfMap.Add(ProviderId, ptrInternalProviderItf))
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");
    }

    // Return the interface that we found
    ptrProviderInterface = ptrInternalProviderItf;

    return TRUE;
}


BOOL CVssProviderManager::GetProviderInterface(
    IN      VSS_ID ProviderId,
    IN      LONG lContext,
    OUT     CComPtr<IVssSnapshotProvider> & ptrProviderInterface,
    IN      GUID ClassId, /* = GUID_NULL   */
    IN      VSS_PROVIDER_TYPE eProviderType /* = VSS_PROV_UNKNOWN */
    )

/*++

Routine Description:

    Get the interface corresponding to this provider Id.

Arguments:

    IN      VSS_ID ProviderId,
    IN      LONG lContext,
    OUT     CComPtr<IVssSnapshotProvider> & ptrProviderInterface,
    IN      GUID ClassId = GUID_NULL    // Hint - for optimizing interface creation

Return value:
    TRUE, if provider was found, and it supports that context
    FALSE otherwise.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

    [GetProviderInterfaceInternal() failures]
        E_OUTOFMEMORY

        [CoCreateInstance() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - The provider interface couldn't be created. An error log entry is added describing the error.

        [QueryInterface failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. An error log entry is added describing the error.

        [OnLoad() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.

        [SetContext() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderInterface");

    BS_ASSERT(IsContextValid(lContext));
    BS_ASSERT(ptrProviderInterface == NULL);

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    CVssSnapshotProviderItfMap* pMap = NULL;
    GetProviderItfArrayInternal(lContext, &pMap);
    BS_ASSERT(pMap);

    return GetProviderInterfaceInternal( (*pMap), ProviderId, lContext, ClassId, eProviderType, ptrProviderInterface);
}


BOOL CVssProviderManager::GetProviderInterfaceForSnapshotCreation(
    IN      VSS_ID ProviderId,
    OUT CComPtr<IVssSnapshotProvider> &ptrProviderInterface
    )
/*++

Method:

    CVssProviderManager::GetProviderInterfaceForSnapshotCreation

Description:

    To be called only in AddToSnapshotSet

    This method caches a list of provider interfaces per coordinator instance, named the local cache.
    The list is an associative array ProviderID - interface designed to be used only during the
    snapshot creation protocol.

    This method does not rely on the global Provider interface cached into
    the global Providers array. (i.e. on the "global cache").
    This is because we need to handle "auto-delete" snapshots
    and we link the lifetime of all auto-delete snapshots with the lifetime of the
    originating provider interface. Therefore there might be several provider interfaces with different
    lifetimes.

    Each coordinator object will keep on its own lifetime a list of provider interfaces
    that corresponds to each "used" provider ID. If the coordinator object goes away then
    all used provider interfaces will be released, therefore giving a chance to the provider to
    delete the "auto-delete" snapshots.

Algorithm:

    If a cached interface exists in the current coordinator object then it will be returned. Otherwise
    a new instance will be created, inserted into the local cache and returned.

Info:

    The ref count for the returned interface is at least 2 (one reference in the local cache and another
    which is returned.

Throws:

    VSS_E_PROVIDER_NOT_REGISTERED

    [lockObj failures]
        E_OUTOFMEMORY

    [GetProviderInterfaceInternal() failures]
        E_OUTOFMEMORY

        [CoCreateInstance() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - The provider interface couldn't be created. An error log entry is added describing the error.

        [QueryInterface failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. An error log entry is added describing the error.

        [OnLoad() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.

        [SetContext() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.

--*/
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderInterfaceForSnapshotCreation");

    BS_ASSERT(IsContextValid(m_lContext));
    BS_ASSERT(ptrProviderInterface == NULL);

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    return GetProviderInterfaceInternal( m_mapProviderItfLocalCache,
        ProviderId, m_lContext, GUID_NULL, VSS_PROV_UNKNOWN, ptrProviderInterface);
}


void CVssProviderManager::GetProviderItfArray(
    IN      LONG lContext,
    OUT     CVssSnapshotProviderItfMap** ppMap
    )

/*++

Routine Description:

    Get the array of all provider interfaces

Arguments:

    IN      LONG lContext,
    OUT     CVssSnapshotProviderItfMap** ppMap

Throws:

    E_OUTOFMEMORY

    [lockObj failures]
        E_OUTOFMEMORY

    [LoadInternalProvidersArray() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

    [GetProviderInterfaceInternal() failures]
        E_OUTOFMEMORY

        [CoCreateInstance() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - The provider interface couldn't be created. An error log entry is added describing the error.

        [QueryInterface failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. An error log entry is added describing the error.

        [OnLoad() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.
            VSS_E_PROVIDER_VETO
                - Expected provider error. The provider already did the logging.

        [SetContext() failures]
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - Unexpected provider error. The error code is logged into the event log.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderItfArray");

    BS_ASSERT(ppMap);
    (*ppMap) = NULL;

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    // Load m_pProvidersArray, if needed.
    LoadInternalProvidersArray();
    BS_ASSERT(m_pProvidersArray);

    //
    //  Try to load all provider interfaces for the given map
    //  If we will not succeed, the method will throw.
    //

    // Enumerate through all registered providers
    for (int nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
    {
        // Get the structure object from the array
        VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

        // Get the provider structure
        BS_ASSERT(ptrProperties.GetStruct());
        BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
        VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;

        // Load the interface. Ignore the error code.
        CComPtr<IVssSnapshotProvider> ptrProviderInterface;
        GetProviderInterface( ProviderProp.m_ProviderId,
            lContext,
            ptrProviderInterface,
            ProviderProp.m_ClassId,
            ProviderProp.m_eProviderType );
    }

    // Get the map for the given context.
    // If we reach this point, all provider interfaces were loaded for this context.
    CVssSnapshotProviderItfMap* pMap = NULL;
    GetProviderItfArrayInternal(lContext, &pMap);
    BS_ASSERT(pMap);

    (*ppMap) = pMap;
}


/////////////////////////////////////////////////////////////////////////////
//  Provider array management


void CVssProviderManager::LoadInternalProvidersArray()

/*++

Routine Description:

    Fill the array with all providers, if not initialized

Arguments:


Warnings:

    Each time when you access m_pProvidersArray you should call first this method.

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - error while reading from registry. An error log entry is added describing the error.

    [GetProviderProperties() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::LoadInternalProvidersArray");

    VSS_OBJECT_PROP_Ptr ptrProviderProperties;
    WCHAR       wszKeyName[_MAX_KEYNAME_LEN];
    HKEY        hKeyProviders = NULL;
    FILETIME    time;
    LONG        lRes;

    try
    {
        // The lock should be active now.
        BS_ASSERT(m_GlobalCS.IsLocked());

        // If needed, reconstruct the array from registry.
        if (m_pProvidersArray == NULL)
        {
            // Create the collection object. Initial reference count is 0.
            m_pProvidersArray = new VSS_OBJECT_PROP_Array;
            if (m_pProvidersArray == NULL)
                ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

            // Open the "Providers" key.
            ::wsprintf( wszKeyName, L"%s\\%s", wszVSSKey, wszVSSKeyProviders);
            lRes = ::RegOpenKeyExW(
                HKEY_LOCAL_MACHINE, //  IN HKEY hKey,
                wszKeyName,         //  IN LPCWSTR lpSubKey,
                0,                  //  IN DWORD ulOptions,
                KEY_ALL_ACCESS,     //  IN REGSAM samDesired,
                &hKeyProviders      //  OUT PHKEY phkResult
                );
            if (lRes != ERROR_SUCCESS)
                ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes),
                    L"RegOpenKeyExW(HKLM,%s\\%s,0,KEY_ALL_ACCESS,&ptr)", wszVSSKey, wszVSSKeyProviders );
            BS_ASSERT(hKeyProviders);

            // Add elements to the collection
            bool bLastProviderInEnumeration = false;
            for (DWORD dwIndex = 0; !bLastProviderInEnumeration; dwIndex++)
            {
                // Fill wszKeyName with the name of the subkey
                DWORD dwSize = _MAX_KEYNAME_LEN;
                lRes = ::RegEnumKeyExW(
                    hKeyProviders,      // IN HKEY hKey,
                    dwIndex,            // IN DWORD dwIndex,
                    wszKeyName,         // OUT LPWSTR lpName,
                    &dwSize,            // IN OUT LPDWORD lpcbName,
                    NULL,               // IN LPDWORD lpReserved,
                    NULL,               // IN OUT LPWSTR lpClass,
                    NULL,               // IN OUT LPDWORD lpcbClass,
                    &time);             // OUT PFILETIME lpftLastWriteTime
                switch(lRes)
                {
                case ERROR_SUCCESS:
                    BS_ASSERT(dwSize != 0);

                    // Get the provider properties structure
                    ft.hr = CVssProviderManager::GetProviderProperties(
                                hKeyProviders,
                                wszKeyName,
                                ptrProviderProperties
                                );
                    if (ft.HrFailed())
                    {
                        // Do not throw in case that the registry contain keys with bad format.
                        ft.Warning( VSSDBG_COORD,
                                  L"Error on getting Provider properties for %s. [0x%08lx]",
                                  wszKeyName, ft.hr );
                        BS_ASSERT(ptrProviderProperties.GetStruct() == NULL);
                        break;  // Continue the iteration
                    }
                    BS_ASSERT(ptrProviderProperties.GetStruct());
                    BS_ASSERT(ptrProviderProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);

                    // Insert it into the array.
                    // If fails then ptrProviderProperties::m_pStruct will be correctly deallocated.
                    if (!m_pProvidersArray->Add(ptrProviderProperties))
                        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
                                  L"Cannot add element to the array");

                    // Reset the current pointer to NULL since
                    // the internal pointer was detached into pArray.
                    ptrProviderProperties.Reset();

                    break; // Go to Next key, if not find yet.

                case ERROR_NO_MORE_ITEMS:
                    bLastProviderInEnumeration = true;
                    break; // End of iteration

                default:
                    // RegEnumKeyExW failure
                    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes),
                        L"RegEnumKeyExW(HKLM\\%s\\%s,%s,%d,...)",
                        wszVSSKey, wszVSSKeyProviders, wszKeyName, dwIndex );
                }
            }
        }
        BS_ASSERT(m_pProvidersArray);
    }
    VSS_STANDARD_CATCH(ft)

    // Cleanup resources
    lRes = hKeyProviders? ::RegCloseKey(hKeyProviders): ERROR_SUCCESS;
    if (lRes != ERROR_SUCCESS)
        ft.Trace( VSSDBG_COORD, L"Error closing the hKeyProviders key. [0x%08lx]", GetLastError());

    // If an error occured then throw it outside
    if (ft.HrFailed()) {
        // Unload the array of providers
        UnloadInternalProvidersArray();
        // Throw the corresponding error
        ft.Throw( VSSDBG_COORD, ft.hr, L"Cannot load the internal providers array [0x%08lx]", ft.hr);
    }
}


void CVssProviderManager::UnloadInternalProvidersArray()

/*++

Routine Description:

    Destroy the static array, if exist.
    Call OnUnload for all providers.
    Deallocate all cached provider interface references.

Arguments:

    None.

Caller:

    You should call this method at program termination.

Throws:

    None.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::UnloadInternalProvidersArray");

    try
    {
        // Lock the global critical section for the duration of this block
        // WARNING: This call may throw exceptions!
        CVssAutomaticLock2 lockObj(m_GlobalCS);

        // Unload all loaded providers
        for (int nIndex = 0; nIndex < m_mapProviderItfOnLoadCache.GetSize(); nIndex++)
        {
            // Get the structure object from the array
            CComPtr<IVssSnapshotProvider> ptrNotif =
                m_mapProviderItfOnLoadCache.GetValueAt(nIndex);

            if (ptrNotif)
            {
                ft.hr = ptrNotif->OnUnload(TRUE);
                if (ft.HrFailed())
                    ft.Warning( VSSDBG_COORD,
                              L"Cannot unload load the internal provider");
            }
        }

        // Unload all unused COM server DLLs in this service
        ::CoFreeUnusedLibraries();

        // Release all interfaces
        m_mapProviderItfOnLoadCache.RemoveAll();

        // Delete the provider array.
        if (m_pProvidersArray != NULL)
        {
            // Delete silently the array and all its elements.
            // This will release the provider interfaces too.
            delete m_pProvidersArray;
            m_pProvidersArray = NULL;
        }
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Warning( VSSDBG_COORD, L"Exception catched 0x%08lx", ft.hr);
}


void CVssProviderManager::AddProviderIntoArray(
    IN      VSS_ID ProviderId,
    IN      VSS_PWSZ pwszProviderName,
    IN      VSS_PROVIDER_TYPE eProviderType,
    IN      VSS_PWSZ pwszProviderVersion,
    IN      VSS_ID ProviderVersionId,
    IN      CLSID ClassId
    )

/*++

Routine Description:

    Add that provider to the array. This has nothing to do with the registry.
    The caller is supposed to add the provider to the registry also.

    Called only by the RegisterProvider method.

Arguments:

    VSS_ID ProviderId,              // Id of the provider
    VSS_PWSZ pwszProviderName,
    VSS_PROVIDER_TYPE eProviderType,
    VSS_PWSZ pwszProviderVersion,
    VSS_ID ProviderVersionId,
    CLSID ClassId

Throws:

    E_OUTOFMEMORY

    [lockObj failures] or
    [InitializeAsProvider() failures]
        E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::AddProviderIntoArray");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    if (m_pProvidersArray)
    {
        VSS_OBJECT_PROP_Ptr ptrProviderProperties;
        ptrProviderProperties.InitializeAsProvider( ft,
            ProviderId,
            pwszProviderName,
            eProviderType,
            pwszProviderVersion,
            ProviderVersionId,
            ClassId );

        // Insert it into the array.
        // If fails then ptrProviderProperties::m_pStruct will be correctly deallocated.
        if (!m_pProvidersArray->Add(ptrProviderProperties))
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
                      L"Cannot add element to the array");

        // Reset the current pointer to NULL since
        // the internal pointer was detached into pArray.
        ptrProviderProperties.Reset();
    }
}


bool CVssProviderManager::RemoveProviderFromArray(
    IN      VSS_ID ProviderId
    )

/*++

Routine Description:

    Eliminates the corresponding array element.
    WARNING: Also load, unload and unregister the provider with the given Id.

    Called only by the UnregisterProvider method

Arguments:

    VSS_ID ProviderId           // The provider Id

Return value:

    true - if the provider was sucessfully removed
    false - if there is no provider registered under that ID.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

    [LoadInternalProvidersArray() failures]
        E_OUTOFMEMORY
        E_UNEXPECTED
            - error while reading from registry. An error log entry is added describing the error.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::RemoveProviderFromArray");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    // Load m_pProvidersArray, if needed.
    LoadInternalProvidersArray();
    BS_ASSERT(m_pProvidersArray);

    // Find that provider
    bool bFound = false;
    int nIndex = -1;
    for (nIndex = 0; nIndex < m_pProvidersArray->GetSize(); nIndex++)
    {
        // Get the structure object from the array
        VSS_OBJECT_PROP_Ptr& ptrProperties = (*m_pProvidersArray)[nIndex];

        // Get the provider structure
        BS_ASSERT(ptrProperties.GetStruct());
        BS_ASSERT(ptrProperties.GetStruct()->Type == VSS_OBJECT_PROVIDER);
        VSS_PROVIDER_PROP& ProviderProp = ptrProperties.GetStruct()->Obj.Prov;

        // Check if provider was found.
        if (ProviderProp.m_ProviderId != ProviderId)
            continue;

        // Exit from the loop
        bFound = true;
        break;
    }

    if (bFound)
    {
        // Delete the element from the array.
        m_pProvidersArray->RemoveAt(nIndex);

        // Remove the entries from the caches.
        for (int lContextIdx = 0; lContextIdx < m_mapProviderMapGlobalCache.GetSize(); lContextIdx++)
        {
            // Get the provider cache for this type of context
            CVssSnapshotProviderItfMap* pMap = m_mapProviderMapGlobalCache.GetValueAt(lContextIdx);

            // Remove the associated provider interface.
            if (pMap)
                pMap->Remove(ProviderId);
        }

        // Unload the provider, if loaded
        CComPtr<IVssSnapshotProvider> ptrNotif = m_mapProviderItfOnLoadCache.Lookup(ProviderId);
        if (ptrNotif)
        {
            ft.hr = ptrNotif->OnUnload(TRUE);
            if (ft.HrFailed())
                ft.Warning( VSSDBG_COORD, L"Cannot unload the internal provider with Provider Id"
                    WSTR_GUID_FMT, GUID_PRINTF_ARG(ProviderId));
        }
        m_mapProviderItfOnLoadCache.Remove(ProviderId);

        // Unload all unused COM server DLLs in this service
        ::CoFreeUnusedLibraries();
    }

    return bFound;
}


/////////////////////////////////////////////////////////////////////////////
// CVssProviderManager private methods



HRESULT CVssProviderManager::GetProviderProperties(
    IN  HKEY hKeyProviders,
    IN  LPCWSTR wszProviderKeyName,
    OUT VSS_OBJECT_PROP_Ptr& ptrProviderProperties
    )

/*++

Routine Description:

    Get provider properties from registry.

Arguments:

    IN  HKEY hKeyProviders,                         // The providers Key
    IN  LPCWSTR wszProviderKeyName,                 // The provider Key name (actually a guid)
    OUT VSS_OBJECT_PROP_Ptr& ptrProviderProperties  // will return an allocated structure containing provider properties

Return values:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - on registry failures. An error log entry is added describing the error.

    [QueryStringValue failures] or
    [QueryDWORDValue] failures
        E_OUTOFMEMORY
        E_UNEXPECTED
            - on registry failures. An error log entry is added describing the error.

Throws:

    None.

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::GetProviderProperties");

    HKEY hKeyProvider = NULL;
    HKEY hKeyCLSID = NULL;
    LONG lRes;

    BS_ASSERT( hKeyProviders );
    BS_ASSERT( wszProviderKeyName != NULL && wszProviderKeyName[0] != L'\0' );
    BS_ASSERT( ptrProviderProperties.GetStruct() == NULL );

    try
    {
        // Convert wszProviderKeyName into ProviderId.
        VSS_ID ProviderId;
        ft.hr = ::CLSIDFromString( W2OLE(const_cast<LPWSTR>(wszProviderKeyName)), &ProviderId);
        if (ft.HrFailed())
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr, L"CLSIDFromString(%s)", wszProviderKeyName);

        // Open the provider key
        lRes = ::RegOpenKeyExW(
            hKeyProviders,      //  IN HKEY hKey,
            wszProviderKeyName, //  IN LPCWSTR lpSubKey,
            0,                  //  IN DWORD ulOptions,
            KEY_READ,           //  IN REGSAM samDesired,
            &hKeyProvider       //  OUT PHKEY phkResult
            );
        if (lRes != ERROR_SUCCESS)
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes),
                L"RegOpenKeyExW(hKeyProviders,%s,KEY_READ,...)", wszProviderKeyName);
        BS_ASSERT(hKeyProvider);

        // Get the provider name
        WCHAR wszProviderName[_MAX_VALUE_LEN];
        QueryStringValue( ft,
            hKeyProvider,
            wszProviderKeyName,
            wszVSSProviderValueName,
            _MAX_VALUE_LEN,
            wszProviderName
            );
        BS_ASSERT(wszProviderName[0] != L'\0');

        // Get the provider type
        DWORD dwProviderType = 0;
        QueryDWORDValue( ft,
            hKeyProvider,
            wszProviderKeyName,
            wszVSSProviderValueType,
            &dwProviderType
            );

        VSS_PROVIDER_TYPE eProviderType = VSS_PROV_UNKNOWN;
        switch(dwProviderType) {
        case VSS_PROV_SYSTEM:
        case VSS_PROV_SOFTWARE:
        case VSS_PROV_HARDWARE:
            eProviderType = (VSS_PROVIDER_TYPE) dwProviderType;
            break;
        default:
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes),
                L"QueryDWORDValue(hProvider,%s,%s,%d)",
                wszProviderKeyName,
                wszVSSProviderValueType,
                dwProviderType);
        }

        // Get the provider version string
        WCHAR wszProviderVersion[_MAX_VALUE_LEN];
        QueryStringValue( ft,
            hKeyProvider,
            wszProviderKeyName,
            wszVSSProviderValueVersion,
            _MAX_VALUE_LEN,
            wszProviderVersion
            );

        // Get the provider version Id
        WCHAR wszProviderVersionId[_MAX_VALUE_LEN];
        QueryStringValue( ft,
            hKeyProvider,
            wszProviderKeyName,
            wszVSSProviderValueVersionId,
            _MAX_VALUE_LEN,
            wszProviderVersionId
            );
        BS_ASSERT(wszProviderVersionId[0] != L'\0');

        // Convert wszValueBuffer into ProviderVersionId .
        VSS_ID ProviderVersionId;
        ft.hr = ::CLSIDFromString(W2OLE(wszProviderVersionId), &ProviderVersionId);
        if (ft.HrFailed())
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr,
                L"CLSIDFromString(%s)", wszProviderVersionId);

        // Open the CLSID key of that provider
        lRes = ::RegOpenKeyExW(
            hKeyProvider,           //  IN HKEY hKey,
            wszVSSKeyProviderCLSID, //  IN LPCWSTR lpSubKey,
            0,                      //  IN DWORD ulOptions,
            KEY_ALL_ACCESS,         //  IN REGSAM samDesired,
            &hKeyCLSID              //  OUT PHKEY phkResult
            );
        if (lRes != ERROR_SUCCESS)
            ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes),
                L"CLSIDFromString(%s)", wszProviderVersionId);
        BS_ASSERT(hKeyCLSID);

        // Get the content of the default value
        WCHAR wszClsid[_MAX_VALUE_LEN];
        QueryStringValue( ft,
            hKeyCLSID,
            wszVSSKeyProviderCLSID,
            wszVSSCLSIDValueName,
            _MAX_VALUE_LEN,
            wszClsid
            );
        BS_ASSERT(wszClsid[0] != L'\0');

        // Get the clsid. Remark: if W2OLE fails a SE is thrown
        CLSID ClassId;
        ft.hr = ::CLSIDFromString(W2OLE(wszClsid), &ClassId);
        if (ft.HrFailed())
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr,
                L"CLSIDFromString(%s)", wszClsid);

        // Initialize the Properties pointer. If an error occurs an exception is thrown.
        ptrProviderProperties.InitializeAsProvider(ft,
            ProviderId,
            wszProviderName,
            eProviderType,
            wszProviderVersion,
            ProviderVersionId,
            ClassId);
    }
    VSS_STANDARD_CATCH(ft)

    // Cleanup resources
    lRes = hKeyProvider? ::RegCloseKey(hKeyProvider): ERROR_SUCCESS;
    if (lRes != ERROR_SUCCESS)
        ft.Trace(VSSDBG_COORD, L"Error closing the hKeyProvider key. [0x%08lx]", GetLastError());

    lRes = hKeyCLSID? ::RegCloseKey(hKeyCLSID): ERROR_SUCCESS;
    if (lRes != ERROR_SUCCESS)
        ft.Trace(VSSDBG_COORD, L"Error closing the hKeyCLSID key. [0x%08lx]", GetLastError());

    // If something went wrong, the out must be NULL.
    if (ft.HrFailed()) {
        BS_ASSERT( ptrProviderProperties.GetStruct() == NULL );
    }

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
//  Local state management


void CVssProviderManager::Activate() throw(HRESULT)

/*++

Routine Description:

    Mark the current object as stateful.

    The concrete case the current object is a coordinator interface. This interface have no state
    in the moment when StartSnapshotSet is called. After that the state will contain the
    snapshot set Id, the list of involved snapshots (providers), etc.

    When DoSnapshotSet is called then the state is lost and the object must be taken out from the
    global list of stategful objects.

    This whole thing is done to allow AbortAllSnapshotsInProgress to take action on all objects.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::Activate");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    if (!m_bHasState)
    {
        m_pNext = m_pPrev = NULL; // for safety

        if (m_pStatefulObjList != NULL)
        {
            BS_ASSERT(m_pStatefulObjList->m_pPrev == NULL);
            m_pStatefulObjList->m_pPrev = this;
        }
        m_pNext = m_pStatefulObjList;
        m_pStatefulObjList = this;
        m_bHasState = true;
    }
}


void CVssProviderManager::Deactivate() throw(HRESULT)

/*++

Routine Description:

    Mark the current object as stateless.

    The concrete case the current object is a coordinator interface. This interface have no state
    in the moment when StartSnapshotSet is called. After that the state will contain the
    snapshot set Id, the list of involved snapshots (providers), etc.

    When DoSnapshotSet is called then the state is lost and the object must be taken out from the
    global list of stategful objects.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::Deactivate");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    if (m_bHasState)
    {
        if (m_pPrev != NULL) // we are in the middle
            m_pPrev->m_pNext = m_pNext;
        else // we are the first
        {
            BS_ASSERT(m_pStatefulObjList == this);
            m_pStatefulObjList = m_pNext;
        }

        if (m_pNext != NULL)
            m_pNext->m_pPrev = m_pPrev;

        m_pNext = m_pPrev = NULL;
        m_bHasState = false;

        // Warning: this call may throw errors!
        OnDeactivate();
    }
}


void CVssProviderManager::DeactivateAll()

/*++

Routine Description:

    Deactivate all activated objects.

Throws:

    [lockObj failures]
        E_OUTOFMEMORY

    [OnDeactivate failures]
        TBD

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::DeactivateAll");

    // Lock the global critical section for the duration of this block
    // WARNING: This call may throw exceptions!
    CVssAutomaticLock2 lockObj(m_GlobalCS);

    while (m_pStatefulObjList)
    {
        CVssProviderManager* pFirstObj = m_pStatefulObjList;

        BS_ASSERT(pFirstObj->m_bHasState);
        pFirstObj->m_bHasState = false;

        BS_ASSERT(pFirstObj->m_pPrev == NULL);
        m_pStatefulObjList = pFirstObj->m_pNext;

        if (pFirstObj->m_pNext != NULL)
        {
            BS_ASSERT(pFirstObj->m_pNext->m_pPrev == pFirstObj);
            pFirstObj->m_pNext->m_pPrev = NULL;

            pFirstObj->m_pNext = NULL;
        }

        pFirstObj->OnDeactivate();
    }
}


bool CVssProviderManager::AreThereStatefulObjects()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::AreThereStatefulObjects");

    return (m_pStatefulObjList != NULL);
};


/////////////////////////////////////////////////////////////////////////////
//  Context-related routines


LONG CVssProviderManager::GetContextInternal()

/*++

Method:

    CVssProviderManager::GetContextInternal

Description:

    Returns the existing context

--*/

{
    BS_ASSERT(IsContextValid(m_lContext));

    return m_lContext;
}


bool CVssProviderManager::IsContextValid(
    IN  LONG lContext
    )

/*++

Method:

    CVssProviderManager::IsContextValid

Description:

    Returns the existing context

--*/

{
    if (lContext == VSS_CTX_ALL)
        return true;

    lContext &= ~(VSS_VOLSNAP_ATTR_TRANSPORTABLE);
    return (lContext == VSS_CTX_BACKUP) ||
           (lContext == VSS_CTX_CLIENT_ACCESSIBLE) ||
           (lContext == VSS_CTX_PERSISTENT_CLIENT_ACCESSIBLE) ||
           (lContext == VSS_CTX_APP_ROLLBACK) ||
           (lContext == VSS_CTX_NAS_ROLLBACK) ||
           (lContext == VSS_CTX_FILE_SHARE_BACKUP);
}


void CVssProviderManager::SetContextInternal(
    IN      LONG lContext
    )

/*++

Method:

    CVssProviderManager::SetContext

Description:

    Called only once to set the context for the snapshot creation process

--*/

{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::SetContextInternal");

    BS_ASSERT(m_lContext == VSS_CTX_BACKUP);
    BS_ASSERT(IsContextValid(lContext));

    if (m_lContext == VSS_CTX_BACKUP)
        m_lContext = lContext;
}



/////////////////////////////////////////////////////////////////////////////
//  Constructors and destructors


CVssProviderManager::~CVssProviderManager()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssProviderManager::~CVssProviderManager");

    BS_ASSERT((m_pNext == NULL) && (m_pPrev == NULL) && !m_bHasState );

    // The local cache interfaces must be automatically released
    // Here the auto-delete snapshots are deleted.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\vssqlwrt.cpp ===
/*++
Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module VsSqlWr.cpp | Implementation of Sql Writer wrapper class used by the coordinator
    @end

Author:

    Brian Berkowitz  [brianb]  04/18/2000

TBD:
	
	Add comments.

Revision History:

	
    Name        Date        Comments
    brianb     04/18/2000   Created
	brianb	   04/20/2000   integrated with coordinator
	brianb	   05/10/2000   make sure registration thread does CoUninitialize

--*/
#include <stdafx.hxx>
#include "vs_inc.hxx"
#include "vs_idl.hxx"


#include <vswriter.h>
#include <sqlsnap.h>
#include <sqlwriter.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSQLWC"
//
////////////////////////////////////////////////////////////////////////


__declspec(dllexport)
CVssSqlWriterWrapper::CVssSqlWriterWrapper() :
	m_pSqlWriter(NULL)
	{
	}

DWORD CVssSqlWriterWrapper::InitializeThreadFunc(VOID *pv)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSqlWriterWrapper::InitializeThreadFunc");

	CVssSqlWriterWrapper *pWrapper = (CVssSqlWriterWrapper *) pv;

	BOOL fCoinitializeSucceeded = false;

	try
		{
		// intialize MTA thread
		ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		if (ft.HrFailed())
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"CoInitializeEx failed 0x%08lx", ft.hr
				);

        fCoinitializeSucceeded = true;

		ft.hr = pWrapper->m_pSqlWriter->Initialize();
		}
	VSS_STANDARD_CATCH(ft)

	if (fCoinitializeSucceeded)
		CoUninitialize();

	pWrapper->m_hrInitialize = ft.hr;
	return 0;
	}



__declspec(dllexport)
HRESULT CVssSqlWriterWrapper::CreateSqlWriter()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssSqlWriterWrapper::CreateSqlWriter");

	if (m_pSqlWriter)
		return S_OK;

	try
		{
		m_pSqlWriter = new CSqlWriter;
		if (m_pSqlWriter == NULL)
			ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Allocation of CSqlWriter object failed.");

		DWORD tid;

		HANDLE hThread = CreateThread
							(
							NULL,
							256* 1024,
							CVssSqlWriterWrapper::InitializeThreadFunc,
							this,
							0,
							&tid
							);

		if (hThread == NULL)
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"CreateThread failed with error %d",
				GetLastError()
				);

		// wait for thread to complete
        WaitForSingleObject(hThread, INFINITE);
		CloseHandle(hThread);
		ft.hr = m_hrInitialize;
		}
	VSS_STANDARD_CATCH(ft)
	if (ft.HrFailed() && m_pSqlWriter)
		{
		delete m_pSqlWriter;
		m_pSqlWriter = NULL;
		}

	return ft.hr;
	}

__declspec(dllexport)
void CVssSqlWriterWrapper::DestroySqlWriter()
	{
	if (m_pSqlWriter)
		{
		m_pSqlWriter->Uninitialize();
		delete m_pSqlWriter;
		m_pSqlWriter = NULL;
		}
	}


__declspec(dllexport)
CVssSqlWriterWrapper::~CVssSqlWriterWrapper()
	{
	DestroySqlWriter();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\query.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Query.cxx | Implementation of Query methods in coordinator interfaces
    @end

Author:

    Adi Oltean  [aoltean]  09/03/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/03/1999  Created
    aoltean     09/09/1999  Adding Query from coord.cxx
                            dss -> vss
	aoltean		09/20/1999	Simplify memory management
	aoltean		09/21/1999	Converting to the new enumerator
	aoltean		09/22/1999  Making the first branch of Query working
	aoltean		09/27/1999	Provider-generic code

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "provmgr.hxx"
#include "admin.hxx"
#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "vs_sec.hxx"
#include "shim.hxx"
#include "coord.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORQRYC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  QueryXXXX methods


STDMETHODIMP CVssCoordinator::Query(
    IN      VSS_ID          QueriedObjectId,
    IN      VSS_OBJECT_TYPE eQueriedObjectType,
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,
    OUT     IVssEnumObject**ppEnum
    )

/*++

Routine Description:

    Implements the IVssCoordinator::Query method

Arguments:

    IN      VSS_ID          QueriedObjectId,
    IN      VSS_OBJECT_TYPE eQueriedObjectType,
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,
    OUT     IVssEnumObject**ppEnum

Return values:

    E_ACCESSDENIED
        - The user is not a backup operator or an administrator
    E_OUTOFMEMORY
    E_INVALIDARG 
        - Invalid arguments
    VSS_E_OBJECT_NOT_FOUND
        - Queried object not found.
    E_UNEXPECTED
        - CVssEnumFromArray::Init failures
        - QueryInterface(IID_IVssEnumObject,...) failures

    [CVssProviderManager::TransferEnumeratorContentsToArray() failures]
        E_OUTOFMEMORY

        [InitializeAsEmpty failed] 
            E_OUTOFMEMORY
        
        [IVssEnumObject::Next() failed]
            E_OUTOFMEMORY
            VSS_E_UNEXPECTED_PROVIDER_ERROR
                - unexpected provider error when calling Next. An error log entry is added describing the error.
            VSS_E_PROVIDER_VETO
                - provider error when calling Next

    [IVssSnapshotProvider::Query failures]
        VSS_E_UNEXPECTED_PROVIDER_ERROR
            - Unexpected provider error. The error code is logged into the event log.
        VSS_E_PROVIDER_VETO
            - Expected provider error. The provider already did the logging.

    [QuerySupportedProvidersIntoArray() failures]
        E_OUTOFMEMORY

        VSS_E_UNEXPECTED_PROVIDER_ERROR
            Unexpected provider error on calling IsVolumeSupported
            
        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [GetProviderInterface failures]
            [lockObj failures]
                E_OUTOFMEMORY
            
            [GetProviderInterfaceInternal() failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.
                
                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. An error log entry is added describing the error.

                [OnLoad() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.
                
                [SetContext() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.

        [InitializeAsProvider() failures]
            E_OUTOFMEMORY

        [IVssSnapshotProvider::IsVolumeSupported() failures]
            E_INVALIDARG
                NULL pointers passed as parameters or a volume name in an invalid format.
            E_OUTOFMEMORY
                Out of memory or other system resources           
            VSS_E_PROVIDER_VETO
                An error occured while opening the IOCTL channel. The error is logged.
            VSS_E_OBJECT_NOT_FOUND
                If the volume name does not correspond to an existing mount point
    
--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssCoordinator::Query" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: "
             L"QueriedObjectId = " WSTR_GUID_FMT
             L", eQueriedObjectType = %d"
             L", eReturnedObjectsType = %d"
             L", ppEnum = %p",
             GUID_PRINTF_ARG( QueriedObjectId ),
             eQueriedObjectType,
             eReturnedObjectsType,
             ppEnum);

        // Argument validation
        if (QueriedObjectId != GUID_NULL)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid QueriedObjectId");
        if (eQueriedObjectType != VSS_OBJECT_NONE)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eQueriedObjectType");
        if ((eReturnedObjectsType != VSS_OBJECT_SNAPSHOT)
            && (eReturnedObjectsType != VSS_OBJECT_PROVIDER))
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eReturnedObjectsType");
		BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppEnum");

        // Freeze context
        FreezeContext();

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

        // Fill now the collection
        switch( eReturnedObjectsType )
        {
        case VSS_OBJECT_SNAPSHOT:
            {
        		// Get the array of interfaces
        		CVssSnapshotProviderItfMap* pItfMap;
        		CVssProviderManager::GetProviderItfArray( GetContextInternal(), &pItfMap );
            	BS_ASSERT(pItfMap);

                // Initialize an observer.
                // This will keep track of all Snapshot set IDs that are created 
                // while the queries are in process
                CVssSnasphotSetIdObserver rec;

                // Start recording. This may throw.
                // (stop recording occurs anyway at object destruction if a throw happens after this call)
                rec.StartRecording();

        		// For each provider get all objects tht corresponds to the filter
        		for (int nIndex = 0; nIndex < pItfMap->GetSize(); nIndex++ )
        		{
            		CComPtr<IVssSnapshotProvider> pProviderItf = pItfMap->GetValueAt(nIndex);
        			if (pProviderItf == NULL)
        			    continue;
   
        			// Query the provider
            		CComPtr<IVssEnumObject> pEnumTmp;
        			ft.hr = pProviderItf->Query(
        				GUID_NULL,
        				VSS_OBJECT_NONE,
        				VSS_OBJECT_SNAPSHOT,
        				&pEnumTmp
        				);
        			if (ft.HrFailed())
        				ft.TranslateProviderError( VSSDBG_COORD, pItfMap->GetKeyAt(nIndex),
                            L"Error calling Query(). [0x%08lx]", ft.hr);
        			
        			// Add enumerator contents to array
        			CVssProviderManager::TransferEnumeratorContentsToArray( 
        			    pItfMap->GetKeyAt(nIndex), pEnumTmp, pArray );
        		}

                // Stop recording. 
                rec.StopRecording();

                // Remove from the array all snapshots that were created during Query.
                for(int nIndex = 0; nIndex < pArray->GetSize();) {
        			VSS_OBJECT_PROP_Ptr& ptr = (*pArray)[nIndex]; 
        			VSS_OBJECT_PROP* pStruct = ptr.GetStruct();
        			BS_ASSERT(pStruct);
        			BS_ASSERT(pStruct->Type == VSS_OBJECT_SNAPSHOT);
                	VSS_SNAPSHOT_PROP* pSnap = &(pStruct->Obj.Snap);

                    // If the snapshot belongs to a partially created snapshot set, remove it.
                	if (rec.IsRecorded(pSnap->m_SnapshotSetId)) {
                	    pArray->RemoveAt(nIndex);
                        // Do not increment - the same index will refer to the next element, if any.
                	} else {
                	    // This element is OK. Proceed with the next one.
                	    nIndex++;
                    }
                }
            }
    		break;
    		
        case VSS_OBJECT_PROVIDER:
            // Insert property structures into array.
    		CVssProviderManager::QuerySupportedProvidersIntoArray( 
    		    GetContextInternal(), true, NULL, pArray );
    		break;

        default:
            BS_ASSERT(false);
            ft.Throw( VSSDBG_COORD, E_INVALIDARG,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        }

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
		// Now pEnumObject's reference count becomes 1 (because of the smart pointer).
		// So if a throw occurs the enumerator object will be safely destroyed by the smart ptr.
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object.
		// The array's reference count becomes now 2, because IEnumOnSTLImpl::m_spUnk is also a smart ptr.
        BS_ASSERT(pArray);
		ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed()) {
            BS_ASSERT(false);
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr, L"Init(%p, %p)", pArrayItf, *pArray);
        }

        // Initialize the enumerator object.
		// The enumerator reference count becomes now 2.
        ft.hr = pUnknown->SafeQI(IVssEnumObject, ppEnum);
        if ( ft.HrFailed() ) {
            BS_ASSERT(false);
            ft.TranslateGenericError(VSSDBG_COORD, ft.hr, L"QueryInterface(IID_IVssEnumObject,%p)", ppEnum);
        }
        BS_ASSERT(*ppEnum);

		BS_ASSERT( !ft.HrFailed() );
		ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssAdmin::QueryProviders(
    OUT   IVssEnumObject**ppEnum
    )

/*++

Routine Description:

    Implements the IVssAdmin::QueryProviders method

Arguments:

    OUT     IVssEnumObject**ppEnum

Return values:

    E_OUTOFMEMORY
    E_INVALIDARG 
        - Invalid arguments
    E_ACCESSDENIED
        - The user is not a backup operator or an administrator
    E_UNEXPECTED
        - CVssEnumFromArray::Init failures
        - QueryInterface(IID_IVssEnumObject,...) failures

    [QuerySupportedProvidersIntoArray() failures]
        E_OUTOFMEMORY

        VSS_E_UNEXPECTED_PROVIDER_ERROR
            Unexpected provider error on calling IsVolumeSupported
            
        [lockObj failures]
            E_OUTOFMEMORY

        [LoadInternalProvidersArray() failures]
            E_OUTOFMEMORY
            E_UNEXPECTED
                - error while reading from registry. An error log entry is added describing the error.

        [GetProviderInterface failures]
            [lockObj failures]
                E_OUTOFMEMORY
            
            [GetProviderInterfaceInternal() failures]
                E_OUTOFMEMORY

                [CoCreateInstance() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - The provider interface couldn't be created. An error log entry is added describing the error.
                
                [QueryInterface failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. An error log entry is added describing the error.

                [OnLoad() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.
                    VSS_E_PROVIDER_VETO
                        - Expected provider error. The provider already did the logging.
                
                [SetContext() failures]
                    VSS_E_UNEXPECTED_PROVIDER_ERROR
                        - Unexpected provider error. The error code is logged into the event log.

        [InitializeAsProvider() failures]
            E_OUTOFMEMORY

        [IVssSnapshotProvider::IsVolumeSupported() failures]
            E_INVALIDARG
                NULL pointers passed as parameters or a volume name in an invalid format.
            E_OUTOFMEMORY
                Out of memory or other system resources           
            VSS_E_PROVIDER_VETO
                An error occured while opening the IOCTL channel. The error is logged.
            VSS_E_OBJECT_NOT_FOUND
                If the volume name does not correspond to an existing mount point
    
--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssAdmin::QueryProviders" );
    VSS_OBJECT_PROP_Ptr ptrProviderProperties;

    try
    {
        // Initialize [out] arguments
        VssZeroOut( ppEnum );

        // Access check
        if (!IsBackupOperator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account or does not have backup privilege enabled");

        // Trace parameters
        ft.Trace( VSSDBG_COORD, L"Parameters: "
             L"ppEnum = %p",
             ppEnum
             );

        // Argument validation
		BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL ppEnum");

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

        // Insert property structures into array. All providers support by default the backup context.
		CVssProviderManager::QuerySupportedProvidersIntoArray( 
		    VSS_CTX_BACKUP, true, NULL, pArray );

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
		// Now pEnumObject's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object. The array's itf pointer refcount becomes now 2.
        ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                      L"Cannot initialize enumerator instance. [0x%08lx]", ft.hr);

        ft.hr = pUnknown->SafeQI(IVssEnumObject, ppEnum);
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                      L"Error querying the IVssEnumObject interface. hr = 0x%08lx", ft.hr);
        BS_ASSERT(*ppEnum);

		BS_ASSERT( !ft.HrFailed() );
		ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
//  CVssSnasphotSetIdObserver


//  Global variables
//

// Global list of observers
CVssDLList<CVssSnasphotSetIdObserver*>	 CVssSnasphotSetIdObserver::m_list;

// Global lock fot the observer operations
CVssSafeCriticalSection  CVssSnasphotSetIdObserver::m_cs;


// Implementation
//

// Constructs an observer object
CVssSnasphotSetIdObserver::CVssSnasphotSetIdObserver():
    m_bRecordingInProgress(false), 
    m_Cookie(VSS_NULL_COOKIE)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::CVssSnasphotSetIdObserver" );
}


// Destructs the observer object
// This does NOT throw!
CVssSnasphotSetIdObserver::~CVssSnasphotSetIdObserver()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::~CVssSnasphotSetIdObserver" );

    // Check if the critical section is initialized
    if (!m_cs.IsInitialized())
        return;
    
    // Global lock. This does NOT throw!
    CVssSafeAutomaticLock lock(m_cs);

    // Check for validity
    if (!IsValid())
        return;

    // Remove ourselves to the global list of observers
    // This also does not throw.
    CVssSnasphotSetIdObserver* pThis = NULL;
    m_list.ExtractByCookie(m_Cookie, pThis);
    BS_ASSERT(this == pThis);
}


// Check if the observer is valid
bool CVssSnasphotSetIdObserver::IsValid()
{
    return (m_Cookie != VSS_NULL_COOKIE);
}


// Puts the observer in the listeners list in order to detect partial results in Query
// This may safely throw!
void CVssSnasphotSetIdObserver::StartRecording() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::StartRecording" );

    // Initialize critical section if needed.
    m_cs.Init();
    if (!m_cs.IsInitialized())
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Unable to initialize the global critical section");

    // Global lock - does not throw
    CVssSafeAutomaticLock lock(m_cs);
    
    // Starts the recording
    BS_ASSERT(m_bRecordingInProgress == false);
    m_bRecordingInProgress = true;

    // Try to add the current snapshot set ID, if any
    // This may throw.
    CVssGlobalSnapshotSetId::InitializeObserver(this);

    // Add ourselves to the global list of observers. 
    // This can throw E_OUTOFMEMORY
    if (m_Cookie != VSS_NULL_COOKIE) {
        BS_ASSERT(false);
        return;
    }
    m_Cookie = m_list.Add(ft, this);
}


// Stop recording SSIDs
void CVssSnasphotSetIdObserver::StopRecording()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::StopRecording" );

    // Programming error: you must successfully call StartRecording first!
    if (!IsValid()) {
        BS_ASSERT(false);
        ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"StartRecording was not called successfully");
    }
    
    // Acquire the critical section. Doesn't throw.
    BS_ASSERT(m_cs.IsInitialized());
    CVssSafeAutomaticLock lock(m_cs);

    // Stops the recording
    BS_ASSERT(m_bRecordingInProgress == true);
    m_bRecordingInProgress = false;
}


// Check if a SSID was in progress
bool CVssSnasphotSetIdObserver::IsRecorded(
    IN  VSS_ID SnapshotSetID 
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::IsRecorded" );

    // Programming error: you must successfully call StartRecording first!
    if (!IsValid()) {
        BS_ASSERT(false);
        ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"StartRecording was not called successfully");
    }
    
    // Acquire the critical section
    BS_ASSERT(m_cs.IsInitialized());
    CVssSafeAutomaticLock lock(m_cs);

    // Check to see if the snapshot set is recorded
    return (m_mapSnapshotSets.FindKey(SnapshotSetID) != -1);
}


// Records this Snapshot Set ID in ALL observers
void CVssSnasphotSetIdObserver::BroadcastSSID(
    IN VSS_ID SnapshotSetId
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::BroadcastSSID" );

    // Validate arguments
    BS_ASSERT(SnapshotSetId != GUID_NULL);

    // Do not attempt to broadcast SSIDs if there are no observers
    if (!m_cs.IsInitialized())
        return;
    
    // Acquire the critical section
    CVssSafeAutomaticLock lock(m_cs);

    // Record the SSID for all listeners
    //

    // Get an iterator for the global list of observers
	CVssDLListIterator<CVssSnasphotSetIdObserver*> iterator(m_list);

    // Send the SSID to all observers. If we fail in the middle, 
    // then we are still in a consistent state. In order to simplify 
    // the code we will not add any supplementary checks,
    // since the caller (StartSnapshotSet) will fail anyway, 
    // so we will have an additional harmless filtering for an invalid SSID. 

    // This might throw!
    CVssSnasphotSetIdObserver* pObj = NULL;
	while (iterator.GetNext(pObj))
		pObj->RecordSSID(SnapshotSetId);
}


// Records this Snapshot Set ID in this observer instance
// Remark: The lock is already acquired
void CVssSnasphotSetIdObserver::RecordSSID(
    IN VSS_ID SnapshotSetId
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVssSnasphotSetIdObserver::RecordSSID" );

    // Check to see if recording is in progress.
    if (!m_bRecordingInProgress)
        return;

    // Add the SSID to the internal map
    if (!m_mapSnapshotSets.Add(SnapshotSetId, 0))
        ft.Throw(VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\softwrp.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module softwrp.cxx | Implementation of CVssSoftwareProviderWrapper
    @end

Author:

    Adi Oltean  [aoltean]  03/11/2001

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     03/11/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

// Generated file from Coord.IDL
#include "vs_idl.hxx"

#include "softwrp.hxx"
#include "vssmsg.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSOFTC"
//
////////////////////////////////////////////////////////////////////////


IVssSnapshotProvider* CVssSoftwareProviderWrapper::CreateInstance(
    IN VSS_ID ProviderId,
	IN CLSID ClassId
    ) throw(HRESULT)
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::CreateInstance");

    // Ref count becomes 1
    CComPtr<CVssSoftwareProviderWrapper> pWrapper = new CVssSoftwareProviderWrapper();
    if (pWrapper == NULL)
        ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");

	// Create the IVssSoftwareSnapshotProvider interface
	ft.hr = pWrapper->m_pSoftwareItf.CoCreateInstance(ClassId, NULL, CLSCTX_LOCAL_SERVER);
	if ( ft.HrFailed() ) {
	    ft.LogError(VSS_ERROR_CREATING_PROVIDER_CLASS, VSSDBG_COORD << ClassId << ft.hr );
		ft.Throw( VSSDBG_COORD, VSS_E_UNEXPECTED_PROVIDER_ERROR, L"CoCreateInstance failed with hr = 0x%08lx", ft.hr);
	}
	BS_ASSERT(pWrapper->m_pSoftwareItf);

	// Query the creation itf.
    ft.hr = pWrapper->m_pSoftwareItf->SafeQI( IVssProviderCreateSnapshotSet, &(pWrapper->m_pCreationItf) );
    if (ft.HrFailed()) {
        ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"QI for IVssProviderCreateSnapshotSet");
    }
	BS_ASSERT(pWrapper->m_pCreationItf);

	// Query the notification itf.
	// Execute the OnLoad, if needed
    ft.hr = pWrapper->m_pSoftwareItf->SafeQI( IVssProviderNotifications, &(pWrapper->m_pNotificationItf) );
    if (ft.HrSucceeded()) {
	    BS_ASSERT(pWrapper->m_pNotificationItf);
    } else if (ft.hr != E_NOINTERFACE) {
        BS_ASSERT(false);
        ft.TranslateProviderError(VSSDBG_COORD, ProviderId, L"QI for IVssProviderNotifications");
    }

    // return the created interface
    // Ref count is still 1
    return pWrapper.Detach();
}


/////////////////////////////////////////////////////////////////////////////
// Internal methods

STDMETHODIMP CVssSoftwareProviderWrapper::QueryInternalInterface(
    IN  REFIID iid,
    OUT void** pp
    )
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::QueryInternalInterface");

    BS_ASSERT(pp);
    if (iid != IID_IVssSnapshotMgmt) {
        BS_ASSERT(false);
        return E_UNEXPECTED;
    }

    // Get the management interface
    CComPtr<IVssSnapshotMgmt> ptrUnk;
    BS_ASSERT(m_pSoftwareItf);
    ft.hr = m_pSoftwareItf->SafeQI(IVssSnapshotMgmt, &ptrUnk);
    if (ft.HrFailed())
    {
        BS_ASSERT(false);
        ft.Trace( VSSDBG_COORD, L"Error while obtaining the IVssSnapshotMgmt interface 0x%08lx", ft.hr);
        return E_UNEXPECTED;
    }

    (*pp) = ptrUnk.Detach();
	return S_OK;
};


/////////////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP CVssSoftwareProviderWrapper::QueryInterface(REFIID iid, void** pp)
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::QueryInterface");

    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
	return S_OK;
};

STDMETHODIMP_(ULONG) CVssSoftwareProviderWrapper::AddRef()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::AddRef");
    ft.Trace(VSSDBG_COORD, L"Provider Wrapper AddRef(%p) %lu --> %lu", this, m_lRef, m_lRef+1);

    return ::InterlockedIncrement(&m_lRef);
};

STDMETHODIMP_(ULONG) CVssSoftwareProviderWrapper::Release()
{
    CVssFunctionTracer ft(VSSDBG_COORD, L"CVssSoftwareProviderWrapper::Release");
    ft.Trace(VSSDBG_COORD, L"Provider Wrapper Release(%p) %lu --> %lu", this, m_lRef, m_lRef-1);

    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        delete this; // We suppose that we always allocate this object on the heap!
    return l;
};


/////////////////////////////////////////////////////////////////////////////
//  IVssSoftwareSnapshotProvider


STDMETHODIMP CVssSoftwareProviderWrapper::SetContext(
	IN		LONG     lContext
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->SetContext(lContext);
}


STDMETHODIMP CVssSoftwareProviderWrapper::GetSnapshotProperties(
	IN      VSS_ID			SnapshotId,
	OUT 	VSS_SNAPSHOT_PROP	*pProp
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->GetSnapshotProperties(
                SnapshotId,
                pProp
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::Query(
    IN      VSS_ID          QueriedObjectId,
    IN      VSS_OBJECT_TYPE eQueriedObjectType,
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,
    OUT     IVssEnumObject**ppEnum
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->Query(
                QueriedObjectId,
                eQueriedObjectType,
                eReturnedObjectsType,
                ppEnum
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::DeleteSnapshots(
    IN      VSS_ID          SourceObjectId,
	IN      VSS_OBJECT_TYPE eSourceObjectType,
	IN		BOOL			bForceDelete,			
	OUT		LONG*			plDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->DeleteSnapshots(
                SourceObjectId,
                eSourceObjectType,
                bForceDelete,			
                plDeletedSnapshots,		
                pNondeletedSnapshotID
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::BeginPrepareSnapshot(
    IN      VSS_ID          SnapshotSetId,
    IN      VSS_ID          SnapshotId,
    IN      VSS_PWSZ		pwszVolumeName
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->BeginPrepareSnapshot(
                SnapshotSetId,
                SnapshotId,
                pwszVolumeName 
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::IsVolumeSupported(
    IN      VSS_PWSZ        pwszVolumeName,
    OUT     BOOL *          pbSupportedByThisProvider
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->IsVolumeSupported(
                pwszVolumeName,
                pbSupportedByThisProvider
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::IsVolumeSnapshotted(
    IN      VSS_PWSZ        pwszVolumeName,
    OUT     BOOL *          pbSnapshotsPresent,
	OUT 	LONG *		    plSnapshotCompatibility
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->IsVolumeSnapshotted(
                pwszVolumeName,
                pbSnapshotsPresent,
                plSnapshotCompatibility
                );
}


STDMETHODIMP CVssSoftwareProviderWrapper::MakeSnapshotReadWrite(
    IN      VSS_ID          SourceObjectId
	)
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->MakeSnapshotReadWrite(SourceObjectId);
}


STDMETHODIMP CVssSoftwareProviderWrapper::SetSnapshotProperty(
	IN   VSS_ID  			SnapshotId,
	IN   VSS_SNAPSHOT_PROPERTY_ID	eSnapshotPropertyId,
	IN   VARIANT 			vProperty
	)
/*++

Routine description:

    Implements IVssSoftwareSnapshotProvider::SetSnapshotProperty


--*/
{
    BS_ASSERT(m_pSoftwareItf);
    return m_pSoftwareItf->SetSnapshotProperty(SnapshotId, eSnapshotPropertyId, vProperty);
}




/////////////////////////////////////////////////////////////////////////////
// IVssProviderCreateSnapshotSet


STDMETHODIMP CVssSoftwareProviderWrapper::EndPrepareSnapshots(
    IN      VSS_ID          SnapshotSetId
	)
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->EndPrepareSnapshots(SnapshotSetId);
}


STDMETHODIMP CVssSoftwareProviderWrapper::PreCommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->PreCommitSnapshots(SnapshotSetId);
}


STDMETHODIMP CVssSoftwareProviderWrapper::CommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->CommitSnapshots(SnapshotSetId);
}


STDMETHODIMP CVssSoftwareProviderWrapper::PostCommitSnapshots(
    IN      VSS_ID          SnapshotSetId,
	IN      LONG            lSnapshotsCount
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->PostCommitSnapshots(SnapshotSetId, lSnapshotsCount);
}


STDMETHODIMP CVssSoftwareProviderWrapper::PostSnapshot(
	IN		IDispatch		*pCallback
	)
	{
	UNREFERENCED_PARAMETER(pCallback);

	return S_OK;
	}


STDMETHODIMP CVssSoftwareProviderWrapper::AbortSnapshots(
    IN      VSS_ID          SnapshotSetId
    )
{
    BS_ASSERT(m_pCreationItf);
    return m_pCreationItf->AbortSnapshots(SnapshotSetId);
}


////////////////////////////////////////////////////////////////////////
// IVssProviderNotifications

STDMETHODIMP CVssSoftwareProviderWrapper::OnLoad(								
    IN  IUnknown* pCallback
    )
{
    return m_pNotificationItf? m_pNotificationItf->OnLoad(pCallback): S_OK;
}


STDMETHODIMP CVssSoftwareProviderWrapper::OnUnload(								
	IN  	BOOL	bForceUnload				
    )
{
    return m_pNotificationItf? m_pNotificationItf->OnUnload(bForceUnload): S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\reg_util.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module reg_util.cxx | Implementation of the Registry-related functions
    @end

Author:

    Adi Oltean  [aoltean]  09/27/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/27/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"
#include "vssmsg.h"

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "provmgr.hxx"
#include "reg_util.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORREGUC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssCoordinator private methods


void RecursiveDeleteKey(
    IN  CVssFunctionTracer& ft,
    IN  HKEY hParentKey,
    IN  LPCWSTR wszName
    )

/*++

Routine Description:

    Deletes recursively a registry key.

Arguments:

    IN  CVssFunctionTracer& ft,     // function tracer of the caller
    IN  HKEY hParentKey,            // handle to an ancestor key (like HKEY_LOCAL_MACHINE)
    IN  LPCWSTR wszName             // The key path from ancestor

Remarks:

    Calls RecursiveDeleteSubkeys() who also calls this function

--*/

{
    HKEY hKey;
    WCHAR wszFunctionName[] = L"RecursiveDeleteKey";

	BS_ASSERT(ft.hr == S_OK);
    BS_ASSERT(hParentKey);
    BS_ASSERT(wszName && wszName[0] != L'\0');

    // Open the key
    LONG lRes = ::RegOpenKeyExW(
        hParentKey,     //  IN HKEY hKey,
        wszName,        //  IN LPCWSTR lpSubKey,
        0,              //  IN DWORD ulOptions,
        KEY_ALL_ACCESS, //  IN REGSAM samDesired,
        &hKey           //  OUT PHKEY phkResult
        );
    if (lRes != ERROR_SUCCESS)
    {
        if (ft.hr == S_OK)  // Remember only first error
            ft.hr = lRes;
		ft.LogGenericWarning(VSSDBG_COORD, L"RegOpenKeyExW(0x%08lx,%s,...) == 0x%08lx", hParentKey, wszName, lRes);
        ft.Trace( VSSDBG_COORD, L"%s: Error on opening (enumerated) key with name %s. lRes == 0x%08lx",
                  wszFunctionName, wszName, lRes );
        return;
    }
    BS_ASSERT(hKey);

    // Recursive delete the subkeys
    RecursiveDeleteSubkeys( ft, hKey );

    // Close the key
    lRes = ::RegCloseKey( hKey );
    if (lRes != ERROR_SUCCESS)
    {
        if (ft.hr == S_OK)  // Remember only first error
            ft.hr = lRes;
        ft.Trace( VSSDBG_COORD, L"%s: Error on closing key with name %s. lRes == 0x%08lx",
                  wszFunctionName, wszName, lRes );
    }

    // Delete the key
    lRes = ::RegDeleteKeyW( hParentKey, wszName );
    switch( lRes )
    {
    case ERROR_SUCCESS:
        break;
    case ERROR_FILE_NOT_FOUND:
    default:
        if (ft.hr == S_OK)  // Remember only first error
            ft.hr = lRes;
		ft.LogGenericWarning(VSSDBG_COORD, L"RegDeleteKeyW(0x%08lx,%s) == 0x%08lx", hParentKey, wszName, lRes);
        ft.Trace( VSSDBG_COORD, L"%s: Error on deleting key with name %s. lRes == 0x%08lx",
                  wszFunctionName, wszName, lRes );
    }
}


void RecursiveDeleteSubkeys(
    IN  CVssFunctionTracer& ft,
    IN  HKEY hKey
    )

/*++

Routine Description:

    Deletes recursively all subkeys under a registry key.

Arguments:

    IN  CVssFunctionTracer& ft,     // function tracer of the caller
    IN  HKEY hKey,                  // handle to the current key

Remarks:

    Calls RecursiveDeleteKey() for all subkeys, who also calls this function

--*/

{
    WCHAR wszFunctionName[] = L"RecursiveDeleteSubkeys";
    WCHAR   wszSubKeyName[_MAX_KEYNAME_LEN];
    FILETIME time;

	BS_ASSERT(ft.hr == S_OK);
    BS_ASSERT(hKey);

    // Enumerate all subkeys
    while (true)
    {
        // Fill wszSubKeyName with the name of the subkey
        DWORD dwSize = sizeof(wszSubKeyName)/sizeof(wszSubKeyName[0]);
        LONG lRes = ::RegEnumKeyExW(
            hKey,           // IN HKEY hKey,
            0,              // IN DWORD dwIndex,
            wszSubKeyName,  // OUT LPWSTR lpName,
            &dwSize,        // IN OUT LPDWORD lpcbName,
            NULL,           // IN LPDWORD lpReserved,
            NULL,           // IN OUT LPWSTR lpClass,
            NULL,           // IN OUT LPDWORD lpcbClass,
            &time);         // OUT PFILETIME lpftLastWriteTime
        switch(lRes)
        {
        case ERROR_SUCCESS:
            BS_ASSERT(dwSize != 0);
            RecursiveDeleteKey( ft, hKey, wszSubKeyName );
            break; // Go to Next key
        default:
            if (ft.hr == S_OK)  // Remember only first error
                ft.hr = lRes;
    		ft.LogGenericWarning(VSSDBG_COORD, L"RegEnumKeyExW(0x%08lx,%s,...) == 0x%08lx", hKey, wszSubKeyName, lRes);
            ft.Trace( VSSDBG_COORD, L"%s: Error on iteration. 0x%08lx", wszFunctionName, lRes );
        case ERROR_NO_MORE_ITEMS:
            return;   // End of iteration
        }
    }
}


void QueryStringValue(
    IN  CVssFunctionTracer& ft,
    IN  HKEY    hKey,
    IN  LPCWSTR wszKeyName,
    IN  LPCWSTR wszValueName,
    IN  DWORD   dwValueSize,
    OUT LPCWSTR wszValue
    )

/*++

Routine Description:

    Get the content of a (named) value of a registry key.
    Intended to be called from CVssCoordinator methods.
    Throw some HRESULTS on error

Arguments:

    IN  CVssFunctionTracer& ft,
    IN  HKEY hKey,              // handle to the registry key
    IN  LPCWSTR wszKeyName,     // the name of the key (used only in tracing)
    IN  LPCWSTR wszValueName,   // the name of the value. Empty string for default key value.
    IN  DWORD   dwValueSize,    // the size of the value buffer, in WCHARs
    OUT LPCWSTR wszValue        // The content of that value.
                                // The buffer must be already allocated and must have at
                                // least dwValueSize WCHARs

Remarks:

    The code throws an error if value name length is greater than dwValueSize-1

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - on registry errors. An error log entry is added describing the error.

--*/

{
    WCHAR       wszFunctionName[] = L"QueryStringValue";

	ft.hr = S_OK;

    BS_ASSERT( hKey );
    BS_ASSERT( wszKeyName != NULL && wszKeyName[0] != L'\0' );
    BS_ASSERT( wszValueName != NULL ); // wszValueName can be L""
    BS_ASSERT( dwValueSize != 0 );
    BS_ASSERT( wszValue );

    ::ZeroMemory( (void*)wszValue, dwValueSize * sizeof(WCHAR) );

    // Get the string content of the named key value
    DWORD   dwType;
    DWORD   dwDataSize = dwValueSize * sizeof(WCHAR);
    LPBYTE  pbData = (LPBYTE)wszValue;
    LONG lRes = ::RegQueryValueExW (
        hKey,           //  IN HKEY hKey,
        wszValueName,   //  IN LPCWSTR lpValueName,
        NULL,           //  IN LPDWORD lpReserved,
        &dwType,        //  OUT LPDWORD lpType,
        pbData,         //  IN OUT LPBYTE lpData,
        &dwDataSize     //  IN OUT LPDWORD lpcbData
        );
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
            L"RegQueryValueExW(%s,%s,...)", wszKeyName, wszValueName );

    // Unexpected key type
    if ( dwType != REG_SZ ) { 
        ft.LogError(VSS_ERROR_WRONG_REGISTRY_TYPE_VALUE, 
            VSSDBG_COORD << (INT)dwType << (INT)REG_SZ << wszValueName << wszKeyName );
        ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                  L"%s: The value %s in the key with name %s has not a REG_SZ type. dwType == 0x%08lx",
                  wszFunctionName, wszValueName, wszKeyName, dwType );
    }
}


void QueryDWORDValue(
    IN  CVssFunctionTracer& ft,
    IN  HKEY    hKey,
    IN  LPCWSTR wszKeyName,
    IN  LPCWSTR wszValueName,
    OUT PDWORD pdwValue
    )

/*++

Routine Description:

    Get the content of a (named) value of a registry key.
    Intended to be called from CVssCoordinator methods.
    Throw some HRESULTS on error

Arguments:

    IN  CVssFunctionTracer& ft,
    IN  HKEY hKey,              // handle to the registry key
    IN  LPCWSTR wszKeyName,     // the name of the key (used only in tracing)
    IN  LPCWSTR wszValueName,   // the name of the value. Empty string for default key value.
    OUT PDWORD pdwValue         // The content of that DWORD value.

Remarks:

    The code throws an error if value name length is greater than dwValueSize-1

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - on registry errors. An error log entry is added describing the error.

--*/

{
    WCHAR       wszFunctionName[] = L"QueryDWORDValue";

	ft.hr = S_OK;

    BS_ASSERT( hKey );
    BS_ASSERT( wszKeyName != NULL && wszKeyName[0] != L'\0' );
    BS_ASSERT( wszValueName != NULL ); // wszValueName can be L""
    BS_ASSERT( pdwValue );

    (*pdwValue)=0;

    // Get the string content of the named key value
    DWORD   dwType = REG_NONE;  // Prefix bug 192471, still doesn't handle throw inside called functions well.
    DWORD   dwDataSize = sizeof(DWORD);
    LPBYTE  pbData = (LPBYTE)pdwValue;
    LONG lRes = ::RegQueryValueExW (
        hKey,           //  IN HKEY hKey,
        wszValueName,   //  IN LPCWSTR lpValueName,
        NULL,           //  IN LPDWORD lpReserved,
        &dwType,        //  OUT LPDWORD lpType,
        pbData,         //  IN OUT LPBYTE lpData,
        &dwDataSize     //  IN OUT LPDWORD lpcbData
        );
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(lRes), 
            L"RegQueryValueExW(%s,%s,...)", wszKeyName, wszValueName );

    // Unexpected key type
    if ( dwType != REG_DWORD ) { 
        ft.LogError(VSS_ERROR_WRONG_REGISTRY_TYPE_VALUE, 
            VSSDBG_COORD << (INT)dwType << (INT)REG_DWORD << wszValueName << wszKeyName );
        ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
                  L"%s: The value %s in the key with name %s has not a REG_DWORD type. dwType == 0x%08lx",
                  wszFunctionName, wszValueName, wszKeyName, dwType );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\jetwriter\stdafx.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <errno.h>
#include <oledb.h>
#include <oledberr.h>
#include <sqloledb.h>

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)

#include "vs_assert.hxx"

#include <oleauto.h>
#include <comadmin.h>

#include <stddef.h>
#include <atlconv.h>
#include <atlbase.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\prop\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.cxx | The file used to compile the precompiled header
    @end

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.

--*/


#include "stdafx.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\sec\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.cxx | The file used to compile the precompiled header
    @end

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.

--*/


#include "stdafx.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\coord\src\svc.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    svc.cxx

Abstract:

    Implements the Volume Snapshot Service.

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     06/30/1999  Created.
    aoltean     07/23/1999  Making registration code more error-prone.
                            Changing the service name.
    aoltean     08/11/1999  Initializing m_bBreakFlagInternal
    aoltean     09/09/1999  dss -> vss
	aoltean		09/21/1999  Adding a new header for the "ptr" class.
	aoltean		09/27/1999	Adding some headers
	aoltean		03/10/2000	Simplifying Setup
	brianb		04/19/2000  Add Sql Writer
	brianb		05/03/2000	Start sql writer before registering COM stuff
	brianb		05/05/2000	fix sql writer startup

--*/


////////////////////////////////////////////////////////////////////////
//  Includes

#include "StdAfx.hxx"
#include <comadmin.h>
#include "resource.h"
#include "vssmsg.h"
#include "dbt.h"

// General utilities
#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "svc.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "provmgr.hxx"
#include "admin.hxx"
#include "worker.hxx"
#include "ichannel.hxx"
#include "lovelace.hxx"
#include "snap_set.hxx"
#include "shim.hxx"
#include "coord.hxx"
#include "mgmt.hxx"

#include "comadmin.hxx"

#include "vswriter.h"
#include "vsbackup.h"
#include "sqlsnap.h"
#include "sqlwriter.h"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "CORSVCC"
//
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
//  Constants

// 15 minutes of idle activity until shutdown.
// The time is expressed number of 100 nanosecond intervals.
const LONGLONG  llVSSVCIdleTimeout = (LONGLONG)(-3) * 60 * 1000 * 1000 * 10;

// Immediate shutdown.
const LONGLONG  llVSSVCShutdownTimeout = (LONGLONG)(-1);


////////////////////////////////////////////////////////////////////////
//  ATL Stuff


CVsServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_VSSCoordinator, CVssCoordinator)
    OBJECT_ENTRY(CLSID_VssSnapshotMgmt, CVssSnapshotMgmt)
END_OBJECT_MAP()

// sql server (MSDE) Writer wrapper.  Included in coordinator because
// it needs admin privileges
CVssSqlWriterWrapper g_SqlWrapper;

void SetArrivalHandler(IVssArrivalNotification *pHandler)
	{
	_Module.SetArrivalHandler(pHandler);
	}


//
//  Store away the thread id of the thread executing the ServiceMain() method.
//  Used to syncronize the ending of the main thread.
//
static DWORD g_dwServiceMainThreadId = 0;

/////////////////////////////////////////////////////////////////////////////////////////////////////////
//  CVsServiceModule implementation


CVsServiceModule::CVsServiceModule()

/*++

Routine Description:

    Default constructor. Initialize ALL members with predefined values.

--*/

{
	::VssZeroOut(&m_status);
	m_hInstance = NULL;
	m_hServiceStatus = NULL;
	m_hDiskNotify = NULL;
	m_pArrival = NULL;
	m_dwThreadID = 0;
	m_hShutdownTimer = NULL;
	m_bShutdownInProgress = false;
	m_hSubscriptionsInitializeEvent = NULL;
	m_bCOMStarted = false;
    m_pvFuncSimulateSnapshotFreezeInternal = NULL;
    m_pvFuncSimulateSnapshotThawInternal = NULL;

	// Initialize the members of the SERVICE_STATUS that don't change
	m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwControlsAccepted =
		SERVICE_ACCEPT_STOP |
		SERVICE_ACCEPT_SHUTDOWN;
}


///////////////////////////////////////////////////////////////////////////////////////
// Service control routines (i.e. ServiceMain-related methods)
//


void CVsServiceModule::StartDispatcher()

/*++

Routine Description:

    Called in the main execution path.
	Will register the _ServiceMain function.

Called by:

	CVsServiceModule::_WinMain

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::StartDispatcher");

    try
    {
		SERVICE_TABLE_ENTRYW st[] =
		{
			{ const_cast<LPWSTR>(wszServiceName), _ServiceMain },
			{ NULL, NULL }
		};

		// Register the dispatcher main function into the Service Control Manager
		// This call blocks until ServiceMain tells SCM the service status is stopped
		if ( !::StartServiceCtrlDispatcherW(st) ) {
		    ft.LogError(VSS_ERROR_STARTING_SERVICE_CTRL_DISPATCHER, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()) );
			ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
					  L"StartServiceCtrlDispatcherW failed. 0x%08lx", GetLastError() );
	    }

        //  If the ServiceMain thread is still running, wait for it to finish.
        if ( g_dwServiceMainThreadId != 0 )
        {
            HANDLE hServiceMainThread;

            hServiceMainThread = ::OpenThread( SYNCHRONIZE, FALSE, g_dwServiceMainThreadId );
            if ( hServiceMainThread != NULL )
            {
                ft.Trace( VSSDBG_COORD, L"CVsServiceModule::StartDispatcher: Waiting for ServiceMain thread to finish..." );
                //  Wait up to 10 seconds
                if ( ::WaitForSingleObject( hServiceMainThread, 10000 ) == WAIT_TIMEOUT )
                {
                    ft.Trace( VSSDBG_COORD, L"CVsServiceModule::StartDispatcher: Wait timed out, ending anyway" );
                }
                ::CloseHandle( hServiceMainThread );
            }
        }
    }
    VSS_STANDARD_CATCH(ft)

	m_status.dwWin32ExitCode = ft.hr;
}


void WINAPI CVsServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}


void CVsServiceModule::ServiceMain(
    IN	DWORD	/* dwArgc */,
    IN	LPTSTR* /* lpszArgv */
    )

/*++

Routine Description:

	The main service control dispatcher.

Called by:

    Called by the NT Service framework following
	the StartServiceCtrlDispatcherW which was called in CVsServiceModule::StartDispatcher

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::ServiceMain");

    try
    {
        // Store away this thread id for use by the main thread.
        g_dwServiceMainThreadId = ::GetCurrentThreadId();

		// Needed for SERVICE_CONTROL_INTERROGATE that may come between the next two calls
		m_status.dwCurrentState = SERVICE_START_PENDING;

        // Register the control request handler
        m_hServiceStatus = ::RegisterServiceCtrlHandlerEx(wszServiceName, _Handler, NULL);
        if ( m_hServiceStatus == NULL ) {
		    ft.LogError(VSS_ERROR_STARTING_SERVICE_REG_CTRL_HANDLER, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()) );
			ft.Throw( VSSDBG_COORD, E_UNEXPECTED, L"RegisterServiceCtrlHandlerEx failed. 0x%08lx", GetLastError() );
        }

		RegisterPnPNotifications();


		// Now we will really inform the SCM that the service is pending its start.
        SetServiceStatus(SERVICE_START_PENDING);

		// Internal initialization
		OnInitializing();

		// The service is started now.
		SetServiceStatus(SERVICE_RUNNING);

		// Wait for shutdown attempt
		OnRunning();

		// Shutdown was started either by receiving the SERVICE_CONTROL_STOP
		// or SERVICE_CONTROL_SHUTDOWN events either because the COM objects number is zero.
		SetServiceStatus(SERVICE_STOP_PENDING);

		// Perform the un-initialization tasks
		OnStopping();

		// The service is stopped now.
        SetServiceStatus(SERVICE_STOPPED);
    }
    VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed()) {

		// Present the error codes to the caller.
		m_status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
		m_status.dwServiceSpecificExitCode = ft.hr;

		// Perform the un-initialization tasks
		OnStopping();

		// The service is stopped now.
        SetServiceStatus(SERVICE_STOPPED, false);
	}
}


DWORD WINAPI CVsServiceModule::_Handler
	(
	DWORD dwOpcode,
	DWORD dwEventType,
	LPVOID lpEventData,
	LPVOID lpEventContext
	)
	{
    return _Module.Handler(dwOpcode, dwEventType, lpEventData, lpEventContext);
	}


DWORD CVsServiceModule::Handler
	(
    DWORD dwOpcode,
	DWORD dwEventType,
    LPVOID lpEventData,
	LPVOID lpEventContext
    )

/*++

Routine Description:

    Used by Service Control Manager to inform this service about the service-related events

Called by:

	Service Control Manager.

--*/

	{
	UNREFERENCED_PARAMETER(lpEventContext);
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::Handler");
	DWORD dwResult = ERROR_CALL_NOT_IMPLEMENTED;

    try
		{
		// re-initialize "volatile" members
		m_status.dwCheckPoint = 0;
		m_status.dwWaitHint = 0;
		m_status.dwWin32ExitCode = 0;
        m_status.dwServiceSpecificExitCode = 0;

		switch (dwOpcode)
			{
			case SERVICE_CONTROL_INTERROGATE:
				dwResult = NOERROR;
				// Present the previous state.
				SetServiceStatus(m_status.dwCurrentState);
				break;

			case SERVICE_CONTROL_STOP:
			case SERVICE_CONTROL_SHUTDOWN:
				dwResult = NOERROR;
				SetServiceStatus(SERVICE_STOP_PENDING);
				OnSignalShutdown();
				// The SERVICE_STOPPED status must be communicated
				// in Service's main function.
				break;

            case SERVICE_CONTROL_DEVICEEVENT:
				{
				dwResult = NOERROR;
                switch(dwEventType)
					{
					default:
						break;

					case DBT_DEVICEARRIVAL:
						if (!lpEventData || (0 == ((PDEV_BROADCAST_HDR) lpEventData)->dbch_size))
							break;

						GUID guid1 = DiskClassGuid;
						if (memcmp
								(
								&((PDEV_BROADCAST_DEVICEINTERFACE) lpEventData)->dbcc_classguid,
								&guid1,
								sizeof(GUID)) == 0)
                            {
							if (m_pArrival)
								m_pArrival->RecordDiskArrival
									(
									((PDEV_BROADCAST_DEVICEINTERFACE) lpEventData)->dbcc_name
									);
							}

						break;
					}
				}

			}
		}
    VSS_STANDARD_CATCH(ft)

	return dwResult;
	}


void CVsServiceModule::SetServiceStatus(
		IN	DWORD dwState,
		IN	bool bThrowOnError /* = true */
		)

/*++

Routine Description:

    Informs the Service Control Manager about the new status.

Called by:

	CVsServiceModule methods

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::SetServiceStatus");

	try
	{
		ft.Trace( VSSDBG_COORD, L"Attempt to change the service status to %lu", dwState);

		BS_ASSERT(m_hServiceStatus != NULL);

		// Inform SCM about the new status
		m_status.dwCurrentState = dwState;
		if ( !::SetServiceStatus(m_hServiceStatus, &m_status) ) {
		    ft.LogError(VSS_ERROR_SET_SERVICE_STATUS, VSSDBG_COORD << (INT)dwState << HRESULT_FROM_WIN32(GetLastError()) );
			ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
						L"Error on calling SetServiceStatus. 0x%08lx", GetLastError() );
		}
	}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		ft.ThrowIf( bThrowOnError, VSSDBG_COORD, ft.hr,
					L"Error on calling SetServiceStatus. 0x%08lx", ft.hr );
}


void CVsServiceModule::WaitForSubscribingCompletion() throw(HRESULT)

/*++

Routine Description:

    Wait until all subscriptions are performed

Called by:

	CVsServiceModule::ServiceMain

Throws:

    E_UNEXPECTED
        - WaitForSingleObject failures

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::WaitForSubscribingCompletion" );

	// Wait for shutdown
	DWORD dwRet = WaitForSingleObject(
		m_hSubscriptionsInitializeEvent,    // IN HANDLE hHandle,
		INFINITE                            // IN DWORD dwMilliseconds
		);
	if( dwRet != WAIT_OBJECT_0 )
	    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
	        L"WaitForSingleObject(%p,INFINITE) != WAIT_OBJECT_0", m_hSubscriptionsInitializeEvent);
}


/*++

Routine Description:

    Gets the simulate snapshot function pointers.

Called by:

	CVsServiceModule::ServiceMain

Throws:

    E_UNEXPECTED
        - WaitForSingleObject failures

--*/
void CVsServiceModule::GetSimulateFunctions(
        OUT PFunc_SimulateSnapshotFreezeInternal *ppvSimulateFreeze,
        OUT PFunc_SimulateSnapshotThawInternal *ppvSimulateThaw )
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::GetSimulateFunctions" );
    //
    //  Must wait for the shim to finish subscribing before accessing the
    //  internal freeze and thaw functions; otherwise the two m_pvFuncXXXX
    //  vars will be NULL.
    //
	WaitForSubscribingCompletion();
    if ( ppvSimulateFreeze != NULL )
        *ppvSimulateFreeze = m_pvFuncSimulateSnapshotFreezeInternal;
    if ( ppvSimulateThaw != NULL )
        *ppvSimulateThaw = m_pvFuncSimulateSnapshotThawInternal;
};



///////////////////////////////////////////////////////////////////////////////////////
// Service initialization, running and finalization routines
//


void CVsServiceModule::OnInitializing()

/*++

Routine Description:

    Initialize the service.

	If the m_status.dwWin32ExitCode is S_OK then initialization succeeded.
	Otherwise ServiceMain must silently shutdown the service.

Called by:

	CVsServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::OnInitializing" );

    m_dwThreadID = GetCurrentThreadId();

    // Initialize the COM library
    ft.hr = CoInitializeEx(
            NULL,
            COINIT_MULTITHREADED
            );
    if (ft.HrFailed()) {
	    ft.LogError(VSS_ERROR_STARTING_SERVICE_CO_INIT_FAILURE, VSSDBG_COORD << ft.hr );
        ft.Throw( VSSDBG_COORD, ft.hr, L" Error: CoInitialize(NULL) returned 0x%08lx", ft.hr );
    }

    BS_ASSERT( ft.hr == S_OK );

    m_bCOMStarted = true;

    // Initialize COM security
    ft.hr = CoInitializeSecurity(
           NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
           -1,                                  //  IN LONG                         cAuthSvc,
           NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
           NULL,                                //  IN void                        *pReserved1,
           RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
           RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
           NULL,                                //  IN void                        *pAuthList,
           EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
           NULL                                 //  IN void                        *pReserved3
           );
    if (ft.HrFailed()) {
	    ft.LogError(VSS_ERROR_STARTING_SERVICE_CO_INITSEC_FAILURE, VSSDBG_COORD << ft.hr );
        ft.Throw( VSSDBG_COORD, ft.hr,
                  L" Error: CoInitializeSecurity() returned 0x%08lx", ft.hr );
    }

	// Create the event needed to synchronize
	BS_ASSERT(m_hShutdownTimer == NULL);
	m_hShutdownTimer = CreateWaitableTimer(
		NULL,       //  IN LPSECURITY_ATTRIBUTES lpEventAttributes,
		TRUE,       //  IN BOOL bManualReset,
		NULL        //  IN LPCTSTR lpName
		);
	if ( m_hShutdownTimer == NULL ) {
	    if (GetLastError() != ERROR_OUTOFMEMORY)
    	    ft.LogError(VSS_ERROR_STARTING_SERVICE_UNEXPECTED_INIT_FAILURE, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()));
		ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
				  L"Error creating the shutdown timer 0x%08lx", GetLastError() );
    }

	// Create the event needed to synchronize
	BS_ASSERT(m_hSubscriptionsInitializeEvent == NULL);
	m_hSubscriptionsInitializeEvent = CreateEvent(
		NULL,       //  IN LPSECURITY_ATTRIBUTES lpEventAttributes,
		TRUE,       //  IN BOOL bManualReset,
		FALSE,      //  IN BOOL bInitialState,
		NULL        //  IN LPCTSTR lpName
		);
	if ( m_hSubscriptionsInitializeEvent == NULL ) {
	    if (GetLastError() != ERROR_OUTOFMEMORY)
    	    ft.LogError(VSS_ERROR_STARTING_SERVICE_UNEXPECTED_INIT_FAILURE, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()));
		ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
				  L"Error creating the subscriptions sync event 0x%08lx", GetLastError() );
    }

    //  Register the COM class objects
    ft.hr = RegisterClassObjects( CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE );
    if (ft.HrFailed()) {
	    if (GetLastError() != ERROR_OUTOFMEMORY)
    	    ft.LogError(VSS_ERROR_STARTING_SERVICE_CLASS_REG, VSSDBG_COORD << ft.hr);
        ft.Throw( VSSDBG_COORD, ft.hr, L" Error: RegisterClassObjects() returned 0x%08lx", ft.hr );
    }
	
	// The service is started now to prevent the service startup from
	// timing out.  The COM registration is done after we fully complete
	// initialization
	SetServiceStatus(SERVICE_RUNNING);

	// startup sql writer if not already started.
	g_SqlWrapper.CreateSqlWriter();

	// register the shim snapshot writers
	RegisterSnapshotSubscriptions( &m_pvFuncSimulateSnapshotFreezeInternal, &m_pvFuncSimulateSnapshotThawInternal );

    // Mark that all the subscriptiuons are initialized
	if (!::SetEvent( m_hSubscriptionsInitializeEvent )) {
	    ft.LogError(VSS_ERROR_STARTING_SERVICE_UNEXPECTED_INIT_FAILURE, VSSDBG_COORD << HRESULT_FROM_WIN32(GetLastError()));
		ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
				L"Error on setting the sub sync event 0x%08lx", GetLastError());
	}
}



void CVsServiceModule::OnRunning()

/*++

Routine Description:

    Keeps the service alive until the job is done.

Called by:

	CVsServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::OnRunning" );

	// Wait for shutdown
	DWORD dwRet = WaitForSingleObject(
		m_hShutdownTimer,                   // IN HANDLE hHandle,
		INFINITE                            // IN DWORD dwMilliseconds
		);
	if( dwRet != WAIT_OBJECT_0 )
	    ft.TranslateGenericError(VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
	        L"WaitForSingleObject(%p,INFINITE) != WAIT_OBJECT_0", m_hShutdownTimer);

    // Trace the fact that the service will be shutdown
	ft.Trace( VSSDBG_COORD, L"VSSVC: %s event received",
	    m_bShutdownInProgress? L"Shutdown": L"Idle timeout");
}


void CVsServiceModule::OnStopping()

/*++

Routine Description:

    Performs the uninitialization tasks.

Called by:

	CVsServiceModule::ServiceMain

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::OnStopping" );

    try
    {
        g_SqlWrapper.DestroySqlWriter();

        //  Unregister the COM classes
        ft.hr = RevokeClassObjects();
        if (ft.HrFailed())
            ft.Trace( VSSDBG_COORD, L" Error: RevokeClassObjects returned hr = 0x%08lx", ft.hr );

		UnRegisterPnPNotifications();

		// Remove the providers array
		CVssProviderManager::UnloadInternalProvidersArray();

		// Remove the global cached interfaces
		CVssProviderManager::UnloadGlobalProviderItfCache();

		// Remove state from all stateful objects
		CVssProviderManager::DeactivateAll();

		UnregisterSnapshotSubscriptions();
        m_pvFuncSimulateSnapshotFreezeInternal = NULL;
        m_pvFuncSimulateSnapshotThawInternal = NULL;

        // Uninitialize the COM library
        if ( m_bCOMStarted )
            CoUninitialize();

        // Close the handles
		if ( !::CloseHandle( m_hShutdownTimer ) )
			ft.Trace( VSSDBG_COORD, L"Error closing the shutdown event 0x%08lx", GetLastError() );

		if ( !::CloseHandle( m_hSubscriptionsInitializeEvent ) )
			ft.Trace( VSSDBG_COORD, L"Error closing the sub sync event 0x%08lx", GetLastError() );
    }
    VSS_STANDARD_CATCH(ft)
}


void CVsServiceModule::OnSignalShutdown()

/*++

Routine Description:

    Called when the current service should not be stopping its activity.
	Too bad about COM calls in progress - the running clients will get an error.

Called by:

	CVsServiceModule::Handler

--*/

{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::OnSignalShutdown" );

    try
    {
        LARGE_INTEGER liDueTime;
        liDueTime.QuadPart = llVSSVCShutdownTimeout;

        // Trace the fact that the service will be shutdown
		ft.Trace( VSSDBG_COORD, L"VSSVC: Trying to shutdown the service");

        // Set the timer to become signaled immediately.
		if (!::SetWaitableTimer( m_hShutdownTimer, &liDueTime, 0, NULL, NULL, FALSE))
			ft.Throw( VSSDBG_COORD, HRESULT_FROM_WIN32(GetLastError()),
        		L"Error on setting the shutdown event 0x%08lx", GetLastError());
		BS_ASSERT(GetLastError() == 0);
		m_bShutdownInProgress = true;
    }
    VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed()) {
		m_status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
		m_status.dwServiceSpecificExitCode = ft.hr;
	}
}


///////////////////////////////////////////////////////////////////////////////////////
// Service WinMain-related methods
//


LONG CVsServiceModule::Lock()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::Lock" );

    // If we are not shutting down then we are cancelling the "idle timeout" timer.
    if (!m_bShutdownInProgress) {

        // Trace the fact that the idle period is done.
    	ft.Trace( VSSDBG_COORD, L"VSSVC: Idle period is finished");

        // Cancel the timer
        if (!::CancelWaitableTimer(m_hShutdownTimer))
            ft.Warning(VSSDBG_COORD, L"Error cancelling the waitable timer 0x%08lx",
                GetLastError());
    }

    return CComModule::Lock();
}


LONG CVsServiceModule::Unlock()
{
    CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::Unlock" );

    // Check if we entered in the idle period.
    LONG lRefCount = CComModule::Unlock();
    if ( lRefCount == 0) {
        LARGE_INTEGER liDueTime;
        liDueTime.QuadPart = llVSSVCIdleTimeout;

        // Trace the fact that the idle period begins
    	ft.Trace( VSSDBG_COORD, L"VSSVC: Idle period begins");

        // Set the timer to become signaled after the proper idle time.
        // We cannot fail at this point (BUG 265455)
		if (!::SetWaitableTimer( m_hShutdownTimer, &liDueTime, 0, NULL, NULL, FALSE))
		    ft.LogGenericWarning( VSSDBG_COORD, L"SetWaitableTimer(...) [0x%08lx]", GetLastError());
		BS_ASSERT(GetLastError() == 0);
		
        return 0;
    }
    return lRefCount;
}



///////////////////////////////////////////////////////////////////////////////////////
// Service WinMain-related methods
//



LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (*p1 != NULL)
    {
        LPCTSTR p = p2;
        while (*p != NULL)
        {
            if (*p1 == *p++)
                return p1+1;
        }
        p1++;
    }
    return NULL;
}


extern "C" int WINAPI _tWinMain(
    IN HINSTANCE hInstance,
    IN HINSTANCE, /* hPrevInstance */
    IN LPTSTR lpCmdLine,
    IN int /* nShowCmd */
    )
{
    return _Module._WinMain( hInstance, lpCmdLine );
}


int WINAPI CVsServiceModule::_WinMain(
    IN HINSTANCE hInstance,
    IN LPTSTR /* lpCmdLine */
    )

/*++

Routine Description:

    Called in the main execution path.
	Used to:
		- start the service, if no parameters on the command line.
		- register the service, if the "/Register" or "-Register" command line parameter is present

Called by:

    _WinMain()

--*/

{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVsServiceModule::_WinMain");

    try
    {
		// Get the command line
        LPTSTR lpCmdLine = GetCommandLine();
        ft.Trace( VSSDBG_COORD, L"Trace: VSS command-line: '%s'", T2W(lpCmdLine) );

        // Set the reporting mode for ATLASSERT and BS_ASSERT macros.
//        VssSetDebugReport(VSS_DBG_TO_DEBUG_CONSOLE);

		// Initialize the internal variables
        Init(ObjectMap, hInstance);
        m_hInstance = hInstance;

		// Parse the command line
        TCHAR szTokens[] = _T("-/");
        LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);

		bool bRegisterTentative = false;
        while (lpszToken != NULL)
        {
			ft.Trace( VSSDBG_COORD, L"Current token = \'%s\'", lpszToken );

            // Register as Server
            if (lstrcmpi(lpszToken, _T("Register"))==0)
			{
				bRegisterTentative = true;
                ft.hr = RegisterServer(TRUE);
				break;
			}

			lpszToken = FindOneOf(lpszToken, szTokens);
        }

		// Start the dispatcher function
		if (!bRegisterTentative)
			StartDispatcher();
    }
    VSS_STANDARD_CATCH(ft)

    // When we get here, the service has been stopped
    return m_status.dwWin32ExitCode;
}


// register for volume arrival
void CVsServiceModule::RegisterPnPNotifications()
	{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVsServiceModule::RegisterPnPNotifications");

    DEV_BROADCAST_DEVICEINTERFACE  Filter;

    Filter.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    Filter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    Filter.dbcc_reserved = 0;

    memcpy(&Filter.dbcc_classguid, (LPGUID)&DiskClassGuid, sizeof(GUID));
    m_hDiskNotify = RegisterDeviceNotification
					(
					(HANDLE) m_hServiceStatus,
					&Filter,
					DEVICE_NOTIFY_SERVICE_HANDLE
					);

    if (!m_hDiskNotify)
		{
		if (UnregisterDeviceNotification(m_hDiskNotify))
			m_hDiskNotify = NULL;

		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_COORD, L"RegisterDeviceNotification");
		}
	}

void CVsServiceModule::UnRegisterPnPNotifications()
	{
	CVssFunctionTracer ft(VSSDBG_COORD, L"CVSServiceModule::UnRegisterPnPNotifications");
    if (m_hDiskNotify)
		{
        if (!UnregisterDeviceNotification(m_hDiskNotify))
			{
			ft.hr = HRESULT_FROM_WIN32(GetLastError());
			ft.CheckForError(VSSDBG_COORD, L"UnregisterDeviceNotification");
            }

		m_hDiskNotify = NULL;
        }

    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\filter\filter.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Abstract:

    @doc
    @module filter.cxx | publisher filter for IVssWriter event
    @end

Author:

    Brian Berkowitz  [brianb]  11/09/2000

TBD:

    Add comments.

Revision History:

    Name        Date        Comments
    brianb      10/09/2000  Created.

--*/

#include <stdafx.hxx>
#include "vs_inc.hxx"
#include "sddl.h"
#include "vs_idl.hxx"
#include "lmerr.h"
#include "lmaccess.h"
#include "lmapibuf.h"
#include "vssmsg.h"

// auto sid class,  destroys sid when going out of scope
class CAutoSid
	{
public:
	CAutoSid() : m_psid(NULL)
		{
		}

	~CAutoSid()
		{
		if (m_psid)
			LocalFree(m_psid);
		}

	// create a sid base on a well known sid type
	void CreateBasicSid(WELL_KNOWN_SID_TYPE type);

	// create a sid from a string
	void CreateFromString(LPCWSTR wsz);

	// return pointer to sid
	SID *GetSid() { return m_psid; }

	void Empty()
		{
		LocalFree(m_psid);
		m_psid = NULL;
		}
private:
	SID *m_psid;

	};

// create a basic well known sid such as LOCAL_SERVICE, LOCAL_SYSTEM,
// or NETWORK_SERVICE.
void CAutoSid::CreateBasicSid(WELL_KNOWN_SID_TYPE type)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CAutoSid::CreateBasicSid");

	BS_ASSERT(m_psid == NULL);

	DWORD cbSid = 0;
	CreateWellKnownSid(type, NULL, NULL, &cbSid);
	DWORD dwErr = GetLastError();
	if (dwErr != ERROR_INSUFFICIENT_BUFFER)
		{
		ft.hr = HRESULT_FROM_WIN32(dwErr);
		ft.CheckForError(VSSDBG_GEN, L"CreateWellKnownSidType");
		}

	m_psid = (SID *) LocalAlloc(0, cbSid);
	if (m_psid == NULL)
		ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Cannot allocate SID");

	if (!CreateWellKnownSid(type, NULL, m_psid, &cbSid))
		{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_GEN, L"CreateWellKnownSidType");
		}
	}

// create a sid based on a STRING sid
void CAutoSid::CreateFromString(LPCWSTR wsz)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CAutoSid::CreateFromString");

	if (!ConvertStringSidToSid (wsz, (PSID *) &m_psid))
		{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_GEN, L"ConvertStringSidToSid");
		}
	}



// filter class
class CVssWriterPublisherFilter : public IMultiInterfacePublisherFilter
	{
public:
	// constructor
	CVssWriterPublisherFilter(IMultiInterfaceEventControl *pControl);

	// destructor
	~CVssWriterPublisherFilter();

	STDMETHOD(Initialize)(IMultiInterfaceEventControl *pEc);
	STDMETHOD(PrepareToFire)(REFIID iid, BSTR bstrMethod, IFiringControl *pFiringControl);

	STDMETHOD(QueryInterface)(REFIID riid, void **ppvUnknown);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	static void CreatePublisherFilter
		(
		IN IMultiInterfaceEventControl *pControl,
		IN const VSS_ID *rgWriterClassId,
		IN UINT cWriterClassId,
		IN const VSS_ID *rgInstanceIdInclude,
		IN UINT  cInstanceIdInclude,
		IN bool bMetadataFire,
		IN bool bIncludeWriterClasses,
		OUT IMultiInterfacePublisherFilter **ppFilter
		);

private:
	// setup well known sids
	void SetupGenericSids();

	// setup id arrays
	void SetupIdArrays
		(
		IN const VSS_ID *rgWriterClassId,
		IN UINT cWriterClassId,
		IN const VSS_ID *rgInstanceIdInclude,
		IN UINT cInstanceIdInclude,
		IN bool bFireAll,
		IN bool bIncludeWriterClasses
		);
		

	// determine if a SID is a member of a local group
	bool IsSidInGroup(SID *psid, LPCWSTR wszGroup);

	// test whether a subscription should be included
	bool TestSubscriptionMembership(IEventSubscription *pSubscription);

	// cached pointer to event control
	CComPtr<IMultiInterfaceEventControl> m_pControl;

	// reference count
	LONG m_cRef;

	// well known sids

	// local service
	CAutoSid m_asidLocalService;

	// local system
	CAutoSid m_asidLocalSystem;

	// network service
	CAutoSid m_asidNetworkService;

	// Administrators
	CAutoSid m_asidAdministrators;

	// backup operators
	CAutoSid m_asidBackupOperators;

	// name of administrators group
	WCHAR m_wszAdministrators[MAX_PATH];

	// name of backup operators group
	WCHAR m_wszBackupOperators[MAX_PATH];

	// have well known sids beeen compouted
	bool m_bSidsAssigned;

	// array of writer class ids
	VSS_ID *m_rgWriterClassId;

	// size of array
	UINT m_cWriterClassId;

	// array of instance ids to include
	VSS_ID *m_rgInstanceIdInclude;

	// count of instance ids to include
	UINT m_cInstanceIdInclude;

	// fire all writers
	bool m_bMetadataFire;

	// exclude or include writer classes
	bool m_bIncludeWriterClasses;
	};

// constructor
CVssWriterPublisherFilter::CVssWriterPublisherFilter(IMultiInterfaceEventControl *pControl) :
	m_cRef(0),
	m_pControl(pControl),
	m_bSidsAssigned(false),
	m_rgWriterClassId(NULL),
	m_rgInstanceIdInclude(NULL),
	m_cWriterClassId(0),
	m_cInstanceIdInclude(0),
	m_bIncludeWriterClasses(false)
	{
	}

CVssWriterPublisherFilter::~CVssWriterPublisherFilter()
	{
	// delete array of class ids
	delete m_rgWriterClassId;

	// delete array of instance ids
	delete m_rgInstanceIdInclude;
	}

// create a publisher filter and return an interface pointer to it
void CVssWriterPublisherFilter::CreatePublisherFilter
	(
	IN IMultiInterfaceEventControl *pControl,
	IN const VSS_ID *rgWriterClassId,
	IN UINT cWriterClassId,
	IN const VSS_ID *rgInstanceIdInclude,
	IN UINT cInstanceIdInclude,
	IN bool bMetadataFire,
	IN bool bIncludeWriterClasses,
	OUT IMultiInterfacePublisherFilter **ppFilter
	)
	{
	CVssWriterPublisherFilter *pFilter = new CVssWriterPublisherFilter(pControl);
	if (pFilter == NULL)
		throw E_OUTOFMEMORY;

	// setup filtering arrays based on writer class and instance ids
	pFilter->SetupIdArrays
		(
		rgWriterClassId,
		cWriterClassId,
		rgInstanceIdInclude,
		cInstanceIdInclude,
		bMetadataFire,
		bIncludeWriterClasses
		);

    // get publisher filter interface
	pFilter->QueryInterface(IID_IMultiInterfacePublisherFilter, (void **) ppFilter);
	}

// query interface method
STDMETHODIMP CVssWriterPublisherFilter::QueryInterface(REFIID riid, void **ppvUnk)
	{
	if (riid == IID_IUnknown)
		*ppvUnk = (IUnknown *) this;
	else if (riid == IID_IMultiInterfacePublisherFilter)
		*ppvUnk = (IMultiInterfacePublisherFilter *) (IUnknown *) this;
	else
		return E_NOINTERFACE;

	((IUnknown *) (*ppvUnk))->AddRef();
	return S_OK;
	}

// add ref method
STDMETHODIMP_(ULONG) CVssWriterPublisherFilter::AddRef()
	{
	LONG cRef = InterlockedIncrement(&m_cRef);

	return (ULONG) cRef;
	}

// release method
STDMETHODIMP_(ULONG) CVssWriterPublisherFilter::Release()
	{
	LONG cRef = InterlockedDecrement(&m_cRef);

	if (cRef == 0)
		{
		delete this;

		return 0;
		}
	else
		return (ULONG) cRef;
	}



// initialize method (does nothing.  All the work is done in PrepareToFire)
STDMETHODIMP CVssWriterPublisherFilter::Initialize
	(
	IMultiInterfaceEventControl *pec
	)
	{
	UNREFERENCED_PARAMETER(pec);

	return S_OK;
	}

void CVssWriterPublisherFilter::SetupIdArrays
	(
	IN const VSS_ID *rgWriterClassId,
	UINT cWriterClassId,
	IN const VSS_ID *rgInstanceIdInclude,
	UINT cInstanceIdInclude,
	bool bMetadataFire,
	bool bIncludeWriterClasses
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriterPublisherFilter::SetupIdArrays");

	m_bMetadataFire = bMetadataFire;
	m_bIncludeWriterClasses = bIncludeWriterClasses;

	if (cWriterClassId)
		{
		// copy writer class id array
		m_rgWriterClassId = new VSS_ID[cWriterClassId];

		// check for allocation failure
		if (m_rgWriterClassId == NULL)
			ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Cannot allocate writer class id array");

		memcpy(m_rgWriterClassId, rgWriterClassId, cWriterClassId * sizeof(VSS_ID));
		m_cWriterClassId = cWriterClassId;
		}

	if (cInstanceIdInclude)
		{
		// copy writer instance id array
		m_rgInstanceIdInclude = new VSS_ID[cInstanceIdInclude];

		// check for allocation failure
		if (m_rgInstanceIdInclude == NULL)
			ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Cannot allocate instance id include array");

		memcpy(m_rgInstanceIdInclude, rgInstanceIdInclude, cInstanceIdInclude*sizeof(VSS_ID));
		m_cInstanceIdInclude = cInstanceIdInclude;
		}
	}


		
// setup well known sids so that they only are computed once
void CVssWriterPublisherFilter::SetupGenericSids()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssPublisherFilter::SetupGenericSids");

	if (m_bSidsAssigned)
		return;

	m_asidLocalService.Empty();
	m_asidLocalSystem.Empty();
	m_asidNetworkService.Empty();

	// setup sids for allowable writers
	m_asidLocalService.CreateBasicSid(WinLocalServiceSid);
	m_asidLocalSystem.CreateBasicSid(WinLocalSystemSid);
	m_asidNetworkService.CreateBasicSid(WinNetworkServiceSid);
	m_asidAdministrators.CreateBasicSid(WinBuiltinAdministratorsSid);
	m_asidBackupOperators.CreateBasicSid(WinBuiltinBackupOperatorsSid);

	DWORD cbName = MAX_PATH;
	WCHAR wszDomain[MAX_PATH];
	DWORD cbDomainName = MAX_PATH;
	SID_NAME_USE snu;

	// lookup name of administrators group
	if (!LookupAccountSid
			(
			NULL,
			m_asidAdministrators.GetSid(),
			m_wszAdministrators,
			&cbName,
			wszDomain,
			&cbDomainName,
			&snu
			))
        {
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_GEN, L"LookupAccountSid");
		}

	// lookup name of backup operators group
	cbName = MAX_PATH;
	cbDomainName= MAX_PATH;

	if (!LookupAccountSid
			(
			NULL,
			m_asidBackupOperators.GetSid(),
			m_wszBackupOperators,
			&cbName,
			wszDomain,
			&cbDomainName,
			&snu
			))
        {
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_GEN, L"LookupAccountSid");
		}

	// indicate that sids were successfully created	
	m_bSidsAssigned = true;
	}

// is a sid a member of a local group
bool CVssWriterPublisherFilter::IsSidInGroup(SID *psid, LPCWSTR wszGroup)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriterPublisherFilter::IsSidInGroup");

	NET_API_STATUS status;
	BYTE *buffer;
	DWORD_PTR ResumeHandle = NULL;
	DWORD cEntriesRead, cEntriesTotal;

	// get list of local group members
	status = NetLocalGroupGetMembers
				(
				NULL,
				wszGroup,
				0,
				&buffer,
				MAX_PREFERRED_LENGTH,
				&cEntriesRead,
				&cEntriesTotal,
				&ResumeHandle
				);

    if (status != NERR_Success)
		{
		ft.hr = HRESULT_FROM_WIN32(status);
		ft.CheckForError(VSSDBG_GEN, L"NetGroupGetUsers");
		}

	BS_ASSERT(cEntriesRead == cEntriesTotal);

	bool bFound = false;
	try
		{
		LOCALGROUP_MEMBERS_INFO_0 *rgMembers = (LOCALGROUP_MEMBERS_INFO_0 *) buffer;

		// loop through member list to see if any sids mach the sid of the owner
		// of the subscription
		for(DWORD iEntry = 0; iEntry < cEntriesRead; iEntry++)
			{
			PSID psidMember = rgMembers[iEntry].lgrmi0_sid;
			if (EqualSid(psidMember, psid))
				{
				bFound = true;
				break;
				}
			}
		}
	VSS_STANDARD_CATCH(ft)

	// free buffer allocated in NetLocalGroupGetMembers
	NetApiBufferFree(buffer);
	if (ft.HrFailed())
		{
		HRESULT hr = ft.hr;
		throw hr;
		}

	return bFound;
	}


// key method that determines which subscriptions shoud receive the event
STDMETHODIMP CVssWriterPublisherFilter::PrepareToFire
	(
	REFIID iid,
	BSTR bstrMethod,
	IFiringControl *pFiringControl
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriterPublisherFilter::PrepareToFire");

	BS_ASSERT(iid == IID_IVssWriter);
	// validate iid we are being called on
	if (iid != IID_IVssWriter)
		return E_INVALIDARG;

	try
		{
		// setup sids if not done so already
		SetupGenericSids();

		CComPtr<IEventObjectCollection> pCollection;
		int location;

		// get subscriptions
		ft.hr = m_pControl->GetSubscriptions
					(
					IID_IVssWriter,
					bstrMethod,
					NULL,
					&location,
					&pCollection
					);

		ft.CheckForError(VSSDBG_GEN, L"IMultiInterfaceEventControl::GetSubscriptions");

		// create enumerator
		CComPtr<IEnumEventObject> pEnum;
		ft.hr = pCollection->get_NewEnum(&pEnum);
		ft.CheckForError(VSSDBG_GEN, L"IEventObjectCollection::get_NewEnum");

		while(TRUE)
			{
			CComPtr<IEventSubscription> pSubscription;
			DWORD cElt;

			// get next subscription
			ft.hr = pEnum->Next(1, (IUnknown **) &pSubscription, &cElt);
			ft.CheckForError(VSSDBG_GEN, L"IEnumEventObject::Next");
			if (ft.hr == S_FALSE)
				break;

			// get owner of subscription
			CComBSTR bstrSID;
			ft.hr = pSubscription->get_OwnerSID(&bstrSID);
			ft.CheckForError(VSSDBG_GEN, L"IEventSubscription::get_OwnerSID");

			// convert string representation to sid
			CAutoSid asid;
			asid.CreateFromString(bstrSID);
			SID *psid = asid.GetSid();

			// determine if subscription should be fired
			bool bFire = false;

			if (EqualSid(psid, m_asidLocalSystem.GetSid()) ||
				EqualSid(psid, m_asidLocalService.GetSid()) ||
				EqualSid(psid, m_asidNetworkService.GetSid()))

				// fire if owner is LOCALSYSTEM, LOCALSERVICE, or NETWORKSERVICE
				bFire = true;
			else if (IsSidInGroup(psid, m_wszAdministrators) ||
					 IsSidInGroup(psid, m_wszBackupOperators))

                // fire if owner is a member of the Administrators
				// or Backup Operators group
				bFire = true;

            // finally make sure that we should fire the subscription
			// based on our writer class and instance lists
			if (bFire && TestSubscriptionMembership(pSubscription))
				pFiringControl->FireSubscription(pSubscription);
			}

		ft.hr = S_OK;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

// test whether a subscription should be fired based on its writer id and
// subscription id.  If the appropriate properties do not exist or are not
// well formed, then we don't fire the subscription.

bool CVssWriterPublisherFilter::TestSubscriptionMembership
	(
	IEventSubscription *pSubscription
	)
	{
	if (m_cWriterClassId)
		{
		VARIANT varWriterId;
		HRESULT hr;

		// initialize variant
		VariantInit(&varWriterId);

		// get writer class id property
		hr = pSubscription->GetSubscriberProperty(L"WriterId", &varWriterId);

		// validate that the property id was found and that its type is correct
		if (hr != S_OK || varWriterId.vt != VT_BSTR)
			{
			VariantClear(&varWriterId);
			return false;
			}

		VSS_ID WriterId;

		// try converting the string to a GUID.
		hr = CLSIDFromString(varWriterId.bstrVal, (LPCLSID) &WriterId);
		if (FAILED(hr))
			{
			VariantClear(&varWriterId);
			return false;
			}

		// test to see if writer class is in array
		for (UINT iWriterId = 0; iWriterId < m_cWriterClassId; iWriterId++)
			{
			if (m_rgWriterClassId[iWriterId] == WriterId)
				{
				// if the writer class id is in the list then we fire the
				// subscription if we enabled specific writer classes and
				// we are firing to gather metadata.  We don't fire the
				// subscription if we disable specific writerc classes

				VariantClear(&varWriterId);

				if (!m_bIncludeWriterClasses)
					return false;
				else
					return m_bMetadataFire;
				}
			}

		VariantClear(&varWriterId);
		}

	// if we are firing to gather metadata then we fire the subscription if
	// we were not enabling specific writer classes.  If we were, then the
	// class must be in the writer class array to be fired
	if (m_bMetadataFire)
		return !m_bIncludeWriterClasses;


	// the subscription is now only fired if the specific instance id is
	// in the instance id array.
	if (m_cInstanceIdInclude)
		{
		VARIANT varInstanceId;
		HRESULT hr;

		VariantInit(&varInstanceId);

		// get writer instance id property
		hr = pSubscription->GetSubscriberProperty(L"WriterInstanceId", &varInstanceId);

		// validate that the property was found and that its type is correct
		if (hr != S_OK || varInstanceId.vt != VT_BSTR)
			{
			VariantClear(&varInstanceId);
			return false;
			}

		VSS_ID InstanceId;

		// try converting the string to a GUID.
		hr = CLSIDFromString(varInstanceId.bstrVal, (LPCLSID) &InstanceId);
		if (FAILED(hr))
			{
			VariantClear(&varInstanceId);
			return false;
			}

		// test to see if writer is included
		for (UINT iInstanceId = 0; iInstanceId < m_cInstanceIdInclude; iInstanceId++)
			{
			if (m_rgInstanceIdInclude[iInstanceId] == InstanceId)
				{
				VariantClear(&varInstanceId);
				return true;
				}
			}

		VariantClear(&varInstanceId);
		}

	// don't fire the subscription.  It wasn't in the list of writer instances
	// to fire.
	return false;
	}


// setup a filter on an event object
void SetupPublisherFilter
	(
	IN IVssWriter *pWriter,					// subscriber
	IN const VSS_ID *rgWriterClassId,		// array of writer class ids
	IN UINT cWriterClassId,					// size of writer class id array
	IN const VSS_ID *rgInstanceIdInclude,	// array of writer instance ids	to include
	IN UINT cInstanceIdInclude,				// size of array of writer instances
	IN bool bMetadataFire,					// whether we are gathering metadata
	IN bool bIncludeWriterClasses			// whether class id array should be used to
											// enable or disable specific writer classes
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"SetupPublisherFilter");

	CComPtr<IMultiInterfaceEventControl> pControl;

	// get event control interface
	ft.hr = pWriter->QueryInterface(IID_IMultiInterfaceEventControl, (void **) &pControl);
	if (ft.HrFailed())
		{
		ft.LogError(VSS_ERROR_QI_IMULTIINTERFACEEVENTCONTROL_FAILED, VSSDBG_GEN << ft.hr);
		ft.Throw
			(
			VSSDBG_GEN,
			E_UNEXPECTED,
			L"Error querying for IMultiInterfaceEventControl interface.  hr = 0x%08lx",
			ft.hr
			);
        }

	// create filter
	CComPtr<IMultiInterfacePublisherFilter> pFilter;
	CVssWriterPublisherFilter::CreatePublisherFilter
		(
		pControl,
		rgWriterClassId,
		cWriterClassId,
		rgInstanceIdInclude,
		cInstanceIdInclude,
		bMetadataFire,
		bIncludeWriterClasses,
		&pFilter
		);

	// set filter for event
	ft.hr = pControl->SetMultiInterfacePublisherFilter(pFilter);
	ft.CheckForError(VSSDBG_GEN, L"IMultiInterfaceEventControl::SetMultiInterfacePublisherFilter");

	// indicate that subscriptions should be fired in parallel
	ft.hr = pControl->put_FireInParallel(TRUE);
	ft.CheckForError(VSSDBG_GEN, L"IMultiInterfaceEventControl::put_FireInParallel");
	}

// clear the publisher filter from an event
void ClearPublisherFilter(IVssWriter *pWriter)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"ClearPublisherFilter");

	try
		{
		CComPtr<IMultiInterfaceEventControl> pControl;

		// get event control interface
		ft.hr = pWriter->QueryInterface(IID_IMultiInterfaceEventControl, (void **) &pControl);
		if (ft.HrFailed())
			{
			ft.LogError(VSS_ERROR_QI_IMULTIINTERFACEEVENTCONTROL_FAILED, VSSDBG_GEN << ft.hr);
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"Error querying for IMultiInterfaceEventControl interface.  hr = 0x%08lx",
				ft.hr
				);	
				}
	
		// set filter for event
		ft.hr = pControl->SetMultiInterfacePublisherFilter(NULL);
		ft.CheckForError(VSSDBG_GEN, L"IMultiInterfaceEventControl::SetMultiInterfacePublisherFilter");
		}
	VSS_STANDARD_CATCH(ft)

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\prop\pointer.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Pointer.cxx | Implementation of VSS_OBJECT_PROP_Ptr class
    @end

Author:

    Adi Oltean  [aoltean]  09/21/1999

Revision History:

    Name        Date        Comments

    aoltean     09/21/1999	VSS_OBJECT_PROP_Ptr as a pointer to the properties structure.
							This pointer will serve as element in CSimpleArray constructs.
	aoltean		09/22/1999	Adding InitializeAsEmpty and Print
	aoltean		09/24/1999	Moving into modules/prop
	aoltean		03/27/2000	Adding Writers
	aoltean		03/01/2001	Adding mgmt objects

--*/


/////////////////////////////////////////////////////////////////////////////
//  Needed includes


#include "stdafx.hxx"

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "copy.hxx"	
#include "pointer.hxx"	

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "PRPPNTRC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  VSS_OBJECT_PROP_Ptr class


void VSS_OBJECT_PROP_Ptr::InitializeAsSnapshot(
    IN  CVssFunctionTracer& ft,
	IN  VSS_ID SnapshotId,
	IN  VSS_ID SnapshotSetId,
	IN  LONG lSnapshotsCount,
	IN  VSS_PWSZ pwszSnapshotDeviceObject,
	IN  VSS_PWSZ pwszOriginalVolumeName,
	IN  VSS_PWSZ pwszOriginatingMachine,
	IN  VSS_PWSZ pwszServiceMachine,
	IN  VSS_PWSZ pwszExposedName,
	IN  VSS_PWSZ pwszExposedPath,
	IN  VSS_ID ProviderId,
	IN  LONG lSnapshotAttributes,
	IN  VSS_TIMESTAMP tsCreationTimestamp,
	IN  VSS_SNAPSHOT_STATE eStatus
    ) throw (HRESULT)
/*++

Routine description:

    Initialize a VSS_OBJECT_PROP_Ptr in order to keep a VSS_OBJECT_SNAPSHOT structure.

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_OBJECT_PROP_Ptr::InitializeAsSnapshot";
	VSS_OBJECT_PROP* pProp = NULL;

    try
    {
		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_OBJECT_UNION structure
        pProp = static_cast<VSS_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_OBJECT_PROP_Copy::init(pProp);
        pProp->Type = VSS_OBJECT_SNAPSHOT;

        // Getting the equivalent VSS_SNAPSHOT_PROP structure
        BS_ASSERT(pProp);
		VSS_SNAPSHOT_PROP& SnapshotProp = pProp->Obj.Snap;

		// Setting the internal members
		SnapshotProp.m_SnapshotId			= SnapshotId;
		SnapshotProp.m_SnapshotSetId		= SnapshotSetId;
		SnapshotProp.m_lSnapshotsCount      = lSnapshotsCount;
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszSnapshotDeviceObject, pwszSnapshotDeviceObject);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszOriginalVolumeName, pwszOriginalVolumeName);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszOriginatingMachine, pwszOriginatingMachine);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszServiceMachine, pwszServiceMachine);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszExposedName, pwszExposedName);
        ::VssSafeDuplicateStr(ft, SnapshotProp.m_pwszExposedPath, pwszExposedPath);
		SnapshotProp.m_ProviderId			= ProviderId;
		SnapshotProp.m_lSnapshotAttributes	= lSnapshotAttributes;
		SnapshotProp.m_tsCreationTimestamp = tsCreationTimestamp;
		SnapshotProp.m_eStatus				= eStatus;

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		if (pProp)
		{
			VSS_OBJECT_PROP_Copy::destroy(pProp); // destroy its contents.
			::CoTaskMemFree(static_cast<LPVOID>(pProp));
		}
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_OBJECT_PROP_Ptr::InitializeAsProvider(
    IN  CVssFunctionTracer& ft,
    IN	VSS_ID ProviderId,
    IN	VSS_PWSZ pwszProviderName,
    IN  VSS_PROVIDER_TYPE eProviderType,
    IN	VSS_PWSZ pwszProviderVersion,
    IN	VSS_ID ProviderVersionId,
	IN	CLSID ClassId
    ) throw (HRESULT)
/*++

Routine description:

    Initialize a VSS_OBJECT_PROP_Ptr in order to keep a VSS_OBJECT_PROVIDER structure.

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_OBJECT_PROP_Ptr::InitializeAsProvider";
	VSS_OBJECT_PROP* pProp = NULL;

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		// Assert parameters
		BS_ASSERT(pwszProviderName == NULL || pwszProviderName[0] != L'\0');
		BS_ASSERT(eProviderType == VSS_PROV_SYSTEM ||
            eProviderType == VSS_PROV_SOFTWARE ||
            eProviderType == VSS_PROV_HARDWARE
            );

		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_OBJECT_UNION structure
        pProp = static_cast<VSS_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_OBJECT_PROP_Copy::init(pProp);
        pProp->Type = VSS_OBJECT_PROVIDER;

        // Getting the equivalent VSS_SNAPSHOT_PROP structure
        BS_ASSERT(pProp);
		VSS_PROVIDER_PROP& ProviderProp = pProp->Obj.Prov;

		// Setting the internal members
		ProviderProp.m_ProviderId		 = ProviderId;
        ::VssSafeDuplicateStr(ft, ProviderProp.m_pwszProviderName, pwszProviderName);
		ProviderProp.m_eProviderType	 = eProviderType;
        ::VssSafeDuplicateStr(ft, ProviderProp.m_pwszProviderVersion, pwszProviderVersion);
		ProviderProp.m_ProviderVersionId = ProviderVersionId;
		ProviderProp.m_ClassId			 = ClassId;

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		if (pProp)
		{
			VSS_OBJECT_PROP_Copy::destroy(pProp); // destroy its contents.
			::CoTaskMemFree(static_cast<LPVOID>(pProp));
		}
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_OBJECT_PROP_Ptr::InitializeAsEmpty(
    IN  CVssFunctionTracer& ft
	)
/*++

Routine description:

    Initialize a VSS_OBJECT_PROP_Ptr in order to appear as an empty structure (to be filled later).

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_OBJECT_PROP_Ptr::InitializeEmpty";
	VSS_OBJECT_PROP* pProp = NULL;

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_OBJECT_UNION structure
        pProp = static_cast<VSS_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_OBJECT_PROP_Copy::init(pProp);

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		BS_ASSERT(pProp == NULL);
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_OBJECT_PROP_Ptr::Print(
    IN  CVssFunctionTracer& ft,
	IN  LPWSTR wszOutputBuffer,
	IN  LONG lBufferSize
	)
{
    WCHAR wszFunctionName[] = L"VSS_OBJECT_PROP_Ptr::Print";

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		if (m_pStruct == NULL)
			::_snwprintf(wszOutputBuffer, lBufferSize, L"NULL object\n\n");

        // Effective copy
        switch(m_pStruct->Type)
        {
        case VSS_OBJECT_SNAPSHOT:

			::_snwprintf(wszOutputBuffer, lBufferSize,
				L"Id = " WSTR_GUID_FMT L", "
				L"SnapshotSetId = " WSTR_GUID_FMT L"\n"
				L"SnapCount = %ld "
				L"DevObj = %s\n"
				L"OriginalVolumeName = %s\n"
				L"OriginatingMachine = %s\n"
				L"ServiceMachine = %s\n"
				L"Exposed name = %s\n"
				L"Exposed path = %s\n"
				L"ProviderId = " WSTR_GUID_FMT L"\n"
				L"Attributes = 0x%08lx\n"
				L"Timestamp = " WSTR_LONGLONG_FMT L"\n"
				L"Status = %d\n ",
				GUID_PRINTF_ARG( m_pStruct->Obj.Snap.m_SnapshotId ),
				GUID_PRINTF_ARG( m_pStruct->Obj.Snap.m_SnapshotSetId ),
				m_pStruct->Obj.Snap.m_lSnapshotsCount,
				m_pStruct->Obj.Snap.m_pwszSnapshotDeviceObject,
				m_pStruct->Obj.Snap.m_pwszOriginalVolumeName,
				m_pStruct->Obj.Snap.m_pwszOriginatingMachine,
				m_pStruct->Obj.Snap.m_pwszServiceMachine,
				m_pStruct->Obj.Snap.m_pwszExposedName,
				m_pStruct->Obj.Snap.m_pwszExposedPath,
				GUID_PRINTF_ARG( m_pStruct->Obj.Snap.m_ProviderId ),
				m_pStruct->Obj.Snap.m_lSnapshotAttributes,
				LONGLONG_PRINTF_ARG( m_pStruct->Obj.Snap.m_tsCreationTimestamp ),
				m_pStruct->Obj.Snap.m_eStatus);
            break;

        case VSS_OBJECT_PROVIDER:
            ::_snwprintf(wszOutputBuffer, lBufferSize,
				L"m_ProviderId = " WSTR_GUID_FMT L"\n"
				L"m_pwszProviderName = %s\n"
				L"m_ProviderType = %d\n"
				L"m_pwszProviderVersion = %s\n"
				L"m_ProviderVersionId = " WSTR_GUID_FMT L"\n"
				L"m_ClassID: " WSTR_GUID_FMT L"\n\n",
                GUID_PRINTF_ARG( m_pStruct->Obj.Prov.m_ProviderId ),
                m_pStruct->Obj.Prov.m_pwszProviderName? m_pStruct->Obj.Prov.m_pwszProviderName: L"NULL",
                m_pStruct->Obj.Prov.m_eProviderType,
                m_pStruct->Obj.Prov.m_pwszProviderVersion? m_pStruct->Obj.Prov.m_pwszProviderVersion: L"NULL",
                GUID_PRINTF_ARG( m_pStruct->Obj.Prov.m_ProviderVersionId ),
                GUID_PRINTF_ARG( m_pStruct->Obj.Prov.m_ClassId )
                );
            break;

        default:
			ft.ErrBox( VSSDBG_GEN, E_UNEXPECTED,
					   L"%s: Wrong object type %d", wszFunctionName, m_pStruct->Type );
            break;
        }
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
		BS_ASSERT(m_pStruct == NULL);
		ft.Throw( VSSDBG_GEN, E_UNEXPECTED,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}



/////////////////////////////////////////////////////////////////////////////
//  VSS_MGMT_OBJECT_PROP_Ptr class


void VSS_MGMT_OBJECT_PROP_Ptr::InitializeAsVolume(
		IN  CVssFunctionTracer& ft,
 		IN  VSS_PWSZ pwszVolumeName,
 		IN  VSS_PWSZ pwszVolumeDisplayName
		) throw (HRESULT)
/*++

Routine description:

    Initialize a VSS_MGMT_OBJECT_PROP_Ptr in order to keep a VSS_MGMT_OBJECT_SNAPSHOT structure.

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_MGMT_OBJECT_PROP_Ptr::InitializeAsVolume";
	VSS_MGMT_OBJECT_PROP* pProp = NULL;

    try
    {
		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_MGMT_OBJECT_UNION structure
        pProp = static_cast<VSS_MGMT_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_MGMT_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_MGMT_OBJECT_PROP_Copy::init(pProp);
        pProp->Type = VSS_MGMT_OBJECT_VOLUME;

        // Getting the equivalent VSS_SNAPSHOT_PROP structure
        BS_ASSERT(pProp);
		VSS_VOLUME_PROP& VolumeProp = pProp->Obj.Vol;

		// Setting the internal members
        ::VssSafeDuplicateStr(ft, VolumeProp.m_pwszVolumeName, pwszVolumeName);
        ::VssSafeDuplicateStr(ft, VolumeProp.m_pwszVolumeDisplayName, pwszVolumeDisplayName);

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		if (pProp)
		{
			VSS_MGMT_OBJECT_PROP_Copy::destroy(pProp); // destroy its contents.
			::CoTaskMemFree(static_cast<LPVOID>(pProp));
		}
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_MGMT_OBJECT_PROP_Ptr::InitializeAsDiffVolume(
		IN  CVssFunctionTracer& ft,
 		IN  VSS_PWSZ pwszVolumeName,
 		IN  VSS_PWSZ pwszVolumeDisplayName,
		IN  LONGLONG llVolumeFreeSpace,
		IN  LONGLONG llVolumeTotalSpace
		) throw (HRESULT)
/*++

Routine description:

    Initialize a VSS_MGMT_OBJECT_PROP_Ptr in order to keep a VSS_MGMT_OBJECT_PROVIDER structure.

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_MGMT_OBJECT_PROP_Ptr::InitializeAsDiffVolume";
	VSS_MGMT_OBJECT_PROP* pProp = NULL;

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		// Assert parameters
		BS_ASSERT(llVolumeFreeSpace >= 0);
		BS_ASSERT(llVolumeTotalSpace >= 0);

		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_MGMT_OBJECT_UNION structure
        pProp = static_cast<VSS_MGMT_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_MGMT_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_MGMT_OBJECT_PROP_Copy::init(pProp);
        pProp->Type = VSS_MGMT_OBJECT_DIFF_VOLUME;

        // Getting the equivalent VSS_SNAPSHOT_PROP structure
        BS_ASSERT(pProp);
		VSS_DIFF_VOLUME_PROP& DiffVolumeProp = pProp->Obj.DiffVol;

		// Setting the internal members
        ::VssSafeDuplicateStr(ft, DiffVolumeProp.m_pwszVolumeName, pwszVolumeName);
        ::VssSafeDuplicateStr(ft, DiffVolumeProp.m_pwszVolumeDisplayName, pwszVolumeDisplayName);
        DiffVolumeProp.m_llVolumeFreeSpace = llVolumeFreeSpace;
        DiffVolumeProp.m_llVolumeTotalSpace = llVolumeTotalSpace;

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		if (pProp)
		{
			VSS_MGMT_OBJECT_PROP_Copy::destroy(pProp); // destroy its contents.
			::CoTaskMemFree(static_cast<LPVOID>(pProp));
		}
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_MGMT_OBJECT_PROP_Ptr::InitializeAsDiffArea(
		IN  CVssFunctionTracer& ft,
 		IN  VSS_PWSZ pwszVolumeName,
 		IN  VSS_PWSZ pwszDiffAreaVolumeName,
		IN  LONGLONG llUsedDiffSpace,
		IN  LONGLONG llAllocatedDiffSpace,
		IN  LONGLONG llMaximumDiffSpace
		) throw (HRESULT)
/*++

Routine description:

    Initialize a VSS_MGMT_OBJECT_PROP_Ptr in order to keep a VSS_MGMT_OBJECT_PROVIDER structure.

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_MGMT_OBJECT_PROP_Ptr::InitializeAsProvider";
	VSS_MGMT_OBJECT_PROP* pProp = NULL;

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		// Assert parameters
		BS_ASSERT(llUsedDiffSpace >= 0);
		BS_ASSERT(llAllocatedDiffSpace >= 0);
		BS_ASSERT((llMaximumDiffSpace >= 0) || (llMaximumDiffSpace == -1));

		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_MGMT_OBJECT_UNION structure
        pProp = static_cast<VSS_MGMT_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_MGMT_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_MGMT_OBJECT_PROP_Copy::init(pProp);
        pProp->Type = VSS_MGMT_OBJECT_DIFF_AREA;

        // Getting the equivalent VSS_SNAPSHOT_PROP structure
        BS_ASSERT(pProp);
		VSS_DIFF_AREA_PROP& DiffAreaProp = pProp->Obj.DiffArea;

		// Setting the internal members
        ::VssSafeDuplicateStr(ft, DiffAreaProp.m_pwszVolumeName, pwszVolumeName);
        ::VssSafeDuplicateStr(ft, DiffAreaProp.m_pwszDiffAreaVolumeName, pwszDiffAreaVolumeName);
        DiffAreaProp.m_llMaximumDiffSpace = llMaximumDiffSpace;
        DiffAreaProp.m_llAllocatedDiffSpace = llAllocatedDiffSpace;
        DiffAreaProp.m_llUsedDiffSpace = llUsedDiffSpace;

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		if (pProp)
		{
			VSS_MGMT_OBJECT_PROP_Copy::destroy(pProp); // destroy its contents.
			::CoTaskMemFree(static_cast<LPVOID>(pProp));
		}
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_MGMT_OBJECT_PROP_Ptr::InitializeAsEmpty(
    IN  CVssFunctionTracer& ft
	)
/*++

Routine description:

    Initialize a VSS_MGMT_OBJECT_PROP_Ptr in order to appear as an empty structure (to be filled later).

Throws:

    E_OUTOFMEMORY

--*/
{
    WCHAR wszFunctionName[] = L"VSS_MGMT_OBJECT_PROP_Ptr::InitializeEmpty";
	VSS_MGMT_OBJECT_PROP* pProp = NULL;

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		// Assert the structure pointer to be set
        BS_ASSERT(m_pStruct == NULL);

        // Allocate the VSS_MGMT_OBJECT_UNION structure
        pProp = static_cast<VSS_MGMT_OBJECT_PROP*>(::CoTaskMemAlloc(sizeof(VSS_MGMT_OBJECT_PROP)));
        if (pProp == NULL)
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
					  L"%s: Error on allocating the Properties structure",
					  wszFunctionName );

        // Initialize the structure
		VSS_MGMT_OBJECT_PROP_Copy::init(pProp);

		// Setting the pointer field
		m_pStruct = pProp;
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
	    BS_ASSERT(ft.hr == E_OUTOFMEMORY);
		BS_ASSERT(m_pStruct == NULL);
		BS_ASSERT(pProp == NULL);
		ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}


void VSS_MGMT_OBJECT_PROP_Ptr::Print(
    IN  CVssFunctionTracer& ft,
	IN  LPWSTR wszOutputBuffer,
	IN  LONG lBufferSize
	)
{
    WCHAR wszFunctionName[] = L"VSS_MGMT_OBJECT_PROP_Ptr::Print";

	// Reset the error code
	ft.hr = S_OK;
		
    try
    {
		if (m_pStruct == NULL)
			::_snwprintf(wszOutputBuffer, lBufferSize, L"NULL object\n\n");

        switch(m_pStruct->Type)
        {
        case VSS_MGMT_OBJECT_VOLUME:

			::_snwprintf(wszOutputBuffer, lBufferSize,
				L"VolumeName = %s\n"
				L"VolumeDisplayName = %s\n"
				L"lCurrentSnapshotCount = %ld \n",
				m_pStruct->Obj.Vol.m_pwszVolumeName,
				m_pStruct->Obj.Vol.m_pwszVolumeDisplayName);
            break;

        case VSS_MGMT_OBJECT_DIFF_VOLUME:
			::_snwprintf(wszOutputBuffer, lBufferSize,
				L"VolumeName = %s\n"
				L"VolumeDisplayName = %s\n"
				L"llFreeSpace = " WSTR_LONGLONG_FMT L"\n"
				L"llTotalSpace = " WSTR_LONGLONG_FMT L"\n",
				m_pStruct->Obj.DiffVol.m_pwszVolumeName,
				m_pStruct->Obj.DiffVol.m_pwszVolumeDisplayName,
				m_pStruct->Obj.DiffVol.m_llVolumeFreeSpace,
				m_pStruct->Obj.DiffVol.m_llVolumeTotalSpace);
            break;

        case VSS_MGMT_OBJECT_DIFF_AREA:
			::_snwprintf(wszOutputBuffer, lBufferSize,
				L"VolumeName = %s\n"
				L"VolumeDiffAreaName = %s\n"
				L"MaxSpace = " WSTR_LONGLONG_FMT L"\n"
				L"AllocatedSpace = " WSTR_LONGLONG_FMT L"\n"
				L"UsedSpace = " WSTR_LONGLONG_FMT L"\n",
				m_pStruct->Obj.DiffArea.m_pwszVolumeName,
				m_pStruct->Obj.DiffArea.m_pwszDiffAreaVolumeName,
				m_pStruct->Obj.DiffArea.m_llMaximumDiffSpace,
				m_pStruct->Obj.DiffArea.m_llAllocatedDiffSpace,
				m_pStruct->Obj.DiffArea.m_llUsedDiffSpace);
            break;


        default:
			ft.ErrBox( VSSDBG_GEN, E_UNEXPECTED,
					   L"%s: Wrong object type %d", wszFunctionName, m_pStruct->Type );
            break;
        }
    }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
	{
		BS_ASSERT(m_pStruct == NULL);
		ft.Throw( VSSDBG_GEN, E_UNEXPECTED,
				  L"%s: Error catched 0x%08lx", wszFunctionName, ft.hr );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\prop\copy.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Copy.cxx | Implementation of VSS_OBJECT_PROP_Copy and VSS_OBJECT_PROP_Ptr classes
    @end

Author:

    Adi Oltean  [aoltean]  09/01/1999

Remarks:

	It cannot be put into a library because of ATL code.

Revision History:

    Name        Date        Comments
    aoltean     09/01/1999  Created
    aoltean     09/09/1999  dss -> vss
	aoltean		09/13/1999	Moved to inc. Renamed to copy.inl
	aoltean		09/20/1999	Adding methods for creating the snapshot, snapshot set,
							provider and volume property structures.
							Also VSS_OBJECT_PROP_Manager renamed to VSS_OBJECT_PROP_Manager.
	aoltean		09/21/1999	Renaming back VSS_OBJECT_PROP_Manager to VSS_OBJECT_PROP_Copy.
							Moving the CreateXXX into VSS_OBJECT_PROP_Ptr::InstantiateAsXXX
	aoltean		09/22/1999	Fixing VSSDBG_GEN.
	aoltean		09/24/1999	Moving into modules/prop
	aoltean		12/16/1999	Adding specialized copyXXX methods
	aoltean     03/05/2001  Adding support for management objects

--*/


/////////////////////////////////////////////////////////////////////////////
//  Needed includes

#include "stdafx.hxx"

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include "copy.hxx"	

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "PRPCOPYC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  VSS_OBJECT_PROP_Copy class


HRESULT VSS_OBJECT_PROP_Copy::copySnapshot(
			IN	VSS_SNAPSHOT_PROP* pObj1,
			IN	VSS_SNAPSHOT_PROP* pObj2
			)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_OBJECT_PROP_Copy::copySnapshot" );

    try
    {
        // Testing arguments
        BS_ASSERT(pObj1 != NULL);
        BS_ASSERT(pObj2 != NULL);

        // Copy the members
        pObj1->m_SnapshotId = pObj2->m_SnapshotId;
        pObj1->m_SnapshotSetId = pObj2->m_SnapshotSetId;
        pObj1->m_lSnapshotsCount = pObj2->m_lSnapshotsCount;
		::VssSafeDuplicateStr( ft, pObj1->m_pwszSnapshotDeviceObject, pObj2->m_pwszSnapshotDeviceObject );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszOriginalVolumeName, pObj2->m_pwszOriginalVolumeName );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszOriginatingMachine, pObj2->m_pwszOriginatingMachine );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszServiceMachine, pObj2->m_pwszServiceMachine );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszExposedName, pObj2->m_pwszExposedName );
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszExposedPath, pObj2->m_pwszExposedPath );
        pObj1->m_ProviderId = pObj2->m_ProviderId;
        pObj1->m_lSnapshotAttributes = pObj2->m_lSnapshotAttributes;
        pObj1->m_tsCreationTimestamp = pObj2->m_tsCreationTimestamp;
        pObj1->m_eStatus = pObj2->m_eStatus;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT VSS_OBJECT_PROP_Copy::copyProvider(
		IN	VSS_PROVIDER_PROP* pObj1,
		IN	VSS_PROVIDER_PROP* pObj2
		)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_OBJECT_PROP_Copy::copyProvider" );

    try
    {
        // Testing arguments
        BS_ASSERT(pObj1 != NULL);
        BS_ASSERT(pObj2 != NULL);

        // Copy the members
        pObj1->m_ProviderId = pObj2->m_ProviderId;
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszProviderName, pObj2->m_pwszProviderName );
        pObj1->m_eProviderType = pObj2->m_eProviderType;
        ::VssSafeDuplicateStr( ft, pObj1->m_pwszProviderVersion, pObj2->m_pwszProviderVersion );
        pObj1->m_ProviderVersionId = pObj2->m_ProviderVersionId;
        pObj1->m_ClassId = pObj2->m_ClassId;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT VSS_OBJECT_PROP_Copy::copy(
		IN	VSS_OBJECT_PROP* pObj1,
		IN	VSS_OBJECT_PROP* pObj2
		)
{
	HRESULT hr;

    // Testing arguments
    if ((pObj1 == NULL) || (pObj2 == NULL))
        return E_INVALIDARG;

    // Zeroing the contents of the destination structure
    ::VssZeroOut(pObj1);

    // Copy the type
    pObj1->Type = pObj2->Type;

    // Effective copy
    switch(pObj2->Type)
    {
    case VSS_OBJECT_SNAPSHOT:
		hr = copySnapshot( &(pObj1->Obj.Snap), &(pObj2->Obj.Snap) );
        break;

    case VSS_OBJECT_PROVIDER:
		hr = copyProvider( &(pObj1->Obj.Prov), &(pObj2->Obj.Prov) );
        break;

    default:
		BS_ASSERT(false);
		hr = E_UNEXPECTED;
        break;
    }

    return hr;
}


void VSS_OBJECT_PROP_Copy::init(
		IN	VSS_OBJECT_PROP* pObjectProp
		)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_OBJECT_PROP_Copy::init" );

    try
    {
        // Zeroing the contents of the structure
        ::VssZeroOut(pObjectProp);
    }
    VSS_STANDARD_CATCH(ft)
}


void VSS_OBJECT_PROP_Copy::destroy(
		IN	VSS_OBJECT_PROP* pObjectProp
		)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_OBJECT_PROP_Copy::destroy" );

    try
    {
        if (pObjectProp)
        {
            switch(pObjectProp->Type)
            {
            case VSS_OBJECT_SNAPSHOT:
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszOriginalVolumeName);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszSnapshotDeviceObject);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszOriginatingMachine);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszServiceMachine);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszExposedName);
                ::VssFreeString(pObjectProp->Obj.Snap.m_pwszExposedPath);
                break;

            case VSS_OBJECT_PROVIDER:
                ::VssFreeString(pObjectProp->Obj.Prov.m_pwszProviderName);
                ::VssFreeString(pObjectProp->Obj.Prov.m_pwszProviderVersion);
                break;

            default:
                break;
            }
            pObjectProp->Type = VSS_OBJECT_UNKNOWN;
        }
    }
    VSS_STANDARD_CATCH(ft)
}


/////////////////////////////////////////////////////////////////////////////
//  VSS_MGMT_OBJECT_PROP_Copy class


HRESULT VSS_MGMT_OBJECT_PROP_Copy::copyVolume(
			IN	VSS_VOLUME_PROP* pObj1,
			IN	VSS_VOLUME_PROP* pObj2
			)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_MGMT_OBJECT_PROP_Copy::copyVolume" );

    try
    {
        // Testing arguments
        BS_ASSERT(pObj1 != NULL);
        BS_ASSERT(pObj2 != NULL);

        // Copy the members
		::VssSafeDuplicateStr( ft, pObj1->m_pwszVolumeName, pObj2->m_pwszVolumeName);
		::VssSafeDuplicateStr( ft, pObj1->m_pwszVolumeDisplayName, pObj2->m_pwszVolumeDisplayName);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT VSS_MGMT_OBJECT_PROP_Copy::copyDiffVolume(
			IN	VSS_DIFF_VOLUME_PROP* pObj1,
			IN	VSS_DIFF_VOLUME_PROP* pObj2
			)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_MGMT_OBJECT_PROP_Copy::copyDiffVolume" );

    try
    {
        // Testing arguments
        BS_ASSERT(pObj1 != NULL);
        BS_ASSERT(pObj2 != NULL);

        // Copy the members
		::VssSafeDuplicateStr( ft, pObj1->m_pwszVolumeName, pObj2->m_pwszVolumeName);
		::VssSafeDuplicateStr( ft, pObj1->m_pwszVolumeDisplayName, pObj2->m_pwszVolumeDisplayName);
        pObj1->m_llVolumeFreeSpace = pObj2->m_llVolumeFreeSpace;
        pObj1->m_llVolumeTotalSpace = pObj2->m_llVolumeTotalSpace;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT VSS_MGMT_OBJECT_PROP_Copy::copyDiffArea(
			IN	VSS_DIFF_AREA_PROP* pObj1,
			IN	VSS_DIFF_AREA_PROP* pObj2
			)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_MGMT_OBJECT_PROP_Copy::copyDiffArea" );

    try
    {
        // Testing arguments
        BS_ASSERT(pObj1 != NULL);
        BS_ASSERT(pObj2 != NULL);

        // Copy the members
		::VssSafeDuplicateStr( ft, pObj1->m_pwszVolumeName, pObj2->m_pwszVolumeName);
		::VssSafeDuplicateStr( ft, pObj1->m_pwszDiffAreaVolumeName, pObj2->m_pwszDiffAreaVolumeName);
        pObj1->m_llMaximumDiffSpace = pObj2->m_llMaximumDiffSpace;
        pObj1->m_llAllocatedDiffSpace = pObj2->m_llAllocatedDiffSpace;
        pObj1->m_llUsedDiffSpace = pObj2->m_llUsedDiffSpace;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


HRESULT VSS_MGMT_OBJECT_PROP_Copy::copy(
		IN	VSS_MGMT_OBJECT_PROP* pObj1,
		IN	VSS_MGMT_OBJECT_PROP* pObj2
		)
{
	HRESULT hr;

    // Testing arguments
    if ((pObj1 == NULL) || (pObj2 == NULL))
        return E_INVALIDARG;

    // Zeroing the contents of the destination structure
    ::VssZeroOut(pObj1);

    // Copy the type
    pObj1->Type = pObj2->Type;

    // Effective copy
    switch(pObj2->Type)
    {
    case VSS_MGMT_OBJECT_VOLUME:
		hr = copyVolume( &(pObj1->Obj.Vol), &(pObj2->Obj.Vol) );
        break;

    case VSS_MGMT_OBJECT_DIFF_VOLUME:
		hr = copyDiffVolume( &(pObj1->Obj.DiffVol), &(pObj2->Obj.DiffVol) );
        break;

    case VSS_MGMT_OBJECT_DIFF_AREA:
		hr = copyDiffArea( &(pObj1->Obj.DiffArea), &(pObj2->Obj.DiffArea) );
        break;

    default:
		BS_ASSERT(false);
		hr = E_UNEXPECTED;
        break;
    }

    return hr;
}


void VSS_MGMT_OBJECT_PROP_Copy::init(
		IN	VSS_MGMT_OBJECT_PROP* pObjectProp
		)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_MGMT_OBJECT_PROP_Copy::init" );

    try
    {
        // Zeroing the contents of the structure
        ::VssZeroOut(pObjectProp);
    }
    VSS_STANDARD_CATCH(ft)
}


void VSS_MGMT_OBJECT_PROP_Copy::destroy(
		IN	VSS_MGMT_OBJECT_PROP* pObjectProp
		)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"VSS_MGMT_OBJECT_PROP_Copy::destroy" );

    try
    {
        if (pObjectProp)
        {
            switch(pObjectProp->Type)
            {
            case VSS_MGMT_OBJECT_VOLUME:
                ::VssFreeString(pObjectProp->Obj.Vol.m_pwszVolumeName);
                ::VssFreeString(pObjectProp->Obj.Vol.m_pwszVolumeDisplayName);
                break;

            case VSS_MGMT_OBJECT_DIFF_VOLUME:
                ::VssFreeString(pObjectProp->Obj.DiffVol.m_pwszVolumeName);
                ::VssFreeString(pObjectProp->Obj.DiffVol.m_pwszVolumeDisplayName);
                break;

            case VSS_MGMT_OBJECT_DIFF_AREA:
                ::VssFreeString(pObjectProp->Obj.DiffArea.m_pwszVolumeName);
                ::VssFreeString(pObjectProp->Obj.DiffArea.m_pwszDiffAreaVolumeName);
                break;

            default:
                break;
            }
            pObjectProp->Type = VSS_MGMT_OBJECT_UNKNOWN;
        }
    }
    VSS_STANDARD_CATCH(ft)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\jetwriter\ijetwriter.cpp ===
/*
**++
**
**  Copyright (c) 2000-2001  Microsoft Corporation
**
**  Module Name:
**
**	wrtrrsm.cpp
**
**
**  Abstract:
**
**	Writer shim module for RSM
**
**
**  Author:
**
**	Brian Berkowitz [brianb]
**
**
**  Revision History:
**
**	X-11	MCJ		Michael C. Johnson		19-Sep-2000
**		215218: Wildcard name of log files returned by OnIdentify()
**		215390: Incorporate multiple '.' fix in MatchFileName from NtBackup
**
**	X-10	MCJ		Michael C. Johnson		19-Sep-2000
**		176860: Add the missing calling convention specifiers
**
**	X-9	MCJ		Michael C. Johnson		21-Aug-2000
**		Added copyright and edit history
**		161899: Don't add a component for a database file in the
**		        exclude list.
**		165873: Remove trailing '\' from metadata file paths
**		165913: Deallocate memory on class destruction
**
**
**--
*/

#include <stdafx.h>

#include <esent.h>

#include <vss.h>
#include <vswriter.h>

#include <jetwriter.h>


#include "ijetwriter.h"
#include "vs_inc.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "JTWIJTWC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  local functions


#define UMAX(_a, _b)			((_a) > (_b)      ? (_a)    : (_b))
#define	EXECUTEIF(_bSuccess, _fn)	((_bSuccess)      ? (_fn)   : (_bSuccess))
#define	GET_STATUS_FROM_BOOL(_bSucceed)	((_bSucceed)      ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))


typedef struct _ExpandedPathInfo
    {
    LIST_ENTRY	leQueueHead;
    PWCHAR	pwszOriginalFilePath;
    PWCHAR	pwszOriginalFileName;
    PWCHAR	pwszExpandedFilePath;
    PWCHAR	pwszExpandedFileName;
    bool	bRecurseIntoSubdirectories;
    } EXPANDEDPATHINFO, *PEXPANDEDPATHINFO, **PPEXPANDEDPATHINFO;



static void RemoveAnyTrailingSeparator (PCHAR szPath)
    {
    ULONG	ulPathLength = strlen (szPath);

    if ('\\' == szPath [ulPathLength - 1])
	{
	szPath [ulPathLength - 1] = '\0';
	}
    }


static void RemoveAnyTrailingSeparator (PWCHAR wszPath)
    {
    ULONG	ulPathLength = wcslen (wszPath);

    if (L'\\' == wszPath [ulPathLength - 1])
	{
	wszPath [ulPathLength - 1] = UNICODE_NULL;
	}
    }


static bool ConvertName (PCHAR  szSourceName,
			 ULONG  ulTargetBufferLengthInChars,
			 PWCHAR wszTargetBuffer)
    {
    bool bSucceeded = true;


    wszTargetBuffer [0] = '\0';


    /*
    ** Only need to do the conversion for non-zero length
    ** strings. Returning a zero length string for a zero length
    ** argument is an ok thing to do.
    */
    if ('\0' != szSourceName [0])
	{
	bSucceeded = (0 != MultiByteToWideChar (CP_OEMCP,
						0,
						szSourceName,
						-1,
						wszTargetBuffer,
						ulTargetBufferLengthInChars));
	}


    return (bSucceeded);
    } /* ConvertName () */


static bool ConvertNameAndSeparateFilePaths (PCHAR	pszSourcePath,
					     ULONG	ulTargetBufferLength,
					     PWCHAR	pwszTargetPath,
					     PWCHAR&	pwszTargetFileSpec)
    {
    bool	bSucceeded;
    PWCHAR	pwchLastSlash;


    bSucceeded = ConvertName (pszSourcePath, ulTargetBufferLength, pwszTargetPath);

    if (bSucceeded)
	{
	/*
	** Scan backwards from the end of the target path, zap the
	** end-most '\' and point the file spec at the character
	** following where the '\' used to be.
	*/
	pwchLastSlash = wcsrchr (pwszTargetPath, L'\\');

	bSucceeded = (NULL != pwchLastSlash);
	}


    if (bSucceeded)
	{
	pwszTargetFileSpec = pwchLastSlash + 1;

	*pwchLastSlash = UNICODE_NULL;
	}


    return (bSucceeded);
    } /* ConvertNameAndSeparateFilePaths () */



/*
** This routine breaks out the next path and filespec from a list of
** filespecs. The expected format of the input string is
**
**	path\[filespec] [/s]
**
**
** The list can contain an arbitrary number of filespecs each
** separated by a semi-colon.
*/
static bool DetermineNextPathWorker (LPCWSTR  pwszFileList,
				     LPCWSTR& pwszReturnedCursor,
				     ULONG&   ulReturnedDirectoryStart,
				     ULONG&   ulReturnedDirectoryLength,
				     ULONG&   ulReturnedFilenameStart,
				     ULONG&   ulReturnedFilenameLength,
				     bool&    bReturnedRecurseIntoSubdirectories,
				     bool&    bReturnedFoundSpec)
    {
    bool	bSucceeded                    = true;
    bool	bFoundSpec                    = false;
    ULONG	ulPathNameLength;
    ULONG	ulFileNameLength;
    ULONG	ulIndex;
    ULONG	ulIndexSubDirectory           = 0;
    ULONG	ulIndexLastDirectorySeparator = 0;
    ULONG	ulIndexFirstCharInSpec        = 0;
    ULONG	ulIndexLastCharInSpec         = 0;
    const ULONG	ulLengthFileList              = wcslen (pwszFileList);


    /*
    ** The format of the string we are expecting is "filename.ext /s
    ** ;nextname", ie a list of semi-colon separated names with an
    ** optional trailing '/s'. There can be an arbitrary number of
    ** spaces before the '/' and before the ';': these will be
    ** stripped out and discarded. So we start by scanning for the
    ** first '/' or ';' characters.
    **
    ** Look for a ';' first to determine the end point.
    */
    if ((NULL         == pwszFileList) ||
	(UNICODE_NULL == pwszFileList [0]))
	{
	bFoundSpec = false;
	}

    else if (( L';'  == pwszFileList [0]) ||
	     ( L'/'  == pwszFileList [0]) ||
	     ((L'\\' == pwszFileList [0]) && (UNICODE_NULL == pwszFileList [1])))
	{
	bSucceeded = false;
	bFoundSpec = false;
	}

    else
	{
	bFoundSpec = true;
	}


    if (bSucceeded && bFoundSpec)
	{
	while (L' ' == pwszFileList [ulIndexFirstCharInSpec])
	    {
	    ulIndexFirstCharInSpec++;
	    }


	for (ulIndex = ulIndexFirstCharInSpec; ulIndex < ulLengthFileList; ulIndex++)
	    {
	    if ((UNICODE_NULL == pwszFileList [ulIndex]) ||
		(L';'         == pwszFileList [ulIndex]))
		{
		/*
		** We found the end of this specification
		*/
		break;
		}

	    else if (L'\\' == pwszFileList [ulIndex])
		{
		/*
		** Found a backslash? Record it's location. We'll want
		** this later when determining what the file name is
		** and so on.
		*/
		ulIndexLastDirectorySeparator = ulIndex;
		}

	    else if ((L'/' ==           pwszFileList [ulIndex]) &&
		     (L's' == towlower (pwszFileList [ulIndex + 1])))
		{
		ulIndexSubDirectory = ulIndex;
		}
	    }
	


	ulIndexLastCharInSpec = (0 == ulIndexSubDirectory) ? ulIndex - 1 : ulIndexSubDirectory - 1;

	while (L' ' == pwszFileList [ulIndexLastCharInSpec])
	    {
	    ulIndexLastCharInSpec--;
	    }


	_ASSERTE (ulIndex                       >  ulIndexSubDirectory);
	_ASSERTE (ulIndexSubDirectory == 0 ||
	          ulIndexSubDirectory           >  ulIndexLastCharInSpec);
	_ASSERTE (ulIndexLastCharInSpec         >= ulIndexLastDirectorySeparator);
	_ASSERTE (ulIndexLastDirectorySeparator >  ulIndexFirstCharInSpec);


	/*
	** We may have an illegal spec here with a missing '\'. Come
	** on folks, there ought to be at least one. one measly '\' is
	** all I'm after.
	*/
	bSucceeded = (0 < ulIndexLastDirectorySeparator);
	}




    if (bSucceeded)
	{
	if (bFoundSpec)
	    {
	    ulPathNameLength = ulIndexLastDirectorySeparator - ulIndexFirstCharInSpec;
	    ulFileNameLength = ulIndexLastCharInSpec         - ulIndexLastDirectorySeparator;


	    pwszReturnedCursor                 = (UNICODE_NULL == pwszFileList [ulIndex])
									? &pwszFileList [ulIndex]
									: &pwszFileList [ulIndex + 1];

	    ulReturnedDirectoryStart           = ulIndexFirstCharInSpec;
	    ulReturnedDirectoryLength          = ulPathNameLength;
	    ulReturnedFilenameStart            = ulIndexLastDirectorySeparator + 1;
	    ulReturnedFilenameLength           = ulFileNameLength;

	    bReturnedRecurseIntoSubdirectories = (0 != ulIndexSubDirectory);
	    bReturnedFoundSpec                 = true;
	    }

	else
	    {
	    pwszReturnedCursor                 = pwszFileList;

	    ulReturnedDirectoryStart           = 0;
	    ulReturnedDirectoryLength          = 0;
	    ulReturnedFilenameStart            = 0;
	    ulReturnedFilenameLength           = 0;

	    bReturnedRecurseIntoSubdirectories = false;
	    bReturnedFoundSpec                 = false;
	    }
	}



    return (bSucceeded);
    } /* DetermineNextPathWorker () */



static bool DetermineNextPathLengths (LPCWSTR pwszFileList,
				      ULONG&  ulReturnedLengthDirectory,
				      ULONG&  ulReturnedLengthFilename,
				      bool&   bReturnedRecurseIntoSubdirectories,
				      bool&   bReturnedFoundSpec)
    {
    bool	bSucceeded;
    LPCWSTR	pwszUpdatedCursor;
    ULONG	ulIndexDirectoryStart;
    ULONG	ulIndexFilenameStart;


    bSucceeded = DetermineNextPathWorker (pwszFileList,
					  pwszUpdatedCursor,
					  ulIndexDirectoryStart,
					  ulReturnedLengthDirectory,
					  ulIndexFilenameStart,
					  ulReturnedLengthFilename,
					  bReturnedRecurseIntoSubdirectories,
					  bReturnedFoundSpec);

    return (bSucceeded);
    } /* DetermineNextPathLengths () */


static bool DetermineNextPath (LPCWSTR  pwszFileList,
			       LPCWSTR& pwszReturnedCursor,
			       ULONG    ulLengthBufferDirectory,
			       PWCHAR   pwszBufferDirectory,
			       ULONG    ulLengthBufferFilename,
			       PWCHAR   pwszBufferFilename,
			       bool&    bReturnedRecurseIntoSubdirectories,
			       bool&    bReturnedFoundSpec)
    {
    bool	bSucceeded                    = true;
    bool	bRecurseIntoSubdirectories;
    bool	bFoundSpec;
    bool	bWildcardFilename;
    LPCWSTR	pwszUpdatedCursor;
    ULONG	ulLengthDirectory;
    ULONG	ulLengthFilename;
    ULONG	ulIndexDirectoryStart;
    ULONG	ulIndexFilenameStart;


    bSucceeded = DetermineNextPathWorker (pwszFileList,
					  pwszUpdatedCursor,
					  ulIndexDirectoryStart,
					  ulLengthDirectory,
					  ulIndexFilenameStart,
					  ulLengthFilename,
					  bRecurseIntoSubdirectories,
					  bFoundSpec);

    if (bSucceeded && bFoundSpec)
	{
	if ((ulLengthBufferDirectory < ((sizeof (WCHAR) * ulLengthDirectory) + sizeof (UNICODE_NULL))) ||
	    (ulLengthBufferFilename  < ((sizeof (WCHAR) * ulLengthFilename)  + sizeof (UNICODE_NULL))))
	    {
	    /*
	    ** Oops, buffer overflow would occur if we were to proceed
	    ** with the copy.
	    */
	    bSucceeded = false;
	    }
	}


    if (bSucceeded)
	{
	bReturnedRecurseIntoSubdirectories = bRecurseIntoSubdirectories;
	bReturnedFoundSpec                 = bFoundSpec;
	pwszReturnedCursor                 = pwszUpdatedCursor;


	if (bFoundSpec)
	    {
	    /*
	    ** Everything up to, but excluding the last directory
	    ** separator is the path. Everything after the last directory
	    ** separator up to and including the last char is the
	    ** filespec. If the filespec is zero length, then add the '*'
	    ** wildcard.
	    */
	    bWildcardFilename = (0 == ulLengthFilename);

	    ulLengthFilename += bWildcardFilename ? 1 : 0;


	    memcpy (pwszBufferDirectory,
		    &pwszFileList [ulIndexDirectoryStart],
		    sizeof (WCHAR) * ulLengthDirectory);

	    memcpy (pwszBufferFilename,
		    (bWildcardFilename) ? L"*" : &pwszFileList [ulIndexFilenameStart],
		    sizeof (WCHAR) * ulLengthFilename);

	    pwszBufferDirectory [ulLengthDirectory] = UNICODE_NULL;
	    pwszBufferFilename  [ulLengthFilename]  = UNICODE_NULL;
	    }
	}


    return (bSucceeded);
    } /* DetermineNextPath () */



static bool ValidateIncludeExcludeList (LPCWSTR pwszFileList)
    {
    LPCWSTR	pwszCursor  = pwszFileList;
    bool	bSucceeded  = true;
    bool	bFoundFiles = true;
    bool	bRecurseIntoSubdirectories;
    ULONG	ulIndexDirectoryStart;
    ULONG	ulIndexFilenameStart;
    ULONG	ulLengthDirectory;
    ULONG	ulLengthFilename;

    while (bSucceeded && bFoundFiles)
	{
	bSucceeded = EXECUTEIF (bSucceeded, (DetermineNextPathWorker (pwszCursor,
								      pwszCursor,
								      ulIndexDirectoryStart,
								      ulLengthDirectory,
								      ulIndexFilenameStart,
								      ulLengthFilename,
								      bRecurseIntoSubdirectories,
								      bFoundFiles)));
	}


    return (bSucceeded);
    } /* ValidateIncludeExcludeList () */


/*
** Based on MatchFname() from \nt\base\fs\utils\ntback50\be\bsdmatch.cpp
*/
static bool MatchFilename (LPCWSTR pwszPattern,    /* I - file name (with wildcards)     */
			   LPCWSTR pwszFilename)   /* I - file name (without wildcards ) */
    {
    ULONG	ulIndexPattern;					/* index for pwszPattern */
    ULONG	ulIndexFilename;				/* index for pwszFilename */
    ULONG	ulLengthPattern;
    const ULONG	ulLengthFilename        = wcslen (pwszFilename);
    bool	bSucceeded              = true;
    PWCHAR	pwszNameBufferAllocated = NULL;			/* allocated temp name buffer  */
    PWCHAR	pwszNameBufferTemp;				/* pointer to one of the above */
    PWCHAR	pwchTemp;
    WCHAR	pwszNameBufferStatic [256];			/* static temp name buffer     */
    WCHAR	wchSavedChar ;


    ulIndexFilename = 0;

    if (wcscmp (pwszPattern, L"*") && wcscmp (pwszPattern, L"*.*"))
	{
	bool bTryWithDot = false;

	do
	    {
	    if (bTryWithDot)
		{
		/*
		** Size of name_buff minus a null, minus a dot for the
		** "bTryWithDot" code below. If the name is longer than the
		** static buffer, allocate one from the heap.
		*/
		if (((ulLengthFilename + 2) * sizeof (WCHAR)) > sizeof (pwszNameBufferStatic))
		    {
		    pwszNameBufferAllocated = new WCHAR [ulLengthFilename + 2];
		    pwszNameBufferTemp = pwszNameBufferAllocated;
		    }
		else
		    {
		    pwszNameBufferTemp = pwszNameBufferStatic;
		    }

		if (pwszNameBufferTemp != NULL)
		    {
		    wcscpy (pwszNameBufferTemp, pwszFilename);
		    wcscat (pwszNameBufferTemp, L".");
		    pwszFilename = pwszNameBufferTemp;
		    ulIndexFilename = 0;
		    bSucceeded = true;
		    }

		bTryWithDot = false;
		}

	    else if (wcschr (pwszFilename, L'.') == NULL)
		{
		bTryWithDot = true;
		}


	    for (ulIndexPattern = 0; (pwszPattern [ulIndexPattern] != 0) && (bSucceeded) ; ulIndexPattern++)
		{
		switch (pwszPattern [ulIndexPattern])
		    {
		    case L'*':
			while (pwszPattern [ulIndexPattern + 1] != UNICODE_NULL)
			    {
			    if (pwszPattern [ulIndexPattern + 1] == L'?')
				{
				if (pwszFilename [++ulIndexFilename] == UNICODE_NULL)
				    {
				    break ;
				    }
				}

			    else if (pwszPattern [ulIndexPattern + 1] != L'*')
				{
				break ;
				}

			    ulIndexPattern++ ;
			    }

			pwchTemp = wcspbrk (&pwszPattern [ulIndexPattern + 1], L"*?");

			if (pwchTemp != NULL)
			    {
			    wchSavedChar = *pwchTemp;
			    *pwchTemp = UNICODE_NULL;

			    ulLengthPattern = wcslen (&pwszPattern [ulIndexPattern + 1]);

			    while (pwszFilename [ulIndexFilename] &&
				   _wcsnicmp (&pwszFilename [ulIndexFilename],
					      &pwszPattern [ulIndexPattern + 1],
					      ulLengthPattern))
				{
				ulIndexFilename++;
				}

			    ulIndexPattern += ulLengthPattern;

			    *pwchTemp = wchSavedChar;

			    if (pwszFilename [ulIndexFilename] == UNICODE_NULL)
				{
				bSucceeded = false;
				}
			    else
				{
				ulIndexFilename++;
				}
			    }
			else
			    {
			    if (pwszPattern [ulIndexPattern + 1] == UNICODE_NULL)
				{
				ulIndexFilename = wcslen (pwszFilename);
				break;
				}
			    else
				{
				pwchTemp = wcschr (&pwszFilename [ulIndexFilename],
						   pwszPattern [ulIndexPattern + 1]);

				if (pwchTemp != NULL)
				    {
				    ulIndexFilename += (ULONG)(pwchTemp - &pwszFilename [ulIndexFilename]);
				    }
				else
				    {
				    bSucceeded = false;
				    }
				}
			    }
			break;


		    case L'?' :
			if (pwszFilename [ulIndexFilename] != UNICODE_NULL)
			    {
			    ulIndexFilename++;
			    }
			break;


		    default:
			if (pwszFilename [ulIndexFilename] == UNICODE_NULL)
			    {
			    bSucceeded = false;
			    }

			else if (towupper (pwszFilename [ulIndexFilename]) != towupper (pwszPattern [ulIndexPattern]))
			    {
			    ULONG	ulIndexPreviousStar = ulIndexPattern;


			    /*
			    ** Set the index back to the last '*'
			    */
			    bSucceeded = false;

			    do
				{
				if (pwszPattern [ulIndexPreviousStar] == L'*')
				    {
				    ulIndexPattern = ulIndexPreviousStar;
				    ulIndexFilename++;
				    bSucceeded = true;
				    break;
				    }
				} while (ulIndexPreviousStar-- > 0);
			    }
			else
			    {
			    ulIndexFilename++;
			    }

		    }
		}


	    if (pwszFilename [ulIndexFilename] != UNICODE_NULL)
		{
		bSucceeded = false;
		}

	    } while ((!bSucceeded) && (bTryWithDot));
	}


    delete [] pwszNameBufferAllocated;


    return (bSucceeded);
    } /* MatchFilename () */


/////////////////////////////////////////////////////////////////////////////
//  class CVssIJetWriter
//
// logical path   == instance name
// component name == dbfilename (minus the extension?)
// caption        == display name
//
//
// add db and slv files as database files
// add the per-instance log file to each database even though is is the same each time.



STDMETHODCALLTYPE CVssIJetWriter::~CVssIJetWriter()
    {
    PostProcessIncludeExcludeLists (true );
    PostProcessIncludeExcludeLists (false);

    delete m_wszWriterName;
    delete m_wszFilesToInclude;
    delete m_wszFilesToExclude;
    }



BOOL CVssIJetWriter::CheckExcludedFileListForMatch (LPCWSTR pwszDatabaseFilePath,
						    LPCWSTR pwszDatabaseFileSpec)
    {
    BOOL		bMatchFound	= false;
    PLIST_ENTRY		pleElement	= m_leFilesToExcludeEntries.Flink;
    UNICODE_STRING	ucsExcludedFilePath;
    UNICODE_STRING	ucsDatabaseFilePath;
    PEXPANDEDPATHINFO	pepnPathInfomation;


    RtlInitUnicodeString (&ucsDatabaseFilePath, pwszDatabaseFilePath);


    while ((&m_leFilesToExcludeEntries != pleElement) && !bMatchFound)
	{
	pepnPathInfomation = (PEXPANDEDPATHINFO)((PBYTE) pleElement - offsetof (EXPANDEDPATHINFO, leQueueHead));

	RtlInitUnicodeString (&ucsExcludedFilePath,
			      pepnPathInfomation->pwszExpandedFilePath);

	
	if (pepnPathInfomation->bRecurseIntoSubdirectories)
	    {
	    bMatchFound = RtlPrefixUnicodeString (&ucsExcludedFilePath,
						  &ucsDatabaseFilePath,
						  true);
	    }
	else
	    {
	    bMatchFound = RtlEqualUnicodeString (&ucsExcludedFilePath, &ucsDatabaseFilePath, true) &&
			  MatchFilename (pepnPathInfomation->pwszExpandedFileName, pwszDatabaseFileSpec);
	    }



	pleElement = pleElement->Flink;
	}




    return (bMatchFound);
    } /* CVssIJetWriter::CheckExcludedFileListForMatch () */




bool CVssIJetWriter::ProcessJetInstance (JET_INSTANCE_INFO *pInstanceInfo)
    {
    JET_ERR	jetStatus;
    HRESULT	hrStatus;
    DWORD	dwStatus;
    bool	bSucceeded;
    bool	bRestoreMetadata        = false;
    bool	bNotifyOnBackupComplete = false;
    bool	bSelectable             = false;
    bool	bIncludeComponent;
    CHAR	szPathShortName        [MAX_PATH];
    CHAR	szPathFullName         [MAX_PATH];
    WCHAR	wszInstanceName        [MAX_PATH];
    WCHAR	wszDatabaseName        [MAX_PATH];
    WCHAR	wszDatabaseDisplayName [MAX_PATH];
    WCHAR	wszDatabaseFilePath    [MAX_PATH];
    WCHAR	wszDatabaseSLVFilePath [MAX_PATH];
    WCHAR	wszLogFilePath         [MAX_PATH];
    WCHAR	wszLogFileName         [MAX_PATH];
    WCHAR	wszCheckpointFilePath  [MAX_PATH];
    WCHAR	wszCheckpointFileName  [MAX_PATH];

    PWCHAR	pwszDatabaseFileName    = L"";
    PWCHAR	pwszDatabaseSLVFileName = L"";




    /*
    ** A valid instance will have an instance Id, but if it's not
    ** actually being used for anything it may well not have a name,
    ** any log or database files.
    **
    ** See if we can get hold of the name of the log file for this
    ** instance.
    */
    bSucceeded = (JET_errSuccess <= JetGetSystemParameter (pInstanceInfo->hInstanceId,
							   JET_sesidNil,
							   JET_paramLogFilePath,
							   NULL,
							   szPathShortName,
							   sizeof (szPathShortName)));

    if (bSucceeded)
	{
	dwStatus = GetFullPathNameA (szPathShortName,
				     sizeof (szPathFullName),
				     szPathFullName,
				     NULL);

	bSucceeded = (dwStatus > 0);
	}


    if (bSucceeded)
	{
	RemoveAnyTrailingSeparator (szPathFullName);

	bSucceeded = ConvertName (szPathFullName,
				  MAX_PATH,
				  wszLogFilePath);
	}


    BsDebugTrace (0,
		  DEBUG_TRACE_VSS_SHIM,
		  (L"CVssIJetWriter::ProcessJetInstance - "
		   L"%s calling JetGetSystemParameter() with instance Log file path '%S' (shortname) or '%s' full name",
		   bSucceeded ? L"Succeeded" : L"FAILED",
		   szPathShortName,
		   wszLogFilePath));





    /*
    ** Ok, now get the SystemPath which we will need to construct the
    ** path for the checkpoint file.
    */
    bSucceeded = (JET_errSuccess <= JetGetSystemParameter (pInstanceInfo->hInstanceId,
							   JET_sesidNil,
							   JET_paramSystemPath,
							   NULL,
							   szPathShortName,
							   sizeof (szPathShortName)));

    if (bSucceeded)
	{
	dwStatus = GetFullPathNameA (szPathShortName,
				     sizeof (szPathFullName),
				     szPathFullName,
				     NULL);

	bSucceeded = (dwStatus > 0);
	}


    if (bSucceeded)
	{
	RemoveAnyTrailingSeparator (szPathFullName);

	bSucceeded = ConvertName (szPathFullName,
				  MAX_PATH,
				  wszCheckpointFilePath);
	}


    BsDebugTrace (0,
		  DEBUG_TRACE_VSS_SHIM,
		  (L"CVssIJetWriter::ProcessJetInstance - "
		   L"%s calling JetGetSystemParameter() with checkpoint file path '%S' (shortname) or '%s' full name",
		   bSucceeded ? L"Succeeded" : L"FAILED",
		   szPathShortName,
		   wszCheckpointFilePath));



    /*
    ** Ok, now get the base name which we will need to construct the
    ** file spec for the log and checkpoint files. Note that we expect
    ** this to be just 3 chars long.
    */
    bSucceeded = (JET_errSuccess <= JetGetSystemParameter (pInstanceInfo->hInstanceId,
							   JET_sesidNil,
							   JET_paramBaseName,
							   NULL,
							   szPathShortName,
							   sizeof (szPathShortName)));

    if (bSucceeded)
	{
	/*
	** Convert to wide char ensuring that we leave a little room
	** for the "*.log"/".chk" strings to be appended to form the
	** log file spec and the checkpoint file specs respectively.
	*/
	bSucceeded = ConvertName (szPathShortName,
				  MAX_PATH - sizeof ("*.log"),
				  wszCheckpointFileName);
	}


    if (bSucceeded)
	{
	wcscpy (wszLogFileName, wszCheckpointFileName);


	wcscat (wszCheckpointFileName, L".chk" );
	wcscat (wszLogFileName,        L"*.log");
	}


    BsDebugTrace (0,
		  DEBUG_TRACE_VSS_SHIM,
		  (L"CVssIJetWriter::ProcessJetInstance - "
		   L"%s calling JetGetSystemParameter() for base name '%S' to form LogFileName '%s' and CheckpointFileName '%s'",
		   bSucceeded ? L"Succeeded" : L"FAILED",
		   szPathShortName,
		   wszLogFileName,
		   wszCheckpointFileName));




    if (bSucceeded && (pInstanceInfo->cDatabases > 0))
	{
	/*
	** Ok, we think we have an instance that is actually being
	** used for something. so go ahead and construct a 'component'
	** for it.
	*/
	if ((NULL == pInstanceInfo->szInstanceName) ||
	    ('\0' == pInstanceInfo->szInstanceName [0]))
	    {
	    /*
	    ** We seem to have a NULL pointer or a zero length
	    ** string. Just set to a zero length unicode string.
	    */
	    wszInstanceName [0] = UNICODE_NULL;
	    }

	else
	    {
	    bSucceeded = ConvertName (pInstanceInfo->szInstanceName,
				      MAX_PATH,
				      wszInstanceName);
	    }



	for (ULONG ulDatabase = 0; bSucceeded && (ulDatabase < pInstanceInfo->cDatabases); ulDatabase++)
	    {
	    bSucceeded = ConvertNameAndSeparateFilePaths (pInstanceInfo->szDatabaseFileName [ulDatabase],
							  MAX_PATH,
							  wszDatabaseFilePath,
							  pwszDatabaseFileName);


	    /*
	    ** Convert the database display name to unicode but allow
	    ** for a possible NULL pointer or a non-zero length file
	    ** spec.
	    */
	    if (bSucceeded)
		{
		if ((NULL == pInstanceInfo->szDatabaseDisplayName [ulDatabase]) ||
		    ('\0' == pInstanceInfo->szDatabaseDisplayName [ulDatabase][0]))
		    {
		    wszDatabaseDisplayName [0] = UNICODE_NULL;
		    }
		else
		    {
		    bSucceeded = ConvertName (pInstanceInfo->szDatabaseDisplayName [ulDatabase],
					      MAX_PATH,
					      wszDatabaseDisplayName);
		    }
		}


	    /*
	    ** Convert the SLV filename to unicode but allow for a
	    ** possible NULL pointer or a non-zero length file spec.
	    */
	    if (bSucceeded)
		{
		if ((NULL == pInstanceInfo->szDatabaseSLVFileName [ulDatabase]) ||
		    ('\0' == pInstanceInfo->szDatabaseSLVFileName [ulDatabase][0]))
		    {
		    wszDatabaseSLVFilePath [0] = UNICODE_NULL;
		    pwszDatabaseSLVFileName    = wszDatabaseSLVFilePath;
		    }
		else
		    {
		    bSucceeded = ConvertNameAndSeparateFilePaths (pInstanceInfo->szDatabaseSLVFileName [ulDatabase],
								  MAX_PATH,
								  wszDatabaseSLVFilePath,
								  pwszDatabaseSLVFileName);
		    }
		}




	    /*
	    ** We've now done all the name conversions to unicode so
	    ** add a component and the log and database files where
	    ** they're available.
	    */
	    if (bSucceeded)
		{
		bIncludeComponent = !CheckExcludedFileListForMatch (wszDatabaseFilePath,
								    pwszDatabaseFileName);
		}


	    if (bSucceeded && bIncludeComponent)
		{
		PWCHAR	pwchLastDot          = wcsrchr (pwszDatabaseFileName, L'.');
		ULONG	ulDatabaseNameLength = (ULONG) (pwchLastDot - pwszDatabaseFileName);

		wcsncpy (wszDatabaseName, pwszDatabaseFileName, ulDatabaseNameLength);
		wszDatabaseName [ulDatabaseNameLength] = '\0';



		hrStatus = m_pIMetadata->AddComponent (VSS_CT_DATABASE,
						       wszInstanceName,
						       wszDatabaseName,
						       wszDatabaseDisplayName,
						       NULL,
						       0,
						       bRestoreMetadata,
						       bNotifyOnBackupComplete,
						       bSelectable);

		bSucceeded = SUCCEEDED (hrStatus);

		BsDebugTrace (0,
			      DEBUG_TRACE_VSS_SHIM,
			      (L"CVssIJetWriter::ProcessJetInstance - "
			       L"%s adding component '%s' for database '%s' with display name '%s'",
			       bSucceeded ? L"Succeeded" : L"FAILED",
			       wszInstanceName,
			       wszDatabaseName,
			       wszDatabaseDisplayName));
		}
	


	    if (bSucceeded && bIncludeComponent)
		{
		hrStatus = m_pIMetadata->AddDatabaseFiles (wszInstanceName,
							   wszDatabaseName,
							   wszDatabaseFilePath,
							   pwszDatabaseFileName);

		bSucceeded = SUCCEEDED (hrStatus);

		BsDebugTrace (0,
			      DEBUG_TRACE_VSS_SHIM,
			      (L"CVssIJetWriter::ProcessJetInstance - "
			       L"%s adding database files for instance '%s', database '%s', database file '%s\\%s'",
			       bSucceeded ? L"Succeeded" : L"FAILED",
			       wszInstanceName,
			       wszDatabaseName,
			       wszDatabaseFilePath,
			       pwszDatabaseFileName));
		}
	


	    /*
	    ** May not have an SLV file so only add it if we have a
	    ** non-zero length file spec
	    */
	    if (bSucceeded && bIncludeComponent && (UNICODE_NULL != pwszDatabaseSLVFileName [0]))
		{
		hrStatus = m_pIMetadata->AddDatabaseFiles (wszInstanceName,
							   wszDatabaseName,
							   wszDatabaseSLVFilePath,
							   pwszDatabaseSLVFileName);

		bSucceeded = SUCCEEDED (hrStatus);

		BsDebugTrace (0,
			      DEBUG_TRACE_VSS_SHIM,
			      (L"CVssIJetWriter::ProcessJetInstance - "
			       L"%s adding SLV file for instance '%s', database '%s', SLV file '%s\\%s'",
			       bSucceeded ? L"Succeeded" : L"FAILED",
			       wszInstanceName,
			       wszDatabaseName,
			       wszDatabaseSLVFilePath,
			       pwszDatabaseSLVFileName));
		}


	    /*
	    ** May not have an instance log file so only add it if we
	    ** have a non-zero length file path
	    */
	    if (bSucceeded && bIncludeComponent && (UNICODE_NULL != wszLogFilePath [0]))
		{
		hrStatus = m_pIMetadata->AddDatabaseLogFiles (wszInstanceName,
							      wszDatabaseName,
							      wszLogFilePath,
							      wszLogFileName);

		bSucceeded = SUCCEEDED (hrStatus);

		BsDebugTrace (0,
			      DEBUG_TRACE_VSS_SHIM,
			      (L"CVssIJetWriter::ProcessJetInstance - "
			       L"%s adding log file for instance '%s', database '%s', log file '%s\\%s'",
			       bSucceeded ? L"Succeeded" : L"FAILED",
			       wszInstanceName,
			       wszDatabaseName,
			       wszLogFilePath,
			       wszLogFileName));
		}


	    /*
	    ** May not have a checkpoint file so only add it if we
	    ** have a non-zero length file path
	    */
	    if (bSucceeded && bIncludeComponent && (UNICODE_NULL != wszCheckpointFilePath [0]))
		{
		hrStatus = m_pIMetadata->AddDatabaseLogFiles (wszInstanceName,
							      wszDatabaseName,
							      wszCheckpointFilePath,
							      wszCheckpointFileName);

		bSucceeded = SUCCEEDED (hrStatus);

		BsDebugTrace (0,
			      DEBUG_TRACE_VSS_SHIM,
			      (L"CVssIJetWriter::ProcessJetInstance - "
			       L"%s adding checkpoint file for instance '%s', database '%s', checkpoint file '%s\\%s'",
			       bSucceeded ? L"Succeeded" : L"FAILED",
			       wszInstanceName,
			       wszDatabaseName,
			       wszCheckpointFilePath,
			       wszCheckpointFileName));
		}
	    }
	}


    return (bSucceeded);
    } /* CVssIJetWriter::ProcessJetInstance () */



bool CVssIJetWriter::PreProcessIncludeExcludeLists (bool bProcessingIncludeList)
    {
    /*
    ** Parse the m_wszFilesToInclude and m_wszFilesToExclude adding
    ** and enty to the appropriate list as necessary. This will
    ** minimize the number of passes over the un-processed lists.
    */
    ULONG		ulPathLength;
    ULONG		ulNameLength;
    bool		bRecurseIntoSubdirectories;
    bool		bSucceeded         = true;
    bool		bFoundFiles        = true;
    PEXPANDEDPATHINFO	pepnPathInfomation = NULL;
    PWCHAR		pwszCursor         = bProcessingIncludeList
						? m_wszFilesToInclude
						: m_wszFilesToExclude;



    while (bSucceeded && bFoundFiles)
	{
	bSucceeded = DetermineNextPathLengths (pwszCursor,
					       ulPathLength,
					       ulNameLength,
					       bRecurseIntoSubdirectories,
					       bFoundFiles);


	if (bSucceeded && bFoundFiles)
	    {
	    pepnPathInfomation = new EXPANDEDPATHINFO;

	    bSucceeded = (NULL != pepnPathInfomation);
	    }
	else
	    {
	    /*
	    ** We either failed and/or found no files. In either case
	    ** there is no point in continuing.
	    */
	    break;
	    }



	if (bSucceeded)
	    {
	    InitializeListHead (&pepnPathInfomation->leQueueHead);


	    if (0 == ulNameLength)
		{
		/*
		** If the filename component is zero length, then it
		** will be turned into a "*" so add a character to the
		** buffer to make room.
		*/
		ulNameLength++;
		}

	    /*
	    ** Allow extra space for terminating UNICODE_NULL
	    */
	    ulPathLength++;
	    ulNameLength++;


	    pepnPathInfomation->pwszExpandedFilePath = NULL;
	    pepnPathInfomation->pwszExpandedFileName = NULL;
	    pepnPathInfomation->pwszOriginalFilePath = new WCHAR [ulPathLength];
	    pepnPathInfomation->pwszOriginalFileName = new WCHAR [ulNameLength];

	    bSucceeded = ((NULL != pepnPathInfomation->pwszOriginalFilePath) &&
			  (NULL != pepnPathInfomation->pwszOriginalFileName));
	    }


	if (bSucceeded)
	    {
	    bSucceeded = DetermineNextPath (pwszCursor,
					    pwszCursor,
					    ulPathLength * sizeof (WCHAR),
					    pepnPathInfomation->pwszOriginalFilePath,
					    ulNameLength * sizeof (WCHAR),
					    pepnPathInfomation->pwszOriginalFileName,
					    pepnPathInfomation->bRecurseIntoSubdirectories,
					    bFoundFiles);

	    BS_ASSERT (bFoundFiles && L"Second attempt to locate files failed unexpectedly");
	    }


	if (bSucceeded)
	    {
	    ulPathLength = ExpandEnvironmentStringsW (pepnPathInfomation->pwszOriginalFilePath, NULL, 0);
	    ulNameLength = ExpandEnvironmentStringsW (pepnPathInfomation->pwszOriginalFileName, NULL, 0);

	    bSucceeded = (0 < ulPathLength) && (0 < ulNameLength);
	    }


	if (bSucceeded)
	    {
	    pepnPathInfomation->pwszExpandedFilePath = new WCHAR [ulPathLength];
	    pepnPathInfomation->pwszExpandedFileName = new WCHAR [ulNameLength];

	    bSucceeded = ((NULL != pepnPathInfomation->pwszExpandedFilePath) &&
			  (NULL != pepnPathInfomation->pwszExpandedFileName));
	    }


	if (bSucceeded)
	    {
	    ExpandEnvironmentStringsW (pepnPathInfomation->pwszOriginalFilePath,
				       pepnPathInfomation->pwszExpandedFilePath,
				       ulPathLength);


	    ExpandEnvironmentStringsW (pepnPathInfomation->pwszOriginalFileName,
				       pepnPathInfomation->pwszExpandedFileName,
				       ulNameLength);
	    }


	if (bSucceeded)
	    {
	    InsertTailList (bProcessingIncludeList ? &m_leFilesToIncludeEntries : &m_leFilesToExcludeEntries,
			    &pepnPathInfomation->leQueueHead);

	    pepnPathInfomation = NULL;
	    }



	if (NULL != pepnPathInfomation)
	    {
	    delete [] pepnPathInfomation->pwszOriginalFilePath;
	    delete [] pepnPathInfomation->pwszOriginalFileName;
	    delete [] pepnPathInfomation->pwszExpandedFilePath;
	    delete [] pepnPathInfomation->pwszExpandedFileName;
	    delete pepnPathInfomation;

	    pepnPathInfomation = NULL;
	    }
	}


    return (bSucceeded);
    } /* CVssIJetWriter::PreProcessIncludeExcludeLists () */



bool CVssIJetWriter::ProcessIncludeExcludeLists (bool bProcessingIncludeList)
    {
    /*
    ** parse the m_wszFilesToInclude and m_wszFilesToExclude
    ** calling the m_pIMetadata->IncludeFiles() and/or
    ** m_pIMetadata->ExcludeFiles() routines as necessary
    */
    HRESULT		hrStatus;
    bool		bSucceeded   = true;
    const PLIST_ENTRY	pleQueueHead = bProcessingIncludeList ? &m_leFilesToIncludeEntries : &m_leFilesToExcludeEntries;
    PLIST_ENTRY		pleElement   = pleQueueHead->Flink;
    PEXPANDEDPATHINFO	pepnPathInfomation;



    while (bSucceeded && (pleQueueHead != pleElement))
	{
	pepnPathInfomation = (PEXPANDEDPATHINFO)((PBYTE) pleElement - offsetof (EXPANDEDPATHINFO, leQueueHead));


	if (bProcessingIncludeList)
	    {
	    hrStatus = m_pIMetadata->AddIncludeFiles (pepnPathInfomation->pwszOriginalFilePath,
						      pepnPathInfomation->pwszOriginalFileName,
						      pepnPathInfomation->bRecurseIntoSubdirectories,
						      NULL);
	    }
	else
	    {
	    hrStatus = m_pIMetadata->AddExcludeFiles (pepnPathInfomation->pwszOriginalFilePath,
						      pepnPathInfomation->pwszOriginalFileName,
						      pepnPathInfomation->bRecurseIntoSubdirectories);
	    }


	bSucceeded = SUCCEEDED (hrStatus);

	pleElement = pleElement->Flink;
	}


    return (bSucceeded);
    } /* CVssIJetWriter::ProcessIncludeExcludeLists () */



void CVssIJetWriter::PostProcessIncludeExcludeLists (bool bProcessingIncludeList)
    {
    PEXPANDEDPATHINFO	pepnPathInfomation;
    PLIST_ENTRY		pleElement;
    const PLIST_ENTRY	pleQueueHead = bProcessingIncludeList
						? &m_leFilesToIncludeEntries
						: &m_leFilesToExcludeEntries;


    while (!IsListEmpty (pleQueueHead))
	{
	pleElement = RemoveHeadList (pleQueueHead);

	BS_ASSERT (NULL != pleElement);


	pepnPathInfomation = (PEXPANDEDPATHINFO)((PBYTE) pleElement - offsetof (EXPANDEDPATHINFO, leQueueHead));

	delete [] pepnPathInfomation->pwszOriginalFilePath;
	delete [] pepnPathInfomation->pwszOriginalFileName;
	delete [] pepnPathInfomation->pwszExpandedFilePath;
	delete [] pepnPathInfomation->pwszExpandedFileName;
	delete pepnPathInfomation;
	}
    } /* CVssIJetWriter::PostProcessIncludeExcludeLists () */



bool STDMETHODCALLTYPE CVssIJetWriter::OnIdentify (IN IVssCreateWriterMetadata *pMetadata)
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnIdentify");

    JET_ERR		 jetStatus;
    HRESULT		 hrStatus;
    bool		 bSucceeded = true;
    ULONG		 ulInstanceInfoCount = 0;
    JET_INSTANCE_INFO	*pInstanceInfo;


    m_pIMetadata = pMetadata;


    /*
    ** Set up list of include and exclude files. ready for use in
    ** filtering Jet databases and adding include/exclude files lists.
    */
    bSucceeded = EXECUTEIF (bSucceeded, (PreProcessIncludeExcludeLists (true )));
    bSucceeded = EXECUTEIF (bSucceeded, (PreProcessIncludeExcludeLists (false)));

    bSucceeded = EXECUTEIF (bSucceeded, (JET_errSuccess <= JetGetInstanceInfo (&ulInstanceInfoCount,
									       &pInstanceInfo)));

    for (ULONG ulInstanceIndex = 0; ulInstanceIndex < ulInstanceInfoCount; ulInstanceIndex++)
	{
	bSucceeded = EXECUTEIF (bSucceeded, (ProcessJetInstance (pInstanceInfo + ulInstanceIndex)));
	}


    bSucceeded = EXECUTEIF (bSucceeded, (ProcessIncludeExcludeLists (true )));
    bSucceeded = EXECUTEIF (bSucceeded, (ProcessIncludeExcludeLists (false)));
    bSucceeded = EXECUTEIF (bSucceeded, (m_pwrapper->OnIdentify (pMetadata)));



    PostProcessIncludeExcludeLists (true );
    PostProcessIncludeExcludeLists (false);


    m_pIMetadata = NULL;

    return (bSucceeded);
    } /* CVssIJetWriter::OnIdentify () */



bool STDMETHODCALLTYPE CVssIJetWriter::OnPrepareBackup (IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnPrepareBackup");

	bool	bSucceeded;
	

	bSucceeded = m_pwrapper->OnPrepareBackupBegin (pIVssWriterComponents);

	bSucceeded = EXECUTEIF (bSucceeded, (m_pwrapper->OnPrepareBackupEnd (pIVssWriterComponents, bSucceeded)));

	return (bSucceeded);
	} /* CVssIJetWriter::OnPrepareBackup () */




bool STDMETHODCALLTYPE CVssIJetWriter::OnBackupComplete (IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnBackupComplete");

	bool	bSucceeded;
	

	bSucceeded = m_pwrapper->OnBackupCompleteBegin (pIVssWriterComponents);

	bSucceeded = EXECUTEIF (bSucceeded, (m_pwrapper->OnBackupCompleteEnd (pIVssWriterComponents, bSucceeded)));

	return (bSucceeded);
	} /* CVssIJetWriter::OnBackupComplete () */




bool STDMETHODCALLTYPE CVssIJetWriter::OnPrepareSnapshot()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnPrepareSnapshot");

	if (!m_pwrapper->OnPrepareSnapshotBegin())
		return false;

	// go to Jet level directly
	bool fSuccess = JET_errSuccess <= JetOSSnapshotPrepare( &m_idJet , 0 );
	return m_pwrapper->OnPrepareSnapshotEnd(fSuccess);
	} /* CVssIJetWriter::OnPrepareSnapshot () */



bool STDMETHODCALLTYPE CVssIJetWriter::OnFreeze()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnFreeze");

	unsigned long 			cInstanceInfo 	= 0;
	JET_INSTANCE_INFO *		aInstanceInfo 	= NULL;
	bool 					fDependence		= true;

	if (!m_pwrapper->OnFreezeBegin())
		return false;


	// we need to freeze at Jet level, then check from this DLL the dependencies
	// (as here we hagve the snapshot object implementation and COM registration)
	
	if ( JET_errSuccess > JetOSSnapshotFreeze( m_idJet , &cInstanceInfo, &aInstanceInfo, 0 ) )
		{
		return false;
		}

	// return false if some instances are only partialy affected
	fDependence = FCheckVolumeDependencies(cInstanceInfo, aInstanceInfo);
	(void)JetFreeBuffer( (char *)aInstanceInfo );
	
	if ( !fDependence )
		{
		JET_ERR 	err;
 		// on error, stop the snapshot, return false
		err = JetOSSnapshotThaw( m_idJet , 0 );
		// shell we check for time-out error here ?
		// (debugging may result in time-out error the call)
		BS_ASSERT ( JET_errSuccess == err );
 		}

	return m_pwrapper->OnFreezeEnd(fDependence);	
	} /* CVssIJetWriter::OnFreeze () */



bool STDMETHODCALLTYPE CVssIJetWriter::OnThaw()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnThaw");

	bool fSuccess1 = m_pwrapper->OnThawBegin();
	// go to Jet level directly. It will eventualy return timeout errors
	bool fSuccess2 = JET_errSuccess <= JetOSSnapshotThaw( m_idJet , 0 );
	return fSuccess1 && m_pwrapper->OnThawEnd(fSuccess2);
	} /* CVssIJetWriter::OnThaw () */

bool STDMETHODCALLTYPE CVssIJetWriter::OnPostSnapshot
	(
	IN IVssWriterComponents *pIVssWriterComponents
	)
	{
	return m_pwrapper->OnPostSnapshot(pIVssWriterComponents);
	}



bool STDMETHODCALLTYPE CVssIJetWriter::OnAbort()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnAbort");

	m_pwrapper->OnAbortBegin();
	JetOSSnapshotThaw( m_idJet , 0 );
	m_pwrapper->OnAbortEnd();
	return true;
	} /* CVssIJetWriter::OnAbort () */

bool STDMETHODCALLTYPE CVssIJetWriter::OnPreRestore
	(
	IN IVssWriterComponents *pIVssWriterComponents
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnPostRestore");

	if (!m_pwrapper->OnPreRestoreBegin(pIVssWriterComponents))
		return false;

	// go to Jet level directly
	// BUGBUG - need to add the correct Jet restore call/code here (MCJ)
	//	bool fSuccess = JET_errSuccess <= JetRestore ( ??? &m_idJet , 0 );
	bool fSuccess = TRUE;
	return m_pwrapper->OnPreRestoreEnd(pIVssWriterComponents, fSuccess);
	} /* CVssIJetWriter::OnPreRestore () */




bool STDMETHODCALLTYPE CVssIJetWriter::OnPostRestore
	(
	IN IVssWriterComponents *pIVssWriterComponents
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::OnPostRestore");

	if (!m_pwrapper->OnPostRestoreBegin(pIVssWriterComponents))
		return false;

	// go to Jet level directly
	// BUGBUG - need to add the correct Jet restore call/code here (MCJ)
	//	bool fSuccess = JET_errSuccess <= JetRestore ( ??? &m_idJet , 0 );
	bool fSuccess = TRUE;
	return m_pwrapper->OnPostRestoreEnd(pIVssWriterComponents, fSuccess);
	} /* CVssIJetWriter::OnPostRestore () */



bool CVssIJetWriter::FCheckPathVolumeDependencies(const char * szPath) const
	{
	// use static variable in order to avoid alloc/free
	WCHAR wszPath[MAX_PATH];

	if (MultiByteToWideChar(CP_OEMCP, 0, szPath, -1, wszPath, MAX_PATH ) == 0 )
		{
		BS_ASSERT( ERROR_INSUFFICIENT_BUFFER != GetLastError() );
		return false;
		}

	// use standart Writer call to check the affected path
	return IsPathAffected(wszPath);
	} /* CVssIJetWriter::FCheckPathVolumeDependencies () */



// all or nothing check: all path in instance are affected or none !
//
bool CVssIJetWriter::FCheckInstanceVolumeDependencies (const JET_INSTANCE_INFO * pInstanceInfo) const
	{
	BS_ASSERT(pInstanceInfo);

	JET_ERR 	err 			= JET_errSuccess;
	bool		fAffected		= false;
	char 		szPath[ MAX_PATH ];		
	
	
	// check first system and log path
	err = JetGetSystemParameter( pInstanceInfo->hInstanceId, JET_sesidNil, JET_paramLogFilePath, NULL, szPath, sizeof( szPath ) );
	if ( JET_errSuccess > err )
		return false;

	fAffected = FCheckPathVolumeDependencies( szPath );

	err = JetGetSystemParameter
		(
		pInstanceInfo->hInstanceId,
		JET_sesidNil,
		JET_paramSystemPath,
		NULL,
		szPath,
		sizeof(szPath)
		);

	if (JET_errSuccess > err)
		return false;

		
	fAffected = !(fAffected ^ FCheckPathVolumeDependencies(szPath));
	if (!fAffected)
		return false;
		
	for (ULONG_PTR iDatabase = 0;
		iDatabase < pInstanceInfo->cDatabases;
		iDatabase++)
		{
		char * szFile = pInstanceInfo->szDatabaseFileName[iDatabase];
		
		BS_ASSERT(szFile); // we always have a db file name
		fAffected = !(fAffected ^ FCheckPathVolumeDependencies(szFile));
		if (!fAffected)
			return false;

		szFile = pInstanceInfo->szDatabaseSLVFileName[iDatabase];

		// if no SLV file, go to next database
		if (!szFile)
			continue;
			
		fAffected = !(fAffected ^ FCheckPathVolumeDependencies(szFile));
		if ( !fAffected )
			return false;
		}

	// all set !
	return true;
	} /* CVssIJetWriter::FCheckInstanceVolumeDependencies () */



bool CVssIJetWriter::FCheckVolumeDependencies
	(
	unsigned long cInstanceInfo,
	JET_INSTANCE_INFO *	aInstanceInfo
	) const
	{
	bool fResult = true;

	// check each instance
	while (cInstanceInfo && fResult)
		{
		cInstanceInfo--;
		fResult = FCheckInstanceVolumeDependencies (aInstanceInfo + cInstanceInfo);
		}
		
	return fResult;
	} /* CVssIJetWriter::FCheckVolumeDependencies () */



// internal method to assign basic members
HRESULT CVssIJetWriter::InternalInitialize (IN VSS_ID  idWriter,
					    IN LPCWSTR wszWriterName,
					    IN bool    bSystemService,
					    IN bool    bBootableSystemState,
					    IN LPCWSTR wszFilesToInclude,
					    IN LPCWSTR wszFilesToExclude)
    {
    HRESULT hrStatus = NOERROR;


    CVssWriter::Initialize (idWriter,
				wszWriterName,
				bBootableSystemState
					? VSS_UT_BOOTABLESYSTEMSTATE
					: (bSystemService
						? VSS_UT_SYSTEMSERVICE
						: VSS_UT_USERDATA),
				VSS_ST_TRANSACTEDDB,
				VSS_APP_BACK_END);


    m_idWriter             = idWriter;
    m_bSystemService       = bSystemService;
    m_bBootableSystemState = bBootableSystemState;
    m_wszWriterName        = _wcsdup(wszWriterName);
    m_wszFilesToInclude    = _wcsdup(wszFilesToInclude);
    m_wszFilesToExclude    = _wcsdup(wszFilesToExclude);

    if ((NULL == m_wszWriterName)     ||
	(NULL == m_wszFilesToInclude) ||
	(NULL == m_wszFilesToExclude))
	{
	delete m_wszWriterName;
	delete m_wszFilesToInclude;
	delete m_wszFilesToExclude;

	m_wszWriterName     = NULL;
	m_wszFilesToInclude = NULL;
	m_wszFilesToExclude = NULL;

	hrStatus = E_OUTOFMEMORY;
	}


    return (hrStatus);
    } /* CVssIJetWriter::InternalInitialize () */



// do initialization
HRESULT STDMETHODCALLTYPE CVssIJetWriter::Initialize (IN VSS_ID idWriter,			// id of writer
						      IN LPCWSTR wszWriterName,		// writer name
						      IN bool bSystemService,		// is this a system service
						      IN bool bBootableSystemState,	// is this writer part of bootable system state
						      IN LPCWSTR wszFilesToInclude,	// additional files to include
						      IN LPCWSTR wszFilesToExclude,	// additional files to exclude
						      IN CVssJetWriter *pWriter,		// writer wrapper class
						      OUT void **ppInstance)		// output instance
    {
    CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::Initialize");

    try
	{
	// check parameters
	if (ppInstance == NULL)
	    {
	    ft.Throw (VSSDBG_GEN, E_INVALIDARG, L"NULL output parameter.");
	    }

	// change null pointer to null strings for files to include
	// and files to exclude
    if (wszFilesToInclude == NULL)
		wszFilesToInclude = L"";

	if (wszFilesToExclude == NULL)
		wszFilesToExclude = L"";


	if (!ValidateIncludeExcludeList (wszFilesToInclude))
	    {
	    ft.Throw (VSSDBG_GEN, E_INVALIDARG, L"Bad FilesToInclude list.");
	    }

	if (!ValidateIncludeExcludeList (wszFilesToExclude))
	    {
	    ft.Throw (VSSDBG_GEN, E_INVALIDARG, L"Bad FilesToExclude list.");
	    }



	// null output parameter
	*ppInstance = NULL;

	// create instance
	PVSSIJETWRITER pInstance = new CVssIJetWriter;

	// create instance
	ft.ThrowIf (NULL == pInstance,
		    VSSDBG_GEN,
		    E_OUTOFMEMORY,
		    L"FAILED creating CVssIJetWriter object due to allocation failure.");



	// call internal initialization
	ft.hr = pInstance->InternalInitialize (idWriter,
					       wszWriterName,
					       bSystemService,
					       bBootableSystemState,
					       wszFilesToInclude,
					       wszFilesToExclude);

	ft.ThrowIf (ft.HrFailed(),
		    VSSDBG_GEN,
		    ft.hr,
		    L"FAILED during internal initialisation of CVssIJetWriter object");



	// Subscribe the object.
	ft.hr = pInstance->Subscribe();

	ft.ThrowIf (ft.HrFailed(),
		    VSSDBG_GEN,
		    ft.hr,
		    L"FAILED during internal initialisation of CVssIJetWriter object");



	((CVssIJetWriter *) pInstance)->m_pwrapper = pWriter;
	*ppInstance = (void *) pInstance;
	} VSS_STANDARD_CATCH(ft)


    return (ft.hr);
    } /* CVssIJetWriter::Initialize () */



void STDMETHODCALLTYPE CVssIJetWriter::Uninitialize(IN PVSSIJETWRITER pInstance)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssIJetWriter::Uninitialize");

	try
		{
		CVssIJetWriter *pWriter = (CVssIJetWriter *) pInstance;
		// Unsubscribe the object.

		BS_ASSERT(pWriter);

		pWriter->Unsubscribe();
		delete pWriter;
		}
	VSS_STANDARD_CATCH(ft)
	} /* CVssIJetWriter::Uninitialize () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\sec\security.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module security.cxx | Implementation of IsAdministrator
    @end

Author:

    Adi Oltean  [aoltean]  07/09/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     07/09/1999  Created
    aoltean     08/26/1999  Adding RegisterProvider
    aoltean     08/26/1999  Adding UnregisterProvider
    aoltean     08/27/1999  Adding IsAdministrator,
                            Adding unique provider name test.
    aoltean     08/30/1999  Calling OnUnregister on un-registering
                            Improving IsProviderNameAlreadyUsed.
    aoltean     09/09/1999  dss -> vss
	aoltean		09/21/1999  Adding a new header for the "ptr" class.
	aoltean		09/27/1999	Adding new headers
	aoltean		10/15/1999  Moving declaration in security.hxx
	aoltean		01/18/2000	Moved into a separate directory
	brianb		04/04/2000	Add IsBackupOperator
	brianb		04/27/2000  Change IsBackupOperator to check SE_BACKUP_NAME privilege
	brianb		05/03/2000	Added GetClientTokenOwner method
	brianb		05/10/2000  fix problem with uninitialized variable
	brianb		05/12/2000	handle in proc case for impersonation failures

--*/

/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"

#include "vs_inc.hxx"

#include "vs_sec.hxx"

#include "vssmsg.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SECSECRC"
//
////////////////////////////////////////////////////////////////////////

BOOL DoImpersonate
	(
	BOOL bImpersonate,
	HANDLE *phToken
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"DoImpersonate");
	if (bImpersonate)
		{
		//  Impersonate the client to get its identity access token.
		//  The client should not have RPC_C_IMP_LEVEL_ANONYMOUS otherwise an error will be returned
		ft.hr = ::CoImpersonateClient();
		if (ft.hr == RPC_E_CALL_COMPLETE)
			{
			// this means that the call came from the same thread
			// do not do impersonation.  Just use the process
			// token
			bImpersonate = false;
			ft.hr = S_OK;
			}
		else
			{
			BOOL bRes;

			ft.CheckForError(VSSDBG_GEN, L"CoImpersonateClient");

			//  Get the Access Token of the client calling process in order to establish the client identity
			CVssAutoWin32Handle  hThread = ::GetCurrentThread(); // CloseHandle have no effect here

			bRes = ::OpenThreadToken
					(
					hThread,        //  IN HANDLE ThreadHandle,
					TOKEN_QUERY,    //  IN DWORD DesiredAccess,
					TRUE,           //  IN BOOL OpenAsSelf      (TRUE means not the client calling thread's access token)
					phToken         //  OUT PHANDLE TokenHandle
					);

			DWORD dwErr = GetLastError();

			// Revert the thread's access token - finish the impersonation
			ft.hr = ::CoRevertToSelf();
			ft.CheckForError(VSSDBG_GEN, L"CoRevertToSelf");

			if (!bRes)
				ft.TranslateError
					(
					VSSDBG_GEN,
					HRESULT_FROM_WIN32(dwErr),
					L"OpenThreadToken"
					);
			}
		}

	// note that the previous if statement may change the value
	// of bImpersonate.  This is why we can't just put this in an
	// else clause
	if (!bImpersonate)
		{
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY,phToken))
			ft.TranslateError
				(
				VSSDBG_GEN,
				HRESULT_FROM_WIN32(GetLastError()),
				L"OpenProcessToken"
				);
        }

	return bImpersonate;
	}




bool IsInGroup(DWORD dwGroup, bool bImpersonate)

/*++

Routine Description:

    Return TRUE if the current thread/process is running under the context of an administrator

Arguments:

    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the specified group is between token groups.

Return Value:

    true, if the caller thread is running under the context of the specified group
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
    CVssFunctionTracer ft( VSSDBG_GEN, L"IsInGroup" );

    BOOL bIsInGroup = FALSE;
    PSID psidGroup = NULL;
	BOOL bRes;

	// Reset the error code
	ft.hr = S_OK;

	//  Build the SID for the Administrators group
	SID_IDENTIFIER_AUTHORITY SidAuth = SECURITY_NT_AUTHORITY;
	bRes = AllocateAndInitializeSid
			(
            &SidAuth,                       //  IN PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
            2,                              //  IN BYTE nSubAuthorityCount,
			SECURITY_BUILTIN_DOMAIN_RID,	//  IN DWORD nSubAuthority0,
            dwGroup,  						//  IN DWORD nSubAuthority1,
            0,                              //  IN DWORD nSubAuthority2,
            0,                              //  IN DWORD nSubAuthority3,
            0,                              //  IN DWORD nSubAuthority4,
            0,                              //  IN DWORD nSubAuthority5,
            0,                              //  IN DWORD nSubAuthority6,
            0,                              //  IN DWORD nSubAuthority7,
            &psidGroup                      //  OUT PSID *pSid
            );

	if (!bRes)
		ft.TranslateError
			(
			VSSDBG_GEN,
			HRESULT_FROM_WIN32(GetLastError()),
			L"AllocateAndInitializeSid"
			);

    try
		{

		if (!bImpersonate)
			bRes = CheckTokenMembership(NULL, psidGroup, &bIsInGroup);
		else
			{
			CVssAutoWin32Handle  hToken;

			// impersonate client (or get process token)
			if (DoImpersonate(true, hToken.ResetAndGetAddress()))
				// check token membership
				bRes = CheckTokenMembership(hToken, psidGroup, &bIsInGroup);
            else
				// called from same thread
				bRes = CheckTokenMembership(NULL, psidGroup, &bIsInGroup);
			}

		if (!bRes)
            ft.TranslateError
				(
				VSSDBG_GEN,
				HRESULT_FROM_WIN32(GetLastError()),
				L"CheckTokenMembership"
				);

		}
    VSS_STANDARD_CATCH(ft)

	HRESULT hr = ft.hr;

    // Catch possible AVs
    try
		{
        //  Free the previously allocated SID
        if (psidGroup)
            ::FreeSid( psidGroup );
		}
    VSS_STANDARD_CATCH(ft)

    // Pass down the exception, if any
    if (FAILED(hr))
        throw(hr);

    return bIsInGroup ? true : false;
	}

bool HasPrivilege(LPWSTR wszPriv, bool bImpersonate)

/*++

Routine Description:

    Return TRUE if the current thread/process has a specific privilege

Arguments:


    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the specified group is between token groups.

Return Value:

    true, if the caller thread is running under the context of the specified group
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
    CVssFunctionTracer ft( VSSDBG_GEN, L"HasPrivilege" );

	BOOL bHasPrivilege = false;
	CVssAutoWin32Handle  hToken;

	LUID TokenValue;
	if (!LookupPrivilegeValue (NULL, wszPriv, &TokenValue))
		ft.TranslateError
			(
			VSSDBG_GEN,
			HRESULT_FROM_WIN32(GetLastError()),
			L"LookupPrivilegeValue"
			);

    DoImpersonate(bImpersonate, hToken.ResetAndGetAddress());

	BYTE rgb[sizeof(LUID_AND_ATTRIBUTES) + sizeof(PRIVILEGE_SET)];
	PRIVILEGE_SET *pSet = (PRIVILEGE_SET *) rgb;

	pSet->PrivilegeCount = 1;
	pSet->Control = PRIVILEGE_SET_ALL_NECESSARY;
	pSet->Privilege[0].Luid = TokenValue;
	pSet->Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;
	
	if (!PrivilegeCheck(hToken, pSet, &bHasPrivilege))
		ft.TranslateError
			(
			VSSDBG_GEN,
			HRESULT_FROM_WIN32(GetLastError()),
			L"PrivilegeCheck"
			);

    return bHasPrivilege ? true : false;
	}


TOKEN_OWNER *GetClientTokenOwner(BOOL bImpersonate)

/*++

Routine Description:

    Return TOKEN_OWNER of client process

Arguments:


    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we return the client sid of that token

Return Value:

	SID of client thread

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
    CVssFunctionTracer ft( VSSDBG_GEN, L"GetClientTokenOwner" );

	BOOL bRes;

    CVssAutoWin32Handle  hToken;

	DoImpersonate(bImpersonate, hToken.ResetAndGetAddress());

    DWORD cbSid;
    bRes = ::GetTokenInformation
			(
            hToken,         //  IN HANDLE TokenHandle,
            TokenOwner,  //  IN TOKEN_INFORMATION_CLASS TokenInformationClass,
            NULL,           //  OUT LPVOID TokenInformation,
            0,              //  IN DWORD TokenInformationLength,
            &cbSid     		//  OUT PDWORD ReturnLength
            );

	BS_ASSERT( bRes == FALSE );

    DWORD dwError = GetLastError();
    if ( dwError != ERROR_INSUFFICIENT_BUFFER )
		{
		ft.LogError(VSS_ERROR_EXPECTED_INSUFFICENT_BUFFER, VSSDBG_GEN << (HRESULT) dwError);
        ft.Throw
			(
			VSSDBG_GEN,
			E_UNEXPECTED,
			L"ERROR_INSUFFICIENT_BUFFER expected error . [0x%08lx]",
			dwError
			);
        }

    //  Allocate the buffer needed to get the Token Groups information
	TOKEN_OWNER *pToken = (TOKEN_OWNER*) new BYTE[cbSid];
    if (pToken == NULL)
		ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error.");

	//  Get the all Group SIDs in the token
	DWORD cbTokenObtained;
	bRes = ::GetTokenInformation
		(
		hToken,             //  IN HANDLE TokenHandle,
		TokenOwner,        	//  IN TOKEN_INFORMATION_CLASS TokenInformationClass,
		pToken,            	//  OUT LPVOID TokenInformation,
		cbSid,         		//  IN DWORD TokenInformationLength,
		&cbTokenObtained 	//  OUT PDWORD ReturnLength
		);

	if ( !bRes )
        ft.TranslateError
			(
			VSSDBG_GEN,
			HRESULT_FROM_WIN32(GetLastError()),
            L"GetTokenInformation"
			);

    if (cbTokenObtained != cbSid)
		{
		ft.LogError(VSS_ERROR_GET_TOKEN_INFORMATION_BUFFER_SIZE_MISMATCH, VSSDBG_GEN << (INT) cbTokenObtained << (INT) cbSid);
		ft.Throw
			(
			VSSDBG_GEN,
			E_UNEXPECTED,
			L"Unexpected error. Final buffer size = %lu, original size was %lu",
			cbTokenObtained,
			cbSid
			);
        }

    return pToken;
	}



bool IsAdministrator()
/*++

Routine Description:

    Return TRUE if the current thread/process is running under the context of an administrator

Arguments:

    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the Administrators group is between token groups.

Return Value:

    true, if the caller thread is running under the context of an administrator
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return IsInGroup(DOMAIN_ALIAS_RID_ADMINS, true);
	}

bool IsProcessAdministrator()
/*++

Routine Description:

    Return TRUE if the current process is running under the context of an administrator

Arguments:

    none

Remarks:
    The current process is asked for the access token.
    After that we check if the Administrators group is between token groups.

Return Value:

    true, if the process is running under the context of an administrator
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return IsInGroup(DOMAIN_ALIAS_RID_ADMINS, false);
	}



bool IsBackupOperator()
/*++

Routine Description:

    Return TRUE if the current thread/process is running under the context of a backup operator

Arguments:

    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the Administrators group is in the groups token
	or the backup privilege is enabled

Return Value:

    true, if the caller thread is running under the context of an administrator
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return HasPrivilege(SE_BACKUP_NAME, true) || IsAdministrator();
	}

bool IsRestoreOperator()
/*++

Routine Description:

    Return TRUE if the current thread/process is running under the context of a restore operator

Arguments:

    none

Remarks:

    The current impersonation thread is asked for the access token.
    After that we check if the Administrators group is in the token groups or
	if the restore privilege is enabled.

Return Value:

    true, if the caller thread is running under the context of an administrator
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return HasPrivilege(SE_RESTORE_NAME, true) || IsAdministrator();
	}


bool IsProcessBackupOperator()
/*++

Routine Description:

    Return TRUE if the current process is running under the context of a backup operator

Arguments:

    none

Remarks:

Return Value:

    true, if the process is running under the context of an administrator or
	has SE_BACKUP_NAME privilege enabled
    false, otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return HasPrivilege(SE_BACKUP_NAME, false) || IsProcessAdministrator();
	}

bool IsProcessRestoreOperator()
/*++

Routine Description:

    Return TRUE if the current process is running under the context of a restore operator

Arguments:

    none

Remarks:

Return Value:

    true, if the process is running under the context of an administrator
	or has the SE_RESTORE_NAME privilege; false otherwise

Thrown exceptions:

    E_UNEXPECTED    // Runtime error
    E_OUTOFMEMORY   // Memory allocation error

--*/

	{
	return HasPrivilege(SE_RESTORE_NAME, false) || IsProcessAdministrator();
	}



// turn on a particular security privilege
HRESULT TurnOnSecurityPrivilege(LPCWSTR wszPriv)

/*++

Routine Description:

    sets the specified privilege on the process token

Arguments:

    none

Remarks:

Return Value:
	status code for operation

Thrown exceptions:
	none
--*/

    {
	HANDLE	hProcessToken = INVALID_HANDLE_VALUE;
	BOOL	bProcessTokenValid = FALSE;

	CVssFunctionTracer ft(VSSDBG_GEN, L"TurnOnSecurityPrivilege");
	try
		{
		LUID	TokenValue = {0, 0};


		bProcessTokenValid = OpenProcessToken
								(
								GetCurrentProcess(),
								TOKEN_ADJUST_PRIVILEGES,
								&hProcessToken
								);

		if (!bProcessTokenValid)
			ft.TranslateError
				(
				VSSDBG_GEN,
                HRESULT_FROM_WIN32(GetLastError()),
				L"OpenProcessToken"
				);

				
		if (!LookupPrivilegeValue (NULL, wszPriv, &TokenValue))
			ft.TranslateError
				(
				VSSDBG_GEN,
                HRESULT_FROM_WIN32(GetLastError()),
				L"LookupPrivilegeValue"
				);

		TOKEN_PRIVILEGES	NewTokenPrivileges;

		NewTokenPrivileges.PrivilegeCount           = 1;
		NewTokenPrivileges.Privileges[0].Luid       = TokenValue;
		NewTokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

		// AdjustTokenPrivileges succeeds even the token isn't set
		SetLastError(ERROR_SUCCESS);

		AdjustTokenPrivileges
			(	
			hProcessToken,
			FALSE,
			&NewTokenPrivileges,
			sizeof (NewTokenPrivileges),
			NULL,
			NULL
			);


        DWORD dwErr = GetLastError();
		if (dwErr != ERROR_SUCCESS)
			ft.TranslateError
				(
				VSSDBG_GEN,
				HRESULT_FROM_WIN32(GetLastError()),
				L"AdjustTokenPrivileges"
				);
		}
	VSS_STANDARD_CATCH(ft)

	if (bProcessTokenValid)
		CloseHandle (hProcessToken);

    return ft.hr;
    }

// turn on backup security privilege
HRESULT TurnOnSecurityPrivilegeBackup()
	{
	return TurnOnSecurityPrivilege(SE_BACKUP_NAME);
	}

// turn on restore security privilege
HRESULT TurnOnSecurityPrivilegeRestore()
	{
	return TurnOnSecurityPrivilege(SE_RESTORE_NAME);
	}



// determine if the process is a local service
bool IsProcessLocalService()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"IsProcessLocalService");

	BYTE rgbSid[256];
	DWORD cbSid = sizeof(rgbSid);
	TOKEN_OWNER *pOwner = GetClientTokenOwner(FALSE);

	if (!CreateWellKnownSid(WinLocalServiceSid, NULL, (SID *) rgbSid, &cbSid))
		{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_GEN, L"CreateWellKnownSid");
		}

	return EqualSid(pOwner->Owner, (SID *) rgbSid) ? true : false;
	}

// determine if the process is a local service
bool IsProcessNetworkService()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"IsProcessNetworkService");

	BYTE rgbSid[256];
	TOKEN_OWNER *pOwner = GetClientTokenOwner(FALSE);
	DWORD cbSid = sizeof(rgbSid);

	if (!CreateWellKnownSid(WinNetworkServiceSid, NULL, (SID *) rgbSid, &cbSid))
		{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.CheckForError(VSSDBG_GEN, L"CreateWellKnownSid");
		}

	return EqualSid(pOwner->Owner, (SID *) rgbSid) ? true : false;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\alloc.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Alloc.cxx | Automatic allocation of diff areas
    @end

Author:

    Adi Oltean  [aoltean]   06/01/2000

Revision History:

    Name        Date        Comments

    aoltean     06/01/2000  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"
#include "vssmsg.h"

#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "vs_reg.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "diff.hxx"
#include "alloc.hxx"
#include "qsnap.hxx"
#include "provider.hxx"

#include "diffmgmt.hxx"
#include "diffreg.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRALLOC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Constants

// The minimum free space for a diff area
const nRemainingFreeSpace = 20 * 1024 * 1024;


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffAreaAllocator constructors/destructors


CVssDiffAreaAllocator::CVssDiffAreaAllocator(
    IN  LONG lContext,
    IN  VSS_ID SnapshotSetID
    ):
    m_bChangesCommitted(false),
    m_bNoChangesNeeded(false),
    m_lContext(lContext),
    m_SnapshotSetID(SnapshotSetID)
{
    CVssFunctionTracer( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::CVssDiffAreaAllocator");

    BS_ASSERT(SnapshotSetID != GUID_NULL);
}


CVssDiffAreaAllocator::~CVssDiffAreaAllocator()
{
    CVssFunctionTracer( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::~CVssDiffAreaAllocator");
    int nIndex;

    // The Rollback function should not throw.
    if (!m_bChangesCommitted && !m_bNoChangesNeeded)
        Rollback();

    // Deallocate all the associations
    for (nIndex = 0; nIndex < m_mapOriginalVolumes.GetSize(); nIndex++)
        delete m_mapOriginalVolumes.GetValueAt(nIndex);

    // Deallocate all the volume names
    for (nIndex = 0; nIndex < m_mapOriginalVolumes.GetSize(); nIndex++)
        ::VssFreeString(m_mapOriginalVolumes.GetKeyAt(nIndex));

    // Deallocate all the diff area candidates
    // This will delete the associated volume names also (which are the keys)
    for (nIndex = 0; nIndex < m_mapDiffAreaCandidates.GetSize(); nIndex++)
	    delete m_mapDiffAreaCandidates.GetValueAt(nIndex);
}


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffAreaAllocator Public operations

void CVssDiffAreaAllocator::AssignDiffAreas() throw(HRESULT)
/*++

Routine description:

    Assign all the diff areas for the current snapshot set.

Throws:

    VSS_E_PROVIDER_VETO
    E_UNEXPECTED
    VSS_E_INSUFFICIENT_STORAGE
        - insufficient diff area

    [CVssDiffAreaAllocator::Initialize() failures]
        E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::AssignDiffAreas");


    // Fill out various internal structures (like the list of original volumes)
    Initialize();

    // If no volumes to snapshot then we are done.
    if (m_bNoChangesNeeded)
        return;

    // Find the candidates for the diff areas
    FindDiffAreaCandidates();

    // Deal with no candidates scenario...
    // If no candidates then we will stop here and inform the user to add more NTFS disk space.
    if (m_mapDiffAreaCandidates.GetSize() == 0) {
        ft.LogError( VSS_ERROR_NO_DIFF_AREAS_CANDIDATES, VSSDBG_SWPRV);
        ft.Throw( VSSDBG_SWPRV, VSS_E_INSUFFICIENT_STORAGE, L"Cannot find a diff area candidate");
    }

    // Clear the non-necessary diff areas and compute the number of allocated
    // diff areas that already exist on each candidate
    ComputeExistingDiffAreasCount();

    // planning of new diff areas
    PlanNewDiffAreas();

    // effectively allocate the diff areas for the voluems to be snapshotted
    AssignPlannedDiffAreas();
}


void CVssDiffAreaAllocator::Commit()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::Commit");

    m_bChangesCommitted = true;
}


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffAreaAllocator Private operations


void CVssDiffAreaAllocator::Initialize() throw(HRESULT)
/*++

Routine description:

    Initialize the internal data structures

Throws:

    E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::Initialize");

    // Get the list of volumes to be snapshotted
    BS_ASSERT(m_mapOriginalVolumes.GetSize() == 0);
	CVssSnapIterator snapIterator;
    while (true)
    {
		CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(m_SnapshotSetID);

		// End of enumeration?
		if (ptrQueuedSnapshot == NULL)
			break;

		// Get the snapshot structure
		PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
		BS_ASSERT(pProp != NULL);

        // Ignore the snapshots that are not in the PREPARING state.
        if (ptrQueuedSnapshot->GetStatus() == VSS_SS_PREPARING) {
            // Make a copy of the volume name
            BS_ASSERT(pProp->m_pwszOriginalVolumeName && pProp->m_pwszOriginalVolumeName[0]);
            LPWSTR wszOriginalVolumeName = NULL;
            ::VssSafeDuplicateStr( ft, wszOriginalVolumeName, pProp->m_pwszOriginalVolumeName );
            BS_ASSERT(wszOriginalVolumeName);

            // Check to see if the volume is snapshotted
            // If is has already snapshots, do not attempt to change its diff area.
            LONG lVolAttr = CVsSoftwareProvider::GetVolumeInformationFlags(wszOriginalVolumeName, VSS_CTX_ALL);
            BS_ASSERT(lVolAttr & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT);
            if ((lVolAttr & CVsSoftwareProvider::VSS_VOLATTR_SNAPSHOTTED) != 0)
                continue;

            // Add the corresponding diff area
            CVssDiffAreaAssociation* pAssociation = new CVssDiffAreaAssociation(wszOriginalVolumeName);
            if (pAssociation == NULL)
                ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");

            // Add the volume to the ones needed for diff area
            if (!m_mapOriginalVolumes.Add(wszOriginalVolumeName, pAssociation)) {
                ::VssFreeString(wszOriginalVolumeName);
                ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");
            }
        }
    }

    // If there are no volumes to process then make this explicit
    if (m_mapOriginalVolumes.GetSize() == 0) {
        m_bNoChangesNeeded = true;
        return;
    }
}


void CVssDiffAreaAllocator::FindDiffAreaCandidates() throw(HRESULT)
/*++

Routine description:

    Find the candidates for the diff areas
    Compute various parameters like the number of allocated diff areas on each candidate

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO
        - FindFirstVolume, FindNextVolume errors

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::FindDiffAreaCandidates");

	// Search between all mounted volumes
	bool bFirstVolume = true;
    CVssAutoSearchHandle hSearch;
	WCHAR wszVolumeName[MAX_PATH+1];
	while(true) {
	
		// Get the volume name
		if (bFirstVolume) {
			hSearch.Set(::FindFirstVolumeW( wszVolumeName, MAX_PATH));
			if (hSearch == INVALID_HANDLE_VALUE)
				ft.TranslateInternalProviderError( VSSDBG_SWPRV,
				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
				    L"FindFirstVolumeW( [%s], MAX_PATH)", wszVolumeName);
			bFirstVolume = false;
		} else {
			if (!::FindNextVolumeW( hSearch, wszVolumeName, MAX_PATH) ) {
				if (GetLastError() == ERROR_NO_MORE_FILES)
					break;	// End of iteration
				else
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV,
    				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    				    L"FindNextVolumeW( %p, [%s], MAX_PATH)", hSearch, wszVolumeName);
			}
		}

        BS_ASSERT( wszVolumeName[0] );

        // Make sure the volume si supported for diff area (fixed, NTFS, read-write)
        LONG lDiffVolumeFlags = CVsSoftwareProvider::GetVolumeInformationFlags( wszVolumeName, VSS_CTX_ALL);
        if ((lDiffVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_DIFF_AREA) == 0)
            continue;

        // Get its free space
        ULARGE_INTEGER ulnFreeBytesAvailable;
        ULARGE_INTEGER ulnTotalNumberOfBytes;
        ULARGE_INTEGER ulnTotalNumberOfFreeBytes;
        if (!::GetDiskFreeSpaceEx(wszVolumeName,
                &ulnFreeBytesAvailable,
                &ulnTotalNumberOfBytes,
                &ulnTotalNumberOfFreeBytes
                )){
            ft.Trace( VSSDBG_SWPRV, L"Cannot get the free space for volume (%s) - [0x%08lx]",
                      wszVolumeName, GetLastError());
            BS_ASSERT(false);
            continue;
        }

        // Check to see if the free space is enough for at least one diff area
        if (ulnTotalNumberOfFreeBytes.QuadPart <
                (ULONGLONG)(nRemainingFreeSpace + nDefaultInitialSnapshotAllocation)) {
            ft.Trace( VSSDBG_SWPRV, L"Encountered a volume (%s) with "
                      L"insufficient free space for one allocation (%I64u)",
                      wszVolumeName, ulnFreeBytesAvailable);
            continue;
        }

        // Add the local volume as a candidate
        LPWSTR wszCandidate = NULL;
        ::VssSafeDuplicateStr(ft, wszCandidate, wszVolumeName);

        // Create the candidate object that must keep this information.
        CVssDiffAreaCandidate* pObj =
            new CVssDiffAreaCandidate(wszCandidate, ulnFreeBytesAvailable);
        if (pObj == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");

        // Add the candidate object into the array
        if (!m_mapDiffAreaCandidates.Add(wszCandidate, pObj)) {
            delete pObj;
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");
        }

        ft.Trace( VSSDBG_SWPRV, L"Candidate added: (\'%s\', %I64u)",
                  wszCandidate, ulnFreeBytesAvailable );
    }
}


void CVssDiffAreaAllocator::ComputeExistingDiffAreasCount() throw(HRESULT)
/*++

Description:

    Compute the nunber of original volumes that keeps diff areas on this volume.
    This does not include volumes on which there are no existing shapshots.

    Stores the results in the properties of the existing candidates objects list.

WARNING:

    This method will clear the diff area settings for volumes who keep no snapshots
    (but for us it doesn't matter)

Throws:

    VSS_E_PROVIDER_VETO
        - failure in FindFirstVolume/FindNextVolume, IVssEnumObject::Next
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::ComputeExistingDiffAreasCount" );

    BS_ASSERT(m_mapDiffAreaCandidates.GetSize() != 0);

    CVssDiffArea diffobj;

	// Search between all mounted volumes
	bool bFirstVolume = true;
    CVssAutoSearchHandle hSearch;
	WCHAR wszQueriedVolumeName[MAX_PATH+1];
	while(true) {
	
		// Get the volume name
		if (bFirstVolume) {
			hSearch.Set(::FindFirstVolumeW( wszQueriedVolumeName, MAX_PATH));
			if (hSearch == INVALID_HANDLE_VALUE)
				ft.TranslateInternalProviderError( VSSDBG_SWPRV,
				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
				    L"FindFirstVolumeW( [%s], MAX_PATH)", wszQueriedVolumeName);
			bFirstVolume = false;
		} else {
			if (!::FindNextVolumeW( hSearch, wszQueriedVolumeName, MAX_PATH) ) {
				if (GetLastError() == ERROR_NO_MORE_FILES)
					break;	// End of iteration
				else
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV,
    				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    				    L"FindNextVolumeW(%p,[%s],MAX_PATH)", hSearch, wszQueriedVolumeName);
			}
		}

        BS_ASSERT( wszQueriedVolumeName[0] );

        // Make sure the volume si supported for snapshot (fixed, NTFS, read-write)
        LONG lVolumeFlags = CVsSoftwareProvider::GetVolumeInformationFlags( wszQueriedVolumeName, VSS_CTX_ALL);
        if ((lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SNAPSHOTTED) == 0)
            continue;

        // Make sure the volume is not proposed for snapshots in the current set.
        // This is needed since diff area files for existing snapshots cannot grow if the volume will be snapshotted right now.
        // (i.e. in the case of multiple snasphots on a volume, only the last snasphot's diff area grows)
        if (m_mapOriginalVolumes.Lookup(wszQueriedVolumeName))
            continue;

        // Initialize the diff area object
        // This might fail...
        diffobj.Initialize(wszQueriedVolumeName);

        // Enumerate the diff area volumes for the queried volume.
        // Increment the "diff areas" counter for the corresponding diff area volume
        diffobj.IncrementCountOnPointedDiffAreas( this );
    }

    // Result of computation
    for(int nIndex = 0; nIndex < m_mapDiffAreaCandidates.GetSize(); nIndex++) {
	    CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.GetValueAt(nIndex);
        ft.Trace( VSSDBG_SWPRV, L"Number of diff areas for volume '%s' = %d",
                  pObj->GetVolumeName(), pObj->GetExistingDiffAreas() );
    }
}


void CVssDiffAreaAllocator::IncrementExistingDiffAreaCountOnVolume(
    IN  LPWSTR pwszDiffAreaVolumeName
    )

/*++

Description:

    Increment the "diff areas" counter for the corresponding diff area volume
    This routine is called for each diff area voplume for the queried volume name.

Arguments:

    pwszDiffAreaVolumeName - The diff area for the queried volume name

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::OnDiffAreaVolume");

    CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.Lookup(pwszDiffAreaVolumeName);

    // If this volume is also a diff area candidate then increment the
    // associated counter of existing diff areas
    if (pObj)
        pObj->IncrementExistingDiffAreas();
}


void CVssDiffAreaAllocator::PlanNewDiffAreas() throw(HRESULT)
/*++

Description:

    Planning of new diff areas

Throws:

    VSS_E_INSUFFICIENT_STORAGE
        - insufficient diff area specified

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::PlanNewDiffAreas");

    BS_ASSERT(m_mapDiffAreaCandidates.GetSize() > 0);

    // Repeat the allocation sequence for each volume to be snapshotted.
    INT nNeededBackupDiffAreas = 0;
    for(INT nVolumeIndex = 0; nVolumeIndex < m_mapOriginalVolumes.GetSize(); nVolumeIndex++)
    {
        // This is the volume to be snapshotted
        VSS_PWSZ pwszVolumeName = m_mapOriginalVolumes.GetKeyAt(nVolumeIndex);

        // If there is an assigned diff area in Registry, use that one
        CVssProviderRegInfo& regInfo = CVssDiffMgmt::GetRegInfo();
        CVssAutoPWSZ awszDiffAreaVolumeName;
        LONGLONG llMaxSize = 0;
        if (regInfo.GetDiffAreaForVolume(pwszVolumeName, awszDiffAreaVolumeName.GetRef(), llMaxSize))
        {
            // Check to see if the diff area found in registry is a diff area candidate also
            CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.Lookup(awszDiffAreaVolumeName);
            if (pObj == NULL)
            {
                ft.Trace( VSSDBG_SWPRV, L"Invalid diff area %s specified in registry for volume %s. Using the default one",
                    awszDiffAreaVolumeName.GetRef(), pwszVolumeName);
                // The diff area volume specified in the registry does not hold enough space
                ft.Throw( VSSDBG_SWPRV,
                    VSS_E_INSUFFICIENT_STORAGE, L"The volume %s must be able to support a diff area",
                    pwszVolumeName);
            }
            else
            {
                // Increment the planned diff areas
                pObj->IncrementPlannedDiffAreas();

                // Add the corresponding diff area
                CVssDiffAreaAssociation* pAssociation = m_mapOriginalVolumes.GetValueAt(nVolumeIndex);
                BS_ASSERT(pAssociation);
                pAssociation->SetDiffArea(awszDiffAreaVolumeName, llMaxSize);

                // Continue with the next volume
                continue;
            }
        }

        // Otherwise: No diff area (or invalid diff area) specified in registry.
        // Now we have two cases: timewarp vs. backup.

        // If we are in non-backup case we will choose the same volume as the snapshotted one.
        // We are supposing that the volume is a diff area candidate also
        if (m_lContext == VSS_CTX_CLIENT_ACCESSIBLE)
        {
            // Check to see if the diff area found in registry is a diff area candidate also
            CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.Lookup(pwszVolumeName);
            if (pObj == NULL)
            {
                // This might happen if the volume temporarily dissapeared when m_mapDiffAreaCandidates
                // was filled. In this case this call will throw the correct error code.
                LONG lVolAttr = CVsSoftwareProvider::GetVolumeInformationFlags(pwszVolumeName, VSS_CTX_CLIENT_ACCESSIBLE);
                // Detail the error. One of these asserts must fail.
                BS_ASSERT(lVolAttr & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT);
                BS_ASSERT(lVolAttr & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_DIFF_AREA);
                // The diff area volume specified in the registry does not hold enough space, or
                // an extremely rare case - the volume dissapeared when m_mapDiffAreaCandidates was filled and then reappeared again.
                ft.Throw( VSSDBG_SWPRV,
                    VSS_E_INSUFFICIENT_STORAGE, L"The timewarp volume %s [0x%08lx] must be able to support a diff area",
                    pwszVolumeName, lVolAttr);
            }

            // Get the default max space
            llMaxSize = (LONGLONG) (pObj->GetVolumeFreeSpace() * VSS_TW_DEFAULT_MAX_SPACE_PERCENT / 100);

            // Increment the planned diff areas
            pObj->IncrementPlannedDiffAreas();

            // Add the corresponding diff area
            CVssDiffAreaAssociation* pAssociation = m_mapOriginalVolumes.GetValueAt(nVolumeIndex);
            BS_ASSERT(pAssociation);
            pAssociation->SetDiffArea(pwszVolumeName, llMaxSize);

            // Continue with the next volume
            continue;
        }

        // The diff area for this volume must be established using the backup algorithm
        // For this volume, the assigned diff area will be still NULL.
        nNeededBackupDiffAreas++;
    }

    // We have now nNeededBackupDiffAreas volumes without a diff area assigned yet.
    // We need first to compute the sublist of diff area candidates.
    // The list will contain (nNeededBackupDiffAreas) entries
    for(INT nNeededDiffIndex = 0; nNeededDiffIndex < nNeededBackupDiffAreas; nNeededDiffIndex++)
    {
        // Find a diff area candidate that will remain with
        // maximum free space per hosted diff area
        INT nCandidateIndex = -1;
        double lfMaxFreeSpacePerHostedDiffArea = 0;
        for(int nIndex = 0; nIndex < m_mapDiffAreaCandidates.GetSize(); nIndex++)
        {
	        CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.GetValueAt(nIndex);
            BS_ASSERT(pObj);

            // We try to add *another* diff area and we estimate the results.
            INT nEstimatedDiffAreas = 1 + pObj->GetPlannedDiffAreas();

            // What will be the free space if we will allocate another diff area?
            // We will ignore the allocated space for the new diff areas in order to keep
            // the algorithm simple to understand
            double lfRemainingFreeSpaceAfterAllocation = pObj->GetVolumeFreeSpace();

            // What will be the free space per hosted diff area (including estimated ones)?
            double lfFreeSpacePerHostedDiffArea =
                lfRemainingFreeSpaceAfterAllocation / (nEstimatedDiffAreas + pObj->GetExistingDiffAreas());

            // Is the current volume a better candidate?
            if (lfFreeSpacePerHostedDiffArea > lfMaxFreeSpacePerHostedDiffArea) {
                nCandidateIndex = nIndex;
                lfMaxFreeSpacePerHostedDiffArea = lfFreeSpacePerHostedDiffArea;
            }
        }

        BS_ASSERT( nCandidateIndex >= 0 );

        // We found another candidate.
        CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.GetValueAt(nCandidateIndex);

        // Check to see if we have enough free space per diff area
        if (lfMaxFreeSpacePerHostedDiffArea < nRemainingFreeSpace) {
            // Indicate to the user the requirement that it should provide more space.
            ft.LogError( VSS_ERROR_NO_DIFF_AREAS_CANDIDATES, VSSDBG_SWPRV);
            ft.Throw( VSSDBG_SWPRV, VSS_E_INSUFFICIENT_STORAGE,
                      L"Not enough free space (%.1f) on any diff area. Best bet: '%s - %.1f'",
                      lfMaxFreeSpacePerHostedDiffArea,
                      pObj->GetVolumeName(),
                      pObj->GetVolumeFreeSpace());
        }

        // Increment the planned diff areas
        pObj->IncrementPlannedDiffAreasForBackup();

        ft.Trace( VSSDBG_SWPRV,
            L"\r\n   New hosting candidate: '%s'. \r\n\tExisting: %d, \r\n\tplanned: %d, \r\n\tFree: (%.1f). \r\n\tRelative (%.1f)\r\n",
            pObj->GetVolumeName(),
            pObj->GetExistingDiffAreas(),
            pObj->GetPlannedDiffAreas(),
            pObj->GetVolumeFreeSpace(),
            lfMaxFreeSpacePerHostedDiffArea
            );
    }

    // For each volume to be snapshotted using hte backup algorithm,
    // check to see if we can put the diff area on the same volume
    // If yes, proceed.
    INT nRemainingDiffCount = nNeededBackupDiffAreas;
    for (int nIndex = 0; nIndex < m_mapOriginalVolumes.GetSize(); nIndex++)
    {
        // Get the diff area association object
        CVssDiffAreaAssociation* pAssoc = m_mapOriginalVolumes.GetValueAt(nIndex);
        BS_ASSERT(pAssoc);

        // If we already assigned a diff area, ignore
        if (pAssoc->IsDiffAreaAssigned())
            continue;

        // The current volume is a diff area candidate also?
        // If not we cannot reassign the diff area to itself
        CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.Lookup(pAssoc->GetOriginalVolumeName());
        if (pObj == NULL)
            continue;
        BS_ASSERT(::wcscmp(pObj->GetVolumeName(), pAssoc->GetOriginalVolumeName()) == 0);

        // We have remaining planned diff areas on the same volume?
        BS_ASSERT(pObj->GetPlannedDiffAreasForBackup() >= 0);
        if (pObj->GetPlannedDiffAreasForBackup() == 0)
            continue;

        // We reserve the planned diff area for backup.
        BS_ASSERT(pObj);
        pObj->DecrementPlannedDiffAreasForBackup();

        // We mark that volume as auto-assigned
        pAssoc->SetDiffArea(pAssoc->GetOriginalVolumeName(), VSS_ASSOC_NO_MAX_SPACE);

        // We just consumed one diff area candidate
        nRemainingDiffCount--;
    }

    // For each volume to be snapshotted using the backup algorithm,
    // and which is not a diff area candidate, assign another diff area
    int nNextCandidateIndex = 0;
    CVssDiffAreaCandidate* pCandidate = NULL;
    for (int nIndex = 0; nIndex < m_mapOriginalVolumes.GetSize(); nIndex++)
    {
        // Get the diff area association object
        CVssDiffAreaAssociation* pAssoc = m_mapOriginalVolumes.GetValueAt(nIndex);
        BS_ASSERT(pAssoc);

        // If we already assigned a diff area, ignore
        if (pAssoc->IsDiffAreaAssigned())
            continue;

        // The current volume is a diff area candidate also?
        // If not we cannot reassign the diff area to itself
        CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.Lookup(pAssoc->GetOriginalVolumeName());
        BS_ASSERT((pObj == NULL) || (pObj->GetPlannedDiffAreasForBackup() == 0));

        // If there are no remainig diff areas on the current candidate, go and search another ones
        // Iterate through the next available diff area candidate for backup
        // Otherwise use another diff area for backup snapshot
        if ((pCandidate == NULL) || (pCandidate->GetPlannedDiffAreasForBackup() == 0))
            while(true) {
                // Premature end of cycle
                if (nNextCandidateIndex >= m_mapDiffAreaCandidates.GetSize()){
                    BS_ASSERT(false); // Programming error. Too few diff area candidates for backup.
                    ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Cannot find anymore diff area candidates for volume %s [%d]",
                        pAssoc->GetOriginalVolumeName(), nIndex);
                }
                // Next candidate?
                pCandidate = m_mapDiffAreaCandidates.GetValueAt(nNextCandidateIndex++);
                BS_ASSERT(pCandidate);
                // We found a candidate
                if (pCandidate && (pCandidate->GetPlannedDiffAreasForBackup() > 0))
                    break;
            }

        // We have remaining planned diff areas?
        BS_ASSERT(pCandidate->GetPlannedDiffAreasForBackup() >= 0);

        // We reserve the planned diff area for backup.
        pCandidate->DecrementPlannedDiffAreasForBackup();

        // We allocate the diff area
        pAssoc->SetDiffArea(pCandidate->GetVolumeName(), VSS_ASSOC_NO_MAX_SPACE);

        // We just consumed one diff area candidate
        nRemainingDiffCount--;
    }

    //
    // Safety checks
    //

    BS_ASSERT(nRemainingDiffCount == 0);

    // The rest of candidates should not be usable for backup
    while(true) {
        BS_ASSERT(!pCandidate || (pCandidate->GetPlannedDiffAreasForBackup() == 0));
        if (nNextCandidateIndex >= m_mapDiffAreaCandidates.GetSize())
            break;
        pCandidate = m_mapDiffAreaCandidates.GetValueAt(nNextCandidateIndex++);
    }

    // Check if all planned diff areas for backup were used.
    for(int nDiffIndex = 0; nDiffIndex < m_mapDiffAreaCandidates.GetSize(); nDiffIndex++) {
	    CVssDiffAreaCandidate* pObj = m_mapDiffAreaCandidates.GetValueAt(nDiffIndex);
        BS_ASSERT(pObj);

        // We have remaining planned diff areas?
        if (pObj->GetPlannedDiffAreasForBackup() != 0) {
            BS_ASSERT(false);
            ft.Trace( VSSDBG_SWPRV,
                      L"FALSE ASSERT: remaining planned diff areas (%d, %d) on '%s'",
                      pObj->GetPlannedDiffAreas(), pObj->GetPlannedDiffAreasForBackup(), pObj->GetVolumeName() );
        }

        // Check if all planned diff areas are correctly assigned.
        int nVolumesServed = 0;
        for(int nVolIndex = 0; nVolIndex < m_mapOriginalVolumes.GetSize(); nVolIndex++) {
    	    CVssDiffAreaAssociation* pAssoc = m_mapOriginalVolumes.GetValueAt(nVolIndex);
            BS_ASSERT(pAssoc);

            if (::wcscmp(pAssoc->GetDiffAreaVolumeName(), pObj->GetVolumeName()) == 0)
                nVolumesServed++;
        }

        if (nVolumesServed != pObj->GetPlannedDiffAreas()) {
            BS_ASSERT(false);
            ft.Trace( VSSDBG_SWPRV,
                      L"FALSE ASSERT: remaining planned diff areas (%d, %d) on '%s'. Expected: %d",
                      pObj->GetPlannedDiffAreas(), pObj->GetPlannedDiffAreasForBackup(), pObj->GetVolumeName(), nVolumesServed);
        }
    }
}


// effectively allocate the diff areas for the voluems to be snapshotted
void CVssDiffAreaAllocator::AssignPlannedDiffAreas() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::AssignPlannedDiffAreas");

    CVssDiffArea diffobj;

    //
    // For each volume to be snapshotted, associate its diff area
    //

    // For each volume to be snapshotted, check to see if we can put the diff area on the same volume
    for (int nIndex = 0; nIndex < m_mapOriginalVolumes.GetSize(); nIndex++)
    {
        // Get the diff area association object
        CVssDiffAreaAssociation* pAssoc = m_mapOriginalVolumes.GetValueAt(nIndex);
        BS_ASSERT(pAssoc);

        //
        // Assign the founded diff area to the snapshotted volume
        //

        // Initialize the diff area object
        // If an error is encountered then it is already logged.
        diffobj.Initialize(pAssoc->GetOriginalVolumeName());

        // Add the volume to the diff area
        // If an error is encountered then it is already logged.
        diffobj.Clear();

        // Add the volume to the diff area
        // If an error is encountered then it is already logged.
        diffobj.AddVolume(pAssoc->GetDiffAreaVolumeName());

        // Set the maximum size
        BS_ASSERT( ( pAssoc->GetMaxSize() == VSS_ASSOC_NO_MAX_SPACE) || ( pAssoc->GetMaxSize() > 0) );
        if (pAssoc->GetMaxSize() != VSS_ASSOC_NO_MAX_SPACE)
            diffobj.ChangeDiffAreaMaximumSize(pAssoc->GetMaxSize());
    }
}


void CVssDiffAreaAllocator::Rollback()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffAreaAllocator::Rollback");

    BS_ASSERT(m_bChangesCommitted == false);
    BS_ASSERT(m_bNoChangesNeeded == false);

    try
    {
        CVssDiffArea diffobj;

        // For each volume to be snapshoted, rollback the diff area assignments
        for (int nIndex = 0; nIndex < m_mapOriginalVolumes.GetSize(); nIndex++) {
            VSS_PWSZ wszVolumeName = m_mapOriginalVolumes.GetKeyAt(nIndex);
            BS_ASSERT( wszVolumeName && wszVolumeName[0] );

            // Initialize the diff area object.
            diffobj.Initialize(wszVolumeName);

            // Clear the diff area on the queried volume.
            diffobj.Clear();
        }
    }
    VSS_STANDARD_CATCH(ft)
}


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffAreaCandidate methods


CVssDiffAreaCandidate::CVssDiffAreaCandidate(
    IN  VSS_PWSZ wszVolumeName,       // Transfer ownership!
    IN  ULARGE_INTEGER ulFreeSpace
    ):
    m_wszVolumeName(wszVolumeName),
    m_ulFreeSpace(ulFreeSpace),
    m_nPlannedDiffAreas(0),
    m_nPlannedDiffAreasForBackup(0),
    m_nExistingDiffAreas(0)
{
}


CVssDiffAreaCandidate::~CVssDiffAreaCandidate()
{
    ::VssFreeString(m_wszVolumeName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\registry\registry.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc  
    @module registry.cxx | Implementation of CVssRegistryKey
    @end

Author:

    Adi Oltean  [aoltean]  03/14/2001

Revision History:

    Name        Date        Comments
    aoltean     03/14/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
// Includes
#include "stdafx.hxx"

#include "vs_inc.hxx"
#include "vs_reg.hxx"


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "REGREGSC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CVssRegistryKey  implementation


// Creates the registry key. 
// Throws an error if the key already exists
void CVssRegistryKey::Create( 
    IN  HKEY        hAncestorKey,
    IN  LPCWSTR     pwszPathFormat,
    IN  ...
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::Create" );

    BS_ASSERT(hAncestorKey);
    BS_ASSERT(pwszPathFormat);
    
    // Build the path to the key
    WCHAR wszKeyPath[VSS_MAX_REG_BUFFER];
    va_list marker;
    va_start( marker, pwszPathFormat );
    _vsnwprintf( wszKeyPath, VSS_MAX_REG_BUFFER, pwszPathFormat, marker );
    va_end( marker );

    // Create the key
    BS_ASSERT(m_samDesired == KEY_ALL_ACCESS);
    DWORD dwDisposition = 0;
    HKEY hRegKey = NULL;
    LONG lRes = ::RegCreateKeyExW(
        hAncestorKey,               //  IN HKEY hKey,
        wszKeyPath,                 //  IN LPCWSTR lpSubKey,
        0,                          //  IN DWORD Reserved,
        REG_NONE,                   //  IN LPWSTR lpClass,
        REG_OPTION_NON_VOLATILE,    //  IN DWORD dwOptions,
        KEY_ALL_ACCESS,             //  IN REGSAM samDesired,
        NULL,                       //  IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        &hRegKey,                   //  OUT PHKEY phkResult,
        &dwDisposition              //  OUT LPDWORD lpdwDisposition
        );
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), L"RegCreateKeyExW(%ld,%s,...)", 
            hAncestorKey, wszKeyPath);

    // Check whether we created or opened the key
    switch ( dwDisposition )
    {
    case REG_CREATED_NEW_KEY: 
        if (!m_awszKeyPath.CopyFrom(wszKeyPath)) {
            ::RegCloseKey( hRegKey );
            ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");
        }
        Close();
        m_hRegKey = hRegKey;
        break;
    case REG_OPENED_EXISTING_KEY:
        ::RegCloseKey( hRegKey );
        ft.Throw( VSSDBG_GEN, VSS_E_OBJECT_ALREADY_EXISTS, L"Key %s already exists", wszKeyPath);
    default:
        BS_ASSERT( false );
        if (hRegKey && (hRegKey != INVALID_HANDLE_VALUE))
            ::RegCloseKey( hRegKey );
        ft.TranslateGenericError(VSSDBG_GEN, E_UNEXPECTED, L"RegCreateKeyExW(%ld,%s,...,[%lu])", 
            hAncestorKey, wszKeyPath, dwDisposition);
    }
}


// Opens a registry key. 
bool CVssRegistryKey::Open( 
    IN  HKEY        hAncestorKey,
    IN  LPCWSTR     pwszPathFormat,
    IN  ...
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::Open" );
    
    BS_ASSERT(hAncestorKey);
    BS_ASSERT(pwszPathFormat);
    
    // Build the path to the key
    WCHAR wszKeyPath[VSS_MAX_REG_BUFFER];
    va_list marker;
    va_start( marker, pwszPathFormat );
    _vsnwprintf( wszKeyPath, VSS_MAX_REG_BUFFER, pwszPathFormat, marker );
    va_end( marker );

    // Open the key
    HKEY hRegKey = NULL;
    LONG lRes = ::RegOpenKeyExW(
        hAncestorKey,               //  IN HKEY hKey,
        wszKeyPath,                 //  IN LPCWSTR lpSubKey,
        0,                          //  IN DWORD dwOptions,
        m_samDesired,               //  IN REGSAM samDesired,
        &hRegKey                    //  OUT PHKEY phkResult
        );
    if ( lRes == ERROR_FILE_NOT_FOUND )
        return false;
    
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), L"RegOpenKeyExW(%ld,%s,...)", 
            hAncestorKey, wszKeyPath);

    if (!m_awszKeyPath.CopyFrom(wszKeyPath)) {
        ::RegCloseKey( hRegKey );
        ft.Throw( VSSDBG_GEN, E_OUTOFMEMORY, L"Memory allocation error");
    }
    
    Close();
    m_hRegKey = hRegKey;

    return true;
}


// Recursively deletes a subkey. 
// Throws an error if the subkey does not exist
void CVssRegistryKey::DeleteSubkey( 
    IN  LPCWSTR     pwszPathFormat,
    IN  ...
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::DeleteSubkey" );
    
    BS_ASSERT(pwszPathFormat);
    
    // Build the path to the key
    WCHAR wszKeyPath[VSS_MAX_REG_BUFFER];
    va_list marker;
    va_start( marker, pwszPathFormat );
    _vsnwprintf( wszKeyPath, VSS_MAX_REG_BUFFER, pwszPathFormat, marker );
    va_end( marker );

    // Recursively delete the key
    DWORD dwRes = ::SHDeleteKey(
        m_hRegKey,                  //  IN HKEY hKey,
        wszKeyPath                  //  IN LPCTSTR  pszSubKey
        );
    if ( dwRes == ERROR_FILE_NOT_FOUND )
        ft.Throw( VSSDBG_GEN, VSS_E_OBJECT_NOT_FOUND, L"Key with path %s\\%s not found", 
            m_awszKeyPath.GetRef(), wszKeyPath);
    if ( dwRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(dwRes), L"SHDeleteKey(%ld[%s],%s)", 
            m_hRegKey, m_awszKeyPath.GetRef(), wszKeyPath);
}


// Adds a LONGLONG value to the registry key
void CVssRegistryKey::SetValue( 
    IN  LPCWSTR     pwszValueName,
    IN  LONGLONG    llValue
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::SetValue_LONGLONG" );

    // Convert the value to a string
    WCHAR wszValue[VSS_MAX_REG_NUM_BUFFER];
    ::swprintf( wszValue, L"%I64d", llValue );

    // Set the value as string
    SetValue(pwszValueName, wszValue);
}


// Adds a VSS_PWSZ value to the registry key
void CVssRegistryKey::SetValue( 
    IN  LPCWSTR     pwszValueName,
    IN  VSS_PWSZ    pwszValue
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::SetValue_PWSZ" );

    // Assert paramters
    BS_ASSERT(pwszValueName);
    BS_ASSERT(pwszValue);

    BS_ASSERT(m_hRegKey);
    
    // Set the value
    DWORD dwLength = ::lstrlenW( pwszValue );
    LONG lRes = ::RegSetValueExW(
        m_hRegKey,                          // IN HKEY hKey,
        pwszValueName,                      // IN LPCWSTR lpValueName,
        0,                                  // IN DWORD Reserved,
        REG_SZ,                             // IN DWORD dwType,
        (CONST BYTE*)pwszValue,             // IN CONST BYTE* lpData,
        (dwLength + 1) * sizeof(WCHAR)      // IN DWORD cbData
        );
    if ( lRes != ERROR_SUCCESS )
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), 
            L"RegSetValueExW(0x%08lx,%s,0,REG_SZ,%s.%d)", 
            m_hRegKey, m_awszKeyPath.GetRef(), pwszValue, (dwLength + 1) * sizeof(WCHAR));
}


// Reads a VSS_PWSZ value from the registry key
void CVssRegistryKey::GetValue( 
    IN  LPCWSTR     pwszValueName,
    OUT VSS_PWSZ &  pwszValue
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::GetValue_PWSZ" );

    // Assert parameters
    BS_ASSERT(pwszValueName);
    BS_ASSERT(pwszValue == NULL);

    // Reset the OUT parameter
    pwszValue = NULL;

    // Get the value length (we suppose that doesn't change)
    DWORD dwType = 0;
    DWORD dwSizeInBytes = 0;
    LONG lResult = ::RegQueryValueExW( 
        m_hRegKey,
        pwszValueName,
        NULL,
        &dwType,
        NULL,
        &dwSizeInBytes);
    if ((lResult != ERROR_SUCCESS) && (lResult != ERROR_MORE_DATA))
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lResult), 
            L"RegQueryValueExW(0x%08lx(%s),%s,0,[%lx],0,[%lu])", 
            m_hRegKey, m_awszKeyPath.GetRef(), pwszValueName, dwType, dwSizeInBytes);

    // Check the type and the size
    if (dwType != REG_SZ)
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Unexpected type %lu for a string value 0x%08lx(%s),%s",
            dwType, m_hRegKey, m_awszKeyPath.GetRef(), pwszValueName );
    BS_ASSERT(dwSizeInBytes);
    
    // Allocate the buffer
    CVssAutoPWSZ awszValue;
    DWORD dwSizeOfString = dwSizeInBytes/sizeof(WCHAR);
    awszValue.Allocate(dwSizeOfString);

    // Get the string contents
    DWORD dwType2 = 0;
    DWORD dwSizeInBytes2 = dwSizeOfString * (sizeof(WCHAR) + 1);
    BS_ASSERT( dwSizeInBytes2 >= dwSizeInBytes);
    lResult = ::RegQueryValueExW( 
        m_hRegKey,
        pwszValueName,
        NULL,
        &dwType2,
        (LPBYTE)awszValue.GetRef(),
        &dwSizeInBytes2);
    if (lResult != ERROR_SUCCESS)
        ft.TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(lResult), 
            L"RegQueryValueExW(0x%08lx(%s),%s,0,[%lx],0,[%lu])", 
            m_hRegKey, m_awszKeyPath.GetRef(), pwszValueName, dwType2, dwSizeInBytes2);
    BS_ASSERT(dwType2 == REG_SZ);
    BS_ASSERT(dwSizeInBytes2 == dwSizeInBytes);

    // Set the OUT parameter
    pwszValue = awszValue.Detach();
}


// Reads a LONGLONG value from the registry key
void CVssRegistryKey::GetValue( 
    IN  LPCWSTR     pwszValueName,
    OUT LONGLONG &  llValue
    ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::GetValue_LONGLONG" );

    // Assert parameters
    BS_ASSERT(pwszValueName);

    CVssAutoPWSZ awszValue;
    GetValue(pwszValueName, awszValue.GetRef());
    BS_ASSERT(awszValue.GetRef());
    BS_ASSERT(awszValue.GetRef()[0]);

    // Read the LONGLONG string
    llValue = ::_wtoi64(awszValue);
}


// Closes the registry key
void CVssRegistryKey::Close()
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKey::Close" );
    
    if (m_hRegKey) {
        // Close the opened key
        LONG lRes = ::RegCloseKey( m_hRegKey );
        if (lRes != ERROR_SUCCESS) {
            BS_ASSERT(false);
            ft.Trace( VSSDBG_GEN, L"%s: Error on closing key with name %s. lRes == 0x%08lx", (VSS_PWSZ)m_awszKeyPath, lRes );
        }
    }
    m_awszKeyPath.Clear();
}


// Standard constructor
CVssRegistryKey::CVssRegistryKey(
        IN  REGSAM samDesired /* = KEY_ALL_ACCESS */
        )
{
    m_hRegKey = NULL;
    m_samDesired = samDesired;
}


// Standard destructor
CVssRegistryKey::~CVssRegistryKey()
{
    Close();
}


/////////////////////////////////////////////////////////////////////////////
// CVssRegistryKey  implementation



// Standard constructor
CVssRegistryKeyIterator::CVssRegistryKeyIterator()
{
    // Initialize data members
    Detach();
}


// Returns the name of the current key.
// The returned key is always non-NULL (or the function will throw E_UNEXPECTED).
VSS_PWSZ CVssRegistryKeyIterator::GetCurrentKeyName() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKeyIterator::GetCurrentKeyName" );

    if (!m_bAttached || !m_awszSubKeyName.GetRef()) {
        BS_ASSERT(false);
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Unexpected error: noninitialized iterator");
    }

    // Fill wszSubKeyName with the name of the subkey
    FILETIME time;
    DWORD dwSize = m_dwMaxSubKeyLen;
    LONG lRes = ::RegEnumKeyExW(
        m_hParentKey,               // IN HKEY hKey,
        m_dwCurrentKeyIndex,        // IN DWORD dwIndex,
        m_awszSubKeyName,           // OUT LPWSTR lpName,
        &dwSize,                    // IN OUT LPDWORD lpcbName,
        NULL,                       // IN LPDWORD lpReserved,
        NULL,                       // IN OUT LPWSTR lpClass,
        NULL,                       // IN OUT LPDWORD lpcbClass,
        &time);                     // OUT PFILETIME lpftLastWriteTime
    switch(lRes)
    {
    case ERROR_SUCCESS:
        BS_ASSERT(dwSize != 0);
        break; // Go to Next key
    default:
        ft.TranslateGenericError( VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), L"RegEnumKeyExW(%p,%lu,%p,%lu ...)", 
             m_hParentKey, m_dwCurrentKeyIndex, m_awszSubKeyName.GetRef(), dwSize);
    case ERROR_NO_MORE_ITEMS:
        BS_ASSERT(false);
        ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"Unexpected error: dwIndex out of scope %lu %lu", m_dwCurrentKeyIndex, m_dwKeyCount);
    }
    
    return m_awszSubKeyName.GetRef();
}


// Standard constructor
void CVssRegistryKeyIterator::Attach(
        IN  CVssRegistryKey & key
        ) throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_GEN, L"CVssRegistryKeyIterator::Attach" );

    // Reset all members
    Detach();
    m_hParentKey = key.GetHandle();
    BS_ASSERT(m_hParentKey);

    // Get the number of subkeys and the max subkey length
    DWORD dwKeyCount = 0;
    DWORD dwMaxSubKeyLen = 0;
    LONG lRes = ::RegQueryInfoKeyW(
                    m_hParentKey,       // handle to key
                    NULL,               // class buffer
                    NULL,               // size of class buffer
                    NULL,               // reserved
                    &dwKeyCount,        // number of subkeys
                    &dwMaxSubKeyLen,    // longest subkey name
                    NULL,               // longest class string
                    NULL,               // number of value entries
                    NULL,               // longest value name
                    NULL,               // longest value data
                    NULL,               // descriptor length
                    NULL);              // last write time
    if (lRes != ERROR_SUCCESS)
        ft.TranslateGenericError( VSSDBG_GEN, HRESULT_FROM_WIN32(lRes), L"RegQueryInfoKeyW(%p, ...)", m_hParentKey);

    // Allocate the key name with a sufficient length.
    // We assume that the key length cannot change during the ennumeration).
    if (dwMaxSubKeyLen)
        m_awszSubKeyName.Allocate(dwMaxSubKeyLen);

    // Setting the number of subkeys
    m_dwKeyCount = dwKeyCount;
    m_dwMaxSubKeyLen = dwMaxSubKeyLen + 1;

    // Attachment completed
    m_bAttached = true;
}


void CVssRegistryKeyIterator::Detach()
{
    // Initialize data members
    m_hParentKey = NULL;
    m_dwKeyCount = 0;
    m_dwCurrentKeyIndex = 0;
    m_dwMaxSubKeyLen = 0;
    m_awszSubKeyName.Clear();
    m_bAttached = false;
}


// Tells if the current key is still valid 
bool CVssRegistryKeyIterator::IsEOF()
{
    return (m_dwCurrentKeyIndex >= m_dwKeyCount);
}


// Return the number of subkeys at the moment of attaching
DWORD CVssRegistryKeyIterator::GetSubkeysCount()
{
    return (m_dwKeyCount);
}


// Set the next key as being the current one in the enumeration
void CVssRegistryKeyIterator::MoveNext()
{
    if (!IsEOF())
        m_dwCurrentKeyIndex++;
    else
        BS_ASSERT(false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\delete.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Delete.cxx | Declarations used by the Software Snapshot Provider interface
    @end

Author:

    Adi Oltean  [aoltean]   02/01/2000

Revision History:

    Name        Date        Comments

    aoltean     02/01/2000  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

#include "vs_idl.hxx"


#include "resource.h"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"
 

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRDELEC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Implementation


STDMETHODIMP CVsSoftwareProvider::DeleteSnapshots(
    IN      VSS_ID          SourceObjectId,
	IN      VSS_OBJECT_TYPE eSourceObjectType,
	IN		BOOL			bForceDelete,			
	OUT		LONG*			plDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
    )

/*++

Description:

	This routine deletes all snapshots that match the proper filter criteria.
	If one snapshot fails to be deleted but other snapshots were deleted
	then pNondeletedSnapshotID must ve filled. Otherwise it must be GUID_NULL.

	At first error the deletion process stops.

	If snapshot set cannot be found then S_OK is returned.

Throws:

    E_ACCESSDENIED
        - The user is not an administrator (this should be the SYSTEM account).
    VSS_E_PROVIDER_VETO
        - An runtime error occured
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::DeleteSnapshots" );

    try
    {
    	// Zero out parameters
		::VssZeroOut(plDeletedSnapshots);
		::VssZeroOut(pNondeletedSnapshotID);

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
				L"  SourceObjectId = " WSTR_GUID_FMT L"\n"
				L"  eSourceObjectType = %d\n"
				L"  bForceDelete = %d"
				L"  plDeletedSnapshots = %p"
				L"  pNondeletedSnapshotID = %p",
				GUID_PRINTF_ARG( SourceObjectId ),
				eSourceObjectType,
				bForceDelete,			
				plDeletedSnapshots,		
				pNondeletedSnapshotID
             	);

		// Check arguments
		BS_ASSERT(plDeletedSnapshots);
		if (plDeletedSnapshots == NULL)
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"plDeletedSnapshots == NULL");
		BS_ASSERT(pNondeletedSnapshotID);
		if (pNondeletedSnapshotID == NULL)
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pNondeletedSnapshotID == NULL");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Freeze the context
        //
        FreezeContext();

		// Delete snapshots based on the given filter
        switch(eSourceObjectType) {
		case VSS_OBJECT_SNAPSHOT_SET:
		case VSS_OBJECT_SNAPSHOT:
    		ft.hr = InternalDeleteSnapshots(SourceObjectId,
    					eSourceObjectType,
    					GetContextInternal(),
    					plDeletedSnapshots,
    					pNondeletedSnapshotID);
			break;
			
		default:
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Incompatible type %d", eSourceObjectType);
		}
		
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// Internal methods


HRESULT CVsSoftwareProvider::InternalDeleteSnapshots(
    IN      VSS_ID			SourceObjectId,
	IN      VSS_OBJECT_TYPE eSourceObjectType,
	IN      LONG            lContext,
	OUT		LONG*			plDeletedSnapshots,		
	OUT		VSS_ID*			pNondeletedSnapshotID
    )

/*++

Description:

	This routine deletes all snapshots in the snapshot set.
	If one snapshot fails to be deleted but other snapshots were deleted
	then pNondeletedSnapshotID must ve filled. Otherwise it must be GUID_NULL.

	At first error the deletion process stops.

	If snapshot set cannot be found then VSS_E_OBJECT_NOT_FOUND is returned.

Throws:

    VSS_E_PROVIDER_VETO
        - An runtime error occured
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::InternalDeleteSnapshotSet" );
    
	BS_ASSERT(*plDeletedSnapshots == 0);
	BS_ASSERT(*pNondeletedSnapshotID == GUID_NULL);

	// Enumerate snapshots through all the volumes
	CVssIOCTLChannel volumeIChannel;	// For enumeration of snapshots on a volume
	CVssIOCTLChannel snapshotIChannel;	// For snapshots attributes
	WCHAR wszVolumeName[MAX_PATH+1];
	bool bFirstVolume = true;
	bool bObjectFound = false;

	// Search for snapshots in all mounted volumes
    CVssAutoSearchHandle hSearch;
	CVssAutoPWSZ awszSnapshotName;
	while(true) {
	
		// Get the volume name
		if (bFirstVolume) {
			hSearch.Set(::FindFirstVolumeW( wszVolumeName, MAX_PATH));
			if (hSearch == INVALID_HANDLE_VALUE)
				ft.TranslateInternalProviderError( VSSDBG_SWPRV,
				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
				    L"FindFirstVolumeW( [%s], MAX_PATH)", wszVolumeName);
			bFirstVolume = false;
		} else {
			if (!::FindNextVolumeW( hSearch, wszVolumeName, MAX_PATH) ) {
				if (GetLastError() == ERROR_NO_MORE_FILES)
					break;	// End of iteration
				else
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV,
    				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    				    L"FindNextVolumeW( %p, [%s], MAX_PATH)", hSearch, wszVolumeName);
			}
		}

        // Check if the volume is fixed (i.e. no CD-ROM, no removable)
        UINT uDriveType = ::GetDriveTypeW(wszVolumeName);
        if ( uDriveType != DRIVE_FIXED) {
            ft.Trace( VSSDBG_SWPRV, L"Warning: Ingnoring the non-fixed volume (%s) - %ud",
                      wszVolumeName, uDriveType);
            continue;
        }

		// Check if the snapshot(s) within this snapshot set is belonging to that volume
		// Open a IOCTL channel on that volume
		// Eliminate the last backslash in order to open the volume
		// The call will throw on error
		ft.hr = volumeIChannel.Open(ft, wszVolumeName, true, false, VSS_ICHANNEL_LOG_NONE);
		if (ft.HrFailed()) {
		    ft.hr = S_OK;
		    continue;
		}

		// Get the list of snapshots
		// If IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS not
		// supported then try with the next volume.

		ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, false);
		if (ft.HrFailed()) {
			ft.hr = S_OK;
			continue;
		}

		// Get the length of snapshot names multistring
		ULONG ulMultiszLen;
		volumeIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
		// Try to find the snapshot with the corresponding Id
		DWORD dwInitialOffset = volumeIChannel.GetCurrentOutputOffset();
#endif
        bool bFirstSnapshot = true;
		for (;volumeIChannel.UnpackZeroString(ft, awszSnapshotName.GetRef()); bFirstSnapshot = false) 
		{
			// Compose the snapshot name in a user-mode style
			WCHAR wszUserModeSnapshotName[MAX_PATH];
            ::VssConcatenate( ft, wszUserModeSnapshotName, MAX_PATH - 1,
                wszGlobalRootPrefix, awszSnapshotName );
				
			// Open that snapshot and verify if it has our ID
            // If we fail we do not throw since the snapshot may be deleted in the meantime
            // Do NOT eliminate the trailing backslash
            // The call will NOT throw on error
			ft.hr = snapshotIChannel.Open(ft, wszUserModeSnapshotName, false, false);
            if (ft.HrFailed()) {
                ft.Trace( VSSDBG_SWPRV, L"Warning: snapshot %s cannot be opened", wszUserModeSnapshotName);
                continue;
            }

			// Get the application buffer
            // If we fail we do not throw since the snapshot may be deleted in the meantime
			ft.hr = snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, false);
            if (ft.HrFailed()) {
                ft.Trace( VSSDBG_SWPRV, L"Warning: snapshot %s cannot be queried for properties",
                          wszUserModeSnapshotName);
                continue;
            }

            // Load the snapshot properties
            VSS_SNAPSHOT_PROP prop;
            LONG lStructureContext;
            bool bHidden;
            CVssQueuedSnapshot::LoadStructure(snapshotIChannel, &prop, &lStructureContext, &bHidden, false);

            // Filter, if needed
            switch(eSourceObjectType) {
    		case VSS_OBJECT_SNAPSHOT_SET:
				// Check if this snapshot belongs to the snapshot set.
				if (prop.m_SnapshotSetId != SourceObjectId) 
					continue;
				break;

    		case VSS_OBJECT_SNAPSHOT:
				if (prop.m_SnapshotId != SourceObjectId)
					continue;
    			break;
    			
    		default:
    			BS_ASSERT(false);
    			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Incompatible type %d", eSourceObjectType);
    		}

			// Filter more.
			if ((lContext != VSS_CTX_ALL) && 
			    (lContext != lStructureContext))
			    continue;

			// Check if the snapshot is already deleted
			if (bHidden)
			    continue;

			// We found a snapshot belonging to the set.
			bObjectFound = true;

			// Set in order to deal with failure cases
			(*pNondeletedSnapshotID) = prop.m_SnapshotId;
			
            // Delete the snapshot if this is the oldest. Otherwise, make it hidden
            if (bFirstSnapshot) 
        		DeleteSnapshotIoctl(wszVolumeName, awszSnapshotName.GetRef());
            else
            {
                snapshotIChannel.ResetOffsets();
                
                // Save the snapshot properties (with the "hidden" flag turned on)
            	CVssQueuedSnapshot::SaveStructure(snapshotIChannel, &prop, lStructureContext, true);

            	// Send the IOCTL
            	snapshotIChannel.Call(ft, IOCTL_VOLSNAP_SET_APPLICATION_INFO, true, VSS_ICHANNEL_LOG_PROV);
            }

			(*plDeletedSnapshots)++;

    		//  Delete all the subsequent hidden snapshots here
			PurgeSnapshotsOnVolume(wszVolumeName, false);
		}

#ifdef _DEBUG
		// Check if all strings were browsed correctly
		DWORD dwFinalOffset = volumeIChannel.GetCurrentOutputOffset();
		BS_ASSERT( dwFinalOffset - dwInitialOffset == ulMultiszLen);
#endif
	}

	if (!bObjectFound)
		ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"Object not found");

	if (ft.HrSucceeded())
		(*pNondeletedSnapshotID) = GUID_NULL;

    return ft.hr;
}


void CVsSoftwareProvider::PurgeSnapshots(
    IN  bool bPurgeAlsoAutoReleaseSnapshots
    )

/*++

Description:

	This routine deletes all snapshots in the snapshot set.
	If one snapshot fails to be deleted but other snapshots were deleted
	then pNondeletedSnapshotID must ve filled. Otherwise it must be GUID_NULL.

	At first error the deletion process stops.

	If snapshot set cannot be found then VSS_E_OBJECT_NOT_FOUND is returned.

Throws:

    VSS_E_PROVIDER_VETO
        - An runtime error occured
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::PurgeSnapshots" );
    

	// Enumerate snapshots through all the volumes
	WCHAR wszVolumeName[MAX_PATH+1];

	// Search for snapshots in all mounted volumes
    CVssAutoSearchHandle hSearch;
	bool bFirstVolume = true;
	while(true) {
	
		// Get the volume name
		if (bFirstVolume) {
			hSearch.Set(::FindFirstVolumeW( wszVolumeName, MAX_PATH));
			if (hSearch == INVALID_HANDLE_VALUE)
				ft.TranslateInternalProviderError( VSSDBG_SWPRV,
				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
				    L"FindFirstVolumeW( [%s], MAX_PATH)", wszVolumeName);
			bFirstVolume = false;
		} else {
			if (!::FindNextVolumeW( hSearch, wszVolumeName, MAX_PATH) ) {
				if (GetLastError() == ERROR_NO_MORE_FILES)
					break;	// End of iteration
				else
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV,
    				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    				    L"FindNextVolumeW( %p, [%s], MAX_PATH)", hSearch, wszVolumeName);
			}
		}

        // Check to see if the volume is snapshotted
        // If is does not have snapshots, ignore it.
        LONG lVolAttr = CVsSoftwareProvider::GetVolumeInformationFlags(wszVolumeName, VSS_CTX_ALL);
        if ((lVolAttr & CVsSoftwareProvider::VSS_VOLATTR_SNAPSHOTTED) == 0)
            continue;

        BS_ASSERT(lVolAttr & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT);

        // The volume has snapshots. Purge the hidden ones.
        PurgeSnapshotsOnVolume(wszVolumeName, bPurgeAlsoAutoReleaseSnapshots);
	}
}


void CVsSoftwareProvider::PurgeSnapshotsOnVolume(
    IN      VSS_PWSZ		wszVolumeName,
    IN      bool            bPurgeAlsoAutoReleaseSnapshots
    ) throw(HRESULT)

/*++

Description:

	This routine deletes, if possible, all hidden snapshots starting with the oldest one.

Throws:

    VSS_E_PROVIDER_VETO
        - An runtime error occured
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::PurgeSnapshotsOnVolume" );
    
	BS_ASSERT(wszVolumeName);

    ft.Trace( VSSDBG_SWPRV, L"Parameters: %s %s", wszVolumeName, bPurgeAlsoAutoReleaseSnapshots? L"TRUE": L"FALSE");

	// Enumerate snapshots through all the volumes
	CVssIOCTLChannel volumeIChannel;	// For enumeration of snapshots on a volume
	CVssIOCTLChannel snapshotIChannel;	// For snapshots attributes

    try
    {
    	// Open a IOCTL channel on that volume
    	// Eliminate the last backslash in order to open the volume
    	// The call will throw on error
    	volumeIChannel.Open(ft, wszVolumeName, true, true, VSS_ICHANNEL_LOG_PROV);

    	// Get the list of snapshots
    	volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, true, VSS_ICHANNEL_LOG_PROV);

    	// Get the length of snapshot names multistring
    	ULONG ulMultiszLen;
    	volumeIChannel.Unpack(ft, &ulMultiszLen);

        // Enumerate through all snapshots, starting with the oldest one.
        bool bTrueDeleteMode = true;
        // 1) If (bPurgeAlsoAutoReleaseSnapshots == false) We will try to delete 
        // each hidden snapshot starting with the olderst one
        // We will stop when we will encounter the first non-hidden snapshot
        // 2) Else (bPurgeAlsoAutoReleaseSnapshots == true) we are in OnLoad and we will try to delete 
        // each hidden snapshot and each auto-released snapshot (the bTrueDeleteMode = true phase). After encountering the first 
        // non-hidden and non-autoreleased snapshot (the bTrueDeleteMode = false phase) 
        // we cannot delete snapshots anymore but we will mark all autodelete snapshots as hidden.
    	CVssAutoPWSZ awszSnapshotName;
    	for (;volumeIChannel.UnpackZeroString(ft, awszSnapshotName.GetRef());) 
    	{
    		// Compose the snapshot name in a user-mode style
    		WCHAR wszUserModeSnapshotName[MAX_PATH];
            ::VssConcatenate( ft, wszUserModeSnapshotName, MAX_PATH - 1,
                wszGlobalRootPrefix, awszSnapshotName );
    			
    		// Open that snapshot and verify if it has our ID
            // If we fail we do not throw since the snapshot may be deleted in the meantime
            // Do NOT eliminate the trailing backslash
            // The call will NOT throw on error
    		ft.hr = snapshotIChannel.Open(ft, wszUserModeSnapshotName, false, true, VSS_ICHANNEL_LOG_PROV);
            if (ft.HrFailed()) {
                ft.Trace( VSSDBG_SWPRV, L"Warning: snapshot %s cannot be opened", wszUserModeSnapshotName);
                break; // the snapshot dissapeared in the meantime?
            }

    		// Get the application buffer
            // If we fail we do not throw since the snapshot may be deleted in the meantime
    		ft.hr = snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, false);
            if (ft.HrFailed()) {
                ft.Trace( VSSDBG_SWPRV, L"Warning: snapshot %s cannot be queried for properties",
                          wszUserModeSnapshotName);
                break; // the snapshot dissapeared in the meantime?
            }

            // Load the snapshot properties
            VSS_SNAPSHOT_PROP prop;
            LONG lContext;
            bool bHidden;
            CVssQueuedSnapshot::LoadStructure(snapshotIChannel, &prop, &lContext, &bHidden, false);

    		// If the snapshot is not hidden, stop here (unless we delete the auto release ones). 
    		if (!bHidden)
    		{
        		if (bPurgeAlsoAutoReleaseSnapshots)
                {   
                    // We encountered an auto-delete snapshot?
                    // If yes, delete it (or make it hidden). If not, continue.
                    if (lContext & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE)
                    {
                        bTrueDeleteMode = false;
                        continue;
                    }
                }
        		else
        		    break;
            }

            // Delete or hide the snapshot
            if (bTrueDeleteMode)
            {
                // Delete the snapshot
        		DeleteSnapshotIoctl(wszVolumeName, awszSnapshotName.GetRef());
            }
            else
            {
                // Resets the offsets
                snapshotIChannel.ResetOffsets();
                    
                // Save the snapshot properties (with the "hidden" flag turned on)
            	CVssQueuedSnapshot::SaveStructure(snapshotIChannel, &prop, lContext, true);

            	// Send the IOCTL
            	snapshotIChannel.Call(ft, IOCTL_VOLSNAP_SET_APPLICATION_INFO, true, VSS_ICHANNEL_LOG_PROV);
            }
    	}
    }
    VSS_STANDARD_CATCH(ft)
    if (ft.HrFailed())
        ft.Warning(VSSDBG_SWPRV, 
            L"Error 0x%08lx detected while purging snapshots on %s volume ", ft.hr, wszVolumeName);
}


void CVsSoftwareProvider::DeleteSnapshotIoctl(
    IN  LPWSTR wszVolumeName,
    IN  LPWSTR wszSnapshotName
    ) throw(HRESULT)

/*++

Description:

	This routine deletesthe given snapshot. This snapshot must be thoe oldest one in the V1 release

Throws:

    VSS_E_PROVIDER_VETO
        - An runtime error occured
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::DeleteSnapshotIoctl" );
    
	BS_ASSERT(wszVolumeName);
	BS_ASSERT(wszSnapshotName);

	CVssIOCTLChannel volumeIChannel;	// For snapshots deletion
	
	// We found a snapshot. 
	volumeIChannel.Open(ft, wszVolumeName, true, true, VSS_ICHANNEL_LOG_PROV);

    // Pack the snapshot name
    volumeIChannel.PackSmallString(ft, wszSnapshotName);

	// Delete the snapshot
	volumeIChannel.Call(ft, IOCTL_VOLSNAP_DELETE_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\diff.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Diff.cxx | Diff area object implementation
    @end

Author:

    Adi Oltean  [aoltean]   01/24/2000

Revision History:

    Name        Date        Comments

    aoltean     01/24/2000  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "diff.hxx"
#include "alloc.hxx"
#include "qsnap.hxx"
#include "diffmgmt.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRDIFFC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Operations


CVssDiffArea::CVssDiffArea()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssDiffArea::CVssDiffArea" );
}


CVssDiffArea::~CVssDiffArea()
{
	CVssFunctionTracer ft( VSSDBG_COORD, L"CVssDiffArea::~CVssDiffArea" );
}


void CVssDiffArea::Initialize(
    IN      LPCWSTR pwszVolumeMountPoint	// DO NOT transfer ownership
    ) throw(HRESULT)
/*++

Routine description:

    Initialize the internal structure for a new diff area.

Throws:

    VSS_E_PROVIDER_VETO
        - Error in GetVolumeNameForVolumeMountPointW
        - Error in opening the IOCTL channel
    E_UNEXPECTED
        - Dev error. Nothing to log.
    E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffArea::Initialize" );

	// Test the arguments
	if ((pwszVolumeMountPoint == NULL) ||
		(pwszVolumeMountPoint[0] == L'\0')) {
		BS_ASSERT(false);
		ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"NULL volume mount point");
	}

	// Convert the volume mount point into a volume name
	WCHAR wszVolumeName[MAX_PATH];
	if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeMountPoint,
			wszVolumeName, ARRAY_LEN(wszVolumeName)))
		ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
		    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
		    L"GetVolumeNameForVolumeMountPointW( %s, ...)", pwszVolumeMountPoint);
	BS_ASSERT(::wcslen(wszVolumeName) != 0);
		
	// Opening the channel
    // (if already opened then it will be closed automatically)
	// Eliminate the last backslash from the volume name.
	// The call will throw on error
	// Warning: Always do the logging 
	m_volumeIChannel.Open(ft, wszVolumeName, true, true, VSS_ICHANNEL_LOG_PROV);
}


void CVssDiffArea::AddVolume(                      			
    IN      VSS_PWSZ pwszVolumeMountPoint
    ) throw(HRESULT)
/*++

Routine description:

    Add a volume to the diff area.
    
Return codes:

    VSS_E_PROVIDER_VETO
        - Error in GetVolumeNameForVolumeMountPointW, ConvertVolMgmtVolumeNameIntoKernelObject
        - Error in sending the IOCTL
    E_UNEXPECTED
        - Dev error. Nothing to log.
    E_OUTOFMEMORY
        - Error in packing arguments

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffArea::AddVolume" );

	// Test arguments
    if (pwszVolumeMountPoint == NULL)
        ft.Throw( VSSDBG_COORD, E_INVALIDARG, L"NULL pwszVolumeName");

	// The critical section will be left automatically at the end of scope.
	CVssAutomaticLock2 lock(m_cs);

	BS_ASSERT(m_volumeIChannel.IsOpen());

	// Convert the volume mount point into a volume name
	WCHAR wszVolumeName[MAX_PATH];
	if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeMountPoint,
			wszVolumeName, ARRAY_LEN(wszVolumeName)))
		ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
		    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
		    L"GetVolumeNameForVolumeMountPointW( %s, ...)", pwszVolumeMountPoint);
	BS_ASSERT(::wcslen(wszVolumeName) != 0);

	if (!::ConvertVolMgmtVolumeNameIntoKernelObject(wszVolumeName))
		ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
		    E_UNEXPECTED, VSS_E_PROVIDER_VETO,
		    L"ConvertVolMgmtVolumeNameIntoKernelObject( %s, ...)", wszVolumeName);

	// Send the IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA ioctl
	// Logs the error, if any, as a provider error.
	m_volumeIChannel.PackSmallString(ft, wszVolumeName);
	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_ADD_VOLUME_TO_DIFF_AREA, true, VSS_ICHANNEL_LOG_PROV);
}


void CVssDiffArea::Clear() throw(HRESULT)
/*++

Routine description:

    Add a volume to the diff area.
    
Throws:

    E_UNEXPECTED
        - Error in sending the IOCTL (ignored anyway in the client)
    E_OUTOFMEMORY
        - Error in packing arguments

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffArea::Clear" );

	// The critical section will be left automatically at the end of scope.
	CVssAutomaticLock2 lock(m_cs);

	// Try to clear the diff area on the current volume
	// Do not log anything at this point!
	BS_ASSERT(m_volumeIChannel.IsOpen());
	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_CLEAR_DIFF_AREA);

	// Set the maximum size to zero
	m_volumeIChannel.ResetOffsets();
	ChangeDiffAreaMaximumSize(VSS_ASSOC_NO_MAX_SPACE);
}


void CVssDiffArea::IncrementCountOnPointedDiffAreas(									
    IN OUT  CVssDiffAreaAllocator* pObj
    ) throw(HRESULT)
    
/*++

Routine description:

    Query the diff area volumes for the current volume.
    and call CVssDiffAreaAllocator::OnDiffAreaVolume 
    for each volume in the diff area.
    
Return codes:

    E_OUTOFMEMORY
        - lock failures
    VSS_E_PROVIDER_VETO
        - Error in GetVolumeNameForVolumeMountPointW, GetVolumeGuid
    E_UNEXPECTED
        - Nothing to log. (wrong volume) The result is anyway ignored by the client.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffArea::IncrementCountOnPointedDiffAreas" );

	CVssAutoPWSZ awszVolumeName;
	
    // Initialize [out] arguments
    BS_ASSERT( pObj );

	// The critical section will be left automatically at the end of scope.
	CVssAutomaticLock2 lock(m_cs);

	// Get the list of volumes that are part of the diff area
	// Do not perform any logging.
	BS_ASSERT(m_volumeIChannel.IsOpen());
	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_DIFF_AREA);

	// Get the length of snapshot names multistring
	ULONG ulMultiszLen;
	m_volumeIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
	// Try to find the snapshot with the corresponding Id
	DWORD dwInitialOffset = m_volumeIChannel.GetCurrentOutputOffset();
#endif

	while(m_volumeIChannel.UnpackZeroString(ft, awszVolumeName.GetRef()))
	{
		// Compose the volume name in a user-mode style
		WCHAR wszMountPoint[MAX_PATH];
		if (::_snwprintf(wszMountPoint, MAX_PATH - 1,
				L"%s%s\\", wszGlobalRootPrefix, awszVolumeName.GetRef()) < 0)
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Not enough memory." );

		// Get the mount point for the volume name
		// If an error occurs then DO the logging.
    	WCHAR wszUserModeVolumeName[MAX_PATH];
		if (!::GetVolumeNameForVolumeMountPointW( wszMountPoint,
				wszUserModeVolumeName, MAX_PATH))
			ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
			    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
			    L"GetVolumeNameForVolumeMountPointW( %s, ...)", wszMountPoint);
		BS_ASSERT(::wcslen(wszUserModeVolumeName) != 0);

        // Invoke the callback
        pObj->IncrementExistingDiffAreaCountOnVolume(wszUserModeVolumeName);
	}

#ifdef _DEBUG
	// Check if all strings were browsed correctly
	DWORD dwFinalOffset = m_volumeIChannel.GetCurrentOutputOffset();
	BS_ASSERT( dwFinalOffset - dwInitialOffset == ulMultiszLen);
#endif
}


void CVssDiffArea::GetDiffArea(							
	OUT     CVssAutoPWSZ & awszDiffAreaName
	) throw(HRESULT)
/*++

Routine description:

    Sends the proper IOCTL in order to get the volume name for the diff area

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - Dev error. No logging.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::GetDiffArea" );

    // Send the QUERY_DIFF_AREA ioctl
    m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_DIFF_AREA, true, VSS_ICHANNEL_LOG_PROV);
    
	// Get the length of snapshot names multistring
	ULONG ulMultiszLen = 0;
	m_volumeIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
	// Try to find the snapshot with the corresponding Id
	DWORD dwInitialOffset = m_volumeIChannel.GetCurrentOutputOffset();
#endif

    CVssAutoPWSZ awszDiffAreaDevice;
    BS_VERIFY(m_volumeIChannel.UnpackZeroString(ft, awszDiffAreaDevice.GetRef()));

	// Compose the volume name in a user-mode style
	WCHAR wszMountPoint[MAX_PATH];
	if (::_snwprintf(wszMountPoint, MAX_PATH - 1, L"%s%s\\", wszGlobalRootPrefix, awszDiffAreaDevice.GetRef()) < 0)
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Not enough memory." );

	// Get the mount point for the volume name
	// If an error occurs then DO the logging.
	WCHAR wszCurrentDiffVolume[MAX_PATH];
	if (!::GetVolumeNameForVolumeMountPointW( wszMountPoint,
			wszCurrentDiffVolume, MAX_PATH))
		ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
		    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
		    L"GetVolumeNameForVolumeMountPointW( %s, ...)", wszMountPoint);
	BS_ASSERT(::wcslen(wszMountPoint) != 0);

    // Make sure we don't have any other diff areas
    BS_VERIFY(!m_volumeIChannel.UnpackZeroString(ft, awszDiffAreaName.GetRef()));
    
#ifdef _DEBUG
	// Check if all strings were unmarshalled correctly
	DWORD dwFinalOffset = m_volumeIChannel.GetCurrentOutputOffset();
	BS_ASSERT( dwFinalOffset - dwInitialOffset == ulMultiszLen);
#endif

    // Copy the diff area to the OUT parameter
    awszDiffAreaName.CopyFrom(wszCurrentDiffVolume);
}


void CVssDiffArea::GetDiffAreaSizes(							
	OUT     LONGLONG & llUsedSpace,
	OUT     LONGLONG & llAllocatedSpace,
	OUT     LONGLONG & llMaxSpace
	) throw(HRESULT)
/*++

Routine description:

    Sends the proper IOCTL in order to get the diff area sizes

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - Dev error. No logging.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::GetDiffAreaSizes" );

    // Send the QUERY_DIFF_AREA ioctl
    m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_DIFF_AREA_SIZES, true, VSS_ICHANNEL_LOG_PROV);
    m_volumeIChannel.Unpack(ft, &llUsedSpace);
    m_volumeIChannel.Unpack(ft, &llAllocatedSpace);
    m_volumeIChannel.Unpack(ft, &llMaxSpace);

    BS_ASSERT(llUsedSpace >= 0);
    BS_ASSERT(llAllocatedSpace >= 0);
    BS_ASSERT(llMaxSpace >= 0);

    // Deal with the "no max size" case
    if (llMaxSpace == VSS_BABBAGE_NO_MAX_SPACE)
        llMaxSpace = VSS_ASSOC_NO_MAX_SPACE;
}


void CVssDiffArea::ChangeDiffAreaMaximumSize(							
    IN      LONGLONG    llMaximumDiffSpace
	) throw(HRESULT)
/*++

Routine description:

    Sends the proper IOCTL in order to change the diff area max size on disk

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - Dev error. No logging.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::ChangeDiffAreaMaximumSize" );

    BS_ASSERT( ( llMaximumDiffSpace == VSS_ASSOC_NO_MAX_SPACE) || ( llMaximumDiffSpace > 0) );

    // The driver will make sure that -1 means no limit
    LONGLONG llInternalMaxDiffSpace = (llMaximumDiffSpace == VSS_ASSOC_NO_MAX_SPACE)? 
        VSS_BABBAGE_NO_MAX_SPACE: llMaximumDiffSpace;

    // Set the maximum space
    LONGLONG llUsedSpace = 0;       // Zero. Babbage will ignore it anyway.
    LONGLONG llAllocatedSpace = 0;  // Zero. Babbage will ignore it anyway.
    m_volumeIChannel.Pack(ft, llUsedSpace);
    m_volumeIChannel.Pack(ft, llAllocatedSpace);
    m_volumeIChannel.Pack(ft, llInternalMaxDiffSpace);
    m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_SET_MAX_DIFF_AREA_SIZE, true, VSS_ICHANNEL_LOG_PROV);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\diffmgmt.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module DiffMgmt.cxx | Implementation of IVssDifferentialSoftwareSnapshotMgmt
    @end

Author:

    Adi Oltean  [aoltean]  03/12/2001

Revision History:

    Name        Date        Comments
    aoltean     03/12/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"

#include "vs_idl.hxx"

#include "swprv.hxx"
#include "ichannel.hxx"
#include "ntddsnap.h"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "vs_sec.hxx"
#include "vs_reg.hxx"

#include "qsnap.hxx"
#include "provider.hxx"
#include "diffreg.hxx"
#include "diffmgmt.hxx"
#include "diff.hxx"



////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRDIFMC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffMgmt


/////////////////////////////////////////////////////////////////////////////
// Static members

CVssProviderRegInfo     CVssDiffMgmt::m_regInfo;


/////////////////////////////////////////////////////////////////////////////
// Methods


STDMETHODIMP CVssDiffMgmt::AddDiffArea(							
	IN  	VSS_PWSZ 	pwszVolumeName,
	IN  	VSS_PWSZ 	pwszDiffAreaVolumeName,
    IN      LONGLONG    llMaximumDiffSpace
	)												
/*++

Routine description:

    Adds a diff area association for a certain volume.
    If the association is not supported, an error code will be returned.

    Both volumes must be Fixed, NTFS and read-write.

Error codes:

    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument or volume not found
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_OBJECT_ALTEADY_EXISTS
        - The association already exists in registry
        - the volume is in use and the association cannot be added.
    VSS_E_VOLUME_NOT_SUPPORTED
        - One of the given volumes is not supported.
    E_UNEXPECTED
        - Unexpected runtime error. An error log entry is added.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::AddDiffArea" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszVolumeName = %s\n"
             L"  pwszDiffAreaVolumeName = %s\n"
             L"  llMaximumDiffSpace = %I64d\n",
             pwszVolumeName,
             pwszDiffAreaVolumeName,
             llMaximumDiffSpace);

        // Argument validation
        if (pwszVolumeName == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pwszVolumeName");
        if (pwszDiffAreaVolumeName == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pwszDiffAreaVolumeName");
        if ( (( llMaximumDiffSpace < 0) && ( llMaximumDiffSpace != VSS_ASSOC_NO_MAX_SPACE))
           || ( llMaximumDiffSpace == VSS_ASSOC_REMOVE) )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid llMaximumDiffSpace");

        if (( llMaximumDiffSpace != VSS_ASSOC_NO_MAX_SPACE) && 
            (llMaximumDiffSpace < (LONGLONG)nDefaultInitialSnapshotAllocation))
            ft.Throw( VSSDBG_SWPRV, VSS_E_INSUFFICIENT_STORAGE, L"Not enough storage for the initial diff area allocation");
            
        // Calculate the internal volume name
    	WCHAR wszVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];
    	if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeName,
    			wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
    		ft.Throw( VSSDBG_SWPRV, E_INVALIDARG,
    				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
    				  L"failed with error code 0x%08lx", pwszVolumeName, GetLastError());
    	BS_ASSERT(::wcslen(wszVolumeNameInternal) != 0);
    	BS_ASSERT(::IsVolMgmtVolumeName( wszVolumeNameInternal ));

        // Calculate the internal diff area volume name
    	WCHAR wszDiffAreaVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];
    	if (!::GetVolumeNameForVolumeMountPointW( pwszDiffAreaVolumeName,
    			wszDiffAreaVolumeNameInternal, ARRAY_LEN(wszDiffAreaVolumeNameInternal)))
    		ft.Throw( VSSDBG_SWPRV, E_INVALIDARG,
    				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
    				  L"failed with error code 0x%08lx", pwszDiffAreaVolumeName, GetLastError());
    	BS_ASSERT(::wcslen(wszDiffAreaVolumeNameInternal) != 0);
    	BS_ASSERT(::IsVolMgmtVolumeName( wszDiffAreaVolumeNameInternal ));

        // Checking if the proposed association is valid and the original volume is not in use
        LONG lAssociationFlags = GetAssociationFlags(wszVolumeNameInternal, wszDiffAreaVolumeNameInternal);
        ft.Trace(VSSDBG_SWPRV, L"An association is proposed: %s - %s with flags 0x%08lx",
            pwszVolumeName, wszDiffAreaVolumeNameInternal, lAssociationFlags);
        if (lAssociationFlags & VSS_DAT_INVALID)
    		ft.Throw( VSSDBG_SWPRV, VSS_E_VOLUME_NOT_SUPPORTED, L"Unsupported volume(s)");
        if (lAssociationFlags & VSS_DAT_ASSOCIATION_IN_USE)
    		ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_ALREADY_EXISTS, L"Association already exists");
        if (lAssociationFlags & VSS_DAT_SNAP_VOLUME_IN_USE)
    		ft.Throw( VSSDBG_SWPRV, VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS_REACHED, L"Original volume has snapshots on it");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Get the previous diff area association, if any.
        // If is invalid, remove it and continue with establishing a new association. If is valid, then stop here.
        CVssAutoPWSZ awszPreviousDiffAreaVolume;
        LONGLONG llPreviousMaxSpace = 0;
        if (m_regInfo.GetDiffAreaForVolume(wszVolumeNameInternal, awszPreviousDiffAreaVolume.GetRef(), llPreviousMaxSpace))
        {
            LONG lPreviousAssociationFlags = GetAssociationFlags(wszVolumeNameInternal, awszPreviousDiffAreaVolume);
            ft.Trace(VSSDBG_SWPRV, L"An association is present: %s - %s (%I64d) with flags 0x%08lx",
                wszVolumeNameInternal, awszPreviousDiffAreaVolume.GetRef(), llPreviousMaxSpace, lPreviousAssociationFlags);

            // If the previous association is NOT invalid, stop here.
            if ((lPreviousAssociationFlags & VSS_DAT_INVALID) == 0)
            {
                // Throw an error
                if (::wcscmp(awszPreviousDiffAreaVolume.GetRef(), wszDiffAreaVolumeNameInternal) == 0)
            		ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_ALREADY_EXISTS, L"Association already exists (and is valid)");
                else
            		ft.Throw( VSSDBG_SWPRV, VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS_REACHED, L"Another association defined");
            }

            // Delete the invalid association
            m_regInfo.RemoveDiffArea(wszVolumeNameInternal, awszPreviousDiffAreaVolume);
        }

        // Add the diff area association into the registry
        m_regInfo.AddDiffArea(wszVolumeNameInternal, wszDiffAreaVolumeNameInternal, llMaximumDiffSpace);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


 STDMETHODIMP CVssDiffMgmt::ChangeDiffAreaMaximumSize(							
	IN  	VSS_PWSZ 	pwszVolumeName,
	IN  	VSS_PWSZ 	pwszDiffAreaVolumeName,
    IN      LONGLONG    llMaximumDiffSpace
	)												
/*++

Routine description:

    Updates the diff area max size for a certain volume.
    This may not have an immediate effect

Error codes:

    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument or volume not found
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_OBJECT_NOT_FOUND
        - The association does not exists
    VSS_E_VOLUME_IN_USE
        - the volume is in use and the association cannot be deleted.
    E_UNEXPECTED
        - Unexpected runtime error. An error log entry is added.
    VSS_E_INSUFFICIENT_STORAGE
        - Insufficient storage for the diff area.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::ChangeDiffAreaMaximumSize" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszVolumeName = %s\n"
             L"  pwszDiffAreaVolumeName = %s\n"
             L"  llMaximumDiffSpace = %I64d\n",
             pwszVolumeName,
             pwszDiffAreaVolumeName,
             llMaximumDiffSpace);

        // Argument validation
        if (pwszVolumeName == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pwszVolumeName");
        if (pwszDiffAreaVolumeName == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pwszDiffAreaVolumeName");
        if ( ( llMaximumDiffSpace < 0) && ( llMaximumDiffSpace != VSS_ASSOC_NO_MAX_SPACE) )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid llMaximumDiffSpace");

        if (( llMaximumDiffSpace != VSS_ASSOC_NO_MAX_SPACE) && 
            ( llMaximumDiffSpace != VSS_ASSOC_REMOVE) && 
            (llMaximumDiffSpace < (LONGLONG)nDefaultInitialSnapshotAllocation))
            ft.Throw( VSSDBG_SWPRV, VSS_E_INSUFFICIENT_STORAGE, L"Not enough storage for the initial diff area allocation");
            
        // Calculate the internal volume name
    	WCHAR wszVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];
    	if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeName,
    			wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
    		ft.Throw( VSSDBG_SWPRV, E_INVALIDARG,
    				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
    				  L"failed with error code 0x%08lx", pwszVolumeName, GetLastError());
    	BS_ASSERT(::wcslen(wszVolumeNameInternal) != 0);
    	BS_ASSERT(::IsVolMgmtVolumeName( wszVolumeNameInternal ));

        // Calculate the internal diff area volume name
    	WCHAR wszDiffAreaVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];
    	if (!::GetVolumeNameForVolumeMountPointW( pwszDiffAreaVolumeName,
    			wszDiffAreaVolumeNameInternal, ARRAY_LEN(wszDiffAreaVolumeNameInternal)))
    		ft.Throw( VSSDBG_SWPRV, E_INVALIDARG,
    				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
    				  L"failed with error code 0x%08lx", pwszDiffAreaVolumeName, GetLastError());
    	BS_ASSERT(::wcslen(wszDiffAreaVolumeNameInternal) != 0);
    	BS_ASSERT(::IsVolMgmtVolumeName( wszDiffAreaVolumeNameInternal ));

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Checking if the association is valid.
        LONG lAssociationFlags = GetAssociationFlags(wszVolumeNameInternal, wszDiffAreaVolumeNameInternal);
        ft.Trace(VSSDBG_SWPRV, L"An association is changing: %s - %s with flags 0x%08lx",
            wszVolumeNameInternal, wszDiffAreaVolumeNameInternal, lAssociationFlags);
        if (lAssociationFlags & VSS_DAT_INVALID)
    		ft.Throw( VSSDBG_SWPRV, VSS_E_VOLUME_NOT_SUPPORTED, L"Unsupported volume(s)");

        // Check if the association is present in registry
        bool bPresentInRegistry = m_regInfo.IsAssociationPresentInRegistry(wszVolumeNameInternal, wszDiffAreaVolumeNameInternal);

        // If the association is in use
        if (lAssociationFlags & VSS_DAT_ASSOCIATION_IN_USE)
        {
            // If we need to remove the association and it is in use, return an error
            // Otherwise, change the max diff space on disk
            if (llMaximumDiffSpace == VSS_ASSOC_REMOVE)
        		ft.Throw( VSSDBG_SWPRV, VSS_E_VOLUME_IN_USE, L"The original volume is in use");
            else
            {
                CVssDiffArea diffobj;
                diffobj.Initialize(wszVolumeNameInternal);
                diffobj.ChangeDiffAreaMaximumSize(llMaximumDiffSpace);
            }
        }
        else
        {
            BS_ASSERT( (lAssociationFlags & VSS_DAT_SNAP_VOLUME_IN_USE) == 0);
            if (!bPresentInRegistry)
        		ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"Association not found");
        }


        // If the association is present on the registry
        if (bPresentInRegistry)
        {
            // If llMaximumDiffSpace is zero, then remove the diff area association from registry
            // Else change the diff area size in registry
            if (llMaximumDiffSpace == VSS_ASSOC_REMOVE)
                m_regInfo.RemoveDiffArea(wszVolumeNameInternal, wszDiffAreaVolumeNameInternal);
            else
                m_regInfo.ChangeDiffAreaMaximumSize(wszVolumeNameInternal, wszDiffAreaVolumeNameInternal, llMaximumDiffSpace);
        }

    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


//
//  Queries
//

STDMETHODIMP CVssDiffMgmt::QueryVolumesSupportedForDiffAreas(
	OUT  	IVssEnumMgmtObject **ppEnum
	)												
/*++

Routine description:

    Query volumes that support diff areas (including the disabled ones)

Error codes:

    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::QueryVolumesSupportedForDiffAreas" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  ppEnum = %p\n",
             ppEnum);

        // Argument validation
		BS_ASSERT(ppEnum)
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppEnum");
		
        // Create the collection object. Initial reference count is 0.
        VSS_MGMT_OBJECT_PROP_Array* pArray = new VSS_MGMT_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

		WCHAR wszVolumeName[MAX_PATH+1];
		bool bFirstVolume = true;
    	CVssAutoSearchHandle hSearch;
		while(true) {

            //
			// Get the volume name
			//
			
			if (bFirstVolume) {
				hSearch.Set(::FindFirstVolumeW( wszVolumeName, MAX_PATH));
				if (hSearch == INVALID_HANDLE_VALUE)
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV,
    				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    				    L"FindFirstVolumeW( [%s], MAX_PATH)", wszVolumeName);
				bFirstVolume = false;
			} else {
				if (!::FindNextVolumeW( hSearch, wszVolumeName, MAX_PATH) ) {
					if (GetLastError() == ERROR_NO_MORE_FILES)
						break;	// End of iteration
					else
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV,
        				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
        				    L"FindNextVolumeW( %p, [%s], MAX_PATH)", hSearch, wszVolumeName);
				}
			}

            //
            //  Verify if the volume is supported for diff area
            //

            // Checking if the volume is Fixed, NTFS and read-write.
            LONG lVolumeFlags = CVsSoftwareProvider::GetVolumeInformationFlags( wszVolumeName, VSS_CTX_CLIENT_ACCESSIBLE );
            if ( (lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_DIFF_AREA) == 0)
                continue;

            //
            //  Calculate the volume display name
            //

            WCHAR wszVolumeDisplayName[MAX_PATH];
            VssGetVolumeDisplayName( wszVolumeName, wszVolumeDisplayName, MAX_PATH);

            //
            //  Calculate the free space
            //
            ULARGE_INTEGER ulnFreeBytesAvailable;
            ULARGE_INTEGER ulnTotalNumberOfBytes;
            ULARGE_INTEGER ulnTotalNumberOfFreeBytes;
            if (!::GetDiskFreeSpaceEx(wszVolumeName,
                    &ulnFreeBytesAvailable,
                    &ulnTotalNumberOfBytes,
                    &ulnTotalNumberOfFreeBytes
                    )){
                ft.Trace( VSSDBG_SWPRV, L"Cannot get the free space for volume (%s) - [0x%08lx]",
                          wszVolumeName, GetLastError());
                continue;
            }

            // We should not have any quotas for the Local SYSTEM account
            BS_ASSERT( ulnFreeBytesAvailable.QuadPart == ulnTotalNumberOfFreeBytes.QuadPart );

            // 
            //  Add the supported volume to the list
            //

			// Initialize an empty snapshot properties structure
			VSS_MGMT_OBJECT_PROP_Ptr ptrVolumeProp;
			ptrVolumeProp.InitializeAsDiffVolume( ft,
				wszVolumeName,
				wszVolumeDisplayName,
				ulnFreeBytesAvailable.QuadPart,
				ulnTotalNumberOfBytes.QuadPart
				);

			if (!pArray->Add(ptrVolumeProp))
				ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
						  L"Cannot add element to the array");

			// Reset the current pointer to NULL
			ptrVolumeProp.Reset(); // The internal pointer was detached into pArray.

		}

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssMgmtEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssMgmtEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
		// Now pEnumObject's reference count becomes 1 (because of the smart pointer).
		// So if a throw occurs the enumerator object will be safely destroyed by the smart ptr.
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object.
		// The array's reference count becomes now 2, because IEnumOnSTLImpl::m_spUnk is also a smart ptr.
        BS_ASSERT(pArray);
		ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed()) {
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Cannot initialize enumerator instance. [0x%08lx]", ft.hr);
        }

        // Initialize the enumerator object.
		// The enumerator reference count becomes now 2.
        ft.hr = pUnknown->SafeQI(IVssEnumMgmtObject, ppEnum);
        if ( ft.HrFailed() ) {
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Error querying the IVssEnumObject interface. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(*ppEnum);

		BS_ASSERT( !ft.HrFailed() );
		ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVssDiffMgmt::QueryDiffAreasForVolume(
	IN  	VSS_PWSZ 	pwszVolumeName,
	OUT  	IVssEnumMgmtObject **ppEnum
	)												
/*++

Routine description:

    Query diff areas that host snapshots for the given (snapshotted) volume

Error codes:

    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::QueryDiffAreasForVolume" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszVolumeName = %s\n"
             L"  ppEnum = %p\n",
             pwszVolumeName? pwszVolumeName: L"NULL",
             ppEnum);

        // Argument validation
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppEnum");
        if (pwszVolumeName == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pwszVolumeName");

        // Calculate the internal volume name
    	WCHAR wszVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];
	    if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeName,
    			wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
    		ft.Throw( VSSDBG_SWPRV, E_INVALIDARG,
				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
				  L"failed with error code 0x%08lx", pwszVolumeName, GetLastError());
    	BS_ASSERT(::wcslen(wszVolumeNameInternal) != 0);
    	BS_ASSERT(::IsVolMgmtVolumeName( wszVolumeNameInternal ));

        // Create the collection object. Initial reference count is 0.
        VSS_MGMT_OBJECT_PROP_Array* pArray = new VSS_MGMT_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        LONG lVolumeFlags = CVsSoftwareProvider::GetVolumeInformationFlags( wszVolumeNameInternal, VSS_CTX_ALL);
        if ((lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT) == 0)
    		ft.Throw( VSSDBG_SWPRV, E_INVALIDARG,
				  L"Volume not supported for snapshots", pwszVolumeName, GetLastError());

        // If the volume is in use, get the corresponding association
        // Otherwise, If the association is only in registry, get it
        if (lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SNAPSHOTTED)
        {
            // Get the diff area for the "in use" volume
            CVssAutoPWSZ awszDiffAreaVolumeInUse;
            CVssDiffArea diffobj;
            diffobj.Initialize(wszVolumeNameInternal);
            diffobj.GetDiffArea( awszDiffAreaVolumeInUse);

            // Get the diff area sizes
            LONGLONG llUsedSpace = 0;
            LONGLONG llAllocatedSpace = 0;
            LONGLONG llMaxSpace = 0;
            diffobj.GetDiffAreaSizes(llUsedSpace, llAllocatedSpace, llMaxSpace);

            // Verify that the registry information is correct
            LONGLONG llMaxSpaceInRegistry = 0;
            CVssAutoPWSZ awszDiffAreaVolumeInRegistry;
            if (m_regInfo.GetDiffAreaForVolume(wszVolumeNameInternal, awszDiffAreaVolumeInRegistry.GetRef(), llMaxSpaceInRegistry))
            {
                BS_ASSERT(::wcscmp(awszDiffAreaVolumeInUse, awszDiffAreaVolumeInRegistry) == 0);
                BS_ASSERT(llMaxSpace == llMaxSpaceInRegistry);
            }

            // Initialize an new structure for the association
      		VSS_MGMT_OBJECT_PROP_Ptr ptrDiffAreaProp;
    		ptrDiffAreaProp.InitializeAsDiffArea( ft,
    			wszVolumeNameInternal,
    			awszDiffAreaVolumeInUse,
    			llUsedSpace,
    			llAllocatedSpace,
    			llMaxSpace);

            //  Add the association to the list
    		if (!pArray->Add(ptrDiffAreaProp))
    			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Cannot add element to the array");

    		// Reset the current pointer to NULL
    		ptrDiffAreaProp.Reset(); // The internal pointer was detached into pArray.
        }
        else
        {
            LONGLONG llMaxSpaceInRegistry = 0;
            CVssAutoPWSZ awszDiffAreaVolumeInRegistry;
            if (m_regInfo.GetDiffAreaForVolume(wszVolumeNameInternal, awszDiffAreaVolumeInRegistry.GetRef(), llMaxSpaceInRegistry))
            {
                // Initialize a new structure for the association
          		VSS_MGMT_OBJECT_PROP_Ptr ptrDiffAreaProp;
        		ptrDiffAreaProp.InitializeAsDiffArea( ft,
        			wszVolumeNameInternal,
        			awszDiffAreaVolumeInRegistry,
        			0,
        			0,
        			llMaxSpaceInRegistry);

                //  Add the association to the list
        		if (!pArray->Add(ptrDiffAreaProp))
        			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Cannot add element to the array");

        		// Reset the current pointer to NULL
        		ptrDiffAreaProp.Reset(); // The internal pointer was detached into pArray.
            }
        }

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssMgmtEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssMgmtEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
		// Now pEnumObject's reference count becomes 1 (because of the smart pointer).
		// So if a throw occurs the enumerator object will be safely destroyed by the smart ptr.
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object.
		// The array's reference count becomes now 2, because IEnumOnSTLImpl::m_spUnk is also a smart ptr.
        BS_ASSERT(pArray);
		ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed()) {
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Cannot initialize enumerator instance. [0x%08lx]", ft.hr);
        }

        // Initialize the enumerator object.
		// The enumerator reference count becomes now 2.
        ft.hr = pUnknown->SafeQI(IVssEnumMgmtObject, ppEnum);
        if ( ft.HrFailed() ) {
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Error querying the IVssEnumObject interface. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(*ppEnum);

		BS_ASSERT( !ft.HrFailed() );
		ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVssDiffMgmt::QueryDiffAreasOnVolume(
	IN  	VSS_PWSZ 	pwszDiffAreaVolumeName,
	OUT  	IVssEnumMgmtObject **ppEnum
	)												
/*++

Routine description:

    Query diff areas that host snapshots on the given (snapshotted) volume

Error codes:

    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::QueryDiffAreasOnVolume" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszDiffAreaVolumeName = %s\n"
             L"  ppEnum = %p\n",
             pwszDiffAreaVolumeName? pwszDiffAreaVolumeName: L"NULL",
             ppEnum);

        // Argument validation
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppEnum");
        bool bFilterByDiffAreaVolumeName = (pwszDiffAreaVolumeName != NULL);

        // Calculate the internal diff area volume name
    	WCHAR wszDiffAreaVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];
   	    wszDiffAreaVolumeNameInternal[0] = L'\0';
    	if (bFilterByDiffAreaVolumeName)
    	{
        	if (!::GetVolumeNameForVolumeMountPointW( pwszDiffAreaVolumeName,
        			wszDiffAreaVolumeNameInternal, ARRAY_LEN(wszDiffAreaVolumeNameInternal)))
        	    ft.Throw( VSSDBG_SWPRV, E_INVALIDARG,
    				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
    				  L"failed with error code 0x%08lx", pwszDiffAreaVolumeName, GetLastError());
        	BS_ASSERT(::wcslen(wszDiffAreaVolumeNameInternal) != 0);
        	BS_ASSERT(::IsVolMgmtVolumeName( wszDiffAreaVolumeNameInternal ));
    	}

        // Checking if the volume is Fixed, NTFS and read-write.
        LONG lVolumeFlags = CVsSoftwareProvider::GetVolumeInformationFlags( wszDiffAreaVolumeNameInternal, VSS_CTX_ALL );
        if ( (lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_DIFF_AREA) == 0)
    	    ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Volume not supported for diff area" );

        // Create the collection object. Initial reference count is 0.
        VSS_MGMT_OBJECT_PROP_Array* pArray = new VSS_MGMT_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Enumerate through all volumes that may be snapshotted
        //

		WCHAR wszVolumeName[MAX_PATH+1];
		bool bFirstVolume = true;
    	CVssAutoSearchHandle hSearch;
		while(true) {

            //
			// Get the volume name
			//
			
			if (bFirstVolume) {
				hSearch.Set(::FindFirstVolumeW( wszVolumeName, MAX_PATH));
				if (hSearch == INVALID_HANDLE_VALUE)
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV,
    				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    				    L"FindFirstVolumeW( [%s], MAX_PATH)", wszVolumeName);
				bFirstVolume = false;
			} else {
				if (!::FindNextVolumeW( hSearch, wszVolumeName, MAX_PATH) ) {
					if (GetLastError() == ERROR_NO_MORE_FILES)
						break;	// End of iteration
					else
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV,
        				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
        				    L"FindNextVolumeW( %p, [%s], MAX_PATH)", hSearch, wszVolumeName);
				}
			}

            //
            //  Verify if the volume is supported for diff area
            //

            // Checking if the volume is Fixed, NTFS and read-write.
            LONG lVolumeFlags = CVsSoftwareProvider::GetVolumeInformationFlags( wszVolumeName, VSS_CTX_ALL );
            if ( (lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT) == 0)
            {
                ft.Trace(VSSDBG_SWPRV, L"Volume %s is not supported for snapshot", wszVolumeName);
                continue;
            }

            // If the volume is in use, get the corresponding association
            // Otherwise, If the association is only in registry, get it
            if (lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SNAPSHOTTED)
            {
                // Get the diff area for the "in use" volume
                CVssAutoPWSZ awszDiffAreaVolumeInUse;
                CVssDiffArea diffobj;
                diffobj.Initialize(wszVolumeName);
                diffobj.GetDiffArea(awszDiffAreaVolumeInUse);

                // If this is not our diff area, then go to the next volume
                if (::wcscmp(wszDiffAreaVolumeNameInternal, awszDiffAreaVolumeInUse))
                {
                    ft.Trace(VSSDBG_SWPRV, L"In Use association %s - %s is ignored",
                        wszDiffAreaVolumeNameInternal, awszDiffAreaVolumeInUse);
                    continue;
                }

                // Get the diff area sizes from disk
                LONGLONG llUsedSpace = 0;
                LONGLONG llAllocatedSpace = 0;
                LONGLONG llMaxSpace = 0;
                diffobj.GetDiffAreaSizes(llUsedSpace, llAllocatedSpace, llMaxSpace);

                // Verify that the registry information is correct
                LONGLONG llMaxSpaceInRegistry = 0;
                CVssAutoPWSZ awszDiffAreaVolumeInRegistry;
                if (m_regInfo.GetDiffAreaForVolume(wszVolumeName, awszDiffAreaVolumeInRegistry.GetRef(), llMaxSpaceInRegistry))
                {
                    BS_ASSERT(::wcscmp(awszDiffAreaVolumeInUse, awszDiffAreaVolumeInUse));
                    BS_ASSERT(llMaxSpace == llMaxSpaceInRegistry);
                }

                // Initialize an new structure for the association
          		VSS_MGMT_OBJECT_PROP_Ptr ptrDiffAreaProp;
        		ptrDiffAreaProp.InitializeAsDiffArea( ft,
        			wszVolumeName,
        			awszDiffAreaVolumeInUse,
        			llUsedSpace,
        			llAllocatedSpace,
        			llMaxSpace);

                //  Add the association to the list
        		if (!pArray->Add(ptrDiffAreaProp))
        			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Cannot add element to the array");

        		// Reset the current pointer to NULL
        		ptrDiffAreaProp.Reset(); // The internal pointer was detached into pArray.
            }
            else
            {
                LONGLONG llMaxSpaceInRegistry = 0;
                CVssAutoPWSZ awszDiffAreaVolumeInRegistry;
                if (m_regInfo.GetDiffAreaForVolume(wszVolumeName, awszDiffAreaVolumeInRegistry.GetRef(), llMaxSpaceInRegistry))
                {
                    // If this is not our diff area, then go to the next volume
                    if (::wcscmp(wszDiffAreaVolumeNameInternal, awszDiffAreaVolumeInRegistry)) {
                        ft.Trace(VSSDBG_SWPRV, L"Registered association %s - %s is ignored",
                            wszDiffAreaVolumeNameInternal, awszDiffAreaVolumeInRegistry);
                        continue;
                    }

                    // Initialize a new structure for the association
              		VSS_MGMT_OBJECT_PROP_Ptr ptrDiffAreaProp;
            		ptrDiffAreaProp.InitializeAsDiffArea( ft,
            			wszVolumeName,
            			awszDiffAreaVolumeInRegistry,
            			0,
            			0,
            			llMaxSpaceInRegistry);

                    //  Add the association to the list
            		if (!pArray->Add(ptrDiffAreaProp))
            			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Cannot add element to the array");

            		// Reset the current pointer to NULL
            		ptrDiffAreaProp.Reset(); // The internal pointer was detached into pArray.
                }
            }
        }

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssMgmtEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssMgmtEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
		// Now pEnumObject's reference count becomes 1 (because of the smart pointer).
		// So if a throw occurs the enumerator object will be safely destroyed by the smart ptr.
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object.
		// The array's reference count becomes now 2, because IEnumOnSTLImpl::m_spUnk is also a smart ptr.
        BS_ASSERT(pArray);
		ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed()) {
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Cannot initialize enumerator instance. [0x%08lx]", ft.hr);
        }

        // Initialize the enumerator object.
		// The enumerator reference count becomes now 2.
        ft.hr = pUnknown->SafeQI(IVssEnumMgmtObject, ppEnum);
        if ( ft.HrFailed() ) {
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Error querying the IVssEnumObject interface. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(*ppEnum);

		BS_ASSERT( !ft.HrFailed() );
		ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// Life management


HRESULT CVssDiffMgmt::CreateInstance(
    OUT		IUnknown** ppItf,
    IN 		const IID iid /* = IID_IVssDifferentialSoftwareSnapshotMgmt */
    )
/*++

Routine description:

    Creates an instance of the CVssDiffMgmt to be returned as IVssDifferentialSoftwareSnapshotMgmt

Throws:

    E_OUTOFMEMORY
    E_UNEXPECTED
        - Dev error. No logging.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::CreateInstance" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr(ppItf);
        BS_ASSERT(ppItf);

        // Allocate the COM object.
        CComObject<CVssDiffMgmt>* pObject;
        ft.hr = CComObject<CVssDiffMgmt>::CreateInstance(&pObject);
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Error creating the CVssDiffMgmt instance. hr = 0x%08lx", ft.hr);
        BS_ASSERT(pObject);

        // Querying the IVssSnapshot interface
        CComPtr<IUnknown> pUnknown = pObject->GetUnknown();
        BS_ASSERT(pUnknown);
        ft.hr = pUnknown->QueryInterface(iid, reinterpret_cast<void**>(ppItf) );
        if ( ft.HrFailed() ) {
            BS_ASSERT(false); // Dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Error querying the interface. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(*ppItf);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
// Internal methods


LONG CVssDiffMgmt::GetAssociationFlags(
		IN  	VSS_PWSZ 	pwszVolumeName,
		IN  	VSS_PWSZ 	pwszDiffAreaVolumeName
        ) throw(HRESULT)
/*++

Routine description:

    Get the association flags for the given volumes.

Throw error codes:

    E_OUTOFMEMORY
        - lock failures.
    E_UNEXPECTED
        - Unexpected runtime error.

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssDiffMgmt::GetAssociationFlags" );

    LONG lAssociationFlags = 0;

    // Checking if the volume is good for snapshots and if it has snapshots.
    LONG lVolumeFlags = CVsSoftwareProvider::GetVolumeInformationFlags( pwszVolumeName, VSS_CTX_ALL);
    if ((lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT) == 0)
        lAssociationFlags |= VSS_DAT_INVALID;
    else if (lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SNAPSHOTTED)
        lAssociationFlags |= VSS_DAT_SNAP_VOLUME_IN_USE;

    // Checking if the diff volume is good for keeping a diff area.
    LONG lDiffVolumeFlags = CVsSoftwareProvider::GetVolumeInformationFlags( pwszDiffAreaVolumeName, VSS_CTX_ALL);
    if ((lDiffVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SUPPORTED_FOR_DIFF_AREA) == 0)
        lAssociationFlags |= VSS_DAT_INVALID;

    //
    // Check if the current association is in use
    //

    if (lVolumeFlags & CVsSoftwareProvider::VSS_VOLATTR_SNAPSHOTTED)
    {
        // Get the diff area from the original volume.
        CVssAutoPWSZ awszCurrentDiffArea;
        CVssDiffArea diffobj;
        diffobj.Initialize(pwszVolumeName);
        diffobj.GetDiffArea(awszCurrentDiffArea);

        // If the used diff area volume is the same as the one passed as parameter
        if (::wcscmp(awszCurrentDiffArea, pwszDiffAreaVolumeName) == 0)
            lAssociationFlags |= VSS_DAT_ASSOCIATION_IN_USE;
    }

    return lAssociationFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\persist.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Persist.hxx | Defines the internal snapshot persistency-related methods.
    @end

Author:

    Adi Oltean  [aoltean]   01/10/2000

Revision History:

    Name        Date        Comments

    aoltean     01/10/2000  Created.


Storage Format for all structures:

	The snapshot structures for the MS Software Snapshot Provider
	have the following format:

	+-----------------+
	|  AppInfo GUID   |   GUID: VOLSNAP_APPINFO_GUID_BACKUP_SERVER_SKU,
	|                 |         VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE or
	|                 |         VOLSNAP_APPINFO_GUID_HIDDEN
	|                 |
	+-----------------+
	|   Snapshot ID   |   GUID: Snapshot ID
	|                 |
	|                 |
	|                 |
	+-----------------+
	| Snapshot Set ID |   GUID: Snapshot Set ID
	|                 |
	|                 |
	|                 |
	+-----------------+
	|  Snapshot ctx   |   LONG: Snapshot context: VSS_CTX_BACKUP or VSS_CTX_CLIENT_ACCESSIBLE
	+-----------------+
	| Snapshots count |   LONG: Snapshots count in the snapshot set.
	+-----------------+


Storage place:

	typedef struct _VSS_SNAPSHOT_PROP {
		VSS_ID			m_SnapshotId;						//	SaveSnapshotPropertiesIoctl	IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO	We need a special IOCTL in the future
		VSS_ID			m_SnapshotSetId;					//	SaveSnapshotPropertiesIoctl	IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO	Mentioned above
		LONG			m_lSnapshotsCount;					//	SaveSnapshotPropertiesIoctl	IOCTL_VOLSNAP_SET_APPLICATION_INFO		IOCTL_VOLSNAP_QUERY_APPLICATION_INFO
		VSS_PWSZ		m_pwszSnapshotDeviceObject; 		//	None						IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS	None
		VSS_PWSZ		m_pwszOriginalVolumeName;			//	LoadOriginalVolumeNameIoctl	IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME None									
		VSS_ID			m_ProviderId;						//	None																None 									Always the Software Provider ID
		LONG            m_lSnapshotAttributes;              //  None                                                                                                        Always zero
		VSS_TIMESTAMP	m_tsCreationTimestamp;				//	LoadTimestampIoctl		    None (driver)		                    IOCTL_VOLSNAP_QUERY_CONFIG_INFO
		VSS_SNAPSHOT_STATE	m_eStatus;						//	None.                                                                                                       Always VSS_SS_CREATED after creation
	} VSS_SNAPSHOT_PROP, *PVSS_SNAPSHOT_PROP;				

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRPERSC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot::SaveXXX methods
//


void CVssQueuedSnapshot::SaveStructure(
    IN  CVssIOCTLChannel& channel,
	IN	PVSS_SNAPSHOT_PROP pProp,
  	IN  LONG lContext, 
  	IN  bool bHidden
    ) throw(HRESULT)

/*++

Description:

	This function will save the properties related to the snapshot in the given IOCTL channel

Throws:

    VSS_E_PROVIDER_VETO
        - on error.

    E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::SaveStructure");

	BS_ASSERT(lContext != VSS_CTX_ALL);
    BS_ASSERT(pProp);
    BS_ASSERT(channel.IsOpen());

	// Pack the length of the entire buffer
	PVOID pulBufferLength = channel.Pack(ft, (ULONG)0 ); // unknown right now
	
	// Start counting entire buffer length
	DWORD dwInitialOffset = channel.GetCurrentInputOffset();
	
	// Pack the AppInfo ID
	VSS_ID AppinfoId;
	if (bHidden)
	    AppinfoId = VOLSNAP_APPINFO_GUID_HIDDEN;
    else 
        switch(lContext)
    	{
        case VSS_CTX_BACKUP:
    	    AppinfoId = VOLSNAP_APPINFO_GUID_BACKUP_SERVER_SKU;
    	    break;
        case VSS_CTX_CLIENT_ACCESSIBLE:
    	    AppinfoId = VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE;
    	    break;
    	default: 
    	    BS_ASSERT(false); // programming error?
    	    ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Invalid conext 0x%08lx", lContext );
    	}
	channel.Pack(ft, AppinfoId);
	
	// Pack the Snapshot ID
	channel.Pack(ft, pProp->m_SnapshotId);
	
	// Pack the Snapshot Set ID
	channel.Pack(ft, pProp->m_SnapshotSetId);
	
	// Pack the snapshot context
	channel.Pack(ft, lContext);

	// Pack the number of snapshots in this snapshot set
	channel.Pack(ft, pProp->m_lSnapshotsCount);

	// Compute the entire buffer length and save it.
	// TBD: move to ULONG
	DWORD dwFinalOffset = channel.GetCurrentInputOffset();
	
	BS_ASSERT( dwFinalOffset > dwInitialOffset );
	DWORD dwBufferLength = dwFinalOffset - dwInitialOffset;
	if ( dwBufferLength > (DWORD)((USHORT)(-1)) )
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
				L"Error: the buffer length cannot be stored in a USHORT %ld", dwBufferLength );
				
	ULONG ulBufferLength = (ULONG)dwBufferLength;
	BS_ASSERT( pulBufferLength );
	::CopyMemory(pulBufferLength, &ulBufferLength, sizeof(ULONG));
	BS_ASSERT( (DWORD)ulBufferLength == dwBufferLength );
}


/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot::LoadXXX methods
//



void CVssQueuedSnapshot::LoadSnapshotProperties() throw(HRESULT)

/*++

Description:

	This method loads various properties of a snapshot.
	It can call:
		- LoadDeviceNameFromID to load the device name
		- Load the properties kept in the Application data
		- LoadOriginalVolumeIoctl for getting the original volume name

	If bGetOnly == true then this method was called in a Get call.
	Otherwise it was called in a Set call.

Throws:

    E_OUTOFMEMORY
    VSS_E_OBJECT_NOT_FOUND
        - The snapshot with this ID was not found.

    [FindPersistedSnapshotByID() failures]
        E_OUTOFMEMORY

        [EnumerateSnapshots() failures]
            VSS_E_PROVIDER_VETO
                - On runtime errors (like Unpack)
            E_OUTOFMEMORY  

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::LoadSnapshotProperties");
		
	// Get the snapshot properties structure
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	if (pProp == NULL)
	{
		BS_ASSERT(false);
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL properties structure." );
	}

	// Assume that the Snapshot is completed
	BS_ASSERT(!IsDuringCreation());
	BS_ASSERT(pProp->m_SnapshotId != GUID_NULL);
	
	// If the device name is not completed, search for it
   	BS_ASSERT(!IsDuringCreation());
	if (pProp->m_pwszSnapshotDeviceObject == NULL)
	{
		// Try to find a created snapshot with this ID
		bool bFound = CVssQueuedSnapshot::FindPersistedSnapshotByID(
		    pProp->m_SnapshotId, 
		    m_lContext,
		    &(pProp->m_pwszSnapshotDeviceObject)
		    );

		// Handle the "snapshot not found" special error
		if (!bFound)
			ft.Throw(VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND,
					L"A snapshot with Id" WSTR_GUID_FMT L"was not found",
					GUID_PRINTF_ARG(pProp->m_SnapshotId) );
		BS_ASSERT(pProp->m_pwszSnapshotDeviceObject != NULL);
	}

	// Load the needed fields saved in snapshot header and standard structure
	// Open the snapshot channel, if needed.
	OpenSnapshotChannel();

	// send the IOCTL.
	m_snapIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, true, VSS_ICHANNEL_LOG_PROV);

	// Unpack the snapshot structure
	LONG lStructureContext;
	bool bHidden;
	LoadStructure(m_snapIChannel, pProp, &lStructureContext, &bHidden);
	if (bHidden)
		ft.Throw(VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND,
				L"A snapshot with Id" WSTR_GUID_FMT L"is hidden therefore reported as not being found",
				GUID_PRINTF_ARG(pProp->m_SnapshotId) );

	// Change the internal context to be equal with the on-disk context.
	// This is needed since we can perform a "Save" later and we need to preserve the real context.
	BS_ASSERT((m_lContext == VSS_CTX_ALL) || (lStructureContext == m_lContext));
	m_lContext = lStructureContext;

	// Get the original volume name and Id, if needed
	CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl(
	    m_snapIChannel, 
	    &(pProp->m_pwszOriginalVolumeName));

	// Get the timestamp
	CVssQueuedSnapshot::LoadTimestampIoctl(
	    m_snapIChannel, 
	    &(pProp->m_tsCreationTimestamp));
}


void CVssQueuedSnapshot::LoadStructure(
    IN  CVssIOCTLChannel& channel,
	OUT PVSS_SNAPSHOT_PROP pProp,
   	OUT LONG * plContext,  
   	OUT bool * pbHidden,
	IN  bool bIDsAlreadyLoaded /* = false */
    ) throw(HRESULT)

/*++

Description:

	This function will load the properties related to the snapshot from the given IOCTL channel

Arguments:

    IN  CVssIOCTLChannel& channel,
	OUT PVSS_SNAPSHOT_PROP pProp,
   	OUT LONG * plContext,       = NULL   // If NULL do not return the context.
	IN  bool bIDsAlreadyLoaded  = false  // If true, do not load the buffer length, the IDs and the ctx

Throws:

    VSS_E_PROVIDER_VETO
        - on error.

    E_OUTOFMEMORY

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::LoadStructure");

	ULONG ulBufferLength = 0;
    DWORD dwInitialOffset = 0;

    // Set the properties that have a constant value.
    pProp->m_eStatus = VSS_SS_CREATED;

    // if IDs not loaded yet
    if (!bIDsAlreadyLoaded) 
    {
    	// Unpack the length of the entire buffer
    	channel.Unpack(ft, &ulBufferLength );
    	if (ulBufferLength == 0) {
    	    BS_ASSERT(false);
    	    ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Warning: zero-size snapshot detected");
    	}

    	// Start counting entire buffer length, for checking
    	dwInitialOffset = channel.GetCurrentOutputOffset();

    	// Unpack the Appinfo ID
    	VSS_ID AppinfoId;
    	channel.Unpack(ft, &AppinfoId);
    	if ((AppinfoId != VOLSNAP_APPINFO_GUID_BACKUP_SERVER_SKU) &&
    	    (AppinfoId != VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE) &&
    	    (AppinfoId != VOLSNAP_APPINFO_GUID_HIDDEN))
    	{
    	    BS_ASSERT(false); // programming error
    	    ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Unknown app info " WSTR_GUID_FMT, GUID_PRINTF_ARG(AppinfoId));
    	}

    	// Unpack the Snapshot ID
    	channel.Unpack(ft, &(pProp->m_SnapshotId));

    	// Unpack the Snapshot Set ID
    	channel.Unpack(ft, &(pProp->m_SnapshotSetId));

        // Unpack the context
        LONG lContext;
    	channel.Unpack(ft, &(lContext));

	    // Consistency check
	    bool bHidden = !!(AppinfoId == VOLSNAP_APPINFO_GUID_HIDDEN);
	    if (!bHidden)
	    {
	        switch(lContext)
	        {
            case VSS_CTX_BACKUP:
                BS_ASSERT(AppinfoId == VOLSNAP_APPINFO_GUID_BACKUP_SERVER_SKU);
                break;
            case VSS_CTX_CLIENT_ACCESSIBLE:
                BS_ASSERT(AppinfoId == VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE);
                break;
            default:
                BS_ASSERT(false);
                ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Invalid context 0x%08lx", lContext);
	        }
	    }

    	// Setting up the attributes
    	pProp->m_lSnapshotAttributes = lContext;

        // Return the context
        BS_ASSERT(plContext != NULL);
   	    (*plContext) = lContext;
    	
        // Return the Hidden flag
        BS_ASSERT(pbHidden)
       	(*pbHidden) = bHidden;

    }
    else 
    {
        BS_ASSERT(plContext == NULL);
        BS_ASSERT(pbHidden == NULL);
    }

    // Unpack the snapshots count
    channel.Unpack(ft, &(pProp->m_lSnapshotsCount) );

    if (bIDsAlreadyLoaded == false) {
		// Compute the entire buffer length and check it.
#ifdef _DEBUG
		DWORD dwFinalOffset = channel.GetCurrentOutputOffset();
		BS_ASSERT( dwFinalOffset > dwInitialOffset );
		BS_ASSERT( dwFinalOffset - dwInitialOffset == ulBufferLength );
#endif
    }
}



void CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl(
    IN  CVssIOCTLChannel & snapshotIChannel,
    OUT LPWSTR * ppwszOriginalVolumeName
    ) throw(HRESULT)

/*++

Description:

	Load the original volume name and ID.
	Uses IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME.

Throws:

    VSS_E_PROVIDER_VETO
        - on runtime failures (like OpenSnapshotChannel, GetVolumeNameForVolumeMountPointW)
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl");
	LPCWSTR pwszDeviceVolumeName = NULL;

	try
	{
	    BS_ASSERT(ppwszOriginalVolumeName);
	    
    	// send the IOCTL.
    	snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME, 
    	    true, VSS_ICHANNEL_LOG_PROV);

    	// Load the Original volume name
    	snapshotIChannel.UnpackSmallString(ft, pwszDeviceVolumeName);

    	// Get the user-mode style device name
    	WCHAR wszVolNameUsermode[MAX_PATH];
    	if (::_snwprintf(wszVolNameUsermode, MAX_PATH - 1,
    			L"%s%s\\", wszGlobalRootPrefix, pwszDeviceVolumeName) < 0)
    		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Not enough memory" );

    	// Get the mount point for the original volume
    	WCHAR wszMPMVolumeName[MAX_PATH];
    	BOOL bSucceeded = ::GetVolumeNameForVolumeMountPointW(
    							wszVolNameUsermode,
    							wszMPMVolumeName, MAX_PATH );			
    	if (!bSucceeded)
			ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
			    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
			    L"GetVolumeNameForVolumeMountPointW( %s, ...)", wszVolNameUsermode);

        ::VssFreeString(*ppwszOriginalVolumeName);
        ::VssSafeDuplicateStr(ft, *ppwszOriginalVolumeName, wszMPMVolumeName);
    }
	VSS_STANDARD_CATCH(ft)

	::VssFreeString(pwszDeviceVolumeName);

	if (ft.HrFailed())
	    ft.Throw( VSSDBG_SWPRV, ft.hr, L"Exception detected");
}


void CVssQueuedSnapshot::LoadTimestampIoctl(
    IN  CVssIOCTLChannel &  snapshotIChannel,
    OUT VSS_TIMESTAMP    *  pTimestamp
    ) throw(HRESULT)

/*++

Description:

	Load the timestamp
	Uses IOCTL_VOLSNAP_QUERY_CONFIG_INFO.

Throws:

    VSS_E_PROVIDER_VETO
        - on runtime failures
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl");

    BS_ASSERT(pTimestamp);
    
	// send the IOCTL.
	snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_CONFIG_INFO, 
	    true, VSS_ICHANNEL_LOG_PROV);

	// Load the attributes
	ULONG ulAttributes = 0;
	snapshotIChannel.Unpack(ft, &ulAttributes);

	// Load the reserved field
	ULONG ulReserved = 0;
	snapshotIChannel.Unpack(ft, &ulReserved);

	// Load the timestamp
	BS_ASSERT(sizeof(LARGE_INTEGER) == sizeof(*pTimestamp));
	snapshotIChannel.Unpack(ft, pTimestamp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\provider.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Provider.hxx | Declarations used by the Software Snapshot Provider interface
    @end

Author:

    Adi Oltean  [aoltean]   07/13/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.
    aoltean     08/17/1999  Change CommitSnapshots to CommitSnapshot
    aoltean     09/23/1999  Using CComXXX classes for better memory management
                            Renaming back XXXSnapshots -> XXXSnapshot
    aoltean     09/26/1999  Returning a Provider Id in OnRegister
    aoltean     09/09/1999  Adding PostCommitSnapshots
                            dss->vss
	aoltean		09/20/1999	Making asserts more cleaner.
	aoltean		09/21/1999	Small renames

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "ichannel.hxx"
#include "ntddsnap.h"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"
#include "diff.hxx"
#include "alloc.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRPROVC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Global Definitions

CVssCriticalSection CVsSoftwareProvider::m_cs;

CVssDLList<CVssQueuedSnapshot*>	 CVssQueuedSnapshot::m_list;


STDMETHODIMP CVsSoftwareProvider::SetContext(
		IN  	LONG 	lContext				
		)
/*++

Routine description:

    Implements IVssSnapshotProvider::SetContext

Error codes:

    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    VSS_E_BAD_STATE
        - Attempt to change the context while it is frozen. It is illegal to
        change the context after the first call on the IVssSnapshotProvider object.

--*/
{
    CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVsSoftwareProvider::SetContext");

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                      L"The client is not an administrator");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: lContext = %ld\n", lContext );

        // Lock in order to update both variables atomically
		// The critical section will be left automatically at the end of scope.
        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Check if the context has been freezed
        if (m_bContextFrozen) {
            BS_ASSERT(false);
            ft.Throw( VSSDBG_SWPRV, VSS_E_BAD_STATE,
                      L"The context is already frozen");
        }

        // Change the context
        switch(lContext) {
        case VSS_CTX_CLIENT_ACCESSIBLE:
        case VSS_CTX_BACKUP:
        case VSS_CTX_ALL:
            m_lSnapContext = lContext;
            m_bContextFrozen = true;
            break;

        default:
            ft.Throw( VSSDBG_SWPRV, VSS_E_UNSUPPORTED_CONTEXT, L"Invalid context");
        }
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


LONG CVsSoftwareProvider::GetContextInternal() const
/*++

Routine description:

    Returns the current context

--*/
{
    CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVsSoftwareProvider::GetContextInternal");

    return m_lSnapContext;
}


void CVsSoftwareProvider::FreezeContext()
/*++

Routine description:

    Freezes the current context. To be called in IVssSoftwareProvider methods.

--*/
{
    CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVsSoftwareProvider::FreezeContext");

    // m_bContextFrozen may be already true...
    m_bContextFrozen = true;
}



/////////////////////////////////////////////////////////////////////////////
//  Definitions


STDMETHODIMP CVsSoftwareProvider::BeginPrepareSnapshot(
    IN      VSS_ID          SnapshotSetId,
    IN      VSS_ID          SnapshotId,
    IN      VSS_PWSZ		pwszVolumeName
    )

/*++

Description:

	Creates a Queued Snapshot object to be committed later.

Algorithm:

	1) Creates an internal VSS_SNAPSHOT_PROP structure that will keep most of the properties.
	2) Creates an CVssQueuedSnapshot object and insert it into the global queue of snapshots pending to commit.
	3) Set the state of the snapshot as PREPARING.
	4) If needed, create the snapshot object and return it to the caller.

Remarks:

	The queued snapshot object keeps a reference count. At the end of this function it will be:
		1 = the queued snap obj is reffered by the global queue (if no snapshot COM object was returned)
		2 = reffered by the global queue and by the returned snapshot COM object

Called by:

	IVssCoordinator::AddToSnapshotSet

Error codes:

    VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER
        - Volume not supported by provider.
    VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED
        - Maximum number of snapshots reached.
    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid arguments

    [CVssSoftwareProvider::GetVolumeInformation]
        E_OUTOFMEMORY
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        E_UNEXPECTED
            Unexpected programming error. Nothing is logged.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.

--*/


{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::BeginPrepareSnapshot" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  SnapshotId = " WSTR_GUID_FMT 	L"\n"
             L"  SnapshotSetId = " WSTR_GUID_FMT 	L"\n"
             L"  VolumeName = %s,\n"
             L"  ppSnapshot = %p,\n",
             GUID_PRINTF_ARG( SnapshotId ),
             GUID_PRINTF_ARG( SnapshotSetId ),
             pwszVolumeName);

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");
        if ( pwszVolumeName == NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pwszVolumeName is NULL");
        if ( SnapshotId == GUID_NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Snapshot ID is NULL");

        if (m_ProviderInstanceID == GUID_NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"The Provider instance ID could not be generated");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        // Check to see if the volume is supported.
        // This may throw VSS_E_OBJECT_NOT_FOUND or even VSS_E_PROVIDER_VETO if an error occurs.
        //
        LONG lVolAttr = GetVolumeInformationFlags(pwszVolumeName, GetContextInternal());
        if ((lVolAttr & VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT) == 0)
            ft.Throw( VSSDBG_SWPRV, VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER, L"Volume not supported");

        //
        //  Freeze the context
        //
        FreezeContext();
        BS_ASSERT((GetContextInternal() == VSS_CTX_BACKUP) || (GetContextInternal() == VSS_CTX_CLIENT_ACCESSIBLE));

        //
        //  Remove the non-autodelete snapshots from previous snapshot sets, if any
        //
        RemoveSnapshotsFromGlobalList(m_ProviderInstanceID, SnapshotSetId, VSS_QST_REMOVE_ALL_NON_AUTORELEASE);


        //
        //  Reset the provider interface state
        //

		// Create the structure that will keep the prepared snapshot state.
		VSS_OBJECT_PROP_Ptr ptrSnapshot;
		ptrSnapshot.InitializeAsSnapshot( ft,
			SnapshotId,
			SnapshotSetId,
			0,
			NULL,
			pwszVolumeName,
			NULL,
			NULL,
			NULL,
			NULL,
			VSS_SWPRV_ProviderId,
			GetContextInternal(),
			0,
			VSS_SS_PREPARING
			);

		// Create the snapshot object. After this assignment the ref count becomes 1.
		CComPtr<CVssQueuedSnapshot> ptrQueuedSnap = new CVssQueuedSnapshot(
            ptrSnapshot, m_ProviderInstanceID, GetContextInternal());
		if (ptrQueuedSnap == NULL)
			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error");

		// The structure was detached into the queued object
		// since the ownership was passed to the constructor.
		ptrSnapshot.Reset();

		// Add the snapshot object to the global queue. No exceptions should be thrown here.
		// The reference count will be 2.
		ptrQueuedSnap->AttachToGlobalList();

        // The destructor for the smart pointer will be called. The reference count will be 1
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVsSoftwareProvider::EndPrepareSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator as a rendez-vous method
    in order to finish the prepare phase for snapshots
    (like ending the background prepare tasks or performing the lengthly operations before
    issuing the snapshots freeze).

	This function acts on the given snapshot set (i.e. to call IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT
    on each snapshotted volume)

Algorithm:

	For each preparing snapshot (but not prepared yet) in this snapshot set:
		2) Call IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT
		3) Change the state of the snapshot to VSS_SS_PREPARED

	Compute the number of prepared snapshots.

	If a snapshot fails in operations above then the coordinator is responsible to Abort

Called by:

	IVssCoordinator::DoSnapshotsSet in the first phase (i.e. EndPrepare All Snapshots).

Remarks:

	- While calling this, Lovelace is not holding yet writes on snapshotted volumes.
	- The coordinator may issue many EndPrepareSnapshots calls for the same Snapshot Set ID.
	- This function can be called on a subsequent retry of DoSnapshotSet or immediately
	after PrepareSnapshots therefore the state of all snapshots must be PREPARING before calling this function.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors. Logging done.
    VSS_E_INSUFFICIENT_STORAGE
        Not enough disk storage to create a snapshot (for ex. diff area)
        (remark: when a snapshot is not created since there is not enough disk space 
        this error is not guaranteed to be returned. VSS_E_PROVIDER_VETO or VSS_E_OBJECT_NOT_FOUND 
        may also be returned in that case.)
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::EndPrepareSnapshots" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId )
			);

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Make sure that the context is frozen
        //
        BS_ASSERT(IsContextFrozen());

        //
        // Allocate the diff areas
        //

        CVssDiffAreaAllocator allocator(GetContextInternal(), SnapshotSetId);

        // Compute all new diff areas
        // This method may throw
        allocator.AssignDiffAreas();

        //
        // Change the state for the existing snapshots
        //

		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  SnapshotId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
                 GUID_PRINTF_ARG( pProp->m_SnapshotId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Deal only with the snapshots that must be pre-committed.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case  VSS_SS_PREPARING:

                // Remark - we are supposing here that only one snaphsot set can be
                // in progress. We are not checking again if the volume has snapshots.

				// Mark the state of this snapshot as failed
                // in order to correctly handle the state
				ptrQueuedSnapshot->MarkAsProcessingPrepare();

				// Open the volume IOCTL channel for that snapshot.
				ptrQueuedSnapshot->OpenVolumeChannel();
					
				// Send the IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT ioctl.
				ptrQueuedSnapshot->PrepareForSnapshotIoctl();

				// Mark the snapshot as prepared
				ptrQueuedSnapshot->MarkAsPrepared();
				break;

			case VSS_SS_PREPARED:

				// Snapshot was already prepared in another call
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        }

        // Commit all diff areas allocations
        // (otherwise the diff areas changes will be rollbacked in destructor)
        allocator.Commit();
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::PreCommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator in order to pre-commit all snapshots
	on the given snapshot set

Algorithm:

	For each prepared snapshot (but not precommitted yet) in this snapshot set:
		1) Change the state of the snapshot to VSS_SS_PRECOMMITTED

	Compute the number of pre-committed snapshots.

	If a snapshot fails in operations above then the coordinator is responsible to Abort

Called by:

	IVssCoordiantor::DoSnapshotsSet in the second phase (i.e. Pre-Commit All Snapshots).

Remarks:

	- While calling this, Lovelace is not holding yet writes on snapshotted volumes.
	- The coordinator may issue many PreCommitSnapshots calls for the same Snapshot Set ID.
	- This function can be called on a subsequent retry of DoSnapshotSet or immediately
	after EndPrepareSnapshots therefore the state of all snapshots must be PREPARED before calling this function.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::PreCommitSnapshots" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId )
			);

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Make sure that the context is frozen
        //
        BS_ASSERT(IsContextFrozen());

		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  SnapshotId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
                 GUID_PRINTF_ARG( pProp->m_SnapshotId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Deal only with the snapshots that must be pre-committed.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case  VSS_SS_PREPARED:

				// Mark the snapshot as processing pre-commit
				ptrQueuedSnapshot->MarkAsProcessingPreCommit();

				// Mark the snapshot as pre-committed
                // Do nothing in Babbage provider
				ptrQueuedSnapshot->MarkAsPreCommitted();

				break;

			case VSS_SS_PRECOMMITTED:

				// Snapshot was already pre-committed in another call
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        }
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::CommitSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator in order to commit all snapshots
	on the given snapshot set (i.e. to call IOCTL_VOLSNAP_COMMIT_SNAPSHOT on each snapshotted volume)

Algorithm:

	For each precommitted (but not yet committed) snapshot in this snapshot set:
		2) Call IOCTL_VOLSNAP_COMMIT_SNAPSHOT
		3) Change the state of the snapshot to VSS_SS_COMMITTED

	Return the number of committed snapshots, if success.
	Otherwise return 0 (even if some snapshots were committed).

	If a snapshot fails in operations above then the coordinator is responsible to Abort

Called by:

	IVssCoordinator::DoSnapshotsSet in the third phase (i.e. Commit All Snapshots).

Remarks:

	- While calling this, Lovelace is already holding writes on snapshotted volumes.
	- The coordinator may issue many CommitSnapshots calls for the same Snapshot Set ID.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::CommitSnapshots" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId ));

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Make sure that the context is frozen
        //
        BS_ASSERT(IsContextFrozen());

		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  SnapshotId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
                 GUID_PRINTF_ARG( pProp->m_SnapshotId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Commit the snapshot, if not failed in pre-commit phase.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case VSS_SS_PRECOMMITTED:

				// Mark the snapshot as processing commit
				ptrQueuedSnapshot->MarkAsProcessingCommit();

				// Send the IOCTL_VOLSNAP_COMMIT_SNAPSHOT ioctl.
				ptrQueuedSnapshot->CommitSnapshotIoctl();

				// Mark the snapshot as committed
				ptrQueuedSnapshot->MarkAsCommitted();
				break;

			case VSS_SS_COMMITTED:

				// Commit was already done.
				// The provider may receive many CommitSnapshots
				// calls for the same Snapshot Set ID.
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        }
    }
    VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::PostCommitSnapshots(
    IN      VSS_ID          SnapshotSetId,
    IN      LONG            lSnapshotsCount
    )

/*++

Description:

	This function gets called by the coordinator as a last phase after commit for all snapshots
	on the given snapshot set

Algorithm:

	For each committed snapshot in this snapshot set:
		1) Call IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT. The purpose of this
			IOCTL is to get the Snapshot Device object name.
		2) Create a unique snapshot ID
		3) Change the state of the snapshot to VSS_SS_CREATED
		4) Set the "number of committed snapshots" attribute of the snapshot set
		5) Save the snapshot properties using the IOCTL_VOLSNAP_SET_APPLICATION_INFO ioctl.
		6) If everything is OK then remove all snapshots from the global list.

	Keep the number of post-committed snapshots.

	If a snapshot fails in operations above then the coordinator is responsible to Abort

Called by:

	IVssCoordinator::DoSnapshotsSet in the third phase (i.e. Commit All Snapshots), after releasing writes
	by Lovelace

Remarks:

	- While calling this, Lovelace is not holding writes anymore.
	- The coordinator may issue many PostCommitSnapshots calls for the same Snapshot Set ID.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::PostCommitSnapshots" );
	LONG lProcessedSnapshotsCount = 0;

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
				  L"  SnapshotSetId = " WSTR_GUID_FMT L" \n"
				  L"  lSnapshotsCount = %ld",
				  GUID_PRINTF_ARG( SnapshotSetId ),
				  lSnapshotsCount);

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");
		if ( lSnapshotsCount < 0 )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"lSnapshotsCount < 0");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Make sure that the context is frozen
        //
        BS_ASSERT(IsContextFrozen());

		// On each committed snapshot store the lSnapshotsCount
		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  SnapshotId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
                 GUID_PRINTF_ARG( pProp->m_SnapshotId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Get the snapshot volume name and set the snapshot data.
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case VSS_SS_COMMITTED:

				// Mark the snapshot as processing post-commit
				ptrQueuedSnapshot->MarkAsProcessingPostCommit();

				// Remark: the snapshot device name will not be persisted

				// Fill the required properties - BEFORE the snapshot properties are saved!
				ptrQueuedSnapshot->SetPostcommitInfo(lSnapshotsCount);

				// Send the IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT ioctl.
				// Get the snapshot device name
				ptrQueuedSnapshot->EndCommitSnapshotIoctl(pProp);
				ft.Trace( VSSDBG_SWPRV, L"Snapshot created");

				// Increment the number of processed snapshots
				lProcessedSnapshotsCount++;

				// Mark the snapshot as created
				ptrQueuedSnapshot->MarkAsCreated();

				break;
				
			case VSS_SS_CREATED:

				// This snapshot is already created.
				// The provider may receive many PostCommitSnapshots
				// calls for the same Snapshot Set ID.
				break;

			default:
				BS_ASSERT(false);
				ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"bad state %d", ptrQueuedSnapshot->GetStatus());
			}
        } // end while(true)
    }
    VSS_STANDARD_CATCH(ft)

	// If an error occured then the coordinator is responsible to call AbortSnapshots
    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::AbortSnapshots(
    IN      VSS_ID          SnapshotSetId
    )

/*++

Description:

	This function gets called by the coordinator as to abort all snapshots from the given snapshot set.
    The snapshots are "reset" to the preparing state, so that a new DoSnapshotSet sequence can start.

Algorithm:

 	For each pre-committed snapshot in this snapshot set calls IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT.
 	For each committed or created snapshot it deletes the snapshot

Called by:

	IVssCoordinator::DoSnapshotsSet to abort precommitted snapshots

Remarks:

	- While calling this, Lovelace is not holding writes on snapshotted volumes.
	- The coordinator may receive many AbortSnapshots calls for the same Snapshot Set ID.

Return codes:

    E_ACCESSDENIED
    E_INVALIDARG
    VSS_E_PROVIDER_VETO
        - runtime errors (for example: cannot find diff areas). Logging done.
    VSS_E_OBJECT_NOT_FOUND
        If the internal volume name does not correspond to an existing volume then
        return VSS_E_OBJECT_NOT_FOUND (Bug 227375)
    E_UNEXPECTED
        - dev errors. No logging.
    E_OUTOFMEMORY

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::AbortSnapshots" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Argument validation
		if ( SnapshotSetId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotSetId == GUID_NULL");

		// Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
			L"  SnapshotSetId = " WSTR_GUID_FMT L"\n",
			GUID_PRINTF_ARG( SnapshotSetId ));

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Make sure that the context is frozen
        //
        BS_ASSERT(IsContextFrozen());

		LONG lProcessedSnapshotsCount = 0;
		CVssSnapIterator snapIterator;
        while (true)
        {
			CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot = snapIterator.GetNextBySnapshotSet(SnapshotSetId);

			// End of enumeration?
			if (ptrQueuedSnapshot == NULL)
				break;

			// Get the snapshot structure
			PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
			BS_ASSERT(pProp != NULL);

            ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
                 L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
                 L"  SnapshotId = " WSTR_GUID_FMT L"\n"
                 L"  VolumeName = %s\n"
                 L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
                 L"  lAttributes = 0x%08lx\n"
                 L"  status = %d\n",
                 pProp,
                 GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
                 GUID_PRINTF_ARG( pProp->m_SnapshotId ),
				 pProp->m_pwszOriginalVolumeName,
                 LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
                 pProp->m_lSnapshotAttributes,
				 pProp->m_eStatus);

			// Switch the snapshot back to "Preparing" state
			switch(ptrQueuedSnapshot->GetStatus())
			{
			case VSS_SS_PREPARING:
			case VSS_SS_PROCESSING_PREPARE: // Bug 207793

                // Nothing to do.
				break;

			case VSS_SS_PREPARED:
			case VSS_SS_PROCESSING_PRECOMMIT:
			case VSS_SS_PRECOMMITTED:

				// If snapshot was prepared, send IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT.
				ft.hr = ptrQueuedSnapshot->AbortPreparedSnapshotIoctl();
				if (ft.HrFailed())
					ft.Warning( VSSDBG_SWPRV,
                                L"sending IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT failed 0x%08lx", ft.hr);
                break;

			case VSS_SS_PROCESSING_COMMIT:
			case VSS_SS_COMMITTED:
			case VSS_SS_PROCESSING_POSTCOMMIT:
			case VSS_SS_CREATED:

			    try
                {
    				// If snapshot was committed, delete the snapshot
    				LONG lDeletedSnapshots = 0;
    				VSS_ID NondeletedSnapshotID = GUID_NULL;
    				ft.hr = CVsSoftwareProvider::InternalDeleteSnapshots(pProp->m_SnapshotId,
    				            VSS_OBJECT_SNAPSHOT,
            					GetContextInternal(),
    				            &lDeletedSnapshots,
    				            &NondeletedSnapshotID);
    				if (ft.HrFailed())
    					ft.Warning( VSSDBG_SWPRV,
                                    L"InternalDeleteSnapshots failed (%ld) " WSTR_GUID_FMT L"0x%08lx",
                                    lDeletedSnapshots,
                                    GUID_PRINTF_ARG(NondeletedSnapshotID),
                                    ft.hr);
    			}
			    VSS_STANDARD_CATCH(ft)
			
                break;

			default:
				BS_ASSERT(false);
			}

            // Reset the snapshot as preparing
            ptrQueuedSnapshot->ResetAsPreparing();

			lProcessedSnapshotsCount++;
        }

        ft.Trace( VSSDBG_SWPRV, L"%ld snapshots were aborted", lProcessedSnapshotsCount);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::GetSnapshotProperties(
    IN      VSS_ID          SnapshotId,
    OUT     PVSS_SNAPSHOT_PROP  pSavedProp
    )
/*++

Routine description:

    Implements IVssSoftwareSnapshotProvider::GetSnapshotProperties

Throws:

    E_OUTOFMEMORY
    E_INVALIDARG
    E_UNEXPECTED
        - Dev error. No logging.
    E_ACCESSDENIED
        - The user is not a backup operator or administrator

    [LoadSnapshotProperties() failures]
        E_OUTOFMEMORY
        VSS_E_OBJECT_NOT_FOUND
            - The snapshot with this ID was not found.

        [FindPersistedSnapshotByID() failures]
            E_OUTOFMEMORY

            [EnumerateSnapshots() failures]
                VSS_E_PROVIDER_VETO
                    - On runtime errors (like Unpack)
                E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssSoftwareProvider::GetSnapshotProperties" );

    try
    {
        // Initialize [out] arguments
        VssZeroOut( pSavedProp );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: pSavedProp = %p", pSavedProp );

        // Argument validation
		BS_ASSERT(pSavedProp);
		if ( SnapshotId == GUID_NULL )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"SnapshotId == GUID_NULL");
        if (pSavedProp == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pSavedProp");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// Get the list of snapshots in the give array
		CVssQueuedSnapshot::EnumerateSnapshots( true, SnapshotId, GetContextInternal(), pArray);

        // Extract the element from the array.
        if (pArray->GetSize() == 0)
            ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"Snapshot not found.");

        // Get the snapshot structure
    	VSS_OBJECT_PROP_Ptr& ptrObj = (*pArray)[0];
    	VSS_OBJECT_PROP* pObj = ptrObj.GetStruct();
    	BS_ASSERT(pObj);
    	BS_ASSERT(pObj->Type == VSS_OBJECT_SNAPSHOT);
    	VSS_SNAPSHOT_PROP* pSnap = &(pObj->Obj.Snap);

        // Fill out the [out] parameter
        VSS_OBJECT_PROP_Copy::copySnapshot(pSavedProp, pSnap);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


STDMETHODIMP CVsSoftwareProvider::MakeSnapshotReadWrite(
    IN      VSS_ID          SnapshotId
    )
/*++

Routine description:

    Implements IVssSoftwareSnapshotProvider::MakeSnapshotReadWrite

Throws:

    E_OUTOFMEMORY
    E_INVALIDARG
    E_UNEXPECTED
        - Dev error. No logging.
    E_ACCESSDENIED
        - The user is not a backup operator or administrator

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssSoftwareProvider::MakeSnapshotReadWrite" );

    return E_NOTIMPL;

    UNREFERENCED_PARAMETER(SnapshotId);
}


STDMETHODIMP CVsSoftwareProvider::SetSnapshotProperty(
	IN   VSS_ID  			SnapshotId,
	IN   VSS_SNAPSHOT_PROPERTY_ID	eSnapshotPropertyId,
	IN   VARIANT 			vProperty
	)
/*++

Routine description:

    Implements IVssSoftwareSnapshotProvider::SetSnapshotProperty


--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssSoftwareProvider::SetSnapshotProperty" );

    return E_NOTIMPL;
    
    UNREFERENCED_PARAMETER(SnapshotId);
    UNREFERENCED_PARAMETER(eSnapshotPropertyId);
    UNREFERENCED_PARAMETER(vProperty);
}


void CVsSoftwareProvider::RemoveSnapshotsFromGlobalList(
	IN	VSS_ID FilterID,
	IN	VSS_ID CurrentSnapshotSetID,
    IN  VSS_QSNAP_REMOVE_TYPE eRemoveType
	) throw(HRESULT)

/*++

Description:

	Detach from the global list all snapshots in this snapshot set

Remark:

	We detach all snapshots at once only in case of total success or total failure.
	This is because we want to be able to retry DoSnapshotSet if a failure happens.
	Therefore we must keep the list of snapshots as long as the client wants.

    VSS_QST_REMOVE_SPECIFIC_QS,  // Remove the remaining specific QS     (called in Provider itf. destructor)
    VSS_QST_REMOVE_ALL_QS,       // Remove all remaining QS              (called in OnUnload)

Called by:

	PostCommitSnapshots, AbortSnapshots, destructor and OnUnload

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::RemoveSnapshotsFromGlobalList" );
		
    ft.Trace( VSSDBG_SWPRV, L"FilterId = " WSTR_GUID_FMT L"CurrentSSID = " WSTR_GUID_FMT L"eRemoveType = %d",
                            GUID_PRINTF_ARG(FilterID),GUID_PRINTF_ARG(CurrentSnapshotSetID),eRemoveType );

	// For each snapshot in the snapshot set...
	LONG lProcessedSnapshotsCount = 0;
	CVssSnapIterator snapIterator;
    while (true)
    {
        CComPtr<CVssQueuedSnapshot> ptrQueuedSnapshot;

        // Check if we need to return all snapshots (OnUnload case)
        switch( eRemoveType ) {
        case VSS_QST_REMOVE_ALL_QS:
            BS_ASSERT( FilterID == GUID_NULL )
	        BS_ASSERT(CurrentSnapshotSetID == GUID_NULL);
		    ptrQueuedSnapshot = snapIterator.GetNext();
            break;
        case VSS_QST_REMOVE_SPECIFIC_QS:
	        BS_ASSERT(FilterID != GUID_NULL);
	        BS_ASSERT(CurrentSnapshotSetID == GUID_NULL);
		    ptrQueuedSnapshot = snapIterator.GetNextByProviderInstance(FilterID);
            break;
        case VSS_QST_REMOVE_ALL_NON_AUTORELEASE:
	        BS_ASSERT(FilterID != GUID_NULL);
	        BS_ASSERT(CurrentSnapshotSetID != GUID_NULL);
		    ptrQueuedSnapshot = snapIterator.GetNextByProviderInstance(FilterID);
            // BUG 385538: This is a snapshot that belongs to the same snapshot set. Ignore it.
	        if (ptrQueuedSnapshot && (CurrentSnapshotSetID == ptrQueuedSnapshot->GetSnapshotSetID()))
	            continue;
            // If we are trying to remove the non-autodelete qs then ignore the autodelete ones.
            // These ones will be removed when the interface is released
            if (ptrQueuedSnapshot &&
                (0 == (ptrQueuedSnapshot->GetContextInternal() & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE)))
            {
                // This is an auto-release snapshot.
                // Since the current context didn't change, it should also refer to autorelease snapshots
		        continue;
            }
            break;
        default:
            BS_ASSERT(false);
            ptrQueuedSnapshot = NULL;
        }

		// End of enumeration?
		if (ptrQueuedSnapshot == NULL)
			break;

		// Get the snapshot structure
		PVSS_SNAPSHOT_PROP pProp = ptrQueuedSnapshot->GetSnapshotProperties();
		BS_ASSERT(pProp != NULL);

        ft.Trace( VSSDBG_SWPRV, L"Field values for %p: \n"
             L" *ProvInstanceId = " WSTR_GUID_FMT L"\n"
             L"  SnapshotId = " WSTR_GUID_FMT L"\n"
             L"  SnapshotSetId = " WSTR_GUID_FMT L"\n"
             L"  VolumeName = %s\n"
             L"  Creation timestamp = " WSTR_LONGLONG_FMT L"\n"
             L"  lAttributes = 0x%08lx\n"
             L"  status = %d\n",
             pProp,
             GUID_PRINTF_ARG( ptrQueuedSnapshot->GetProviderInstanceId() ),
             GUID_PRINTF_ARG( pProp->m_SnapshotSetId ),
             GUID_PRINTF_ARG( pProp->m_SnapshotId ),
			 pProp->m_pwszOriginalVolumeName,
             LONGLONG_PRINTF_ARG( pProp->m_tsCreationTimestamp ),
             pProp->m_lSnapshotAttributes,
			 pProp->m_eStatus);

        // The destructor (and the autodelete stuff) is called here.
		ptrQueuedSnapshot->DetachFromGlobalList();
		lProcessedSnapshotsCount++;
	}

	ft.Trace( VSSDBG_SWPRV, L" %ld snapshots were detached", lProcessedSnapshotsCount);
}


STDMETHODIMP CVsSoftwareProvider::OnLoad(
	IN  	IUnknown* pCallback	
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::OnLoad" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED, L"Access denied");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Purge all hidden snapshots that may become available for delete
        PurgeSnapshots(true);
    }
    VSS_STANDARD_CATCH(ft)

    // Log warning and ignore error code
    // (bug 406920	CVsSoftwareProvider::OnLoad fails if drive goes away)
    if (ft.HrFailed())
        ft.LogGenericWarning(VSSDBG_SWPRV, L"PurgeSnapshots(true)");

    return S_OK;
    UNREFERENCED_PARAMETER(pCallback);
}


STDMETHODIMP CVsSoftwareProvider::OnUnload(
	IN  	BOOL	bForceUnload				
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::OnUnload" );

    try
    {
        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED, L"Access denied");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Remove all snapshots that belong to all provider instance IDs
    	RemoveSnapshotsFromGlobalList(GUID_NULL, GUID_NULL, VSS_QST_REMOVE_ALL_QS);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    UNREFERENCED_PARAMETER(bForceUnload);
}


STDMETHODIMP CVsSoftwareProvider::IsVolumeSupported(
    IN      VSS_PWSZ        pwszVolumeName,
    OUT     BOOL *          pbSupportedByThisProvider
    )

/*++

Description:

    This call is used to check if a volume can be snapshotted or not by the
    corresponding provider.

Parameters
    pwszVolumeName
        [in] The volume name to be checked. It must be one of those returned by
        GetVolumeNameForVolumeMountPoint, in other words in
        the \\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\ format
        with the corresponding unique ID.(with trailing backslash)
    pbSupportedByThisProvider
        [out] Non-NULL pointer that receives TRUE if the volume can be
        snapshotted using this provider or FALSE otherwise.

Return codes
    S_OK
        The function completed with success
    E_ACCESSDENIED
        The user is not an administrator.
    E_INVALIDARG
        NULL pointers passed as parameters or a volume name in an invalid format.
    E_OUTOFMEMORY
        Out of memory or other system resources
    E_UNEXPECTED
        Unexpected programming error. Logging not done and not needed.
    VSS_E_PROVIDER_VETO
        An error occured while opening the IOCTL channel. The error is logged.

    [CVssSoftwareProvider::GetVolumeInformation]
        E_OUTOFMEMORY
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        E_UNEXPECTED
            Unexpected programming error. Nothing is logged.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.


Remarks
    The function will return TRUE in the pbSupportedByThisProvider
    parameter if it is possible to create a snapshot on the given volume.
    The function must return TRUE on that volume even if the current
    configuration does not allow the creation of a snapshot on that volume.
    For example, if the maximum number of snapshots were reached on the
    given volume (and therefore no more snapshots can be created on that volume),
    the method must still indicate that the volume can be snapshotted.

--*/


{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::IsVolumeSupported" );

    try
    {
        ::VssZeroOut(pbSupportedByThisProvider);

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszVolumeName = %p\n"
             L"  pbSupportedByThisProvider = %p\n",
             pwszVolumeName,
             pbSupportedByThisProvider);

        // Argument validation
        if ( (pwszVolumeName == NULL) || (wcslen(pwszVolumeName) == 0))
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pwszVolumeName is NULL");
        if (pbSupportedByThisProvider == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid bool");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Freeze the context
        //
        FreezeContext();

        // Get volume information. This may throw.
        LONG lVolAttr = GetVolumeInformationFlags(pwszVolumeName, GetContextInternal());
        (*pbSupportedByThisProvider) = ((lVolAttr & VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT) != 0);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}




STDMETHODIMP CVsSoftwareProvider::IsVolumeSnapshotted(
    IN      VSS_PWSZ        pwszVolumeName,
    OUT     BOOL *          pbSnapshotsPresent,
	OUT 	LONG *		    plSnapshotCompatibility
    )

/*++

Description:

    This call is used to check if a volume can be snapshotted or not by the
    corresponding provider.

Parameters
    pwszVolumeName
        [in] The volume name to be checked. It must be one of those returned by
        GetVolumeNameForVolumeMountPoint, in other words in
        the \\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\ format
        with the corresponding unique ID.(with trailing backslash)
    pbSnapshotPresent
        [out] Non-NULL pointer that receives TRUE if the volume has at least
        one snapshot or FALSE otherwise.
    plSnapshotCompatibility
        [out] Flags denoting the compatibility of the snapshotted volume with various operations

Return codes
    S_OK
        The function completed with success
    E_ACCESSDENIED
        The user is not an administrator.
    E_INVALIDARG
        NULL pointers passed as parameters or a volume name in an invalid format.
    E_OUTOFMEMORY
        Out of memory or other system resources
    E_UNEXPECTED
        Unexpected programming error. Logging not done and not needed.
    VSS_E_PROVIDER_VETO
        An error occured while opening the IOCTL channel. The error is logged.

    [CVssSoftwareProvider::GetVolumeInformation]
        E_OUTOFMEMORY
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.
        E_UNEXPECTED
            Unexpected programming error. Nothing is logged.
        VSS_E_OBJECT_NOT_FOUND
            The device does not exist or it is not ready.


Remarks
    The function will return S_OK even if the current volume is a non-supported one.
    In this case FALSE must be returned in the pbSnapshotPresent parameter.

--*/


{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::IsVolumeSnapshotted" );

    try
    {
        ::VssZeroOut(pbSnapshotsPresent);

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszVolumeName = %p\n"
             L"  pbSnapshotsPresent = %p\n"
             L"  plSnapshotCompatibility = %p\n",
             pwszVolumeName,
             pbSnapshotsPresent,
             plSnapshotCompatibility);

        // Argument validation
        if ( (pwszVolumeName == NULL) || (wcslen(pwszVolumeName) == 0))
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"pwszVolumeName is NULL");
        if (pbSnapshotsPresent == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid bool");
        if (plSnapshotCompatibility == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid plSnapshotCompatibility");

        CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        //
        //  Freeze the context
        //
        FreezeContext();

        // Get volume information. This may throw,
        LONG lVolAttr = GetVolumeInformationFlags(pwszVolumeName, GetContextInternal());

        (*pbSnapshotsPresent) = ((lVolAttr & VSS_VOLATTR_SNAPSHOTTED) != 0);
        (*plSnapshotCompatibility) = ((lVolAttr & VSS_VOLATTR_SNAPSHOTTED) != 0)?
            (VSS_SC_DISABLE_DEFRAG|VSS_SC_DISABLE_CONTENTINDEX): 0 ;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}


LONG CVsSoftwareProvider::GetVolumeInformationFlags(
    IN  LPCWSTR pwszVolumeName,
    IN  LONG    lContext
    ) throw(HRESULT)

/*++

Description:

    This function returns various attributes that describe
        - if the volume is supported by this provider
        - if the volume has snapshots.

Parameter:

    [in] The volume name to be checked. It must be one of those returned by
    GetVolumeNameForVolumeMountPoint, in other words in
    the \\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\ format
    with the corresponding unique ID.(with trailing backslash)

    [in] The context.

Return values:

    A combination of _VSS_VOLUME_INFORMATION_ATTR flags.

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO
        An error occured while opening the IOCTL channel. The error is logged.
    E_UNEXPECTED
        Unexpected programming error. Nothing is logged.
    VSS_E_OBJECT_NOT_FOUND
        The device does not exist or it is not ready.

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::GetVolumeInformationFlags" );
	CVssIOCTLChannel volumeIChannel;	// For checking the snapshots on a volume
    LONG lReturnedFlags = 0;

    // Argument validation
    BS_ASSERT(pwszVolumeName);
   	BS_ASSERT(::IsVolMgmtVolumeName( pwszVolumeName ));

    // Check if the volume is fixed (i.e. no CD-ROM, no removable)
    UINT uDriveType = ::GetDriveTypeW(pwszVolumeName);
    if ( uDriveType != DRIVE_FIXED) {
        ft.Trace( VSSDBG_SWPRV, L"Warning: Ingnoring the non-fixed volume (%s) - %ud",
                  pwszVolumeName, uDriveType);
        return lReturnedFlags;
    }

    // Check if the volume is NTFS
    DWORD dwFileSystemFlags = 0;
    WCHAR wszFileSystemNameBuffer[MAX_PATH+1];
    if (!::GetVolumeInformationW(pwszVolumeName,
            NULL,   // lpVolumeNameBuffer
            0,      // nVolumeNameSize
            NULL,   // lpVolumeSerialNumber
            NULL,   // lpMaximumComponentLength
            &dwFileSystemFlags,
            wszFileSystemNameBuffer,
            MAX_PATH
            ))
    {
        ft.Trace( VSSDBG_SWPRV,
                  L"Warning: Error calling GetVolumeInformation on volume '%s' 0x%08lx",
                  pwszVolumeName, GetLastError());

        // Check if the volume was found
        if ((GetLastError() == ERROR_NOT_READY) ||
            (GetLastError() == ERROR_DEVICE_NOT_CONNECTED))
            ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND,
                  L"Volume not found: error calling GetVolumeInformation on volume '%s' : %u",
                  pwszVolumeName, GetLastError() );

        // RAW volumes are supported by VSS (bug 209059)
        if (GetLastError() != ERROR_UNRECOGNIZED_VOLUME)
            return lReturnedFlags;
    }

    // We do not support snapshots on read-only volumes
    if (dwFileSystemFlags & FILE_READ_ONLY_VOLUME) {
        ft.Trace( VSSDBG_SWPRV, L"Encountered a read-only volume (%s)", pwszVolumeName);
        return lReturnedFlags;
    }

    // If the file system is NTFS then mark the volume as supported for diff area
    if (::wcscmp(wszFileSystemNameBuffer, wszFileSystemNameNTFS) == 0) {
    	// Mark the volume as supported since the query succeeded.
    	lReturnedFlags |= VSS_VOLATTR_SUPPORTED_FOR_DIFF_AREA;
    }
    else if ( (lContext != VSS_CTX_ALL) && (lContext & VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE) )
    {
        // For contexts different than Backup, make sure that we do not support NTFS volumes
        ft.Trace( VSSDBG_SWPRV, L"Encountered a non-NTFS volume (%s) - %s",
                  pwszVolumeName, wszFileSystemNameBuffer);
        return lReturnedFlags;
    }

    // Open the volume. Throw "object not found" if needed.
	volumeIChannel.Open(ft, pwszVolumeName, true, true, VSS_ICHANNEL_LOG_PROV);

    // Check to see if there are existing snapshots
	ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS);
    if (ft.HrFailed()) {
        // The volume is not even supported
        ft.hr = S_OK;
        return 0;
    }

	// Mark the volume as supported since the query succeeded.
	lReturnedFlags |= VSS_VOLATTR_SUPPORTED_FOR_SNAPSHOT;

	// Get the length of snapshot names multistring
	ULONG ulMultiszLen;
	volumeIChannel.Unpack(ft, &ulMultiszLen);

    // If the multistring is empty, then ulMultiszLen is necesarily 2
    // (i.e. two l"\0' characters)
    // Then mark the volume as snapshotted.
	if (ulMultiszLen != nEmptyVssMultiszLen)
	    lReturnedFlags |= VSS_VOLATTR_SNAPSHOTTED;

    return lReturnedFlags;
}



CVsSoftwareProvider::CVsSoftwareProvider():
    m_bContextFrozen(false),
    m_lSnapContext(VSS_CTX_BACKUP)
{
    CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVsSoftwareProvider::CVsSoftwareProvider");

    // Create the provider instance Id (which is used to mark the queued snapshots that belongs to it)
    ft.hr = ::CoCreateGuid(&m_ProviderInstanceID);
    if (ft.HrFailed()) {
        m_ProviderInstanceID = GUID_NULL;
        ft.Trace( VSSDBG_SWPRV, L"CoCreateGuid failed 0x%08lx", ft.hr );
        // TBD: Add event log here.
    }
    else {
        BS_ASSERT(m_ProviderInstanceID != GUID_NULL);
    }
}


CVsSoftwareProvider::~CVsSoftwareProvider()
{
    CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVsSoftwareProvider::~CVsSoftwareProvider");

    // Remove here all [Auto-Delete] queued snapshots that belong to this particular
    // Provider Instance ID.
    // The volume handle gets closed here and this will delete the underlying snapshots.
    if (m_ProviderInstanceID != GUID_NULL)
        RemoveSnapshotsFromGlobalList(m_ProviderInstanceID, GUID_NULL, VSS_QST_REMOVE_SPECIFIC_QS);
    else {
        BS_ASSERT(false);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by swprv.rc
//
#define IDS_PROJNAME                    100
#define IDR_SWPRV                       101
#define IDS_SERVICE_DESCRIPTION         102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\qsnap.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module QSnap.hxx | Defines the internal data structure attached to a snapshot.
    @end

Author:

    Adi Oltean  [aoltean]   07/13/1999

Revision History:

    Name        Date        Comments

    aoltean     11/??/1999  Created.


--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"
#include "vssmsg.h"

#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRQSNPC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  CVssQueuedSnapshot IOCTL commands


void CVssQueuedSnapshot::OpenVolumeChannel() throw(HRESULT)

/*++

Description:

	Open the volume IOCTL.

Warning:

	The original volume name must be already known!

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::OpenVolumeChannel");
		
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();

	// Open the volume channel, if needed.
	if( !m_snapIChannel.IsOpen() )
	{
		if (pProp->m_pwszOriginalVolumeName == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Unknown volume name." );
		}

		// Open the channel. Remove the trailing backslash. It will throw on error.
		BS_ASSERT(::wcslen(pProp->m_pwszOriginalVolumeName) == nLengthOfVolMgmtVolumeName);
		m_volumeIChannel.Open(ft, pProp->m_pwszOriginalVolumeName, true, true, VSS_ICHANNEL_LOG_PROV);
	}
}


void CVssQueuedSnapshot::OpenSnapshotChannel() throw(HRESULT)

/*++

Description:

	Open the snapshot IOCTL.

Warning:

	The snapshot device name must be already known!

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::OpenSnapshotChannel");
		
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();

	// Open the snapshot channel, if needed.
   	BS_ASSERT(!IsDuringCreation());
	if( !m_snapIChannel.IsOpen() )
	{
		if (pProp->m_pwszSnapshotDeviceObject == NULL)
		{
			BS_ASSERT(false);
			ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"Unknown device object." );
		}
		
        // Open the snapshot. There is no trailing backslash to eliminate.
        // It will throw on error and log it.
		m_snapIChannel.Open(ft, pProp->m_pwszSnapshotDeviceObject, false, true, VSS_ICHANNEL_LOG_PROV);
	}
}


void CVssQueuedSnapshot::PrepareForSnapshotIoctl()

/*++

Description:

	Send IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::PrepareForSnapshotIoctl");

	BS_ASSERT(m_volumeIChannel.IsOpen());
	

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_pwszOriginalVolumeName != NULL);

/* 
    TBD: Replace this code with the correct code that rejects creation of multiple backup snapshots

    // Check to see if there are existing snapshots
	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, true, VSS_ICHANNEL_LOG_PROV);

	// Get the length of snapshot names multistring
	ULONG ulMultiszLen;
	m_volumeIChannel.Unpack(ft, &ulMultiszLen);

    // If the multistring is empty, then ulMultiszLen is necesarily 2
    // (i.e. two l"\0' characters)
	if (ulMultiszLen != 2) {
	    ft.LogError( VSS_ERROR_MULTIPLE_SNAPSHOTS_UNSUPPORTED,
	        VSSDBG_SWPRV << pProp->m_pwszOriginalVolumeName );
	    ft.Throw( VSSDBG_SWPRV, VSS_E_PROVIDER_VETO,
	              L"A snapshot already exist on the current volume" );
	}
*/

	// Pack snapshot attributes
	ULONG ulTmp = static_cast<ULONG>(0);
	m_volumeIChannel.Pack(ft, ulTmp);

	// Pach the reserved field
	ulTmp = 0;
	m_volumeIChannel.Pack(ft, ulTmp);

	// Pack initial allocation size
	m_volumeIChannel.Pack(ft, m_llInitialAllocation);

	// Send the IOCTL
	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_PREPARE_FOR_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV);
}


void CVssQueuedSnapshot::CommitSnapshotIoctl()  throw(HRESULT)

/*++

Description:

	Send IOCTL_VOLSNAP_COMMIT_SNAPSHOT

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::CommitSnapshotIoctl");

	BS_ASSERT(m_volumeIChannel.IsOpen());

	// Send the IOCTL
	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_COMMIT_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV);
}


void CVssQueuedSnapshot::EndCommitSnapshotIoctl(
	IN	PVSS_SNAPSHOT_PROP pProp
	) throw(HRESULT)

/*++

Description:

	Send IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT. Save also the snapshot properties.

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::EndCommitSnapshotIoctl");

    BS_ASSERT(pProp);
    BS_ASSERT(pProp->m_pwszSnapshotDeviceObject == NULL);
	BS_ASSERT(m_volumeIChannel.IsOpen());

    // Save the snapshot properties
    SaveStructure(m_volumeIChannel, pProp, GetContextInternal(), false);

	// Send the IOCTL
	m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_END_COMMIT_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV);
}



HRESULT CVssQueuedSnapshot::AbortPreparedSnapshotIoctl()

/*++

Description:

	Send IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT

Throws:

    E_OUTOFMEMORY
    VSS_E_PROVIDER_VETO

--*/

{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::AbortPreparedSnapshotIoctl");

	try
	{
		BS_ASSERT(m_volumeIChannel.IsOpen());

		// send the IOCTL
		m_volumeIChannel.Call(ft, IOCTL_VOLSNAP_ABORT_PREPARED_SNAPSHOT, true, VSS_ICHANNEL_LOG_PROV);
	}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
}


/////////////////////////////////////////////////////////////////////////////
//  CVssQueuedSnapshot constructor


CVssQueuedSnapshot::CVssQueuedSnapshot(
	IN  VSS_OBJECT_PROP_Ptr& ptrSnap,	// Ownership passed to the Constructor
    IN  VSS_ID ProviderInstanceId,
    IN  LONG   lContext
	):
	m_cookie(VSS_NULL_COOKIE),
	m_llInitialAllocation(nDefaultInitialSnapshotAllocation),			// Babbage-related properties
	m_ptrSnap(ptrSnap),					// Properties related to the standard structure.
	m_lRefCount(0),						// Life-management
    m_ProviderInstanceId(ProviderInstanceId),
    m_lContext(lContext)
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::CVssQueuedSnapshot");
}


CVssQueuedSnapshot::~CVssQueuedSnapshot()
/*++

Remarks: 

    Delete here all auto-delete snapshots

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::~CVssQueuedSnapshot");
    VSS_ID SnapshotId = GUID_NULL;
    
    try
    {
        // Get the snapshot Id
    	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
        BS_ASSERT(pProp);
    	SnapshotId = pProp->m_SnapshotId;

        ft.Trace( VSSDBG_SWPRV, L"INFO: Attempting to garbage collect snapshot with Id " WSTR_GUID_FMT L" [0x%08lx]", 
            GUID_PRINTF_ARG(SnapshotId), ft.hr);
        
        // If the snapshot is auto-release then delete it now.
        if ((SnapshotId != GUID_NULL) && 
            ((GetContextInternal() & VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE) == 0))
        {
            LONG lDeletedSnapshots = 0;
            VSS_ID SnapshotWithProblem = GUID_NULL;
            ft.hr = CVsSoftwareProvider::InternalDeleteSnapshots( SnapshotId, 
                        VSS_OBJECT_SNAPSHOT,
                        GetContextInternal(),
                        &lDeletedSnapshots,
                        &SnapshotWithProblem
                        );
            BS_ASSERT(lDeletedSnapshots <= 1);
        }
    }
    VSS_STANDARD_CATCH(ft)

    // Do not throw or log any error, we are in a destructor.
    if (ft.HrFailed())
        ft.Trace( VSSDBG_SWPRV, L"Error deleting snapshot with Id " WSTR_GUID_FMT L" [0x%08lx]", 
            GUID_PRINTF_ARG(SnapshotId), ft.hr);
}


/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot Operations


PVSS_SNAPSHOT_PROP CVssQueuedSnapshot::GetSnapshotProperties()
{
	CVssFunctionTracer ft(VSSDBG_SWPRV, L"CVssQueuedSnapshot::GetSnapshotProperties");

	if (m_ptrSnap.GetStruct() == NULL ||
		m_ptrSnap.GetStruct()->Type != VSS_OBJECT_SNAPSHOT)
		ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED, L"NULL  or invalid properties structure.");

	return &(m_ptrSnap.GetStruct()->Obj.Snap);
}

void CVssQueuedSnapshot::SetInitialAllocation(
	LONGLONG llInitialAllocation
	)
{
	m_llInitialAllocation = llInitialAllocation;
}


LONGLONG CVssQueuedSnapshot::GetInitialAllocation()
{
	return m_llInitialAllocation;
}


VSS_SNAPSHOT_STATE CVssQueuedSnapshot::GetStatus()	
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	return pProp->m_eStatus;
}


bool CVssQueuedSnapshot::IsDuringCreation()

/*++

Description:

	This method returns true if the snapshot is during creation

--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::IsDuringCreation");

	VSS_SNAPSHOT_STATE eState = GetStatus();

	switch(eState)
	{
	case VSS_SS_PREPARING:
	case VSS_SS_PROCESSING_PREPARE:
	case VSS_SS_PREPARED:
	case VSS_SS_PROCESSING_PRECOMMIT:
	case VSS_SS_PRECOMMITTED:
	case VSS_SS_PROCESSING_COMMIT:
	case VSS_SS_COMMITTED:
	case VSS_SS_PROCESSING_POSTCOMMIT:
		return true;
	default:
		return false;
	}
}


void CVssQueuedSnapshot::ResetSnapshotProperties() throw(HRESULT)

/*++

Description:

	Reset the internal fields that can change between Get calls.
	Cache only the immutable fields (for the future Gets on the same interface):
	- Snapshot ID
	- Snapshot Set ID
	- Provider ID
	- Snapshot Device name
	
--*/

{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::ResetSnapshotProperties");
		
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();

	// Reset the non-immutable property fields
	::VssFreeString(pProp->m_pwszOriginalVolumeName);
	pProp->m_eStatus = VSS_SS_UNKNOWN;

	// Close the opened IOCTL channels.
	m_volumeIChannel.Close();
	m_snapIChannel.Close();
}


void CVssQueuedSnapshot::ResetAsPreparing()	
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::ResetAsPreparing");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT((pProp->m_eStatus == VSS_SS_PREPARING)||
        (pProp->m_eStatus == VSS_SS_PROCESSING_PREPARE)||
        (pProp->m_eStatus == VSS_SS_PREPARED)||
        (pProp->m_eStatus == VSS_SS_PROCESSING_PRECOMMIT)||
		(pProp->m_eStatus == VSS_SS_PRECOMMITTED) ||
        (pProp->m_eStatus == VSS_SS_PROCESSING_COMMIT)||
		(pProp->m_eStatus == VSS_SS_COMMITTED)||
        (pProp->m_eStatus == VSS_SS_PROCESSING_POSTCOMMIT)||
		(pProp->m_eStatus == VSS_SS_CREATED));

	// Reset the properties/members that were completed during PreCommit, Commit or PostCommit
	pProp->m_SnapshotId = GUID_NULL;
	BS_ASSERT(pProp->m_pwszSnapshotDeviceObject == NULL);
	pProp->m_eStatus = VSS_SS_PREPARING;

	// Close the opened IOCTL channels.
	m_volumeIChannel.Close();
	m_snapIChannel.Close();
}


void CVssQueuedSnapshot::MarkAsProcessingPrepare()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsProcessingPrepare");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
    BS_ASSERT(pProp->m_eStatus == VSS_SS_PREPARING);
    pProp->m_eStatus = VSS_SS_PROCESSING_PREPARE;
}


void CVssQueuedSnapshot::MarkAsPrepared()	
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsPrepared");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PROCESSING_PREPARE);
	pProp->m_eStatus = VSS_SS_PREPARED;
}


void CVssQueuedSnapshot::MarkAsProcessingPreCommit()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsProcessingPreCommit");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
    BS_ASSERT(pProp->m_eStatus == VSS_SS_PREPARED);
    pProp->m_eStatus = VSS_SS_PROCESSING_PRECOMMIT;
}


void CVssQueuedSnapshot::MarkAsPreCommitted()	
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsPreCommitted");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PROCESSING_PRECOMMIT);
	pProp->m_eStatus = VSS_SS_PRECOMMITTED;
}


void CVssQueuedSnapshot::MarkAsProcessingCommit()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsProcessingCommit");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PRECOMMITTED);
    pProp->m_eStatus = VSS_SS_PROCESSING_COMMIT;
}


void CVssQueuedSnapshot::MarkAsCommitted()	
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsCommitted");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PROCESSING_COMMIT);
	pProp->m_eStatus = VSS_SS_COMMITTED;
}


void CVssQueuedSnapshot::MarkAsProcessingPostCommit()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsProcessingPostCommit");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp->m_eStatus == VSS_SS_COMMITTED);
    pProp->m_eStatus = VSS_SS_PROCESSING_POSTCOMMIT;
}


void CVssQueuedSnapshot::MarkAsCreated()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::MarkAsCreated");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();

	// Reset the properties/members that were completed during PreCommit, Commit or PostCommit
	BS_ASSERT(pProp->m_pwszSnapshotDeviceObject == NULL);

	// Close the opened IOCTL channels.
	m_volumeIChannel.Close();
	m_snapIChannel.Close();

	// Assert that the snapshot state
	// is set before "save"
	BS_ASSERT(pProp->m_eStatus == VSS_SS_CREATED);
}


void CVssQueuedSnapshot::SetPostcommitInfo(
    IN  LONG lSnapshotsCount
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::SetPostcommitInfo");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
    BS_ASSERT(pProp->m_SnapshotId != GUID_NULL);

	// Set the snapshots count
	BS_ASSERT(lSnapshotsCount != 0);
	BS_ASSERT(pProp->m_lSnapshotsCount == 0);
	pProp->m_lSnapshotsCount = lSnapshotsCount;

	// Set the snapshot state to "created" since it will be saved.
	BS_ASSERT(pProp->m_eStatus == VSS_SS_PROCESSING_POSTCOMMIT);
	pProp->m_eStatus = VSS_SS_CREATED;
}


VSS_ID CVssQueuedSnapshot::GetProviderInstanceId()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::GetProviderInstanceId");

	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();

    return m_ProviderInstanceId;
}


void CVssQueuedSnapshot::AttachToGlobalList() throw(HRESULT)
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::AttachToGlobalList");

	// The caller must have a separate reference to the object
	AddRef();

	BS_ASSERT( m_cookie == VSS_NULL_COOKIE );
	m_cookie = m_list.AddTail( ft, this );
}


void CVssQueuedSnapshot::DetachFromGlobalList()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::DetachFromGlobalList");

	BS_ASSERT( m_cookie != VSS_NULL_COOKIE );

	CVssQueuedSnapshot* pThis;
	m_list.ExtractByCookie( m_cookie, pThis );
	BS_ASSERT( this == pThis );
	m_cookie = VSS_NULL_COOKIE;

	// The caller must have a separate reference to the object
	Release();
}


VSS_ID CVssQueuedSnapshot::GetSnapshotID()
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp);

    return pProp->m_SnapshotId;
}


VSS_ID CVssQueuedSnapshot::GetSnapshotSetID()
{
	PVSS_SNAPSHOT_PROP pProp = GetSnapshotProperties();
	BS_ASSERT(pProp);

    return pProp->m_SnapshotSetId;
}
	


/////////////////////////////////////////////////////////////////////////////
// CVssSnapIterator
//


CVssSnapIterator::CVssSnapIterator():
	CVssDLListIterator<CVssQueuedSnapshot*>(CVssQueuedSnapshot::m_list)
{}


CVssQueuedSnapshot* CVssSnapIterator::GetNext()
{
	CVssQueuedSnapshot* pObj;
	if (CVssDLListIterator<CVssQueuedSnapshot*>::GetNext(pObj))
        return pObj;
    else
        return NULL;
}


CVssQueuedSnapshot* CVssSnapIterator::GetNextBySnapshot(
	IN		VSS_ID SID
	)
{
	CVssQueuedSnapshot* pObj;
	while (CVssDLListIterator<CVssQueuedSnapshot*>::GetNext(pObj))
		if (pObj->GetSnapshotID() == SID)
			return pObj;
	return NULL;
}


CVssQueuedSnapshot* CVssSnapIterator::GetNextBySnapshotSet(
	IN		VSS_ID SSID
	)
{
	CVssQueuedSnapshot* pObj;
	while (CVssDLListIterator<CVssQueuedSnapshot*>::GetNext(pObj))
		if (pObj->GetSnapshotSetID() == SSID)
			return pObj;
	return NULL;
}


CVssQueuedSnapshot* CVssSnapIterator::GetNextByProviderInstance(
	IN		VSS_ID PIID
	)
{
	CVssQueuedSnapshot* pObj;
	while (CVssDLListIterator<CVssQueuedSnapshot*>::GetNext(pObj))
		if (pObj->m_ProviderInstanceId == PIID)
			return pObj;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\diffreg.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module Diffreg.cxx | Implementation of CVssProviderRegInfo
    @end

Author:

    Adi Oltean  [aoltean]  03/13/2001

Revision History:

    Name        Date        Comments
    aoltean     03/13/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"
#include "vs_reg.hxx"

#include "diffreg.hxx"



////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRREGMC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  CVssDiffMgmt - Methods


void CVssProviderRegInfo::AddDiffArea(							
	IN  	VSS_PWSZ 	pwszVolumeName,         
	IN  	VSS_PWSZ 	pwszDiffAreaVolumeName,     
    IN      LONGLONG    llMaximumDiffSpace
	) throw(HRESULT)
/*++

Routine description:

    Adds a diff area association for a certain volume.
    If the association is not supported, an error code will be returned.
    
Throws:

    E_OUTOFMEMORY
        - lock failures.
    VSS_E_OBJECT_ALREADY_EXISTS
        - If an associaltion already exists
    
--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssProviderRegInfo::AddDiffArea" );

    BS_ASSERT(pwszVolumeName);
    BS_ASSERT(pwszDiffAreaVolumeName);

    // Extract the GUIDs
    GUID VolumeID, DiffAreaVolumeID;
    BOOL bRes = GetVolumeGuid( pwszVolumeName, VolumeID );
    BS_ASSERT(bRes);
    bRes = GetVolumeGuid( pwszDiffAreaVolumeName, DiffAreaVolumeID );
    BS_ASSERT(bRes);

    // Make sure this is the only association on hte original volume
    CVssRegistryKey reg;
    if (reg.Open( HKEY_LOCAL_MACHINE, L"%s\\" WSTR_GUID_FMT, wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID)))
        ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_ALREADY_EXISTS, L"There is an association on %s", pwszVolumeName);
    
    // Create the registry key
    reg.Create( HKEY_LOCAL_MACHINE, L"%s\\" WSTR_GUID_FMT L"\\" WSTR_GUID_FMT, 
        wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID), GUID_PRINTF_ARG(DiffAreaVolumeID));

    //Add the value denoting the maximum diff area
    reg.SetValue( wszVssMaxDiffValName, llMaximumDiffSpace);
}


void CVssProviderRegInfo::RemoveDiffArea(							
	IN  	VSS_PWSZ 	pwszVolumeName,         
	IN  	VSS_PWSZ 	pwszDiffAreaVolumeName
	) throw(HRESULT)
/*++

Routine description:

    Removes a diff area association for a certain volume.
    If the association does not exists, an error code will be returned.
    
Throws:

    E_OUTOFMEMORY
        - lock failures.
    VSS_E_OBJECT_NOT_FOUND
        - If an associaltion does not exists
    E_UNEXPECTED
        - Unexpected runtime errors.
    
--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssProviderRegInfo::RemoveDiffArea" );

    BS_ASSERT(pwszVolumeName);
    BS_ASSERT(pwszDiffAreaVolumeName);

    // Extract the GUIDs
    GUID VolumeID, DiffAreaVolumeID;
    if(!GetVolumeGuid( pwszVolumeName, VolumeID ))
        ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"The volume %s does not represent a volume name", pwszVolumeName );
    if(!GetVolumeGuid( pwszDiffAreaVolumeName, DiffAreaVolumeID ))
        ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"The volume %s does not represent a volume name", pwszDiffAreaVolumeName );

    // Open the registry key for that association, to make sure it's there.
    CVssRegistryKey reg;
    if (!reg.Open( HKEY_LOCAL_MACHINE, L"%s\\" WSTR_GUID_FMT L"\\" WSTR_GUID_FMT, 
            wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID), GUID_PRINTF_ARG(DiffAreaVolumeID)))
        ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"An association between %s and %s does not exist", 
            pwszVolumeName, pwszDiffAreaVolumeName);

    // Open the associations root key
    if (!reg.Open( HKEY_LOCAL_MACHINE, wszVssAssociationsKey))
        ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"The associations key does not exists", pwszVolumeName);

    // Recursively deletes the subkey for that volume.
    reg.DeleteSubkey( WSTR_GUID_FMT, GUID_PRINTF_ARG(VolumeID));
}


bool CVssProviderRegInfo::IsAssociationPresentInRegistry(							
	IN  	VSS_PWSZ 	pwszVolumeName,         
	IN  	VSS_PWSZ 	pwszDiffAreaVolumeName
	) throw(HRESULT)
/*++

Routine description:

    Removes a diff area association for a certain volume.
    If the association does not exists, an error code will be returned.
    
Throws:

    E_OUTOFMEMORY
        - lock failures.
    VSS_E_OBJECT_NOT_FOUND
        - If an associaltion does not exists
    E_UNEXPECTED
        - Unexpected runtime errors.
    
--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssProviderRegInfo::IsAssociationPresentInRegistry" );

    BS_ASSERT(pwszVolumeName);
    BS_ASSERT(pwszDiffAreaVolumeName);

    // Extract the GUIDs
    GUID VolumeID, DiffAreaVolumeID;
    if(!GetVolumeGuid( pwszVolumeName, VolumeID ))
        ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"The volume %s does not represent a volume name", pwszVolumeName );
    if(!GetVolumeGuid( pwszDiffAreaVolumeName, DiffAreaVolumeID ))
        ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"The volume %s does not represent a volume name", pwszDiffAreaVolumeName );

    // Try to open the registry key for that association, to make sure it's there.
    CVssRegistryKey reg;
    return reg.Open( HKEY_LOCAL_MACHINE, L"%s\\" WSTR_GUID_FMT L"\\" WSTR_GUID_FMT, 
            wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID), GUID_PRINTF_ARG(DiffAreaVolumeID));
}


void CVssProviderRegInfo::ChangeDiffAreaMaximumSize(							
	IN  	VSS_PWSZ 	pwszVolumeName,         
	IN  	VSS_PWSZ 	pwszDiffAreaVolumeName,     
    IN      LONGLONG    llMaximumDiffSpace
	) throw(HRESULT)
/*++

Routine description:

    Updates the diff area max size for a certain volume.
    This may not have an immediate effect
    
Throws:

    E_OUTOFMEMORY
        - lock failures.
    VSS_E_OBJECT_NOT_FOUND
        - The association does not exists
    E_UNEXPECTED
        - Unexpected runtime error. An error log entry is added.
    
--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssProviderRegInfo::ChangeDiffAreaMaximumSize" );

    BS_ASSERT(pwszVolumeName);
    BS_ASSERT(pwszDiffAreaVolumeName);

    // Extract the GUIDs
    GUID VolumeID, DiffAreaVolumeID;
    BOOL bRes = GetVolumeGuid( pwszVolumeName, VolumeID );
    BS_ASSERT(bRes);
    bRes = GetVolumeGuid( pwszDiffAreaVolumeName, DiffAreaVolumeID );
    BS_ASSERT(bRes);

    // Open the registry key
    CVssRegistryKey reg;
    if (!reg.Open( HKEY_LOCAL_MACHINE, L"%s\\" WSTR_GUID_FMT L"\\" WSTR_GUID_FMT, 
            wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID), GUID_PRINTF_ARG(DiffAreaVolumeID)))
        ft.Throw( VSSDBG_SWPRV, VSS_E_OBJECT_NOT_FOUND, L"An association between %s and %s does not exist", 
            pwszVolumeName, pwszDiffAreaVolumeName);

    // Update the value denoting the maximum diff area
    reg.SetValue( wszVssMaxDiffValName, llMaximumDiffSpace);
}


bool CVssProviderRegInfo::GetDiffAreaForVolume(							
	IN  	VSS_PWSZ 	pwszVolumeName,         
	IN OUT 	VSS_PWSZ &	pwszDiffAreaVolumeName,
	IN OUT 	LONGLONG &	llMaxSize
	) throw(HRESULT)
/*++

Routine description:

    Gets the diff area volume name from registry.
    In the next version this will return an array of diff area volumes associated with the given volume.

Returns:
    true
        - There is an association. Returns the diff area volume in the out parameter
    false
        - There is no association
    
Throws:

    E_OUTOFMEMORY
        - lock failures.
    E_UNEXPECTED
        - Unexpected runtime error. An error log entry is added.
    
--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssProviderRegInfo::GetDiffAreaForVolume" );

    BS_ASSERT(pwszVolumeName);
    BS_ASSERT(pwszDiffAreaVolumeName == NULL);
    BS_ASSERT(llMaxSize == 0);

    // Extract the GUIDs
    GUID VolumeID, DiffAreaVolumeID;
    BOOL bRes = GetVolumeGuid( pwszVolumeName, VolumeID );
    BS_ASSERT(bRes);

    // Open the registry key
    CVssRegistryKey reg;
    if (!reg.Open( HKEY_LOCAL_MACHINE, L"%s\\" WSTR_GUID_FMT, wszVssAssociationsKey, GUID_PRINTF_ARG(VolumeID)))
        return false;

    // Enumerate the subkeys (in fact it should be only one)
    CVssRegistryKeyIterator iter;
    iter.Attach(reg);
    BS_ASSERT(!iter.IsEOF());
    
    // Read the subkey name
    CVssAutoPWSZ awszVolumeName;
    awszVolumeName.Allocate(nLengthOfVolMgmtVolumeName);
    ::_snwprintf(awszVolumeName.GetRef(), nLengthOfVolMgmtVolumeName + 1, L"%s%s%s", 
        wszVolMgmtVolumeDefinition, iter.GetCurrentKeyName(), wszVolMgmtEndOfVolumeName);

    // Open the diff area key
    CVssRegistryKey reg2;
    bRes = reg2.Open( reg.GetHandle(), iter.GetCurrentKeyName());
    BS_ASSERT(bRes);

    // Get the max space
    reg2.GetValue( wszVssMaxDiffValName, llMaxSize );

    // Save also the new volume to the output parameter
    pwszDiffAreaVolumeName = awszVolumeName.Detach();

    // Go to next subkey. There should be no subkeys left since in this version we have only one diff area per volume.
    iter.MoveNext();
    BS_ASSERT(iter.IsEOF());
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\find.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Find.hxx | Defines the internal snapshot persistency-related methods.
    @end

Author:

    Adi Oltean  [aoltean]   01/10/2000

Revision History:

    Name        Date        Comments

    aoltean     01/10/2000  Created.


--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"

#include "ntddsnap.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRFINDC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CVssQueuedSnapshot::SaveXXX methods
//


void CVssQueuedSnapshot::EnumerateSnapshots(
	    IN  bool bSearchBySnapshotID,
	    IN  VSS_ID SnapshotID,
		IN  LONG lContext,
		IN OUT	VSS_OBJECT_PROP_Array* pArray
	    ) throw(HRESULT)

/*++

Description:

	This method enumerates all snapshots

Throws:

    VSS_E_PROVIDER_VETO
        - On runtime errors
    E_OUTOFMEMORY

--*/

{	
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::EnumerateSnapshots");
		
	// Enumerate snapshots through all the volumes
	WCHAR wszVolumeName[MAX_PATH+1];
	CVssAutoSearchHandle hSearch;
	bool bFirstVolume = true;
	while(true) {
	    
		// Get the volume name
		if (bFirstVolume) {
			hSearch.Set(::FindFirstVolumeW( wszVolumeName, MAX_PATH));
			if (hSearch == INVALID_HANDLE_VALUE)
				ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
				    L"FindFirstVolumeW( [%s], MAX_PATH)", wszVolumeName);
		    BS_ASSERT( (HANDLE)hSearch );
			bFirstVolume = false;
		} else {
		    BS_ASSERT( (HANDLE)hSearch );
			if (!::FindNextVolumeW( hSearch, wszVolumeName, MAX_PATH) ) {
				if (GetLastError() == ERROR_NO_MORE_FILES)
					break;	// End of iteration
				else
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
    				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO,
    				    L"FindNextVolumeW( %p, [%s], MAX_PATH)", hSearch, wszVolumeName);
			}
		}

        // Check if the volume is fixed (i.e. no CD-ROM, no removable)
        UINT uDriveType = ::GetDriveTypeW(wszVolumeName);
        if ( uDriveType != DRIVE_FIXED) {
            ft.Trace( VSSDBG_SWPRV, L"Warning: Ingnoring the non-fixed volume (%s) - %ud",
                      wszVolumeName, uDriveType);
            continue;
        }

        // Enumerate the snapshots on that volume
        BOOL bResult = EnumerateSnapshotsOnVolume( wszVolumeName, 
            bSearchBySnapshotID, SnapshotID, lContext, pArray );

        if (!bResult)
            continue;
	}
}


bool CVssQueuedSnapshot::EnumerateSnapshotsOnVolume(
		IN  VSS_PWSZ wszVolumeName,
	    IN  bool bSearchBySnapshotID,
	    IN  VSS_ID SnapshotID,
		IN  LONG lContext,
		IN OUT	VSS_OBJECT_PROP_Array* pArray,
	    IN  bool bThrowOnError // = false  By default do not throw on error
	    ) throw(HRESULT)

/*++

Description:

	This method enumerates all snapshots o the give volume

Returns:

    false - if the enumeration of volumes may continue
    true - otherwise

Throws:

    VSS_E_PROVIDER_VETO
        - On runtime errors
    E_OUTOFMEMORY

--*/
{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::EnumerateSnapshotsOnVolume");
		
	// Check if the snapshot is belonging to that volume
	// Open a IOCTL channel on that volume
	// Eliminate the last backslash in order to open the volume
	CVssIOCTLChannel volumeIChannel;
	ft.hr = volumeIChannel.Open(ft, wszVolumeName, true, bThrowOnError, 
	            bThrowOnError? VSS_ICHANNEL_LOG_PROV: VSS_ICHANNEL_LOG_NONE);
	if (ft.HrFailed())
		return false;

	// Get the list of snapshots
	// If IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS not
	// supported then try with the next volume.
	ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, 
	            bThrowOnError, bThrowOnError? VSS_ICHANNEL_LOG_PROV: VSS_ICHANNEL_LOG_NONE);
	if (ft.HrFailed())
		return false;

	// Get the length of snapshot names multistring
	ULONG ulMultiszLen;
	volumeIChannel.Unpack(ft, &ulMultiszLen);

#ifdef _DEBUG
	// Try to find the snapshot with the corresponding Id
	DWORD dwInitialOffset = volumeIChannel.GetCurrentOutputOffset();
#endif

	CVssAutoPWSZ pwszSnapshotName;
	while(volumeIChannel.UnpackZeroString(ft, pwszSnapshotName.GetRef())) {
	    
		// Compose the snapshot name in a user-mode style
		WCHAR wszUserModeSnapshotName[MAX_PATH];
        ::VssConcatenate( ft, wszUserModeSnapshotName, MAX_PATH - 1,
            wszGlobalRootPrefix, pwszSnapshotName );
		
		// Open that snapshot 
		// Do not eliminate the trailing backslash
		// Do not throw on error
    	CVssIOCTLChannel snapshotIChannel;
		ft.hr = snapshotIChannel.Open(ft, wszUserModeSnapshotName, false, 
		            bThrowOnError, bThrowOnError? VSS_ICHANNEL_LOG_PROV: VSS_ICHANNEL_LOG_NONE);
		if (ft.HrFailed()) {
			ft.Warning( VSSDBG_SWPRV, L"Warning: Error opening the snapshot device name %s [0x%08lx]",
						wszUserModeSnapshotName, ft.hr );
			return false;
		}

		// Send the IOCTL to get the application buffer
		ft.hr = snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, 
		            bThrowOnError, bThrowOnError? VSS_ICHANNEL_LOG_PROV: VSS_ICHANNEL_LOG_NONE);
		if (ft.HrFailed()) {
			ft.Warning( VSSDBG_SWPRV,
						L"Warning: Error sending the query IOCTL to the snapshot device name %s [0x%08lx]",
						wszUserModeSnapshotName, ft.hr );
			return false;
		}

		// Unpack the length of the application buffer
		ULONG ulLen;
		snapshotIChannel.Unpack(ft, &ulLen);

		if (ulLen == 0) {
		    BS_ASSERT(false);
			ft.Warning(VSSDBG_SWPRV, L"Warning: zero-size snapshot detected: %s", pwszSnapshotName);
			continue;
		}

    	// Unpack the Appinfo ID
    	VSS_ID AppinfoId;
    	snapshotIChannel.Unpack(ft, &AppinfoId);

        // We encountered a hidden snapshot
        if (AppinfoId == VOLSNAP_APPINFO_GUID_HIDDEN)
            continue;

        // Check for invalid values
    	if ((AppinfoId != VOLSNAP_APPINFO_GUID_BACKUP_SERVER_SKU) &&
    	    (AppinfoId != VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE))
    	{
    	    ft.Trace(VSSDBG_SWPRV, L"Unsupported app info for snapshot %s: " WSTR_GUID_FMT, 
    	        pwszSnapshotName.GetRef(), GUID_PRINTF_ARG(AppinfoId));
    	    continue;
    	}

		// Get the snapshot Id
		VSS_ID CurrentSnapshotId;
		snapshotIChannel.Unpack(ft, &CurrentSnapshotId);

        // If we are filtering, ignore the rest...
        if (bSearchBySnapshotID)
            if (SnapshotID != CurrentSnapshotId)
                continue;

		// Get the snapshot set Id
		VSS_ID CurrentSnapshotSetId;
		snapshotIChannel.Unpack(ft, &CurrentSnapshotSetId);

        // Get the snapshot context
        LONG lStructureContext;
		snapshotIChannel.Unpack(ft, &lStructureContext);

        // Further validation
        switch(lStructureContext)
        {
        case VSS_CTX_BACKUP:
            BS_ASSERT(AppinfoId == VOLSNAP_APPINFO_GUID_BACKUP_SERVER_SKU);
            break;
        case VSS_CTX_CLIENT_ACCESSIBLE:
            BS_ASSERT(AppinfoId == VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE);
            break;
        default:
            BS_ASSERT(false);
            continue;
        }

		// If the snapshot belongs to the wrong context, then ignore it.
		if (lContext != VSS_CTX_ALL)
		    if (lContext != lStructureContext)
                continue;
		
        //
		// Process the snapshot that was just found
		//
		
		// Initialize an empty snapshot properties structure
		VSS_OBJECT_PROP_Ptr ptrSnapProp;
		ptrSnapProp.InitializeAsSnapshot( ft,
			CurrentSnapshotId,
			CurrentSnapshotSetId,
			0,
			wszUserModeSnapshotName,
			wszVolumeName,
			NULL,
			NULL,
			NULL,
			NULL,
			VSS_SWPRV_ProviderId,
			lStructureContext,
			0,
			VSS_SS_UNKNOWN);

		// Get the snapshot structure
		VSS_OBJECT_PROP* pObj = ptrSnapProp.GetStruct();
		BS_ASSERT(pObj);
		VSS_SNAPSHOT_PROP* pSnap = &(pObj->Obj.Snap);

		// Load the rest of properties
		// Do not load the Name and the Original volume name fields
		// twice since they are already known
		LoadStructure( snapshotIChannel, pSnap, NULL, NULL, true );

    	// Get the original volume name and Id
		CVssQueuedSnapshot::LoadOriginalVolumeNameIoctl(
		    snapshotIChannel, 
		    &(pSnap->m_pwszOriginalVolumeName));

    	// Get the timestamp
    	CVssQueuedSnapshot::LoadTimestampIoctl(
    	    snapshotIChannel, 
    	    &(pSnap->m_tsCreationTimestamp));
    		
		if (!pArray->Add(ptrSnapProp))
			ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
					  L"Cannot add element to the array");

		// Reset the current pointer to NULL
		ptrSnapProp.Reset(); // The internal pointer was detached into pArray.
	}

#ifdef _DEBUG
	// Check if all strings were browsed correctly
	DWORD dwFinalOffset = volumeIChannel.GetCurrentOutputOffset();
	BS_ASSERT( (dwFinalOffset - dwInitialOffset == ulMultiszLen));
#endif

	return true;
}



bool CVssQueuedSnapshot::FindPersistedSnapshotByID(
    IN  VSS_ID SnapshotID,
    IN  LONG lContext,
    OUT LPWSTR * ppwszSnapshotDeviceObject
    ) throw(HRESULT)

/*++

Description:

	Finds a snapshot (and its device name) based on ID.

Throws:

    E_OUTOFMEMORY

    [EnumerateSnapshots() failures]
        VSS_E_PROVIDER_VETO
            - On runtime errors (like Unpack)
        E_OUTOFMEMORY    

--*/
{
	CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVssQueuedSnapshot::FindPersistedSnapshotByID");
		
	BS_ASSERT(SnapshotID != GUID_NULL);
	if (ppwszSnapshotDeviceObject != NULL) {
    	BS_ASSERT((*ppwszSnapshotDeviceObject) == NULL);
	}

    // Create the collection object. Initial reference count is 0.
    VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
    if (pArray == NULL)
        ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

    // Get the pointer to the IUnknown interface.
	// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
	// Now pArray's reference count becomes 1 (because of the smart pointer).
    CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
    BS_ASSERT(pArrayItf);

    // Put into the array only one element.
    EnumerateSnapshots(
	    true,
    	SnapshotID,
    	lContext,
    	pArray
    	);

    // Extract the element from the array.
    if (pArray->GetSize() == 0)
    	return false;

    if (ppwszSnapshotDeviceObject) {
    	VSS_OBJECT_PROP_Ptr& ptrObj = (*pArray)[0];
    	VSS_OBJECT_PROP* pObj = ptrObj.GetStruct();
    	BS_ASSERT(pObj);
    	BS_ASSERT(pObj->Type == VSS_OBJECT_SNAPSHOT);
    	VSS_SNAPSHOT_PROP* pSnap = &(pObj->Obj.Snap);
    	BS_ASSERT(pSnap->m_pwszSnapshotDeviceObject);
    	::VssSafeDuplicateStr(ft, (*ppwszSnapshotDeviceObject), 
    	    pSnap->m_pwszSnapshotDeviceObject);
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\mgmt.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module Mgmt.cxx | Implementation of IVssSnapshotMgmt
    @end

Author:

    Adi Oltean  [aoltean]  03/05/2001

Revision History:

    Name        Date        Comments
    aoltean     03/07/2001  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include "resource.h"

#include "vs_inc.hxx"
#include "vs_reg.hxx"
#include "vs_sec.hxx"

// Generated file from Coord.IDL
#include "vss.h"
#include "vscoordint.h"
#include "vsevent.h"
#include "vsprov.h"
#include "vsswprv.h"
#include "vsmgmt.h"

#include "swprv.hxx"
#include "ichannel.hxx"
#include "ntddsnap.h"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"
#include "diffreg.hxx"
#include "diffmgmt.hxx"



////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRMGMTC"
//
////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//  CVsSoftwareProvider


STDMETHODIMP CVsSoftwareProvider::GetProviderMgmtInterface(							
	IN  	VSS_ID 	    ProviderId,     //  It might be a software or a system provider.
	IN  	REFIID 	    InterfaceId,    //  Might be IID_IVssDifferentialSoftwareSnapshotMgmt
	OUT     IUnknown**  ppItf           
	)
/*++

Routine description:

    Returns an interface to further configure a snapshot provider

Error codes:

    E_ACCESSDENIED
        - The user is not a administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    E_NOINTERFACE
        - the provider does not support the interface with the given ID.
    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - unexpected error when calling QueryInteface
    
--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::GetProviderMgmtInterface" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppItf );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  InterfaceId = " WSTR_GUID_FMT L"\n"
             L"  ppItf = %p\n",
             GUID_PRINTF_ARG( ProviderId ),
             GUID_PRINTF_ARG( InterfaceId ),
             ppItf);

        // Argument validation
		BS_ASSERT(ppItf);
        if (ProviderId != VSS_SWPRV_ProviderId)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid provider ID");
        if (ppItf == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppItf");

        // Right now we support only IVssDifferentialSoftwareSnapshotMgmt. In future version we might support more interfaces.
        // WARNING: with the current implementation the client may still use QueryInterface to reach other provider's custom interfaces.
        // We cannot prevent that unless we decide to create a wrapper object around the returned provider interface, in order to 
        // intercept QueryInterface calls also.
        if ( InterfaceId != IID_IVssDifferentialSoftwareSnapshotMgmt )
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid Interface ID");

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // 
        // Create the instance
        //
        ft.hr = CVssDiffMgmt::CreateInstance( ppItf, InterfaceId );
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



STDMETHODIMP CVsSoftwareProvider::QueryVolumesSupportedForSnapshots(
	IN  	VSS_ID 	    ProviderId,     
    IN      LONG        lContext,
	OUT 	IVssEnumMgmtObject **ppEnum
	)
/*++

Routine description:

    Query volumes (on the local machine) that support snapshots.

Parameters:

    ProviderID - the provider on which we should return the supported volumes for snapshot. 
        If NULL ID is provided, then return the volumes that are supported by at least one provider.
        
    ppEnum - the returned list of volumes.

Remarks:

    The result of the query is independent by context.

Error codes:

    S_FALSE
        - If returning an empty array
    E_ACCESSDENIED
        - The user is not an administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    E_UNEXPECTED
        Error while getting the list of volumes. (for example dismounting a volume in the middle of an enumeration)
        A error log entry contains more information.

    [CVssSoftwareProvider::IsVolumeSupported() failures]
        S_OK
            The function completed with success
        E_ACCESSDENIED
            The user is not an administrator.
        E_INVALIDARG
            NULL pointers passed as parameters or a volume name in an invalid format.
        E_OUTOFMEMORY
            Out of memory or other system resources           
        E_UNEXPECTED
            Unexpected programming error. Logging not done and not needed.
        VSS_E_PROVIDER_VETO
            An error occured while opening the IOCTL channel. The error is logged.

        [CVssSoftwareProvider::GetVolumeInformation]
            E_OUTOFMEMORY
            VSS_E_PROVIDER_VETO
                An error occured while opening the IOCTL channel. The error is logged.
            E_UNEXPECTED
                Unexpected programming error. Nothing is logged.
            VSS_E_OBJECT_NOT_FOUND
                The device does not exist or it is not ready.
        
--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::QueryVolumesSupportedForSnapshots" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  ppEnum = %p\n",
             GUID_PRINTF_ARG( ProviderId ),
             ppEnum);

        // Argument validation
		BS_ASSERT(ppEnum);
        if (ProviderId != VSS_SWPRV_ProviderId)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid provider ID");
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppEnum");

        // Create the collection object. Initial reference count is 0.
        VSS_MGMT_OBJECT_PROP_Array* pArray = new VSS_MGMT_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

		WCHAR wszVolumeName[MAX_PATH+1];
		bool bFirstVolume = true;
    	CVssAutoSearchHandle hSearch;
		while(true) {

            //
			// Get the volume name
			//
			
			if (bFirstVolume) {
				hSearch.Set(::FindFirstVolumeW( wszVolumeName, MAX_PATH));
				if (hSearch == INVALID_HANDLE_VALUE)
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
    				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO, 
    				    L"FindFirstVolumeW( [%s], MAX_PATH)", wszVolumeName);
				bFirstVolume = false;
			} else {
				if (!::FindNextVolumeW( hSearch, wszVolumeName, MAX_PATH) ) {
					if (GetLastError() == ERROR_NO_MORE_FILES)
						break;	// End of iteration
					else
    				ft.TranslateInternalProviderError( VSSDBG_SWPRV, 
        				    HRESULT_FROM_WIN32(GetLastError()), VSS_E_PROVIDER_VETO, 
        				    L"FindNextVolumeW( %p, [%s], MAX_PATH)", hSearch, wszVolumeName);
				}
			}

            //
            //  Verify if the volume is supported
            //

            BOOL bIsSupported = FALSE;
            ft.hr = IsVolumeSupported( wszVolumeName, &bIsSupported);
            if (ft.HrFailed())
                ft.Throw(VSSDBG_SWPRV, ft.hr, L"Volume % not found", wszVolumeName);

            // Ignore volumes that are not supported.
            if (!bIsSupported)
                continue;

            // Treatment of errors
            if (ft.HrFailed())
                ft.Throw(VSSDBG_SWPRV, ft.hr, L"Rethrowing hr = 0x%08lx", ft.hr);

            // 
            //  Calculate the volume display name
            //

            WCHAR wszVolumeDisplayName[MAX_PATH];
            VssGetVolumeDisplayName( wszVolumeName, wszVolumeDisplayName, MAX_PATH);

            // 
            //  Add the supported volume to the list
            //

			// Initialize an empty snapshot properties structure
			VSS_MGMT_OBJECT_PROP_Ptr ptrVolumeProp;
			ptrVolumeProp.InitializeAsVolume( ft,
				wszVolumeName,
				wszVolumeDisplayName);

			if (!pArray->Add(ptrVolumeProp))
				ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
						  L"Cannot add element to the array");

			// Reset the current pointer to NULL
			ptrVolumeProp.Reset(); // The internal pointer was detached into pArray.
            
		}

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssMgmtEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssMgmtEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
		// Now pEnumObject's reference count becomes 1 (because of the smart pointer).
		// So if a throw occurs the enumerator object will be safely destroyed by the smart ptr.
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object.
		// The array's reference count becomes now 2, because IEnumOnSTLImpl::m_spUnk is also a smart ptr.
        BS_ASSERT(pArray);
		ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed()) {
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Cannot initialize enumerator instance. [0x%08lx]", ft.hr);
        }

        // Initialize the enumerator object.
		// The enumerator reference count becomes now 2.
        ft.hr = pUnknown->SafeQI(IVssEnumMgmtObject, ppEnum);
        if ( ft.HrFailed() ) { 
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Error querying the IVssEnumObject interface. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(*ppEnum);

		BS_ASSERT( !ft.HrFailed() );
		ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



/*++

Routine description:

    Query snapshots on the given volume.

Error codes:

    E_ACCESSDENIED
        - The user is not a administrator
    E_INVALIDARG
        - Invalid argument
    E_OUTOFMEMORY
        - lock failures.
    E_OBJECT_NOT_FOUND
        - Invalid volume name
        
--*/
STDMETHODIMP CVsSoftwareProvider::QuerySnapshotsByVolume(
	IN  	VSS_PWSZ 	pwszVolumeName,         
	IN  	VSS_ID 	    ProviderId,     
	OUT 	IVssEnumObject **ppEnum
	)
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::QuerySnapshotsByVolume" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_SWPRV, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");

        // Trace parameters
        ft.Trace( VSSDBG_SWPRV, L"Parameters: \n"
             L"  pwszVolumeName = %s\n"
             L"  ProviderId = " WSTR_GUID_FMT L"\n"
             L"  ppEnum = %p\n",
             pwszVolumeName,
             GUID_PRINTF_ARG( ProviderId ),
             ppEnum);

        // Argument validation
		BS_ASSERT(ppEnum);
        if (pwszVolumeName == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL pwszVolumeName");
        if (ProviderId != VSS_SWPRV_ProviderId)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"Invalid provider ID");
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppEnum");

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// The critical section will be left automatically at the end of scope.
		CVssAutomaticLock2 lock(CVsSoftwareProvider::GetGlobalCS());

        // Fill the array with the snapshots on the given volume
        BOOL bResult = CVssQueuedSnapshot::EnumerateSnapshotsOnVolume(pwszVolumeName, 
            false, GUID_NULL, VSS_CTX_ALL, pArray);
        BS_ASSERT(bResult);

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
		// Now pEnumObject's reference count becomes 1 (because of the smart pointer).
		// So if a throw occurs the enumerator object will be safely destroyed by the smart ptr.
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object.
		// The array's reference count becomes now 2, because IEnumOnSTLImpl::m_spUnk is also a smart ptr.
        BS_ASSERT(pArray);
		ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed()) {
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Cannot initialize enumerator instance. [0x%08lx]", ft.hr);
        }

        // Initialize the enumerator object.
		// The enumerator reference count becomes now 2.
        ft.hr = pUnknown->SafeQI(IVssEnumObject, ppEnum);
        if ( ft.HrFailed() ) { 
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Error querying the IVssEnumObject interface. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(*ppEnum);

		BS_ASSERT( !ft.HrFailed() );
		ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\query.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Query.hxx | Declarations used by the Software Snapshot Provider interface
    @end

Author:

    Adi Oltean  [aoltean]   09/15/1999

Revision History:

    Name        Date        Comments

    aoltean     09/23/1999  Created.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>
#include "swprv.hxx"

#include "vs_idl.hxx"

#include "resource.h"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"
#include "provider.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRQRYC"
//
////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  Implementation


STDMETHODIMP CVsSoftwareProvider::Query(
    IN      VSS_ID          QueriedObjectId,
    IN      VSS_OBJECT_TYPE eQueriedObjectType,
    IN      VSS_OBJECT_TYPE eReturnedObjectsType,
    OUT     IVssEnumObject**ppEnum
    )
/*++

Routine description:

    Implements IVssSnapshotProvider::Query

Return values:

    E_OUTOFMEORY
    E_ACCESSDENIED
        - if the user is not administrator
    E_INVALIARG
    E_UNEXPECTED
        - Dev error - no logging.

    [CVssQueuedSnapshot::EnumerateSnapshots() failures]
        VSS_E_PROVIDER_VETO
            - On runtime errors
        E_OUTOFMEMORY

--*/
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"CVsSoftwareProvider::Query" );

    try
    {
        // Initialize [out] arguments
        VssZeroOutPtr( ppEnum );

        // Access check
        if (!IsAdministrator())
            ft.Throw( VSSDBG_COORD, E_ACCESSDENIED,
                L"The client process is not running under an administrator account");
        
        ft.Trace( VSSDBG_SWPRV, L"Parameters: QueriedObjectId = " WSTR_GUID_FMT
				  L"eQueriedObjectType = %d. eReturnedObjectsType = %d, ppEnum = %p",
				  GUID_PRINTF_ARG( QueriedObjectId ),
				  eQueriedObjectType,
				  eReturnedObjectsType,
				  ppEnum);

        // Argument validation
        if (QueriedObjectId != GUID_NULL)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid QueriedObjectId");
        if (eQueriedObjectType != VSS_OBJECT_NONE)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eQueriedObjectType");
        if (eReturnedObjectsType != VSS_OBJECT_SNAPSHOT)
            ft.Throw(VSSDBG_COORD, E_INVALIDARG, L"Invalid eReturnedObjectsType");
		BS_ASSERT(ppEnum);
        if (ppEnum == NULL)
            ft.Throw( VSSDBG_SWPRV, E_INVALIDARG, L"NULL ppEnum");

        //
        //  Freeze the context
        //
        FreezeContext();

        // Create the collection object. Initial reference count is 0.
        VSS_OBJECT_PROP_Array* pArray = new VSS_OBJECT_PROP_Array;
        if (pArray == NULL)
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");

        // Get the pointer to the IUnknown interface.
		// The only purpose of this is to use a smart ptr to destroy correctly the array on error.
		// Now pArray's reference count becomes 1 (because of the smart pointer).
        CComPtr<IUnknown> pArrayItf = static_cast<IUnknown*>(pArray);
        BS_ASSERT(pArrayItf);

		// Get the list of snapshots in the give array
		CVssQueuedSnapshot::EnumerateSnapshots( false, GUID_NULL, GetContextInternal(), pArray);

        // Create the enumerator object. Beware that its reference count will be zero.
        CComObject<CVssEnumFromArray>* pEnumObject = NULL;
        ft.hr = CComObject<CVssEnumFromArray>::CreateInstance(&pEnumObject);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_SWPRV, E_OUTOFMEMORY,
                      L"Cannot create enumerator instance. [0x%08lx]", ft.hr);
        BS_ASSERT(pEnumObject);

        // Get the pointer to the IVssEnumObject interface.
		// Now pEnumObject's reference count becomes 1 (because of the smart pointer).
		// So if a throw occurs the enumerator object will be safely destroyed by the smart ptr.
        CComPtr<IUnknown> pUnknown = pEnumObject->GetUnknown();
        BS_ASSERT(pUnknown);

        // Initialize the enumerator object.
		// The array's reference count becomes now 2, because IEnumOnSTLImpl::m_spUnk is also a smart ptr.
        BS_ASSERT(pArray);
		ft.hr = pEnumObject->Init(pArrayItf, *pArray);
        if (ft.HrFailed()) {
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Cannot initialize enumerator instance. [0x%08lx]", ft.hr);
        }

        // Initialize the enumerator object.
		// The enumerator reference count becomes now 2.
        ft.hr = pUnknown->SafeQI(IVssEnumObject, ppEnum);
        if ( ft.HrFailed() ) { 
            BS_ASSERT(false); // dev error
            ft.Throw( VSSDBG_SWPRV, E_UNEXPECTED,
                      L"Error querying the IVssEnumObject interface. hr = 0x%08lx", ft.hr);
        }
        BS_ASSERT(*ppEnum);

		BS_ASSERT( !ft.HrFailed() );
		ft.hr = (pArray->GetSize() != 0)? S_OK: S_FALSE;
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\sqllib\clogmsg.h ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: snapsql.cpp
//
// PURPOSE:
//
//      Implement the SQLServer Volume Snapshot Writer.
//
// NOTES:
//
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     66601 srs  10/05/00 NTSNAP improvements
//
//
// @EndHeader@
// ***************************************************************************

class CLogMsg
	{
public:
	CLogMsg() :
		m_cwc(0),
		m_bEof(false)
		{
		m_rgwc[0] = L'\0';
		}

	LPCWSTR GetMsg()
		{
		return m_rgwc;
		}

	void Add(LPCWSTR wsz)
		{
		if (m_bEof)
			return;

		UINT cwc = (UINT) wcslen(wsz);

		if (cwc + m_cwc + 5 > x_MAX_MSG_SIZE)
			{
			wcscpy(m_rgwc + m_cwc, L" ...");
			m_cwc += 4;
			m_bEof = TRUE;
			}
		else
			{
			wcscpy(m_rgwc + m_cwc, wsz);
			m_cwc += cwc;
			}
		}

private:
	enum
		{
		x_MAX_MSG_SIZE = 2048
		};

    // size of string
    UINT m_cwc;

	// string
	WCHAR m_rgwc[x_MAX_MSG_SIZE];

	// end of string encountered
	bool m_bEof;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\sqllib\stdafx.h ===
#include <memory>

#ifndef __VSS_STDAFX_HXX__
#define __VSS_STDAFX_HXX__

#if _MSC_VER > 1000
#pragma once
#endif

// Disable warning: 'identifier' : identifier was truncated to 'number' characters in the debug information
//#pragma warning(disable:4786)

//
// C4290: C++ Exception Specification ignored
//
#pragma warning(disable:4290)

//
// C4511: copy constructor could not be generated
//
#pragma warning(disable:4511)


//
//  Warning: ATL debugging turned off (BUG 250939)
//
//  #ifdef _DEBUG
//  #define _ATL_DEBUG_INTERFACES
//  #define _ATL_DEBUG_QI
//  #define _ATL_DEBUG_REFCOUNT
//  #endif // _DEBUG


#include <wtypes.h>
#pragma warning( disable: 4201 )    // C4201: nonstandard extension used : nameless struct/union
#include <winioctl.h>
#pragma warning( default: 4201 )	// C4201: nonstandard extension used : nameless struct/union
#include <winbase.h>
#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <errno.h>

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"


#include <oleauto.h>
#include <stddef.h>

#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <atlconv.h>
#include <atlbase.h>

#include <sql.h>
#include <sqlext.h>
#include <sqltypes.h>
#include <odbcss.h>

#include "vs_inc.hxx"

#include "sqlsnap.h"
#include "sqlsnapi.h"
#include <auto.h>
#include "vssmsg.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.cxx | The file used to compile the precompiled header
    @end

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.

--*/


#include "stdafx.hxx"
#include "swprv.hxx"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#pragma warning( disable: 4189 )  /* local variable is initialized but not referenced */
#include <atlimpl.cpp>
#pragma warning( default: 4189 )  /* local variable is initialized but not referenced */

// Define the VOLSNAP_APPINFO_GUID_CLIENT_ACCESSIBLE guid
#include "initguid.h"
#include "ntddsnap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\softprv\src\swprv.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module swprv.hxx | Definition the COM server of the Software Snapshot provider
    @end

Author:

    Adi Oltean  [aoltean]   07/13/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.
    aoltean     09/09/1999  dss->vss

--*/


///////////////////////////////////////////////////////////////////////////////
//   Includes
//


#include "stdafx.hxx"
#include <process.h>
#include "initguid.h"

#include "vs_idl.hxx"

#include "vssmsg.h"
#include "resource.h"
#include "vs_inc.hxx"

#include "swprv.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "provider.hxx"

#include <comadmin.h>
#include "comadmin.hxx"


/////////////////////////////////////////////////////////////////////////////
// Constants



const WCHAR g_wszAppName[]  = L"MS Software Snapshot Provider";
const WCHAR g_wszSvcName[]  = L"SwPrv";
const WCHAR g_wszDllName[]  = L"\\SWPRV.DLL";

const MAX_STRING_RESOURCE_LEN = 1024;

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SPRSWPRC"
//
////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//   Static objects
//

CSwPrvSnapshotSrvModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_VSSoftwareProvider, CVsSoftwareProvider)
END_OBJECT_MAP()


///////////////////////////////////////////////////////////////////////////////////////
//  COM Server registration
//

HRESULT GetDllPathName(
	IN	INT nBufferLength, // Does not include terminating zero character
    IN  LPCWSTR wszDllName,
    OUT LPWSTR wszDllPath
    )
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"GetDllPathName" );

    try
    {
		WCHAR wszDir[MAX_PATH];
        if (!::GetCurrentDirectory(MAX_PATH, wszDir)) {
            ft.LogError(VSS_ERROR_GETTING_CURRENT_DIR, VSSDBG_SWPRV << HRESULT_FROM_WIN32(GetLastError()) );
            ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED,
				L"Error on getting the current path. hr = 0x%08lx",
                HRESULT_FROM_WIN32(GetLastError()));
        }

        if ( ::wcslen(wszDir) +
			 ::wcslen(wszDllName) >= (size_t) nBufferLength )
            ft.Throw(VSSDBG_SWPRV, E_OUTOFMEMORY, L"Out of memory.");

        ::_snwprintf(wszDllPath, nBufferLength,
				L"%s%s", wszDir, wszDllName);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}

void MakeChangeable(bool fChangeable)
	{
	CVssFunctionTracer ft(VSSDBG_SWPRV, L"MakeChangeable");

	CVssCOMAdminCatalog     catalog;
	ft.hr = catalog.Attach(g_wszAppName);
	if (ft.HrFailed())
		ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in initializing the catalog object 0x%08lx", ft.hr);

	// Get the list of applications
	CVssCOMCatalogCollection appsList(VSS_COM_APPLICATIONS);
	ft.hr = appsList.Attach(catalog);
	if (ft.HrFailed())
		ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in initializing the apps collection object 0x%08lx", ft.hr);

	CVssCOMApplication application;
	ft.hr = application.AttachByName( appsList, catalog.GetAppName() );
	if (ft.HrFailed())
		ft.LogError(VSS_ERROR_ATTACH_COLL_BY_NAME, VSSDBG_SWPRV << catalog.GetAppName() << ft.hr);


	// if the application doesn't exist then return
	if (ft.hr == S_FALSE)
		return;

	application.m_bChangeable = fChangeable;
	application.m_bDeleteable = fChangeable;
	ft.hr = appsList.SaveChanges();
	if (ft.HrFailed())
		{
		ft.TraceComError();
		ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in commiting changes. hr = 0x%08lx", ft.hr);
		}
	}

HRESULT RegisterNewCOMApp()
{
    CVssFunctionTracer ft( VSSDBG_SWPRV, L"RegisterNewCOMApp" );

    try
    {
		MakeChangeable(true);
        //
        // Initialize the catalog
        //

        CVssCOMAdminCatalog     catalog;
        ft.hr = catalog.Attach(g_wszAppName);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in initializing the catalog object 0x%08lx", ft.hr);

        //
        //  Create a new application, if doesn't exist yet.
        //

        // Get the list of applications
        CVssCOMCatalogCollection appsList(VSS_COM_APPLICATIONS);
        ft.hr = appsList.Attach(catalog);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in initializing the apps collection object 0x%08lx", ft.hr);

		// Check if the application already exists - to solve the upgrade between different OS versions.
		// If the application doesn't exist then insert a new application
        CVssCOMApplication application;
		ft.hr = application.AttachByName( appsList, catalog.GetAppName() );
		if (ft.HrFailed()) {
            ft.LogError(VSS_ERROR_ATTACH_COLL_BY_NAME, VSSDBG_SWPRV << catalog.GetAppName() << ft.hr);
		}
		
		if (ft.hr == S_OK)
			{
			// the application exits.  delete it
			LONG lIndex = application.GetIndex();
			BS_ASSERT(lIndex != -1);
			ft.hr = appsList.GetInterface()->Remove(lIndex);
			if (ft.HrFailed())
				{
				ft.LogError(VSS_ERROR_REMOVING_APPLICATION, VSSDBG_COORD << catalog.GetAppName() << ft.hr);
				ft.TraceComError();
				ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"Failure to remove eventcls application object 0x %08lx", ft.hr);
				}

			// commit changes
			ft.hr = appsList.SaveChanges();
			if (ft.HrFailed())
				{
                ft.TraceComError();
				ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"Failure in commiting changes. hr = 0x%08lx", ft.hr);
				}
			ft.hr = application.AttachByName( appsList, catalog.GetAppName() );
			if (ft.HrFailed())
				{
				ft.LogError(VSS_ERROR_ATTACH_COLL_BY_NAME, VSSDBG_COORD << catalog.GetAppName() << ft.hr);
				ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"Failure in initializing the apps collection object 0x%08lx", ft.hr);
				}
			}

		// The application doesn't exist.
		ft.hr = application.InsertInto(appsList);
		if (ft.HrFailed())
			ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in creating a new application object 0x%08lx", ft.hr);

		// Set application name
		application.m_bstrName = catalog.GetAppName();

        // Loads the application description
        WCHAR wszBuffer[MAX_STRING_RESOURCE_LEN];
        if (0 == ::LoadStringW(_Module.GetModuleInstance(), 
            IDS_SERVICE_DESCRIPTION, wszBuffer, MAX_STRING_RESOURCE_LEN - 1)) 
        {
            BS_ASSERT(false);
            ft.Throw(VSSDBG_SWPRV, HRESULT_FROM_WIN32(GetLastError()),
    			L"Error on loading the app description. [0x%08lx]", 
    			HRESULT_FROM_WIN32(GetLastError()));
        }

        CComBSTR bstrAppDescription = wszBuffer;
        if ((LPWSTR)bstrAppDescription == NULL)
            ft.Throw(VSSDBG_SWPRV, E_OUTOFMEMORY, L"Memory allocation error.");
		application.m_bstrDescription = bstrAppDescription;
		    
		// Register as Server package
		application.m_lActivation = COMAdminActivationLocal;

		// Commit changes
		ft.hr = appsList.SaveChanges();
		if (ft.HrFailed())
			{
			ft.TraceComError();
			ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Failure in commiting changes. hr = 0x%08lx", ft.hr);
    	    }
		// Make the application a true NT service
//			BS_ASSERT(false);
		ft.hr = catalog.CreateServiceForApplication(g_wszSvcName);
		if (ft.HrFailed())
			{
			BS_ASSERT(false);
			ft.TraceComError();
			ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Error on installing the service. hr = 0x%08lx", ft.hr);
            }

        //
        //  Insert this component into the application
        //

        WCHAR wszFileName[MAX_PATH];
        ft.hr = GetDllPathName(MAX_PATH - 1, g_wszDllName, wszFileName);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Error in getting the DLL path. hr = 0x%08lx", ft.hr);

        // Install the component
        ft.hr = catalog.InstallComponent(wszFileName, NULL, NULL);
        if (ft.HrFailed()) {
            ft.TraceComError();
            ft.Throw(VSSDBG_SWPRV, E_UNEXPECTED, L"Error on install the event class. hr = 0x%08lx", ft.hr);
			}

	    BS_ASSERT(ft.hr != S_FALSE);

		MakeChangeable(false);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



///////////////////////////////////////////////////////////////////////////////
//   DLL Entry point
//

//
// The real DLL Entry Point is _DLLMainCrtStartup (initializes global objects and after that calls DllMain
// this is defined in the runtime libaray
//

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        //  Set the correct tracing context. This is an inproc DLL
        g_cDbgTrace.SetContextNum(VSS_CONTEXT_DELAYED_DLL);

        // Set the proper way for displaying asserts
//        ::VssSetDebugReport(VSS_DBG_TO_DEBUG_CONSOLE);

        //  initialize COM module
        _Module.Init(ObjectMap, hInstance);

        //  optimization
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
//   DLL Exports
//


// Used to determine whether the DLL can be unloaded by OLE
STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}


// DllUnregisterServer - Removes entries from the system registry
STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}


// DllInstall - install the component into the COM+ catalog.
STDAPI DllInstall(	
	IN	BOOL bInstall,
	IN	LPCWSTR /* pszCmdLine */
)
{
	HRESULT hr = S_OK;

	// Registers the COM+ application
	// This will implicitely call DllRegisterServer
	if (bInstall)
		hr = RegisterNewCOMApp();

	return hr;
}

HRESULT APIENTRY IsVolumeSnapshottedByProvider(
        IN VSS_PWSZ pwszVolumeName, 
        OUT BOOL * pbSnapshotsPresent)
{
    CVssFunctionTracer	ft (VSSDBG_SWPRV, L"SWPRV::IsVolumeSnapshottedByProvider");

    UNREFERENCED_PARAMETER(pwszVolumeName);
    UNREFERENCED_PARAMETER(pbSnapshotsPresent);
        
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\sqllib\sqlenum.cpp ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: sqlenum.cpp
//
// PURPOSE:
//
//      Enumerate the sqlservers available on the local node.
//
// NOTES:
//
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     68067 srs  11/06/00 ntsnap fix
//     67026 srs  10/05/00 Server enumeration bugs
//
//
// @EndHeader@
// ***************************************************************************

#ifdef HIDE_WARNINGS
#pragma warning( disable : 4786)
#endif

#include <stdafx.h>
#include <clogmsg.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQLENUMC"
//
////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------
// ODBC error reporter
//
void PrintODBCError
	(
	SQLSMALLINT HandleType,
	SQLHANDLE hHandle,
	CLogMsg &msg
	)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"PrintODBCError");

	INT		i;
	INT		j;
	SDWORD NativeErr;
	INT severity;
	INT msgstate;
	DBUSMALLINT LineNumber;
	WCHAR	szSQLState[SQL_SQLSTATE_SIZE + 1];
	WCHAR   szMsg     [1024 + 1];
	WCHAR   ServerName[SQL_MAX_SQLSERVERNAME + 1];
	WCHAR   ProcName  [SQL_MAX_SQLSERVERNAME + 1];


	if (SQLGetDiagField(
		HandleType,
		hHandle,
		0,
		SQL_DIAG_NUMBER,
		&i,
		sizeof(i),
		NULL) == SQL_ERROR )
	{
		ft.Trace(VSSDBG_SQLLIB, L"SQLGetDiagField failed");
	}
	else
	{
		for (j = 1; j <= i; j++)
		{
			if (SQLGetDiagRecW (
				HandleType,
				hHandle,
				(SQLSMALLINT)j,
				(SQLWCHAR*)szSQLState,	
				&NativeErr,
				(SQLWCHAR*) szMsg,
				sizeof(szMsg) / sizeof(WCHAR),
				NULL) == SQL_ERROR )
			{
				ft.Trace (VSSDBG_SQLLIB, L"SQLGetDiagRec failed");
			}
			else
			{	
				//	Get driver specific diagnostic fields
				//
				if (SQLGetDiagField(
					HandleType,
					hHandle,
					(SQLSMALLINT)j,
					SQL_DIAG_SS_MSGSTATE,
					&msgstate,
					SQL_IS_INTEGER,
					NULL) == SQL_ERROR )
				{
					msgstate = 0;
				}

				if (SQLGetDiagField(
					HandleType,
					hHandle,
					(SQLSMALLINT)j,
					SQL_DIAG_SS_SEVERITY,
					&severity,
					SQL_IS_INTEGER,
					NULL) == SQL_ERROR )
				{
					severity = 0;
				}

				if (SQLGetDiagField(
					HandleType,
					hHandle,
					(SQLSMALLINT)j,
					SQL_DIAG_SS_SRVNAME,
					&ServerName,
					sizeof(ServerName),
					NULL) == SQL_ERROR )
				{
					ServerName[0] = L'\0';
				}

				if (SQLGetDiagField(
					HandleType,
					hHandle,
					(SQLSMALLINT)j,
					SQL_DIAG_SS_PROCNAME,
					&ProcName,
					sizeof(ProcName),
					NULL) == SQL_ERROR )
				{
					ProcName[0] = L'\0';
				}

				if (SQLGetDiagField(
					HandleType,
					hHandle,
					(SQLSMALLINT)j,
					SQL_DIAG_SS_LINE,
					&LineNumber,
					SQL_IS_SMALLINT,
					NULL) == SQL_ERROR )
				{
					LineNumber = 0;
				}

				ft.Trace
					(
					VSSDBG_SQLLIB,
					L"ODBC Error: Msg %d, SevLevel %d, State %d, SQLState %s\n%s\n",
                    NativeErr,
                    severity,
                    msgstate,
                    szSQLState,
					szMsg
					);

            WCHAR buf[80];
			swprintf(buf, L"Error: %d, Severity: %d, State: %d, SQLState: ", NativeErr, severity, msgstate);
			msg.Add(buf);
            msg.Add(szSQLState);
			msg.Add(L"\n ProcName: ");
			msg.Add(ProcName);
			swprintf(buf, L", Line Number: %d, ServerName: ", LineNumber);
			msg.Add(buf);
			msg.Add(L"\n");
			msg.Add(szMsg);
			}
		} // for( j = 1; j <= i; j++ )
	}
}

//------------------------------------------------------------
// Scanner to locate servernames in a "BrowseConnect" string.
//
class BrowseServers
{
public:
	const WCHAR* FindFirst (const WCHAR* source, unsigned* nameLen);
	const WCHAR* FindNext (unsigned* nameLen);

private:
	const WCHAR*	m_CurrChar;
};

const WCHAR*
BrowseServers::FindFirst (const WCHAR *source, unsigned* nameLen)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"BrowseServers::FindFirst");

	const WCHAR*	pChar;
	const WCHAR		Prefix[] = L"Server={";

	m_CurrChar = NULL;
	if (source == NULL)
		return NULL;

	pChar = wcsstr (source, Prefix);
	if (pChar == NULL)
		return NULL;

	m_CurrChar = pChar + wcslen (Prefix);

	if (*m_CurrChar == L'}')
	{
		// The server list is empty
		//
		m_CurrChar = NULL;
		return NULL;
	}

	if (nameLen)
	{
		*nameLen = wcscspn (m_CurrChar, L",;}");
	}
	return m_CurrChar;
}

const WCHAR*
BrowseServers::FindNext (unsigned* nameLen)
{
	const WCHAR*	pChar;

	if (m_CurrChar == NULL)
		return NULL;

	pChar = wcschr (m_CurrChar, L',');
	if (pChar == NULL)
	{
		m_CurrChar = NULL;
		return NULL;
	}
	m_CurrChar = pChar + 1;
	if (nameLen)
	{
		*nameLen = wcscspn (m_CurrChar, L",;}");
	}
	return m_CurrChar;
}

//------------------------------------------------------------------------
// Return true if we could fetch the version of the SQLServer ODBC driver
//
bool
GetSQLDriverVersion (int* major, int* minor)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"GetSQLDriverVersion");

	DWORD	status;
	HKEY	hKey;
	WCHAR	driver[MAX_PATH+1];
    DWORD	vType;
    DWORD	pathLen = MAX_PATH;

    status = RegOpenKeyExW (
        HKEY_LOCAL_MACHINE,
        L"Software\\ODBC\\ODBCINST.INI\\SQL Server",
        0,
        KEY_QUERY_VALUE,
        &hKey);

    if (status != ERROR_SUCCESS)
    {
		ft.Trace (VSSDBG_SQLLIB, L"SQL not installed. Regkey status %d", status);
		return false;
	}

    status = (DWORD) RegQueryValueExW (
        hKey,
        L"Driver",
        NULL,
        &vType,
        (BYTE*)driver,
        &pathLen);

    RegCloseKey (hKey);

    if (status != ERROR_SUCCESS)
    {
		ft.Trace(VSSDBG_SQLLIB, L"SQL Driver installed wrong: %d\n", status);
		return false;
	}

	char	versionInfo [4096];

	if (!GetFileVersionInfoW (driver, 0, 4096, versionInfo))
	{
		ft.Trace(VSSDBG_SQLLIB, L"SQL Driver version not found: %d", GetLastError ());
		return false;
	}

	VS_FIXEDFILEINFO*   pInfo;
	UINT				infoSize;
	if (!VerQueryValueW (versionInfo, L"\\", (LPVOID*)&pInfo, &infoSize))
	{
		ft.Trace(VSSDBG_SQLLIB, L"version info resource not found: %d", GetLastError ());
		return false;
	}
	
	*major = pInfo->dwFileVersionMS >> 16;
	*minor = pInfo->dwFileVersionMS & 0x0FFFF;
	return true;
}

//------------------------------------------------------------------------
// Build the list of servers on the current machine.
// Throws exception if any errors occur.
//
StringVector*
EnumerateServers ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"EnumerateServers");

	SQLHENV		henv			= SQL_NULL_HANDLE;
	SQLHDBC		hdbc			= SQL_NULL_HANDLE;
	RETCODE		rc;
	LPWSTR		lpBuffer		= NULL;
	StringVector*	serverList = new StringVector;
	CLogMsg msg;


	int major, minor;
	if (!GetSQLDriverVersion (&major, &minor))
	{
		// SQL isn't installed right, so just ignore it, return empty list.
		//
		return serverList;
	}
	if (major < 2000)
	{
		// Require the modern MDAC to give a proper enumeration.
		//
		ft.LogError(VSS_ERROR_SQLLIB_UNSUPPORTEDMDAC, VSSDBG_SQLLIB << major << minor);
		throw HRESULT (E_SQLLIB_NO_SUPPORT);

		// ORIGINAL CODE:
		// May have a 6.5 or 7.0 server.  We aren't sure, but the
		// caller can determine if the server is up itself.
		//
		//serverList->push_back (L"(local)");
		//return serverList;
	}

	// SQL2000 or better
	//
	try
	{
		if (SQLAllocHandle(SQL_HANDLE_ENV, NULL, &henv) == SQL_ERROR)
		{
			ft.LogError(VSS_ERROR_SQLLIB_SQLAllocHandle_FAILED, VSSDBG_SQLLIB);
			THROW_GENERIC;
		}

		rc = SQLSetEnvAttr(
			henv,
			SQL_ATTR_ODBC_VERSION,
			(SQLPOINTER)SQL_OV_ODBC3,
			0);

		if (rc != SQL_SUCCESS)
		{
			PrintODBCError(SQL_HANDLE_ENV, henv, msg);
			if (rc == SQL_ERROR)
			{
				ft.LogError(VSS_ERROR_SQLLIB_ODBC_ERROR, VSSDBG_SQLLIB << L"SQLSetEnvAttr" << msg.GetMsg());
				THROW_GENERIC;
			}
		}

		rc = SQLSetEnvAttr(
			henv,
			SQL_ATTR_CONNECTION_POOLING,
			(SQLPOINTER)SQL_CP_OFF,
			0);
		if (rc != SQL_SUCCESS)
		{
			PrintODBCError(SQL_HANDLE_ENV, henv, msg);
			if (rc == SQL_ERROR)
			{
				ft.LogError(VSS_ERROR_SQLLIB_ODBC_ERROR, VSSDBG_SQLLIB << L"SQLSetEnvAttr" << msg.GetMsg());
				THROW_GENERIC;
			}
		}

		rc = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);
		if (rc != SQL_SUCCESS)
		{
			PrintODBCError(SQL_HANDLE_ENV, henv, msg);
			if (rc == SQL_ERROR)
			{
				ft.LogError(VSS_ERROR_SQLLIB_ODBC_ERROR, VSSDBG_SQLLIB << L"SQLSetAllocHandle" << msg.GetMsg());
				THROW_GENERIC;
			}
		}

		// Note: older versions of sqlsvr32 don't support
		// these connect attributes, but the failure to
		// recognize them isn't detected until the actual
		// SQLBrowseConnect call.  For old sqlsrv32, the
		// "list of servers" performs a domain search!
		//

		rc = SQLSetConnectAttr (
			hdbc,
			SQL_COPT_SS_BROWSE_CONNECT,
			(SQLPOINTER)SQL_MORE_INFO_YES,
			SQL_IS_UINTEGER);

		if (rc != SQL_SUCCESS)
		{
			PrintODBCError(SQL_HANDLE_DBC, hdbc, msg);
			if (rc == SQL_ERROR)
			{
				ft.LogError(VSS_ERROR_SQLLIB_ODBC_ERROR, VSSDBG_SQLLIB << L"SQLSetConnectAttr" << msg.GetMsg());
				THROW_GENERIC;
			}
		}

		rc = SQLSetConnectAttrW (
			hdbc,
			SQL_COPT_SS_BROWSE_SERVER,
			(SQLPOINTER)L"(local)",
			SQL_NTS);

		if (rc != SQL_SUCCESS)
		{
			PrintODBCError(SQL_HANDLE_DBC, hdbc, msg);
			if (rc == SQL_ERROR)
			{
				ft.LogError(VSS_ERROR_SQLLIB_ODBC_ERROR, VSSDBG_SQLLIB << L"SQLSetConnectAttr" << msg.GetMsg());
				THROW_GENERIC;
			}
		}

		// We use the maximum buffer supported in ODBC.
		//
		#define MAX_BUFFER 0x7ff0
		lpBuffer = new WCHAR [MAX_BUFFER];
		SQLSMALLINT browseLen;

		rc = SQLBrowseConnectW (
			hdbc,
			L"Driver={SQL Server}",
			SQL_NTS,
			lpBuffer,
			MAX_BUFFER,
			&browseLen);

		//ft.Trace(VSSDBG_SQLLIB, L"browse connect rc: %d", rc);

		if (rc != SQL_NEED_DATA)
		{
			PrintODBCError(SQL_HANDLE_DBC, hdbc, msg);

			if (rc == SQL_ERROR)
			{
				ft.LogError(VSS_ERROR_SQLLIB_ODBC_ERROR, VSSDBG_SQLLIB << L"SQLSetConnectAttr" << msg.GetMsg());
				THROW_GENERIC;
			}
		}

		// check for SQL6.5 in any of the servers
		//
		WCHAR	*pVersion = lpBuffer;
		int srvVer;
		while (1)
		{
			pVersion = wcsstr (pVersion, L";Version:");
			if (!pVersion)
				break;

			pVersion += 9;
			srvVer = 0;
			swscanf (pVersion, L"%u", &srvVer);
			if (srvVer < 7)
			{
				ft.LogError(VSS_ERROR_SQLLIB_UNSUPPORTEDSQLSERVER, VSSDBG_SQLLIB << srvVer);
				throw HRESULT (E_SQLLIB_NO_SUPPORT);
			}
		}

		//ft.Trace(VSSDBG_SQLLIB, L"BrowseResult:%s", lpBuffer);

		// Scan to count the servers
		//
		BrowseServers	scanner;
		if (NULL == scanner.FindFirst (lpBuffer, NULL))
		{
			ft.Trace(VSSDBG_SQLLIB, L"No servers found!\n");
		}
		else
		{
			unsigned		i,nameLen;
			const WCHAR*	pServerName;
			unsigned int	cServers = 1;

			while (scanner.FindNext (NULL) != NULL)
			{
				cServers++;
			}

			serverList->reserve (cServers);

			pServerName = scanner.FindFirst (lpBuffer, &nameLen);
			serverList->push_back (std::wstring (pServerName, nameLen));

			i = 1;
			while (i < cServers)
			{
				pServerName = scanner.FindNext (&nameLen);
				serverList->push_back (std::wstring (pServerName, nameLen));
				i++;
			}
		}

		if (lpBuffer)
		{
			delete [] lpBuffer;
		}

		if (hdbc)
		{
			SQLDisconnect(hdbc);
			SQLFreeHandle(SQL_HANDLE_DBC, hdbc);
		}

		if (henv)
		{
			SQLFreeHandle(SQL_HANDLE_ENV, henv);
		}
	}
	catch (...)
	{
		if (lpBuffer)
		{
			delete [] lpBuffer;
		}

		if (hdbc)
		{
			SQLDisconnect(hdbc);
			SQLFreeHandle(SQL_HANDLE_DBC, hdbc);
		}

		if (henv)
		{
			SQLFreeHandle(SQL_HANDLE_ENV, henv);
		}

		delete serverList;

		throw;
	}

	return serverList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\sqllib\auto.h ===
//--------------------------------------------------------------------
// Microsoft DART Utilities
//
// Copyright 1994 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module auto.h | Definition of <c CAutoRg> and <c CAutoP>
//
// @devnote None
//
// @rev   0 | 24-Oct-94 | matthewb	| Created
// @rev   1 | 01-May-95 | rossbu	| Updated and consolidated interface
// @rev   2 | 23-May-95 | eugenez	| Added support for TaskAlloc'ed pointers
//

extern IMalloc * g_pIMalloc;

//--------------------------------------------------------------------
//
// @class CAutoBase | This template class is a base class, used to give dynamic memory
// local (auto) scope within a function.  For instance a large character
// buffer can be allocated from a memory object, but be cleanup up as if were
// allocated on the stack.	An additional feature is the ability to
// 'unhook' the object from the local scope using the PvReturn().  For
// instance, you may want to return a  newly allocated object to the
// caller, but still have the benefit of error clean up any error
// scenario.  <c CAutoRg> is a derived class which cleans up arrays allocated
// with new[].	<c CAutoP> is an analagous but works for single objects
// rather than arrays (allocated with new).
//
// @tcarg class | T | Type of auto object
//
// @ex This declaration would allocate a 100 char buffer from pmem, and
// automatically free the buffer when rgbBuf goes out of scope. |
//
//	CAutoRg<lt>char<gt> rgbBuf(New(pmem) char[100]);
//
// @xref <c CAutoRg>
//
// @ex This CAutoP example allocates a CFoo object and returns it if there
// are no errors. |
//
//	/* inilize pfoo */
//	CAutoP<lt>CFoo<gt> pfoo(New(pmem) CFoo);
//	/* do stuff */
//	/* call pfoo methods */
//	pfoo->Bar();
//	/* return w/o destroying foo */
//	return pfoo .PvReturn;
//
// @xref <c CAutoP>
//

// ************************ CAutoBase - base class for all AutoPointers *****************************

template <class T>
class CAutoBase
	{
public:		// @access public
	inline CAutoBase(T* pt);
	inline ~CAutoBase();

	inline T* operator= (T*);
	inline operator T* (void);
	inline operator const T* (void)const;
	inline T ** operator & (void);
	inline T* PvReturn(void);

protected:	// @access protected
	T* m_pt;

private:	// Never-to-use
	inline CAutoBase& operator= (CAutoBase&);
	CAutoBase(CAutoBase&);
	};

//--------------------------------------------------------------------
// @mfunc Create a CAutoBase giving the array of objects pointed to by pt
// auto scope.
// @side Allows NULL to be passed in
// @rdesc None

template <class T>
inline CAutoBase<T>::CAutoBase(T *pt)
	{
	m_pt = pt;
	}

//--------------------------------------------------------------------
// @mfunc CAutoBase destructor.  Asserts that the object has been free'd
// 	(set to NULL).	Setting to NULL does not happen in the retail build
// @side None
// @rdesc None
//

template <class T>
inline CAutoBase<T>::~CAutoBase()
	{
//	_ASSERT(NULL == m_pt);
	}

//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL
// @side None
// @rdesc None
//
// @ex Assign CAutoBase variable after construction. |
//
//		CAutoBase<lt>char<gt>	rgb;
//		/* ... */
//		rgb(NewG char[100]);
//

template <class T>
inline T* CAutoBase<T>::operator=(T* pt)
	{
	_ASSERT(m_pt == NULL);
	m_pt = pt;
	return pt;
	}

//--------------------------------------------------------------------
// @mfunc Cast operator used to "unwrap" the pointed object
// as if the CAutoBase variable were a pointer of type T.
// In many situations this is enough for an autopointer to
// look exactly like an ordinary pointer.
// @side None
// @rdesc None
//

template <class T>
inline CAutoBase<T>::operator T*(void)
	{
	return m_pt;
	}

template <class T>
inline CAutoBase<T>::operator const T*(void)const
	{
	return m_pt;
	}

//--------------------------------------------------------------------
// @mfunc Address-of operator is used to make the autopointer even more
//	similar to an ordinary pointer. When you take an address of an
//	autopointer, you actually get an address of the wrapped
//	pointer.
// @side None
// @rdesc None

template <class T>
inline T ** CAutoBase<T>::operator & ()
	{
	return & m_pt;
	}

//--------------------------------------------------------------------
// @mfunc Returns the object(s) pointed to by the CAutoBase variable.
// In addition this method 'unhooks' the object(s), such that
// the scope of the object(s) are no longer local.
//
// See <c CAutoBase> for an example.
// @side None
// @rdesc None
//

template <class T>
inline T * CAutoBase<T>::PvReturn(void)
	{
	T *ptT = m_pt;
	m_pt = NULL;
	return ptT;
	}



//************************* CAutoRg - autopointers to arrays ******************************

//--------------------------------------------------------------------
// @class This derived class is primarily used to implement the
//	vector deleting destructor.  Should only be used on objects allocated
//	with new[]
//

template <class T>
class CAutoRg :
	public CAutoBase<T>
	{
public:		// @access public
	inline CAutoRg(T *pt);
	inline ~CAutoRg();

	inline T* operator= (T*);

private:	// Never-to-use
	inline CAutoRg& operator= (CAutoRg&);
	CAutoRg(CAutoRg&);
	};

//--------------------------------------------------------------------
// @mfunc Create a CAutoRg giving the array of objects pointed to by pt
// auto scope.
// @side Allows NULL to be passed in
// @rdesc None

template <class T>
inline CAutoRg<T>::CAutoRg(T *pt)
	: CAutoBase<T>(pt)
	{
	}

//--------------------------------------------------------------------
// @mfunc CAutoRg destructor.  When an object of class CAutoRg goes out
// of scope, free the associated object (if any).
// @side calls the vector delete method
// @rdesc None
//

template <class T>
inline CAutoRg<T>::~CAutoRg()
	{
	delete [] m_pt;
	}


//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL
// @side None
// @rdesc None
//
// @ex Assign CAutoRg variable after construction. |
//
//		CAutoRg<lt>char<gt>	rgb;
//		/* ... */
//		rgb(NewG char[100]);
//

template <class T>
inline T* CAutoRg<T>::operator=(T* pt)
	{
	return ((CAutoBase<T> *) this)->operator= (pt);
	}

//*************************** CAutoP - autopointers to scalars **************

//--------------------------------------------------------------------
// @class This is analagous to <c CAutoRg> but calls scalar delete
//	of an object rather than arrays.
//
// @xref <c CAutoRg>

template <class T>
class CAutoP :
	public CAutoBase<T>
	{
public: 	// @access public
	inline CAutoP(T *pt);
	inline ~CAutoP();
	inline T* operator= (T*);
	inline T* operator->(void);

private:	// Never-to-use
	inline CAutoP& operator= (CAutoP&);
	CAutoP(CAutoP&);
	};


//--------------------------------------------------------------------
// @mfunc Create a CAutoP giving the object pointed to by pt
// auto scope.
// @side Allows NULL to be passed in
// @rdesc None

template <class T>
inline CAutoP<T>::CAutoP(T *pt)
	: CAutoBase<T>(pt)
	{
	}

//--------------------------------------------------------------------
// @mfunc Delete the object pointed by CAutoP variable if any.
// @side None
// @rdesc None
//

template <class T>
inline CAutoP<T>::~CAutoP()
	{
	delete m_pt;
	}


//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL.
//		  Assign operator is not inherited, so it has to be written
//		again. Just calls base class assignment.
// @side None
// @rdesc None
//

template <class T>
inline T* CAutoP<T>::operator=(T* pt)
	{
	return ((CAutoBase<T> *) this)->operator= (pt);
	}

//--------------------------------------------------------------------
// @mfunc The 'follow' operator on the CAutoP allows an CAutoP variable
// to act like a pointer of type T.  This overloading generally makes using
// a CAutoP simple as using a regular T pointer.
//
// See <c CAutoRg> example.
// @side None
// @rdesc None

template <class T>
inline T * CAutoP<T>::operator->()
	{
	_ASSERT(m_pt != NULL);
	return m_pt;
	}


//******************** CAutoTask - autopointers to TaskAlloc'ed memory ***************

//--------------------------------------------------------------------
// @class CAutoTask is an autopointer to an area allocated using TaskAlloc.
//	May be used for scalars or vectors alike, but beware: object destructors
//	are not called by the autopointer, just the memory gets released.
//

template <class T>
class CAutoTask :
	public CAutoBase<T>
	{
public: 	// @access public
	inline CAutoTask (T *pt);
	inline ~CAutoTask ();
	inline T* operator= (T*);

private:	// Never-to-use
	inline CAutoTask& operator= (CAutoTask&);
	CAutoTask(CAutoTask&);
	};


//--------------------------------------------------------------------
// @mfunc Constructor simply calls the constructor for CAutoBase<lt>T<gt>.
// @side None
// @rdesc None

template <class T>
inline CAutoTask<T>::CAutoTask(T *pt)
	: CAutoBase<T>(pt)
	{
	}

//--------------------------------------------------------------------
// @mfunc Free the memory pointed to by CAutoTask variable.
// @side None
// @rdesc None
//

template <class T>
inline CAutoTask<T>::~CAutoTask()
	{
	if (m_pt)
		g_pIMalloc->Free(m_pt);

	}


//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL.
//		  Assign operator is not inherited, so it has to be written
//		again. Just calls base class assignment.
// @side None
// @rdesc None
//

template <class T>
inline T* CAutoTask<T>::operator=(T* pt)
	{
	return ((CAutoBase<T> *) this)->operator= (pt);
	}

//************************* CAutoUnivRg - universal autopointers to arrays ******************************

//--------------------------------------------------------------------
// @class CAutoUnivRg and CAutoUnivP are "universal" autopointer classes.
//	They can handle those rare occasions when the "auto-scoped" pointer
//	might have been allocated by either New or TaskAlloc, depending on
//	the circumstances. You have to always know however just how it was
//	allocated this time, and pass this knowledge to the CAutoUniv object
//	at construction time.
//
//	CAutoUniv objects have the additional construction parameter of type
//	BOOL. It is used in fact as a BOOL flag: TRUE means that the
//	pointer is allocated by TaskAlloc, and FALSE means NewG.
//

template <class T>
class CAutoUnivRg :
	public CAutoRg<T>
	{
public:		// @access public
	inline CAutoUnivRg (T *pt, BOOL fIsTaskAlloc);
	inline ~CAutoUnivRg ();

	inline T* operator= (T*);

private:
	BOOL m_fTaskAlloc;

private:	// Never-to-use
	inline CAutoUnivRg& operator= (CAutoUnivRg&);
	CAutoUnivRg(CAutoUnivRg&);
	};

//--------------------------------------------------------------------
// @mfunc Create a CAutoUnivRg giving the array of objects pointed to by pt
// auto scope. Takes a pointer to a memory object, NULL indicates global
// IMalloc (not a global memory object!).
// @side Allows NULL to be passed in
// @rdesc None

template <class T>
inline CAutoUnivRg<T>::CAutoUnivRg (T *pt, BOOL fIsTaskAlloc)
	: CAutoRg<T>(pt)
	{
	m_fTaskAlloc = fIsTaskAlloc;
	}

//--------------------------------------------------------------------
// @mfunc CAutoUnivRg destructor.  When an object of class CAutoUnivRg goes out
// of scope, free the associated object (if any).
// @side calls the vector delete method
// @rdesc None
//

template <class T>
inline CAutoUnivRg<T>::~CAutoUnivRg()
	{
	if (m_fTaskAlloc)
		{
		// m_pt->~T();	// Awaits VC++ 3.0...
		g_pIMalloc->Free(m_pt);
		}
	else
		delete [] m_pt;

	}


//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL
// @side None
// @rdesc None
//

template <class T>
inline T* CAutoUnivRg<T>::operator=(T* pt)
	{
	return ((CAutoBase<T> *) this)->operator= (pt);
	}

//*************************** CAutoUnivP - universal autopointers to scalars **************

//--------------------------------------------------------------------
// @class This is analagous to <c CAutoUnivRg> but calls scalar delete
//	of an object rather than arrays.
//

template <class T>
class CAutoUnivP :
	public CAutoP<T>
	{
public: 	// @access public
	inline CAutoUnivP(T *pt, BOOL fIsTaskAlloc);
	inline ~CAutoUnivP();
	inline T* operator= (T*);
	inline T* operator->(void);

private:
	BOOL m_fTaskAlloc;

private:	// Never-to-use
	inline CAutoUnivP& operator= (CAutoUnivP&);
	CAutoUnivP(CAutoUnivP&);
	};


//--------------------------------------------------------------------
// @mfunc Constructor
// @side None
// @rdesc None

template <class T>
inline CAutoUnivP<T>::CAutoUnivP(T *pt, BOOL fIsTaskAlloc)
	: CAutoBase<T>(pt)
	{
	m_fTaskAlloc = fIsTaskAlloc;
	}


//--------------------------------------------------------------------
// @mfunc Delete the object pointed by CAutoUnivP variable if any.
// @side None
// @rdesc None
//

template <class T>
inline CAutoUnivP<T>::~CAutoUnivP()
	{
	if (m_fTaskAlloc)
		{
		// m_pt->~T();	// Awaits VC++ 3.0...
		g_pIMalloc->Free(m_pt);
		}
	else
		delete m_pt;

	}


//--------------------------------------------------------------------
// @mfunc Assigns to variable after construction.  May be dangerous
//		so it assert's that the variable is NULL.
//		  Assign operator is not inherited, so it has to be written
//		again. Just calls base class assignment.
// @side None
// @rdesc None
//

template <class T>
inline T* CAutoUnivP<T>::operator=(T* pt)
	{
	return ((CAutoBase<T> *) this)->operator= (pt);
	}

//--------------------------------------------------------------------
// @mfunc The 'follow' operator on the CAutoUnivP allows an CAutoUnivP variable
// to act like a pointer of type T.  This overloading generally makes using
// a CAutoUnivP simple as using a regular T pointer.
//
// @side None
// @rdesc None

template <class T>
inline T * CAutoUnivP<T>::operator->()
	{
	_ASSERT(m_pt != NULL);
	return m_pt;
	}


//------------------------------------------------------------------
// @class auto handle class
//
class CAutoHandle
	{
public:
	// @cmember constructor
	inline CAutoHandle(HANDLE h) : m_handle(h)
		{
		}

	inline CAutoHandle() :
		m_handle(INVALID_HANDLE_VALUE)
		{
		}

	// @cmember destructor
	inline ~CAutoHandle()
		{
		if (m_handle != INVALID_HANDLE_VALUE)
			CloseHandle(m_handle);
		}

	// coercion to handle value
	inline operator HANDLE (void)
		{
		return m_handle;
		}

	inline HANDLE PvReturn(void)
		{
		HANDLE h = m_handle;
		m_handle = INVALID_HANDLE_VALUE;
		return h;
		}

private:

	// @cmember handle value
	HANDLE m_handle;
	};


//----------------------------------------------------------------------
// @class auto class for registry keys
//
class CAutoHKEY
	{
public:
	// @cmember constructor
	inline CAutoHKEY(HKEY hkey) : m_hkey(hkey)
		{
		}

	// @cmember destructor
	inline ~CAutoHKEY()
		{
		if (m_hkey != NULL)
			RegCloseKey(m_hkey);
		}

	inline operator HKEY(void)
		{
		return m_hkey;
		}

	inline HKEY PvReturn(void)
		{
		HKEY hkey = m_hkey;

		m_hkey = NULL;
		return hkey;
		}
private:
	HKEY m_hkey;
	};


//------------------------------------------------------------------
// @class automatically unmap view of file on function exit
//
class CAutoUnmapViewOfFile
	{
public:
	// @cmember constructor
	inline CAutoUnmapViewOfFile(PVOID pv) : m_pv(pv)
		{
		}

	// @cmember destructor
	inline ~CAutoUnmapViewOfFile()
		{
		if (m_pv != NULL)
			UnmapViewOfFile(m_pv);
		}

	// @cmember indicate that region should not be unmapped by destructor
	inline PVOID PvReturn()
		{
		PVOID pv = m_pv;
		m_pv = NULL;
		return pv;
		}

private:
	// @cmember handle value
	PVOID m_pv;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\sqllib\inc\vdierror.h ===
#ifndef VDIERROR_H_
#define VDIERROR_H_
//****************************************************************************
//		Copyright (c) 1998-2000 Microsoft Corporation.
//
// @File: vdierror.h
//
// Purpose:
//  Declare the error codes emitted by the virtual device interface.
//
// Notes:
//	
// History:
//     
//
// @EndHeader@
//****************************************************************************

//
// Define all the VDI errors.
//


//---------------------------------------------------------------------------------------
// Error code handling will be done in standard COM fashion:
//
// an HRESULT is returned and the caller can use
// SUCCEEDED(code) or FAILED(code) to determine
// if the function failed or not.
//

// form an error code
//
#define VD_ERROR(code) MAKE_HRESULT(SEVERITY_ERROR, 0x77, code)

// The object was not open
//
#define VD_E_NOTOPEN        VD_ERROR( 2 )   /* 0x80770002 */

// The api was waiting and the timeout interval had elapsed.
//
#define VD_E_TIMEOUT        VD_ERROR( 3 )   /* 0x80770003 */

// An abort request is preventing anything except termination actions.
//
#define VD_E_ABORT          VD_ERROR( 4 )   /* 0x80770004 */

// Failed to create security environment.
//
#define VD_E_SECURITY		VD_ERROR( 5 )   /* 0x80770005 */

// An invalid parameter was supplied
//
#define VD_E_INVALID        VD_ERROR( 6 )   /* 0x80770006 */

// Failed to recognize the SQL Server instance name
//
#define VD_E_INSTANCE_NAME  VD_ERROR( 7 )   /* 0x80770007 */

// The requested configuration is invalid
#define VD_E_NOTSUPPORTED   VD_ERROR( 9 )   /* 0x80770009 */

// Out of memory
#define VD_E_MEMORY         VD_ERROR( 10 )  /* 0x8077000a */

// Unexpected internal error
#define VD_E_UNEXPECTED     VD_ERROR (11)   /* 0x8077000b */

// Protocol error
#define VD_E_PROTOCOL       VD_ERROR (12)   /* 0x8077000c */

// All devices are open
#define VD_E_OPEN           VD_ERROR (13)   /* 0x8077000d */

// the object is now closed
#define VD_E_CLOSE          VD_ERROR (14)   /* 0x8077000e */

// the resource is busy
#define VD_E_BUSY           VD_ERROR (15)   /* 0x8077000f */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\sqllib\inc\vdiguid.h ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Jun 30 16:43:31 1999
 */
/* Compiler settings for vdi.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IClientVirtualDevice = {0x40700424,0x0080,0x11d2,{0x85,0x1f,0x00,0xc0,0x4f,0xc2,0x17,0x59}};


const IID IID_IClientVirtualDeviceSet = {0x40700425,0x0080,0x11d2,{0x85,0x1f,0x00,0xc0,0x4f,0xc2,0x17,0x59}};


const IID IID_IClientVirtualDeviceSet2 = {0xd0e6eb07,0x7a62,0x11d2,{0x85,0x73,0x00,0xc0,0x4f,0xc2,0x17,0x59}};


const IID IID_IServerVirtualDevice = {0xb5e7a131,0xa7bd,0x11d1,{0x84,0xc2,0x00,0xc0,0x4f,0xc2,0x17,0x59}};


const IID IID_IServerVirtualDeviceSet = {0xb5e7a132,0xa7bd,0x11d1,{0x84,0xc2,0x00,0xc0,0x4f,0xc2,0x17,0x59}};


const IID IID_IServerVirtualDeviceSet2 = {0xAECBD0D6,0x24C6,0x11d3,{0x85,0xB7,0x00,0xC0,0x4F,0xC2,0x17,0x59}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\sqllib\vdifreeze.cpp ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: vdifreeze.cpp
//
// PURPOSE:
//
//		Use a coordinated VDI BACKUP WITH SNAPSHOT (SQL2000 and above)
//
// NOTES:
//		The VDI method of freeze/thaw avoids the potential resource deadlock
//	which prevents SQLServer from accepting a "dbcc thaw_io" when one or more
//  databases is frozen.
//
// Extern dependencies:
//   provision of "_Module" and the COM guids....
//
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     68202      11/07/00 ntsnap work
//
//
// @EndHeader@
// ***************************************************************************


#if HIDE_WARNINGS
#pragma warning( disable : 4786)
#endif

#include <stdafx.h>

#include "vdierror.h"
#include "vdiguid.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQLVFRZC"
//
////////////////////////////////////////////////////////////////////////

Freeze2000::Freeze2000 (
	const WString&	serverName,
	ULONG			maxDatabases) :
		m_ServerName (serverName),
		m_MaxDatabases (maxDatabases),
		m_NumDatabases (0),
		m_State (Unprepared),
		m_AbortCount (0)
{
	CVssFunctionTracer(VSSDBG_SQLLIB, L"Freeze2000::Freeze2000");

	m_pDBContext = new FrozenDatabase [maxDatabases];
	CoCreateGuid (&m_BackupId);
	try
		{
		InitializeCriticalSection (&m_Latch);
		}
	catch(...)
		{
		// delete created object if we fail InitializeCriticalSection
		delete m_pDBContext;
		}
}


//----------------------------------------------------------
// Wait for all the database threads to terminate.
// This is only called by the coordinating thread while
// holding exclusive access on the object.
//
void
Freeze2000::WaitForThreads ()
{
	CVssFunctionTracer(VSSDBG_SQLLIB, L"Freeze2000::WaitForThreads");

	for (int i=0; i<m_NumDatabases; i++)
	{
		FrozenDatabase* pDb = m_pDBContext+i;
		if (pDb->m_hThread != NULL)
		{
			DWORD	status;
			do
			{
				status = WaitForSingleObjectEx (pDb->m_hThread, 2000, TRUE);

				if (m_State != Aborted && CheckAbort ())
					Abort ();

			} while (status != WAIT_OBJECT_0);

			CloseHandle (pDb->m_hThread);
			pDb->m_hThread = NULL;
		}
	}
}

//---------------------------------------------------------
// Handle an abort.
// The main thread will already hold the the lock and so
// will always be successful at aborting the operation.
// The database threads will attempt to abort, but won't
// block in order to do so.  The abort count is incremented
// and the main thread is ulimately responsible for cleanup.
//
void
Freeze2000::Abort () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Freeze2000::Abort");

	SetAbort ();	
	if (TryLock ())
	{
		m_State = Aborted;
		for (int i=0; i<m_NumDatabases; i++)
		{
			if (m_pDBContext[i].m_pIVDSet)
			{
				m_pDBContext[i].m_pIVDSet->SignalAbort ();
				m_pDBContext[i].m_pIVDSet->Close ();
				m_pDBContext[i].m_pIVDSet->Release ();
				m_pDBContext[i].m_pIVDSet = NULL;
				m_pDBContext[i].m_pIVD = NULL;
			}
		}
		Unlock ();
	}
}

Freeze2000::~Freeze2000 ()
{
	Lock ();

	if (m_State != Complete)
	{
		// Trigger any waiting threads, cleaning up any VDI's.
		//
		Abort ();

		WaitForThreads ();
	}

	delete[] m_pDBContext;
	DeleteCriticalSection (&m_Latch);
}

//-------------------------------------------
// Map the voids and proc call stuff to the real
// thread routine.
//
DWORD WINAPI FreezeThreadProc(
  LPVOID lpParameter )  // thread data
{
	return Freeze2000::DatabaseThreadStart (lpParameter);
}

DWORD Freeze2000::DatabaseThreadStart (
  LPVOID lpParameter )  // thread data
{
	FrozenDatabase*	pDbContext = (FrozenDatabase*)lpParameter;
	return pDbContext->m_pContext->DatabaseThread (pDbContext);
}

//-------------------------------------------
// Add a database to the freeze set.
//
void
Freeze2000::PrepareDatabase (
	const WString&		dbName)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Free2000::PrepareDatabase");

	// can't backup tempdb!
	//
	if (dbName == L"tempdb")
		return;

	Lock ();

	try
	{
		if (m_State == Unprepared)
		{
			m_State = Preparing;
		}

		if (m_NumDatabases >= m_MaxDatabases ||
			m_State != Preparing)
		{
			DBG_ASSERT(FALSE && L"Too many databases or not preparing");
			THROW_GENERIC;
		}

		FrozenDatabase*	pDbContext = m_pDBContext+m_NumDatabases;
		m_NumDatabases++;

		pDbContext->m_pContext = this;

		ft.hr = CoCreateInstance (
			CLSID_MSSQL_ClientVirtualDeviceSet,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_IClientVirtualDeviceSet2,
			(void**)&pDbContext->m_pIVDSet);

		if (ft.HrFailed())
		{
			ft.LogError(VSS_ERROR_SQLLIB_CANTCREATEVDS, VSSDBG_SQLLIB << ft.hr);
			ft.Throw
				(
				VSSDBG_SQLLIB,
				ft.hr,
				L"Failed to create VDS object.  hr = 0x%08lx",
				ft.hr
				);
		}

		VDConfig	config;
		memset (&config, 0, sizeof(config));
		config.deviceCount = 1;

		StringFromGUID2 (m_BackupId, pDbContext->m_SetName, sizeof (pDbContext->m_SetName));
		swprintf (pDbContext->m_SetName+wcslen(pDbContext->m_SetName), L"%d", m_NumDatabases);

		// A "\" indicates a named instance, so append the name...
		//
		WCHAR* pInstance = wcschr (m_ServerName.c_str (), L'\\');

		if (pInstance)
		{
			pInstance++;  // step over the separator
		}

		// Create the virtual device set
		//
		ft.hr = pDbContext->m_pIVDSet->CreateEx (pInstance, pDbContext->m_SetName, &config);
		if (ft.HrFailed())
		{
			ft.LogError(VSS_ERROR_SQLLIB_CANTCREATEVDS, VSSDBG_SQLLIB << ft.hr);
			ft.Throw
				(
				VSSDBG_SQLLIB,
				ft.hr,
				L"Failed to create VDS object.  hr = 0x%08lx",
				ft.hr
				);
		}
		pDbContext->m_VDState = Created;
		pDbContext->m_DbName = dbName;

		pDbContext->m_hThread = CreateThread (NULL, 0,
			FreezeThreadProc, pDbContext, 0, NULL);

		if (pDbContext->m_hThread == NULL)
		{
			ft.hr = HRESULT_FROM_WIN32(GetLastError());
			ft.CheckForError(VSSDBG_SQLLIB, L"CreateThread");
		}
	}
	catch (...)
	{
		Abort ();
		Unlock ();
		throw;
	}
	Unlock ();
}

//---------------------------------------------------------
// Prep a database by setting up a BACKUP WITH SNAPSHOT
// We perform a checkpoint first to minimize the backup checkpoint duration.
// Since the backup has no way to stall for the prepare, we stall it by delaying
// the VDI processing until freeze time.
//
DWORD
Freeze2000::DatabaseThread (
	FrozenDatabase*		pDbContext)
{
	CVssFunctionTracer ft(VSSDBG_XML, L"Freeze2000::DatabaseThread");

	try
	{
		SqlConnection	sql;
		sql.Connect (m_ServerName);
		WString command =
			L"BACKUP DATABASE [" + pDbContext->m_DbName + L"] TO VIRTUAL_DEVICE='" +
			pDbContext->m_SetName + L"' WITH SNAPSHOT,BUFFERCOUNT=1,BLOCKSIZE=1024";

		sql.SetCommand (command);
		sql.ExecCommand ();
		pDbContext->m_SuccessDetected = TRUE;
	}
	catch (...)
	{
		Abort ();
	}

	return 0;
}

//---------------------------------------------------------
// Advance the status of each VD.
// Will throw if problems are encountered.
//
// This routine is called in two contexts:
//  1. During the "Prepare" phase, in which case 'toSnapshot' is FALSE
//     and the goal is to move each VD to an "open" state.
//     At that time, the backup metadata is not yet consumed, to the BACKUP will
//     be waiting (leaving the database unfrozen).
//  2. During the "Freeze" phase, the metadata is consumed (and discarded),
//	   so the BACKUP will freeze the database and send the 'VDC_Snapshot' command.
//
void
Freeze2000::AdvanceVDState (
	bool toSnapshot)	// TRUE when we want to advance to the snapshot open stage.
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Freeze2000::AdvanceVDState");

	// Poll over the VD's moving them to Open or SnapshotOpen
	//
	while (1)
	{
		bool	didSomething = false;
		int nDatabasesReady = 0;

		for (int i=0; i<m_NumDatabases; i++)
		{
			FrozenDatabase*	pDb = m_pDBContext+i;

			if (CheckAbort ())
			{
				THROW_GENERIC;
			}

			switch (pDb->m_VDState)
			{
				case Created:
					VDConfig	config;
					ft.hr = pDb->m_pIVDSet->GetConfiguration (0, &config);
					if (ft.hr == VD_E_TIMEOUT)
						break;
					if (ft.HrFailed())
						ft.CheckForError(VSSDBG_SQLLIB, L"IClientVirtualDeviceSet2::GetConfiguration");

					ft.hr = pDb->m_pIVDSet->OpenDevice (pDb->m_SetName, &pDb->m_pIVD);
					if (ft.HrFailed())
						ft.CheckForError(VSSDBG_SQLLIB, L"IClientVirtualDeviceSet2::OpenDevice");

					pDb->m_VDState = Open;
					didSomething = true;
					
					// fall thru

				case Open:
					if (!toSnapshot)
					{
						nDatabasesReady++;
						break;
					}

					// pull commands until we see the snapshot
					//
					VDC_Command *   cmd;
					HRESULT hr;

					while (pDb->m_VDState == Open &&
						SUCCEEDED (hr=pDb->m_pIVD->GetCommand (0, &cmd)))
					{
						DWORD           completionCode;
						DWORD           bytesTransferred;
						didSomething = true;

						switch (cmd->commandCode)
						{
							case VDC_Write:
								bytesTransferred = cmd->size;
							case VDC_Flush:
								completionCode = ERROR_SUCCESS;

								ft.hr = pDb->m_pIVD->CompleteCommand (
									cmd, completionCode, bytesTransferred, 0);
								if (ft.HrFailed())
									ft.CheckForError(VSSDBG_SQLLIB, L"IClientVirtualDevice::CompleteCommand");

								break;

							case VDC_Snapshot:
								pDb->m_VDState = SnapshotOpen;
								pDb->m_pSnapshotCmd = cmd;
								break;

							default:
								ft.Trace(VSSDBG_SQLLIB, L"Unexpected VDCmd: x%x\n", cmd->commandCode);
								THROW_GENERIC;
						} // end command switch
					} // end command loop

					ft.hr = hr;

					if (ft.hr == VD_E_TIMEOUT)
						break;	// no command was ready.
					if (ft.HrFailed())
						ft.CheckForError(VSSDBG_SQLLIB, L"IClientVirtualDevice::GetCommand");

					DBG_ASSERT(pDb->m_VDState == SnapshotOpen);
					break;

				case SnapshotOpen:
					nDatabasesReady++;
					break;

				default:
					DBG_ASSERT(FALSE && L"Shouldn't get here");
					THROW_GENERIC;
			} // end switch to handle this db
		} // end loop over each db
	
		if (nDatabasesReady == m_NumDatabases)
			break;

		// Unless we found something to do,
		// delay a bit and try again.
		//

		if (didSomething)
			continue;
		SleepEx (100, TRUE);

	} // wait for all databases to go "Ready"
}

//---------------------------------------------------------
// Wait for the databases to finish preparing.
// This waits for the virtual devices to open up
//
void
Freeze2000::WaitForPrepare ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Freeze2000::WaitForPrepare");

	Lock ();
	if (m_State != Preparing || CheckAbort ())
	{
		Abort ();
		Unlock ();
		THROW_GENERIC;
	}
	m_State = Prepared;
	try
	{
		AdvanceVDState (FALSE);
	}
	catch (...)
	{
		Abort ();
		Unlock ();
		throw;
	}
	Unlock ();
}


//------------------------------------------------------------------
// Perform the freeze, waiting for a "Take-snapshot" from each db.
//
void
Freeze2000::Freeze ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Freeze2000::Freeze");

	Lock ();
	if (m_State != Prepared || CheckAbort ())
	{
		Abort ();
		Unlock ();
		THROW_GENERIC;
	}

	try
	{
		m_State = Frozen;
		AdvanceVDState (TRUE);
	}
	catch (...)
	{
		Abort ();
		Unlock ();
		throw;
	}
	Unlock ();
}


//---------------------------------------------------------
// Perform the thaw.
//
// Return TRUE if the databases were all successfully backed up
// and were thawed out as expected.
// FALSE is returned in any other case.
// No exceptions are thrown (this routine can be used as a cleanup routine).
//
BOOL
Freeze2000::Thaw () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Freeze2000::Thaw");

	Lock ();

	if (m_State != Frozen || CheckAbort ())
	{
		Abort ();
		Unlock ();
		return FALSE;
	}

	try
	{

		// Send the "snapshot complete" messages.
		//
			int i;

		for (i=0; i<m_NumDatabases; i++)
		{
			FrozenDatabase*	pDb = m_pDBContext+i;

			DBG_ASSERT (pDb->m_VDState == SnapshotOpen);
			ft.hr = pDb->m_pIVD->CompleteCommand (pDb->m_pSnapshotCmd, ERROR_SUCCESS, 0, 0);
			if (FAILED (ft.hr))
				ft.CheckForError(VSSDBG_SQLLIB, L"IClientVirtualDevice::CompleteCommand");
		}

		// Wait for the BACKUP threads to report success.
		//
		WaitForThreads ();

		for (i=0; i<m_NumDatabases; i++)
		{
			FrozenDatabase*	pDb = m_pDBContext+i;

			if (!pDb->m_SuccessDetected)
			{
				THROW_GENERIC;
			}
		}

		// Pull the "close" message from each VD
		//
		for (i=0; i<m_NumDatabases; i++)
		{
			FrozenDatabase*	pDb = m_pDBContext+i;
		    VDC_Command *   cmd;
			ft.hr=pDb->m_pIVD->GetCommand (INFINITE, &cmd);
			if (ft.hr != VD_E_CLOSE)
				ft.LogError(VSS_ERROR_SQLLIB_FINALCOMMANDNOTCLOSE, VSSDBG_SQLLIB << ft.hr);

			pDb->m_pIVDSet->Close ();
			pDb->m_pIVDSet->Release ();
			pDb->m_pIVDSet = NULL;
			pDb->m_pIVD = NULL;

		}

		m_State = Complete;
	}
	catch (...)
	{
		Abort ();
		Unlock ();
		return FALSE;
	}
	Unlock ();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\sqlwriter\globals.cpp ===
//
// globals.cpp : define all the stinking global vars :(
//

#define DBINITCONSTANTS

#pragma warning (disable: 4268)
#include <stdafx.hxx>

#include <oledb.h>
#include <oledberr.h>
#include <sqloledb.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\sqllib\sqlsnapi.h ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: sqlsnapi.h
//
// PURPOSE:
//
//		The internal include file for the sql snapshot module
//
// NOTES:
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     66601 srs  10/05/00 NTSNAP improvements
//
//
// @EndHeader@
// ***************************************************************************


#include <string>
#include <vector>
#include <list>

#include <oledb.h>
#include <oledberr.h>
#include <sqloledb.h>

#include "vdi.h"        // interface declaration from SQLVDI kit

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQLSNPIH"
//
////////////////////////////////////////////////////////////////////////

typedef unsigned long	ULONG;
typedef wchar_t			WCHAR;

#define TRUE 1
#define FALSE 0

class CLogMsg;


// Unexpected, "internal" errors can be logged with some
// generic international text, like "Internal error: <English servicibility text>"
//
// Situations we expect, for which the user needs to know should
// occur with proper internationalization
//

// Process wide globals used by the sql modules
//
extern IMalloc *	g_pIMalloc;

//-------------------------------------------------------------------------
//
typedef std::wstring					WString;
typedef std::vector<WString>			StringVector;
typedef StringVector::const_iterator	StringVectorIter;
typedef std::list<WString>				StringList;
typedef StringList::const_iterator		StringListIter;

StringVector* EnumerateServers ();

//-------------------------------------------------------------------------
// Handle our simple needs for DB services.
//
// Useage:
//    - Connect :		establish a connection to a given server
//    - SetCommand:		setup the SQL text to send
//    - ExecCommand:	execute some SQL, returns TRUE if a result set
//					is open and ready for retrieval
//	  - Get*:			retrieve info from the result set
//	
// The destructor will automatically disconnect from the server.
//
class SqlConnection
{
public:
	SqlConnection () :
		m_pCommandFactory (NULL),
		m_pCommand (NULL),
		m_pRowset (NULL),
		m_pBuffer (NULL),
		m_BufferSize (0),
		m_hAcc (NULL),
		m_pAccessor (NULL),
		m_pBindings (NULL),
		m_cBindings (0)
	{}

	~SqlConnection ();

	void
	Connect (const std::wstring& serverName);

	void
	Disconnect ();

	void
	ReleaseRowset ();
		
	void	
	SetCommand (const std::wstring& command);

	BOOL	
	ExecCommand ();

	StringVector*
	GetStringColumn ();

	ULONG
	GetServerVersion () {return m_ServerVersion;}

	BOOL
	FetchFirst ();
	
	BOOL
	FetchNext ();
	
	void*
	AccessColumn (int id);

private:
	void LogOledbError
		(
		CVssFunctionTracer &ft,
		CVssDebugInfo &dbgInfo,
		LPCWSTR wszRoutine,
		CLogMsg &msg
		);

	WString						m_ServerName;
	IDBCreateCommand*			m_pCommandFactory;
	ICommandText*				m_pCommand;
	IRowset*					m_pRowset;
	ULONG						m_ServerVersion;

	// used for the generic findfirst/findnext
	DBBINDING*					m_pBindings;
	ULONG						m_cBindings;
	BYTE*						m_pBuffer;
	ULONG						m_BufferSize;
	HACCESSOR					m_hAcc;
	IAccessor*					m_pAccessor;
};

BOOL
IsServerOnline (const WCHAR*	serverName);

//-------------------------------------------------------------------------
// In SQL2000 we'll use VDI snapshots to avoid bug 58266: thaw fails.
//
//  We'll prepare each database by starting a BACKUP WITH SNAPSHOT.
//  This will require one thread per database.
//  The backups will stall waiting for the VDI client to pull metadata.
//  When the "freeze" message comes along, the controlling thread will
//  pull all the BACKUPs to the frozen state.
//  Later the "thaw" message results in gathering the "success" report
//  from each thread.
//
//

class Freeze2000
{
public:
	enum VDState
	{
		Unknown=0, Created, Open, SnapshotOpen
	};
private:
	class FrozenDatabase
	{
		friend Freeze2000;

		FrozenDatabase () :
			m_pContext (NULL),
			m_hThread (NULL),
			m_pIVDSet (NULL),
			m_pIVD (NULL),
			m_pSnapshotCmd (NULL),
			m_VDState (Unknown),
			m_SuccessDetected (FALSE)
		{}

		Freeze2000*					m_pContext;
		HANDLE						m_hThread;
		IClientVirtualDeviceSet2*   m_pIVDSet;
		IClientVirtualDevice*       m_pIVD;
		WString						m_DbName;
	    VDC_Command*				m_pSnapshotCmd;
		VDState						m_VDState;
		WCHAR						m_SetName [80];
		bool						m_SuccessDetected;
	};

public:
	Freeze2000 (
		const WString&	serverName,
		ULONG			maxDatabases);

	~Freeze2000 ();

	void
	PrepareDatabase (
		const WString&	dbName);
	
	void
	WaitForPrepare ();

	void
	Freeze ();

	BOOL
	Thaw () throw ();

	static DWORD
	DatabaseThreadStart (LPVOID	pContext);

private:
	enum State {
		Unprepared,
		Preparing,
		Prepared,
		Frozen,
		Complete,
		Aborted
	};

	DWORD
	DatabaseThread (
		FrozenDatabase*	pDbContext);

	void
	WaitForThreads ();

	void
	AdvanceVDState (bool toSnapshot);

	void		// race-free method to persist an abort condition
	SetAbort ()
	{
		InterlockedIncrement (&m_AbortCount);
	}

	bool		// return true if the freeze is aborting
	CheckAbort ()
	{
		return 0 != InterlockedCompareExchange (&m_AbortCount, 0, 0);
	}

	void
	Abort () throw ();

	void
	Lock ()
	{
		EnterCriticalSection (&m_Latch);
	}
	void
	Unlock ()
	{	
		LeaveCriticalSection (&m_Latch);
	}
	BOOL	// return TRUE if we got the lock
	TryLock ()
	{
		return TryEnterCriticalSection (&m_Latch);
	}

	LONG				m_AbortCount;
	CRITICAL_SECTION	m_Latch;		
	State				m_State;
	WString				m_ServerName;
	GUID				m_BackupId;
	ULONG				m_NumDatabases;
	ULONG				m_MaxDatabases;
	FrozenDatabase*		m_pDBContext;
};

//-------------------------------------------------------------------------
// Represent a server which can be frozen.
//
class FrozenServer
{
public:
	FrozenServer (const std::wstring& serverName) :
		m_Name (serverName),
		m_pFreeze2000 (NULL)
	{}

	~FrozenServer ()
	{
		if (m_pFreeze2000)
		{
			delete m_pFreeze2000;
			m_pFreeze2000 = NULL;
		}
	}

	const std::wstring& GetName () const
	{ return m_Name; }

	BOOL
	FindDatabasesToFreeze (
		CCheckPath*		checker);

	BOOL
	Prepare ();

	BOOL
	Freeze ();

	BOOL
	Thaw () throw ();

private:
	BOOL
	FindDatabases2000 (
		CCheckPath*		checker);

	void
	GetDatabaseProperties (const WString& dbName,
		BOOL*	pSimple,
		BOOL*	pOnline);

private:
	std::wstring	m_Name;
	SqlConnection	m_Connection;
	StringList		m_FrozenDatabases;
	Freeze2000*		m_pFreeze2000;
};

//-------------------------------------------------------------------------
//
class Snapshot : public CSqlSnapshot
{
	enum Status {
		NotInitialized,
		Enumerated,
		Prepared,
		Frozen };

public:
	HRESULT Prepare (
		CCheckPath*		checker) throw ();

	HRESULT Freeze () throw ();

	HRESULT Thaw () throw ();

	Snapshot () {m_Status = NotInitialized;}

	~Snapshot () throw ();

private:
	void
	Deinitialize ();

	Status						m_Status;
	std::list<FrozenServer*>	m_FrozenServers;

	typedef std::list<FrozenServer*>::iterator ServerIter;
};

// We'll use very simple exception handling.
//
#define THROW_GENERIC  throw exception ();

//----------------------------------------------------------
// Implement our simple enumeration service
//
class SqlEnumerator : public CSqlEnumerator
{
	enum Status {
		Unknown = 0,
		DatabaseQueryActive,
		FileQueryActive
	};

public:
	~SqlEnumerator () throw ();

	SqlEnumerator () :
		m_State (Unknown),
		m_pServers (NULL)
	{}

	HRESULT FirstServer (
		ServerInfo*			pServer) throw ();

	HRESULT NextServer (
		ServerInfo*			pServer) throw ();

	HRESULT FirstDatabase (
		const WCHAR*		pServerName,
		DatabaseInfo*		pDbInfo) throw ();

	HRESULT NextDatabase (
		DatabaseInfo*		pDbInfo) throw ();

	HRESULT FirstFile (
		const WCHAR*		pServerName,
		const WCHAR*		pDbName,
		DatabaseFileInfo*	pDbInfo) throw ();

	HRESULT NextFile (
		DatabaseFileInfo*	pDbInfo) throw ();

private:
	Status			m_State;
	SqlConnection	m_Connection;
	StringVector*	m_pServers;
	int				m_CurrServer;
};

#if defined (DEBUG)

// Type of assertion passed through to utassert_fail function.
//


#define DBG_ASSERT(exp)  BS_ASSERT(exp)

// Allow for noop 64 bit asserts on win32 for things like
// overflowing 32 bit long, etc.
//
#ifdef _WIN64
 #define DBG64_ASSERT(exp) BS_ASSERT(exp)
#else
 #define DBG64_ASSERT(exp)
#endif

#else
 #define DBG_ASSERT(exp)
 #define DBG64_ASSERT(exp)
 #define DBG_ASSERTSZ(exp, txt)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\sqllib\sqlconnect.cpp ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: sqlconnect.cpp
//
// PURPOSE:
//
//		Handle the OLEDB connection and commands
//
// NOTES:
//
// Extern dependencies:
//   provision of "_Module" and the COM guids....
//
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     66601 srs  10/05/00 NTSNAP improvements
//
//
// @EndHeader@
// ***************************************************************************


// the templates make awful, long names which result in excessive warnings
//
#ifdef HIDE_WARNINGS
#pragma warning( disable : 4663)
#pragma warning( disable : 4786)
#pragma warning( disable : 4100)
#pragma warning( disable : 4511)
#endif


#include <stdafx.h>
#include <atlbase.h>
#include <clogmsg.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQLCONNC"
//
////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------------------
// routine to print out error information for a failed OLEDB request
//
// An optional parm is used to check for the 3014 code when a successful backup is
// erroneously marked as failed due to other problems (such as msdb access)
//
void DumpErrorInfo (
	IUnknown* pObjectWithError,
	REFIID IID_InterfaceWithError,
	CLogMsg &msg,
	BOOL*	pBackupSuccess = NULL
	)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"DumpErrorInfo");

    CComPtr<IErrorInfo> apIErrorInfoAll;
	CComPtr<IErrorInfo> apIErrorInfoRecord;
	CComPtr<IErrorRecords> apIErrorRecords;
	CComPtr<ISupportErrorInfo> apISupportErrorInfo;
	CComPtr<ISQLErrorInfo> apISQLErrorInfo;
	CComPtr<ISQLServerErrorInfo> apISQLServerErrorInfo;

    // Number of error records.
    ULONG nRecs;
    ULONG nRec;

    // Basic error information from GetBasicErrorInfo.
    ERRORINFO               errorinfo;

    // IErrorInfo values.
    CComBSTR bstrDescription;
    CComBSTR bstrSource;

    // ISQLErrorInfo parameters.
    CComBSTR bstrSQLSTATE;
    LONG lNativeError;
	

    // ISQLServerErrorInfo parameter pointers.
    SSERRORINFO* pSSErrorInfo = NULL;
    LPWSTR pSSErrorStrings = NULL;

    // Hard-code an American English locale for the example.
	//
	// **UNDONE** How should we internationalize properly?
	//
    DWORD MYLOCALEID = 0x0409;

	BOOL	msg3014seen = FALSE;
	BOOL	msg3013seen = FALSE;
	WCHAR buf[80];

    // Only ask for error information if the interface supports
    // it.
    if (FAILED(pObjectWithError->QueryInterface
					(
					IID_ISupportErrorInfo,
					(void**) &apISupportErrorInfo)
					))
    {
		ft.Trace (VSSDBG_SQLLIB, L"SupportErrorErrorInfo interface not supported");
		return;
    }

    if (FAILED(apISupportErrorInfo->InterfaceSupportsErrorInfo(IID_InterfaceWithError)))
    {
		ft.Trace (VSSDBG_SQLLIB, L"InterfaceWithError interface not supported");
		return;
    }


    // Do not test the return of GetErrorInfo. It can succeed and return
    // a NULL pointer in pIErrorInfoAll. Simply test the pointer.
    GetErrorInfo(0, &apIErrorInfoAll);

    if (apIErrorInfoAll != NULL)
    {
        // Test to see if it's a valid OLE DB IErrorInfo interface
        // exposing a list of records.

        if (SUCCEEDED(apIErrorInfoAll->QueryInterface (
						IID_IErrorRecords,
						(void**) &apIErrorRecords)))
        {
            apIErrorRecords->GetRecordCount(&nRecs);

			// Within each record, retrieve information from each
            // of the defined interfaces.
            for (nRec = 0; nRec < nRecs; nRec++)
            {
                // From IErrorRecords, get the HRESULT and a reference
                // to the ISQLErrorInfo interface.
                apIErrorRecords->GetBasicErrorInfo(nRec, &errorinfo);
				apIErrorRecords->GetCustomErrorObject (
					nRec,
                    IID_ISQLErrorInfo,
					(IUnknown**) &apISQLErrorInfo);

                // Display the HRESULT, then use the ISQLErrorInfo.
                ft.Trace(VSSDBG_SQLLIB, L"HRESULT:\t%#X\n", errorinfo.hrError);
                if (apISQLErrorInfo != NULL)
                {
                    apISQLErrorInfo->GetSQLInfo(&bstrSQLSTATE, &lNativeError);

                    // Display the SQLSTATE and native error values.
                    ft.Trace(
				        VSSDBG_SQLLIB,
						L"SQLSTATE:\t%s\nNative Error:\t%ld\n",
                        bstrSQLSTATE,
						lNativeError);

                    msg.Add(L"SQLSTATE: ");
					msg.Add(bstrSQLSTATE);
					swprintf(buf, L", Native Error: %d\n", lNativeError);
					msg.Add(buf);
					

					if (lNativeError == 3013)
						msg3013seen = TRUE;
					else if (lNativeError == 3014)
						msg3014seen = TRUE;

                    // Get the ISQLServerErrorInfo interface from
                    // ISQLErrorInfo before releasing the reference.
                    apISQLErrorInfo->QueryInterface (
                        IID_ISQLServerErrorInfo,
                        (void**) &apISQLServerErrorInfo);

					// Test to ensure the reference is valid, then
					// get error information from ISQLServerErrorInfo.
					if (apISQLServerErrorInfo != NULL)
					{
						apISQLServerErrorInfo->GetErrorInfo (
							&pSSErrorInfo,
							&pSSErrorStrings);

						// ISQLServerErrorInfo::GetErrorInfo succeeds
						// even when it has nothing to return. Test the
						// pointers before using.
						if (pSSErrorInfo)
						{
							// Display the state and severity from the
							// returned information. The error message comes
							// from IErrorInfo::GetDescription.
							ft.Trace
								(
								VSSDBG_SQLLIB,
								L"Error state:\t%d\nSeverity:\t%d\n",
								pSSErrorInfo->bState,
								pSSErrorInfo->bClass
								);

                            swprintf(buf, L"Error state: %d, Severity: %d\n",pSSErrorInfo->bState, pSSErrorInfo->bClass);
							msg.Add(buf);

							// IMalloc::Free needed to release references
							// on returned values. For the example, assume
							// the g_pIMalloc pointer is valid.
							g_pIMalloc->Free(pSSErrorStrings);
							g_pIMalloc->Free(pSSErrorInfo);
						}
						apISQLServerErrorInfo.Release ();
					}
					apISQLErrorInfo.Release ();

				} // got the custom error info

                if (SUCCEEDED(apIErrorRecords->GetErrorInfo	(
						nRec,
						MYLOCALEID,
						&apIErrorInfoRecord)))
				{
                    // Get the source and description (error message)
                    // from the record's IErrorInfo.
                    apIErrorInfoRecord->GetSource(&bstrSource);
					apIErrorInfoRecord->GetDescription(&bstrDescription);

					if (bstrSource != NULL)
						{
                        ft.Trace(VSSDBG_SQLLIB, L"Source:\t\t%s\n", bstrSource);
						msg.Add(L"Source: ");
						msg.Add(bstrSource);
						msg.Add(L"\n");
						}

                    if (bstrDescription != NULL)
						{
                        ft.Trace(VSSDBG_SQLLIB, L"Error message:\t%s\n", bstrDescription);
						msg.Add(L"Error message: ");
						msg.Add(bstrDescription);
						msg.Add(L"\n");
						}

					apIErrorInfoRecord.Release ();
                }
            } // for each record
		}
        else
        {
            // IErrorInfo is valid; get the source and
            // description to see what it is.
            apIErrorInfoAll->GetSource(&bstrSource);
            apIErrorInfoAll->GetDescription(&bstrDescription);
            if (bstrSource != NULL)
				{
                ft.Trace(VSSDBG_SQLLIB, L"Source:\t\t%s\n", bstrSource);
				msg.Add(L"Source: ");
				msg.Add(bstrSource);
				msg.Add(L"\n");
				}

            if (bstrDescription != NULL)
				{
                ft.Trace(VSSDBG_SQLLIB, L"Error message:\t%s\n", bstrDescription);
				msg.Add(L"Error message: ");
				msg.Add(bstrDescription);
				msg.Add(L"\n");
				}
        }
	}
    else
	{
        ft.Trace(VSSDBG_SQLLIB, L"GetErrorInfo failed.");
    }

	if (pBackupSuccess)
	{
		*pBackupSuccess = (msg3014seen && !msg3013seen);
	}
}

//------------------------------------------------------------------
//
SqlConnection::~SqlConnection ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::~SqlConnection");
	Disconnect ();
}

//------------------------------------------------------------------
//
void
SqlConnection::ReleaseRowset ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::ReleaseRowset");

	if (m_pBuffer)
	{
		delete[] m_pBuffer;
		m_pBuffer = NULL;
	}
	if (m_pBindings)
	{
		delete[] m_pBindings;
		m_pBindings = NULL;
	}
	m_cBindings = 0;
	if (m_pAccessor)
	{
		if (m_hAcc)
		{
			m_pAccessor->ReleaseAccessor (m_hAcc, NULL);
			m_hAcc = NULL;
		}
		m_pAccessor->Release ();
		m_pAccessor = NULL;
	}
	if (m_pRowset)
	{
		m_pRowset->Release ();
		m_pRowset = NULL;
	}
}

//------------------------------------------------------------------
//
void
SqlConnection::Disconnect ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConenction::Disconnect");

	ReleaseRowset ();
	if (m_pCommand)
	{
		m_pCommand->Release ();
		m_pCommand = NULL;
	}
	if (m_pCommandFactory)
	{
		m_pCommandFactory->Release ();
		m_pCommandFactory = NULL;
	}
}

// log an error if not an out of resource error
void SqlConnection::LogOledbError
	(
	CVssFunctionTracer &ft,
	CVssDebugInfo &dbgInfo,
	LPCWSTR wszRoutine,
	CLogMsg &msg
	)
	{
	if (ft.hr == E_OUTOFMEMORY ||
		ft.hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
		ft.hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
		ft.hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
		ft.hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL) ||
		ft.hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
		ft.Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected in function %s", wszRoutine);
	else
		{
		ft.LogError(VSS_ERROR_SQLLIB_OLEDB_ERROR, dbgInfo << wszRoutine << ft.hr << msg.GetMsg());
		ft.Throw
			(
			dbgInfo,
			E_UNEXPECTED,
			L"Error calling %s.  hr = 0x%08lx.\n%s",
			wszRoutine,
			ft.hr,
			msg.GetMsg()
			);
        }
	}
	

//------------------------------------------------------------------
// Setup a session, ready to receive commands.
//
// This call may block for a long time while establishing the connection.
//
// See the "FrozenServer" object for a method to determine if the local
// server is up or not prior to requesting a connection.
//
// The "trick" of prepending "tcp:" to the servername isn't fast or robust
// enough to detect a shutdown server.
//
// Note for C programmers....BSTRs are used as part of the COM
// environment to be interoperable with VisualBasic.  The VARIANT
// datatype doesn't work with standard C strings.
//
void
SqlConnection::Connect (
	const WString&	serverName)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::Connect");
	CLogMsg msg;

	CComPtr<IDBInitialize> apdbInitialize;

	// "Connect" always implies a "fresh" connection.
	//
	ReleaseRowset ();

	if (m_ServerName.compare (serverName) == 0 && m_pCommand)
	{
		// Requesting the same server and we are connected.
		//
		return;
	}

	Disconnect ();
	m_ServerName = serverName;

	ft.hr = CoCreateInstance
		(
		CLSID_SQLOLEDB,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IDBInitialize,
		(void **) &apdbInitialize
		);

	if (ft.HrFailed())
		ft.CheckForError(VSSDBG_SQLLIB, L"CoCreateInstance");

	CComPtr<IDBProperties> apdbProperties;
	ft.hr = apdbInitialize->QueryInterface(IID_IDBProperties, (void **) &apdbProperties);
	if (ft.HrFailed())
		ft.CheckForError(VSSDBG_SQLLIB, L"IDBInitialize::QueryInterface");

	CComBSTR bstrComputerName = serverName.c_str ();

	// initial database context
	CComBSTR bstrDatabaseName = L"master";

	// use NT Authentication
	CComBSTR bstrSSPI = L"SSPI";

	const unsigned x_CPROP = 3;
	DBPROPSET propset;
	DBPROP rgprop[x_CPROP];

	propset.guidPropertySet = DBPROPSET_DBINIT;
	propset.cProperties = x_CPROP;
	propset.rgProperties = rgprop;

	for (unsigned i = 0; i < x_CPROP; i++)
	{
		VariantInit(&rgprop[i].vValue);
		rgprop[i].dwOptions = DBPROPOPTIONS_REQUIRED;
		rgprop[i].colid = DB_NULLID;
		rgprop[i].vValue.vt = VT_BSTR;
	}

	rgprop[0].dwPropertyID = DBPROP_INIT_DATASOURCE;
	rgprop[1].dwPropertyID = DBPROP_INIT_CATALOG;
	rgprop[2].dwPropertyID = DBPROP_AUTH_INTEGRATED;
	rgprop[0].vValue.bstrVal = bstrComputerName;
	rgprop[1].vValue.bstrVal = bstrDatabaseName;
	rgprop[2].vValue.bstrVal = bstrSSPI;

	ft.hr = apdbProperties->SetProperties(1, &propset);
	if (ft.HrFailed())
	{
		DumpErrorInfo(apdbProperties, IID_IDBProperties, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IDBProperties::SetProperties", msg);
	}

	ft.Trace(VSSDBG_SQLLIB, L"Connecting to server %s...", serverName.c_str ());

	ft.hr = apdbInitialize->Initialize();
	if (ft.HrFailed())
	{
		DumpErrorInfo(apdbInitialize, IID_IDBInitialize, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IDBInitialize::Initialize", msg);
	}

	CComPtr<IDBCreateSession> apCreateSession;
	ft.hr = apdbInitialize->QueryInterface(IID_IDBCreateSession, (void **) &apCreateSession);
	if (ft.HrFailed())
	{
		DumpErrorInfo(apdbInitialize, IID_IDBInitialize, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IDBInitialize::QueryInterface", msg);
	}

	// We keep the command factory around to generate commands.
	//
	ft.hr = apCreateSession->CreateSession (
			NULL,
			IID_IDBCreateCommand,
			(IUnknown **) &m_pCommandFactory);

	if (ft.HrFailed())
	{
		DumpErrorInfo(apCreateSession, IID_IDBCreateSession, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IDBCreateSession::CreateSession", msg);
	}

	ft.Trace(VSSDBG_SQLLIB, L"Connected\n");

	// Request the version of this server
	//
	DBPROPIDSET		versionSet;
	DBPROPID		versionID = DBPROP_DBMSVER;

	versionSet.guidPropertySet	= DBPROPSET_DATASOURCEINFO;
	versionSet.cPropertyIDs		= 1;
	versionSet.rgPropertyIDs	= &versionID;

	ULONG		propCount;
	DBPROPSET*	pPropSet;

	ft.hr = apdbProperties->GetProperties (1, &versionSet, &propCount, &pPropSet);

	if (ft.HrFailed())
	{
		DumpErrorInfo(apdbProperties, IID_IDBProperties, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IDBProperties::GetProperties", msg);
	}

	ft.Trace(VSSDBG_SQLLIB, L"Version: %s\n", pPropSet->rgProperties->vValue.bstrVal);

	swscanf (pPropSet->rgProperties->vValue.bstrVal, L"%d", &m_ServerVersion);

	g_pIMalloc->Free(pPropSet->rgProperties);
	g_pIMalloc->Free(pPropSet);
}

//---------------------------------------------------------------------
//	Setup the command with some SQL text
//
void
SqlConnection::SetCommand (const WString& command)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::SetCommand");

	CLogMsg msg;

	// Release the result of the previous command
	//
	ReleaseRowset ();

	// We create the command on the first request, then keep only one
	// around in the SqlConnection.
	//
	if (!m_pCommand)
	{
		ft.hr = m_pCommandFactory->CreateCommand (NULL, IID_ICommandText,
			(IUnknown **) &m_pCommand);

		if (ft.HrFailed())
		{
			DumpErrorInfo(m_pCommandFactory, IID_IDBCreateCommand, msg);
			LogOledbError(ft, VSSDBG_SQLLIB, L"IDBCreateCommand::CreateCommand", msg);
		}
	}

	ft.hr = m_pCommand->SetCommandText(DBGUID_DBSQL, command.c_str ());
	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pCommand, IID_ICommandText, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"ICommandText::SetCommandText", msg);
	}
	ft.Trace (VSSDBG_SQLLIB, L"SetCommand (%s)\n", command.c_str ());
}

//---------------------------------------------------------------------
//	Execute the command.  "SetCommand" must have been called previously.
//
BOOL
SqlConnection::ExecCommand ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::ExecCommand");

	CLogMsg msg;

	CComPtr<IRowset> apRowset;
	DBROWCOUNT	crows;
	HRESULT		hr;

	// Release the result of the previous command
	//
	ReleaseRowset ();

	ft.hr = m_pCommand->Execute (
			NULL,
			IID_IRowset,
			NULL,
			&crows,
			(IUnknown **) &m_pRowset);

    if (ft.HrFailed())
	{
		BOOL	backupSuccess = FALSE;

		DumpErrorInfo (m_pCommand, IID_ICommandText, msg, &backupSuccess);

		if (!backupSuccess)
			LogOledbError(ft, VSSDBG_SQLLIB, L"ICommandText::Execute", msg);
	}

	if (!m_pRowset)
	{
		ft.Trace(VSSDBG_SQLLIB, L"Command completed successfully with no rowset\n");
		return FALSE;
	}
	return TRUE;
}

//---------------------------------------------------------------------
// return a vector of string, one for each row of the output.
// The query should have returned a single column.
//
StringVector*
SqlConnection::GetStringColumn ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::GetStringColumn");
	CLogMsg msg;

	//ASSERT (m_pRowset)
	//

	CComPtr<IColumnsInfo> apColumnsInfo;
	ft.hr = m_pRowset->QueryInterface(IID_IColumnsInfo, (void **) &apColumnsInfo);
	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::QueryInterface", msg);
	}

	// get columns info
	//
	DBCOLUMNINFO *rgColumnInfo;
	DBORDINAL cColumns;
	WCHAR *wszColumnInfo;
	ft.hr = apColumnsInfo->GetColumnInfo(&cColumns, &rgColumnInfo, &wszColumnInfo);
	if (ft.HrFailed())
	{
		DumpErrorInfo (apColumnsInfo, IID_IColumnsInfo, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IColumnsInfo::GetColumnInfo", msg);
	}

	// Auto objects ensure that memory is freed on exit
	//
	CAutoTask<DBCOLUMNINFO> argColumnInfo = rgColumnInfo;
	CAutoTask<WCHAR> awszColumnInfo = wszColumnInfo;

	// Setup a buffer to hold the string.
	// The output buffer holds a 4byte length, followed by the string column.
	//
	// "bufferSize" is in units of characters (not bytes)
	// Note that the "ulColumnSize" is in characters.
	// 1 char is used for the null term and we actually allocate one additional
	// char (hidden), just incase our provider gets the boundary condition wrong.
	//
	ULONG bufferSize = 1 + rgColumnInfo[0].ulColumnSize + (sizeof(ULONG)/sizeof(WCHAR));
	std::auto_ptr<WCHAR> rowBuffer(new WCHAR[bufferSize+1]);

	// Describe the binding for our single column of interest
	//
	DBBINDING	rgbind[1];
	unsigned	cBindings = 1;

	rgbind[0].dwPart	= DBPART_VALUE|DBPART_LENGTH;
	rgbind[0].wType		= DBTYPE_WSTR;	// retrieve a
	rgbind[0].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
	rgbind[0].eParamIO	= DBPARAMIO_NOTPARAM;
	rgbind[0].pObject	= NULL;
	rgbind[0].pBindExt	= NULL;
	rgbind[0].pTypeInfo = NULL;
	rgbind[0].dwFlags	= 0;
	rgbind[0].obLength	= 0;		// offset to the length field
	rgbind[0].iOrdinal	= 1;		// column id's start at 1
	rgbind[0].obValue	= sizeof(ULONG);	// offset to the string field		
	rgbind[0].cbMaxLen	= (unsigned) (bufferSize*sizeof(WCHAR)-sizeof(ULONG));

	CComPtr<IAccessor> apAccessor;
	ft.hr = m_pRowset->QueryInterface(IID_IAccessor, (void **) &apAccessor);
	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::QueryInterface", msg);
	}

	HACCESSOR hacc;
	ft.hr = apAccessor->CreateAccessor (
		DBACCESSOR_ROWDATA,
		cBindings,
		rgbind,
        0,
		&hacc,
		NULL);

	if (ft.HrFailed())
	{
		DumpErrorInfo(apAccessor, IID_IAccessor, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IAccessor::CreateAccessor", msg);
	}

	// loop through rows, generating a vector of strings.
	//

	HROW hrow;
	HROW *rghrow = &hrow;
	DBCOUNTITEM crow;
	std::auto_ptr<StringVector> aVec (new StringVector);
	
	// pString points into the output buffer for the string column
	//
	WCHAR*	pString = (WCHAR*)((BYTE*)rowBuffer.get () + sizeof (ULONG));

	while(TRUE)
	{
		ft.hr = m_pRowset->GetNextRows(NULL, 0, 1, &crow, &rghrow);
		if (ft.hr == DB_S_ENDOFROWSET)
			break;

		if (ft.HrFailed())
		{
			DumpErrorInfo (m_pRowset, IID_IRowset, msg);
			LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetNextRows", msg);
		}

		ft.hr = m_pRowset->GetData (hrow, hacc, rowBuffer.get());
		if (ft.HrFailed())
		{
			DumpErrorInfo(m_pRowset, IID_IRowset, msg);
			m_pRowset->ReleaseRows (1, rghrow, NULL, NULL, NULL);
			LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetData", msg);
		}

		unsigned	tempChars = (*(ULONG*)rowBuffer.get ())/sizeof (WCHAR);
		WString	tempStr (pString, tempChars);
		aVec->push_back (tempStr);

		ft.Trace(VSSDBG_SQLLIB, L"StringColumn: %s\n", tempStr.c_str ());

		m_pRowset->ReleaseRows(1, rghrow, NULL, NULL, NULL);
	}

	// UNDONE...make this an auto object to avoid leaks
	//
	apAccessor->ReleaseAccessor (hacc, NULL);

	return aVec.release ();
}


//---------------------------------------------------------------------
// Fetch the first row of the result.
//
BOOL
SqlConnection::FetchFirst ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::FetchFirst");
	CLogMsg msg;


	// UNDONE...make this nicely restep back to the first row.
	//
	if (m_pBindings)
	{
		throw HRESULT(E_SQLLIB_PROTO);
	}

	CComPtr<IColumnsInfo> apColumnsInfo;
	ft.hr = m_pRowset->QueryInterface(IID_IColumnsInfo, (void **) &apColumnsInfo);
	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::QueryInteface", msg);
	}

	// get columns info
	//
	DBCOLUMNINFO *rgColumnInfo;
	DBORDINAL cColumns;
	WCHAR *wszColumnInfo;
	ft.hr = apColumnsInfo->GetColumnInfo(&cColumns, &rgColumnInfo, &wszColumnInfo);
	if (ft.HrFailed())
	{
		DumpErrorInfo (apColumnsInfo, IID_IColumnsInfo, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IColumnsInfo::GetColumnInfo", msg);
	}

	// Auto objects ensure that memory is freed on exit
	//
	CAutoTask<DBCOLUMNINFO> argColumnInfo = rgColumnInfo;
	CAutoTask<WCHAR> awszColumnInfo = wszColumnInfo;

	// allocate bindings
	unsigned m_cBindings = (unsigned) cColumns;
	m_pBindings = new DBBINDING[m_cBindings];

	// Set up the bindings onto a buffer we'll allocate
	// UNDONE: do this properly for alignment & handling null indicators
	//

	unsigned cb = 0;
	for (unsigned icol = 0; icol < m_cBindings; icol++)
	{
		unsigned maxBytes;

		m_pBindings[icol].iOrdinal	= icol + 1;
		m_pBindings[icol].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
		m_pBindings[icol].eParamIO	= DBPARAMIO_NOTPARAM;
		m_pBindings[icol].pObject	= NULL;
		m_pBindings[icol].pBindExt	= NULL;
		m_pBindings[icol].pTypeInfo	= NULL;
		m_pBindings[icol].dwFlags	= 0;
		m_pBindings[icol].bPrecision	= rgColumnInfo[icol].bPrecision;
		m_pBindings[icol].bScale		= rgColumnInfo[icol].bScale;

		m_pBindings[icol].obStatus = 0; // no status info

		if (rgColumnInfo[icol].wType == DBTYPE_WSTR)
		{	// do we need the length?
			m_pBindings[icol].dwPart = DBPART_VALUE; //|DBPART_LENGTH;
			m_pBindings[icol].wType	= DBTYPE_WSTR;
			m_pBindings[icol].obLength = 0; //icol * sizeof(DBLENGTH);
			maxBytes = rgColumnInfo[icol].ulColumnSize * sizeof(WCHAR);
		}
		else
		{
			m_pBindings[icol].dwPart = DBPART_VALUE;
			m_pBindings[icol].wType = rgColumnInfo[icol].wType;
			m_pBindings[icol].obLength = 0;  // no length
			maxBytes = rgColumnInfo[icol].ulColumnSize;
		}

		m_pBindings[icol].obValue = cb;
		m_pBindings[icol].cbMaxLen = maxBytes;
		
		cb += maxBytes;
	}

	// allocate data buffer
	//
	m_pBuffer = new BYTE[cb];
	m_BufferSize = cb;

	ft.hr = m_pRowset->QueryInterface(IID_IAccessor, (void **) &m_pAccessor);
	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::QueryInterface", msg);
	}

	ft.hr = m_pAccessor->CreateAccessor (
		DBACCESSOR_ROWDATA,
		m_cBindings,
		m_pBindings,
        0,
		&m_hAcc,
		NULL);

	if (ft.HrFailed())
	{
		DumpErrorInfo(m_pAccessor, IID_IAccessor, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IAccessor::CreateAccessor", msg);
	}

	// Fetch the first row
	//

	HROW hrow;
	HROW *rghrow = &hrow;
	DBCOUNTITEM crow;

	ft.hr = m_pRowset->GetNextRows(NULL, 0, 1, &crow, &rghrow);
	if (ft.hr == DB_S_ENDOFROWSET)
	{
		// No rows in this set
		//
		return FALSE;
	}

	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetNextRows", msg);
	}

	ft.hr = m_pRowset->GetData (hrow, m_hAcc, m_pBuffer);
	if (ft.HrFailed())
	{
		DumpErrorInfo(m_pRowset, IID_IRowset, msg);
		m_pRowset->ReleaseRows (1, rghrow, NULL, NULL, NULL);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetData", msg);
	}

	m_pRowset->ReleaseRows(1, rghrow, NULL, NULL, NULL);

	return TRUE;
}


//---------------------------------------------------------------------
// Fetch the next row of the result.
//
BOOL
SqlConnection::FetchNext ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlConnection::FetchNext");

	HROW hrow;
	HROW *rghrow = &hrow;
	DBCOUNTITEM crow;
	CLogMsg msg;

	ft.hr = m_pRowset->GetNextRows(NULL, 0, 1, &crow, &rghrow);
	if (ft.hr == DB_S_ENDOFROWSET)
	{
		return FALSE;
	}

	if (ft.HrFailed())
	{
		DumpErrorInfo (m_pRowset, IID_IRowset, msg);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetNextRows", msg);
	}

	ft.hr = m_pRowset->GetData (hrow, m_hAcc, m_pBuffer);
	if (ft.HrFailed())
	{
		DumpErrorInfo(m_pRowset, IID_IRowset, msg);
		m_pRowset->ReleaseRows (1, rghrow, NULL, NULL, NULL);
		LogOledbError(ft, VSSDBG_SQLLIB, L"IRowset::GetData", msg);
	}

	m_pRowset->ReleaseRows(1, rghrow, NULL, NULL, NULL);

	return TRUE;
}

//-----------------------------------------------------------
// Provide a pointer to the n'th column.
//
void*
SqlConnection::AccessColumn (int colid)
{
	return m_pBuffer + m_pBindings[colid-1].obValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\sqllib\snapsql.cpp ===
// ***************************************************************************
//               Copyright (C) 2000- Microsoft Corporation.
// @File: snapsql.cpp
//
// PURPOSE:
//
//      Implement the SQLServer Volume Snapshot Writer.
//
// NOTES:
//
//
// HISTORY:
//
//     @Version: Whistler/Shiloh
//     66601 srs  10/05/00 NTSNAP improvements
//
//
// @EndHeader@
// ***************************************************************************

#if HIDE_WARNINGS
#pragma warning( disable : 4786)
#endif

#include <stdafx.h>

#include <new.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQLSNAPC"
//
////////////////////////////////////////////////////////////////////////

int __cdecl out_of_store(size_t size)
	{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"out_of_store");
	ft.Trace(VSSDBG_SQLLIB, L"out of memory");

	throw HRESULT (E_OUTOFMEMORY);
	return 0;
	}

class AutoNewHandler
{
public:
	AutoNewHandler ()
	{
	   m_oldHandler = _set_new_handler (out_of_store);
	}

	~AutoNewHandler ()
	{
	   _set_new_handler (m_oldHandler);
	}

private:
   _PNH		m_oldHandler;
};

//-------------------------------------------------------------------------
// Handle enviroment stuff:
//	- tracing/error logging
//  - mem alloc
//
IMalloc * g_pIMalloc = NULL;

HRESULT
InitSQLEnvironment()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"InitSqlEnvironment");
	try
	{
		ft.hr = CoGetMalloc(1, &g_pIMalloc);
		if (ft.HrFailed())
			ft.Trace(VSSDBG_SQLLIB, L"Failed to get task allocator: hr=0x%X", ft.hr);
	}
	catch (...)
	{
		ft.hr = E_SQLLIB_GENERIC;
	}

	return ft.hr;
}


//-------------------------------------------------------------------------
// Return TRUE if the server is online and a connection shouldn't take forever!
//
BOOL
IsServerOnline (const WCHAR*	serverName)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"IsServerOnline");

	WCHAR	eventName [300];
	WCHAR*	pInstance;

	wcscpy (eventName, L"Global\\sqlserverRecComplete");

	// A "\" indicates a named instance, so append the name...
	//
	pInstance = wcschr (serverName, L'\\');

	if (pInstance)
	{
		wcscat (eventName, L"$");
		wcscat (eventName, pInstance+1);
	}

	HANDLE hEvent = CreateEventW (NULL, TRUE, FALSE, eventName);

	if (hEvent == NULL)
	{
		ft.hr = HRESULT_FROM_WIN32(GetLastError());
		ft.LogError(VSS_ERROR_SQLLIB_CANT_CREATE_EVENT, VSSDBG_SQLLIB << ft.hr);
		THROW_GENERIC;
	}

	// If the event isn't signaled, the server is not up.
	//
	BOOL result = (WaitForSingleObject (hEvent, 0) == WAIT_OBJECT_0);

	CloseHandle (hEvent);

	return result;
}

//-------------------------------------------------------------------------
// Return TRUE if the database properties are retrieved:
//		simple: TRUE if using the simple recovery model.
//		online: TRUE if the database is usable and currently open
//
void
FrozenServer::GetDatabaseProperties (const WString& dbName,
	BOOL*	pSimple,
	BOOL*	pOnline)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::GetDatabaseProperties");

	// We use status bit 0x40000000 (1073741824) to identify
	// clean-shutdown databases which are "offline".
	//
	WString		query =
		L"select databaseproperty(N'" + dbName + L"','IsTruncLog'),"
		L"case status & 1073741824 "
			L"when 1073741824 then 0 "
			L"else 1 end "
		L"from master..sysdatabases where name = N'" + dbName + L"'";		

	m_Connection.SetCommand (query);
	m_Connection.ExecCommand ();

	if (!m_Connection.FetchFirst ())
	{
		LPCWSTR wsz = dbName.c_str();
		ft.LogError(VSS_ERROR_SQLLIB_DATABASE_NOT_IN_SYSDATABASES, VSSDBG_SQLLIB << wsz);
		THROW_GENERIC;
	}

	*pSimple = (BOOL)(*(int*)m_Connection.AccessColumn (1));
	*pOnline = (BOOL)(*(int*)m_Connection.AccessColumn (2));
}


//------------------------------------------------------------------------------
// Called only by "FindDatabasesToFreeze" to implement a smart access strategy:
//    - use sysaltfiles to qualify the databases.
//      This avoids access to shutdown or damaged databases.
//
// Autoclose databases which are not started are left out of the freeze-list.
// We do this to avoid scaling problems, especially on desktop systems.
// However, such db's are still evaluated to see if they are "torn".
//
// The 'model' database is allowed to be a full recovery database, since only
// database backups are sensible for it.
//
BOOL
FrozenServer::FindDatabases2000 (
	CCheckPath*		checker)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::FindDatabases2000");

	// Create an ordered set of tuples (dbname, filename, simpleRecovery, dbIsActive)
	//
	// We use status bit 0x40000000 (1073741824) to identify
	// clean-shutdown databases which are not active.
	//
	m_Connection.SetCommand (
		L"select db_name(af.dbid),rtrim(af.filename), "
		L"case databasepropertyex(db_name(af.dbid),'recovery') "
			L"when 'SIMPLE' then 1 "
			L"else 0 end,"
		L"case databasepropertyex(db_name(af.dbid),'Status') "
			L"when 'ONLINE' then case db.status & 1073741824 "
				L"when 1073741824 then 0 "
				L"else 1 end "
			L"else 0 end "
		L"from master..sysaltfiles af, master..sysdatabases db "
		L"where af.dbid = db.dbid and af.dbid != db_id('tempdb') "
		L"order by af.dbid"
		);

	m_Connection.ExecCommand ();

	WCHAR*	pDbName;
	WCHAR*	pFileName;
	int*	pSimple;
	int*	pIsOnline;
	WString currentDbName;
	BOOL	firstDb = TRUE;
	BOOL	firstFile;
	BOOL	shouldFreeze = FALSE;
	BOOL	masterLast = FALSE;
	BOOL	currDbIsOnline;

	if (!m_Connection.FetchFirst ())
	{
		ft.LogError(VSS_ERROR_SQLLIB_SYSALTFILESEMPTY, VSSDBG_SQLLIB);
		THROW_GENERIC;
	}

	pDbName = (WCHAR*)m_Connection.AccessColumn (1);
	pFileName = (WCHAR*)m_Connection.AccessColumn (2);
	pSimple = (int*)m_Connection.AccessColumn (3);
	pIsOnline = (int*)m_Connection.AccessColumn (4);

	while (1)
	{

		// Check out the current row
		//
		BOOL fileInSnap = checker->IsPathInSnapshot (pFileName);
		if (fileInSnap && !*pSimple && wcscmp (L"model", pDbName))
		{
			ft.LogError(VSS_ERROR_SQLLIB_DATABASENOTSIMPLE, VSSDBG_SQLLIB << pDbName);
			throw HRESULT (E_SQLLIB_NONSIMPLE);
		}

		// Is this the next database?
		//
		if (firstDb || currentDbName.compare (pDbName))
		{
			if (!firstDb)
			{
				// Deal with completed database
				//
				if (shouldFreeze && currDbIsOnline)
				{
					if (currentDbName == L"master")
					{
						masterLast = TRUE;
					}
					else
					{
						m_FrozenDatabases.push_back (currentDbName);
					}
				}
			}

			// Keep info about the newly encountered db
			//
			currentDbName = WString (pDbName);
			currDbIsOnline = *pIsOnline;
			firstFile = TRUE;
			firstDb = FALSE;
			ft.Trace(VSSDBG_SQLLIB, L"Examining %s. SimpleRecovery:%d Online:%d\n", pDbName, *pSimple, *pIsOnline);
		}

		ft.Trace(VSSDBG_SQLLIB, L"%s\n", pFileName);

		if (firstFile)
		{
			shouldFreeze = fileInSnap;
			firstFile = FALSE;
		}
		else
		{
			if (shouldFreeze ^ fileInSnap)
			{
				ft.LogError(VSS_ERROR_SQLLIB_DATABASEISTORN, VSSDBG_SQLLIB);
				throw HRESULT (E_SQLLIB_TORN_DB);
			}
		}

		if (!m_Connection.FetchNext ())
		{
			// Deal with the current database
			//
			if (shouldFreeze && currDbIsOnline)
			{
				m_FrozenDatabases.push_back (currentDbName);
			}
			break;
		}
	}

	if (masterLast)
	{
		m_FrozenDatabases.push_back (L"master");
	}

	return m_FrozenDatabases.size () > 0;
}

//------------------------------------------------------------------------------
// Determine if there are databases which qualify for a freeze on this server.
// Returns TRUE if so.
// Throws if any qualified databases are any of:
//    - "torn" (not fully covered by the snapshot)
//    - hosted by a server which can't support freeze
//    - are not "simple" databases
//
BOOL
FrozenServer::FindDatabasesToFreeze (
	CCheckPath*		checker)
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::FindDatabasesToFreeze");

	m_Connection.Connect (m_Name);

	m_FrozenDatabases.clear ();

	if (m_Connection.GetServerVersion () > 7)
	{
		// SQL2000 allows us to use a better access strategy.
		//
		return FindDatabases2000 (checker);
	}

	m_Connection.SetCommand (L"select name from sysdatabases where name != 'tempdb'");
	m_Connection.ExecCommand ();
	std::auto_ptr<StringVector> dbList (m_Connection.GetStringColumn ());
	BOOL	masterLast = FALSE;

	for (StringVectorIter i = dbList->begin (); i != dbList->end (); i++)
	{
		// UNDONE: SKIP OVER DB'S in SHUTDOWN DB'S?
		// DB'S IN LOAD, ETC?
		// We'll avoid freezing shutdown db's, but we don't avoid
		// enumerating their files (they might be torn)
		//

		// Note the [] around the dbname to handle non-trivial dbnames.
		//
		WString		command = L"select rtrim(filename) from [";
		command += *i + L"]..sysfiles";

		m_Connection.SetCommand (command);
		try
		{
			m_Connection.ExecCommand ();
		}
		catch (...)
		{
			// We've decided to be optimistic:
			// If we can't get the list of files, ignore this database.
			//
			ft.Trace(VSSDBG_SQLLIB, L"Failed to get db files for %s\n", i->c_str ());

			continue;
		}

		std::auto_ptr<StringVector> fileList (m_Connection.GetStringColumn ());

		BOOL first=TRUE;
		BOOL shouldFreeze;

		for (StringVectorIter iFile = fileList->begin ();
			iFile != fileList->end (); iFile++)
		{
			BOOL fileInSnap = checker->IsPathInSnapshot (iFile->c_str ());

			if (first)
			{
				shouldFreeze = fileInSnap;
			}
			else
			{
				if (shouldFreeze ^ fileInSnap)
				{
					ft.LogError(VSS_ERROR_SQLLIB_DATABASEISTORN, VSSDBG_SQLLIB << i->c_str());
					throw HRESULT (E_SQLLIB_TORN_DB);
				}
			}
		}

		if (shouldFreeze)
		{
			BOOL	simple, online;
			GetDatabaseProperties (i->c_str (), &simple, &online);
			if (!simple && L"model" != *i)
			{
				ft.LogError(VSS_ERROR_SQLLIB_DATABASENOTSIMPLE, VSSDBG_SQLLIB << i->c_str ());
				throw HRESULT (E_SQLLIB_NONSIMPLE);
			}
			if (online)
			{
				if (L"master" == *i)
				{
					masterLast = TRUE;
				}
				else
				{
					m_FrozenDatabases.push_back (*i);
				}
			}
		}
	}
	if (masterLast)
	{
		m_FrozenDatabases.push_back (L"master");
	}


	return m_FrozenDatabases.size () > 0;
}

//-------------------------------------------------------------------
// Prep the server for the freeze.
// For SQL2000, start a BACKUP WITH SNAPSHOT.
// For SQL7, issuing checkpoints to each database.
// This minimizes the recovery processing needed when the snapshot is restored.
//
BOOL
FrozenServer::Prepare ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::Prepare");

	if (m_Connection.GetServerVersion () > 7)
	{
		m_pFreeze2000 = new Freeze2000 (m_Name, m_FrozenDatabases.size ());

		// Release the connection, we won't need it anymore
		//
		m_Connection.Disconnect ();

		for (StringListIter i=m_FrozenDatabases.begin ();
			i != m_FrozenDatabases.end (); i++)
		{
			m_pFreeze2000->PrepareDatabase (*i);
		}
		m_pFreeze2000->WaitForPrepare ();
	}
	else
	{
		WString		command;

		for (StringListIter i=m_FrozenDatabases.begin ();
			i != m_FrozenDatabases.end (); i++)
		{
			command += L"use [" + *i + L"]\ncheckpoint\n";
		}
		
		m_Connection.SetCommand (command);
		m_Connection.ExecCommand ();
	}
	return TRUE;
}

//---------------------------------------------
// Freeze the server by issuing freeze commands
// to each database.
// Returns an exception if any failure occurs.
//
BOOL
FrozenServer::Freeze ()
{
    CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::Freeze");
	if (m_pFreeze2000)
	{
		m_pFreeze2000->Freeze ();
	}
	else
	{
		WString		command;

		for (StringListIter i=m_FrozenDatabases.begin ();
			i != m_FrozenDatabases.end (); i++)
		{
			command += L"dbcc freeze_io (N'" + *i + L"')\n";
		}
		
		m_Connection.SetCommand (command);
		m_Connection.ExecCommand ();
	}

	return TRUE;
}

//---------------------------------------------
// Thaw the server by issuing thaw commands
// to each database.
// For SQL7, we can't tell if the database was
// already thawn.
// But for SQL2000, we'll return TRUE only if
// the databases were still all frozen at the thaw time.
BOOL
FrozenServer::Thaw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"FrozenServer::Thaw");
	if (m_pFreeze2000)
	{
		return m_pFreeze2000->Thaw ();
	}

	WString		command;

	for (StringListIter i=m_FrozenDatabases.begin ();
		i != m_FrozenDatabases.end (); i++)
	{
		command += L"dbcc thaw_io (N'" + *i + L"')\n";
	}
	
	m_Connection.SetCommand (command);
	m_Connection.ExecCommand ();

	return TRUE;
}


//-------------------------------------------------------------------------
// Create an object to handle the SQL end of the snapshot.
//
CSqlSnapshot*
CreateSqlSnapshot () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"CreateSqlSnapshot");
	try
	{
		return new Snapshot;
	}
	catch (...)
	{
	ft.Trace(VSSDBG_SQLLIB, L"Out of memory");
	}
	return NULL;
}

//---------------------------------------------------------------
// Move to an uninitialized state.
//
void
Snapshot::Deinitialize ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Snapshot::Deinitialize");

	if (m_Status == Frozen)
	{
		Thaw ();
	}
	for (ServerIter i=m_FrozenServers.begin ();
		i != m_FrozenServers.end (); i++)
	{
		delete *i;
	}
	m_FrozenServers.clear ();
	m_Status = NotInitialized;
}

Snapshot::~Snapshot ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Snapshot::~Snapshot");

	try
	{
		ft.Trace(VSSDBG_SQLLIB, L"\n~CSqlSnapshot called\n");
		Deinitialize ();
	}
	catch (...)
	{
		// swallow!
	}
}


//---------------------------------------------------------------------------------------
// Prepare for the snapshot:
//   - identify the installed servers
//   - for each server that is "up":
//		- identify databases affected by the snapshot
//		- if there are such databases, fail the snapshot if:
//			- the server doesn't support snapshots
//			- the database isn't a SIMPLE database
//			- the database is "torn" (not all files in the snapshot)
//
//
HRESULT
Snapshot::Prepare (CCheckPath*	checker) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Snapshot::Prepare");

	HRESULT		hr = S_OK;

	try
	{
		AutoNewHandler	t;

		// hack in a test of the new handler
		//
#if 0
		while (1)
		{
			char*p = new char [100000];
			if (p==NULL)
			{
				ft.Trace(VSSDBG_SQLLIB, L"Can never happen!\n");
				THROW_GENERIC;
			}
		}
#endif

		if (m_Status != NotInitialized)
		{
			Deinitialize ();
		}

		// The state moves immediately to enumerated, indicating
		// that the frozen server list may be non-empty.
		//
		m_Status = Enumerated;

		// Build a list of servers on this machine.
		//
		{
			std::auto_ptr<StringVector>	servers (EnumerateServers ());

			// Scan over the servers, picking out the online ones.
			//
			for (int i=0; i < servers->size (); i++)
			{
				if (IsServerOnline ((*servers)[i].c_str ()))
				{
					FrozenServer* p = new FrozenServer ((*servers)[i]);

					m_FrozenServers.push_back (p);
				}
				else
				{
					ft.Trace(VSSDBG_SQLLIB, L"Server %s is not online\n", (*servers)[i].c_str ());
				}
			}
		}

		// Evaulate the server databases to find those which need to freeze.
		//
		ServerIter i=m_FrozenServers.begin ();
		while (i != m_FrozenServers.end ())
		{
			if (!(**i).FindDatabasesToFreeze (checker))
			{
				ft.Trace(VSSDBG_SQLLIB, L"Server %s has no databases to freeze\n", ((**i).GetName ()).c_str ());

				// Forget about this server, it's got nothing to do.
				//
				delete *i;
				i = m_FrozenServers.erase (i);
			}
			else
			{
				i++;
			}
		}
		
		// Prep the servers for the freeze
		// 	
		for (i=m_FrozenServers.begin (); i != m_FrozenServers.end (); i++)
		{
			(*i)->Prepare ();
		}

#if 0
		// debug: print the frozen list
		//
		for (i=m_FrozenServers.begin ();
			i != m_FrozenServers.end (); i++)
		{
			ft.Trace(VSSDBG_SQLLIB, L"FrozenServer: %s\n", ((**i).GetName ()).c_str ());
		}
#endif
		
		m_Status = Prepared;
	}
	catch (HRESULT& e)
	{
		hr = e;
	}
	catch (...)
	{
		hr = E_SQLLIB_GENERIC;
	}

	return hr;
}

//---------------------------------------------------------------------------------------
// Freeze any prepared servers
//
HRESULT
Snapshot::Freeze () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Snapshot::Freeze");
	HRESULT hr = S_OK;

	if (m_Status != Prepared)
	{
		return E_SQLLIB_PROTO;
	}

	try
	{
		AutoNewHandler	t;

		// If any server is frozen, we are frozen.
		//
		m_Status = Frozen;

		// Ask the servers to freeze
		// 	
		for (ServerIter i=m_FrozenServers.begin (); i != m_FrozenServers.end (); i++)
		{
			(*i)->Freeze ();
		}
	}
	catch (...)
	{
		hr = E_SQLLIB_GENERIC;
	}

	return hr;
}

//-----------------------------------------------
// Thaw all the servers.
// This routine must not throw.  It's safe in a destructor
//
// DISCUSS WITH BRIAN....WE MUST RETURN "SUCCESS" only if the
// servers were all still frozen.  Otherwise the snapshot must
// have been cancelled.
//
HRESULT
Snapshot::Thaw () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"Snapshot::Thaw");
	HRESULT	hr = S_OK;
	AutoNewHandler	t;

	// Ask the servers to thaw
	// 	
	for (ServerIter i=m_FrozenServers.begin (); i != m_FrozenServers.end (); i++)
	{
		try
		{
			if (!(*i)->Thaw ())
			{
				hr = E_SQLLIB_GENERIC;
			}
		}
		catch (...)
		{
			hr = E_SQLLIB_GENERIC;
			ft.LogError(VSS_ERROR_SQLLIB_ERRORTHAWSERVER, VSSDBG_SQLLIB << ((**i).GetName ()).c_str ());
		}
	}

	// We still have the original list of servers.
	// The snapshot object is reusable if another "Prepare" is done, which will
	// re-enumerate the servers.
	//
	m_Status = Enumerated;

	return hr;
}

// Setup some try/catch/handlers for our interface...
// The invoker defines "hr" which is set if an exception
// occurs.
//
#define TRY_SQLLIB \
	try	{\
		AutoNewHandler	_myNewHandler;

#define END_SQLLIB \
	} catch (HRESULT& e)\
	{\
		ft.hr = e;\
	}\
	catch (...)\
	{\
		ft.hr = E_SQLLIB_GENERIC;\
	}

//-------------------------------------------------------------------------
// Create an object to handle enumerations
//
CSqlEnumerator*
CreateSqlEnumerator () throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"CreateSqlEnumerator");
	try
	{
		return new SqlEnumerator;
	}
	catch (...)
	{
		ft.Trace(VSSDBG_SQLLIB, L"Out of memory");
	}
	return NULL;
}

//-------------------------------------------------------------------------
//
SqlEnumerator::~SqlEnumerator ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::~SqlEnumerator");

	if (m_pServers)
		delete m_pServers;
}

//-------------------------------------------------------------------------
// Begin retrieval of the servers.
//
HRESULT
SqlEnumerator::FirstServer (ServerInfo* pSrv) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::FirstServer");


	if (m_pServers)
	{
		delete m_pServers;
		m_pServers = NULL;
	}

	m_CurrServer = 0;

	TRY_SQLLIB
	{
		m_pServers = EnumerateServers ();

		if (m_pServers->size () == 0)
		{
			ft.hr = DB_S_ENDOFROWSET;
		}
		else
        {
			wcscpy (pSrv->name, (*m_pServers)[0].c_str ());
			pSrv->isOnline = IsServerOnline (pSrv->name) ? true : false;

			m_CurrServer = 1;
			
			ft.hr = NOERROR;
        }
	}
	END_SQLLIB

	return ft.hr;
}

//-------------------------------------------------------------------------
// Continue retrieval of the servers.
//
HRESULT
SqlEnumerator::NextServer (ServerInfo* pSrv) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::NextServer");


	if (!m_pServers)
	{
		ft.hr = E_SQLLIB_PROTO;
	}
	else
	{
		TRY_SQLLIB
		{
			if (m_CurrServer >= m_pServers->size ())
			{
				ft.hr = DB_S_ENDOFROWSET;
			}
			else
			{
				wcscpy (pSrv->name, (*m_pServers)[m_CurrServer].c_str ());
				m_CurrServer++;

				pSrv->isOnline = IsServerOnline (pSrv->name) ? true : false;
				
				ft.hr = NOERROR;
			}
		}
		END_SQLLIB
    }

	return ft.hr;
}

//-------------------------------------------------------------------------
// Begin retrieval of the databases
//
HRESULT
SqlEnumerator::FirstDatabase (const WCHAR *pServerName, DatabaseInfo* pDbInfo) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::FirstDatabase");

	TRY_SQLLIB
	{
		m_Connection.Connect (pServerName);
		m_Connection.SetCommand (
			L"select name,DATABASEPROPERTY(name,'IsTruncLog') from master..sysdatabases");
		m_Connection.ExecCommand ();

		if (!m_Connection.FetchFirst ())
		{
			ft.LogError(VSS_ERROR_SQLLIB_NORESULTFORSYSDB, VSSDBG_SQLLIB);
			THROW_GENERIC;
		}

		WCHAR *pDbName = (WCHAR*)m_Connection.AccessColumn (1);
		int* pSimple = (int*)m_Connection.AccessColumn (2);

		wcscpy (pDbInfo->name, pDbName);
		pDbInfo->supportsFreeze = *pSimple &&
			m_Connection.GetServerVersion () >= 7;

		m_State = DatabaseQueryActive;

		ft.hr = NOERROR;
	}
	END_SQLLIB

	return ft.hr;
}

//-------------------------------------------------------------------------
// Continue retrieval of the databases
//
HRESULT
SqlEnumerator::NextDatabase (DatabaseInfo* pDbInfo) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::NextDatabase");

	if (m_State != DatabaseQueryActive)
	{
		ft.hr = E_SQLLIB_PROTO;
	}
	else
    {
		TRY_SQLLIB
		{
			if (!m_Connection.FetchNext ())
			{
				ft.hr = DB_S_ENDOFROWSET;
			}
			else
			{
				WCHAR* pDbName = (WCHAR*)m_Connection.AccessColumn (1);
				int* pSimple = (int*)m_Connection.AccessColumn (2);

				wcscpy (pDbInfo->name, pDbName);
				pDbInfo->supportsFreeze = *pSimple &&
					m_Connection.GetServerVersion () >= 7;

				ft.hr = NOERROR;
			}
		}
		END_SQLLIB
    }

	return ft.hr;
}

//-------------------------------------------------------------------------
// Begin retrieval of the database files
//
HRESULT
SqlEnumerator::FirstFile (
	const WCHAR*		pServerName,
	const WCHAR*		pDbName,
	DatabaseFileInfo*	pFileInfo) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::FirstFile");

	TRY_SQLLIB
	{
		m_Connection.Connect (pServerName);

		WString query;

		if (m_Connection.GetServerVersion () >= 8)
		{
			query =	L"select rtrim(filename),status & 64 from sysaltfiles where DB_ID('"
				+ WString(pDbName) + L"') = dbid";
		}
		else
		{
			query = L"select rtrim(filename),status & 64 from ["
				+ WString(pDbName) + L"]..sysfiles";
		}

		m_Connection.SetCommand (query);
		m_Connection.ExecCommand ();

		if (!m_Connection.FetchFirst ())
		{
			ft.LogError(VSS_ERROR_SQLLIB_NORESULTFORSYSDB, VSSDBG_SQLLIB);
			THROW_GENERIC;
		}

		WCHAR* pName = (WCHAR*)m_Connection.AccessColumn (1);
		int* pLogFile = (int*)m_Connection.AccessColumn (2);

		wcscpy (pFileInfo->name, pName);
		pFileInfo->isLogFile = (*pLogFile != 0);

		m_State = FileQueryActive;

		ft.hr = NOERROR;
	}
	END_SQLLIB

	return ft.hr;
}

//-------------------------------------------------------------------------
// Continue retrieval of the files
//
HRESULT
SqlEnumerator::NextFile (DatabaseFileInfo* pFileInfo) throw ()
{
	CVssFunctionTracer ft(VSSDBG_SQLLIB, L"SqlEnumerator::NextFile");

	if (m_State != FileQueryActive)
	{
		ft.hr = E_SQLLIB_PROTO;
	}
	else
    {
		TRY_SQLLIB
		{
			if (!m_Connection.FetchNext ())
			{
				ft.hr = DB_S_ENDOFROWSET;
			}
			else
            {
				WCHAR* pName = (WCHAR*)m_Connection.AccessColumn (1);
				int* pLogFile = (int*)m_Connection.AccessColumn (2);

				wcscpy (pFileInfo->name, pName);
				pFileInfo->isLogFile = (*pLogFile != 0);

				ft.hr = NOERROR;
			}
		}
		END_SQLLIB
    }

	return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\tracing\assrt.cxx ===
/*++

Copyright (c) 200  Microsoft Corporation

Module Name:

    assrt.cxx

Abstract:
	assertion code used by BS_ASSERT

Author:


Revision History:
	Name		Date		Comments
	brianb		04/19/2000	created
	aoltean     06/20/2000  Adding VssSetDebugReport

--*/


extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <stdio.h>

#undef ASSERT

#include "vs_assert.hxx"
#include "vs_trace.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "TRCASRTC"
//
////////////////////////////////////////////////////////////////////////


// No MP protection...
static LONG g_lVssDebugReportFlags = VSS_DBG_TO_DEBUG_CONSOLE | VSS_DBG_MESSAGE_BOX;


VOID
AssertFail
	(
    IN LPCSTR FileName,
    IN UINT LineNumber,
    IN LPCSTR Condition
    )
	{
    int i;
    CHAR Title[4096];
    CHAR Msg[4096];

    DWORD dwCurrentProcessId = GetCurrentProcessId();
    DWORD dwCurrentThreadId = GetCurrentThreadId();
    
    if (g_lVssDebugReportFlags & VSS_DBG_TO_DEBUG_CONSOLE) 
        {
        sprintf(
            Msg,
            "VSS(PID:%ld,TID:%ld): %s(%d): *** Assertion failure  *** %s\n",
            dwCurrentProcessId,
            dwCurrentThreadId,
            FileName,
            LineNumber,
            Condition
            );


        ::OutputDebugStringA(Msg);
/*
        ::DbgPrintEx(
            DPFLTR_VSS_ID,
            1,
            Msg
            );
 */
        }

    if (g_lVssDebugReportFlags & VSS_DBG_MESSAGE_BOX) 
        {
        LPSTR szCommandLine = GetCommandLineA();

        //
        // Use dll name as caption
        //
        sprintf(
            Title,
            "Volume Snapshots (PID:%ld,TID:%ld)",
            dwCurrentProcessId,
            dwCurrentThreadId
            );

        //
        // Print the assertion and the command line
        //
        sprintf(
            Msg,
            "Assertion failure at line %u in file %s: %s\n\nCommand line: %s\n\nHit Cancel to break into the debugger.",
            LineNumber,
            FileName,
            Condition,
            szCommandLine
            );

        i = MessageBoxA
    			(
                NULL,
                Msg,
    			Title,
    			MB_SYSTEMMODAL | MB_ICONSTOP | MB_OKCANCEL | MB_SERVICE_NOTIFICATION
                );

        if(i == IDCANCEL)
            DebugBreak();
        }
    }

void VssSetDebugReport( LONG lDebugReportFlags )
{
    g_lVssDebugReportFlags = lDebugReportFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\tracing\bsconcur.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bsconcur.cxx

Abstract:

    Implementation of CBsXXXX classes that wrap Win32 concurrency controls.

Author:

    Stefan R. Steiner   [SSteiner]      11-Apr-1998

Revision History:

--*/

#include <windows.h>
#include "bsconcur.hxx"

//////////////////////////////////////////////////////////////////////
// CBsAutoLock class implementation
//////////////////////////////////////////////////////////////////////

CBsAutoLock::~CBsAutoLock()
{
    BOOL bStatus = TRUE;

    switch( m_type ) {
    case BS_AUTO_MUTEX_HANDLE: 
        bStatus = ::ReleaseMutex( m_hMutexHandle );
        break;
    case BS_AUTO_CRIT_SEC:
        ::LeaveCriticalSection( m_pCritSec );
        break;
    case BS_AUTO_CRIT_SEC_CLASS:
        m_pcCritSec->Leave();
        break;
    }

    if ( bStatus == FALSE ) {
        throw( ::GetLastError() );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\tracing\vs_seh.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    vs_seh.cxx

Abstract:

    Exception handling support code

Author:

   Stefan R. Steiner   [SSteiner]      15-Apr-1998

Revision History:

    ssteiner   09/10/98		- Removed the exception classes.  Now only throwing
							HRESULTs.
	aoltean		02/02/2000	- moved into Vss project under the name from bsexcept.cxx 
							into "vs_seh" 
    
--*/

#include <windows.h>
#include "vs_seh.hxx"
#include "vs_trace.hxx"

/*++

Routine Description:

    The Structured Exception Handling translator function.  Translates
    SEH exceptions to C++ Native exceptions.  Generates a trace message.

Arguments:

    ExceptionCode - SEH exception code.

    pEP - pointer to a more detailed explanation of why the exception
          was thrown.
        
Return Value:

    None

Throws:

    HRESULT - translated exception code from windows exception code to HRESULT.

--*/

void _cdecl BsSeHandler::SeHandler(
    unsigned int uiExceptionCode,
    struct _EXCEPTION_POINTERS *pEP
    )
{
    BsDebugTraceAlways( 0, DEBUG_TRACE_CATCH_EXCEPTIONS, 
                        ( L"BsSeHandler::SeHandler: Caught SEH exception, code: 0x%08x", uiExceptionCode ) );                        
    BS_THROW( (HRESULT)uiExceptionCode );
    UNREFERENCED_PARAMETER( pEP );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\sqllib\inc\odbcss.h ===
/*
** ODBCSS.H - This is the application include file for the
** SQL Server driver specific defines.
**
** (C) Copyright 1993-1998 By Microsoft Corp.
**
*/

#ifndef __ODBCSS
#define __ODBCSS

#ifdef __cplusplus
extern "C" { 			/* Assume C declarations for C++   */
#endif  /* __cplusplus */

//	Useful defines
#define SQL_MAX_SQLSERVERNAME	128		// max SQL Server identifier length

//	SQLSetConnectOption/SQLSetStmtOption driver specific defines.
//	Microsoft has 1200 thru 1249 reserved for Microsoft SQL Server driver usage.

//	Connection Options
#define SQL_COPT_SS_BASE				1200
#define SQL_COPT_SS_REMOTE_PWD			(SQL_COPT_SS_BASE+1) // dbrpwset SQLSetConnectOption only
#define SQL_COPT_SS_USE_PROC_FOR_PREP	(SQL_COPT_SS_BASE+2) // Use create proc for SQLPrepare
#define SQL_COPT_SS_INTEGRATED_SECURITY	(SQL_COPT_SS_BASE+3) // Force integrated security on login
#define SQL_COPT_SS_PRESERVE_CURSORS	(SQL_COPT_SS_BASE+4) // Preserve server cursors after SQLTransact
#define SQL_COPT_SS_USER_DATA			(SQL_COPT_SS_BASE+5) // dbgetuserdata/dbsetuserdata
#define SQL_COPT_SS_ENLIST_IN_DTC		SQL_ATTR_ENLIST_IN_DTC // Enlist in a DTC transaction
#define SQL_COPT_SS_ENLIST_IN_XA		SQL_ATTR_ENLIST_IN_XA // Enlist in a XA transaction
#define SQL_COPT_SS_CONNECTION_DEAD		SQL_ATTR_CONNECTION_DEAD // dbdead SQLGetConnectOption only
#define SQL_COPT_SS_FALLBACK_CONNECT	(SQL_COPT_SS_BASE+10) // Enables FallBack connections
#define SQL_COPT_SS_PERF_DATA			(SQL_COPT_SS_BASE+11) // Used to access SQL Server ODBC driver performance data
#define SQL_COPT_SS_PERF_DATA_LOG		(SQL_COPT_SS_BASE+12) // Used to set the logfile name for the Performance data
#define SQL_COPT_SS_PERF_QUERY_INTERVAL (SQL_COPT_SS_BASE+13) // Used to set the query logging threshold in milliseconds.
#define SQL_COPT_SS_PERF_QUERY_LOG		(SQL_COPT_SS_BASE+14) // Used to set the logfile name for saving queryies.
#define SQL_COPT_SS_PERF_QUERY			(SQL_COPT_SS_BASE+15) // Used to start and stop query logging.
#define SQL_COPT_SS_PERF_DATA_LOG_NOW	(SQL_COPT_SS_BASE+16) // Used to make a statistics log entry to disk.
#define SQL_COPT_SS_QUOTED_IDENT		(SQL_COPT_SS_BASE+17) // Enable/Disable Quoted Identifiers
#define SQL_COPT_SS_ANSI_NPW			(SQL_COPT_SS_BASE+18) // Enable/Disable ANSI NULL, Padding and Warnings
#define SQL_COPT_SS_BCP					(SQL_COPT_SS_BASE+19) // Allow BCP usage on connection
#define SQL_COPT_SS_TRANSLATE			(SQL_COPT_SS_BASE+20) // Perform code page translation
#define SQL_COPT_SS_ATTACHDBFILENAME	(SQL_COPT_SS_BASE+21) // File name to be attached as a database
#define SQL_COPT_SS_CONCAT_NULL			(SQL_COPT_SS_BASE+22) // Enable/Disable CONCAT_NULL_YIELDS_NULL
#define SQL_COPT_SS_ENCRYPT             (SQL_COPT_SS_BASE+23) // Allow strong encryption for data

#define SQL_COPT_SS_MAX_USED			SQL_COPT_SS_ENCRYPT

//	Statement Options
#define SQL_SOPT_SS_BASE				1225
#define SQL_SOPT_SS_TEXTPTR_LOGGING		(SQL_SOPT_SS_BASE+0) // Text pointer logging
#define SQL_SOPT_SS_CURRENT_COMMAND		(SQL_SOPT_SS_BASE+1) // dbcurcmd SQLGetStmtOption only
#define SQL_SOPT_SS_HIDDEN_COLUMNS		(SQL_SOPT_SS_BASE+2) // Expose FOR BROWSE hidden columns
#define SQL_SOPT_SS_NOBROWSETABLE		(SQL_SOPT_SS_BASE+3) // Set NOBROWSETABLE option
#define SQL_SOPT_SS_REGIONALIZE			(SQL_SOPT_SS_BASE+4) // Regionalize output character conversions
#define SQL_SOPT_SS_CURSOR_OPTIONS		(SQL_SOPT_SS_BASE+5) // Server cursor options
#define SQL_SOPT_SS_NOCOUNT_STATUS      (SQL_SOPT_SS_BASE+6) // Real vs. Not Real row count indicator
#define SQL_SOPT_SS_DEFER_PREPARE		(SQL_SOPT_SS_BASE+7) // Defer prepare until necessary

#define SQL_SOPT_SS_MAX_USED			SQL_SOPT_SS_DEFER_PREPARE

#define SQL_COPT_SS_BASE_EX   1240
#define SQL_COPT_SS_BROWSE_CONNECT		(SQL_COPT_SS_BASE_EX+1) // Browse connect mode of operation
#define SQL_COPT_SS_BROWSE_SERVER		(SQL_COPT_SS_BASE_EX+2) // Single Server browse request.
#define SQL_COPT_SS_WARN_ON_CP_ERROR	(SQL_COPT_SS_BASE_EX+3) // Issues warning when data from the server 
																// had a loss during code page conversion.

#define SQL_COPT_SS_EX_MAX_USED			SQL_COPT_SS_WARN_ON_CP_ERROR

//	Defines for use with SQL_COPT_SS_USE_PROC_FOR_PREP
#define SQL_UP_OFF		0L			//	Procedures won't be used for prepare
#define SQL_UP_ON		1L			//	Procedures will be used for prepare
#define SQL_UP_ON_DROP	2L			//	Temp procedures will be explicitly dropped
#define SQL_UP_DEFAULT	SQL_UP_ON

//	Defines for use with SQL_COPT_SS_INTEGRATED_SECURITY - Pre-Connect Option only
#define SQL_IS_OFF		0L			//	Integrated security isn't used
#define SQL_IS_ON		1L			//	Integrated security is used
#define SQL_IS_DEFAULT	SQL_IS_OFF

//	Defines for use with SQL_COPT_SS_PRESERVE_CURSORS
#define SQL_PC_OFF		0L			//	Cursors are closed on SQLTransact
#define SQL_PC_ON		1L			//	Cursors remain open on SQLTransact
#define SQL_PC_DEFAULT	SQL_PC_OFF

//	Defines for use with SQL_COPT_SS_USER_DATA
#define SQL_UD_NOTSET	NULL			//	No user data pointer set

//	Defines for use with SQL_COPT_SS_TRANSLATE
#define SQL_XL_OFF		0L			//	Code page translation is not performed
#define SQL_XL_ON		1L			//	Code page translation is performed
#define SQL_XL_DEFAULT	SQL_XL_ON

//	Defines for use with SQL_COPT_SS_FALLBACK_CONNECT - Pre-Connect Option only
#define SQL_FB_OFF		0L			//	FallBack connections are disabled
#define SQL_FB_ON		1L			//	FallBack connections are enabled
#define SQL_FB_DEFAULT	SQL_FB_OFF

//	Defines for use with SQL_COPT_SS_BCP - Pre-Connect Option only
#define SQL_BCP_OFF		0L			//	BCP is not allowed on connection
#define SQL_BCP_ON		1L			//	BCP is allowed on connection
#define SQL_BCP_DEFAULT	SQL_BCP_OFF

//	Defines for use with SQL_COPT_SS_QUOTED_IDENT
#define SQL_QI_OFF		0L			//	Quoted identifiers are enable
#define SQL_QI_ON		1L			//	Quoted identifiers are disabled
#define SQL_QI_DEFAULT	SQL_QI_ON

//	Defines for use with SQL_COPT_SS_ANSI_NPW - Pre-Connect Option only
#define SQL_AD_OFF		0L			//	ANSI NULLs, Padding and Warnings are enabled
#define SQL_AD_ON		1L			//	ANSI NULLs, Padding and Warnings are disabled
#define SQL_AD_DEFAULT	SQL_AD_ON

//	Defines for use with SQL_COPT_SS_CONCAT_NULL - Pre-Connect Option only
#define SQL_CN_OFF	  0L		  //  CONCAT_NULL_YIELDS_NULL is off
#define SQL_CN_ON	  1L		  //  CONCAT_NULL_YIELDS_NULL is on
#define SQL_CN_DEFAULT	SQL_CN_ON


//	Defines for use with SQL_SOPT_SS_TEXTPTR_LOGGING
#define SQL_TL_OFF		0L			//	No logging on text pointer ops
#define SQL_TL_ON		1L			//	Logging occurs on text pointer ops
#define SQL_TL_DEFAULT	SQL_TL_ON

//	Defines for use with SQL_SOPT_SS_HIDDEN_COLUMNS
#define SQL_HC_OFF		0L		  //  FOR BROWSE columns are hidden
#define SQL_HC_ON		1L		  //  FOR BROWSE columns are exposed
#define SQL_HC_DEFAULT	SQL_HC_OFF

//	Defines for use with SQL_SOPT_SS_NOBROWSETABLE
#define SQL_NB_OFF		0L			//	NO_BROWSETABLE is off
#define SQL_NB_ON		1L			//	NO_BROWSETABLE is on
#define SQL_NB_DEFAULT	SQL_NB_OFF

//	Defines for use with SQL_SOPT_SS_REGIONALIZE
#define SQL_RE_OFF		0L			//	No regionalization occurs on output character conversions
#define SQL_RE_ON		1L			//	Regionalization occurs on output character conversions
#define SQL_RE_DEFAULT	SQL_RE_OFF

//	Defines for use with SQL_SOPT_SS_CURSOR_OPTIONS
#define SQL_CO_OFF		0L			//	Clear all cursor options
#define SQL_CO_FFO		1L			//	Fast-forward cursor will be used
#define SQL_CO_AF		2L			//	Autofetch on cursor open
#define SQL_CO_FFO_AF	(SQL_CO_FFO|SQL_CO_AF)	//	Fast-forward cursor with autofetch
#define SQL_CO_FIREHOSE_AF 4L       //  Auto fetch on fire-hose cursors 
#define SQL_CO_DEFAULT	SQL_CO_OFF

//SQL_SOPT_SS_NOCOUNT_STATUS
#define SQL_NC_OFF      0L 
#define SQL_NC_ON       1L 

//SQL_SOPT_SS_DEFER_PREPARE
#define SQL_DP_OFF      0L 
#define SQL_DP_ON       1L 

//SQL_COPT_SS_ENCRYPT
#define SQL_EN_OFF      0L
#define SQL_EN_ON       1L

//SQL_COPT_SS_BROWSE_CONNECT
#define SQL_MORE_INFO_NO  0L
#define SQL_MORE_INFO_YES 1L

//SQL_COPT_SS_WARN_ON_CP_ERROR
#define SQL_WARN_NO   0L
#define SQL_WARN_YES  1L

//	Defines returned by SQL_ATTR_CURSOR_TYPE/SQL_CURSOR_TYPE
#define SQL_CURSOR_FAST_FORWARD_ONLY	8	//	Only returned by SQLGetStmtAttr/Option


//	SQLColAttributes driver specific defines.
//	SQLSet/GetDescField driver specific defines.
//	Microsoft has 1200 thru 1249 reserved for Microsoft SQL Server driver usage.

#define SQL_CA_SS_BASE				1200
#define SQL_CA_SS_COLUMN_SSTYPE		(SQL_CA_SS_BASE+0)	//	dbcoltype/dbalttype
#define SQL_CA_SS_COLUMN_UTYPE		(SQL_CA_SS_BASE+1)	//	dbcolutype/dbaltutype
#define SQL_CA_SS_NUM_ORDERS		(SQL_CA_SS_BASE+2)	//	dbnumorders
#define SQL_CA_SS_COLUMN_ORDER		(SQL_CA_SS_BASE+3)	//	dbordercol
#define SQL_CA_SS_COLUMN_VARYLEN	(SQL_CA_SS_BASE+4)	//	dbvarylen
#define SQL_CA_SS_NUM_COMPUTES		(SQL_CA_SS_BASE+5)	//	dbnumcompute
#define SQL_CA_SS_COMPUTE_ID		(SQL_CA_SS_BASE+6)	//	dbnextrow status return
#define SQL_CA_SS_COMPUTE_BYLIST	(SQL_CA_SS_BASE+7)	//	dbbylist
#define SQL_CA_SS_COLUMN_ID			(SQL_CA_SS_BASE+8)	//	dbaltcolid
#define SQL_CA_SS_COLUMN_OP			(SQL_CA_SS_BASE+9)	//	dbaltop
#define SQL_CA_SS_COLUMN_SIZE		(SQL_CA_SS_BASE+10)	//	dbcollen
#define SQL_CA_SS_COLUMN_HIDDEN		(SQL_CA_SS_BASE+11) //	Column is hidden (FOR BROWSE)
#define SQL_CA_SS_COLUMN_KEY		(SQL_CA_SS_BASE+12) //	Column is key column (FOR BROWSE)
//#define SQL_DESC_BASE_COLUMN_NAME_OLD	(SQL_CA_SS_BASE+13) //This is defined at another location.
#define SQL_CA_SS_COLUMN_COLLATION	(SQL_CA_SS_BASE+14) //	Column collation (only for chars)
#define SQL_CA_SS_VARIANT_TYPE      (SQL_CA_SS_BASE+15)
#define SQL_CA_SS_VARIANT_SQL_TYPE  (SQL_CA_SS_BASE+16)
#define SQL_CA_SS_VARIANT_SERVER_TYPE (SQL_CA_SS_BASE+17)
#define SQL_CA_SS_MAX_USED			(SQL_CA_SS_BASE+18)




//	SQL Server Data Type Tokens.
//	New types for 6.0 and later servers
/* SQL Server Data Type Tokens. */
#define SQLTEXT 			0x23
#define SQLVARBINARY		0x25
#define SQLINTN 			0x26
#define SQLVARCHAR			0x27
#define SQLBINARY			0x2d
#define SQLIMAGE			0x22
#define SQLCHARACTER		0x2f
#define SQLINT1 			0x30
#define SQLBIT				0x32
#define SQLINT2 			0x34
#define SQLINT4 			0x38
#define SQLMONEY			0x3c
#define SQLDATETIME 		0x3d
#define SQLFLT8 			0x3e
#define SQLFLTN 			0x6d
#define SQLMONEYN			0x6e
#define SQLDATETIMN 		0x6f
#define SQLFLT4 			0x3b
#define SQLMONEY4			0x7a
#define SQLDATETIM4 		0x3a
//	New types for 6.0 and later servers
#define SQLDECIMAL			0x6a
#define SQLNUMERIC			0x6c
//	New types for 7.0 and later servers
#define SQLUNIQUEID			0x24
#define SQLBIGCHAR			0xaf
#define SQLBIGVARCHAR		0xa7
#define SQLBIGBINARY		0xad
#define SQLBIGVARBINARY		0xa5
#define SQLBITN				0x68
#define SQLNCHAR			0xef
#define SQLNVARCHAR 		0xe7
#define SQLNTEXT			0x63
// New for 7.x
#define SQLINT8	            0x7f
#define SQLVARIANT          0x62

//	User Data Type definitions.
//	Returned by SQLColAttributes/SQL_CA_SS_COLUMN_UTYPE.
#define SQLudtBINARY			3
#define SQLudtBIT				16
#define SQLudtBITN				0
#define SQLudtCHAR				1
#define SQLudtDATETIM4			22
#define SQLudtDATETIME			12
#define SQLudtDATETIMN			15
#define SQLudtDECML 			24
#define SQLudtDECMLN			26
#define SQLudtFLT4				23
#define SQLudtFLT8				8
#define SQLudtFLTN				14
#define SQLudtIMAGE 			20
#define SQLudtINT1				5
#define SQLudtINT2				6
#define SQLudtINT4				7
#define SQLudtINTN				13
#define SQLudtMONEY 			11
#define SQLudtMONEY4			21
#define SQLudtMONEYN			17
#define SQLudtNUM				10
#define SQLudtNUMN				25
#define SQLudtSYSNAME			18
#define SQLudtTEXT				19
#define SQLudtTIMESTAMP 		80
#define SQLudtUNIQUEIDENTIFIER	0
#define SQLudtVARBINARY 		4
#define SQLudtVARCHAR			2
#define MIN_USER_DATATYPE		256

//	Aggregate operator types.
//	Returned by SQLColAttributes/SQL_CA_SS_COLUMN_OP.
#define SQLAOPSTDEV 	0x30	// Standard deviation
#define SQLAOPSTDEVP	0x31	// Standard deviation population
#define SQLAOPVAR		0x32	// Variance
#define SQLAOPVARP		0x33	// Variance population
#define SQLAOPCNT		0x4b	// Count
#define SQLAOPSUM		0x4d	// Sum
#define SQLAOPAVG		0x4f	// Average
#define SQLAOPMIN		0x51	// Min
#define SQLAOPMAX		0x52	// Max
#define SQLAOPANY		0x53	// Any
#define SQLAOPNOOP		0x56	// None


//	SQLGetInfo driver specific defines.
//	Microsoft has 1151 thru 1200 reserved for Microsoft SQL Server driver usage.

#define SQL_INFO_SS_FIRST		1199
#define SQL_INFO_SS_NETLIB_NAMEW (SQL_INFO_SS_FIRST+0) //  dbprocinfo
#define SQL_INFO_SS_NETLIB_NAMEA (SQL_INFO_SS_FIRST+1) //  dbprocinfo
#define SQL_INFO_SS_MAX_USED	SQL_INFO_SS_NETLIB_NAMEA
#ifdef UNICODE
#define SQL_INFO_SS_NETLIB_NAME		SQL_INFO_SS_NETLIB_NAMEW
#else
#define SQL_INFO_SS_NETLIB_NAME		SQL_INFO_SS_NETLIB_NAMEA
#endif


//	Driver specific SQL type defines.
//	Microsoft has -150 thru -199 reserved for Microsoft SQL Server driver usage.
#define SQL_SS_VARIANT    -150


//	SQLGetDiagField driver specific defines.
//	Microsoft has -1150 thru -1199 reserved for Microsoft SQL Server driver usage.

#define SQL_DIAG_SS_BASE		(-1150)
#define SQL_DIAG_SS_MSGSTATE	(SQL_DIAG_SS_BASE)
#define SQL_DIAG_SS_SEVERITY	(SQL_DIAG_SS_BASE-1)
#define SQL_DIAG_SS_SRVNAME 	(SQL_DIAG_SS_BASE-2)
#define SQL_DIAG_SS_PROCNAME	(SQL_DIAG_SS_BASE-3)
#define SQL_DIAG_SS_LINE		(SQL_DIAG_SS_BASE-4)


//	SQLGetDiagField/SQL_DIAG_DYNAMIC_FUNCTION_CODE driver specific defines.
//	Microsoft has -200 thru -299 reserved for Microsoft SQL Server driver usage.

#define SQL_DIAG_DFC_SS_BASE					(-200)
#define SQL_DIAG_DFC_SS_ALTER_DATABASE			(SQL_DIAG_DFC_SS_BASE-0)
#define SQL_DIAG_DFC_SS_CHECKPOINT				(SQL_DIAG_DFC_SS_BASE-1)
#define SQL_DIAG_DFC_SS_CONDITION				(SQL_DIAG_DFC_SS_BASE-2)
#define SQL_DIAG_DFC_SS_CREATE_DATABASE 		(SQL_DIAG_DFC_SS_BASE-3)
#define SQL_DIAG_DFC_SS_CREATE_DEFAULT			(SQL_DIAG_DFC_SS_BASE-4)
#define SQL_DIAG_DFC_SS_CREATE_PROCEDURE		(SQL_DIAG_DFC_SS_BASE-5)
#define SQL_DIAG_DFC_SS_CREATE_RULE 			(SQL_DIAG_DFC_SS_BASE-6)
#define SQL_DIAG_DFC_SS_CREATE_TRIGGER			(SQL_DIAG_DFC_SS_BASE-7)
#define SQL_DIAG_DFC_SS_CURSOR_DECLARE			(SQL_DIAG_DFC_SS_BASE-8)
#define SQL_DIAG_DFC_SS_CURSOR_OPEN 			(SQL_DIAG_DFC_SS_BASE-9)
#define SQL_DIAG_DFC_SS_CURSOR_FETCH			(SQL_DIAG_DFC_SS_BASE-10)
#define SQL_DIAG_DFC_SS_CURSOR_CLOSE			(SQL_DIAG_DFC_SS_BASE-11)
#define SQL_DIAG_DFC_SS_DEALLOCATE_CURSOR		(SQL_DIAG_DFC_SS_BASE-12)
#define SQL_DIAG_DFC_SS_DBCC					(SQL_DIAG_DFC_SS_BASE-13)
#define SQL_DIAG_DFC_SS_DISK					(SQL_DIAG_DFC_SS_BASE-14)
#define SQL_DIAG_DFC_SS_DROP_DATABASE			(SQL_DIAG_DFC_SS_BASE-15)
#define SQL_DIAG_DFC_SS_DROP_DEFAULT			(SQL_DIAG_DFC_SS_BASE-16)
#define SQL_DIAG_DFC_SS_DROP_PROCEDURE			(SQL_DIAG_DFC_SS_BASE-17)
#define SQL_DIAG_DFC_SS_DROP_RULE				(SQL_DIAG_DFC_SS_BASE-18)
#define SQL_DIAG_DFC_SS_DROP_TRIGGER			(SQL_DIAG_DFC_SS_BASE-19)
#define SQL_DIAG_DFC_SS_DUMP_DATABASE			(SQL_DIAG_DFC_SS_BASE-20)
#define SQL_DIAG_DFC_SS_DUMP_TABLE				(SQL_DIAG_DFC_SS_BASE-21)
#define SQL_DIAG_DFC_SS_DUMP_TRANSACTION		(SQL_DIAG_DFC_SS_BASE-22)
#define SQL_DIAG_DFC_SS_GOTO					(SQL_DIAG_DFC_SS_BASE-23)
#define SQL_DIAG_DFC_SS_INSERT_BULK 			(SQL_DIAG_DFC_SS_BASE-24)
#define SQL_DIAG_DFC_SS_KILL					(SQL_DIAG_DFC_SS_BASE-25)
#define SQL_DIAG_DFC_SS_LOAD_DATABASE			(SQL_DIAG_DFC_SS_BASE-26)
#define SQL_DIAG_DFC_SS_LOAD_HEADERONLY 		(SQL_DIAG_DFC_SS_BASE-27)
#define SQL_DIAG_DFC_SS_LOAD_TABLE				(SQL_DIAG_DFC_SS_BASE-28)
#define SQL_DIAG_DFC_SS_LOAD_TRANSACTION		(SQL_DIAG_DFC_SS_BASE-29)
#define SQL_DIAG_DFC_SS_PRINT					(SQL_DIAG_DFC_SS_BASE-30)
#define SQL_DIAG_DFC_SS_RAISERROR				(SQL_DIAG_DFC_SS_BASE-31)
#define SQL_DIAG_DFC_SS_READTEXT				(SQL_DIAG_DFC_SS_BASE-32)
#define SQL_DIAG_DFC_SS_RECONFIGURE 			(SQL_DIAG_DFC_SS_BASE-33)
#define SQL_DIAG_DFC_SS_RETURN					(SQL_DIAG_DFC_SS_BASE-34)
#define SQL_DIAG_DFC_SS_SELECT_INTO 			(SQL_DIAG_DFC_SS_BASE-35)
#define SQL_DIAG_DFC_SS_SET 					(SQL_DIAG_DFC_SS_BASE-36)
#define SQL_DIAG_DFC_SS_SET_IDENTITY_INSERT 	(SQL_DIAG_DFC_SS_BASE-37)
#define SQL_DIAG_DFC_SS_SET_ROW_COUNT			(SQL_DIAG_DFC_SS_BASE-38)
#define SQL_DIAG_DFC_SS_SET_STATISTICS			(SQL_DIAG_DFC_SS_BASE-39)
#define SQL_DIAG_DFC_SS_SET_TEXTSIZE			(SQL_DIAG_DFC_SS_BASE-40)
#define SQL_DIAG_DFC_SS_SETUSER 				(SQL_DIAG_DFC_SS_BASE-41)
#define SQL_DIAG_DFC_SS_SHUTDOWN				(SQL_DIAG_DFC_SS_BASE-42)
#define SQL_DIAG_DFC_SS_TRANS_BEGIN 			(SQL_DIAG_DFC_SS_BASE-43)
#define SQL_DIAG_DFC_SS_TRANS_COMMIT			(SQL_DIAG_DFC_SS_BASE-44)
#define SQL_DIAG_DFC_SS_TRANS_PREPARE			(SQL_DIAG_DFC_SS_BASE-45)
#define SQL_DIAG_DFC_SS_TRANS_ROLLBACK			(SQL_DIAG_DFC_SS_BASE-46)
#define SQL_DIAG_DFC_SS_TRANS_SAVE				(SQL_DIAG_DFC_SS_BASE-47)
#define SQL_DIAG_DFC_SS_TRUNCATE_TABLE			(SQL_DIAG_DFC_SS_BASE-48)
#define SQL_DIAG_DFC_SS_UPDATE_STATISTICS		(SQL_DIAG_DFC_SS_BASE-49)
#define SQL_DIAG_DFC_SS_UPDATETEXT				(SQL_DIAG_DFC_SS_BASE-50)
#define SQL_DIAG_DFC_SS_USE 					(SQL_DIAG_DFC_SS_BASE-51)
#define SQL_DIAG_DFC_SS_WAITFOR 				(SQL_DIAG_DFC_SS_BASE-52)
#define SQL_DIAG_DFC_SS_WRITETEXT				(SQL_DIAG_DFC_SS_BASE-53)
#define SQL_DIAG_DFC_SS_DENY					(SQL_DIAG_DFC_SS_BASE-54)
#define SQL_DIAG_DFC_SS_SET_XCTLVL				(SQL_DIAG_DFC_SS_BASE-55)

//	Severity codes for SQL_DIAG_SS_SEVERITY
#define	EX_ANY			0
#define	EX_INFO			10
#define EX_MAXISEVERITY EX_INFO
#define	EX_MISSING		11
#define	EX_TYPE			12
#define	EX_DEADLOCK		13
#define	EX_PERMIT		14
#define	EX_SYNTAX		15
#define	EX_USER			16
#define	EX_RESOURCE		17
#define	EX_INTOK		18
#define	MAXUSEVERITY	EX_INTOK
#define	EX_LIMIT		19
#define	EX_CMDFATAL		20
#define	MINFATALERR		EX_CMDFATAL
#define	EX_DBFATAL		21
#define	EX_TABCORRUPT	22
#define	EX_DBCORRUPT	23
#define	EX_HARDWARE		24
#define	EX_CONTROL		25

//	Internal server datatypes - used when binding to SQL_C_BINARY
#ifndef MAXNUMERICLEN	// Resolve ODS/DBLib conflicts
// DB-Library datatypes
#define DBMAXCHAR		(8000+1)	// Max length of DBVARBINARY and DBVARCHAR, etc. +1 for zero byte
#define MAXNAME 		(SQL_MAX_SQLSERVERNAME+1)	// Max server identifier length including zero byte

#ifdef UNICODE
typedef wchar_t			DBCHAR;
#else
typedef char            DBCHAR;
#endif
typedef unsigned char   DBBINARY;
typedef unsigned char   DBTINYINT;
typedef short           DBSMALLINT;
typedef unsigned short  DBUSMALLINT;
typedef double          DBFLT8;
typedef unsigned char   DBBIT;
typedef unsigned char   DBBOOL;
typedef float           DBFLT4;

typedef DBFLT4 DBREAL;
typedef UINT   DBUBOOL;

typedef struct dbvarychar
{
	DBSMALLINT  len;
	DBCHAR      str[DBMAXCHAR];
} DBVARYCHAR;

typedef struct dbvarybin
{
	DBSMALLINT  len;
	BYTE        array[DBMAXCHAR];
} DBVARYBIN;

typedef struct dbmoney
{						// Internal representation of MONEY data type
	LONG  mnyhigh;		// Money value *10,000 (High 32 bits/signed)
	ULONG mnylow;		// Money value *10,000 (Low 32 bits/unsigned)
} DBMONEY;

typedef struct dbdatetime
{						// Internal representation of DATETIME data type
	LONG  dtdays;		// No of days since Jan-1-1900 (maybe negative)
	ULONG dttime;		// No. of 300 hundredths of a second since midnight
} DBDATETIME;

typedef struct dbdatetime4
{						// Internal representation of SMALLDATETIME data type
	USHORT numdays; 	// No of days since Jan-1-1900
	USHORT nummins; 	// No. of minutes since midnight
} DBDATETIM4;

typedef LONG DBMONEY4;	// Internal representation of SMALLMONEY data type
						// Money value *10,000

#define DBNUM_PREC_TYPE BYTE
#define DBNUM_SCALE_TYPE BYTE
#define DBNUM_VAL_TYPE BYTE

#if (ODBCVER < 0x0300)
#define MAXNUMERICLEN 16

typedef struct dbnumeric
{							// Internal representation of NUMERIC data type
	DBNUM_PREC_TYPE   precision;			// Precision
	DBNUM_SCALE_TYPE  scale;				// Scale
	BYTE			  sign; 				// Sign (1 if positive, 0 if negative)
	DBNUM_VAL_TYPE	  val[MAXNUMERICLEN];	// Value
} DBNUMERIC;
typedef DBNUMERIC DBDECIMAL;// Internal representation of DECIMAL data type
#else	//	Use ODBC 3.0 definitions since same as DBLib
#define MAXNUMERICLEN SQL_MAX_NUMERIC_LEN
typedef SQL_NUMERIC_STRUCT DBNUMERIC;
typedef SQL_NUMERIC_STRUCT DBDECIMAL;
#endif

#endif //	MAXNUMERICLEN

#ifndef INT
typedef int INT;
typedef long            DBINT;
#ifndef _LPCBYTE_DEFINED
#define _LPCBYTE_DEFINED
typedef const LPBYTE	LPCBYTE;
#endif
typedef DBINT *			LPDBINT;
#endif

/*****************************************************************
 This struct is a global used for 
 gathering statistical data on the driver.
 Access to this structure is controlled via the
 pStatCrit;
******************************************************************/

typedef struct sqlperf
{
	// Application Profile Statistics
	DWORD TimerResolution;
	DWORD SQLidu;
	DWORD SQLiduRows;
	DWORD SQLSelects;
	DWORD SQLSelectRows;
	DWORD Transactions;
	DWORD SQLPrepares;
	DWORD ExecDirects;
	DWORD SQLExecutes;
	DWORD CursorOpens;
	DWORD CursorSize;
	DWORD CursorUsed;
	LDOUBLE PercentCursorUsed;
	LDOUBLE AvgFetchTime;
	LDOUBLE AvgCursorSize; 
	LDOUBLE AvgCursorUsed;
	DWORD SQLFetchTime;
	DWORD SQLFetchCount;
	DWORD CurrentStmtCount;
	DWORD MaxOpenStmt;
	DWORD SumOpenStmt;
	
	// Connection Statistics
	DWORD CurrentConnectionCount;
	DWORD MaxConnectionsOpened;
	DWORD SumConnectionsOpened;
	DWORD SumConnectiontime;
	LDOUBLE AvgTimeOpened;

	// Network Statistics
	DWORD ServerRndTrips;
	DWORD BuffersSent;
	DWORD BuffersRec;
	DWORD BytesSent;
	DWORD BytesRec;

	// Time Statistics;
	DWORD msExecutionTime;
	DWORD msNetWorkServerTime;

} 	SQLPERF;

// The following are options for SQL_COPT_SS_PERF_DATA and SQL_COPT_SS_PERF_QUERY
#define SQL_PERF_START	1			// Starts the driver sampling performance data.
#define SQL_PERF_STOP	2			// Stops the counters from sampling performance data.

// The following are defines for SQL_COPT_SS_PERF_DATA_LOG
#define SQL_SS_DL_DEFAULT	TEXT("C:\\STATS.LOG")

// The following are defines for SQL_COPT_SS_PERF_QUERY_LOG
#define SQL_SS_QL_DEFAULT	TEXT("C:\\QUERY.LOG")

// The following are defines for SQL_COPT_SS_PERF_QUERY_INTERVAL
#define SQL_SS_QI_DEFAULT	30000	//	30,000 milliseconds

//	ODBC BCP prototypes and defines

//	Return codes
#define SUCCEED 		1
#define FAIL			0
#define SUCCEED_ABORT	2
#define SUCCEED_ASYNC	3

//	Transfer directions
#define DB_IN			1	// Transfer from client to server
#define DB_OUT			2	// Transfer from server to client

//	bcp_control option
#define BCPMAXERRS		1	// Sets max errors allowed
#define BCPFIRST		2	// Sets first row to be copied out
#define BCPLAST 		3	// Sets number of rows to be copied out
#define BCPBATCH		4	// Sets input batch size
#define BCPKEEPNULLS	5	// Sets to insert NULLs for empty input values
#define BCPABORT		6	// Sets to have bcpexec return SUCCEED_ABORT
#define BCPODBC 		7	// Sets ODBC canonical character output
#define BCPKEEPIDENTITY	8	// Sets IDENTITY_INSERT on
#define BCP6xFILEFMT	9	// DEPRECATED: Sets 6x file format on
#define BCPHINTSA		10	// Sets server BCP hints (ANSI string)
#define BCPHINTSW		11	// Sets server BCP hints (UNICODE string)
#define BCPFILECP		12	// Sets clients code page for the file
#define BCPUNICODEFILE	13	// Sets that the file contains unicode header
#define BCPTEXTFILE		14	// Sets BCP mode to expect a text file and to detect Unicode or ANSI automatically
#define BCPFILEFMT		15	// Sets file format version

//	BCPFILECP values
//	Any valid code page that is installed on the client can be passed plus:
#define BCPFILECP_ACP	0	// Data in file is in Windows code page
#define BCPFILECP_OEMCP	1	// Data in file is in OEM code page (default)
#define BCPFILECP_RAW	(-1)// Data in file is in Server code page (no conversion)

//	bcp_collen definition
#define SQL_VARLEN_DATA (-10)	//	Use default length for column

// BCP functions
DBINT	SQL_API bcp_batch (HDBC);
RETCODE SQL_API bcp_bind (HDBC, LPCBYTE, INT, DBINT, LPCBYTE, INT, INT, INT);
RETCODE SQL_API bcp_colfmt (HDBC, INT, BYTE, INT, DBINT, LPCBYTE, INT, INT);
RETCODE SQL_API bcp_collen (HDBC, DBINT, INT);
RETCODE SQL_API bcp_colptr (HDBC, LPCBYTE, INT);
RETCODE SQL_API bcp_columns (HDBC, INT);
RETCODE SQL_API bcp_control (HDBC, INT, void *);
DBINT	SQL_API bcp_done (HDBC);
RETCODE SQL_API bcp_exec (HDBC, LPDBINT);
RETCODE SQL_API bcp_getcolfmt (HDBC, INT, INT, void *, INT, INT *);
RETCODE SQL_API bcp_initA (HDBC, LPCSTR, LPCSTR, LPCSTR, INT);
RETCODE SQL_API bcp_initW (HDBC, LPCWSTR, LPCWSTR, LPCWSTR, INT);
RETCODE SQL_API bcp_moretext (HDBC, DBINT, LPCBYTE);
RETCODE SQL_API bcp_readfmtA (HDBC, LPCSTR);
RETCODE SQL_API bcp_readfmtW (HDBC, LPCWSTR);
RETCODE SQL_API bcp_sendrow (HDBC);
RETCODE SQL_API bcp_setcolfmt (HDBC, INT, INT, void *, INT);
RETCODE SQL_API bcp_writefmtA (HDBC, LPCSTR);
RETCODE SQL_API bcp_writefmtW (HDBC, LPCWSTR);
CHAR *	SQL_API dbprtypeA (INT);
WCHAR * SQL_API dbprtypeW (INT);

#ifdef UNICODE
#define bcp_init		bcp_initW
#define bcp_readfmt		bcp_readfmtW
#define bcp_writefmt	bcp_writefmtW
#define dbprtype		dbprtypeW
#define BCPHINTS		BCPHINTSW

#else
#define bcp_init		bcp_initA
#define bcp_readfmt		bcp_readfmtA
#define bcp_writefmt	bcp_writefmtA
#define dbprtype		dbprtypeA
#define BCPHINTS		BCPHINTSA
#endif

//	SQL Server catalog extensions for distributed queries
SQLRETURN SQL_API SQLLinkedServers (SQLHSTMT);
SQLRETURN SQL_API SQLLinkedCatalogsA (SQLHSTMT, LPCSTR, SWORD);
SQLRETURN SQL_API SQLLinkedCatalogsW (SQLHSTMT, LPCWSTR, SWORD);

//	SQL Server extensions for server enumeration
HANDLE   SQL_API SQLInitEnumServers (WCHAR * pwchServerName,WCHAR *pwchInstanceName);
RETCODE  SQL_API SQLGetNextEnumeration (HANDLE hEnumHandle,BYTE * prgEnumData,INT * piEnumLength);
RETCODE  SQL_API SQLCloseEnumServers (HANDLE hEnumHandle);

#ifdef UNICODE
#define SQLLinkedCatalogs	SQLLinkedCatalogsW
#else
#define SQLLinkedCatalogs	SQLLinkedCatalogsA
#endif

//  BCP column format properties
#define BCP_FMT_TYPE			0x01
#define BCP_FMT_INDICATOR_LEN	0x02
#define BCP_FMT_DATA_LEN		0x03
#define	BCP_FMT_TERMINATOR		0x04
#define BCP_FMT_SERVER_COL		0x05
#define BCP_FMT_COLLATION		0x06
#define BCP_FMT_COLLATION_ID	0x07

//	The following options have been deprecated

#define SQL_FAST_CONNECT				(SQL_COPT_SS_BASE+0)
//	Defines for use with SQL_FAST_CONNECT - only useable before connecting
#define SQL_FC_OFF		0L			//	Fast connect is off
#define SQL_FC_ON		1L			//	Fast connect is on
#define SQL_FC_DEFAULT	SQL_FC_OFF
#define SQL_COPT_SS_ANSI_OEM			(SQL_COPT_SS_BASE+6)
#define SQL_AO_OFF						0L
#define SQL_AO_ON						1L
#define SQL_AO_DEFAULT					SQL_AO_OFF

//	Define old names
#define SQL_REMOTE_PWD					SQL_COPT_SS_REMOTE_PWD
#define SQL_USE_PROCEDURE_FOR_PREPARE	SQL_COPT_SS_USE_PROC_FOR_PREP
#define SQL_INTEGRATED_SECURITY 		SQL_COPT_SS_INTEGRATED_SECURITY
#define SQL_PRESERVE_CURSORS			SQL_COPT_SS_PRESERVE_CURSORS
#define SQL_TEXTPTR_LOGGING 			SQL_SOPT_SS_TEXTPTR_LOGGING
#define SQL_CA_SS_BASE_COLUMN_NAME		SQL_DESC_BASE_COLUMN_NAME
#define SQLDECIMALN						0x6a
#define SQLNUMERICN 					0x6c

#ifdef __cplusplus
}                                    /* End of extern "C" { */
#endif  /* __cplusplus */
#endif

//	End of odbcss.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\sqllib\inc\vdi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Jun 30 16:43:31 1999
 */
/* Compiler settings for vdi.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __vdi_h__
#define __vdi_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IClientVirtualDevice_FWD_DEFINED__
#define __IClientVirtualDevice_FWD_DEFINED__
typedef interface IClientVirtualDevice IClientVirtualDevice;
#endif 	/* __IClientVirtualDevice_FWD_DEFINED__ */


#ifndef __IClientVirtualDeviceSet_FWD_DEFINED__
#define __IClientVirtualDeviceSet_FWD_DEFINED__
typedef interface IClientVirtualDeviceSet IClientVirtualDeviceSet;
#endif 	/* __IClientVirtualDeviceSet_FWD_DEFINED__ */


#ifndef __IClientVirtualDeviceSet2_FWD_DEFINED__
#define __IClientVirtualDeviceSet2_FWD_DEFINED__
typedef interface IClientVirtualDeviceSet2 IClientVirtualDeviceSet2;
#endif 	/* __IClientVirtualDeviceSet2_FWD_DEFINED__ */


#ifndef __IServerVirtualDevice_FWD_DEFINED__
#define __IServerVirtualDevice_FWD_DEFINED__
typedef interface IServerVirtualDevice IServerVirtualDevice;
#endif 	/* __IServerVirtualDevice_FWD_DEFINED__ */


#ifndef __IServerVirtualDeviceSet_FWD_DEFINED__
#define __IServerVirtualDeviceSet_FWD_DEFINED__
typedef interface IServerVirtualDeviceSet IServerVirtualDeviceSet;
#endif 	/* __IServerVirtualDeviceSet_FWD_DEFINED__ */


#ifndef __IServerVirtualDeviceSet2_FWD_DEFINED__
#define __IServerVirtualDeviceSet2_FWD_DEFINED__
typedef interface IServerVirtualDeviceSet2 IServerVirtualDeviceSet2;
#endif 	/* __IServerVirtualDeviceSet2_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_vdi_0000 */
/* [local] */ 


#pragma pack(push, _vdi_h_)

#pragma pack(8)
struct  VDConfig
    {
    unsigned long deviceCount;
    unsigned long features;
    unsigned long prefixZoneSize;
    unsigned long alignment;
    unsigned long softFileMarkBlockSize;
    unsigned long EOMWarningSize;
    unsigned long serverTimeOut;
    unsigned long blockSize;
    unsigned long maxIODepth;
    unsigned long maxTransferSize;
    unsigned long bufferAreaSize;
    };

enum VDFeatures
    {	VDF_Removable	= 0x1,
	VDF_Rewind	= 0x2,
	VDF_Position	= 0x10,
	VDF_SkipBlocks	= 0x20,
	VDF_ReversePosition	= 0x40,
	VDF_Discard	= 0x80,
	VDF_FileMarks	= 0x100,
	VDF_RandomAccess	= 0x200,
	VDF_WriteMedia	= 0x10000,
	VDF_ReadMedia	= 0x20000,
	VDF_LatchStats	= 0x80000000,
	VDF_LikePipe	= 0,
	VDF_LikeTape	= VDF_FileMarks | VDF_Removable | VDF_Rewind | VDF_Position | VDF_SkipBlocks | VDF_ReversePosition,
	VDF_LikeDisk	= VDF_RandomAccess
    };

enum VDCommands
    {	VDC_Read	= 1,
	VDC_Write	= VDC_Read + 1,
	VDC_ClearError	= VDC_Write + 1,
	VDC_Rewind	= VDC_ClearError + 1,
	VDC_WriteMark	= VDC_Rewind + 1,
	VDC_SkipMarks	= VDC_WriteMark + 1,
	VDC_SkipBlocks	= VDC_SkipMarks + 1,
	VDC_Load	= VDC_SkipBlocks + 1,
	VDC_GetPosition	= VDC_Load + 1,
	VDC_SetPosition	= VDC_GetPosition + 1,
	VDC_Discard	= VDC_SetPosition + 1,
	VDC_Flush	= VDC_Discard + 1,
	VDC_Snapshot	= VDC_Flush + 1,
	VDC_MountSnapshot	= VDC_Snapshot + 1
    };

enum VDWhence
    {	VDC_Beginning	= 0,
	VDC_Current	= VDC_Beginning + 1,
	VDC_End	= VDC_Current + 1
    };
struct  VDC_Command
    {
    DWORD commandCode;
    DWORD size;
    DWORDLONG position;
    BYTE __RPC_FAR *buffer;
    };


extern RPC_IF_HANDLE __MIDL_itf_vdi_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdi_0000_v0_0_s_ifspec;

#ifndef __IClientVirtualDevice_INTERFACE_DEFINED__
#define __IClientVirtualDevice_INTERFACE_DEFINED__

/* interface IClientVirtualDevice */
/* [object][uuid] */ 


EXTERN_C const IID IID_IClientVirtualDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40700424-0080-11d2-851f-00c04fc21759")
    IClientVirtualDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCommand( 
            /* [in] */ DWORD dwTimeOut,
            /* [out] */ struct VDC_Command __RPC_FAR *__RPC_FAR *ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompleteCommand( 
            /* [in] */ struct VDC_Command __RPC_FAR *pCmd,
            /* [in] */ DWORD dwCompletionCode,
            /* [in] */ DWORD dwBytesTransferred,
            /* [in] */ DWORDLONG dwlPosition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClientVirtualDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IClientVirtualDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IClientVirtualDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IClientVirtualDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCommand )( 
            IClientVirtualDevice __RPC_FAR * This,
            /* [in] */ DWORD dwTimeOut,
            /* [out] */ struct VDC_Command __RPC_FAR *__RPC_FAR *ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompleteCommand )( 
            IClientVirtualDevice __RPC_FAR * This,
            /* [in] */ struct VDC_Command __RPC_FAR *pCmd,
            /* [in] */ DWORD dwCompletionCode,
            /* [in] */ DWORD dwBytesTransferred,
            /* [in] */ DWORDLONG dwlPosition);
        
        END_INTERFACE
    } IClientVirtualDeviceVtbl;

    interface IClientVirtualDevice
    {
        CONST_VTBL struct IClientVirtualDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClientVirtualDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClientVirtualDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClientVirtualDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClientVirtualDevice_GetCommand(This,dwTimeOut,ppCmd)	\
    (This)->lpVtbl -> GetCommand(This,dwTimeOut,ppCmd)

#define IClientVirtualDevice_CompleteCommand(This,pCmd,dwCompletionCode,dwBytesTransferred,dwlPosition)	\
    (This)->lpVtbl -> CompleteCommand(This,pCmd,dwCompletionCode,dwBytesTransferred,dwlPosition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClientVirtualDevice_GetCommand_Proxy( 
    IClientVirtualDevice __RPC_FAR * This,
    /* [in] */ DWORD dwTimeOut,
    /* [out] */ struct VDC_Command __RPC_FAR *__RPC_FAR *ppCmd);


void __RPC_STUB IClientVirtualDevice_GetCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDevice_CompleteCommand_Proxy( 
    IClientVirtualDevice __RPC_FAR * This,
    /* [in] */ struct VDC_Command __RPC_FAR *pCmd,
    /* [in] */ DWORD dwCompletionCode,
    /* [in] */ DWORD dwBytesTransferred,
    /* [in] */ DWORDLONG dwlPosition);


void __RPC_STUB IClientVirtualDevice_CompleteCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClientVirtualDevice_INTERFACE_DEFINED__ */


#ifndef __IClientVirtualDeviceSet_INTERFACE_DEFINED__
#define __IClientVirtualDeviceSet_INTERFACE_DEFINED__

/* interface IClientVirtualDeviceSet */
/* [object][uuid] */ 


EXTERN_C const IID IID_IClientVirtualDeviceSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40700425-0080-11d2-851f-00c04fc21759")
    IClientVirtualDeviceSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ LPCWSTR lpName,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConfiguration( 
            /* [in] */ DWORD dwTimeOut,
            /* [out] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenDevice( 
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IClientVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SignalAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenInSecondary( 
            /* [in] */ LPCWSTR lpSetName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferHandle( 
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [out] */ DWORD __RPC_FAR *pBufferHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapBufferHandle( 
            /* [in] */ DWORD dwBuffer,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClientVirtualDeviceSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IClientVirtualDeviceSet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IClientVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConfiguration )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ DWORD dwTimeOut,
            /* [out] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenDevice )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IClientVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IClientVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SignalAbort )( 
            IClientVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenInSecondary )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ LPCWSTR lpSetName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferHandle )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [out] */ DWORD __RPC_FAR *pBufferHandle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapBufferHandle )( 
            IClientVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ DWORD dwBuffer,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer);
        
        END_INTERFACE
    } IClientVirtualDeviceSetVtbl;

    interface IClientVirtualDeviceSet
    {
        CONST_VTBL struct IClientVirtualDeviceSetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClientVirtualDeviceSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClientVirtualDeviceSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClientVirtualDeviceSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClientVirtualDeviceSet_Create(This,lpName,pCfg)	\
    (This)->lpVtbl -> Create(This,lpName,pCfg)

#define IClientVirtualDeviceSet_GetConfiguration(This,dwTimeOut,pCfg)	\
    (This)->lpVtbl -> GetConfiguration(This,dwTimeOut,pCfg)

#define IClientVirtualDeviceSet_OpenDevice(This,lpName,ppVirtualDevice)	\
    (This)->lpVtbl -> OpenDevice(This,lpName,ppVirtualDevice)

#define IClientVirtualDeviceSet_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IClientVirtualDeviceSet_SignalAbort(This)	\
    (This)->lpVtbl -> SignalAbort(This)

#define IClientVirtualDeviceSet_OpenInSecondary(This,lpSetName)	\
    (This)->lpVtbl -> OpenInSecondary(This,lpSetName)

#define IClientVirtualDeviceSet_GetBufferHandle(This,pBuffer,pBufferHandle)	\
    (This)->lpVtbl -> GetBufferHandle(This,pBuffer,pBufferHandle)

#define IClientVirtualDeviceSet_MapBufferHandle(This,dwBuffer,ppBuffer)	\
    (This)->lpVtbl -> MapBufferHandle(This,dwBuffer,ppBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_Create_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ LPCWSTR lpName,
    /* [in] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IClientVirtualDeviceSet_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_GetConfiguration_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ DWORD dwTimeOut,
    /* [out] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IClientVirtualDeviceSet_GetConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_OpenDevice_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ LPCWSTR lpName,
    /* [out] */ IClientVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);


void __RPC_STUB IClientVirtualDeviceSet_OpenDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_Close_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This);


void __RPC_STUB IClientVirtualDeviceSet_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_SignalAbort_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This);


void __RPC_STUB IClientVirtualDeviceSet_SignalAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_OpenInSecondary_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ LPCWSTR lpSetName);


void __RPC_STUB IClientVirtualDeviceSet_OpenInSecondary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_GetBufferHandle_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pBuffer,
    /* [out] */ DWORD __RPC_FAR *pBufferHandle);


void __RPC_STUB IClientVirtualDeviceSet_GetBufferHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet_MapBufferHandle_Proxy( 
    IClientVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ DWORD dwBuffer,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer);


void __RPC_STUB IClientVirtualDeviceSet_MapBufferHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClientVirtualDeviceSet_INTERFACE_DEFINED__ */


#ifndef __IClientVirtualDeviceSet2_INTERFACE_DEFINED__
#define __IClientVirtualDeviceSet2_INTERFACE_DEFINED__

/* interface IClientVirtualDeviceSet2 */
/* [object][uuid] */ 


EXTERN_C const IID IID_IClientVirtualDeviceSet2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d0e6eb07-7a62-11d2-8573-00c04fc21759")
    IClientVirtualDeviceSet2 : public IClientVirtualDeviceSet
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateEx( 
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpName,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenInSecondaryEx( 
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpSetName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClientVirtualDeviceSet2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConfiguration )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ DWORD dwTimeOut,
            /* [out] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenDevice )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IClientVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SignalAbort )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenInSecondary )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpSetName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferHandle )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [out] */ DWORD __RPC_FAR *pBufferHandle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapBufferHandle )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ DWORD dwBuffer,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEx )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpName,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenInSecondaryEx )( 
            IClientVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpSetName);
        
        END_INTERFACE
    } IClientVirtualDeviceSet2Vtbl;

    interface IClientVirtualDeviceSet2
    {
        CONST_VTBL struct IClientVirtualDeviceSet2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClientVirtualDeviceSet2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClientVirtualDeviceSet2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClientVirtualDeviceSet2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClientVirtualDeviceSet2_Create(This,lpName,pCfg)	\
    (This)->lpVtbl -> Create(This,lpName,pCfg)

#define IClientVirtualDeviceSet2_GetConfiguration(This,dwTimeOut,pCfg)	\
    (This)->lpVtbl -> GetConfiguration(This,dwTimeOut,pCfg)

#define IClientVirtualDeviceSet2_OpenDevice(This,lpName,ppVirtualDevice)	\
    (This)->lpVtbl -> OpenDevice(This,lpName,ppVirtualDevice)

#define IClientVirtualDeviceSet2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IClientVirtualDeviceSet2_SignalAbort(This)	\
    (This)->lpVtbl -> SignalAbort(This)

#define IClientVirtualDeviceSet2_OpenInSecondary(This,lpSetName)	\
    (This)->lpVtbl -> OpenInSecondary(This,lpSetName)

#define IClientVirtualDeviceSet2_GetBufferHandle(This,pBuffer,pBufferHandle)	\
    (This)->lpVtbl -> GetBufferHandle(This,pBuffer,pBufferHandle)

#define IClientVirtualDeviceSet2_MapBufferHandle(This,dwBuffer,ppBuffer)	\
    (This)->lpVtbl -> MapBufferHandle(This,dwBuffer,ppBuffer)


#define IClientVirtualDeviceSet2_CreateEx(This,lpInstanceName,lpName,pCfg)	\
    (This)->lpVtbl -> CreateEx(This,lpInstanceName,lpName,pCfg)

#define IClientVirtualDeviceSet2_OpenInSecondaryEx(This,lpInstanceName,lpSetName)	\
    (This)->lpVtbl -> OpenInSecondaryEx(This,lpInstanceName,lpSetName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet2_CreateEx_Proxy( 
    IClientVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ LPCWSTR lpInstanceName,
    /* [in] */ LPCWSTR lpName,
    /* [in] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IClientVirtualDeviceSet2_CreateEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClientVirtualDeviceSet2_OpenInSecondaryEx_Proxy( 
    IClientVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ LPCWSTR lpInstanceName,
    /* [in] */ LPCWSTR lpSetName);


void __RPC_STUB IClientVirtualDeviceSet2_OpenInSecondaryEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClientVirtualDeviceSet2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vdi_0008 */
/* [local] */ 

struct  VDS_Command
    {
    DWORD commandCode;
    DWORD size;
    DWORDLONG inPosition;
    DWORDLONG outPosition;
    BYTE __RPC_FAR *buffer;
    BYTE __RPC_FAR *completionRoutine;
    BYTE __RPC_FAR *completionContext;
    DWORD completionCode;
    DWORD bytesTransferred;
    };


extern RPC_IF_HANDLE __MIDL_itf_vdi_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdi_0008_v0_0_s_ifspec;

#ifndef __IServerVirtualDevice_INTERFACE_DEFINED__
#define __IServerVirtualDevice_INTERFACE_DEFINED__

/* interface IServerVirtualDevice */
/* [object][uuid] */ 


EXTERN_C const IID IID_IServerVirtualDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5e7a131-a7bd-11d1-84c2-00c04fc21759")
    IServerVirtualDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SendCommand( 
            /* [in] */ struct VDS_Command __RPC_FAR *pCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseDevice( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVirtualDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServerVirtualDevice __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServerVirtualDevice __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServerVirtualDevice __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendCommand )( 
            IServerVirtualDevice __RPC_FAR * This,
            /* [in] */ struct VDS_Command __RPC_FAR *pCmd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseDevice )( 
            IServerVirtualDevice __RPC_FAR * This);
        
        END_INTERFACE
    } IServerVirtualDeviceVtbl;

    interface IServerVirtualDevice
    {
        CONST_VTBL struct IServerVirtualDeviceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServerVirtualDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServerVirtualDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServerVirtualDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServerVirtualDevice_SendCommand(This,pCmd)	\
    (This)->lpVtbl -> SendCommand(This,pCmd)

#define IServerVirtualDevice_CloseDevice(This)	\
    (This)->lpVtbl -> CloseDevice(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IServerVirtualDevice_SendCommand_Proxy( 
    IServerVirtualDevice __RPC_FAR * This,
    /* [in] */ struct VDS_Command __RPC_FAR *pCmd);


void __RPC_STUB IServerVirtualDevice_SendCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDevice_CloseDevice_Proxy( 
    IServerVirtualDevice __RPC_FAR * This);


void __RPC_STUB IServerVirtualDevice_CloseDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServerVirtualDevice_INTERFACE_DEFINED__ */


#ifndef __IServerVirtualDeviceSet_INTERFACE_DEFINED__
#define __IServerVirtualDeviceSet_INTERFACE_DEFINED__

/* interface IServerVirtualDeviceSet */
/* [object][uuid] */ 


EXTERN_C const IID IID_IServerVirtualDeviceSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5e7a132-a7bd-11d1-84c2-00c04fc21759")
    IServerVirtualDeviceSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ LPCWSTR lpName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConfiguration( 
            /* [out] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConfiguration( 
            /* [in] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteCompletionAgent( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenDevice( 
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateBuffer( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeBuffer( 
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ DWORD dwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSharedBuffer( 
            /* [in] */ BYTE __RPC_FAR *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SignalAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVirtualDeviceSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServerVirtualDeviceSet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServerVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConfiguration )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [out] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConfiguration )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecuteCompletionAgent )( 
            IServerVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenDevice )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateBuffer )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeBuffer )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ DWORD dwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSharedBuffer )( 
            IServerVirtualDeviceSet __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SignalAbort )( 
            IServerVirtualDeviceSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IServerVirtualDeviceSet __RPC_FAR * This);
        
        END_INTERFACE
    } IServerVirtualDeviceSetVtbl;

    interface IServerVirtualDeviceSet
    {
        CONST_VTBL struct IServerVirtualDeviceSetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServerVirtualDeviceSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServerVirtualDeviceSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServerVirtualDeviceSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServerVirtualDeviceSet_Open(This,lpName)	\
    (This)->lpVtbl -> Open(This,lpName)

#define IServerVirtualDeviceSet_GetConfiguration(This,pCfg)	\
    (This)->lpVtbl -> GetConfiguration(This,pCfg)

#define IServerVirtualDeviceSet_SetConfiguration(This,pCfg)	\
    (This)->lpVtbl -> SetConfiguration(This,pCfg)

#define IServerVirtualDeviceSet_ExecuteCompletionAgent(This)	\
    (This)->lpVtbl -> ExecuteCompletionAgent(This)

#define IServerVirtualDeviceSet_OpenDevice(This,lpName,ppVirtualDevice)	\
    (This)->lpVtbl -> OpenDevice(This,lpName,ppVirtualDevice)

#define IServerVirtualDeviceSet_AllocateBuffer(This,ppBuffer,dwSize,dwAlignment)	\
    (This)->lpVtbl -> AllocateBuffer(This,ppBuffer,dwSize,dwAlignment)

#define IServerVirtualDeviceSet_FreeBuffer(This,pBuffer,dwSize)	\
    (This)->lpVtbl -> FreeBuffer(This,pBuffer,dwSize)

#define IServerVirtualDeviceSet_IsSharedBuffer(This,pBuffer)	\
    (This)->lpVtbl -> IsSharedBuffer(This,pBuffer)

#define IServerVirtualDeviceSet_SignalAbort(This)	\
    (This)->lpVtbl -> SignalAbort(This)

#define IServerVirtualDeviceSet_Close(This)	\
    (This)->lpVtbl -> Close(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_Open_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ LPCWSTR lpName);


void __RPC_STUB IServerVirtualDeviceSet_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_GetConfiguration_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [out] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IServerVirtualDeviceSet_GetConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_SetConfiguration_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IServerVirtualDeviceSet_SetConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_ExecuteCompletionAgent_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet_ExecuteCompletionAgent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_OpenDevice_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ LPCWSTR lpName,
    /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);


void __RPC_STUB IServerVirtualDeviceSet_OpenDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_AllocateBuffer_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwAlignment);


void __RPC_STUB IServerVirtualDeviceSet_AllocateBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_FreeBuffer_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pBuffer,
    /* [in] */ DWORD dwSize);


void __RPC_STUB IServerVirtualDeviceSet_FreeBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_IsSharedBuffer_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pBuffer);


void __RPC_STUB IServerVirtualDeviceSet_IsSharedBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_SignalAbort_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet_SignalAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet_Close_Proxy( 
    IServerVirtualDeviceSet __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServerVirtualDeviceSet_INTERFACE_DEFINED__ */


#ifndef __IServerVirtualDeviceSet2_INTERFACE_DEFINED__
#define __IServerVirtualDeviceSet2_INTERFACE_DEFINED__

/* interface IServerVirtualDeviceSet2 */
/* [object][uuid] */ 


EXTERN_C const IID IID_IServerVirtualDeviceSet2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AECBD0D6-24C6-11d3-85B7-00C04FC21759")
    IServerVirtualDeviceSet2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpSetName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConfiguration( 
            /* [out] */ struct VDConfig __RPC_FAR *pCfg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginConfiguration( 
            /* [in] */ DWORD dwFeatures,
            /* [in] */ DWORD dwAlignment,
            /* [in] */ DWORD dwBlockSize,
            /* [in] */ DWORD dwMaxTransferSize,
            /* [in] */ DWORD dwTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndConfiguration( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestBuffers( 
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment,
            /* [in] */ DWORD dwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAvailableBuffers( 
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment,
            /* [out] */ DWORD __RPC_FAR *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteCompletionAgent( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenDevice( 
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateBuffer( 
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeBuffer( 
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ DWORD dwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSharedBuffer( 
            /* [in] */ BYTE __RPC_FAR *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SignalAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVirtualDeviceSet2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpInstanceName,
            /* [in] */ LPCWSTR lpSetName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConfiguration )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [out] */ struct VDConfig __RPC_FAR *pCfg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginConfiguration )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ DWORD dwFeatures,
            /* [in] */ DWORD dwAlignment,
            /* [in] */ DWORD dwBlockSize,
            /* [in] */ DWORD dwMaxTransferSize,
            /* [in] */ DWORD dwTimeout);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndConfiguration )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestBuffers )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment,
            /* [in] */ DWORD dwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryAvailableBuffers )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment,
            /* [out] */ DWORD __RPC_FAR *pCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecuteCompletionAgent )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenDevice )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpName,
            /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllocateBuffer )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
            /* [in] */ DWORD dwSize,
            /* [in] */ DWORD dwAlignment);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeBuffer )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ DWORD dwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSharedBuffer )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SignalAbort )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IServerVirtualDeviceSet2 __RPC_FAR * This);
        
        END_INTERFACE
    } IServerVirtualDeviceSet2Vtbl;

    interface IServerVirtualDeviceSet2
    {
        CONST_VTBL struct IServerVirtualDeviceSet2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServerVirtualDeviceSet2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServerVirtualDeviceSet2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServerVirtualDeviceSet2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServerVirtualDeviceSet2_Open(This,lpInstanceName,lpSetName)	\
    (This)->lpVtbl -> Open(This,lpInstanceName,lpSetName)

#define IServerVirtualDeviceSet2_GetConfiguration(This,pCfg)	\
    (This)->lpVtbl -> GetConfiguration(This,pCfg)

#define IServerVirtualDeviceSet2_BeginConfiguration(This,dwFeatures,dwAlignment,dwBlockSize,dwMaxTransferSize,dwTimeout)	\
    (This)->lpVtbl -> BeginConfiguration(This,dwFeatures,dwAlignment,dwBlockSize,dwMaxTransferSize,dwTimeout)

#define IServerVirtualDeviceSet2_EndConfiguration(This)	\
    (This)->lpVtbl -> EndConfiguration(This)

#define IServerVirtualDeviceSet2_RequestBuffers(This,dwSize,dwAlignment,dwCount)	\
    (This)->lpVtbl -> RequestBuffers(This,dwSize,dwAlignment,dwCount)

#define IServerVirtualDeviceSet2_QueryAvailableBuffers(This,dwSize,dwAlignment,pCount)	\
    (This)->lpVtbl -> QueryAvailableBuffers(This,dwSize,dwAlignment,pCount)

#define IServerVirtualDeviceSet2_ExecuteCompletionAgent(This)	\
    (This)->lpVtbl -> ExecuteCompletionAgent(This)

#define IServerVirtualDeviceSet2_OpenDevice(This,lpName,ppVirtualDevice)	\
    (This)->lpVtbl -> OpenDevice(This,lpName,ppVirtualDevice)

#define IServerVirtualDeviceSet2_AllocateBuffer(This,ppBuffer,dwSize,dwAlignment)	\
    (This)->lpVtbl -> AllocateBuffer(This,ppBuffer,dwSize,dwAlignment)

#define IServerVirtualDeviceSet2_FreeBuffer(This,pBuffer,dwSize)	\
    (This)->lpVtbl -> FreeBuffer(This,pBuffer,dwSize)

#define IServerVirtualDeviceSet2_IsSharedBuffer(This,pBuffer)	\
    (This)->lpVtbl -> IsSharedBuffer(This,pBuffer)

#define IServerVirtualDeviceSet2_SignalAbort(This)	\
    (This)->lpVtbl -> SignalAbort(This)

#define IServerVirtualDeviceSet2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_Open_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ LPCWSTR lpInstanceName,
    /* [in] */ LPCWSTR lpSetName);


void __RPC_STUB IServerVirtualDeviceSet2_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_GetConfiguration_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [out] */ struct VDConfig __RPC_FAR *pCfg);


void __RPC_STUB IServerVirtualDeviceSet2_GetConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_BeginConfiguration_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ DWORD dwFeatures,
    /* [in] */ DWORD dwAlignment,
    /* [in] */ DWORD dwBlockSize,
    /* [in] */ DWORD dwMaxTransferSize,
    /* [in] */ DWORD dwTimeout);


void __RPC_STUB IServerVirtualDeviceSet2_BeginConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_EndConfiguration_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet2_EndConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_RequestBuffers_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwAlignment,
    /* [in] */ DWORD dwCount);


void __RPC_STUB IServerVirtualDeviceSet2_RequestBuffers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_QueryAvailableBuffers_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwAlignment,
    /* [out] */ DWORD __RPC_FAR *pCount);


void __RPC_STUB IServerVirtualDeviceSet2_QueryAvailableBuffers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_ExecuteCompletionAgent_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet2_ExecuteCompletionAgent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_OpenDevice_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ LPCWSTR lpName,
    /* [out] */ IServerVirtualDevice __RPC_FAR *__RPC_FAR *ppVirtualDevice);


void __RPC_STUB IServerVirtualDeviceSet2_OpenDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_AllocateBuffer_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *ppBuffer,
    /* [in] */ DWORD dwSize,
    /* [in] */ DWORD dwAlignment);


void __RPC_STUB IServerVirtualDeviceSet2_AllocateBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_FreeBuffer_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pBuffer,
    /* [in] */ DWORD dwSize);


void __RPC_STUB IServerVirtualDeviceSet2_FreeBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_IsSharedBuffer_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pBuffer);


void __RPC_STUB IServerVirtualDeviceSet2_IsSharedBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_SignalAbort_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet2_SignalAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IServerVirtualDeviceSet2_Close_Proxy( 
    IServerVirtualDeviceSet2 __RPC_FAR * This);


void __RPC_STUB IServerVirtualDeviceSet2_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServerVirtualDeviceSet2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_vdi_0011 */
/* [local] */ 

#define CLSID_MSSQL_ClientVirtualDeviceSet IID_IClientVirtualDeviceSet
#define CLSID_MSSQL_ServerVirtualDeviceSet IID_IServerVirtualDeviceSet

#pragma pack(pop, _vdi_h_)


extern RPC_IF_HANDLE __MIDL_itf_vdi_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vdi_0011_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\vssadmin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vssadmin.rc
//
#define IDS_UNKNOWN_PROVIDER            102
#define IDS_PROV_TYPE_SYSTEM            103
#define IDS_PROV_TYPE_SOFTWARE          104
#define IDS_PROV_TYPE_HARDWARE          105
#define IDS_PROV_TYPE_UNKNOWN           106
#define IDS_WRITER_STATUS_STABLE        107
#define IDS_WRITER_STATUS_FAILED        108
#define IDS_WRITER_STATUS_UNKNOWN       109
#define IDS_WRITER_STATUS_WAITING_FOR_FREEZE        110
#define IDS_WRITER_STATUS_FROZEN        111
#define IDS_WRITER_STATUS_WAITING_FOR_COMPLETION    112
#define IDS_WRITER_ERROR_INCONSISTENTSNAPSHOT       113
#define IDS_WRITER_ERROR_OUTOFRESOURCES 114
#define IDS_WRITER_ERROR_TIMEOUT        115
#define IDS_WRITER_ERROR_RETRYABLE      116
#define IDS_WRITER_ERROR_NONRETRYABLE   117
#define IDS_WRITER_ERROR_UNEXPECTED     118
#define IDS_WRITER_ERROR_SUCCESS        119

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         301
#define _APS_NEXT_SYMED_VALUE           401
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\tracing\vs_trace.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    vs_trace.cxx

Abstract:

    This module defines the global debug\trace facilities used by the
	Long Term Storage service.
	
	Previous name: bsdebug.cxx

Author:


Revision History:
	Name		Date		Comments
    ssteiner    06/03/98    Made numerious changes and removed iostream
                            dependencies, added a few new registry entries and
                            added serialization.
	aoltean		06/06/99	Taken from atl30\atlbase.h in order to avoid linking ATL with BSCommon.lib
    ssteiner    05/15/00    Fixed bug #116688.  Added file locking to prevent multiple processes from
                            interferring with writing to the trace file.  Added code to place a UNICODE
                            BOM at the beginning of the trace file.
--*/

//
//  ***** Includes *****
//

#pragma warning(disable:4290)
#pragma warning(disable:4127)

#include <wtypes.h>
#pragma warning( disable: 4201 )    // C4201: nonstandard extension used : nameless struct/union
#include <winioctl.h>
#pragma warning( default: 4201 )	// C4201: nonstandard extension used : nameless struct/union
#include <winbase.h>
#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <vssmsg.h>

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"


#include <oleauto.h>
#include <stddef.h>
#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <atlconv.h>
#include <atlbase.h>
#include <ntverp.h>



#include "vs_inc.hxx"
#include "vs_idl.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "TRCTRCC"
//
////////////////////////////////////////////////////////////////////////

//
//  The following global, g_cDbgTrace must be declared BEFORE any of our
//  objects including _Module, since some of our static objects have destructors
//  that call trace methods.  The following pragma ensures that this
//  module's static objects are initialized before any of our other
//  static objects, assuming they don't use this same pragma.
//
#pragma warning(disable:4073) // ignore init_seg warning
#pragma init_seg(lib)

CBsDbgTrace g_cDbgTrace;


static VOID MakeFileUnicode(
    IN HANDLE hFile
    );

/////////////////////////////////////////////////////////////////////////////
// constants
//

const WCHAR	VSS_TRACINGKEYPATH[]	=
			L"SYSTEM\\CurrentControlSet\\Services\\VSS\\Debug\\Tracing";

const WCHAR	SETUP_KEY[]	=
			L"SYSTEM\\Setup";

const WCHAR	SETUP_INPROGRESS_REG[]	=
			L"SystemSetupInProgress";

const DWORD SETUP_INPROGRESS_VALUE = 1;


/////////////////////////////////////////////////////////////////////////////
//  Globals
//

//
//  NOTE: g_cDbgTrace, the global instance of this class is declared in
//  ltss\modules\ltssvc\src\ltssvc.cxx since we have to make sure
//  this object is the last one being destructed, otherwise possible
//  calls to this object will fail.
//

//
// Define a TLS var, stores the CLTermStg & intention list index.
// The index is a counter that is incremented and set for each thread
// coming into the service, in the CLTermStg::FinalConstruct method.
// The counter is also incremented and set for each intention list
// thread that is created by the service.
//
//  WARNING
//
//
//_declspec( thread ) DWORD CBsDbgTrace::m_dwContextNum = 0;

//
//  Queries a registry value name and if found sets dwValue to the value.
//  If the value name is not found, dwValue remains unchanged.
//
static DWORD
QuerySetValue (
    IN CRegKey &cRegKey,
    IN OUT DWORD &dwValue,
    IN LPCWSTR pwszValueName
    )
{
    DWORD dwReadValue = 0;
    DWORD dwResult = cRegKey.QueryValue( dwReadValue, pwszValueName );
    
    if ( dwResult == ERROR_SUCCESS )
        dwValue = dwReadValue;

    return dwResult;
}

//
//  Queries a registry value name and if found sets bValue to the value.
//  If the value name is not found, bValue remains unchanged.
//
static DWORD
QuerySetValue (
    IN CRegKey &cRegKey,
    IN OUT BOOL &bValue,
    IN LPCWSTR pwszValueName
    )
{
    DWORD dwReadValue = 0;
    DWORD dwResult = cRegKey.QueryValue( dwReadValue, pwszValueName );

    if ( dwResult == ERROR_SUCCESS )
        bValue = (BOOL)(dwReadValue != 0);

    return dwResult;
}

//
//  Queries a registry value name and if found sets wsValue to the value.
//  If the value name is not found, wsValue remains unchanged.
//
static DWORD
QuerySetValue (
    IN CRegKey &cRegKey,
    OUT LPWSTR &wsValue, // If allocated, must be freed before calling with ::VssFreeString
    IN LPCWSTR pwszValueName
    )
{
	WCHAR pszValueBuffer[_MAX_PATH];
    DWORD dwCount = _MAX_PATH;
    DWORD dwResult = cRegKey.QueryValue( pszValueBuffer, pwszValueName, &dwCount );

    BS_ASSERT(wsValue == NULL);
    if ( dwResult == ERROR_SUCCESS ) 
        ::VssDuplicateStr(wsValue, pszValueBuffer);

    return dwResult;
}

//
//  ***** class definitions *****
//


CBsDbgTrace::CBsDbgTrace()

/*++

Routine Description:

    Constructor method. Default values are given to operational
    parameters and overwritten using values from the registry if
    set.  Also prints out the trace file banner.

Arguments:

    NONE

Return Value:

    NONE

--*/
{
	m_bInitialized = false;
	m_bTracingEnabled = false;
	m_pcs = NULL;
    Initialize( TRUE );
}


CBsDbgTrace::~CBsDbgTrace()
/*++

Routine Description:

    Destructor method.  Prints out the last record in the NTMS


Arguments:

	LONG Indent - NOT USED YET [todo] this is the indentation indicator
	LONG Level - this is the debug trace level

Return Value:

    BOOL

--*/
{
    if ( !m_bInitialized )
        return;

    if ( m_bTracingEnabled ) {
        //
        //  Write out a finished tracing message
        //
        m_pcs->Enter();
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"****************************************************************" ) );
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  TRACING FINISHED - ProcessId: 0x%x, ContextId: 0x%x",
            m_dwCurrentProcessId, m_dwContextId ) );
        WCHAR pwszCurrentTime[128];
        time_t ltime;
        struct tm *pToday;
        time( &ltime );
        pToday = localtime( &ltime );
        wcsftime( pwszCurrentTime, sizeof pwszCurrentTime, L"%c", pToday );
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Current time: %s", pwszCurrentTime ) );
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Elapsed time: %d seconds", ltime- m_lTimeStarted ) );
   	    BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Command-line: %s", GetCommandLineW() ) );
        BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"****************************************************************" ) );
        m_pcs->Leave();

        //
        //  Make sure the file is flushed before leaving
        //
        if ( m_bTraceToFile ) {
            m_hTraceFile = ::CreateFile( m_pwszTraceFileName?
                                            m_pwszTraceFileName :
                                            BS_DBG_TRACE_FILE_NAME_DFLT,
                                         GENERIC_WRITE,
                                         FILE_SHARE_READ,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL );
            if ( m_hTraceFile != INVALID_HANDLE_VALUE ) {
                ::FlushFileBuffers( m_hTraceFile );
                ::CloseHandle( m_hTraceFile );
            }
        }
    }

    ::VssFreeString(m_pwszTraceFileName);

    //
    //  Delete the critical section
    //
    delete m_pcs;
    m_pcs = NULL;
    m_bInitialized = FALSE;
}

//
//  In certain cases the global trace object doesn't seem to get it's constructor called.
//  To fix this problem, this function was added to perform the initialization of the
//  object.  This function is called both in the constructor and the set context call
//  which all DLLs that use the trace class call.
//
VOID
CBsDbgTrace::Initialize(
    IN  BOOL bInConstructor
    )
{
    if ( !m_bInitialized )
    {
		try
			{
			//
			//  Get the critical section created first
			//
			m_pcs = new CBsCritSec;
			if ( m_pcs == NULL )
				throw E_OUTOFMEMORY;
			m_bInitialized = TRUE;

			m_bTracingEnabled       = FALSE;
			m_bTraceToFile          = BS_DBG_TRACE_TO_FILE_DFLT;
			m_bTraceToDebugger      = BS_DBG_TRACE_TO_DEBUGGER_DFLT;
			m_bTraceEnterExit       = BS_DBG_TRACE_ENTER_EXIT_DFLT;
			m_dwTraceLevel          = BS_DBG_TRACE_LEVEL_DFLT;
			m_bTraceFileLineInfo    = BS_DBG_TRACE_FILE_LINE_INFO_DFLT;
			m_bTraceTimestamp       = BS_DBG_TRACE_TIMESTAMP_DFLT;
			m_pwszTraceFileName     = NULL;
			m_bForceFlush           = BS_DBG_TRACE_FORCE_FLUSH_DFLT;
			m_dwTraceIndent         = 0;
			m_bInTrace              = FALSE;
			m_hTraceFile            = INVALID_HANDLE_VALUE;
			m_dwLineNum             = 0;
			m_dwCurrentProcessId    = GetCurrentProcessId();
			m_bIsDuringSetup        = FALSE;
			
			LARGE_INTEGER liTimer;
			if ( ::QueryPerformanceCounter( &liTimer ) )
				{
				//  Got high performance counter, use the low part
				m_dwContextId = liTimer.LowPart;
				}
			else
				{
				m_dwContextId = ::GetTickCount();
				}

			ReadRegistry();

			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"****************************************************************" ) );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  TRACING STARTED - ProcessId: 0x%x, ContextId: 0x%x",
				m_dwCurrentProcessId, m_dwContextId ) );
			if ( !bInConstructor )
				BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  N.B. NOT INITIALIZED BY THE CONSTRUCTOR" ) );

			WCHAR pwszCurrentTime[128];
			struct tm *pToday;
			time( &m_lTimeStarted );
			pToday = localtime( &m_lTimeStarted );
			wcsftime( pwszCurrentTime, sizeof pwszCurrentTime, L"%c", pToday );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Current time: %s", pwszCurrentTime ) );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Command-line: %s", GetCommandLineW() ) );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  Product version: %d.%d.%d.%d", VER_PRODUCTVERSION ) );
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"**  VSS SKU ID: 0x%02x", (UINT)CVssSKU::GetSKU() ) );			
			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"****************************************************************" ) );

			if ( CVssSKU::GetSKU() == CVssSKU::VSS_SKU_INVALID )
    			BsDebugTraceAlways( 0, DEBUG_TRACE_ALL, ( L"ERROR: Unable to determine the Windows SKU" ) );			    
			}
		catch(...)
			{
			delete m_pcs;
			m_pcs = NULL;
			m_bInitialized = false;
			m_bTracingEnabled = false;
			}
		}

}


BOOL
CBsDbgTrace::IsDuringSetup()
{
    return m_bIsDuringSetup;
}



HRESULT
CBsDbgTrace::ReadRegistry()
/*++

Routine Description:

    Tries to read debug specific values from the registry and adds
    the values if they don't exist.

Arguments:

    NONE

Return Value:

    HRESULT

--*/
{

	DWORD dwRes;
	CRegKey cRegKeySetup;
	CRegKey cRegKeyTracing;


    m_bTracingEnabled = FALSE;
    m_bIsDuringSetup = FALSE;
    
	//
	// Open the Setup key
	//

	dwRes = cRegKeySetup.Open( HKEY_LOCAL_MACHINE, SETUP_KEY, KEY_READ );
	if ( dwRes == ERROR_SUCCESS ) {
        DWORD dwSetupInProgress = 0;
        QuerySetValue( cRegKeySetup, dwSetupInProgress, SETUP_INPROGRESS_REG );
        m_bIsDuringSetup = ( dwSetupInProgress == SETUP_INPROGRESS_VALUE );
	}
	
	//
	// Open the VSS tracing key
	//

	dwRes = cRegKeyTracing.Open( HKEY_LOCAL_MACHINE, VSS_TRACINGKEYPATH, KEY_READ );
	if ( dwRes == ERROR_SUCCESS ) {
		
        // The name of the optional trace file
        QuerySetValue( cRegKeyTracing, m_pwszTraceFileName, BS_DBG_TRACE_FILE_NAME_REG );

        // The trace level determines what type of traciung will occur. Zero
        // indicates that no tracing will occur, and is the default.
        QuerySetValue( cRegKeyTracing, m_dwTraceLevel, BS_DBG_TRACE_LEVEL_REG );

        // The TraceEnterExit flag determines whether or not function entry & exit
        // information is output to the trace file & the debug output stream.
        QuerySetValue( cRegKeyTracing, m_bTraceEnterExit, BS_DBG_TRACE_ENTER_EXIT_REG );

        // The TraceToFile flag determines whether or not trace information is output to
        // the trace file. If this value is FALSE, no output is sent to the trace file.
        QuerySetValue( cRegKeyTracing, m_bTraceToFile, BS_DBG_TRACE_TO_FILE_REG );

        // The TraceToDebugger flag determines whether or not trace information is output
        // to the debugger. If this value is FALSE, no output is sent to the debugger.
        QuerySetValue( cRegKeyTracing, m_bTraceToDebugger, BS_DBG_TRACE_TO_DEBUGGER_REG );

        // The Timestamp flag determines whether or not timestamp
        // information is output to the trace file & the debug output stream.
        QuerySetValue( cRegKeyTracing, m_bTraceTimestamp, BS_DBG_TRACE_TIMESTAMP_REG );

        // The FileLineInfo flag determines whether or not the module file name
        // and line number information is output to the trace file & the debug
        // output stream.
        QuerySetValue( cRegKeyTracing, m_bTraceFileLineInfo, BS_DBG_TRACE_FILE_LINE_INFO_REG );

        // The TraceForceFlush flag specifies whether or not after each trace message is
        // written to the trace file a forced flush occurs.  If enabled, no trace records
        // are ever lost, however, performance is greatly reduced.
        QuerySetValue( cRegKeyTracing, m_bForceFlush, BS_DBG_TRACE_FORCE_FLUSH_REG );

        // Determine if tracing should be enabled
        if ( m_bTraceToDebugger || m_bTraceToFile )
            m_bTracingEnabled = TRUE;

	}

    return S_OK;
}


HRESULT
CBsDbgTrace::PrePrint(
    IN LPCWSTR pwszSourceFileName,
    IN DWORD dwLineNum,
    IN DWORD dwIndent,
    IN DWORD dwLevel,
    IN LPCWSTR pwszFunctionName,
    IN BOOL bTraceEnter
    )
/*++

Routine Description:

    Acquires the critical section so that other threads are
    now serialized.  Opens the trace file if necessary.
    N.B. Any A/V's in this code can cause a hang since the SEH translator function
    calls these trace functions.

Arguments:

    pszSourceFileName - Source file name of the module whose
        code called this method.
    dwLineNum - Line number in the source
    dwIndent - Number to increase or decrease the indendation level
    dwLevel - Trace level that specifies for which component
        the code resides in.
    pwszFunctionName - For entry/exit tracing.  Specifies the
        function name constains a call the a trace macro.
    bTraceEnter - True if this is a entry trace.

Return Value:

    HRESULT

--*/
{
    m_pcs->Enter();

    //
    //  Assume the trace macros have already filtered out traces based
    //  on m_bTracingEnabled and on the active trace level.
    //

    if ( m_bTracingEnabled && (dwLevel & m_dwTraceLevel) != 0) {
        if ( pwszSourceFileName == NULL )
            m_pwszSourceFileName = L"(Unknown source file)";
        else
        {
            //
            //  Keep only two levels deep of directory components
            //
            LPCWSTR pwszTemp = pwszSourceFileName + ::wcslen( pwszSourceFileName ) - 1;
            for ( int i = 0; pwszTemp > pwszSourceFileName && i < 3; ++i )
            {
                do
                {
                    --pwszTemp;
                }
                while( *pwszTemp != L'\\' && pwszTemp > pwszSourceFileName ) ;
            }
            if ( pwszTemp > pwszSourceFileName )
                m_pwszSourceFileName = pwszTemp + 1;
            else
                m_pwszSourceFileName = pwszSourceFileName;
        }

        m_pwszFunctionName   = pwszFunctionName;
        m_dwLineNum        = dwLineNum;
        m_bTraceEnter      = bTraceEnter;

        BS_ASSERT( m_hTraceFile == INVALID_HANDLE_VALUE );

        if ( m_bTraceToFile ) {
            m_hTraceFile = ::CreateFile( m_pwszTraceFileName?
                                            m_pwszTraceFileName :
                                            BS_DBG_TRACE_FILE_NAME_DFLT,
                                         GENERIC_WRITE,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL );
            if ( m_hTraceFile == INVALID_HANDLE_VALUE ) {
                //
                //  Error opening the file, print a message to the debugger if debugger
                //  tracing is enabled
                //
                Print( L"CBsDbgTrace::PrePrint: TRACING ERROR: Unable to open trace file, dwRet: %u", ::GetLastError() );
            } else {
                //
                //  Now lock the process from other processes and threads that are concurrently
                //  accessing the file.  Just lock the first byte of the file.
                //
                OVERLAPPED ovStart = { NULL, NULL, { 0, 0 }, 0 };
                if ( !::LockFileEx( m_hTraceFile,
                                    LOCKFILE_EXCLUSIVE_LOCK,
                                    0,
                                    1,
                                    0,
                                    &ovStart ) ) {
                    //
                    //  Tracing to file will be skipped for this record.  This should
                    //  never happen in practice.
                    //
                    ::CloseHandle( m_hTraceFile );
                    m_hTraceFile = INVALID_HANDLE_VALUE;

                    //
                    //  Try printing a trace message that will get to the debugger if debugger
                    //  tracing is enabled
                    //
                    Print( L"CBsDbgTrace::PrePrint: TRACING ERROR: Unable to lock trace file, skipping trace record, dwRet: %u", ::GetLastError() );
                } else {
                    //
                    //  If the file is new (empty) put the UNICODE BOM at the beginning of the file
                    //
                    LARGE_INTEGER liPointer;
                    if ( ::GetFileSizeEx( m_hTraceFile, &liPointer ) ) {
                        if ( liPointer.QuadPart == 0 )
                            ::MakeFileUnicode( m_hTraceFile );
                    }

                    //
                    //  Now move the file pointer to the end of the file
                    //
                    liPointer.QuadPart = 0;
                    if ( !::SetFilePointerEx( m_hTraceFile,
                                              liPointer,
                                              NULL,
                                              FILE_END ) ) {
                        //
                        //  Don't write to the file since it might overwrite valid records.
                        //  Tracing to file will be skipped for this record.  This should
                        //  never happen in practice.
                        //
                        ::CloseHandle( m_hTraceFile );
                        m_hTraceFile = INVALID_HANDLE_VALUE;

                        //
                        //  Try printing a trace message that will get to the debugger if debugger
                        //  tracing is enabled
                        //
                        Print( L"CBsDbgTrace::PrePrint: TRACING ERROR: Unable to set end of file, skipping trace record, dwRet: %u", ::GetLastError() );
                    }
                }
            }
        }

        m_bInTrace = TRUE;
    }

    return S_OK;
    UNREFERENCED_PARAMETER( dwIndent );
}

HRESULT
CBsDbgTrace::PostPrint(
    IN DWORD dwIndent
    )
/*++

Routine Description:

    Releases the critical section so that other threads
    can now call perform tracing.  Closes the trace file
    and resets variables.

Arguments:

    dwIndent - Number to increase or decrease the indendation level

Return Value:

    HRESULT

--*/
{
    if ( m_hTraceFile != INVALID_HANDLE_VALUE ) {
        OVERLAPPED ovStart = { NULL, NULL, { 0, 0 }, 0 };
        if ( !::UnlockFileEx( m_hTraceFile,
                              0,
                              1,
                              0,
                              &ovStart ) ) {
            Print( L"CBsDbgTrace::PrePrint: TRACING ERROR: Unable to unlock trace file, dwRet: %u", ::GetLastError() );
        }
        if ( m_bForceFlush )
            ::FlushFileBuffers( m_hTraceFile );
        ::CloseHandle( m_hTraceFile );
        m_hTraceFile = INVALID_HANDLE_VALUE;
    }

    m_pwszSourceFileName = NULL;
    m_pwszFunctionName = NULL;
    m_dwLineNum = 0;
    m_bInTrace  = FALSE;

    m_pcs->Leave();

    return S_OK;
    UNREFERENCED_PARAMETER( dwIndent );
}

HRESULT _cdecl
CBsDbgTrace::Print(
    IN LPCWSTR pwszFormatStr,
    IN ...
    )
/*++

Routine Description:

    Formats the trace message out to the trace file and/or debugger.

Arguments:

    pwszFormatStr - printf style format string
    ... - Arguments for the message

Return Value:

    HRESULT

--*/
{
    va_list pArg;

    if ( m_bInTrace ) {
        if ( m_bTraceTimestamp )
            swprintf( m_pwszOutBuf,
                      L"[%010u,",
                      GetTickCount() );
        else
            swprintf( m_pwszOutBuf,
                      L"[-," );

        swprintf( m_pwszOutBuf + wcslen( m_pwszOutBuf ),
                  L"0x%06x:0x%04x:0x%08x] ",
                  m_dwCurrentProcessId,
                  GetCurrentThreadId(),
                  m_dwContextId );

        if ( m_bTraceFileLineInfo )
          swprintf( m_pwszOutBuf + wcslen( m_pwszOutBuf ),
                    L"%s(%04u): ",
                    m_pwszSourceFileName,
                    m_dwLineNum );

        OutputString();

	    //
        // read the variable length parameter list into a formatted string
        //

        va_start( pArg, pwszFormatStr );
	    _vsnwprintf( m_pwszOutBuf, BS_DBG_OUT_BUF_SIZE-1, pwszFormatStr, pArg );
	    va_end( pArg );

        OutputString();

        //
        //  Finish up with a carriage return.
        //
        wcscpy( m_pwszOutBuf, L"\r\n" );
        OutputString();
    }

    return S_OK;
}

HRESULT _cdecl
CBsDbgTrace::PrintEnterExit(
    IN LPCWSTR pwszFormatStr,
    IN ...
    )
/*++

Routine Description:

    Formats the entry/exit trace message out to the trace file and/or debugger.

Arguments:

    pwszFormatStr - printf style format string
    ... - Arguments for the message

Return Value:

    HRESULT

--*/
{
    va_list pArg;

    if ( m_bInTrace ) {
        if ( m_bTraceTimestamp )
            swprintf( m_pwszOutBuf,
                      L"[%010u,",
                      GetTickCount() );
        else
            swprintf( m_pwszOutBuf,
                      L"[-," );

        swprintf( m_pwszOutBuf + wcslen( m_pwszOutBuf ),
                  L"0x%06x:0x%04x:0x%08x] %s {%s}: ",
                  m_dwCurrentProcessId,
                  GetCurrentThreadId(),
                  m_dwContextId,
                  m_bTraceEnter ? L"ENTER" : L"EXIT ",
                  m_pwszFunctionName );

        OutputString();

	    //
        // read the variable length parameter list into a formatted string
        //

        va_start( pArg, pwszFormatStr );
	    _vsnwprintf( m_pwszOutBuf, BS_DBG_OUT_BUF_SIZE-1, pwszFormatStr, pArg );
	    va_end( pArg );

        OutputString();

        //
        //  Finish up with a carriage return.
        //
        wcscpy( m_pwszOutBuf, L"\r\n" );
        OutputString();
    }

    return S_OK;
}

HRESULT
CBsDbgTrace::OutputString()
/*++

Routine Description:

    Prints the trace message out to the trace file and/or debugger.

Arguments:

    Assumes m_pwszOutBuf has the string to be printed.

Return Value:

    HRESULT

--*/
{
    //
    //  Make sure we didn't go off the end.  Can't use BS_ASSERT(), it
    //  will cause an deadlock.
    //
    _ASSERTE( wcslen( m_pwszOutBuf ) < BS_DBG_OUT_BUF_SIZE );

    //
    // Print to the debug stream for debug builds
    //
    if ( m_bTraceToDebugger )
        OutputDebugString( m_pwszOutBuf );

    //
    // If file tracing is enabled, dump to file
    //
    if ( m_hTraceFile != INVALID_HANDLE_VALUE ) {
        DWORD dwBytesWritten;
        ::WriteFile( m_hTraceFile,
                     m_pwszOutBuf,
                     (DWORD)(wcslen( m_pwszOutBuf ) * sizeof(WCHAR)),
                     &dwBytesWritten,
                     NULL );
    }

    return S_OK;
}


VOID CBsDbgTrace::SetContextNum(
    IN DWORD dwContextNum
    )
/*++

Routine Description:

    Use to be used to set the context number of the operation.  Now it is only
    used to determine if a DLL is loading using the trace class.

Arguments:

    LTS_CONTEXT_DELAYED_DLL - DLL is using the class object.

--*/
{
    if (dwContextNum == LTS_CONTEXT_DELAYED_DLL && !m_bInitialized )
    {
        Initialize();
    }

}


/*++

Routine Description:

    Puts the UNICODE UCS-2 BOM (Byte Order Mark) at the beginning of the file
    to let applications know that 1. this is a UCS-2 UNICODE file and 2. that
    the byte ordering is little-endian.

    Assumes the file is empty.

Arguments:

    hFile - Handle to the file

Return Value:

    <Enter return values here>

--*/
static VOID MakeFileUnicode(
    IN HANDLE hFile
    )
{
    BS_ASSERT( hFile != INVALID_HANDLE_VALUE );
    BYTE byteBOM[2] = { 0xFF, 0xFE };

    DWORD dwBytesWritten;
    ::WriteFile( hFile,
                 byteBOM,
                 sizeof byteBOM,
                 &dwBytesWritten,
                 NULL );
}


void __cdecl CVssFunctionTracer::TranslateError
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN HRESULT hr,
		IN LPCWSTR wszRoutine
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

--*/

    {
	if (hr == E_OUTOFMEMORY ||
		hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
		hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected in function %s", wszRoutine);
	else
		{
		LogError(VSS_ERROR_UNEXPECTED_CALLING_ROUTINE, dbgInfo << wszRoutine << hr);
		Throw(dbgInfo, E_UNEXPECTED, L"Unexpected error in routine %s.  hr = 0x%08lx", wszRoutine, hr);
		}
	}


void __cdecl CVssFunctionTracer::TranslateGenericError
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN HRESULT hr,
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

Throws:

    E_UNEXPECTED
        - on unrecognized error codes

--*/

    {
    WCHAR wszOutputBuffer[nVssMsgBufferSize + 1];
    va_list marker;
    va_start( marker, wszErrorTextFormat );
    _vsnwprintf( wszOutputBuffer, nVssMsgBufferSize, wszErrorTextFormat, marker );
    va_end( marker );

	if (hr == E_OUTOFMEMORY ||
		hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
		hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected. %s", wszOutputBuffer);
	else
		{
		LogError(VSS_ERROR_UNEXPECTED_ERRORCODE, dbgInfo << wszOutputBuffer << hr);
		Throw(dbgInfo, E_UNEXPECTED, L"Unexpected error: %s  [hr = 0x%08lx]", wszOutputBuffer, hr);
		}
	}



void __cdecl CVssFunctionTracer::TranslateProviderError
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN GUID ProviderID,
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

	The error is coming from a provider call

Throws:

    E_OUTOFMEMORY
    VSS_E_UNEXPECTED_PROVIDER_ERROR
        - Unexpected provider error. The error code is logged into the event log.
    VSS_E_PROVIDER_VETO
        - Expected provider error. The provider already did the logging.

--*/

    {
    WCHAR wszOutputBuffer[nVssMsgBufferSize + 1];
    va_list marker;
    va_start( marker, wszErrorTextFormat );
    _vsnwprintf( wszOutputBuffer, nVssMsgBufferSize, wszErrorTextFormat, marker );
    va_end( marker );

	if (hr == E_OUTOFMEMORY)
		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected. %s. Provider ID = " WSTR_GUID_FMT, 
		    wszOutputBuffer, GUID_PRINTF_ARG(ProviderID));
	else if (hr == E_INVALIDARG) {
		LogError(VSS_ERROR_CALLING_PROVIDER_ROUTINE_INVALIDARG, dbgInfo << ProviderID << wszOutputBuffer );
		Throw(dbgInfo, E_INVALIDARG, L"Invalid argument detected. %s. Provider ID = " WSTR_GUID_FMT, 
		    wszOutputBuffer, GUID_PRINTF_ARG(ProviderID));
	}
	else if (hr == VSS_E_PROVIDER_VETO)
		Throw(dbgInfo, VSS_E_PROVIDER_VETO, L"Provider veto detected. %s. Provider ID = " WSTR_GUID_FMT, 
		    wszOutputBuffer, GUID_PRINTF_ARG(ProviderID));
    else
		{
		LogError(VSS_ERROR_CALLING_PROVIDER_ROUTINE, dbgInfo << ProviderID << wszOutputBuffer << hr );
		Throw(dbgInfo, VSS_E_UNEXPECTED_PROVIDER_ERROR, 
		    L"Unexpected error calling a provider routine: %s  [hr = 0x%08lx] Provider ID = " WSTR_GUID_FMT, 
		    wszOutputBuffer, hr, GUID_PRINTF_ARG(ProviderID));
		}
	}



void __cdecl CVssFunctionTracer::TranslateInternalProviderError
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN HRESULT hrToBeTreated,
		IN HRESULT hrToBeThrown,
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

	The error is coming from a provider call

Throws:

    E_OUTOFMEMORY
    
    hrToBeThrown

--*/

    {
    WCHAR wszOutputBuffer[nVssMsgBufferSize + 1];
    va_list marker;
    va_start( marker, wszErrorTextFormat );
    _vsnwprintf( wszOutputBuffer, nVssMsgBufferSize, wszErrorTextFormat, marker );
    va_end( marker );

    hr = hrToBeTreated;

	if (hr == E_OUTOFMEMORY ||
		hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_SEARCH_HANDLES) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_LOG_SPACE) ||
		hr == HRESULT_FROM_WIN32(ERROR_DISK_FULL) ||
		hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES))
		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected. %s.", wszOutputBuffer);
	else if ( hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ||
	    hr == HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED) || 
		hr == HRESULT_FROM_WIN32(ERROR_NOT_READY))
	    {
		LogError(VSS_ERROR_DEVICE_NOT_CONNECTED, dbgInfo << wszOutputBuffer );
		Throw(dbgInfo, VSS_E_OBJECT_NOT_FOUND, 
		    L"Invalid device when calling a provider routine: %s", wszOutputBuffer);
    	}
    else
		{
		LogError(VSS_ERROR_UNEXPECTED_ERRORCODE, dbgInfo << wszOutputBuffer << hr );
		Throw(dbgInfo, hrToBeThrown, 
		    L"Unexpected error calling a provider routine: %s  [hr = 0x%08lx] ", wszOutputBuffer, hr );
		}
	}



void __cdecl CVssFunctionTracer::TranslateWriterReturnCode
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Translates an error into a well defined error code.  May log to
	the event log if the error is unexpected

	The error is coming from a writer call (CoCreteInstance of the writer COM+ event class
	or sending an event.

Throws:

    E_OUTOFMEMORY
    VSS_E_UNEXPECTED_WRITER_ERROR
        - Unexpected writer error. The error code is logged into the event log.

--*/

    {

    if (HrSucceeded()) {
        BS_ASSERT(hr == S_OK || hr == EVENT_S_NOSUBSCRIBERS || hr == EVENT_S_SOME_SUBSCRIBERS_FAILED);
        hr = S_OK;
        return;
    }
    
    WCHAR wszOutputBuffer[nVssMsgBufferSize + 1];
    va_list marker;
    va_start( marker, wszErrorTextFormat );
    _vsnwprintf( wszOutputBuffer, nVssMsgBufferSize, wszErrorTextFormat, marker );
    va_end( marker );
    
    if (hr == EVENT_E_ALL_SUBSCRIBERS_FAILED) {
		Warning( VSSDBG_COORD, L"%s event failed at one writer. hr = 0x%08lx", wszOutputBuffer, hr);
		// ignore the error;
        return;
        }
	else if (hr == E_OUTOFMEMORY)
		Throw(dbgInfo, E_OUTOFMEMORY, L"Out of memory detected. %s.", wszOutputBuffer);
    else
		{
		LogError(VSS_ERROR_UNEXPECTED_WRITER_ERROR, dbgInfo << wszOutputBuffer << hr );
		Throw(dbgInfo, VSS_E_UNEXPECTED_WRITER_ERROR, 
		    L"Unexpected error calling a provider routine: %s  [hr = 0x%08lx] ", wszOutputBuffer, hr);
		}
    }



void __cdecl CVssFunctionTracer::LogGenericWarning
		(
		IN CVssDebugInfo dbgInfo,          // Caller debugging info
		IN LPCWSTR wszErrorTextFormat,
		IN ...
		)
/*++

Routine Description:

    Log a generic warning.

--*/

    {
    WCHAR wszOutputBuffer[nVssMsgBufferSize + 1];
    va_list marker;
    va_start( marker, wszErrorTextFormat );
    _vsnwprintf( wszOutputBuffer, nVssMsgBufferSize, wszErrorTextFormat, marker );
    va_end( marker );

	LogError(VSS_WARNING_UNEXPECTED, dbgInfo << wszOutputBuffer << hr, EVENTLOG_WARNING_TYPE);
	Trace(dbgInfo, L"WARNING: %s [hr = 0x%08lx]", wszOutputBuffer, hr);
	}


// This method must be called prior to calling a CoCreateInstance that may start VSS
void CVssFunctionTracer::LogVssStartupAttempt()
{
    // the name of the Volume Snapshot Service
    const LPCWSTR wszVssvcServiceName = L"VSS";
    
    SC_HANDLE		shSCManager = NULL;
    SC_HANDLE		shSCService = NULL;

    try
	{
        //
        //  Check to see if VSSVC is running. If not, we are putting an entry into the trace log if enabled.
        //

    	// Connect to the local service control manager
        shSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_CONNECT);
        if (!shSCManager) 
            TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(GetLastError()), 
                L"OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT)");

    	// Get a handle to the service
        shSCService = OpenService (shSCManager, wszVssvcServiceName, SERVICE_QUERY_STATUS);
        if (!shSCService) 
            TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(GetLastError()), 
                L" OpenService (shSCManager, \'%s\', SERVICE_QUERY_STATUS)", wszVssvcServiceName);

    	// Now query the service to see what state it is in at the moment.
        SERVICE_STATUS	sSStat;
        if (!QueryServiceStatus (shSCService, &sSStat))
            TranslateGenericError(VSSDBG_GEN, HRESULT_FROM_WIN32(GetLastError()), 
                L"QueryServiceStatus (shSCService, &sSStat)");

        // If the service is not running, then we will put an informational error log entry 
        // if (sSStat.dwCurrentState != SERVICE_RUNNING)
        //     LogError(VSS_INFO_SERVICE_STARTUP, 
        //         VSSDBG_GEN << GetCommandLineW() << (HRESULT)sSStat.dwCurrentState, 
        //         EVENTLOG_INFORMATION_TYPE);
        if (sSStat.dwCurrentState != SERVICE_RUNNING)
            Trace( VSSDBG_GEN, 
                L"Volume Snapshots Service information: Service starting at request of process '%s'. [0x%08x]",
                GetCommandLineW(), sSStat.dwCurrentState );        
	} VSS_STANDARD_CATCH ((*this));

    // Close handles
    if (NULL != shSCService) CloseServiceHandle (shSCService);
    if (NULL != shSCManager) CloseServiceHandle (shSCManager);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\sqlwriter\sqlwriter.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module sqlwriter.cpp | Implementation of Writer
    @end

Author:

    Brian Berkowitz  [brianb]  04/17/2000

TBD:
	

Revision History:

	Name		Date		Comments
	brianb		04/17/2000	created
	brianb		04/20/2000	integrated with coordinator
	brainb		05/05/2000	add OnIdentify support
	mikejohn	06/01/2000	fix minor but confusing typos in trace messages
	mikejohn	09/19/2000	176860: Add the missing calling convention specifiers

--*/
#include <stdafx.hxx>
#include "vs_idl.hxx"

#include "vswriter.h"
#include "sqlsnap.h"
#include "sqlwriter.h"
#include "vs_seh.hxx"
#include "vs_trace.hxx"
#include "vs_debug.hxx"
#include "allerror.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "SQWWRTRC"
//
////////////////////////////////////////////////////////////////////////

static LPCWSTR x_wszSqlServerWriter = L"SqlServerWriter";

static GUID s_writerId =
	{
	0xf8544ac1, 0x0611, 0x4fa5, 0xb0, 0x4b, 0xf7, 0xee, 0x00, 0xb0, 0x32, 0x77
	};

static LPCWSTR s_wszWriterName = L"MSDEWriter";

HRESULT STDMETHODCALLTYPE CSqlWriter::Initialize()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CSqlWriter::Initialize");

	try
		{
		InitSQLEnvironment();
		m_pSqlSnapshot = CreateSqlSnapshot();
		if (m_pSqlSnapshot == NULL)
			ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Failed to allocate CSqlSnapshot object.");

		ft.hr = CVssWriter::Initialize
			(
			s_writerId,
			s_wszWriterName,
			VSS_UT_SYSTEMSERVICE,
			VSS_ST_TRANSACTEDDB,
			VSS_APP_BACK_END,
			60000
			);

        if (ft.HrFailed())
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"Failed to initialize the Sql writer.  hr = 0x%08lx",
				ft.hr
				);

		ft.hr = Subscribe();
		if (ft.HrFailed())
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"Subscribing the Sql server writer failed. hr = %0x08lx",
				ft.hr
				);
		}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed()  && m_pSqlSnapshot)
		{
		delete m_pSqlSnapshot;
		m_pSqlSnapshot = NULL;
		}

	return ft.hr;
	}

HRESULT STDMETHODCALLTYPE CSqlWriter::Uninitialize()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CSqlWriter::Uninitialize");

	return Unsubscribe();
	}
	

bool STDMETHODCALLTYPE CSqlWriter::OnPrepareSnapshot()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CSqlWriter::OnPrepareSnapshot");


	try
		{
		BS_ASSERT(!m_fFrozen);
		ft.hr = m_pSqlSnapshot->Prepare(this);
		}
	VSS_STANDARD_CATCH(ft)

	TranslateWriterError(ft.hr);

	return !ft.HrFailed();
	}



bool STDMETHODCALLTYPE CSqlWriter::OnFreeze()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CSqlWriter::OnFreeze");


	try
		{
		BS_ASSERT(!m_fFrozen);
		ft.hr = m_pSqlSnapshot->Freeze();
		if (!ft.HrFailed())
			m_fFrozen = true;
		}
	VSS_STANDARD_CATCH(ft)

	TranslateWriterError(ft.hr);

	return !ft.HrFailed();
	}


bool STDMETHODCALLTYPE CSqlWriter::OnThaw()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CSqlWriter::OnThaw");


	try
		{
		if (m_fFrozen)
			{
			m_fFrozen = false;
			ft.hr = m_pSqlSnapshot->Thaw();
			}
		}
	VSS_STANDARD_CATCH(ft)

	TranslateWriterError(ft.hr);

	return !ft.HrFailed();
	}


bool STDMETHODCALLTYPE CSqlWriter::OnAbort()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CSqlWriter::OnAbort");


	try
		{
		if (m_fFrozen)
			{
			m_fFrozen = false;
			ft.hr = m_pSqlSnapshot->Thaw();
			}
		}
	VSS_STANDARD_CATCH(ft)

	return !ft.HrFailed();
	}

bool CSqlWriter::IsPathInSnapshot(const WCHAR *wszPath) throw()
	{
	return IsPathAffected(wszPath);
	}


// handle request for WRITER_METADATA
// implements CVssWriter::OnIdentify
bool STDMETHODCALLTYPE CSqlWriter::OnIdentify(IVssCreateWriterMetadata *pMetadata)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CSqlWriter::OnIdentify");

	ServerInfo server;
	DatabaseInfo database;
	DatabaseFileInfo file;

	// create enumerator
	CSqlEnumerator *pEnumServers = CreateSqlEnumerator();
	CSqlEnumerator *pEnumDatabases = NULL;
	CSqlEnumerator *pEnumFiles = NULL;
	try
		{
		if (pEnumServers == NULL)
			ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Failed to create CSqlEnumerator");

		// find first server
		ft.hr = pEnumServers->FirstServer(&server);
		while(ft.hr != DB_S_ENDOFROWSET)
			{
			// check for error code
			if (ft.HrFailed())
				ft.Throw
					(
					VSSDBG_GEN,
					E_UNEXPECTED,
					L"Enumerating database servers failed.  hr = 0x%08lx",
					ft.hr
					);

            // only look at server if it is online
			if (server.isOnline)
				{
				// recreate enumerator for databases
				BS_ASSERT(pEnumDatabases == NULL);
				pEnumDatabases = CreateSqlEnumerator();
				if (pEnumDatabases == NULL)
					ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Failed to create CSqlEnumerator");

				// find first database
				ft.hr = pEnumDatabases->FirstDatabase(server.name, &database);


				while(ft.hr != DB_S_ENDOFROWSET)
					{
					// check for error
					if (ft.HrFailed())
						ft.Throw
							(
							VSSDBG_GEN,
							E_UNEXPECTED,
							L"Enumerating databases failed.  hr = 0x%08lx",
							ft.hr
							);

                    // only include database if it supports Freeze
					if (database.supportsFreeze &&
						wcscmp(database.name, L"tempdb") != 0)
						{
						// add database component
						ft.hr = pMetadata->AddComponent
									(
									VSS_CT_DATABASE,		// component type
									server.name,			// logical path	
									database.name,			// component name
									NULL,					// caption
									NULL,					// pbIcon
									0,						// cbIcon
									false,					// bRestoreMetadata
									false,					// bNotifyOnBackupComplete
									false					// bSelectable
									);

                        if (ft.HrFailed())
							ft.Throw
								(
								VSSDBG_GEN,
								E_UNEXPECTED,
								L"IVssCreateWriterMetadata::AddComponent failed.  hr = 0x%08lx",
								ft.hr
								);

						// recreate enumerator for files
						BS_ASSERT(pEnumFiles == NULL);
						pEnumFiles = CreateSqlEnumerator();
						if (pEnumFiles == NULL)
							ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Failed to create CSqlEnumerator");


                        // findfirst database file
                        ft.hr = pEnumFiles->FirstFile(server.name, database.name, &file);
						while(ft.hr != DB_S_ENDOFROWSET)
							{
							// check for error
							if (ft.HrFailed())
								ft.Throw
									(
									VSSDBG_GEN,
									E_UNEXPECTED,
									L"Enumerating database files failed.  hr = 0x%08lx",
									ft.hr
									);

                            // split file name into separate path
							// and filename components.  Path is everything
							// before the last backslash.
							WCHAR logicalPath[MAX_PATH];
							WCHAR *pFileName = file.name + wcslen(file.name);
							while(--pFileName > file.name)
								{
								if (*pFileName == '\\')
									break;
								}

							// if no backslash, then there is no path
							if (pFileName == file.name)
								logicalPath[0] = '\0';
							else
								{
								// extract path
								size_t cwc = wcslen(file.name) - wcslen(pFileName);
								memcpy(logicalPath, file.name, cwc*sizeof(WCHAR));
								logicalPath[cwc] = L'\0';
								pFileName++;
								}


							if (file.isLogFile)
								// log file
								ft.hr = pMetadata->AddDatabaseLogFiles
												(
												server.name,
												database.name,
												logicalPath,
												pFileName
												);
							else
								// physical database file
								ft.hr = pMetadata->AddDatabaseLogFiles
												(
												server.name,
												database.name,
												logicalPath,
												pFileName
												);

                            // continue at next file
							ft.hr = pEnumFiles->NextFile(&file);
							}

						delete pEnumFiles;
						pEnumFiles = NULL;
						}

					// continue at next database
					ft.hr = pEnumDatabases->NextDatabase(&database);
					}

				delete pEnumDatabases;
				pEnumDatabases = NULL;
				}

			// continue at next server
			ft.hr = pEnumServers->NextServer(&server);
			}
		}
	VSS_STANDARD_CATCH(ft)

	TranslateWriterError(ft.hr);

	delete pEnumServers;
	delete pEnumDatabases;
	delete pEnumFiles;

	return ft.HrFailed() ? false : true;
	}

// translate a sql writer error code into a writer error
void CSqlWriter::TranslateWriterError(HRESULT hr)
	{
	switch(hr)
		{
		default:
			SetWriterFailure(VSS_E_WRITERERROR_NONRETRYABLE);
			break;

        case S_OK:
			break;

        case E_OUTOFMEMORY:
        case HRESULT_FROM_WIN32(ERROR_DISK_FULL):
        case HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES):
        case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
        case HRESULT_FROM_WIN32(ERROR_NO_MORE_USER_HANDLES):
			SetWriterFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
			break;

        case HRESULT_FROM_WIN32(E_SQLLIB_TORN_DB):
			SetWriterFailure(VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT);
			break;
        }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\vssadmin\vssadmin.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module vssadmin.cpp | Implementation of the Volume Snapshots demo
    @end

Author:

    Adi Oltean  [aoltean]  09/17/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/17/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes

// The rest of includes are specified here
#include "vssadmin.h"

#include <locale.h>
#include <winnlsp.h>  // in public\internal\base\inc

BOOL AssertPrivilege( 
    IN LPCWSTR privName 
    );

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "ADMVADMC"
//
////////////////////////////////////////////////////////////////////////

//
//  List of hard coded option names.  If you add options, make sure to keep this
//  list in alphabetical order.
//
const SVssAdmOption g_asAdmOptions[] =
{
    { VSSADM_O_AUTORETRY,      L"AutoRetry",      VSSADM_OT_NUM  },
    { VSSADM_O_EXPOSE_USING,   L"ExposeUsing",    VSSADM_OT_STR  },
    { VSSADM_O_FOR,            L"For",            VSSADM_OT_STR  },
    { VSSADM_O_MAXSIZE,        L"MaxSize",        VSSADM_OT_NUM  },
    { VSSADM_O_OLDEST,         L"Oldest",         VSSADM_OT_BOOL },
    { VSSADM_O_ON,             L"On",             VSSADM_OT_STR  },
    { VSSADM_O_PROVIDER,       L"Provider",       VSSADM_OT_STR  },
    { VSSADM_O_QUIET,          L"Quiet",          VSSADM_OT_BOOL },
    { VSSADM_O_SET,            L"Set",            VSSADM_OT_STR  },
    { VSSADM_O_SHAREPATH,      L"SharePath",      VSSADM_OT_STR  },
    { VSSADM_O_SNAPSHOT,       L"Snapshot",       VSSADM_OT_STR  },
    { VSSADM_O_SNAPTYPE,       L"Type",           VSSADM_OT_STR  },
    { VSSADM_O_INVALID,        NULL,              VSSADM_OT_BOOL }
};

#define SKU_C   CVssSKU::VSS_SKU_CLIENT
#define SKU_S   CVssSKU::VSS_SKU_SERVER
#define SKU_N   CVssSKU::VSS_SKU_NAS
#define SKU_I   CVssSKU::VSS_SKU_INVALID

#define SKU_A   ( SKU_C | SKU_S | SKU_N )
#define SKU_SN  ( SKU_S | SKU_N )
//
//  List of vssadmin commands.  Keep this in alphabetical order.  Also, keep the option flags in the same order as
//  the EVssAdmOption and g_asAdmOptions.
//
const SVssAdmCommandsEntry g_asAdmCommands[] = 
{ //  Major      Minor               Option                     SKUs    MsgGen                          MsgDetail                       bShowSSTypes  AutoRtry ExpUsing For      MaxSize  Oldest   On       Provider Quiet    Set      ShrePath Snapshot Type 
    { L"Add",    L"SnapshotStorage", VSSADM_C_ADD_DIFFAREA,     SKU_SN, MSG_USAGE_GEN_ADD_DIFFAREA,     MSG_USAGE_DTL_ADD_DIFFAREA,     FALSE,      { V_NO,    V_NO,    V_YES,   V_OPT,   V_NO,    V_YES,   V_YES,   V_NO,    V_NO,    V_NO,    V_NO,    V_NO    } },
    { L"Create", L"Snapshot",        VSSADM_C_CREATE_SNAPSHOT,  SKU_SN, MSG_USAGE_GEN_CREATE_SNAPSHOT,  MSG_USAGE_DTL_CREATE_SNAPSHOT,  TRUE,       { V_OPT,    V_NO,    V_YES,   V_NO,    V_NO,    V_NO,    V_OPT,   V_NO,    V_NO,    V_NO,    V_NO,    V_YES   } },
    { L"Delete", L"Snapshots",       VSSADM_C_DELETE_SNAPSHOTS, SKU_SN, MSG_USAGE_GEN_DELETE_SNAPSHOTS, MSG_USAGE_DTL_DELETE_SNAPSHOTS, TRUE,       { V_NO,    V_NO,    V_OPT,   V_NO,    V_OPT,   V_NO,    V_NO,    V_OPT,   V_NO,    V_NO,    V_OPT,   V_OPT   } },
    { L"Delete", L"SnapshotStorage", VSSADM_C_DELETE_DIFFAREAS, SKU_SN, MSG_USAGE_GEN_DELETE_DIFFAREAS, MSG_USAGE_DTL_DELETE_DIFFAREAS, FALSE,      { V_NO,    V_NO,    V_YES,   V_NO,    V_NO,    V_OPT,   V_YES,   V_OPT,   V_NO,    V_NO,    V_NO,    V_NO    } },
    { L"Expose", L"Snapshot",        VSSADM_C_EXPOSE_SNAPSHOT,  SKU_SN, MSG_USAGE_GEN_EXPOSE_SNAPSHOT,  MSG_USAGE_DTL_EXPOSE_SNAPSHOT,  FALSE,      { V_NO,   V_OPT,   V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_OPT,   V_YES,   V_NO    } },
    { L"List",   L"Providers",       VSSADM_C_LIST_PROVIDERS,   SKU_A,  MSG_USAGE_GEN_LIST_PROVIDERS,   MSG_USAGE_DTL_LIST_PROVIDERS,   FALSE,      { V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO    } },
    { L"List",   L"Snapshots",       VSSADM_C_LIST_SNAPSHOTS,   SKU_A,  MSG_USAGE_GEN_LIST_SNAPSHOTS,   MSG_USAGE_DTL_LIST_SNAPSHOTS,   TRUE,       { V_NO,    V_NO,    V_OPT,   V_NO,    V_NO,    V_NO,    V_OPT,   V_NO,    V_OPT,   V_NO,    V_OPT,   V_OPT   } },
    { L"List",   L"SnapshotStorage", VSSADM_C_LIST_DIFFAREAS,   SKU_SN, MSG_USAGE_GEN_LIST_DIFFAREAS,   MSG_USAGE_DTL_LIST_DIFFAREAS,   FALSE,      { V_NO,    V_NO,    V_OPT,   V_NO,    V_NO,    V_OPT,   V_YES,   V_NO,    V_NO,    V_NO,    V_NO,    V_NO    } },
    { L"List",   L"Volumes",         VSSADM_C_LIST_VOLUMES,     SKU_A,  MSG_USAGE_GEN_LIST_VOLUMES,     MSG_USAGE_DTL_LIST_VOLUMES,     TRUE,       { V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_YES,   V_NO,    V_NO,    V_NO,    V_NO,    V_OPT   } },
    { L"List",   L"Writers",         VSSADM_C_LIST_WRITERS,     SKU_A,  MSG_USAGE_GEN_LIST_WRITERS,     MSG_USAGE_DTL_LIST_WRITERS,     FALSE,      { V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO    } },
    { L"Resize", L"SnapshotStorage", VSSADM_C_RESIZE_DIFFAREA,  SKU_SN, MSG_USAGE_GEN_RESIZE_DIFFAREA,  MSG_USAGE_DTL_RESIZE_DIFFAREA,  FALSE,      { V_NO,    V_NO,    V_YES,   V_OPT,   V_NO,    V_YES,   V_YES,   V_NO,    V_NO,    V_NO,    V_NO,    V_NO    } },
    { NULL,      NULL,               VSSADM_C_NUM_COMMANDS,     0,      0,                              0,                              FALSE,      { V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO,    V_NO    } }
};

//
//  List of snapshot types that are supported by the command line
//
const SVssAdmSnapshotTypeName g_asAdmTypeNames[]=
{
    { L"ClientAccessible",           SKU_SN,   VSS_CTX_CLIENT_ACCESSIBLE            },
    { L"DataVolumeRollback",         SKU_SN,   VSS_CTX_NAS_ROLLBACK                 },
    { L"PersistentClientAccessible", SKU_N,    VSS_CTX_PERSISTENT_CLIENT_ACCESSIBLE },
    { L"ApplicationRollback",        SKU_I,    VSS_CTX_APP_ROLLBACK                 },
    { L"FileShareRollback",          SKU_I,    VSS_CTX_FILE_SHARE_BACKUP            },    
    { L"Backup",                     SKU_I,    VSS_CTX_BACKUP                       },            
    { NULL,                          0,        0                                    }
};

/////////////////////////////////////////////////////////////////////////////
//  Implementation



CVssAdminCLI::CVssAdminCLI(
    IN INT argc,
    IN PWSTR argv[]
	)

/*++

	Description:

		Standard constructor. Initializes internal members

--*/

{
    m_argc = argc;
    m_argv = argv;
    
	m_eFilterObjectType = VSS_OBJECT_UNKNOWN;
	m_eListedObjectType = VSS_OBJECT_UNKNOWN;
	m_FilterSnapshotId = GUID_NULL;
	m_nReturnValue = VSS_CMDRET_ERROR;
	m_hConsoleOutput = INVALID_HANDLE_VALUE;	
}


CVssAdminCLI::~CVssAdminCLI()

/*++

	Description:

		Standard destructor. Calls Finalize and eventually frees the
		memory allocated by internal members.

--*/

{
	// Release the cached resource strings
    for( int nIndex = 0; nIndex < m_mapCachedResourceStrings.GetSize(); nIndex++) {
	    LPCWSTR& pwszResString = m_mapCachedResourceStrings.GetValueAt(nIndex);
		::VssFreeString(pwszResString);
    }

	// Release the cached provider names
    for( int nIndex = 0; nIndex < m_mapCachedProviderNames.GetSize(); nIndex++) {
	    LPCWSTR& pwszProvName = m_mapCachedProviderNames.GetValueAt(nIndex);
		::VssFreeString(pwszProvName);
    }

	// Uninitialize the COM library
	Finalize();
}



/////////////////////////////////////////////////////////////////////////////
//  Implementation

LPCWSTR CVssAdminCLI::GetProviderName(
	IN	CVssFunctionTracer& ft,
	IN	VSS_ID& ProviderId
	) throw(HRESULT)
{
	LPCWSTR wszReturnedString = m_mapCachedProviderNames.Lookup(ProviderId);
	if (wszReturnedString)
		return wszReturnedString;

	CComPtr<IVssCoordinator> pICoord;

    ft.LogVssStartupAttempt();
	ft.hr = pICoord.CoCreateInstance( CLSID_VSSCoordinator );
	if ( ft.HrFailed() )
		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED, L"Connection failed with hr = 0x%08lx", ft.hr);

	CComPtr<IVssEnumObject> pIEnumProvider;
	ft.hr = pICoord->Query( GUID_NULL,
				VSS_OBJECT_NONE,
				VSS_OBJECT_PROVIDER,
				&pIEnumProvider );
	if ( ft.HrFailed() )
		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Query failed with hr = 0x%08lx", ft.hr);

	VSS_OBJECT_PROP Prop;
	VSS_PROVIDER_PROP& Prov = Prop.Obj.Prov;

	// Go through the list of providers to find the one we are interested in.
	ULONG ulFetched;
	while( 1 )
	{
    	ft.hr = pIEnumProvider->Next( 1, &Prop, &ulFetched );
    	if ( ft.HrFailed() )
    		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);

    	if (ft.hr == S_FALSE) {
    	    // End of enumeration.
        	// Provider not registered? Where did this snapshot come from?
        	// It might be still possible if a snapshot provider was deleted
        	// before querying the snapshot provider but after the snapshot attributes
        	// were queried.
    		BS_ASSERT(ulFetched == 0);
    		return LoadString( ft, IDS_UNKNOWN_PROVIDER );
    	}
    	
    	if (Prov.m_ProviderId == ProviderId)
    	    break;
	}	

	// Duplicate the new string
	LPWSTR wszNewString = NULL;
	BS_ASSERT(Prov.m_pwszProviderName);
	::VssSafeDuplicateStr( ft, wszNewString, Prov.m_pwszProviderName );
	wszReturnedString = wszNewString;

	// Save the string in the cache
	if (!m_mapCachedProviderNames.Add( ProviderId, wszReturnedString )) {
		::VssFreeString( wszReturnedString );
		ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
	}

	return wszReturnedString;
}


BOOL CVssAdminCLI::GetProviderId(
	IN	CVssFunctionTracer& ft,
	IN  LPCWSTR pwszProviderName,
	OUT	VSS_ID *pProviderId
	) throw(HRESULT)
{
    //  See if the provider name is the special MS name.  If so, return the babbage provider
    //  VSS_ID.
    if ( !::_wcsicmp( pwszProviderName, L"MS" ) || !::_wcsicmp( pwszProviderName, L"BABBAGE" ) )
    {
        *pProviderId = VSS_SWPRV_ProviderId;
        return TRUE;
    }
    
	CComPtr<IVssCoordinator> pICoord;

    ft.LogVssStartupAttempt();
	ft.hr = pICoord.CoCreateInstance( CLSID_VSSCoordinator );
	if ( ft.HrFailed() )
		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

	CComPtr<IVssEnumObject> pIEnumProvider;
	ft.hr = pICoord->Query( GUID_NULL,
				VSS_OBJECT_NONE,
				VSS_OBJECT_PROVIDER,
				&pIEnumProvider );
	if ( ft.HrFailed() )
		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Query failed with hr = 0x%08lx", ft.hr);

	VSS_OBJECT_PROP Prop;
	VSS_PROVIDER_PROP& Prov = Prop.Obj.Prov;

	// Go through the list of providers to find the one we are interested in.
	ULONG ulFetched;
	while( 1 )
	{
    	ft.hr = pIEnumProvider->Next( 1, &Prop, &ulFetched );
    	if ( ft.HrFailed() )
    		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);

    	if (ft.hr == S_FALSE) {
    	    // End of enumeration.
        	// Provider not registered? Where did this snapshot come from?
        	// It might be still possible if a snapshot provider was deleted
        	// before querying the snapshot provider but after the snapshot attributes
        	// were queried.
    		BS_ASSERT(ulFetched == 0);
    	    *pProviderId = GUID_NULL;
    	    return FALSE;
    	}
    	
    	if (::_wcsicmp( Prov.m_pwszProviderName, pwszProviderName) == 0)
    	    break;
	}	

    *pProviderId = Prov.m_ProviderId;
    
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//  Implementation


void CVssAdminCLI::Initialize(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)

/*++

	Description:

		Initializes the COM library. Called explicitely after instantiating the CVssAdminCLI object.

--*/

{
    // Use the OEM code page ...
    ::setlocale(LC_ALL, ".OCP");

    // Use the console UI language
    ::SetThreadUILanguage( 0 );

    //
    //  Use only the Console routines to output messages.  To do so, need to open standard
    //  output.
    //
    m_hConsoleOutput = ::GetStdHandle(STD_OUTPUT_HANDLE); 
    if (m_hConsoleOutput == INVALID_HANDLE_VALUE) 
    {
		ft.Throw( VSSDBG_VSSADMIN, HRESULT_FROM_WIN32( ::GetLastError() ),
				  L"Initialize - Error from GetStdHandle(), rc: %d",
				  ::GetLastError() );
    }
    
	// Initialize COM library
	ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (ft.HrFailed())
		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Failure in initializing the COM library 0x%08lx", ft.hr);

    // Initialize COM security
    ft.hr = CoInitializeSecurity(
           NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
           -1,                                  //  IN LONG                         cAuthSvc,
           NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
           NULL,                                //  IN void                        *pReserved1,
           RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
           RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
           NULL,                                //  IN void                        *pAuthList,
           EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
           NULL                                 //  IN void                        *pReserved3
           );

	if (ft.HrFailed()) {
        ft.Throw( VSSDBG_VSSADMIN, ft.hr,
                  L" Error: CoInitializeSecurity() returned 0x%08lx", ft.hr );
    }

    //
    //  Assert the Backup privilage.  Not worried about errors here since VSS will
    //  return access denied return codes if the user doesn't have permission.
    //
    
    (void)::AssertPrivilege (SE_BACKUP_NAME);

    
	// Print the header
	OutputMsg( ft, MSG_UTILITY_HEADER );
}


//
//  Returns true if the command line was parsed fine
//
BOOL CVssAdminCLI::ParseCmdLine(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)

/*++

	Description:

		Parses the command line.

--*/

{
	// Skip the executable name
	GetNextCmdlineToken( ft, true );

	// Get the first token after the executable name
	LPCWSTR pwszMajor = GetNextCmdlineToken( ft );
    LPCWSTR pwszMinor = NULL;
    if ( pwszMajor != NULL )
    {
        if ( ::wcscmp( pwszMajor, L"/?" ) == 0 || ::wcscmp( pwszMajor, L"-?" ) == 0 )
            return FALSE;
        pwszMinor = GetNextCmdlineToken( ft );
    }
    
    if ( pwszMajor == NULL || pwszMinor == NULL )
    {
   		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_COMMAND, L"Incomplete command");
    }

    INT idx;
    
    // See if the command is found in list of commands
    for ( idx = VSSADM_C_FIRST; idx < VSSADM_C_NUM_COMMANDS; ++idx )
    {
        if ( ( CVssSKU::GetSKU() & g_asAdmCommands[idx].dwSKUs ) &&
             Match( ft, pwszMajor, g_asAdmCommands[idx].pwszMajorOption ) && 
             Match( ft, pwszMinor, g_asAdmCommands[idx].pwszMinorOption ) )
        {
            //
            //  Got a match
            //
            break;            
        }
    }

    if ( idx == VSSADM_C_NUM_COMMANDS )
    {
   		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_COMMAND, L"Invalid command");
    }

    //
    // Found the command. 
    //
    m_eCommandType = ( EVssAdmCommand )idx;
    m_sParsedCommand.eAdmCmd = ( EVssAdmCommand )idx;

    //
    // Now need to process command line options
    //
    LPCWSTR pwszOption = GetNextCmdlineToken( ft );

    while ( pwszOption != NULL )
    {
        if ( pwszOption[0] == L'/' || pwszOption[0] == L'-' )
        {
            //
            // Got a named option, now see if it is a valid option 
            // for the command.
            //

            // Skip past delimiter
            ++pwszOption;

            //
            // See if they want usage
            //
            if ( pwszOption[0] == L'?' )
                return FALSE;
            
            // Parse out the value part of the named option
            LPWSTR pwszValue = ::wcschr( pwszOption, L'=' );
            if ( pwszValue != NULL )
            {
                // Replace = with NULL char and set value to point to string after the =
                pwszValue[0] = L'\0';
                ++pwszValue;
            }
            
            // At this point, if pwszValue == NULL, it means the option had no = and so no specified value.
            // If pwszValue[0] == L'\0', then the value is an empty value
            
            INT eOpt;
            
            // Now figure out which named option this is
            for ( eOpt = VSSADM_O_FIRST; eOpt < VSSADM_O_NUM_OPTIONS; ++eOpt )
            {
                if ( Match( ft, g_asAdmOptions[eOpt].pwszOptName, pwszOption ) )
                    break;
            }

            // See if this is a bogus option
            if ( eOpt == VSSADM_O_NUM_OPTIONS )
            {
           		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION, L"Invalid option: %s", pwszOption);
            }

            // See if this option has already been specified
            if ( m_sParsedCommand.apwszOptionValues[eOpt] != NULL )
            {
           		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_DUPLICATE_OPTION, L"Duplicate option given: %s", pwszOption);
            }
            
            //  See if this option is allowed for the command
            if ( g_asAdmCommands[ m_sParsedCommand.eAdmCmd ].aeOptionFlags[ eOpt ] == V_NO )
            {
           		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_OPTION_NOT_ALLOWED_FOR_COMMAND, L"Option not allowed for this command: %s", pwszOption);
            }

            // See if this option is supposed to have a value, BOOL options do not
            if ( ( g_asAdmOptions[eOpt].eOptType == VSSADM_OT_BOOL && pwszValue != NULL ) ||
                 ( g_asAdmOptions[eOpt].eOptType != VSSADM_OT_BOOL && ( pwszValue == NULL || pwszValue[0] == L'\0' ) ) )
            {
           		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE, L"Invalid option value: /%s=%s", pwszOption, pwszValue ? pwszValue : L"<MISSING>" );
            }

            // Finally, we have a valid option, save away the option value.  
            // See if it is a boolean type.  In the option array we store the wszVssOptBoolTrue string.  
            // The convention is if the option is NULL, then the boolean option is false, else it
            // is true.
            if ( g_asAdmOptions[eOpt].eOptType == VSSADM_OT_BOOL )
                ::VssSafeDuplicateStr( ft, m_sParsedCommand.apwszOptionValues[eOpt], wszVssOptBoolTrue );
            else
                ::VssSafeDuplicateStr( ft, m_sParsedCommand.apwszOptionValues[eOpt], pwszValue );                
        }
        else
        {
            //
            // Got an unnamed option, not valid in any command
            //
       		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_COMMAND, L"Invalid command");
        }
        pwszOption = GetNextCmdlineToken( ft );
    }

    //  We are done parsing the command-line.  Now see if any manditory named options were missing
    for ( idx = VSSADM_O_FIRST; idx < VSSADM_O_NUM_OPTIONS; ++idx )
    {
        if ( ( m_sParsedCommand.apwszOptionValues[idx] == NULL ) &&
             ( g_asAdmCommands[ m_sParsedCommand.eAdmCmd ].aeOptionFlags[ idx ] == V_YES ) )
        {
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_REQUIRED_OPTION_MISSING, L"Required option missing");
        }
    }

    //
    //  Now fix up certain options if needed
    //
    LPWSTR pwszStr;
    
    //  Need a \ at the end of the FOR option
    pwszStr =  m_sParsedCommand.apwszOptionValues[ VSSADM_O_FOR ];
    if (  pwszStr != NULL )
    {
        if ( pwszStr[ ::wcslen( pwszStr ) - 1 ] != L'\\' )
        {
            pwszStr = ::VssReallocString( ft, pwszStr, (LONG)::wcslen( pwszStr ) + 1 );
            ::wcscat( pwszStr, L"\\" );
            m_sParsedCommand.apwszOptionValues[ VSSADM_O_FOR ] = pwszStr;
        }
    }
    //  Need a \ at the end of the ON option
    pwszStr =  m_sParsedCommand.apwszOptionValues[ VSSADM_O_ON ];
    if (  pwszStr != NULL )
    {
        if ( pwszStr[ ::wcslen( pwszStr ) - 1 ] != L'\\' )
        {
            pwszStr = ::VssReallocString( ft, pwszStr, (LONG)::wcslen( pwszStr ) + 1 );
            ::wcscat( pwszStr, L"\\" );
            m_sParsedCommand.apwszOptionValues[ VSSADM_O_ON ] = pwszStr;
        }
    }

    return TRUE;
}

void CVssAdminCLI::DoProcessing(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
	switch( m_sParsedCommand.eAdmCmd )
	{
    case VSSADM_C_CREATE_SNAPSHOT:
        CreateSnapshot(ft);
        break;

    case VSSADM_C_LIST_PROVIDERS:
        ListProviders(ft);
        break;

    case VSSADM_C_LIST_SNAPSHOTS:
        ListSnapshots(ft);
        break;

    case VSSADM_C_LIST_WRITERS:
        ListWriters(ft);
        break;
        
    case VSSADM_C_ADD_DIFFAREA:
        AddDiffArea( ft );
        break;
        
    case VSSADM_C_RESIZE_DIFFAREA:
        ResizeDiffArea( ft );
        break;
        
    case VSSADM_C_DELETE_DIFFAREAS:
        DeleteDiffAreas( ft );
        break;

    case VSSADM_C_LIST_DIFFAREAS:
        ListDiffAreas( ft );
        break;

    case VSSADM_C_DELETE_SNAPSHOTS:
        DeleteSnapshots( ft );
        break;

    case VSSADM_C_EXPOSE_SNAPSHOT:
        ExposeSnapshot( ft );
        break;

    case VSSADM_C_LIST_VOLUMES:
        ListVolumes( ft );
        break;
        
	default:
		ft.Throw( VSSDBG_COORD, E_UNEXPECTED,
				  L"Invalid command type: %d", m_eCommandType);
	}
}

void CVssAdminCLI::Finalize()

/*++

	Description:

		Uninitialize the COM library. Called in CVssAdminCLI destructor.

--*/

{
	// Uninitialize COM library
	CoUninitialize();
}


HRESULT CVssAdminCLI::Main(
    IN INT argc,
    IN PWSTR argv[]
	)

/*++

Function:
	
	CVssAdminCLI::Main

Description:

	Static function used as the main entry point in the VSS CLI

--*/

{
    CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdminCLI::Main" );
	INT nReturnValue = VSS_CMDRET_ERROR;

    try
    {
		CVssAdminCLI	program(argc, argv);

		try
		{
			// Initialize the program. This calls CoInitialize()
			program.Initialize(ft);
			// Parse the command line
			if ( program.ParseCmdLine(ft) )
			{
    			// Do the work...
	    		program.DoProcessing(ft);
			}
			else
			{
			    // Error parsing the command line, print out usage
			    program.PrintUsage( ft );
			}

			ft.hr = S_OK; // Assume that the above methods printed error
			              // messages if there was an error.
		}
		VSS_STANDARD_CATCH(ft)

        nReturnValue = program.GetReturnValue();

        //
        // Log the error if this is create snapshot
        //
        if ( ft.hr != S_OK  &&  program.m_eCommandType == VSSADM_C_CREATE_SNAPSHOT )
        {
            // 
            //  Log error message
            //
            LPWSTR pwszSnapshotErrMsg;
            pwszSnapshotErrMsg = program.GetMsg( ft, FALSE, MSG_ERROR_UNABLE_TO_CREATE_SNAPSHOT );
            if ( pwszSnapshotErrMsg == NULL ) 
            {
        		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
            			  L"Error on loading the message string id %d. 0x%08lx",
        	    		  MSG_ERROR_UNABLE_TO_CREATE_SNAPSHOT, ::GetLastError() );
            }    
            
            LONG lMsgNum;        
            LPWSTR pwszMsg = NULL;   
            if ( ::MapVssErrorToMsg( ft, ft.hr, &lMsgNum ) )
            {
                pwszMsg = program.GetMsg( ft, FALSE, lMsgNum );
                if ( pwszMsg == NULL ) 
                {
            		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
                			  L"Error on loading the message string id %d. 0x%08lx",
            	    		  lMsgNum, ::GetLastError() );
                }    
                ft.LogError( VSS_ERROR_VSSADMIN_ERROR, VSSDBG_VSSADMIN << pwszSnapshotErrMsg << pwszMsg << ::GetCommandLineW() );
                ::VssFreeString( pwszMsg );
            }
            else
            {
                // Try to get the system error message
                pwszMsg = program.GetMsg( ft, FALSE, ft.hr );
                if ( pwszMsg != NULL ) 
                {
                    ft.LogError( VSS_ERROR_VSSADMIN_ERROR, VSSDBG_VSSADMIN << pwszSnapshotErrMsg << pwszMsg << ::GetCommandLineW() );
                    ::VssFreeString( pwszMsg );
                }
                else
                {
                    WCHAR wszHr[64];
                    ::wsprintf( wszHr, L"hr = 0x%08x", ft.hr );
                    ft.LogError( VSS_ERROR_VSSADMIN_ERROR, VSSDBG_VSSADMIN << pwszSnapshotErrMsg << wszHr << ::GetCommandLineW() );
                }
            }

            ::VssFreeString( pwszSnapshotErrMsg );            
        }

        //
		// Print the error on the display, if any
		//
		if ( ft.hr != S_OK )
		{
		    LONG lMsgNum;
		    
		    //  If the error is empty query, print out a message stating that
		    if ( ft.hr == VSSADM_E_NO_ITEMS_IN_QUERY )
		    {
      	        nReturnValue = VSS_CMDRET_EMPTY_RESULT;
       			program.OutputMsg( ft, MSG_ERROR_NO_ITEMS_FOUND );    			         	        
		    }
            else if ( ::MapVssErrorToMsg(ft, ft.hr, &lMsgNum ) )
		    {
    		    //  This is a parsing or VSS error, map it to a msg id
      	        program.OutputErrorMsg( ft, lMsgNum );
      	        if ( ft.hr >= VSSADM_E_FIRST_PARSING_ERROR && ft.hr <= VSSADM_E_LAST_PARSING_ERROR )
      	        {
      	            program.PrintUsage( ft );
      	        }
		    }
		    else
		    {
    	        //  Unhandled error, try to get the error string from the system
                LPWSTR pwszMsg;
                // Try to get the system error message
                pwszMsg = program.GetMsg( ft, FALSE, ft.hr );
                if ( pwszMsg != NULL ) 
                {
        			program.OutputMsg( ft, MSG_ERROR_UNEXPECTED_WITH_STRING, pwszMsg );    			    
                    ::LocalFree( pwszMsg );
                } 
    			else
    			{
        			program.OutputMsg( ft, MSG_ERROR_UNEXPECTED_WITH_HRESULT, ft.hr );    			    
    			}
		    }
        }

		// The destructor automatically calls CoUninitialize()
	}
    VSS_STANDARD_CATCH(ft)

	return nReturnValue;
}

BOOL AssertPrivilege( 
    IN LPCWSTR privName 
    )
{
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if ( ::OpenProcessToken (GetCurrentProcess(),
			   TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,
			   &tokenHandle))
	{
    	LUID value;

    	if ( ::LookupPrivilegeValueW( NULL, privName, &value ) )
    	{
    	    TOKEN_PRIVILEGES newState;
    	    DWORD            error;

    	    newState.PrivilegeCount           = 1;
    	    newState.Privileges[0].Luid       = value;
    	    newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED;

    	    /*
    	     * We will always call GetLastError below, so clear
    	     * any prior error values on this thread.
    	     */
    	    ::SetLastError( ERROR_SUCCESS );

    	    stat = ::AdjustTokenPrivileges (tokenHandle,
    					  FALSE,
    					  &newState,
    					  (DWORD)0,
    					  NULL,
    					  NULL );

    	    /*
    	     * Supposedly, AdjustTokenPriveleges always returns TRUE
    	     * (even when it fails). So, call GetLastError to be
    	     * extra sure everything's cool.
    	     */
    	    if ( (error = ::GetLastError()) != ERROR_SUCCESS )
    		{
        		stat = FALSE;
    		}
        }

    	DWORD cbTokens;
    	::GetTokenInformation (tokenHandle,
    			     TokenPrivileges,
    			     NULL,
    			     0,
    			     &cbTokens);

    	TOKEN_PRIVILEGES *pTokens = (TOKEN_PRIVILEGES *) new BYTE[cbTokens];
    	::GetTokenInformation (tokenHandle,
    			     TokenPrivileges,
    			     pTokens,
    			     cbTokens,
    			     &cbTokens);

    	delete pTokens;
    	::CloseHandle( tokenHandle );
	}

    return stat;
}


/////////////////////////////////////////////////////////////////////////////
//  WinMain


extern "C" INT __cdecl wmain(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    return CVssAdminCLI::Main(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\vssadmin\utility.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module utility.cpp | Implementation of the Volume Snapshots admin utility
    @end

Author:

    Adi Oltean  [aoltean]  09/17/1999
    Stefan Steiner [ssteiner] 03/27/2001
    
TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    ssteiner    03/27/2001  Created
--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes

// The rest of includes are specified here
#include "vssadmin.h"
#include <float.h>

#define VSS_LINE_BREAK_COLUMN (79)

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "ADMUTILC"

LPCWSTR CVssAdminCLI::LoadString(
		IN	CVssFunctionTracer& ft,
		IN	UINT uStringId
		)
{
    LPCWSTR wszReturnedString = m_mapCachedResourceStrings.Lookup(uStringId);
	if (wszReturnedString)
		return wszReturnedString;

	// Load the string from resources.
	WCHAR	wszBuffer[nStringBufferSize];
	INT nReturnedCharacters = ::LoadStringW(
			GetModuleHandle(NULL),
			uStringId,
			wszBuffer,
			nStringBufferSize - 1
			);
	if (nReturnedCharacters == 0)
		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
				  L"Error on loading the string %u. 0x%08lx",
				  uStringId, ::GetLastError() );

	// Duplicate the new string
	LPWSTR wszNewString = NULL;
	::VssSafeDuplicateStr( ft, wszNewString, wszBuffer );
	wszReturnedString = wszNewString;

	// Save the string in the cache
	if ( !m_mapCachedResourceStrings.Add( uStringId, wszReturnedString ) ) {
		::VssFreeString( wszReturnedString );
		ft.Throw( VSSDBG_COORD, E_OUTOFMEMORY, L"Memory allocation error");
	}

	return wszReturnedString;
}


LPCWSTR CVssAdminCLI::GetNextCmdlineToken(
	IN	CVssFunctionTracer& ft,
	IN	bool bFirstToken /* = false */
	) throw(HRESULT)

/*++

Description:

	This function returns the tokens in the command line.

	The function will skip any separators (space and tab).

	If bFirstCall == true then it will return the first token.
	Otherwise subsequent calls will return subsequent tokens.

	If the last token is NULL then there are no more tokens in the command line.

--*/

{
    static INT iCurrArgc;
    WCHAR *pwsz;

    if ( bFirstToken )
        iCurrArgc = 0; 

    if ( iCurrArgc >= m_argc )
        return NULL;
    
    pwsz = m_argv[iCurrArgc++];

	return pwsz;
	UNREFERENCED_PARAMETER(ft);
}


bool CVssAdminCLI::Match(
	IN	CVssFunctionTracer& ft,
	IN	LPCWSTR wszString,
	IN	LPCWSTR wszPatternString
	) throw(HRESULT)

/*++

Description:

	This function returns true iif the given string matches the
	pattern string. The comparison is case insensitive.

--*/

{
	// If the string is NULL then the Match failed.
	if (wszString == NULL) return false;

	// Check for string equality (case insensitive)
	return (::_wcsicmp( wszString, wszPatternString ) == 0);
	UNREFERENCED_PARAMETER(ft);
}


bool CVssAdminCLI::ScanGuid(
	IN	CVssFunctionTracer& /* ft */,
	IN	LPCWSTR wszString,
	OUT	VSS_ID& Guid
	) throw(HRESULT)

/*++

Description:

	This function returns true iif the given string matches a guid.
	The guid is returned in the proper variable.
	The formatting is case insensitive.

--*/

{
	return SUCCEEDED(::CLSIDFromString(W2OLE(const_cast<WCHAR*>(wszString)), &Guid));
}


void CVssAdminCLI::Output(
	IN	CVssFunctionTracer& ft,
	IN	LPCWSTR wszFormat,
	...
	) throw(HRESULT)

/*++

Description:

	This function returns true iif the given string matches the
	pattern strig from resources. The comparison is case insensitive.

--*/

{
    WCHAR wszOutputBuffer[nStringBufferSize];

	// Format the final string
    va_list marker;
    va_start( marker, wszFormat );
    _vsnwprintf( wszOutputBuffer, nStringBufferSize - 1, wszFormat, marker );
    va_end( marker );

	// Print the final string to the output
	OutputOnConsole( wszOutputBuffer );
	UNREFERENCED_PARAMETER(ft);
}


void CVssAdminCLI::OutputMsg(
	IN	CVssFunctionTracer& ft,
    IN  LONG msgId,
    ...
    )
/*++

Description:

	This function outputs a msg.mc message.

--*/
{
    va_list args;
    LPWSTR lpMsgBuf;
	
    va_start( args, msgId );

    if (::FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
            NULL,
            msgId,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPWSTR) &lpMsgBuf,
            0,
            &args
            ))
    {
        OutputOnConsole( lpMsgBuf );
        ::LocalFree( lpMsgBuf );
    } 
    else 
    {
        if (::FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                msgId,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPWSTR) &lpMsgBuf,
                0,
                &args))
        {
            OutputOnConsole( lpMsgBuf );
            ::LocalFree( lpMsgBuf );
        } 
        else 
        {
            ::wprintf( L"Unable to format message for id %x - %d\n", msgId, ::GetLastError( ));                        
    		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
    				  L"Error on loading the message string id %d. 0x%08lx",
    				  msgId, ::GetLastError() );
        }
    }
    va_end( args );
}

LPWSTR CVssAdminCLI::GetMsg(
	IN	CVssFunctionTracer& ft,
	IN  BOOL bLineBreaks,
    IN  LONG msgId,
    ...
    )
{
    va_list args;
    LPWSTR lpMsgBuf;
    LPWSTR lpReturnStr = NULL;
    
    va_start( args, msgId );

    if (::FormatMessageW(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE | 
                ( bLineBreaks ? VSS_LINE_BREAK_COLUMN : FORMAT_MESSAGE_MAX_WIDTH_MASK ),
            NULL,
            msgId,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPWSTR) &lpMsgBuf,
            0,
            &args
            ))
    {
        ::VssSafeDuplicateStr( ft, lpReturnStr, lpMsgBuf );
        ::LocalFree( lpMsgBuf );
    }
    else if (::FormatMessageW(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | 
                    ( bLineBreaks ? VSS_LINE_BREAK_COLUMN : FORMAT_MESSAGE_MAX_WIDTH_MASK ),
                NULL,
                msgId,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPWSTR) &lpMsgBuf,
                0,
                &args ) )
    {
        ::VssSafeDuplicateStr( ft, lpReturnStr, lpMsgBuf );
        ::LocalFree( lpMsgBuf );
    }

    va_end( args );

    //  Returns NULL if message was not found
    return lpReturnStr;
}

void CVssAdminCLI::AppendMessageToStr(
    IN CVssFunctionTracer& ft,
    IN LPWSTR pwszString,
    IN SIZE_T cMaxStrLen,
    IN LONG lMsgId,
    IN DWORD AttrBit,
    IN LPCWSTR pwszDelimitStr
    ) throw( HRESULT )
{
    if ( pwszString[0] != L'\0' )
    {
        //  First append the delimiter
        ::wcsncat( pwszString, pwszDelimitStr, cMaxStrLen );       
    }

    //  If this is a known message, lMsgId != 0
    if ( lMsgId != 0 )
    {
        LPWSTR pwszMsg;
        pwszMsg = GetMsg( ft, FALSE, lMsgId );
        if ( pwszMsg == NULL ) 
        {
    		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
	    			  L"Error on loading the message string id %d. 0x%08lx",
		    		  lMsgId, ::GetLastError() );
        }
        
        ::wcsncat( pwszString, pwszMsg, cMaxStrLen );
        ::VssFreeString( pwszMsg );
    }
    else
    {
        //  No message for this one, just append the attribute in hex
        WCHAR pwszBitStr[64];
        ::swprintf( pwszBitStr, L"0x%x", AttrBit );
        ::wcsncat( pwszString, pwszBitStr, cMaxStrLen );
    }
}

//
//  Scans a number input by the user and converts it to a LONGLONG.  Accepts the following
//  unit suffixes: B, K, KB, M, MB, G, GB, T, TB, P, PB, E, EB and floating point.
//
LONGLONG CVssAdminCLI::ScanNumber(
	IN CVssFunctionTracer& ft,
	IN LPCWSTR pwszNumToConvert
    ) throw( HRESULT )
{
    WCHAR wUnit = L'B';
    SIZE_T NumStrLen;

    //  If the string is NULL, assume infinite size
    if ( pwszNumToConvert == NULL )
        return -1;
    
    //
    //  Set up an automatically released temporary string
    //
    CVssAutoPWSZ autoStrNum;
    autoStrNum.CopyFrom( pwszNumToConvert );
    LPWSTR pwszNum = autoStrNum.GetRef();

    NumStrLen = ::wcslen( pwszNum );

    //  Remove trailing spaces
    while ( NumStrLen > 0 && pwszNum[ NumStrLen - 1 ] == L' ' )
    {
        NumStrLen -= 1;        
        pwszNum[ NumStrLen ] = L'\0';
    }
    
    //  If the string is empty, assume infinite size
    if ( NumStrLen == 0 )
        return -1;

    //  Now see if there is a single or double byte alpha suffix.  If so, put the suffix in wUnit.
    if ( NumStrLen > 2 && iswalpha( pwszNum[ NumStrLen - 2 ] ) && ( towupper( pwszNum[ NumStrLen - 1 ] ) == L'B' ) )
    {
        wUnit = pwszNum[ NumStrLen - 2 ];
        pwszNum[ NumStrLen - 2 ] = L'\0';
        NumStrLen -= 2;
    } 
    else if ( NumStrLen > 1 && iswalpha( pwszNum[ NumStrLen - 1 ] ) )
    {
        wUnit = pwszNum[ NumStrLen - 1 ];
        pwszNum[ NumStrLen - 1 ] = L'\0';
        NumStrLen -= 1;
    }
    //  At this point, the rest of the string should be a valid floating point number
    double dSize;
    if ( swscanf( pwszNum, L"%lf", &dSize ) != 1 )
		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_NUMBER,
				  L"Invalid input number: %s", pwszNumToConvert );
    //  Now bump up the size based on suffix
    
    switch( towupper( wUnit ) )
    {
    case L'B':
        break;
    case L'E':
        dSize *= 1024.;
    case L'P':
        dSize *= 1024.;
    case L'T':
        dSize *= 1024.;
    case L'G':
        dSize *= 1024.;
    case L'M':
        dSize *= 1024.;
    case L'K':
        dSize *= 1024.;
        break;
    default:
		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_NUMBER,
				  L"Invalid input number: %s", pwszNumToConvert );
        break;
    }

    LONGLONG llRetVal;
    llRetVal = (LONGLONG)dSize;
    if ( llRetVal <= -1 )
		ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_NUMBER,
				  L"Invalid input number: %s", pwszNumToConvert );
            
    return llRetVal;
}

//
//  Format a LONGLONG into the appropriate string using xB (KB, MB, GB, TB, PB, EB) suffixes.
//  Must use ::VssFreeString() to free returned string.
//
LPWSTR CVssAdminCLI::FormatNumber(
	IN CVssFunctionTracer& ft,
	IN LONGLONG llNum
    ) throw( HRESULT )
{
    // If the string is -1 or less, assume this is infinite.
    if ( llNum < 0 ) 
    {
        LPWSTR pwszMsg = GetMsg( ft, FALSE, MSG_INFINITE );
        if ( pwszMsg == NULL ) 
        {
    		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
	    			  L"Error on loading the message string id %d. 0x%08lx",
		    		  MSG_INFINITE, ::GetLastError() );
        }
        
        return pwszMsg;
    }
    
    // Now convert the size into string
    UINT nExaBytes =   (UINT)((llNum >> 60));
    UINT nPetaBytes =  (UINT)((llNum >> 50) & 0x3ff);
    UINT nTerraBytes = (UINT)((llNum >> 40) & 0x3ff);
    UINT nGigaBytes =  (UINT)((llNum >> 30) & 0x3ff);
    UINT nMegaBytes =  (UINT)((llNum >> 20) & 0x3ff);
    UINT nKiloBytes =  (UINT)((llNum >> 10) & 0x3ff);
    UINT nBytes =      (UINT)( llNum  & 0x3ff);

    LPCWSTR pwszUnit;
    double dSize = 0.0;

    // Display only biggest units, and never more than 999
    // instead of "1001 KB" we display "0.98 MB"
    if ( (nExaBytes) > 0 || (nPetaBytes > 999) )
    {
        pwszUnit = L"EB";
        dSize = (double)nExaBytes + ((double)nPetaBytes / 1024.);
    }
    else if ( (nPetaBytes) > 0 || (nTerraBytes > 999) )
    {
        pwszUnit = L"PB";
        dSize = (double)nPetaBytes + ((double)nTerraBytes / 1024.);
    }
    else if ( (nTerraBytes) > 0 || (nGigaBytes > 999) )
    {
        pwszUnit = L"TB";
        dSize = (double)nTerraBytes + ((double)nGigaBytes / 1024.);
    }
    else if ( (nGigaBytes) > 0 || (nMegaBytes > 999) )
    {
        pwszUnit = L"GB";
        dSize = (double)nGigaBytes + ((double)nMegaBytes / 1024.);
    }
    else if ( (nMegaBytes) > 0 || (nKiloBytes > 999) )
    {
        pwszUnit = L"MB";
        dSize = (double)nMegaBytes + ((double)nKiloBytes / 1024.);
    }
    else if ( (nKiloBytes) > 0 || (nBytes > 999) )
    {
        pwszUnit = L"KB";
        dSize = (double)nKiloBytes + ((double)nBytes / 1024.);
    }
    else
    {
        pwszUnit = L"B";  
        dSize = (double)nBytes;
    }

    // Format with op to three decimal points
    WCHAR pwszSize[64];
    ::swprintf( pwszSize, L"%.3f", dSize );
    SIZE_T len = ::wcslen( pwszSize );
        
    // Truncate trailing zeros
    while ( len > 0 && pwszSize[ len - 1 ] == L'0' )
    {
        len -= 1;        
        pwszSize[ len ] = L'\0';
    }
    // Truncate trailing decimal point
    if ( len > 0 && pwszSize[ len - 1 ] == L'.' )
        pwszSize[ len - 1 ] = L'\0';

    // Now attach the unit suffix
    ::wcscat( pwszSize, L" " );
    ::wcscat( pwszSize, pwszUnit );

    // Allocate a string buffer and return it.
    LPWSTR pwszRetStr = NULL;
    ::VssSafeDuplicateStr( ft, pwszRetStr, pwszSize );

    return pwszRetStr;
}


/*++

Description:

	This function outputs a msg.mc message.

--*/
void CVssAdminCLI::OutputErrorMsg(
	IN	CVssFunctionTracer& ft,
    IN  LONG msgId,
    ...
    )
{
    va_list args;
    LPWSTR lpMsgBuf;
    
    va_start( args, msgId );
 
    if (::FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
            NULL,
            MSG_ERROR,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPWSTR) &lpMsgBuf,
            0,
            NULL
            ))
    {
        OutputOnConsole( lpMsgBuf );
        ::LocalFree( lpMsgBuf );
    }

    if (::FormatMessage(
            (msgId >= MSG_FIRST_MESSAGE_ID ? FORMAT_MESSAGE_FROM_HMODULE :
                                             FORMAT_MESSAGE_FROM_SYSTEM)
            | FORMAT_MESSAGE_ALLOCATE_BUFFER,
            NULL,
            msgId,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPWSTR) &lpMsgBuf, 
            0,
            &args
            ))
    {
        OutputOnConsole( L" " );
        OutputOnConsole( lpMsgBuf );
        OutputOnConsole( L" \r\n" );
        ::LocalFree( lpMsgBuf );
    } 
    else 
    {
        if (::FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                msgId,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPWSTR) &lpMsgBuf,
                0,
                &args))
        {
            OutputOnConsole( L" " );
            OutputOnConsole( lpMsgBuf );
            OutputOnConsole( L" \r\n" );
            ::LocalFree( lpMsgBuf );
        } 
        else 
        {
            ::wprintf( L"Unable to format message for id %x - %d\n", msgId, ::GetLastError( ));            
    		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
    				  L"Error on loading the message string id %d. 0x%08lx",
    				  msgId, ::GetLastError() );
        }
    }

    va_end( args );
	UNREFERENCED_PARAMETER(ft);
}

BOOL CVssAdminCLI::PromptUserForConfirmation(
	IN CVssFunctionTracer& ft,
	IN LONG lPromptMsgId,
	IN ULONG ulNum
	)
{
    BOOL bRetVal = FALSE;
    
    //
    //  First check to see if in quiet mode.  If so, simply return
    //  true
    //
    if ( GetOptionValueBool( VSSADM_O_QUIET ) )
        return TRUE;

    //
    //  Load the response message string, in English it is "YN"
    //
    LPWSTR pwszResponse;
    pwszResponse = GetMsg( ft, FALSE, MSG_YESNO_RESPONSE_DATA );
    if ( pwszResponse == NULL ) 
    {
		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
    			  L"Error on loading the message string id %d. 0x%08lx",
	    		  MSG_YESNO_RESPONSE_DATA, ::GetLastError() );
    }    

    //
    //  Now prompt the user
    //
    OutputMsg( ft, lPromptMsgId, ulNum );
    WCHAR wcIn;
    DWORD fdwMode;

    //  Make sure we are outputting to a real console.
    if ( ( ::GetFileType( m_hConsoleOutput ) & FILE_TYPE_CHAR ) &&
         ::GetConsoleMode( m_hConsoleOutput, &fdwMode ) )
    {
        // Going to the console, ask the user.
        wcIn = ::MyGetChar(ft);
    }
    else
    {
        // Output redirected, assume NO
        wcIn = pwszResponse[1];  // N
    }

    WCHAR wcsOutput[16];
    ::swprintf( wcsOutput, L"%c\n\n", wcIn );
    OutputOnConsole( wcsOutput );

    //
    //  Compare the character using the proper W32 function and
    //  not towupper().  
    //
    if ( ::CompareStringW( LOCALE_INVARIANT, 
                           NORM_IGNORECASE | NORM_IGNOREKANATYPE, 
                           &wcIn,
                           1,
                           pwszResponse + 0,  // Y
                           1 ) == CSTR_EQUAL )
    {
        bRetVal = TRUE;
    }
    else
    {
        bRetVal = FALSE;
    }
                                                          
    ::CoTaskMemFree( pwszResponse );
    return bRetVal;
}

void CVssAdminCLI::OutputOnConsole(
    IN	LPCWSTR wszStr
    )
{
	DWORD dwCharsOutput;
	DWORD fdwMode;
	static BOOL bFirstTime = TRUE;
	static BOOL bIsTrueConsoleOutput;

    if ( m_hConsoleOutput == INVALID_HANDLE_VALUE )
    {
        throw E_UNEXPECTED;
    }

    if ( bFirstTime )
    {
        //
        //  Stash away the results in static vars.  bIsTrueConsoleOutput is TRUE when the 
        //  standard output handle is pointing to a console character device.
        //
    	bIsTrueConsoleOutput = ( ::GetFileType( m_hConsoleOutput ) & FILE_TYPE_CHAR ) && 
    	                       ::GetConsoleMode( m_hConsoleOutput, &fdwMode  );
	    bFirstTime = FALSE;
    }
    
    if ( bIsTrueConsoleOutput )
    {
        //
        //  Output to the console
        //
    	if ( !::WriteConsoleW( m_hConsoleOutput, 
    	                       ( PVOID )wszStr, 
    	                       ( DWORD )::wcslen( wszStr ), 
    	                       &dwCharsOutput, 
    	                       NULL ) )
    	{
    	    throw HRESULT_FROM_WIN32( ::GetLastError() );
    	}    	    	                       
    }
    else
    {
        //
        //  Output being redirected.  WriteConsoleW doesn't work for redirected output.  Convert
        //  UNICODE to the current output CP multibyte charset.
        //
        LPSTR lpszTmpBuffer;
        DWORD dwByteCount;

        //
        //  Get size of temp buffer needed for the conversion.
        //
        dwByteCount = ::WideCharToMultiByte(
                          ::GetConsoleOutputCP(),
                            0,
                            wszStr,
                            -1,
                            NULL,
                            0,
                            NULL,
                            NULL
                            );
        if ( dwByteCount == 0 )
        {
            throw HRESULT_FROM_WIN32( ::GetLastError() );
        }
        
        lpszTmpBuffer = ( LPSTR )::malloc( dwByteCount );
        if ( lpszTmpBuffer == NULL )
        {
            throw E_OUTOFMEMORY;
        }

        //
        //  Now convert it.
        //
        dwByteCount = ::WideCharToMultiByte(
                        ::GetConsoleOutputCP(),
                        0,
                        wszStr,
                        -1,
                        lpszTmpBuffer,
                        dwByteCount,
                        NULL,
                        NULL
                        );
        if ( dwByteCount == 0 )
        {
            ::free( lpszTmpBuffer );
            throw HRESULT_FROM_WIN32( ::GetLastError() );
        }
        
        //  Finally output it.
        if ( !::WriteFile(
                m_hConsoleOutput,
                lpszTmpBuffer,
                dwByteCount - 1,  // Get rid of the trailing NULL char
                &dwCharsOutput,
                NULL ) )
    	{
    	    throw HRESULT_FROM_WIN32( ::GetLastError() );
    	}    	    	                       

        ::free( lpszTmpBuffer );
    }
}

//
//  Returns TRUE if error message was mapped
//
BOOL MapVssErrorToMsg(
	IN CVssFunctionTracer& ft,
	IN HRESULT hr,
	OUT LONG *plMsgNum
    ) throw( HRESULT )
{
    LONG msg = 0;
    *plMsgNum = 0;
    
    switch ( hr ) 
    {
    case VSSADM_E_NO_ITEMS_IN_QUERY:
        msg = MSG_ERROR_NO_ITEMS_FOUND;
        break;
    //  Parsing errors:
    case VSSADM_E_INVALID_NUMBER:
        msg = MSG_ERROR_INVALID_INPUT_NUMBER;
        break;
    case VSSADM_E_INVALID_COMMAND:
        msg = MSG_ERROR_INVALID_COMMAND;    	        
        break;
    case VSSADM_E_INVALID_OPTION:
        msg = MSG_ERROR_INVALID_OPTION;    	        
        break;
    case E_INVALIDARG:
    case VSSADM_E_INVALID_OPTION_VALUE:
        msg = MSG_ERROR_INVALID_OPTION_VALUE;    	        
        break;
    case VSSADM_E_DUPLICATE_OPTION:
        msg = MSG_ERROR_DUPLICATE_OPTION;    	        
        break;
    case VSSADM_E_OPTION_NOT_ALLOWED_FOR_COMMAND:
        msg = MSG_ERROR_OPTION_NOT_ALLOWED_FOR_COMMAND;
        break;
    case VSSADM_E_REQUIRED_OPTION_MISSING:
        msg = MSG_ERROR_REQUIRED_OPTION_MISSING;
        break;
    case VSSADM_E_INVALID_SET_OF_OPTIONS:
        msg = MSG_ERROR_INVALID_SET_OF_OPTIONS;
        break;

    // VSS errors
    case VSS_E_PROVIDER_NOT_REGISTERED:
        msg = MSG_ERROR_VSS_PROVIDER_NOT_REGISTERED;
        break;    	        
    case VSS_E_OBJECT_NOT_FOUND:
        msg = MSG_ERROR_VSS_VOLUME_NOT_FOUND;
        break;    	            	        
    case VSS_E_PROVIDER_VETO:
        msg = MSG_ERROR_VSS_PROVIDER_VETO;
        break;    	            
    case VSS_E_VOLUME_NOT_SUPPORTED:
        msg = MSG_ERROR_VSS_VOLUME_NOT_SUPPORTED;
        break;
    case VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER:
        msg = MSG_ERROR_VSS_VOLUME_NOT_SUPPORTED_BY_PROVIDER;
        break;
    case VSS_E_UNEXPECTED_PROVIDER_ERROR:
        msg = MSG_ERROR_VSS_UNEXPECTED_PROVIDER_ERROR;
        break;
    case VSS_E_FLUSH_WRITES_TIMEOUT:
        msg = MSG_ERROR_VSS_FLUSH_WRITES_TIMEOUT;
        break;
    case VSS_E_HOLD_WRITES_TIMEOUT:
        msg = MSG_ERROR_VSS_HOLD_WRITES_TIMEOUT;
        break;
    case VSS_E_UNEXPECTED_WRITER_ERROR:
        msg = MSG_ERROR_VSS_UNEXPECTED_WRITER_ERROR;
        break;
    case VSS_E_SNAPSHOT_SET_IN_PROGRESS:
        msg = MSG_ERROR_VSS_SNAPSHOT_SET_IN_PROGRESS;
        break;
    case VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED:
        msg = MSG_ERROR_VSS_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED;
        break;
    case VSS_E_UNSUPPORTED_CONTEXT:
        msg = MSG_ERROR_VSS_UNSUPPORTED_CONTEXT;
        break;
    case VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS_REACHED:
        msg = MSG_ERROR_VSS_MAXIMUM_DIFFAREA_ASSOCIATIONS_REACHED;
        break;
    case VSS_E_INSUFFICIENT_STORAGE:
        msg = MSG_ERROR_VSS_INSUFFICIENT_STORAGE;
        break;    	            

    case E_OUTOFMEMORY:
        msg = MSG_ERROR_OUT_OF_MEMORY;
        break;
    case E_ACCESSDENIED:
        msg = MSG_ERROR_ACCESS_DENIED;
        break;

    case VSS_E_BAD_STATE:
    case VSS_E_CORRUPT_XML_DOCUMENT:
    case VSS_E_INVALID_XML_DOCUMENT:
    case VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED:
        msg = MSG_ERROR_INTERNAL_VSSADMIN_ERROR;
        break;
    }    

    if ( msg == 0 )
        return FALSE;
    
    *plMsgNum = msg;
    return TRUE;

    UNREFERENCED_PARAMETER( ft );
}

LPWSTR GuidToString(
	IN CVssFunctionTracer& ft,
    IN GUID guid
    )
{
    LPWSTR pwszGuid;
    
    //  {36e4be76-035d-11d5-9ef2-806d6172696f}    
    pwszGuid = (LPWSTR)::CoTaskMemAlloc( 40 * sizeof( WCHAR ) );
    if ( pwszGuid == NULL )
		ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY,
				  L"Error from CoTaskMemAlloc: 0x%08lx",
				  ::GetLastError() );
        
    ::swprintf( pwszGuid, L"{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}", GUID_PRINTF_ARG( guid ) );
    return pwszGuid;    
}


LPWSTR DateTimeToString(
	IN CVssFunctionTracer& ft,
    IN VSS_TIMESTAMP *pTimeStamp
    )
{
    LPWSTR pwszDateTime;
    SYSTEMTIME stLocal;
    FILETIME ftLocal;
    WCHAR pwszDate[ 64 ];
    WCHAR pwszTime[ 64 ];
    
    if ( pTimeStamp == NULL || *pTimeStamp == 0 )
    {
        SYSTEMTIME sysTime;
        FILETIME fileTime;
        
        //  Get current time
        ::GetSystemTime( &sysTime );

        //  Convert system time to file time
        ::SystemTimeToFileTime( &sysTime, &fileTime );
        
        //  Compensate for local TZ
        ::FileTimeToLocalFileTime( &fileTime, &ftLocal );
    }
    else
    {        
        //  Compensate for local TZ
        ::FileTimeToLocalFileTime( (FILETIME *)pTimeStamp, &ftLocal );
    }

    //  Finally convert it to system time
    ::FileTimeToSystemTime( &ftLocal, &stLocal );

    //  Convert timestamp to a date string
    ::GetDateFormatW( GetThreadLocale( ),
                      DATE_SHORTDATE,
                      &stLocal,
                      NULL,
                      pwszDate,
                      sizeof( pwszDate ) / sizeof( pwszDate[0] ));

    //  Convert timestamp to a time string
    ::GetTimeFormatW( GetThreadLocale( ),
                      0,
                      &stLocal,
                      NULL,
                      pwszTime,
                      sizeof( pwszTime ) / sizeof( pwszTime[0] ));

    //  Now combine the strings and return it
    pwszDateTime = (LPWSTR)::CoTaskMemAlloc( ( ::wcslen( pwszDate ) + ::wcslen( pwszTime ) + 2 ) * sizeof( pwszDate[0] ) );
    if ( pwszDateTime == NULL )
		ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY,
				  L"Error from CoTaskMemAlloc, rc: %d",
				  ::GetLastError() );

    ::wcscpy( pwszDateTime, pwszDate );
    ::wcscat( pwszDateTime, L" " );
    ::wcscat( pwszDateTime, pwszTime );
    
    return pwszDateTime;    
}


LPWSTR LonglongToString(
	IN CVssFunctionTracer& ft,
    IN LONGLONG llValue
    )
{
    WCHAR wszLL[64];
    LPWSTR pwszRetVal = NULL;

    ::_i64tow( llValue, wszLL, 10 );

    ::VssSafeDuplicateStr( ft, pwszRetVal, wszLL );
    return pwszRetVal;
}

/*++

Description:

	Uses the win32 console functions to get one character of input.

--*/
WCHAR MyGetChar(
	IN CVssFunctionTracer& ft
    )
{
    DWORD fdwOldMode, fdwMode;
    HANDLE hStdin;
    WCHAR chBuffer[2];
    
    hStdin = ::GetStdHandle(STD_INPUT_HANDLE); 
    if (hStdin == INVALID_HANDLE_VALUE) 
    {
		ft.Throw( VSSDBG_VSSADMIN, HRESULT_FROM_WIN32( ::GetLastError() ),
				  L"MyGetChar - Error from GetStdHandle(), rc: %d",
				  ::GetLastError() );
    }

    if (!::GetConsoleMode(hStdin, &fdwOldMode)) 
    {
		ft.Throw( VSSDBG_VSSADMIN, HRESULT_FROM_WIN32( ::GetLastError() ),
				  L"MyGetChar - Error from GetConsoleMode(), rc: %d",
				  ::GetLastError() );
    }

    fdwMode = fdwOldMode & ~( ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT ); 
    if (!::SetConsoleMode(hStdin, fdwMode)) 
    {
		ft.Throw( VSSDBG_VSSADMIN, HRESULT_FROM_WIN32( ::GetLastError() ),
				  L"MyGetChar - Error from SetConsoleMode(), rc: %d",
				  ::GetLastError() );
    }

    // Flush the console input buffer to make sure there is no queued input
    ::FlushConsoleInputBuffer( hStdin );
    
    // Without line and echo input modes, ReadFile returns 
    // when any input is available.
    DWORD dwBytesRead;
    if (!::ReadConsoleW(hStdin, chBuffer, 1, &dwBytesRead, NULL)) 
    {
		ft.Throw( VSSDBG_VSSADMIN, HRESULT_FROM_WIN32( ::GetLastError() ),
				  L"MyGetChar - Error from ReadConsoleW(), rc: %d",
				  ::GetLastError() );
    }

    // Restore the original console mode. 
    ::SetConsoleMode(hStdin, fdwOldMode);

    return chBuffer[0];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\tracing\vs_sku.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    vs_sku.cxx

Abstract:

    This module defines the global SKU information implementation. 
	
Author:


Revision History:
	Name		Date		Comments
    ssteiner    05/01/01    Created file
    
--*/

//
//  ***** Includes *****
//

#pragma warning(disable:4290)
#pragma warning(disable:4127)

#include <wtypes.h>
#pragma warning( disable: 4201 )    // C4201: nonstandard extension used : nameless struct/union
#include <winioctl.h>
#pragma warning( default: 4201 )	// C4201: nonstandard extension used : nameless struct/union
#include <winbase.h>
#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <vssmsg.h>

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"

#include <oleauto.h>
#include <stddef.h>
#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <atlconv.h>
#include <atlbase.h>
#include <ntverp.h>


#include "vs_inc.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "TRCSKUC"
//
////////////////////////////////////////////////////////////////////////

BOOL CVssSKU::ms_bInitialized = FALSE;
CVssSKU::EVssSKUType CVssSKU::ms_eSKU = VSS_SKU_INVALID;

VOID CVssSKU::Initialize()
{
    if ( ms_bInitialized ) 
        return;

    //  Determine the SKU...
    OSVERSIONINFOEXW sOSV;
    sOSV.dwOSVersionInfoSize = sizeof OSVERSIONINFOEXW;
    if ( !::GetVersionExW( (LPOSVERSIONINFO)&sOSV ) )
    {
        ms_eSKU = VSS_SKU_INVALID;  //  Problem.  The tracing class will print out a trace message flagging this.    
        ms_bInitialized = TRUE;
    }
    
    if ( sOSV.wProductType == VER_NT_DOMAIN_CONTROLLER || sOSV.wProductType == VER_NT_SERVER )
    {            
        if ( sOSV.wSuiteMask & VER_SUITE_EMBEDDEDNT )
            ms_eSKU = VSS_SKU_NAS;
        else
            ms_eSKU = VSS_SKU_SERVER;
    }
    else if ( sOSV.wProductType == VER_NT_WORKSTATION )
        ms_eSKU = VSS_SKU_CLIENT;
    else
        ms_eSKU = VSS_SKU_INVALID;  //  Problem.  THe tracing class will print out a trace message flagging this.
    
    ms_bInitialized = TRUE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\delayloadhandler.cpp ===
//***************************************************************************

//

//  DELAYLOADHANDLER.CPP

//

//  Module: Delay load handler functions

//

//  Purpose: When delay loaded libraries either fail to load, or functions

//           in them are not found, this handler is called as a result of

//           the //DELAYLOAD linker specification.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <stdafx.h>
#include <delayimp.h>


// Skeleton DliHook function that does nothing interesting
FARPROC WINAPI DliHook(
    unsigned dliNotify,
    PDelayLoadInfo pdli)
{
   FARPROC fp = NULL;   // Default return value

   // NOTE: The members of the DelayLoadInfo structure pointed
   // to by pdli shows the results of progress made so far.

   switch (dliNotify)
   {
   case dliStartProcessing:
      // Called when __delayLoadHelper attempts to find a DLL/function
      // Return 0 to have normal behavior, or non-0 to override
      // everything (you will still get dliNoteEndProcessing)
      break;

   case dliNotePreLoadLibrary:
      // Called just before LoadLibrary
      // Return NULL to have __delayLoadHelper call LoadLibary
      // or you can call LoadLibrary yourself and return the HMODULE
      fp = (FARPROC)(HMODULE) NULL;
      break;

   case dliFailLoadLib:
      // Called if LoadLibrary fails
      // Again, you can call LoadLibary yourself here and return an HMODULE
      // If you return NULL, __delayLoadHelper raises the
      // ERROR_MOD_NOT_FOUND exception
      fp = (FARPROC)(HMODULE) NULL;
      break;

   case dliNotePreGetProcAddress:
      // Called just before GetProcAddress
      // Return NULL to have __delayLoadHelper call GetProcAddress
      // or you can call GetProcAddress yourself and return the address
      fp = (FARPROC) NULL;
      break;

   case dliFailGetProc:
      // Called if GetProcAddress fails
      // Again, you can call GetProcAddress yourself here and return an address
      // If you return NULL, __delayLoadHelper raises the
      // ERROR_PROC_NOT_FOUND exception
      fp = (FARPROC) NULL;
      break;

   case dliNoteEndProcessing:
      // A simple notification that __delayLoadHelper is done
      // You can examine the members of the DelayLoadInfo structure
      // pointed to by pdli and raise an exception if you desire
      break;
   }

   return(fp);
}

// Tell __delayLoadHelper to call my hook function
PfnDliHook __pfnDliNotifyHook  = DliHook;
PfnDliHook __pfnDliFailureHook = DliHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\jetwriter.cpp ===
#include <stdafx.h>

#include <esent.h>
#include <comadmin.h>
#include "vs_inc.hxx"

#include "vs_idl.hxx"


#include "comadmin.hxx"
#include "vswriter.h"

#include <jetwriter.h>
#include <ijetwriter.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHJTWRC"
//
////////////////////////////////////////////////////////////////////////

// destructor
__declspec(dllexport) CVssJetWriter::~CVssJetWriter()
	{
	BS_ASSERT(m_pWriter == NULL);
	}


// routine for passing arguments between threads
typedef struct _JW_INIT_ARGS
	{
	VSS_ID idWriter;
	LPCWSTR wszWriterName;
	bool bSystemService;
	bool bBootableSystemState;
	LPCWSTR wszFilesToInclude;
	LPCWSTR wszFilesToExclude;
	CVssJetWriter *pobj;
	} JW_INIT_ARGS;


// separate MTA thread for doing initialization
DWORD CVssJetWriter::InitializeThreadFunc(VOID *pv)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"InitializeThreadFunc");

	JW_INIT_ARGS *pargs = (JW_INIT_ARGS *) pv;

	try
		{
		// intialize MTA thread
		ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		if (ft.HrFailed())
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"CoInitializeEx failed 0x%08lx", ft.hr
				);

        // call internal object to initialize
		ft.hr = CVssIJetWriter::Initialize
						(
						pargs->idWriter,
						pargs->wszWriterName,
						pargs->bSystemService,
						pargs->bBootableSystemState,
						pargs->wszFilesToInclude,
						pargs->wszFilesToExclude,
						pargs->pobj,
						&pargs->pobj->m_pWriter
						);


        if(ft.HrFailed())
			ft.Throw(VSSDBG_GEN, E_UNEXPECTED, L"CvssIJetWriter::Initialize failed");
		}
	VSS_STANDARD_CATCH(ft)

	// save result of initialization
	pargs->pobj->m_hrInitialized = ft.hr;
	return 0;
	}


// initialize method on external thread
__declspec(dllexport) HRESULT CVssJetWriter::Initialize
	(
	IN GUID idWriter,
	IN LPCWSTR wszWriterName,
	bool bSystemService,
	bool bBootableSystemState,
	LPCWSTR wszFilesToInclude,
	LPCWSTR wszFilesToExclude
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::Initialize");

	try
		{
		DWORD tid;
		// setup arguments to thread
		JW_INIT_ARGS args;
		args.idWriter = idWriter;
		args.wszWriterName = wszWriterName;
		args.bSystemService = bSystemService;
		args.bBootableSystemState = bBootableSystemState;
		args.wszFilesToInclude = wszFilesToInclude;
		args.wszFilesToExclude = wszFilesToExclude;
		args.pobj = this;

		// create thread
		HANDLE hThread = CreateThread
								(
								NULL,
								256*1024,
                                CVssJetWriter::InitializeThreadFunc,
								&args,
								0,
								&tid
								);

        if (hThread == NULL)
			ft.Throw
				(
				VSSDBG_GEN,
				E_UNEXPECTED,
				L"CreateThread failed with error %d",
				GetLastError()
				);

		// wait for thread to complete
        WaitForSingleObject(hThread, INFINITE);
		CloseHandle(hThread);
		}
	VSS_STANDARD_CATCH(ft)

	if (!ft.HrFailed())
		// get result of initialization
		ft.hr = m_hrInitialized;

	return ft.hr;
	}


__declspec(dllexport) void CVssJetWriter::Uninitialize()
	{
	// call uninitialize
	if (m_pWriter)
		{
		CVssIJetWriter::Uninitialize((PVSSIJETWRITER) m_pWriter);
		m_pWriter = NULL;
		}
	}

__declspec(dllexport) bool CVssJetWriter::OnIdentify(IVssCreateWriterMetadata *pIVssWriterMetadata)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnIdentify");
	return true;
	}

__declspec(dllexport) bool CVssJetWriter::OnPrepareBackupBegin(IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPrepareBackupBegin");
	return true;
	}

__declspec(dllexport) bool CVssJetWriter::OnPrepareBackupEnd(IN IVssWriterComponents *pIVssWriterComponents,
							     bool fJetPrepareSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPrepareBackupEnd");
	return fJetPrepareSucceeded;
	}

__declspec(dllexport) bool CVssJetWriter::OnPrepareSnapshotBegin()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPrepareSnapshotBegin");
	return true;
	}

__declspec(dllexport) bool CVssJetWriter::OnPrepareSnapshotEnd(bool fJetPrepareSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPrepareSnapshotEnd");
	return fJetPrepareSucceeded;
	}

__declspec(dllexport) bool CVssJetWriter::OnFreezeBegin()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnFreezeBegin");
	return true;
	}

__declspec(dllexport) bool CVssJetWriter::OnFreezeEnd(bool fJetFreezeSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnFreezeEnd");
	return fJetFreezeSucceeded;
	}

__declspec(dllexport) bool CVssJetWriter::OnThawBegin()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnThawBegin");
	return true;
	}

__declspec(dllexport) bool CVssJetWriter::OnThawEnd(bool fJetThawSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnThawEnd");
	return fJetThawSucceeded;
	}

__declspec(dllexport) bool CVssJetWriter::OnPostSnapshot(IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPostSnapshot");
	return true;
	}


__declspec(dllexport) void CVssJetWriter::OnAbortBegin()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnAbortBegin");
  	}

__declspec(dllexport) void CVssJetWriter::OnAbortEnd()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnAbortEnd");
  	}

__declspec(dllexport) bool CVssJetWriter::OnBackupCompleteBegin(IN IVssWriterComponents *pComponent)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnBackupCompleteBegin");
	return true;
  	}

__declspec(dllexport) bool CVssJetWriter::OnBackupCompleteEnd(IN IVssWriterComponents *pComponent,
							      bool fJetBackupCompleteSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnBackupCompleteEnd");
	return true;
  	}

__declspec(dllexport) bool CVssJetWriter::OnPreRestoreBegin(IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPreRestoreBegin");
	return true;
  	}

__declspec(dllexport) bool CVssJetWriter::OnPreRestoreEnd(IN IVssWriterComponents *pIVssWriterComponents,
						       IN bool fJetRestoreSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPreRestoreEnd");
	return true;
  	}


__declspec(dllexport) bool CVssJetWriter::OnPostRestoreBegin(IN IVssWriterComponents *pIVssWriterComponents)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPostRestoreBegin");
	return true;
  	}

__declspec(dllexport) bool CVssJetWriter::OnPostRestoreEnd(IN IVssWriterComponents *pIVssWriterComponents,
						       IN bool fJetRestoreSucceeded)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssJetWriter::OnPostRestoreEnd");
	return true;
  	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\vssadmin\process.cpp ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Abstract:

    @doc
    @module process.cpp | The processing functions for the VSS admin CLI
    @end

Author:

    Adi Oltean  [aoltean]  04/04/2000

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     04/04/2000  Created
    ssteiner    10/20/2000  Changed List SnapshotSets to use more limited VSS queries.

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes

// The rest of includes are specified here
#include "vssadmin.h"
#include "vswriter.h"
#include "vsbackup.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "ADMPROCC"
//
////////////////////////////////////////////////////////////////////////

#define VSSADM_ONE_MB ( 1024 * 1024 )
#define VSSADM_INFINITE_DIFFAREA 0xFFFFFFFFFFFFFFFF

#define VSS_CTX_ATTRIB_MASK 0x01F

/////////////////////////////////////////////////////////////////////////////
//  Implementation


class CVssAdmSnapshotSetEntry {
public:
    // Constructor - Throws NOTHING
    CVssAdmSnapshotSetEntry(
        IN VSS_ID SnapshotSetId,
        IN INT nOriginalSnapshotsCount
        ) : m_SnapshotSetId( SnapshotSetId ),
            m_nOriginalSnapshotCount(nOriginalSnapshotsCount)
            { }

    ~CVssAdmSnapshotSetEntry()
    {
        // Have to delete all snapshots entries
        int iCount = GetSnapshotCount();
        for ( int i = 0; i < iCount; ++i )
        {
            VSS_SNAPSHOT_PROP *pSSProp;
            pSSProp = GetSnapshotAt( i );
			::VssFreeSnapshotProperties(pSSProp);

            delete pSSProp;
        }

    }

    // Add new snapshot to the snapshot set
    HRESULT AddSnapshot(
        IN CVssFunctionTracer &ft,
        IN VSS_SNAPSHOT_PROP *pVssSnapshotProp )
    {
        HRESULT hr = S_OK;
        try
        {
            VSS_SNAPSHOT_PROP *pNewVssSnapshotProp = new VSS_SNAPSHOT_PROP;
            if ( pNewVssSnapshotProp == NULL )
    			ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY, L"Out of memory" );

            *pNewVssSnapshotProp = *pVssSnapshotProp;
            if ( !m_mapSnapshots.Add( pNewVssSnapshotProp->m_SnapshotId, pNewVssSnapshotProp ) )
            {
                delete pNewVssSnapshotProp;
    			ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY, L"Out of memory" );
            }
        }
        BS_STANDARD_CATCH();

        return hr;
    }

    INT GetSnapshotCount() { return m_mapSnapshots.GetSize(); }

    INT GetOriginalSnapshotCount() { return m_nOriginalSnapshotCount; }

    VSS_ID GetSnapshotSetId() { return m_SnapshotSetId; }

    VSS_SNAPSHOT_PROP *GetSnapshotAt(
        IN int nIndex )
    {
        BS_ASSERT( !(nIndex < 0 || nIndex >= GetSnapshotCount()) );
        return m_mapSnapshots.GetValueAt( nIndex );
    }

private:
    VSS_ID  m_SnapshotSetId;
    INT     m_nOriginalSnapshotCount;
    CVssSimpleMap<VSS_ID, VSS_SNAPSHOT_PROP *> m_mapSnapshots;
};


// This class queries the list of all snapshots and assembles from the query
// the list of snapshotsets and the volumes which are in the snapshotset.
class CVssAdmSnapshotSets
{
public:
    // Constructor - Throws HRESULTS
    CVssAdmSnapshotSets(
        IN LONG lSnapshotContext,
        IN VSS_ID FilteredSnapshotSetId,
        IN VSS_ID FilteredSnapshotId,
        IN VSS_ID FilteredProviderId,
        IN LPCWSTR pwszFilteredForVolume
        )
    {
        CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdmSnapshotSets::CVssAdmSnapshotSets" );

    	// Create the coordinator object
    	CComPtr<IVssCoordinator> pICoord;

        ft.LogVssStartupAttempt();
        ft.hr = pICoord.CoCreateInstance( CLSID_VSSCoordinator );
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

        // Set the context
		ft.hr = pICoord->SetContext( lSnapshotContext );
        
        //
        //  If access denied, don't stop, it probably is a backup operator making this
        //  call.  Continue.  The coordinator will use the backup context.
        //
		if ( ft.HrFailed() && ft.hr != E_ACCESSDENIED )
			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"SetContext failed with hr = 0x%08lx", ft.hr);

		// Get list all snapshots
		CComPtr<IVssEnumObject> pIEnumSnapshots;
		ft.hr = pICoord->Query( GUID_NULL,
					VSS_OBJECT_NONE,
					VSS_OBJECT_SNAPSHOT,
					&pIEnumSnapshots );
		if ( ft.HrFailed() )
			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Query failed with hr = 0x%08lx", ft.hr);

		// For all snapshots do...
		VSS_OBJECT_PROP Prop;
		VSS_SNAPSHOT_PROP& Snap = Prop.Obj.Snap;
		for(;;) {
			// Get next element
			ULONG ulFetched;
			ft.hr = pIEnumSnapshots->Next( 1, &Prop, &ulFetched );
			if ( ft.HrFailed() )
				ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);
			
			// Test if the cycle is finished
			if (ft.hr == S_FALSE) {
				BS_ASSERT( ulFetched == 0);
				break;
			}

            // If filtering, skip entry if snapshot set id is not in the specified snapshot set
			if ( ( FilteredSnapshotSetId != GUID_NULL ) && 
			     !( Snap.m_SnapshotSetId == FilteredSnapshotSetId ) )
			    continue;

            // If filtering, skip entry if snapshot id is not in the specified snapshot set
			if ( ( FilteredSnapshotId != GUID_NULL ) && 
			     !( Snap.m_SnapshotId == FilteredSnapshotId ) )
			    continue;

            // If filtering, skip entry if provider ID is not in the specified snapshot
			if ( ( FilteredProviderId != GUID_NULL ) && 
			     !( Snap.m_ProviderId == FilteredProviderId ) )
			    continue;

            // If filtering, skip entry if FOR volume is not in the specified snapshot
			if ( ( pwszFilteredForVolume != NULL ) && ( pwszFilteredForVolume[0] != '\0' ) && 
			     ( ::_wcsicmp( pwszFilteredForVolume, Snap.m_pwszOriginalVolumeName ) != 0 ) )
			    continue;

            ft.Trace( VSSDBG_VSSADMIN, L"Snapshot: %s", Snap.m_pwszOriginalVolumeName );

            // Look up the snapshot set id in the list of snapshot sets
            CVssAdmSnapshotSetEntry *pcSSE;
			pcSSE = m_mapSnapshotSets.Lookup( Snap.m_SnapshotSetId );
			if ( pcSSE == NULL )
			{
			    // Haven't seen this snapshot set before, add it to list
			    pcSSE = new CVssAdmSnapshotSetEntry( Snap.m_SnapshotSetId,
			                    Snap.m_lSnapshotsCount );
			    if ( pcSSE == NULL )
        			ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY, L"Out of memory" );
			    if ( !m_mapSnapshotSets.Add( Snap.m_SnapshotSetId, pcSSE ) )
			    {
			        delete pcSSE;
        			ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY, L"Out of memory" );
			    }
			}

			// Now add the snapshot to the snapshot set
			ft.hr = pcSSE->AddSnapshot( ft, &Snap );
			if ( ft.HrFailed() )
      			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"AddSnapshot failed" );			
		}
    }

    ~CVssAdmSnapshotSets()
    {
        CVssFunctionTracer ft( VSSDBG_VSSADMIN, L"CVssAdmSnapshotSets::~CVssAdmSnapshotSets" );
        // Have to delete all
        int iCount;
        iCount = m_mapSnapshotSets.GetSize();
        for ( int i = 0; i < iCount; ++i )
        {
            delete m_mapSnapshotSets.GetValueAt( i );
        }
    }

    INT GetSnapshotSetCount() { return m_mapSnapshotSets.GetSize(); }

    CVssAdmSnapshotSetEntry *GetSnapshotSetAt(
        IN int nIndex )
    {
        BS_ASSERT( !(nIndex < 0 || nIndex >= GetSnapshotSetCount()) );
        return m_mapSnapshotSets.GetValueAt( nIndex );
    }


private:
    CVssSimpleMap<VSS_ID, CVssAdmSnapshotSetEntry *> m_mapSnapshotSets;
};

/////////////////////////////////////////////////////////////////////////////
//  Implementation


void CVssAdminCLI::PrintUsage(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
    //
    //  Based on parsed command line type, print detailed command usage if
    //  eAdmCmd is valid, else print general vssadmin usage
    //
    if ( m_sParsedCommand.eAdmCmd != VSSADM_C_INVALID )
    {
        OutputMsg( ft, g_asAdmCommands[m_sParsedCommand.eAdmCmd].lMsgDetail,
                   g_asAdmCommands[m_sParsedCommand.eAdmCmd].pwszMajorOption,
                   g_asAdmCommands[m_sParsedCommand.eAdmCmd].pwszMinorOption);
        if ( g_asAdmCommands[m_sParsedCommand.eAdmCmd].bShowSSTypes )
            DumpSnapshotTypes( ft );
        return;
    }

    //
    //  Print out header
    //
    OutputMsg( ft, MSG_USAGE );

    //
    //  Figure out the maximum command length to help with formatting
    //
    INT idx;
    INT iMaxLen = 0;

    for ( idx = VSSADM_C_FIRST; idx < VSSADM_C_NUM_COMMANDS; ++idx )
    {
        if ( CVssSKU::GetSKU() & g_asAdmCommands[idx].dwSKUs )
        {
            size_t cCmd;
            cCmd = ::wcslen( g_asAdmCommands[idx].pwszMajorOption ) +
                   ::wcslen( g_asAdmCommands[idx].pwszMinorOption ) + 1;
            if ( iMaxLen < (INT)cCmd )
                iMaxLen = (INT)cCmd;
        }
    }

    //
    //  Get a string to hold the string
    //
    LPWSTR pwszCommand;
    pwszCommand = new WCHAR[iMaxLen + 1];
    if (pwszCommand == NULL )
        ft.Throw( VSSDBG_VSSADMIN, E_OUTOFMEMORY,
            L"CVssAdminCLI::PrintUsage: Can't get memory: %d",
            ::GetLastError() );

    //
    //  Go through the list of commands and print the general information
    //  about each.
    //
    for ( idx = VSSADM_C_FIRST; idx < VSSADM_C_NUM_COMMANDS; ++idx )
    {
        if ( CVssSKU::GetSKU() & g_asAdmCommands[idx].dwSKUs )
        {
            //  stick both parts of the command together
            ::wcscpy( pwszCommand, g_asAdmCommands[idx].pwszMajorOption );
            ::wcscat( pwszCommand, L" " );
            ::wcscat( pwszCommand, g_asAdmCommands[idx].pwszMinorOption );
            //  pad with spaces at the end
            for ( INT i = (INT) ::wcslen( pwszCommand); i < iMaxLen; ++i )
                pwszCommand[i] = L' ';
            pwszCommand[iMaxLen] = L'\0';
            OutputMsg( ft, g_asAdmCommands[idx].lMsgGen, pwszCommand );
        }
    }

    delete[] pwszCommand;
	m_nReturnValue = VSS_CMDRET_SUCCESS;    
}

void CVssAdminCLI::AddDiffArea(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
    VSS_ID ProviderId = GUID_NULL;

    //
    // Convert provider option to a VSS_ID
    //
    LPCWSTR pwszProvider = GetOptionValueStr( VSSADM_O_PROVIDER );

    //
    //  Determine if this is an ID or a name
    //
    if ( !ScanGuid( ft, pwszProvider, ProviderId ) )
    {
        //  Have a provider name, look it up
        if ( !GetProviderId( ft, pwszProvider, &ProviderId ) )
        {
            // Provider name not found, print error
            OutputErrorMsg( ft, MSG_ERROR_PROVIDER_NAME_NOT_FOUND, pwszProvider );
            return;
        }
    }

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pIMgmt;

    ft.LogVssStartupAttempt();
    ft.hr = pIMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt );
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pIDiffSnapMgmt;
	ft.hr = pIMgmt->GetProviderMgmtInterface( ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pIDiffSnapMgmt );
	if ( ft.HrFailed() )
	{
	    if ( ft.hr == E_NOINTERFACE )
	    {
	        //  The provider doesn't support this interface
            OutputErrorMsg( ft, MSG_ERROR_PROVIDER_DOESNT_SUPPORT_DIFFAREAS, pwszProvider );
	        return;
	    }
  		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"GetProviderMgmtInterface failed with hr = 0x%08lx", ft.hr);
	}

	LONGLONG llMaxSize;
    if ( GetOptionValueNum( ft, VSSADM_O_MAXSIZE, &llMaxSize ) )
    {
        if ( llMaxSize < VSSADM_ONE_MB )
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_NUMBER,
                L"CVssAdminCLI::AddDiffarea: A maxsize of less than 1 MB specified, invalid");
    }
    else
    {
        llMaxSize = VSSADM_INFINITE_DIFFAREA;
    }
    
    //  Now add the assocation
    ft.hr = pIDiffSnapMgmt->AddDiffArea( 
        GetOptionValueStr( VSSADM_O_FOR ), 
        GetOptionValueStr( VSSADM_O_ON ), 
        llMaxSize );
	if ( ft.HrFailed() )
	{
	    switch( ft.hr )
	    {
	        case VSS_E_OBJECT_ALREADY_EXISTS:
                OutputErrorMsg( ft, MSG_ERROR_ASSOCIATION_ALREADY_EXISTS );                        
	            break;
	        default: 
    	 		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"AddDiffArea failed with hr = 0x%08lx", ft.hr);
    	 		break;
	    }
	    
	    return;
	}
	
    //
    //  Print results, if needed
    //
    if ( !IsQuiet() )
    {
        OutputMsg( ft, MSG_INFO_ADDED_DIFFAREA );
    }

	m_nReturnValue = VSS_CMDRET_SUCCESS;
}

void CVssAdminCLI::CreateSnapshot(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
    LONG lContext;

    //
    // First determine the snapshot type as specified by the user
    //
    lContext = DetermineSnapshotType( ft, GetOptionValueStr( VSSADM_O_SNAPTYPE ) );

    //
    //  There are two different ways snapshots are created.  One is where
    //  the backup components has to be used when writers have to be invoked,
    //  and the other is to directly call the coordinator.
    //
    if ( lContext | VSS_VOLSNAP_ATTR_NO_WRITERS )
    {
        CreateNoWritersSnapshot( lContext );
    }
}

void CVssAdminCLI::DisplayDiffAreasPrivate(
	IN	CVssFunctionTracer& ft,
   	IVssEnumMgmtObject *pIEnumMgmt	
	) throw(HRESULT)
{
	// For all diffareas do...
	VSS_MGMT_OBJECT_PROP Prop;
	VSS_DIFF_AREA_PROP& DiffArea = Prop.Obj.DiffArea; 
	for(;;) 
	{
		// Get next element
		ULONG ulFetched;
		ft.hr = pIEnumMgmt->Next( 1, &Prop, &ulFetched );
		if ( ft.HrFailed() )
			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        LPWSTR pwszUsedSpace, pwszAllocatedSpace, pwszMaxSpace;
        pwszUsedSpace =       FormatNumber( ft, DiffArea.m_llUsedDiffSpace );
        pwszAllocatedSpace =  FormatNumber( ft, DiffArea.m_llAllocatedDiffSpace );
        pwszMaxSpace =        FormatNumber( ft, DiffArea.m_llMaximumDiffSpace );

        OutputMsg( ft, MSG_INFO_SNAPSHOT_STORAGE_CONTENTS,
            DiffArea.m_pwszVolumeName, 
            DiffArea.m_pwszDiffAreaVolumeName,
            pwszUsedSpace,
            pwszAllocatedSpace,
            pwszMaxSpace
            );

        ::VssFreeString(pwszUsedSpace);
        ::VssFreeString(pwszAllocatedSpace);
        ::VssFreeString(pwszMaxSpace);
        ::CoTaskMemFree(DiffArea.m_pwszVolumeName);
        ::CoTaskMemFree(DiffArea.m_pwszDiffAreaVolumeName);
	}
}

void CVssAdminCLI::ListDiffAreas(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
    //  Make sure user didn't specify both /On and /For
    if ( GetOptionValueStr( VSSADM_O_FOR ) != NULL && GetOptionValueStr( VSSADM_O_ON ) != NULL )
        ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_SET_OF_OPTIONS,
            L"CVssAdminCLI::ListDiffAreas: Can't specify both ON and FOR volume options" );

    VSS_ID ProviderId = GUID_NULL;

    //
    // Convert provider option to a VSS_ID
    //
    LPCWSTR pwszProvider = GetOptionValueStr( VSSADM_O_PROVIDER );

    //
    //  Determine if this is an ID or a name
    //
    if ( !ScanGuid( ft, pwszProvider, ProviderId ) )
    {
        //  Have a provider name, look it up
        if ( !GetProviderId( ft, pwszProvider, &ProviderId ) )
        {
            // Provider name not found, print error
            OutputErrorMsg( ft, MSG_ERROR_PROVIDER_NAME_NOT_FOUND, pwszProvider );
            return;
        }
    }

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pIMgmt;

    ft.LogVssStartupAttempt();
    ft.hr = pIMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt );
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pIDiffSnapMgmt;
	ft.hr = pIMgmt->GetProviderMgmtInterface( ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pIDiffSnapMgmt );
	if ( ft.HrFailed() )
	{
	    if ( ft.hr == E_NOINTERFACE )
	    {
	        //  The provider doesn't support this interface
            OutputErrorMsg( ft, MSG_ERROR_PROVIDER_DOESNT_SUPPORT_DIFFAREAS, pwszProvider );
	        return;
	    }
  		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"GetProviderMgmtInterface failed with hr = 0x%08lx", ft.hr);
	}

    //  See if query by for volume
    if ( GetOptionValueStr( VSSADM_O_FOR ) != NULL )
    {        
        //  Query by For volume
    	CComPtr<IVssEnumMgmtObject> pIEnumMgmt;
        ft.hr = pIDiffSnapMgmt->QueryDiffAreasForVolume( 
                    GetOptionValueStr( VSSADM_O_FOR ),
                    &pIEnumMgmt );
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"QueryDiffAreasForVolume failed, hr = 0x%08lx", ft.hr);

        if ( ft.hr == S_FALSE )
            // empty query
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_NO_ITEMS_IN_QUERY,
                L"CVssAdminCLI::ListDiffareas: No diffareas found that satisfy the query" );

        DisplayDiffAreasPrivate( ft, pIEnumMgmt );
    }
    else if ( GetOptionValueStr( VSSADM_O_ON ) != NULL )
    {
        //  Query by On volume
    	CComPtr<IVssEnumMgmtObject> pIEnumMgmt;
        ft.hr = pIDiffSnapMgmt->QueryDiffAreasOnVolume( 
                    GetOptionValueStr( VSSADM_O_ON ),
                    &pIEnumMgmt );
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"QueryDiffAreasOnVolume failed, hr = 0x%08lx", ft.hr);
            
        if ( ft.hr == S_FALSE )
            // empty query
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_NO_ITEMS_IN_QUERY,
                L"CVssAdminCLI::ListDiffareas: No diffareas found that satisfy the query" );

        DisplayDiffAreasPrivate( ft, pIEnumMgmt );
    }
    else
    {
        //  Query all diff areas

        //
        //  Get the list of all volumes
        //
    	CComPtr<IVssEnumMgmtObject> pIEnumMgmt;
        ft.hr = pIMgmt->QueryVolumesSupportedForSnapshots( 
                    ProviderId,
                    VSS_CTX_ALL,
                    &pIEnumMgmt );
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"QueryVolumesSupportedForSnapshots failed, hr = 0x%08lx", ft.hr);

        if ( ft.hr == S_FALSE )
            // empty query
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_NO_ITEMS_IN_QUERY,
                L"CVssAdminCLI::ListDiffareas: No diffareas found that satisfy the query" );

        //
        //  Query each volume to see if diff areas exist.
        //
    	VSS_MGMT_OBJECT_PROP Prop;
    	VSS_VOLUME_PROP& VolProp = Prop.Obj.Vol; 
    	for(;;) 
    	{
    		// Get next element
    		ULONG ulFetched;
    		ft.hr = pIEnumMgmt->Next( 1, &Prop, &ulFetched );
    		if ( ft.HrFailed() )
    			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);
    		
    		// Test if the cycle is finished
    		if (ft.hr == S_FALSE) {
    			BS_ASSERT( ulFetched == 0);
    			break;
    		}

        	// For all volumes do...
        	CComPtr<IVssEnumMgmtObject> pIEnumMgmtDiffArea;
            ft.hr = pIDiffSnapMgmt->QueryDiffAreasForVolume( 
                        VolProp.m_pwszVolumeName,
                        &pIEnumMgmtDiffArea );
            if ( ft.HrFailed() )
                ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"QueryDiffAreasForVolume failed, hr = 0x%08lx", ft.hr);

            if ( ft.hr == S_FALSE )
                // empty query
                continue;
            
            DisplayDiffAreasPrivate( ft, pIEnumMgmtDiffArea );
            
            ::CoTaskMemFree(VolProp.m_pwszVolumeName);
            ::CoTaskMemFree(VolProp.m_pwszVolumeDisplayName);
    	}
    }

    m_nReturnValue = VSS_CMDRET_SUCCESS;
}

void CVssAdminCLI::ListSnapshots(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
    bool bNonEmptyResult = false;

    //  See if we have to filter by snapshot set id
    VSS_ID guidSSID = GUID_NULL;
    if ( GetOptionValueStr( VSSADM_O_SET ) != NULL )
    {
        //  Get GUID
        if ( !ScanGuid( ft, GetOptionValueStr( VSSADM_O_SET ), guidSSID ) )
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE,
                L"CVssAdminCLI::ListSnapshots: invalid snapshot set ID: %s",
                GetOptionValueStr( VSSADM_O_SET ) );
    }

    //  Set if we have to filter by snapshot id
    VSS_ID guidSnapID = GUID_NULL;
    if ( GetOptionValueStr( VSSADM_O_SNAPSHOT ) != NULL )
    {
        //  Can't specify both snapshot set id and snapshot id
        if ( guidSSID != GUID_NULL )
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_SET_OF_OPTIONS,
                L"CVssAdminCLI::ListSnapshots: Cannot specify both /SET and /SNAPSHOT options at the same time" );
            
        //  Get GUID
        if ( !ScanGuid( ft, GetOptionValueStr( VSSADM_O_SNAPSHOT ), guidSnapID ) )
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE,
                L"CVssAdminCLI::ListSnapshots: invalid snapshot ID: %s",
                GetOptionValueStr( VSSADM_O_SNAPSHOT ) );
    }

    //  Figure out snapshot context
    LONG lSnapshotContext;
    lSnapshotContext = DetermineSnapshotType( ft, GetOptionValueStr( VSSADM_O_SNAPTYPE ) ); 

    // See if we have to filter by volume name
  	WCHAR wszVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1] = L"";    
    if ( GetOptionValueStr( VSSADM_O_FOR ) != NULL )
    {
        // Calculate the unique volume name, just to make sure that we have the right path
        // If FOR volume name starts with the '\', assume it is already in the correct volume name format.
        // This is important for transported volumes since GetVolumeNameForVolumeMountPointW() won't work.
        if ( GetOptionValueStr( VSSADM_O_FOR )[0] != L'\\' )
        {
    	    if (!::GetVolumeNameForVolumeMountPointW( GetOptionValueStr( VSSADM_O_FOR ),
    		    	wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
        		ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
        				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
        				  L"failed with error code 0x%08lx", GetOptionValueStr( VSSADM_O_FOR ), ::GetLastError());
        }
        else
            ::wcsncpy( wszVolumeNameInternal, GetOptionValueStr( VSSADM_O_FOR ), STRING_LEN(wszVolumeNameInternal) );
    }
    
    //
    //  See if we have to filter by provider
    //
    VSS_ID ProviderId = GUID_NULL;
    LPCWSTR pwszProvider = GetOptionValueStr( VSSADM_O_PROVIDER );
    if ( pwszProvider != NULL )
    {
        //
        //  Determine if this is an ID or a name
        //
        if ( !ScanGuid( ft, pwszProvider, ProviderId ) )
        {
            //  Have a provider name, look it up
            if ( !GetProviderId( ft, pwszProvider, &ProviderId ) )
            {
                // Provider name not found, print error
                OutputErrorMsg( ft, MSG_ERROR_PROVIDER_NAME_NOT_FOUND, pwszProvider );
                return;
            }
        }
    }

    //  Query the snapshots
    CVssAdmSnapshotSets cVssAdmSS( lSnapshotContext, guidSSID, guidSnapID, ProviderId, wszVolumeNameInternal );

    INT iSnapshotSetCount = cVssAdmSS.GetSnapshotSetCount();

    // If there are no present snapshots then display a message.
    if (iSnapshotSetCount == 0) {
        ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_NO_ITEMS_IN_QUERY,
            L"CVssAdminCLI::ListSnapshots: No snapshots found that satisfy the query");
    }

	// For all snapshot sets do...
    for ( INT iSSS = 0; iSSS < iSnapshotSetCount; ++iSSS )
    {
        CVssAdmSnapshotSetEntry *pcSSE;

        pcSSE = cVssAdmSS.GetSnapshotSetAt( iSSS );
        BS_ASSERT( pcSSE != NULL );

        LPWSTR pwszGuid;
        LPWSTR pwszDateTime;
        pwszGuid = ::GuidToString( ft, pcSSE->GetSnapshotSetId() );
        pwszDateTime = ::DateTimeToString( ft, &( pcSSE->GetSnapshotAt( 0 )->m_tsCreationTimestamp ) );
        
		// Print each snapshot set
		OutputMsg( 
		    ft, 
		    MSG_INFO_SNAPSHOT_SET_HEADER,
			pwszGuid, 
			pcSSE->GetOriginalSnapshotCount(), 
			pwszDateTime );
		
        ::VssFreeString( pwszGuid );
        ::VssFreeString( pwszDateTime );
        
		INT iSnapshotCount = pcSSE->GetSnapshotCount();
		
		VSS_SNAPSHOT_PROP *pSnap;
		for( INT iSS = 0; iSS < iSnapshotCount; ++iSS ) {
		    pSnap = pcSSE->GetSnapshotAt( iSS );
            BS_ASSERT( pSnap != NULL );

    		// Get the provider name
			LPCWSTR pwszProviderName =
				GetProviderName(ft, pSnap->m_ProviderId);
            LPWSTR pwszAttributeStr = BuildSnapshotAttributeDisplayString( ft, pSnap->m_lSnapshotAttributes );			
            LPWSTR pwszSnapshotType = DetermineSnapshotType( ft, pSnap->m_lSnapshotAttributes );
            
            // Print each snapshot            
			pwszGuid = ::GuidToString( ft, pSnap->m_SnapshotId );          
			OutputMsg( ft, 
			    MSG_INFO_SNAPSHOT_CONTENTS,                
				pwszGuid, 
				pSnap->m_pwszOriginalVolumeName, 
				pSnap->m_pwszSnapshotDeviceObject,
				pSnap->m_pwszOriginatingMachine ? pSnap->m_pwszOriginatingMachine : L"",
				pSnap->m_pwszServiceMachine ? pSnap->m_pwszServiceMachine : L"",  // fix this when the idl file changes
				pwszProviderName ? pwszProviderName : L"?",
				pwszSnapshotType,
				pwszAttributeStr
				);

            ::VssFreeString( pwszGuid );
            ::VssFreeString( pwszAttributeStr );
            ::VssFreeString( pwszSnapshotType );
			bNonEmptyResult = true;
		}
	}

	m_nReturnValue = bNonEmptyResult? VSS_CMDRET_SUCCESS: VSS_CMDRET_EMPTY_RESULT;
}


void CVssAdminCLI::DumpSnapshotTypes(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
    //
    //  Dump list of snapshot types based on SKU
    //
    INT idx;

    // Determine type of snapshot
    for ( idx = 0; g_asAdmTypeNames[idx].pwszName != NULL; ++idx )
    {
        if ( CVssSKU::GetSKU() & g_asAdmTypeNames[idx].dwSKUs )
        {
            OutputOnConsole( L"       " );
            OutputOnConsole( g_asAdmTypeNames[idx].pwszName );
            OutputOnConsole( L"\r\n" );
        }
    }    

    UNREFERENCED_PARAMETER( ft );
}

void CVssAdminCLI::ListWriters(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
    bool bNonEmptyResult = false;

    // Get the backup components object
    CComPtr<IVssBackupComponents> pBackupComp;
	CComPtr<IVssAsync> pAsync;
    ft.hr = ::CreateVssBackupComponents(&pBackupComp);
    if (ft.HrFailed())
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"CreateVssBackupComponents failed with hr = 0x%08lx", ft.hr);

    // BUGBUG Initialize for backup
    ft.hr = pBackupComp->InitializeForBackup();
    if (ft.HrFailed())
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"InitializeForBackup failed with hr = 0x%08lx", ft.hr);

	UINT unWritersCount;
	// get metadata for all writers
	ft.hr = pBackupComp->GatherWriterMetadata(&pAsync);
	if (ft.HrFailed())
		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"GatherWriterMetadata failed with hr = 0x%08lx", ft.hr);

    // Using polling, try to obtain the list of writers as soon as possible
    HRESULT hrReturned = S_OK;
    for (int nRetries = 0; nRetries < MAX_RETRIES_COUNT; nRetries++ ) {

        // Wait a little
        ::Sleep(nPollingInterval);

        // Check if finished
        INT nReserved = 0;
    	ft.hr = pAsync->QueryStatus(
    	    &hrReturned,
    	    &nReserved
    	    );
        if (ft.HrFailed())
            ft.Throw( VSSDBG_VSSADMIN, ft.hr,
                L"IVssAsync::QueryStatus failed with hr = 0x%08lx", ft.hr);
        if (hrReturned == VSS_S_ASYNC_FINISHED)
            break;
        if (hrReturned == VSS_S_ASYNC_PENDING)
            continue;
        ft.Throw( VSSDBG_VSSADMIN, ft.hr,
            L"IVssAsync::QueryStatus returned hr = 0x%08lx", hrReturned);
    }

    // If still not ready, then print the "waiting for responses" message and wait.
    if (hrReturned == VSS_S_ASYNC_PENDING) {
        OutputMsg( ft, MSG_INFO_WAITING_RESPONSES );
    	ft.hr = pAsync->Wait();
        if (ft.HrFailed())
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"IVssAsync::Wait failed with hr = 0x%08lx", ft.hr);
    }

	pAsync = NULL;
	
    // Gather the status of all writers
	ft.hr = pBackupComp->GatherWriterStatus(&pAsync);
	if (ft.HrFailed())
		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"GatherWriterMetadata failed with hr = 0x%08lx", ft.hr);

	ft.hr = pAsync->Wait();
    if (ft.HrFailed())
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"IVssAsync::Wait failed with hr = 0x%08lx", ft.hr);

	pAsync = NULL;

	ft.hr = pBackupComp->GetWriterStatusCount(&unWritersCount);
    if (ft.HrFailed())
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"GetWriterStatusCount failed with hr = 0x%08lx", ft.hr);

    // Print each writer status+supplementary info
	for(UINT unIndex = 0; unIndex < unWritersCount; unIndex++)
	{
		VSS_ID idInstance;
		VSS_ID idWriter;
		CComBSTR bstrWriter;
		VSS_WRITER_STATE eStatus;
		HRESULT hrWriterFailure;

        // Get the status for the (unIndex)-th writer
		ft.hr = pBackupComp->GetWriterStatus(unIndex, &idInstance, &idWriter, &bstrWriter, &eStatus, &hrWriterFailure);
        if (ft.HrFailed())
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"GetWriterStatus failed with hr = 0x%08lx", ft.hr);

        // Get the status description strings
        LPCWSTR pwszStatusDescription;
        switch (eStatus) 
        {
            case VSS_WS_STABLE:
                pwszStatusDescription = LoadString( ft, IDS_WRITER_STATUS_STABLE);
                break;
            case VSS_WS_WAITING_FOR_FREEZE:
                pwszStatusDescription = LoadString( ft, IDS_WRITER_STATUS_WAITING_FOR_FREEZE);
                break;
            case VSS_WS_WAITING_FOR_THAW:
                pwszStatusDescription = LoadString( ft, IDS_WRITER_STATUS_FROZEN);
                break;
            case VSS_WS_WAITING_FOR_BACKUP_COMPLETE:
                pwszStatusDescription = LoadString( ft, IDS_WRITER_STATUS_WAITING_FOR_COMPLETION);
                break;
            case VSS_WS_FAILED_AT_IDENTIFY:
            case VSS_WS_FAILED_AT_PREPARE_BACKUP:
            case VSS_WS_FAILED_AT_PREPARE_SNAPSHOT:
            case VSS_WS_FAILED_AT_FREEZE:
            case VSS_WS_FAILED_AT_THAW:
                pwszStatusDescription = LoadString( ft, IDS_WRITER_STATUS_FAILED);
                break;
            default:
                pwszStatusDescription = LoadString( ft, IDS_WRITER_STATUS_UNKNOWN);
                break;
        }
        BS_ASSERT(pwszStatusDescription);

        LPCWSTR pwszWriterError;
        switch ( hrWriterFailure )
        {
            case S_OK:
                pwszWriterError = LoadString ( ft, IDS_WRITER_ERROR_SUCCESS );
                break;
            case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:
                pwszWriterError = LoadString( ft, IDS_WRITER_ERROR_INCONSISTENTSNAPSHOT);
                break; 
            case VSS_E_WRITERERROR_OUTOFRESOURCES:
                pwszWriterError = LoadString( ft, IDS_WRITER_ERROR_OUTOFRESOURCES);
                break;
            case VSS_E_WRITERERROR_TIMEOUT:
                pwszWriterError = LoadString( ft, IDS_WRITER_ERROR_TIMEOUT);
                break;        
            case VSS_E_WRITERERROR_RETRYABLE:
                pwszWriterError = LoadString( ft, IDS_WRITER_ERROR_RETRYABLE);
                break;
            case VSS_E_WRITERERROR_NONRETRYABLE:
                pwszWriterError = LoadString( ft, IDS_WRITER_ERROR_NONRETRYABLE);
                break;
            default:
                pwszWriterError = LoadString( ft, IDS_WRITER_ERROR_UNEXPECTED);
                ft.Trace( VSSDBG_VSSADMIN, L"Unexpected writer error failure: 0x%08x", hrWriterFailure );
                break;                
        }
        
        LPWSTR pwszWriterId =   ::GuidToString( ft, idWriter );
		LPWSTR pwszInstanceId = ::GuidToString( ft, idInstance );
		
		OutputMsg( ft, MSG_INFO_WRITER_CONTENTS,
            (LPWSTR)bstrWriter ? (LPWSTR)bstrWriter : L"",
			pwszWriterId,
			pwszInstanceId,
            (INT)eStatus,
			pwszStatusDescription,
			pwszWriterError
			);
		
        ::VssFreeString(pwszWriterId);
        ::VssFreeString(pwszInstanceId);

		bNonEmptyResult = true;
    }

	ft.hr = pBackupComp->FreeWriterStatus();
    if (ft.HrFailed())
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"FreeWriterStatus failed with hr = 0x%08lx", ft.hr);

	m_nReturnValue = bNonEmptyResult? VSS_CMDRET_SUCCESS: VSS_CMDRET_EMPTY_RESULT;
}


void CVssAdminCLI::ListProviders(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
    bool bNonEmptyResult = false;

	// Create the coordinator object
	CComPtr<IVssCoordinator> pICoord;

    ft.LogVssStartupAttempt();
    ft.hr = pICoord.CoCreateInstance( CLSID_VSSCoordinator );
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

	// Query all (filtered) snapshot sets
	CComPtr<IVssEnumObject> pIEnumProv;
	ft.hr = pICoord->Query( GUID_NULL,
				VSS_OBJECT_NONE,
				VSS_OBJECT_PROVIDER,
				&pIEnumProv );
	if ( ft.HrFailed() )
		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Query failed with hr = 0x%08lx", ft.hr);

	// For all snapshot sets do...
	VSS_OBJECT_PROP Prop;
	VSS_PROVIDER_PROP& Prov = Prop.Obj.Prov;
	for(;;) {
		// Get next element
		ULONG ulFetched;
		ft.hr = pIEnumProv->Next( 1, &Prop, &ulFetched );
		if ( ft.HrFailed() )
			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);
		
		// Test if the cycle is ended
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        // Get the provider type strings
        LPCWSTR pwszProviderType;
        switch (Prov.m_eProviderType) {
        case VSS_PROV_SYSTEM:
            pwszProviderType = LoadString( ft, IDS_PROV_TYPE_SYSTEM);
            break;
        case VSS_PROV_SOFTWARE:
            pwszProviderType = LoadString( ft, IDS_PROV_TYPE_SOFTWARE);
            break;
        case VSS_PROV_HARDWARE:
            pwszProviderType = LoadString( ft, IDS_PROV_TYPE_HARDWARE);
            break;
        default:
            pwszProviderType = LoadString( ft, IDS_PROV_TYPE_UNKNOWN);
            break;
        }
        BS_ASSERT(pwszProviderType);

		// Print each snapshot set
		LPWSTR pwszProviderId;
		pwszProviderId = ::GuidToString( ft, Prov.m_ProviderId );
		OutputMsg( ft, MSG_INFO_PROVIDER_CONTENTS,
            Prov.m_pwszProviderName? Prov.m_pwszProviderName: L"",
			pwszProviderType,
			pwszProviderId,
            Prov.m_pwszProviderVersion ? Prov.m_pwszProviderVersion: L"");

        ::VssFreeString(pwszProviderId);
		::CoTaskMemFree(Prov.m_pwszProviderName);
		::CoTaskMemFree(Prov.m_pwszProviderVersion);

		bNonEmptyResult = true;
	}

	m_nReturnValue = bNonEmptyResult? VSS_CMDRET_SUCCESS: VSS_CMDRET_EMPTY_RESULT;
}

void CVssAdminCLI::ListVolumes(
    IN CVssFunctionTracer& ft
    ) throw(HRESULT)
{
    LONG lContext;
    VSS_ID ProviderId = GUID_NULL;

    //
    // First determine the snapshot type as specified by the user
    //
    lContext = DetermineSnapshotType( ft, GetOptionValueStr( VSSADM_O_SNAPTYPE ) );

    //
    // Convert provider option to a VSS_ID
    //
    LPCWSTR pwszProvider = GetOptionValueStr( VSSADM_O_PROVIDER );

    //
    //  Determine if this is an ID or a name
    //
    if ( !ScanGuid( ft, pwszProvider, ProviderId ) )
    {
        //  Have a provider name, look it up
        if ( !GetProviderId( ft, pwszProvider, &ProviderId ) )
        {
            // Provider name not found, print error
            OutputErrorMsg( ft, MSG_ERROR_PROVIDER_NAME_NOT_FOUND, pwszProvider );
            return;
        }
    }

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pIMgmt;

    ft.LogVssStartupAttempt();
    ft.hr = pIMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt );
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

    //
    //  Get the list of all volumes
    //
	CComPtr<IVssEnumMgmtObject> pIEnumMgmt;
    ft.hr = pIMgmt->QueryVolumesSupportedForSnapshots( 
                ProviderId,
                lContext,
                &pIEnumMgmt );
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"QueryVolumesSupportedForSnapshots failed, hr = 0x%08lx", ft.hr);

    if ( ft.hr == S_FALSE )
        // empty query
        ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_NO_ITEMS_IN_QUERY,
            L"CVssAdminCLI::ListVolumes: No volumes found that satisfy the query" );

    //
    //  Query each volume to see if diff areas exist.
    //
	VSS_MGMT_OBJECT_PROP Prop;
	VSS_VOLUME_PROP& VolProp = Prop.Obj.Vol; 

	for(;;) 
	{
		// Get next element
		ULONG ulFetched;
		ft.hr = pIEnumMgmt->Next( 1, &Prop, &ulFetched );
		if ( ft.HrFailed() )
			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        OutputMsg( ft, MSG_INFO_VOLUME_CONTENTS, VolProp.m_pwszVolumeDisplayName, VolProp.m_pwszVolumeName );        
        ::CoTaskMemFree(VolProp.m_pwszVolumeName);
        ::CoTaskMemFree(VolProp.m_pwszVolumeDisplayName);
	}

	m_nReturnValue = VSS_CMDRET_SUCCESS;
}

void CVssAdminCLI::ResizeDiffArea(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
    VSS_ID ProviderId = GUID_NULL;

    //
    // Convert provider option to a VSS_ID
    //
    LPCWSTR pwszProvider = GetOptionValueStr( VSSADM_O_PROVIDER );

    //
    //  Determine if this is an ID or a name
    //
    if ( !ScanGuid( ft, pwszProvider, ProviderId ) )
    {
        //  Have a provider name, look it up
        if ( !GetProviderId( ft, pwszProvider, &ProviderId ) )
        {
            // Provider name not found, print error
            OutputErrorMsg( ft, MSG_ERROR_PROVIDER_NAME_NOT_FOUND, pwszProvider );
            return;
        }
    }

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pIMgmt;

    ft.LogVssStartupAttempt();
    ft.hr = pIMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt );
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pIDiffSnapMgmt;
	ft.hr = pIMgmt->GetProviderMgmtInterface( ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pIDiffSnapMgmt );
	if ( ft.HrFailed() )
	{
	    if ( ft.hr == E_NOINTERFACE )
	    {
	        //  The provider doesn't support this interface
            OutputErrorMsg( ft, MSG_ERROR_PROVIDER_DOESNT_SUPPORT_DIFFAREAS, pwszProvider );
	        return;
	    }
  		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"GetProviderMgmtInterface failed with hr = 0x%08lx", ft.hr);
	}

	LONGLONG llMaxSize;
    if ( GetOptionValueNum( ft, VSSADM_O_MAXSIZE, &llMaxSize ) )
    {
        if ( llMaxSize > -1 && llMaxSize < VSSADM_ONE_MB )
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_NUMBER,
                L"CVssAdminCLI::ResizeDiffarea: maxsize of less than 1 MB specified, invalid");
    }
    else
    {
        llMaxSize = VSSADM_INFINITE_DIFFAREA;
    }

    //  Now add the assocation
    ft.hr = pIDiffSnapMgmt->ChangeDiffAreaMaximumSize( 
        GetOptionValueStr( VSSADM_O_FOR ), 
        GetOptionValueStr( VSSADM_O_ON ), 
        llMaxSize );
	if ( ft.HrFailed() )
	{
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )  // should be VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS
        {
	        //  The associations was not found
            OutputErrorMsg( ft, MSG_ERROR_ASSOCIATION_NOT_FOUND );                        
	        return;
        }
        else
    		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"ResizeDiffArea failed with hr = 0x%08lx", ft.hr);
	}
	
    //
    //  Print results, if needed
    //
    if ( !IsQuiet() )
    {
        OutputMsg( ft, MSG_INFO_RESIZED_DIFFAREA );
    }

	m_nReturnValue = VSS_CMDRET_SUCCESS;    
}
    

void CVssAdminCLI::DeleteDiffAreas(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
    VSS_ID ProviderId = GUID_NULL;

    //
    // Convert provider option to a VSS_ID
    //
    LPCWSTR pwszProvider = GetOptionValueStr( VSSADM_O_PROVIDER );

    //
    //  Determine if this is an ID or a name
    //
    if ( !ScanGuid( ft, pwszProvider, ProviderId ) )
    {
        //  Have a provider name, look it up
        if ( !GetProviderId( ft, pwszProvider, &ProviderId ) )
        {
            // Provider name not found, print error
            OutputErrorMsg( ft, MSG_ERROR_PROVIDER_NAME_NOT_FOUND, pwszProvider );
            return;
        }
    }

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pIMgmt;

    ft.LogVssStartupAttempt();
    ft.hr = pIMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt );
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pIDiffSnapMgmt;
	ft.hr = pIMgmt->GetProviderMgmtInterface( ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pIDiffSnapMgmt );
	if ( ft.HrFailed() )
	{
	    if ( ft.hr == E_NOINTERFACE )
	    {
	        //  The provider doesn't support this interface
            OutputErrorMsg( ft, MSG_ERROR_PROVIDER_DOESNT_SUPPORT_DIFFAREAS, pwszProvider );
	        return;
	    }
  		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"GetProviderMgmtInterface failed with hr = 0x%08lx", ft.hr);
	}

    //  Now delete the assocation by changing the size to zero
    ft.hr = pIDiffSnapMgmt->ChangeDiffAreaMaximumSize( 
        GetOptionValueStr( VSSADM_O_FOR ), 
        GetOptionValueStr( VSSADM_O_ON ), 
        0 );
	if ( ft.HrFailed() )
	{
        if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )  // should be VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS
        {
	        //  The associations was not found
            OutputErrorMsg( ft, MSG_ERROR_ASSOCIATION_NOT_FOUND );                        
	        return;
        }
        else if ( ft.hr == VSS_E_VOLUME_IN_USE ) 
        {
	        //  Can't delete associations that are in use
            OutputErrorMsg( ft, MSG_ERROR_ASSOCIATION_IS_IN_USE );                        
	        return;
        }
        else
    		ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"ResizeDiffArea to 0 failed with hr = 0x%08lx", ft.hr);
	}
	
    //
    //  Print results, if needed
    //
    if ( !IsQuiet() )
    {
        OutputMsg( ft, MSG_INFO_DELETED_DIFFAREAS );
    }

	m_nReturnValue = VSS_CMDRET_SUCCESS;    
}
    
void CVssAdminCLI::DeleteSnapshots(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
    LONG lNumDeleted = 0;
    
    if ( GetOptionValueStr( VSSADM_O_SNAPSHOT ) )
    {
        //
        //  Delete by snapshot id
        //
        if ( GetOptionValueStr( VSSADM_O_SNAPTYPE ) != NULL || GetOptionValueStr( VSSADM_O_FOR ) != NULL )
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_SET_OF_OPTIONS,
                L"CVssAdminCLI::DeleteSnapshots: Can't specify both ON and/or FOR volume options with SNAPSHOT option" );

        //  Make sure the user didn't specify any of the other optional options
        if ( GetOptionValueStr( VSSADM_O_FOR ) != NULL || GetOptionValueStr( VSSADM_O_SNAPTYPE ) != NULL ||
             GetOptionValueBool( VSSADM_O_OLDEST ) )
        {
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_SET_OF_OPTIONS,
                L"CVssAdminCLI::DeleteSnapshots: Invalid set of options" );
        }

        VSS_ID SnapshotId = GUID_NULL;
        if ( !ScanGuid( ft, GetOptionValueStr( VSSADM_O_SNAPSHOT ), SnapshotId ) )
        {
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE,
                L"CVssAdminCLI::DeleteSnapshots: Invalid snapshot id" );
        }

        //
        //  Let's try to delete the snapshot
        //
        if ( PromptUserForConfirmation( ft, MSG_INFO_PROMPT_USER_FOR_DELETE_SNAPSHOTS, 1 ) )
        {
            // Create the coordinator object
        	CComPtr<IVssCoordinator> pICoord;

            ft.LogVssStartupAttempt();
            ft.hr = pICoord.CoCreateInstance( CLSID_VSSCoordinator );
            if ( ft.HrFailed() )
                ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

            //  Set all context
            ft.hr = pICoord->SetContext( VSS_CTX_ALL );
            if ( ft.HrFailed() )
                ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"SetContext failed with hr = 0x%08lx", ft.hr);
            
            VSS_ID NondeletedSnapshotId;
            
            ft.hr = pICoord->DeleteSnapshots(
                        SnapshotId,
                        VSS_OBJECT_SNAPSHOT,
                        TRUE,
                        &lNumDeleted,
                        &NondeletedSnapshotId );
            if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
            {
                OutputErrorMsg( ft, MSG_ERROR_SNAPSHOT_NOT_FOUND, GetOptionValueStr( VSSADM_O_SNAPSHOT ) );
            } 
            else if ( ft.HrFailed() )
            {
                ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"DeleteSnapshots failed with hr = 0x%08lx", ft.hr);
            }
        }
    }
    else
    {
        //
        //  Delete by FOR option
        //
        if ( GetOptionValueStr( VSSADM_O_SNAPTYPE ) == NULL || GetOptionValueStr( VSSADM_O_FOR ) == NULL
             || GetOptionValueStr( VSSADM_O_SNAPSHOT ) != NULL )
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_SET_OF_OPTIONS,
                L"CVssAdminCLI::DeleteSnapshots: Invalid set of options" );

        //  Figure out snapshot context
        LONG lSnapshotContext;
        lSnapshotContext = DetermineSnapshotType( ft, GetOptionValueStr( VSSADM_O_SNAPTYPE ) ); 

        // Calculate the unique volume name, just to make sure that we have the right path
    	WCHAR wszVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];
        // If FOR volume name starts with the '\', assume it is already in the correct volume name format.
        // This is important for transported volumes since GetVolumeNameForVolumeMountPointW() won't work.
        if ( GetOptionValueStr( VSSADM_O_FOR )[0] != L'\\' )
        {
    	    if (!::GetVolumeNameForVolumeMountPointW( GetOptionValueStr( VSSADM_O_FOR ),
    		    	wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
        		ft.Throw( VSSDBG_COORD, VSS_E_OBJECT_NOT_FOUND, 
        				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
        				  L"failed with error code 0x%08lx", GetOptionValueStr( VSSADM_O_FOR ), ::GetLastError());
        }
        else
            ::wcsncpy( wszVolumeNameInternal, GetOptionValueStr( VSSADM_O_FOR ), STRING_LEN(wszVolumeNameInternal) );

    	// Create the coordinator object
    	CComPtr<IVssCoordinator> pICoord;

        ft.LogVssStartupAttempt();
        ft.hr = pICoord.CoCreateInstance( CLSID_VSSCoordinator );
        if ( ft.HrFailed() )
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

        // Set the context
		ft.hr = pICoord->SetContext( lSnapshotContext );
		if ( ft.HrFailed() )
			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"SetContext failed with hr = 0x%08lx", ft.hr);

		// Get list all snapshots
		CComPtr<IVssEnumObject> pIEnumSnapshots;
		ft.hr = pICoord->Query( GUID_NULL,
					VSS_OBJECT_NONE,
					VSS_OBJECT_SNAPSHOT,
					&pIEnumSnapshots );
		if ( ft.HrFailed() )
			ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Query failed with hr = 0x%08lx", ft.hr);

		// For all snapshots do...
		VSS_ID OldestSnapshotId = GUID_NULL;   // used if Oldest option is specified
		VSS_TIMESTAMP OldestSnapshotTimestamp = 0x7FFFFFFFFFFFFFFF; // Used if Oldest option is specified
		
		VSS_OBJECT_PROP Prop;
		VSS_SNAPSHOT_PROP& Snap = Prop.Obj.Snap;

        //
        //  If not asking to delete the oldest snapshot, this could possibly delete multiple snapshots
        //  Let's determine how many snapshots will be deleted.  If one or more, ask the user if we
		//  should continue.  If in quiet mode, don't bother the user and skip this step.
        //   
		if ( !GetOptionValueBool( VSSADM_O_OLDEST ) && !IsQuiet() )
		{
    		ULONG ulNumToBeDeleted = 0;
    		
		    for (;;) 
		    {
    			ULONG ulFetched;
    			ft.hr = pIEnumSnapshots->Next( 1, &Prop, &ulFetched );
    			if ( ft.HrFailed() )
    				ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);
    			
    			// Test if the cycle is finished
    			if (ft.hr == S_FALSE) {
    				BS_ASSERT( ulFetched == 0);
    				break;
    			}

                if ( ::_wcsicmp( Snap.m_pwszOriginalVolumeName, wszVolumeNameInternal ) == 0 )
                    ++ulNumToBeDeleted;
                
                ::VssFreeSnapshotProperties( &Snap );
		    }

            if ( ulNumToBeDeleted == 0 )
                ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_NO_ITEMS_IN_QUERY,
                    L"CVssAdminCLI::DeleteSnapshots: No snapshots found that satisfy the query");
                
            if ( !PromptUserForConfirmation( ft, MSG_INFO_PROMPT_USER_FOR_DELETE_SNAPSHOTS, ulNumToBeDeleted ) )
                return;

            //  Reset the enumerator to the beginning.
			ft.hr = pIEnumSnapshots->Reset();
			if ( ft.HrFailed() )
				ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Reset failed with hr = 0x%08lx", ft.hr);		    
		}

		//
		//  Now iterate through the list of snapshots looking for matches and delete them.
		//
		for(;;) 
		{
			// Get next element
			ULONG ulFetched;
			ft.hr = pIEnumSnapshots->Next( 1, &Prop, &ulFetched );
			if ( ft.HrFailed() )
				ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Next failed with hr = 0x%08lx", ft.hr);
			
			// Test if the cycle is finished
			if (ft.hr == S_FALSE) {
				BS_ASSERT( ulFetched == 0);
				break;
			}

            if ( ::_wcsicmp( Snap.m_pwszOriginalVolumeName, wszVolumeNameInternal ) == 0 )
            {
                //  We have a volume name match
                if ( GetOptionValueBool( VSSADM_O_OLDEST ) )
                {   
                    // Stow away snapshot info if this is the oldest one so far
                    if ( OldestSnapshotTimestamp > Snap.m_tsCreationTimestamp )
                    {
                        OldestSnapshotId        = Snap.m_SnapshotId;
                        OldestSnapshotTimestamp = Snap.m_tsCreationTimestamp;
                    }
                }
                else
                {
                    //  Delete the snapshot
                    VSS_ID NondeletedSnapshotId;
                    LONG lNumDeletedPrivate;
                    ft.hr = pICoord->DeleteSnapshots(
                                Snap.m_SnapshotId,
                                VSS_OBJECT_SNAPSHOT,
                                TRUE,
                                &lNumDeletedPrivate,
                                &NondeletedSnapshotId );
                    if ( ft.HrFailed() )
                    {
                        //  If it is object not found, the snapshot must have gotten deleted by someone else
                        if ( ft.hr != VSS_E_OBJECT_NOT_FOUND )
                        {
                            //  Print out an error message but keep going
                            LPWSTR pwszSnapshotId = ::GuidToString( ft, Snap.m_SnapshotId );
                            OutputErrorMsg( ft, MSG_ERROR_UNABLE_TO_DELETE_SNAPSHOT, ft.hr, pwszSnapshotId );
                            ::VssFreeString( pwszSnapshotId );
                        } 
                    }
                    else 
                    {
                        lNumDeleted += lNumDeletedPrivate;
                    }                    
                }
            }
			::VssFreeSnapshotProperties( &Snap );
		}

        // If in delete oldest mode, do the delete
        if ( GetOptionValueBool( VSSADM_O_OLDEST ) && OldestSnapshotId != GUID_NULL )
        {
            if ( PromptUserForConfirmation( ft, MSG_INFO_PROMPT_USER_FOR_DELETE_SNAPSHOTS, 1 ) )
            {
                //  Delete the snapshot
                VSS_ID NondeletedSnapshotId;
                ft.hr = pICoord->DeleteSnapshots(
                            OldestSnapshotId,
                            VSS_OBJECT_SNAPSHOT,
                            TRUE,
                            &lNumDeleted,
                            &NondeletedSnapshotId );
                if ( ft.HrFailed() )
                {
                    LPWSTR pwszSnapshotId = ::GuidToString( ft, OldestSnapshotId );
                    //  If it is object not found, the snapshot must have gotten deleted by someone else
                    if ( ft.hr == VSS_E_OBJECT_NOT_FOUND )
                    {
                        OutputErrorMsg( ft, MSG_ERROR_SNAPSHOT_NOT_FOUND, pwszSnapshotId );
                    }
                    else
                    {
                        OutputErrorMsg( ft, MSG_ERROR_UNABLE_TO_DELETE_SNAPSHOT, ft.hr, pwszSnapshotId );
                    } 
                    ::VssFreeString( pwszSnapshotId );
                }
            }
            else
                return;
        }		

        if ( lNumDeleted == 0 )
            ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_NO_ITEMS_IN_QUERY,
                L"CVssAdminCLI::DeleteSnapshots: No snapshots found that satisfy the query");
            
    }
    
    if ( !IsQuiet() && lNumDeleted > 0 )
        OutputMsg( ft, MSG_INFO_SNAPSHOTS_DELETED_SUCCESSFULLY, lNumDeleted );

	m_nReturnValue = VSS_CMDRET_SUCCESS;    
}


void CVssAdminCLI::ExposeSnapshot(
	IN	CVssFunctionTracer& ft
	) throw(HRESULT)
{
    BOOL bExposeLocally = TRUE;
    LPWSTR pwszExposeUsing = GetOptionValueStr( VSSADM_O_EXPOSE_USING );
    LPWSTR pwszPathFromRoot = GetOptionValueStr( VSSADM_O_SHAREPATH );
    
    if ( pwszExposeUsing == NULL )
    {
        //  Option not given, set it to an empty string
        pwszExposeUsing = L"";
    } 
    else if ( ( ::wcslen( pwszExposeUsing ) >= 2 && pwszExposeUsing[1] != L':' ) ||
              ( ::wcslen( pwszExposeUsing ) < 2 ) )         
    {
        //  User specified a share name
        bExposeLocally = FALSE;
    }

    // See if this is a valid command
    if ( bExposeLocally && pwszPathFromRoot != NULL )
        ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_SET_OF_OPTIONS,
            L"CVssAdminCLI::ExposeSnapshot: Specified a ShareUsing option with an expose locally command" );

    if ( pwszPathFromRoot == NULL )
        pwszPathFromRoot = L"";
    else if ( pwszPathFromRoot[0] != L'\\' )
        ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE,
            L"CVssAdminCLI::ExposeSnapshot: Specified SharePath doesn't start with '\\'" );
        

    LONG lAttributes;
    if ( bExposeLocally )
        lAttributes = VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY;
    else
        lAttributes = VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY;
    
    // Create the coordinator object
	CComPtr<IVssCoordinator> pICoord;

    ft.LogVssStartupAttempt();
    ft.hr = pICoord.CoCreateInstance( CLSID_VSSCoordinator );
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

    VSS_ID SnapshotId = GUID_NULL;
    if ( !ScanGuid( ft, GetOptionValueStr( VSSADM_O_SNAPSHOT ), SnapshotId ) )
    {
        ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE,
            L"CVssAdminCLI::ExposeSnapshot: Invalid snapshot id" );
    }

    LPWSTR wszExposedAs = NULL;
    
    //  Now try to expose
    ft.hr = pICoord->ExposeSnapshot( SnapshotId, 
                                     pwszPathFromRoot, 
                                     lAttributes, 
                                     pwszExposeUsing, 
                                     &wszExposedAs );
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Error returned from ExposeSnapshot: hr = 0x%08x", ft.hr);
        
    //  The snapshot is exposed, print the results to the user
    OutputMsg( ft, MSG_INFO_EXPOSE_SNAPSHOT_SUCCESSFUL, wszExposedAs );

    ::VssFreeString( wszExposedAs );

	m_nReturnValue = VSS_CMDRET_SUCCESS;    
}

// Creating a backup snapshot
void CVssAdminCLI::CreateNoWritersSnapshot(
    IN LONG lSnapshotContext
    ) throw(HRESULT)
{
    CVssFunctionTracer ft(VSSDBG_VSSADMIN, L"CVssAdminCLI::CreateNoWritersSnapshot");
    VSS_ID ProviderId = GUID_NULL;
    
    //
    // If user specified a provider, process option
    //
    LPCWSTR pwszProvider = GetOptionValueStr( VSSADM_O_PROVIDER );
    if ( pwszProvider != NULL )
    {
        //
        //  Determine if this is an ID or a name
        //
        if ( !ScanGuid( ft, pwszProvider, ProviderId ) )
        {
            //  Have a provider name, look it up
            if ( !GetProviderId( ft, pwszProvider, &ProviderId ) )
            {
                // Provider name not found, print error
                OutputErrorMsg( ft, MSG_ERROR_PROVIDER_NAME_NOT_FOUND, pwszProvider );
                return;
            }
        }
    }

	// Create the coordinator object
	CComPtr<IVssCoordinator> pICoord;

    ft.LogVssStartupAttempt();
    ft.hr = pICoord.CoCreateInstance( CLSID_VSSCoordinator );
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Connection failed with hr = 0x%08lx", ft.hr);

    ft.hr = pICoord->SetContext(lSnapshotContext);
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Error from SetContext(0x%x) hr = 0x%08lx", lSnapshotContext, ft.hr);

	CComPtr<IVssAsync> pAsync;
	VSS_ID SnapshotSetId = GUID_NULL;

    // Starting a new snapshot set.  Note, if another process is creating snapshots, then
    // this will fail.  If AutoRetry was specified, then retry the start snapshot set for
    // that the specified number of minutes.
    LONGLONG llTimeout = 0;
    if ( GetOptionValueNum( ft, VSSADM_O_AUTORETRY, &llTimeout ) )
    {
        LARGE_INTEGER liPerfCount;
        (void)QueryPerformanceCounter( &liPerfCount );
        ::srand( liPerfCount.LowPart );
        DWORD dwTickcountStart = ::GetTickCount();
        do
        {
            ft.hr = pICoord->StartSnapshotSet(&SnapshotSetId);
            if ( ft.HrFailed() )
            {
                if ( ft.hr == VSS_E_SNAPSHOT_SET_IN_PROGRESS && 
                     ( (LONGLONG)( ::GetTickCount() - dwTickcountStart ) < ( llTimeout * 1000 * 60 ) ) )
                {
                    static dwMSec = 250; // Starting retry time
                    if ( dwMSec < 10000 )
                    {
                        dwMSec += ::rand() % 750;
                    }
                    ft.Trace( VSSDBG_VSSADMIN, L"Snapshot already in progress, retrying in %u millisecs", dwMSec );
                    Sleep( dwMSec );
                }
                else
                {
                    ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Error from StartSnapshotSet hr = 0x%08lx", ft.hr);
                }
            }
        } while ( ft.HrFailed() );
    }
    else
    {
        //
        //  Error right away with out a timeout when there is another snapshot in progress.
        //
        ft.hr = pICoord->StartSnapshotSet(&SnapshotSetId);
        if ( ft.HrFailed() )
        {
            ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Error from StartSnapshotSet hr = 0x%08lx", ft.hr);
        }
    }
    
    // Add the volume to the snapshot set
    VSS_ID SnapshotId;
    ft.hr = pICoord->AddToSnapshotSet(
            GetOptionValueStr( VSSADM_O_FOR ),
            ProviderId,
            &SnapshotId);
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr, L"Error from AddToSnapshotSet hr = 0x%08lx", ft.hr);

    ft.hr = S_OK;
    pAsync = NULL;
    ft.hr = pICoord->DoSnapshotSet(NULL, &pAsync);
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr,
            L"Error from DoSnapshotSet hr = 0x%08lx", ft.hr);

	ft.hr = pAsync->Wait();
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr,
            L"Error from Wait hr = 0x%08lx", ft.hr);

    HRESULT hrStatus;
	ft.hr = pAsync->QueryStatus(&hrStatus, NULL);
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr,
            L"Error from QueryStatus hr = 0x%08lx", ft.hr);

    //
    // If VSS failed to create the snapshot, it's result code is in hrStatus.  Process
    // it.
    //
    ft.hr = hrStatus;
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr,
            L"QueryStatus hrStatus parameter returned error, hr = 0x%08lx", ft.hr);

    //
    //  Print results
    //
    VSS_SNAPSHOT_PROP sSSProp;
    ft.hr = pICoord->GetSnapshotProperties( SnapshotId, &sSSProp );
    if ( ft.HrFailed() )
        ft.Throw( VSSDBG_VSSADMIN, ft.hr,
            L"Error from GetId hr = 0x%08lx", ft.hr);

    LPWSTR pwszSnapshotId = ::GuidToString( ft, SnapshotId );

    OutputMsg( ft, MSG_INFO_SNAPSHOT_CREATED, GetOptionValueStr( VSSADM_O_FOR ),
        pwszSnapshotId, sSSProp.m_pwszSnapshotDeviceObject );

    ::VssFreeString(pwszSnapshotId);
    ::VssFreeSnapshotProperties(&sSSProp);

    m_nReturnValue = VSS_CMDRET_SUCCESS;
}


LPWSTR CVssAdminCLI::BuildSnapshotAttributeDisplayString(
    IN CVssFunctionTracer& ft,
    IN DWORD Attr
    ) throw(HRESULT)
{
    WCHAR pwszDisplayString[1024] = L"";
    WORD wBit = 0;

    //  Go through the bits of the attribute
    for ( ; wBit < (sizeof ( Attr ) * 8) ; ++wBit )
    {
        switch ( Attr & ( 1 << wBit ) )
        {
        case 0:
            break;
        case VSS_VOLSNAP_ATTR_PERSISTENT:
            AppendMessageToStr( ft, pwszDisplayString, STRING_SIZE( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_PERSISTENT, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_READ_WRITE:
            AppendMessageToStr( ft, pwszDisplayString, STRING_SIZE( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_READ_WRITE, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE:
            AppendMessageToStr( ft, pwszDisplayString, STRING_SIZE( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_CLIENT_ACCESSIBLE, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE: 	
            AppendMessageToStr( ft, pwszDisplayString, STRING_SIZE( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_NO_AUTO_RELEASE, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_NO_WRITERS:         
            AppendMessageToStr( ft, pwszDisplayString, STRING_SIZE( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_NO_WRITERS, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_TRANSPORTABLE:
            AppendMessageToStr( ft, pwszDisplayString, STRING_SIZE( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_TRANSPORTABLE, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_NOT_SURFACED:	    
            AppendMessageToStr( ft, pwszDisplayString, STRING_SIZE( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_NOT_SURFACED, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_HARDWARE_ASSISTED:	
            AppendMessageToStr( ft, pwszDisplayString, STRING_SIZE( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_HARDWARE_ASSISTED, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_DIFFERENTIAL:		
            AppendMessageToStr( ft, pwszDisplayString, STRING_SIZE( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_DIFFERENTIAL, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_PLEX:				
            AppendMessageToStr( ft, pwszDisplayString, STRING_SIZE( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_PLEX, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_IMPORTED:			
            AppendMessageToStr( ft, pwszDisplayString, STRING_SIZE( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_IMPORTED, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY:    
            AppendMessageToStr( ft, pwszDisplayString, STRING_SIZE( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_EXPOSED_LOCALLY, 0, L", " );
            break;
        case VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY:   
            AppendMessageToStr( ft, pwszDisplayString, STRING_SIZE( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_EXPOSED_REMOTELY, 0, L", " );
            break;
        default:
             AppendMessageToStr( ft, pwszDisplayString, STRING_SIZE( pwszDisplayString ), 
                0, Attr & ( 1 << wBit ), L", " );
            break;

        }
    }

    // If this is a backup snapshot, most like there will not be any attributes
    if ( pwszDisplayString[0] == L'\0' )
    {
         AppendMessageToStr( ft, pwszDisplayString, STRING_SIZE( pwszDisplayString ), 
                MSG_INFO_SNAPSHOT_ATTR_NONE, 0, L", " );
    }
    
    LPWSTR pwszRetString = NULL;
    ::VssSafeDuplicateStr( ft, pwszRetString, pwszDisplayString );
    return pwszRetString;
}


LONG CVssAdminCLI::DetermineSnapshotType(
    IN CVssFunctionTracer& ft,
    IN LPCWSTR pwszType
    ) throw(HRESULT)
{
    //  Determine the snapshot type based on the entered snapshot type string.

    //  See if the snapshot type was specified, if not, return all context
    if ( pwszType == NULL || pwszType[0] == L'\0' )
    {
        return VSS_CTX_ALL;
    }
    
    INT idx;
    
    // Determine type of snapshot
    for ( idx = 0; g_asAdmTypeNames[idx].pwszName != NULL; ++idx )
    {
        if ( ( CVssSKU::GetSKU() & g_asAdmTypeNames[idx].dwSKUs ) && 
             ( ::_wcsicmp( pwszType, g_asAdmTypeNames[idx].pwszName ) == 0 ) )
        {
            break;
        }
    }

    if ( g_asAdmTypeNames[idx].pwszName == NULL )
    {
        ft.Throw( VSSDBG_VSSADMIN, VSSADM_E_INVALID_OPTION_VALUE,
            L"DetermineSnapshotType: Invalid type specified: %s",
            pwszType );
    }

    //
    //  Now return the context
    //
    return( g_asAdmTypeNames[idx].lSnapshotContext );
}

LPWSTR CVssAdminCLI::DetermineSnapshotType(
    IN CVssFunctionTracer& ft,
    IN LONG lSnapshotAttributes
    ) throw(HRESULT)
{
    //  Determine the snapshot type string based on the snapshot attributes
    LPWSTR pwszType = NULL;

    INT idx;
    
    // Determine type of snapshot
    for ( idx = 0; g_asAdmTypeNames[idx].pwszName != NULL; ++idx )
    {
        if ( g_asAdmTypeNames[idx].lSnapshotContext == ( lSnapshotAttributes & VSS_CTX_ATTRIB_MASK ) )
            break;
    }

    if ( g_asAdmTypeNames[idx].pwszName == NULL )
    {
        ft.Trace( VSSDBG_VSSADMIN, L"DetermineSnapshotType: Invalid context in lSnapshotAttributes: 0x%08x",
            lSnapshotAttributes );
        LPWSTR pwszMsg = GetMsg( ft, FALSE, MSG_UNKNOWN );
        if ( pwszMsg == NULL ) 
        {
    		ft.Throw( VSSDBG_VSSADMIN, E_UNEXPECTED,
        			  L"Error on loading the message string id %d. 0x%08lx",
    	    		  MSG_UNKNOWN, ::GetLastError() );
        }    
        return pwszMsg;
    }

    //
    //  Now return the context
    //
    ::VssSafeDuplicateStr( ft, pwszType, g_asAdmTypeNames[idx].pwszName );

    return pwszType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\vssadmin\vssadmin.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module vssadmin.cpp | header of VSS demo
    @end

Author:

    Adi Oltean  [aoltean]  09/17/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/17/1999  Created

--*/


#ifndef __VSS_DEMO_H_
#define __VSS_DEMO_H_


/////////////////////////////////////////////////////////////////////////////
//  Defines and pragmas

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>
#include <comadmin.h>

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"

// ATL
#include <atlconv.h>
#include <atlbase.h>

// Application specific
#include "vs_inc.hxx"

// Generated MIDL headers
#include "vs_idl.hxx"

#include "copy.hxx"
#include "pointer.hxx"

#include "resource.h"

#include "vssmsg.h"
#include "msg.h"

/////////////////////////////////////////////////////////////////////////////
//  Constants

const nStringBufferSize = 1024;	    // Includes the zero character

const nPollingInterval  = 2500;     // Three seconds

const MAX_RETRIES_COUNT = 4;        // Retries for polling

const WCHAR wszVssOptBoolTrue[] = L"TRUE";

#define VSSADM_E_NO_ITEMS_IN_QUERY          S_FALSE
#define VSSADM_E_FIRST_PARSING_ERROR        0x1001
#define VSSADM_E_INVALID_NUMBER             0x1001
#define VSSADM_E_INVALID_COMMAND            0x1002
#define VSSADM_E_INVALID_OPTION             0x1003
#define VSSADM_E_INVALID_OPTION_VALUE       0x1004
#define VSSADM_E_DUPLICATE_OPTION           0x1005
#define VSSADM_E_OPTION_NOT_ALLOWED_FOR_COMMAND 0x1006
#define VSSADM_E_REQUIRED_OPTION_MISSING    0x1007
#define VSSADM_E_INVALID_SET_OF_OPTIONS     0x1008
#define VSSADM_E_LAST_PARSING_ERROR         0x1008

enum EVssAdmSnapshotType
{
    VSSADM_ST_FIRST = 0,
    VSSADM_ST_NAS_ROLLBACK = 0,
    VSSADM_ST_PERSISTENT_TIMEWARP,
    VSSADM_ST_TIMEWARP,
    VSSADM_ST_NUM_TYPES,
    VSSADM_ST_INVALID,
    VSSADM_ST_ALL
};

struct SVssAdmSnapshotTypeName
{
    LPCWSTR pwszName;
    DWORD dwSKUs;       // Specifies which SKUs this type is supported for snapshot creation using vssadmin, formed from ORing CVssSKU::EVssSKUType
    LONG lSnapshotContext;  // The snapshot context from vss.idl
};

//
//  List of all options.  This list must remain in sync with the g_asAdmOptions list.
//
enum EVssAdmOption
{
    VSSADM_O_FIRST = 0,
    VSSADM_O_AUTORETRY = 0,
    VSSADM_O_EXPOSE_USING,
    VSSADM_O_FOR,
    VSSADM_O_MAXSIZE,
    VSSADM_O_OLDEST,
    VSSADM_O_ON,
    VSSADM_O_PROVIDER,
    VSSADM_O_QUIET,
    VSSADM_O_SET,
    VSSADM_O_SHAREPATH,
    VSSADM_O_SNAPSHOT,
    VSSADM_O_SNAPTYPE,
    VSSADM_O_NUM_OPTIONS,
    VSSADM_O_INVALID
};

//
//  LIst of all commands.  This list must remain in sync with the g_asAdmCommands list.
//
enum EVssAdmCommand
{
    VSSADM_C_FIRST = 0,
    VSSADM_C_ADD_DIFFAREA = 0,
    VSSADM_C_CREATE_SNAPSHOT,
    VSSADM_C_DELETE_SNAPSHOTS,
    VSSADM_C_DELETE_DIFFAREAS,
    VSSADM_C_EXPOSE_SNAPSHOT,
    VSSADM_C_LIST_PROVIDERS,
    VSSADM_C_LIST_SNAPSHOTS,
    VSSADM_C_LIST_DIFFAREAS,
    VSSADM_C_LIST_VOLUMES,
    VSSADM_C_LIST_WRITERS,
    VSSADM_C_RESIZE_DIFFAREA,
    VSSADM_C_NUM_COMMANDS,
    VSSADM_C_INVALID
};

enum EVssAdmOptionType
{
    VSSADM_OT_BOOL = 0,  // no qualifier on the option, i.e. /quiet, TRUE if present
    VSSADM_OT_STR,
    VSSADM_OT_NUM
};

struct SVssAdmOption
{
    EVssAdmOption eOpt;
    LPCWSTR pwszOptName;  // The option name as typed on the command-line, i.e. the "for" in /for=XXXX
    EVssAdmOptionType eOptType;
};

//
//  Specifies the validity of the option for a particular command.
//
enum EVssAdmOptionFlag
{
    V_NO = 0,  //  Option not allowed
    V_YES,     //  Option manditory
    V_OPT      //  Option optional
};

//
//  The main command structure.  The commands are structured like:
//  vssadmin <pwszMajorOption> <pwszMinorOption> <OPTIONS>
//
struct SVssAdmCommandsEntry
{
    LPCWSTR pwszMajorOption;
    LPCWSTR pwszMinorOption;
    EVssAdmCommand eAdmCmd;
    DWORD dwSKUs;       // Specifies which SKUs this command is supported, formed from ORing CVssSKU::EVssSKUType
    LONG lMsgGen;
    LONG lMsgDetail;
    BOOL bShowSSTypes;  //  If true, in detailed usage show a list of valid snapshot types at end of message
    EVssAdmOptionFlag aeOptionFlags[VSSADM_O_NUM_OPTIONS]; // Array of option flags indexed by EVssAdmOption
};


//
//  The structure of the parsed command.  One of these is created by the 
//  ParseCmdLine method.
//
struct SVssAdmParsedCommand
{
    EVssAdmCommand eAdmCmd;
    LPWSTR apwszOptionValues[VSSADM_O_NUM_OPTIONS];

    //  Simple initializer constructor
    SVssAdmParsedCommand()
    {
        eAdmCmd = VSSADM_C_INVALID;
        // psUnnamedOptions = NULL;
        
        //  Clear out the option values arrays
        for ( INT i = 0; i < VSSADM_O_NUM_OPTIONS; ++i )
            apwszOptionValues[ i ] = NULL;
    };
    ~SVssAdmParsedCommand()
    {
        //  Free any allocated memory
        for ( INT i = 0; i < VSSADM_O_NUM_OPTIONS; ++i )
            ::VssFreeString( apwszOptionValues[ i ] );
        
    }
};

extern const SVssAdmOption g_asAdmOptions[];
extern const SVssAdmCommandsEntry g_asAdmCommands[];
extern const SVssAdmSnapshotTypeName g_asAdmTypeNames[];

LPWSTR GuidToString(
	IN CVssFunctionTracer& ft,
    IN GUID guid
    );

LPWSTR LonglongToString(
	IN CVssFunctionTracer& ft,
    IN LONGLONG llValue
    );

LPWSTR DateTimeToString(
	IN CVssFunctionTracer& ft,
    IN VSS_TIMESTAMP *pTimeStamp
    );

WCHAR MyGetChar(
	IN CVssFunctionTracer& ft
    );

BOOL MapVssErrorToMsg(
	IN CVssFunctionTracer& ft,
	IN HRESULT hr,
	OUT LONG *plMsgNum
    ) throw( HRESULT );
   

/////////////////////////////////////////////////////////////////////////////
//	class CVssAdminCLI


class CVssAdminCLI
{
// Enums and typedefs
private:

	enum _RETURN_VALUE
	{
		VSS_CMDRET_SUCCESS      = 0,
		VSS_CMDRET_EMPTY_RESULT = 1,
		VSS_CMDRET_ERROR        = 2,
	};

// Constructors& destructors
private:
	CVssAdminCLI(const CVssAdminCLI&);
	CVssAdminCLI();

public:
	CVssAdminCLI(
        IN INT argc,
        IN PWSTR argv[]
		);
	~CVssAdminCLI();

// Attributes
private:
    BOOL       IsQuiet() { return GetOptionValueBool( VSSADM_O_QUIET ); }
    
	INT        GetReturnValue() { return m_nReturnValue; };

    LPWSTR     GetOptionValueStr(
        IN EVssAdmOption eOption
        )
    {
        BS_ASSERT( g_asAdmOptions[ eOption ].eOptType == VSSADM_OT_STR );
        BS_ASSERT( g_asAdmCommands[ m_sParsedCommand.eAdmCmd].aeOptionFlags[ eOption ] != V_NO );
        return m_sParsedCommand.apwszOptionValues[ eOption ];
    };

    BOOL        GetOptionValueBool(
        IN EVssAdmOption eOption
        )
    {
        BS_ASSERT( g_asAdmOptions[ eOption ].eOptType == VSSADM_OT_BOOL );
        BS_ASSERT( g_asAdmCommands[ m_sParsedCommand.eAdmCmd].aeOptionFlags[ eOption ] != V_NO );
        return m_sParsedCommand.apwszOptionValues[ eOption ] != NULL;
    };

    BOOL        GetOptionValueNum(
		IN	CVssFunctionTracer& ft,
        IN EVssAdmOption eOption,
        OUT LONGLONG *pllValue
        ) throw( HRESULT )
    {
        BS_ASSERT( g_asAdmOptions[ eOption ].eOptType == VSSADM_OT_NUM );
        BS_ASSERT( g_asAdmCommands[ m_sParsedCommand.eAdmCmd].aeOptionFlags[ eOption ] != V_NO );
        if ( m_sParsedCommand.apwszOptionValues[ eOption ] == NULL )
        {
            BS_ASSERT( g_asAdmCommands[ m_sParsedCommand.eAdmCmd].aeOptionFlags[ eOption ] == V_OPT );
            //  Option wasn't specified on command line - an optional one
            *pllValue = 0;
            return FALSE; 
        }
        *pllValue = ScanNumber( ft, m_sParsedCommand.apwszOptionValues[ eOption ] );

        return TRUE;
    };


// Operations
public:

    static HRESULT Main(
        IN INT argc,
        IN PWSTR argv[]
	    );

private:

	void Initialize(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	BOOL ParseCmdLine(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	void DoProcessing(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	void Finalize();

// Processing
private:

	void PrintUsage(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

    // The following are the methods that get called for each command.
	void AddDiffArea(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);
    
	void CreateSnapshot(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	void DeleteDiffAreas(
    	IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	void DeleteSnapshots(
    	IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	void ExposeSnapshot(
    	IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	void ListDiffAreas(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);
	
	void ListProviders(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	void ListSnapshots(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	void ListVolumes(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	void ListWriters(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	void ResizeDiffArea(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

// Implementation
private:
    LONG DetermineSnapshotType(
        IN CVssFunctionTracer& ft,
        IN LPCWSTR pwszType
        ) throw(HRESULT);

    LPWSTR DetermineSnapshotType(
        IN CVssFunctionTracer& ft,
        IN LONG lSnapshotAttributes
        ) throw(HRESULT);

    void DisplayDiffAreasPrivate(
	    IN	CVssFunctionTracer& ft,
   	    IVssEnumMgmtObject *pIEnumMgmt	
	    ) throw(HRESULT);

    void CreateNoWritersSnapshot(
        IN LONG lSnapshotContext
        ) throw(HRESULT);
    
    LPWSTR BuildSnapshotAttributeDisplayString(
        IN CVssFunctionTracer& ft,
        IN DWORD Attr
        ) throw(HRESULT);
    
	void DumpSnapshotTypes(
		IN	CVssFunctionTracer& ft
		) throw(HRESULT);

	LPCWSTR LoadString(
		IN	CVssFunctionTracer& ft,
		IN	UINT nStringId
		) throw(HRESULT);

	LPCWSTR GetNextCmdlineToken(
		IN	CVssFunctionTracer& ft,
		IN	bool bFirstToken = false
		) throw(HRESULT);

	bool Match(
		IN	CVssFunctionTracer& ft,
		IN	LPCWSTR wszString,
		IN	LPCWSTR wszPatternString
		) throw(HRESULT);

	bool ScanGuid(
		IN	CVssFunctionTracer& ft,
		IN	LPCWSTR wszString,
		OUT	VSS_ID& Guid
		) throw(HRESULT);

	void Output(
		IN	CVssFunctionTracer& ft,
    	IN	LPCWSTR wszFormat,
		...
		) throw(HRESULT);

    void OutputMsg(
	    IN	CVssFunctionTracer& ft,
        IN  LONG msgId,
        ...
        ) throw(HRESULT);

    void OutputOnConsole(
        IN	LPCWSTR wszStr
        );

    LPWSTR GetMsg(
    	IN	CVssFunctionTracer& ft,
    	IN  BOOL bLineBreaks,	
        IN  LONG msgId,
        ...
        );

    void AppendMessageToStr(
        IN CVssFunctionTracer& ft,
        IN LPWSTR pwszString,
        IN SIZE_T cMaxStrLen,
        IN LONG lMsgId,
        IN DWORD AttrBit,
        IN LPCWSTR pwszDelimitStr
        ) throw( HRESULT );
    
    LONGLONG ScanNumber(
    	IN CVssFunctionTracer& ft,
    	IN LPCWSTR pwszNumToConvert
        ) throw( HRESULT );
    
    LPWSTR FormatNumber(
	    IN CVssFunctionTracer& ft,
    	IN LONGLONG llNum
        ) throw(HRESULT);
    
    void OutputErrorMsg(
	    IN	CVssFunctionTracer& ft,
        IN  LONG msgId,
        ...
        ) throw(HRESULT);

    BOOL PromptUserForConfirmation(
    	IN CVssFunctionTracer& ft,
    	IN LONG lPromptMsgId,
    	IN ULONG ulNum	
    	);
    
	LPCWSTR GetProviderName(
		IN	CVssFunctionTracer& ft,
		IN	VSS_ID& ProviderId
		) throw(HRESULT);

    BOOL GetProviderId(
	    IN	CVssFunctionTracer& ft,
	    IN  LPCWSTR pwszProviderName,
	    OUT	VSS_ID *pProviderId
	    ) throw(HRESULT);

// Data members
private:

	HANDLE              m_hConsoleOutput;
    CVssSimpleMap<UINT, LPCWSTR> m_mapCachedResourceStrings;
    CVssSimpleMap<VSS_ID, LPCWSTR> m_mapCachedProviderNames;
	INT                 m_nReturnValue;

    INT                 m_argc;
    PWSTR               *m_argv;
	
	EVssAdmCommand      m_eCommandType;
	SVssAdmParsedCommand m_sParsedCommand;
	VSS_OBJECT_TYPE		m_eFilterObjectType;
	VSS_OBJECT_TYPE		m_eListedObjectType;
	VSS_ID				m_FilterSnapshotId;
};


#endif //__VSS_DEMO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrcomdb.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrcomdb.cpp | Implementation of SnapshotWriter for COM+ Registration Database



Author:

    Michael C. Johnson [mikejohn] 03-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-14	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-13	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-12	MCJ		Michael C. Johnson		18-Jul-2000
		144027: Really remove trailing '\' from Include/Exclude lists.

	X-11	MCJ		Michael C. Johnson		20-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.


	X-10	MCJ		Michael C. Johnson		12-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-9	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()

	X-8	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-7	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-6	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.


	X-5	MCJ		Michael C. Johnson		22-Feb-2000
		Add SYSTEM_STATE_SUBDIR to COM+ database save path.

	X-4	MCJ		Michael C. Johnson		17-Feb-2000
		Modify save path to be consistent with standard.

	X-3	MCJ		Michael C. Johnson		11-Feb-2000
		Update to use some new StringXxxx() routines and fix a
		length check bug along the way.

	X-2	MCJ		Michael C. Johnson		08-Feb-2000
		Ensure wide chars are used for saving the COM+ Db rather
		than the 'CHAR' type used by NtBackup (CHAR == WCHAR in
		NtBackup just to fool folk)
		Fix broken assert in shutdown code.
		Fix path length checks and calculations.

	X-1	MCJ		Michael C. Johnson		03-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.

--*/


#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHCMDBC"
//
////////////////////////////////////////////////////////////////////////

/*
** The save path has a standard form which is
**
**	%SystemRoot%\Repair\Backup,
**
** followed by the application writer string as publised in the export
** table followed by whatever else the writer requires.
*/
#define APPLICATION_STRING	L"ComRegistrationDatabase"
#define COMPONENT_NAME		L"COM+ Registration Database"
#define TARGET_PATH		ROOT_BACKUP_DIR BOOTABLE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING

DeclareStaticUnicodeString (ucsBackupFilename, L"\\ComRegDb.bak");


HRESULT (WINAPI *RegDbBackup)(PWCHAR);

typedef HRESULT (WINAPI *PF_REG_DB_API)(PWCHAR);





/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterComDb : public CShimWriter
    {
public:
    CShimWriterComDb (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath, BOOL bParticipateInBootableState) : 
		CShimWriter (pwszWriterName, pwszTargetPath, bParticipateInBootableState) {};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    };


static CShimWriterComDb ShimWriterComDb (APPLICATION_STRING, TARGET_PATH, TRUE);

PCShimWriter pShimWriterComPlusRegDb = &ShimWriterComDb;



/*
**++
**
** Routine Description:
**
**	The Cluster database snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterComDb::DoIdentify ()
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriterComDb::DoIdentify");


    try
	{
	ft.hr = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							   NULL,
							   COMPONENT_NAME,
							   COMPONENT_NAME,
							   NULL, // icon
							   0,
							   true,
							   false,
							   false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddComponent");



	ft.hr = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								  COMPONENT_NAME,
								  m_pwszTargetPath,
								  L"*",
								  true,
								  NULL);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddFilesToFileGroup");




	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (L"%SystemRoot%\\registration",
							      L"*.clb",
							      false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles (*.clb)");




	/*
	** Exclude all *.crmlog files from the root down.
	*/
	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (DIR_SEP_STRING,
							      L"*.crmlog",
							      true);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles (*.crmlog)");

	} VSS_STANDARD_CATCH (ft)
								 


    return (ft.hr);
    } /* CShimWriterComDb::DoIdentify () */


/*
**++
**
** Routine Description:
**
**	The Cluster database snapshot writer PrepareForSnapshot function.
**	Currently all of the real work for this writer happens here.
**
**
** Arguments:
**
**	Same arguments as those passed in the PrepareForSnapshot event.
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterComDb::DoPrepareForSnapshot ()
    {
    HRESULT		hrStatus;
    HINSTANCE		hRegDbDll = NULL;
    UNICODE_STRING	ucsBackupPath;


    StringInitialise (&ucsBackupPath);


    hrStatus = StringCreateFromExpandedString (&ucsBackupPath,
					       m_pwszTargetPath,
					       ucsBackupFilename.Length / sizeof (WCHAR));



    if (SUCCEEDED (hrStatus))
	{
	hRegDbDll = LoadLibraryW (L"catsrvut.dll");

	hrStatus = GET_STATUS_FROM_HANDLE (hRegDbDll);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"LoadLibraryW (catsrvut.dll)", 
		    L"CShimWriterComDb::DoPrepareForSnapshot");
	}


    if (SUCCEEDED (hrStatus))
	{
	RegDbBackup = (PF_REG_DB_API) GetProcAddress (hRegDbDll, "RegDBBackup");

	hrStatus = GET_STATUS_FROM_BOOL (NULL != RegDbBackup);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetProcAddress (RegDbBackup)", 
		    L"CShimWriterComDb::DoPrepareForSnapshot");
	}


    if (SUCCEEDED (hrStatus))
	{
	StringAppendString (&ucsBackupPath, &ucsBackupFilename);

	hrStatus = RegDbBackup (ucsBackupPath.Buffer);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegDbBackup", 
		    L"CShimWriterComDb::DoPrepareForSnapshot");
	}



    if (!HandleInvalid (hRegDbDll))
	{
	FreeLibrary (hRegDbDll);
	}



    StringFree (&ucsBackupPath);

    return (hrStatus);
    } /* DoPrepareForSnapshot () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\common.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module common.cpp | Implementation of SnapshotWriter common code



Author:

    Michael C. Johnson [mikejohn] 03-Feb-2000


Description:
	
    Add comments.


Revision History:


	X-18	MCJ		Michael C. Johnson		18-Oct-2000
		210264: Prevent Win32 status from leaking out and return 
			one of the sanctioned error codes.

	X-18	MCJ		Michael C. Johnson		18-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-17	MCJ		Michael C. Johnson		 4-Aug-2000
		 94487: Ensure VsCreateDirectories() adds security attributes 
		        to all directories that it creates.
		143435: Added new variations of StringCreateFromExpandedString()
		        StringInitialise() and StringCreateFromString() 
		153807: Replace CleanDirectory() and EmptyDirectory() with a 
		        more comprehensive directory tree cleanup routine
			RemoveDirectoryTree().

		Also fix a couple of minor problems in MoveFilesInDirectory()


	X-16	MCJ		Michael C. Johnson		19-Jun-2000
		Apply code review comments.
			Remove unused routines
				ANSI version of StringXxxx routines.
				GetStringFromControlCode()
				GetTargetStateFromControlCode()
				VsGetVolumeNameFromPath()
				VsCheckPathAgainstVolumeNameList()
			Fix race conditions in VsCreateDirectories()
			Replace use of CheckShimPrivileges() with 
			IsProcessBackupOperator()

	X-15	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events


	X-14	MCJ		Michael C. Johnson		15-May-2000
		107129: Ensure that the outputs from ContextLocate () are 
		        set to known values in all cases.
		108586: Add CheckShimPrivileges() to check for the privs we 
		        require to invoke the public shim routines.

	X-13	MCJ		Michael C. Johnson		23-Mar-2000
		Add routines MoveFilesInDirectory() and EmptyDirectory()

	X-12	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-11	MCJ		Michael C. Johnson		 6-Mar-2000
		Add VsServiceChangeState () which should deal with all the
		service states that we are interested in.

	X-10	MCJ		Michael C. Johnson		 2-Mar-2000
		Inadvertantly trimmed trailing '\' if present from directory
		path when cleaning directory.

	X-9	MCJ		Michael C. Johnson		29-Feb-2000
		Fix off-by-one error testing for trailing '\' and delete
		the directory itself in CleanDirectory().

	X-8	MCJ		Michael C. Johnson		23-Feb-2000
		Add common context manipulation routines including state
		tracking and checking.

	X-7	MCJ		Michael C. Johnson		17-Feb-2000
		Move definition of ROOT_BACKUP_DIR to common.h

	X-6	MCJ		Michael C. Johnson		16-Feb-2000
		Merge in X-3v1

		X-3v1	MCJ		Michael C. Johnson		11-Feb-2000
			Added additional StringXxxx () routines and routines to
			turn on backup priviledges and restore priviledges.

	X-5	SRS		Stefan R. Steiner		14-Feb-2000
		Removed the check for CBsString's being potentially > 2^15 characters since
		the CBsString class supports strings up to 2^31 characters in length.  Added
		VsCopyFilesInDirectory()

	X-4	SRS	Stefan R. Steiner			13-Feb-2000
		Added VsExpandEnvironmentStrings()

	X-3	SRS		Stefan R. Steiner		08-Feb-2000
		Added service management code and volume name from path code

	X-2	MCJ		Michael C. Johnson		08-Feb-2000
		Cleaned up some comments and fixed a string length
		calculation.
		Also made sure module can be built as part of the standalone
		writer tests.

	X-1	MCJ		Michael C. Johnson		03-Feb-2000
		Initial creation.

--*/


#include "stdafx.h"
#include "vssmsg.h"
#include "common.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHCOMNC"


/* 
** The first group of (overloaded) routines manipulate UNICODE_STRING
** strings. The rules which apply here are:
**
** 1) The Buffer field points to an array of characters (WCHAR) with
** the length of the buffer being specified in the MaximumLength
** field. If the Buffer field is non-NULL it must point to a valid
** buffer capable of holding at least one character.  If the Buffer
** field is NULL, the MaximumLength and Length fields must both be
** zero.
**
** 2) Any valid string in the buffer is always terminated with a
** UNICODE_NULL.
**
** 3) the MaximumLength describes the length of the buffer measured in
** bytes. This value must be even.
**
** 4) The Length field describes the number of valid characters in the
** buffer measured in BYTES, excluding the termination
** character. Since the string must always have a termination
** character ('\0'), the maximum value of Length is MaximumLength - 2.
**
**
** The routines available are:-
**
**	StringInitialise ()
**	StringTruncate ()
**	StringSetLength ()
**	StringAllocate ()
**	StringFree ()
**	StringCreateFromString ()
**	StringAppendString ()
**	StringCreateFromExpandedString ()
** 
*/


/*
**++
**
**  Routine Description:
**
**
**  Arguments:
**
**
**  Side Effects:
**
**
**  Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT StringInitialise (PUNICODE_STRING pucsString)
    {
    pucsString->Buffer        = NULL;
    pucsString->Length        = 0;
    pucsString->MaximumLength = 0;

    return (NOERROR);
    } /* StringInitialise () */


HRESULT StringInitialise (PUNICODE_STRING pucsString, LPCWSTR pwszString)
    {
    return (StringInitialise (pucsString, (PWCHAR) pwszString));
    }

HRESULT StringInitialise (PUNICODE_STRING pucsString, PWCHAR pwszString)
    {
    HRESULT	hrStatus       = NOERROR;
    ULONG	ulStringLength = wcslen (pwszString) * sizeof (WCHAR);


    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}
    else
	{
	pucsString->Buffer        = pwszString;
	pucsString->Length        = (USHORT) ulStringLength;
	pucsString->MaximumLength = (USHORT) (ulStringLength + sizeof (UNICODE_NULL));
	}


    return (hrStatus);
    } /* StringInitialise () */


HRESULT StringTruncate (PUNICODE_STRING pucsString, USHORT usSizeInChars)
    {
    HRESULT	hrStatus    = NOERROR;
    USHORT	usNewLength = (USHORT)(usSizeInChars * sizeof (WCHAR));

    if (usNewLength > pucsString->Length)
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}
    else
	{
	pucsString->Buffer [usSizeInChars] = UNICODE_NULL;
	pucsString->Length                 = usNewLength;
	}


    return (hrStatus);
    } /* StringTruncate () */


HRESULT StringSetLength (PUNICODE_STRING pucsString)
    {
    HRESULT	hrStatus       = NOERROR;
    ULONG	ulStringLength = wcslen (pucsString->Buffer) * sizeof (WCHAR);


    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}
    else
	{
	pucsString->Length        = (USHORT) ulStringLength;
	pucsString->MaximumLength = (USHORT) UMAX (pucsString->MaximumLength,
						   pucsString->Length + sizeof (UNICODE_NULL));
	}


    return (hrStatus);
    } /* StringSetLength () */


HRESULT StringAllocate (PUNICODE_STRING pucsString, USHORT usMaximumStringLengthInBytes)
    {
    HRESULT	hrStatus      = NOERROR;
    LPVOID	pvBuffer      = NULL;
    SIZE_T	cActualLength = 0;


    pvBuffer = HeapAlloc (GetProcessHeap (), HEAP_ZERO_MEMORY, usMaximumStringLengthInBytes);

    hrStatus = GET_STATUS_FROM_POINTER (pvBuffer);


    if (SUCCEEDED (hrStatus))
	{
	pucsString->Buffer        = (PWCHAR)pvBuffer;
	pucsString->Length        = 0;
	pucsString->MaximumLength = usMaximumStringLengthInBytes;


	cActualLength = HeapSize (GetProcessHeap (), 0, pvBuffer);

	if ((cActualLength <= MAXUSHORT) && (cActualLength > usMaximumStringLengthInBytes))
	    {
	    pucsString->MaximumLength = (USHORT) cActualLength;
	    }
	}


    return (hrStatus);
    } /* StringAllocate () */


HRESULT StringFree (PUNICODE_STRING pucsString)
    {
    HRESULT	hrStatus = NOERROR;
    BOOL	bSucceeded;


    if (NULL != pucsString->Buffer)
	{
	bSucceeded = HeapFree (GetProcessHeap (), 0, pucsString->Buffer);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);
	}


    if (SUCCEEDED (hrStatus))
	{
	pucsString->Buffer        = NULL;
	pucsString->Length        = 0;
	pucsString->MaximumLength = 0;
	}


    return (hrStatus);
    } /* StringFree () */


HRESULT StringCreateFromString (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString)
    {
    HRESULT	hrStatus = NOERROR;


    hrStatus = StringAllocate (pucsNewString, pucsOriginalString->MaximumLength);


    if (SUCCEEDED (hrStatus))
	{
	memcpy (pucsNewString->Buffer, pucsOriginalString->Buffer, pucsOriginalString->Length);

	pucsNewString->Length = pucsOriginalString->Length;

	pucsNewString->Buffer [pucsNewString->Length / sizeof (WCHAR)] = UNICODE_NULL;
	}


    return (hrStatus);
    } /* StringCreateFromString () */


HRESULT StringCreateFromString (PUNICODE_STRING pucsNewString, LPCWSTR pwszOriginalString)
    {
    HRESULT	hrStatus       = NOERROR;
    ULONG	ulStringLength = wcslen (pwszOriginalString) * sizeof (WCHAR);


    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (pucsNewString, (USHORT) (ulStringLength + sizeof (UNICODE_NULL)));
	}


    if (SUCCEEDED (hrStatus))
	{
	memcpy (pucsNewString->Buffer, pwszOriginalString, ulStringLength);

	pucsNewString->Length = (USHORT) ulStringLength;

	pucsNewString->Buffer [pucsNewString->Length / sizeof (WCHAR)] = UNICODE_NULL;
	}


    return (hrStatus);
    } /* StringCreateFromString () */


HRESULT StringCreateFromString (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString, DWORD dwExtraChars)
    {
    HRESULT	hrStatus       = NOERROR;
    ULONG	ulStringLength = pucsOriginalString->MaximumLength + (dwExtraChars * sizeof (WCHAR));


    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (pucsNewString, (USHORT) (ulStringLength + sizeof (UNICODE_NULL)));
	}


    if (SUCCEEDED (hrStatus))
	{
	memcpy (pucsNewString->Buffer, pucsOriginalString->Buffer, pucsOriginalString->Length);

	pucsNewString->Length = pucsOriginalString->Length;

	pucsNewString->Buffer [pucsNewString->Length / sizeof (WCHAR)] = UNICODE_NULL;
	}


    return (hrStatus);
    } /* StringCreateFromString () */


HRESULT StringCreateFromString (PUNICODE_STRING pucsNewString, LPCWSTR pwszOriginalString, DWORD dwExtraChars)
    {
    HRESULT	hrStatus       = NOERROR;
    ULONG	ulStringLength = (wcslen (pwszOriginalString) + dwExtraChars) * sizeof (WCHAR);


    if (ulStringLength >= (MAXUSHORT - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (pucsNewString, (USHORT) (ulStringLength + sizeof (UNICODE_NULL)));
	}


    if (SUCCEEDED (hrStatus))
	{
	memcpy (pucsNewString->Buffer, pwszOriginalString, ulStringLength);

	pucsNewString->Length = (USHORT) ulStringLength;

	pucsNewString->Buffer [pucsNewString->Length / sizeof (WCHAR)] = UNICODE_NULL;
	}


    return (hrStatus);
    } /* StringCreateFromString () */


HRESULT StringAppendString (PUNICODE_STRING pucsTarget, PUNICODE_STRING pucsSource)
    {
    HRESULT	hrStatus = NOERROR;

    if (pucsSource->Length > (pucsTarget->MaximumLength - pucsTarget->Length - sizeof (UNICODE_NULL)))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}
    else
	{
	memmove (&pucsTarget->Buffer [pucsTarget->Length / sizeof (WCHAR)],
		 pucsSource->Buffer,
		 pucsSource->Length + sizeof (UNICODE_NULL));

	pucsTarget->Length += pucsSource->Length;
	}


    /*
    ** There should be no reason in this code using this routine to
    ** have to deal with a short buffer so trap potential problems.
    */
    BS_ASSERT (SUCCEEDED (hrStatus));


    return (hrStatus);
    } /* StringAppendString () */


HRESULT StringAppendString (PUNICODE_STRING pucsTarget, PWCHAR pwszSource)
    {
    HRESULT		hrStatus = NOERROR;
    UNICODE_STRING	ucsSource;


    StringInitialise (&ucsSource, pwszSource);

    hrStatus = StringAppendString (pucsTarget, &ucsSource);


    /*
    ** There should be no reason in this code using this routine to
    ** have to deal with a short buffer so trap potential problems.
    */
    BS_ASSERT (SUCCEEDED (hrStatus));


    return (hrStatus);
    } /* StringAppendString () */


HRESULT StringCreateFromExpandedString (PUNICODE_STRING pucsNewString, LPCWSTR pwszOriginalString)
    {
    return (StringCreateFromExpandedString (pucsNewString, pwszOriginalString, 0));
    }


HRESULT StringCreateFromExpandedString (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString)
    {
    return (StringCreateFromExpandedString (pucsNewString, pucsOriginalString->Buffer, 0));
    }


HRESULT StringCreateFromExpandedString (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString, DWORD dwExtraChars)
    {
    return (StringCreateFromExpandedString (pucsNewString, pucsOriginalString->Buffer, dwExtraChars));
    }


HRESULT StringCreateFromExpandedString (PUNICODE_STRING pucsNewString, LPCWSTR pwszOriginalString, DWORD dwExtraChars)
    {
    HRESULT	hrStatus = NOERROR;
    DWORD	dwStringLength;


    /*
    ** Remember, ExpandEnvironmentStringsW () includes the terminating null in the response.
    */
    dwStringLength = ExpandEnvironmentStringsW (pwszOriginalString, NULL, 0) + dwExtraChars;

    hrStatus = GET_STATUS_FROM_BOOL (0 != dwStringLength);



    if (SUCCEEDED (hrStatus) && ((dwStringLength * sizeof (WCHAR)) > MAXUSHORT))
	{
	hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (pucsNewString, (USHORT)(dwStringLength * sizeof (WCHAR)));
	}


    if (SUCCEEDED (hrStatus))
	{
	/*
	** Note that if the expanded string has gotten bigger since we
	** allocated the buffer then too bad, we may not get all the
	** new translation. Not that we really expect these expanded
	** strings to have changed any time recently.
	*/
	dwStringLength = ExpandEnvironmentStringsW (pwszOriginalString,
						    pucsNewString->Buffer,
						    pucsNewString->MaximumLength / sizeof (WCHAR));

	hrStatus = GET_STATUS_FROM_BOOL (0 != dwStringLength);


	if (SUCCEEDED (hrStatus))
	    {
	    pucsNewString->Length = (USHORT) ((dwStringLength - 1) * sizeof (WCHAR));
	    }
	}


    return (hrStatus);
    } /* StringCreateFromExpandedString () */



/*
**++
**
**  Routine Description:
**
**	Closes a standard Win32 handle and set it to INVALID_HANDLE_VALUE. 
**	Safe to be called multiple times on the same handle or on a handle 
**	initialised to INVALID_HANDLE_VALUE or NULL.
**
**
**  Arguments:
**
**	phHandle	Address of the handle to be closed
**
**
**  Side Effects:
**
**
**  Return Value:
**
**	Any HRESULT from CloseHandle()
**
**-- 
*/

HRESULT CommonCloseHandle (PHANDLE phHandle)
    {
    HRESULT	hrStatus = NOERROR;
    BOOL	bSucceeded;


    if ((INVALID_HANDLE_VALUE != *phHandle) && (NULL != *phHandle))
	{
	bSucceeded = CloseHandle (*phHandle);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	if (SUCCEEDED (hrStatus))
	    {
	    *phHandle = INVALID_HANDLE_VALUE;
	    }
	}


    return (hrStatus);
    } /* CommonCloseHandle () */



#define VALID_PATH( path ) ( ( ( pwszPathName[0] == DIR_SEP_CHAR )  && ( pwszPathName[1] == DIR_SEP_CHAR ) ) || \
                             ( isalpha( pwszPathName[0] ) && ( pwszPathName[1] == L':' ) && ( pwszPathName[2] == DIR_SEP_CHAR ) ) )
/*++
**
** Routine Description:
**
**	Creates any number of directories along a path.  Only works for
**	full path names with no relative elements in it.  Other than that
**	it works identically as CreateDirectory() works and sets the same
**	error codes except it doesn't return an error if the complete
**	path already exists.
**
** Arguments:
**
**	pwszPathName - The path with possible directory components to create.
**
**	lpSecurityAttributes -
**
** Return Value:
**
**	TRUE - Sucessful
**	FALSE - GetLastError() can return one of these (and others):
**		ERROR_ALREADY_EXISTS - when something other than a file exists somewhere in the path.
**		ERROR_BAD_PATHNAME   - when \\servername alone is specified in the pathname
**		ERROR_ACCESS_DENIED  - when x:\ alone is specified in the pathname and x: exists
**		ERROR_PATH_NOT_FOUND - when x: alone is specified in the pathname and x: doesn't exist.
**				       Should not get this error code for any other reason.
**		ERROR_INVALID_NAME   - when pathname doesn't start with either x:\ or \\
**
**--
*/

BOOL VsCreateDirectories (IN LPCWSTR pwszPathName,
			  IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
			  IN DWORD dwExtraAttributes)
    {
    DWORD dwObjAttribs, dwRetPreserve;
    BOOL bRet;


    /*
    ** Make sure the path starts with the valid path prefixes
    */
    if (!VALID_PATH (pwszPathName))
	{
	SetLastError (ERROR_INVALID_NAME);
        return FALSE;
	}



    /*
    ** Save away the current last error code.
    */
    dwRetPreserve = GetLastError ();


    /*
    **  Now test for the most common case, the directory already exists.  This
    **  is the performance path.
    */
    dwObjAttribs = GetFileAttributesW (pwszPathName);

    if ((dwObjAttribs != 0xFFFFFFFF) && (dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY))
	{
	/*
	** Don't return an error if the directory already exists.
	** This is the one case where this function differs from
	** CreateDirectory().  Notice that even though another type of
	** file may exist with this pathname, no error is returned yet
	** since I want the error to come from CreateDirectory() to
	** get CreateDirectory() error behavior.
	**
	** Since we're successful restore the last error code.
	*/
        SetLastError (dwRetPreserve);
        return TRUE;
	}


    /*
    ** Now try to create the directory using the full path.  Even
    ** though we might already know it exists as something other than
    ** a directory, get the error from CreateDirectory() instead of
    ** having to try to reverse engineer all possible errors that
    ** CreateDirectory() can return in the above code.
    **
    ** It is probably the second most common case that when this
    ** function is called that only the last component in the
    ** directory doesn't exist.  Let's try to make it.
    **
    ** Note that it appears if a UNC path is given with a number of
    ** non-existing path components the remote server automatically
    ** creates all of those components when CreateDirectory is called.
    ** Therefore, the next call is almost always successful when the
    ** path is a UNC.
    */
    bRet = CreateDirectoryW (pwszPathName, lpSecurityAttributes);

    if (bRet)
	{
	SetFileAttributesW (pwszPathName, dwExtraAttributes);

	/*
	** Set it back to the last error code
	*/
        SetLastError (dwRetPreserve);
        return TRUE;
	}

    else if (GetLastError () == ERROR_ALREADY_EXISTS)
	{
	/*
 	** Looks like someone created the name whilst we weren't
	** looking. Check to see if it's a directory and return
	** success if so, otherwise return the error that
	** CreateDirectoryW() set.
	*/
	dwObjAttribs = GetFileAttributesW (pwszPathName);

	if ((dwObjAttribs != 0xFFFFFFFF) && (dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY))
	    {
	    /*
	    ** It's a directory. Declare victory.
	    **
	    ** Restore the last error code
	    */
	    SetLastError (dwRetPreserve);
	    return TRUE;
	    }
	else
	    {
	    SetLastError (ERROR_ALREADY_EXISTS);

	    return FALSE;
	    }
	}

    else if (GetLastError () != ERROR_PATH_NOT_FOUND )
	{
        return FALSE;
	}



    /*
    ** Allocate memory to hold the string while processing the path.
    ** The passed in string is a const.
    */
    PWCHAR pwszTempPath = (PWCHAR) malloc ((wcslen (pwszPathName) + 1) * sizeof (WCHAR));

    BS_ASSERT (pwszTempPath != NULL);


    wcscpy (pwszTempPath, pwszPathName);

    /*
    ** Appears some components in the path don't exist.  Now try to
    ** create the components.
    */
    PWCHAR pwsz, pwszSlash;


    /*
    ** First skip the drive letter part or the \\server\sharename
    ** part and get to the first slash before the first level
    ** directory component.
    */
    if (pwszTempPath [1] == L':')
	{
	/*
        **  Path in the form of x:\..., skip first 2 chars
        */
        pwsz = pwszTempPath + 2;
	}
    else
	{
        /*
        ** Path should be in form of \\servername\sharename.  Can be
        ** \\?\d: Search to first slash after sharename
        **
        ** First search to first char of the share name
        */
        pwsz = pwszTempPath + 2;

        while ((*pwsz != L'\0') && (*pwsz != DIR_SEP_CHAR))
	    {
            ++pwsz;
	    }


        /*
        ** Eat up all continuous slashes and get to first char of the
        ** share name
        */
        while (*pwsz == DIR_SEP_CHAR)
	    {
	    ++pwsz;
	    }


        if (*pwsz == L'\0')
	    {
            /*
            ** This shouldn't have happened since the CreateDirectory
            ** call should have caught it.  Oh, well, deal with it.
            */
            SetLastError (ERROR_BAD_PATHNAME);

            free (pwszTempPath);

            return FALSE;
	    }


        /*
	** Now at first char of share name, let's search for first
	** slash after the share name to get to the (first) shash in
	** front the first level directory.
        */
        while ((*pwsz != L'\0') && (*pwsz != DIR_SEP_CHAR))
	    {
            ++pwsz;
	    }
	}


    
    /*
    ** Eat up all continuous slashes before the first level directory
    */
    while (*pwsz == DIR_SEP_CHAR)
	{
	++pwsz;
	}


    /*
    ** Now at first char of the first level directory, let's search
    ** for first slash after the directory.
    */
    while ((*pwsz != L'\0') && (*pwsz != DIR_SEP_CHAR))
	{
	++pwsz;
	}


    /*
    ** If pwsz is pointing to a null char, that means only the first
    ** level directory needs to be created.  Fall through to the leaf
    ** node create directory.
    */
    while (*pwsz != L'\0')
	{
        pwszSlash = pwsz;  //  Keep pointer to the separator

        /*
        **  Eat up all continuous slashes.
        */
        while (*pwsz == DIR_SEP_CHAR)
	    {
	    ++pwsz;
	    }


        if (*pwsz == L'\0')
	    {
	    /*
            ** There were just slashes at the end of the path.  Break
            ** out of loop, let the leaf node CreateDirectory create
            ** the last directory.
            */
            break;
	    }


        /*
        ** Terminate the directory path at the current level.
        */
        *pwszSlash = L'\0';

        dwObjAttribs = GetFileAttributesW (pwszTempPath);

        if ((dwObjAttribs == 0XFFFFFFFF) || ((dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY) == 0))
	    {
            bRet = CreateDirectoryW (pwszTempPath, lpSecurityAttributes);

            if (bRet)
		{
		SetFileAttributesW (pwszTempPath, dwExtraAttributes);
		}
	    else
		{
		if (ERROR_ALREADY_EXISTS != GetLastError ())
		    {
		    /*
		    **  Restore the slash.
		    */
		    *pwszSlash = DIR_SEP_CHAR;

		    free (pwszTempPath);
		    
		    return FALSE;
		    }

		else
		    {
		    /* 
		    ** Looks like someone created the name whilst we
		    ** weren't looking. Check to see if it's a
		    ** directory and continue if so, otherwise return
		    ** the error that CreateDirectoryW() set.
		    */
		    dwObjAttribs = GetFileAttributesW (pwszTempPath);

		    if ((dwObjAttribs == 0xFFFFFFFF) || ((dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY) == 0))
			{
			/*
			** It's not what we recognise as a
			** directory. Declare failure. Set the error
			** code to that which CreateDirectoryW()
			** returned, restore the slash, free the
			** buffer and get out of here.
			*/
			SetLastError (ERROR_ALREADY_EXISTS);

			*pwszSlash = DIR_SEP_CHAR;

			free (pwszTempPath);

			return FALSE;
			}
		    }
		}
	    }


        /*
        **  Restore the slash.
        */
        *pwszSlash = DIR_SEP_CHAR;

        /*
        ** Now at first char of the next level directory, let's search
        ** for first slash after the directory.
        */
        while ((*pwsz != L'\0') && (*pwsz != DIR_SEP_CHAR))
	    {
            ++pwsz;
	    }
	}


    free (pwszTempPath);

    pwszTempPath = NULL;


    /*
    **  Now make the last directory.
    */
    dwObjAttribs = GetFileAttributesW (pwszPathName);

    if ((dwObjAttribs == 0xFFFFffff) || ((dwObjAttribs & FILE_ATTRIBUTE_DIRECTORY) == 0))
	{
        bRet = CreateDirectoryW (pwszPathName, lpSecurityAttributes);

        if (bRet)
	    {
	    SetFileAttributesW (pwszPathName, dwExtraAttributes);
	    }
	else
	    {
            return FALSE;
	    }
	}


    SetLastError (dwRetPreserve);    //  Set back old last error code
    return TRUE;
    }


/*
** The next set of rountes are used to change the state of SCM
** controlled services, typically between RUNNING and either PAUSED or
** STOPPED.
**
** The initial collection are for manipulating the states, control
** codes and getting the string equivalents to be used for tracing
** purposes.
**
** The major routines is VsServiceChangeState(). This is called
** specifying the reuiqred state for the service and after some
** validation, it makes the appropriate request of the SCM and calls
** WaitForServiceToEnterState() to wait until the services reaches the
** desired state, or it times out.  
*/

static PWCHAR const GetStringFromStateCode (DWORD dwState)
    {
    PWCHAR	pwszReturnedString = NULL;


    switch (dwState)
	{
	case 0:                        pwszReturnedString = L"UnSpecified";     break;
	case SERVICE_STOPPED:          pwszReturnedString = L"Stopped";         break;
	case SERVICE_START_PENDING:    pwszReturnedString = L"StartPending";    break;
	case SERVICE_STOP_PENDING:     pwszReturnedString = L"StopPending";     break;
	case SERVICE_RUNNING:          pwszReturnedString = L"Running";         break;
	case SERVICE_CONTINUE_PENDING: pwszReturnedString = L"ContinuePending"; break;
	case SERVICE_PAUSE_PENDING:    pwszReturnedString = L"PausePending";    break;
	case SERVICE_PAUSED:           pwszReturnedString = L"Paused";          break;
	default:                       pwszReturnedString = L"UNKKNOWN STATE";  break;
	}


    return (pwszReturnedString);
    } /* GetStringFromStateCode () */


static DWORD const GetControlCodeFromTargetState (const DWORD dwTargetState)
    {
    DWORD	dwServiceControlCode;


    switch (dwTargetState)
	{
	case SERVICE_STOPPED: dwServiceControlCode = SERVICE_CONTROL_STOP;     break;
	case SERVICE_PAUSED:  dwServiceControlCode = SERVICE_CONTROL_PAUSE;    break;
	case SERVICE_RUNNING: dwServiceControlCode = SERVICE_CONTROL_CONTINUE; break;
	default:              dwServiceControlCode = 0;                        break;
	}

    return (dwServiceControlCode);
    } /* GetControlCodeFromTargetState () */


static DWORD const GetNormalisedState (DWORD dwCurrentState)
    {
    DWORD	dwNormalisedState;


    switch (dwCurrentState)
	{
	case SERVICE_STOPPED:
	case SERVICE_STOP_PENDING:
	    dwNormalisedState = SERVICE_STOPPED;
	    break;

	case SERVICE_START_PENDING:
	case SERVICE_CONTINUE_PENDING:
	case SERVICE_RUNNING:
	    dwNormalisedState = SERVICE_RUNNING;
	    break;

	case SERVICE_PAUSED:
	case SERVICE_PAUSE_PENDING:
	    dwNormalisedState = SERVICE_PAUSED;
	    break;

	default:
	    dwNormalisedState = 0;
	    break;
	}

    return (dwNormalisedState);
    } /* GetNormalisedState () */

/*
**++
**
**  Routine Description:
**
**	Wait for the specified service to enter the specified
**	state. The routine polls the serivce for it's current state
**	every dwServiceStatePollingIntervalInMilliSeconds milliseconds
**	to see if the service has reached the desired state. If the
**	repeated delay eventually reaches the timeout period the
**	routine stops polling and returns a failure status.
**
**	NOTE: since this routine just sleeps between service state 
**	interrogations, it effectively stalls from the point of view
**	of the caller.
**
**
**  Arguments:
**
**	shService			handle to the service being manipulated
**	dwMaxDelayInMilliSeconds	timeout period
**	dwDesiredState			state to move the service into
**
**
**  Side Effects:
**
**
**  Return Value:
**
**	HRESULT for ERROR_TIMOUT if the service did not reach the required state in the required time
**
**-- 
*/

static HRESULT WaitForServiceToEnterState (SC_HANDLE   shService, 
					   DWORD       dwMaxDelayInMilliSeconds, 
					   const DWORD dwDesiredState)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"WaitForServiceToEnterState");

    DWORD		dwRemainingDelay = dwMaxDelayInMilliSeconds;
    DWORD		dwInitialState;
    const DWORD		dwServiceStatePollingIntervalInMilliSeconds = 100;
    BOOL		bSucceeded;
    SERVICE_STATUS	sSStat;



    try
	{
	bSucceeded = QueryServiceStatus (shService, &sSStat);

	ft.hr = GET_STATUS_FROM_BOOL (bSucceeded);

	dwInitialState = sSStat.dwCurrentState;

	ft.Trace (VSSDBG_SHIM,
		  L"Initial QueryServiceStatus returned: 0x%08X with current state '%s' and desired state '%s'",
		  ft.hr,
		  GetStringFromStateCode (dwInitialState),
		  GetStringFromStateCode (dwDesiredState));


	while ((dwDesiredState != sSStat.dwCurrentState) && (dwRemainingDelay > 0))
	    {
	    Sleep (UMIN (dwServiceStatePollingIntervalInMilliSeconds, dwRemainingDelay));

	    dwRemainingDelay -= (UMIN (dwServiceStatePollingIntervalInMilliSeconds, dwRemainingDelay));

	    if (0 == dwRemainingDelay)
		{
		ft.Throw (VSSDBG_SHIM,
			  HRESULT_FROM_WIN32 (ERROR_TIMEOUT),
			  L"Exceeded maximum delay (%dms)",
			  dwMaxDelayInMilliSeconds);
		}

	    bSucceeded = QueryServiceStatus (shService, &sSStat);

	    ft.ThrowIf (!bSucceeded,
			VSSDBG_SHIM,
			GET_STATUS_FROM_BOOL (bSucceeded),
			L"QueryServiceStatus shows '%s' as current state",
			GetStringFromStateCode (sSStat.dwCurrentState));
	    }



	ft.Trace (VSSDBG_SHIM,
		  L"Service state change from '%s' to '%s' took %u milliseconds",
		  GetStringFromStateCode (dwInitialState),
		  GetStringFromStateCode (sSStat.dwCurrentState),
		  dwMaxDelayInMilliSeconds - dwRemainingDelay);
	}
    VSS_STANDARD_CATCH (ft);


    return (ft.hr);
    } /* WaitForServiceToEnterState () */

/*
**++
**
**  Routine Description:
**
**	Changes the state of a service if appropriate.
**
**
**  Arguments:
**
**	pwszServiceName		The real service name, i.e. cisvc
**	dwRequestedState	the state code for the state we wish to enter
**	pdwReturnedOldState	pointer to location to receive current service state.
**				Can be NULL of current state not required
**	pbReturnedStateChanged	pointer to location to receive flag indicating if  
**				service changed state. Pointer can be NULL if flag
**				value not required.
**
**
**  Return Value:
**
**	Any HRESULT resulting from faiure communication with the
**	SCM (Service Control Manager).
**
**--
*/

HRESULT VsServiceChangeState (LPCWSTR	pwszServiceName,
			      DWORD	dwRequestedState,
			      PDWORD	pdwReturnedOldState,
			      PBOOL	pbReturnedStateChanged)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"VsServiceChangeState");

    SC_HANDLE		shSCManager = NULL;
    SC_HANDLE		shSCService = NULL;
    DWORD		dwOldState  = 0;
    BOOL		bSucceeded;
    SERVICE_STATUS	sSStat;
    const DWORD		dwNormalisedRequestedState = GetNormalisedState (dwRequestedState);


    ft.Trace (VSSDBG_SHIM,
	      L"Service '%s' requested to change to state '%s' (normalised to '%s')",
	      pwszServiceName,
	      GetStringFromStateCode (dwRequestedState),
	      GetStringFromStateCode (dwNormalisedRequestedState));


    RETURN_VALUE_IF_REQUIRED (pbReturnedStateChanged, FALSE);


    try
	{
        /*
	**  Connect to the local service control manager
        */
        shSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS);

	ft.hr = GET_STATUS_FROM_HANDLE (shSCManager);

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"Called OpenSCManager()");


        /*
	**  Get a handle to the service
        */
        shSCService = OpenService (shSCManager, pwszServiceName, SERVICE_ALL_ACCESS);

	ft.hr = GET_STATUS_FROM_HANDLE (shSCService);


	/*
	** If it's an invalid name or the service doesn't exist then
	** fail gracefully. For all other failures do the normal
	** thing. Oh yes, if on the off-chance we should happen to
	** succeed, carry on.
	*/
	if ((HRESULT_FROM_WIN32 (ERROR_INVALID_NAME)           == ft.hr) ||
	    (HRESULT_FROM_WIN32 (ERROR_SERVICE_DOES_NOT_EXIST) == ft.hr))
	    {
	    ft.Trace (VSSDBG_SHIM, L"'%s' service not found", pwszServiceName);
	    }

	else if (ft.HrFailed ())
	    {
	    /*
	    ** See if the service doesn't exist
            */
	    ft.Throw (VSSDBG_SHIM, E_FAIL, L"ERROR - OpenService() returned: %d", ft.hr);
	    }

        else
	    {
            /*
	    ** Now query the service to see what state it is in at the moment.
            */
	    bSucceeded = QueryServiceStatus (shSCService, &sSStat);

	    ft.ThrowIf (!bSucceeded,
			VSSDBG_SHIM,
			GET_STATUS_FROM_BOOL (bSucceeded),
			L"QueryServiceStatus shows '%s' as current state",
			GetStringFromStateCode (sSStat.dwCurrentState));


	    dwOldState = sSStat.dwCurrentState;



	    /*
	    ** Now we decide what to do.
	    **	    If we are already in the requested state, we do nothing.
	    **	    If we are stopped and are requested to pause, we do nothing
	    **	    otherwise we make the attempt to change state.
	    */
            if (dwNormalisedRequestedState == dwOldState)
		{
		/*
		** We are already in the requested state, so do
		** nothing. We should even tell folk of that. We're
		** proud to be doing nothing.
		*/
                ft.Trace (VSSDBG_SHIM,
			  L"'%s' service is already in requested state: doing nothing",
			  pwszServiceName);

		RETURN_VALUE_IF_REQUIRED (pdwReturnedOldState, dwOldState);
		}

	    else if ((SERVICE_STOPPED == sSStat.dwCurrentState) && (SERVICE_PAUSED == dwNormalisedRequestedState))
		{
		/*
		** Do nothing. Just log the fact and move on.
		*/
		ft.Trace (VSSDBG_SHIM,
			  L"Asked to PAUSE the '%s' service which is already STOPPED",
			  pwszServiceName);

		RETURN_VALUE_IF_REQUIRED (pdwReturnedOldState, dwOldState);
		}

	    else
		{
		/*
		** We want a state which is different from the one
		** we're in at the moment. Generally this just means
		** calling ControlService() asking for the new state
		** except if the service is currently stopped. If
		** that's so, then we call StartService()
		*/
		if (SERVICE_STOPPED == sSStat.dwCurrentState)
		    {
		    /*
		    ** Call StartService to get the ball rolling
		    */
		    bSucceeded = StartService (shSCService, 0, NULL);
		    }

		else
		    {
		    bSucceeded = ControlService (shSCService,
						 GetControlCodeFromTargetState (dwNormalisedRequestedState),
						 &sSStat);
		    }

		ft.ThrowIf (!bSucceeded,
			    VSSDBG_SHIM,
			    GET_STATUS_FROM_BOOL (bSucceeded),
			    (SERVICE_STOPPED == sSStat.dwCurrentState)
							? L"StartService attempting '%s' to '%s', now at '%s'"
							: L"ControlService attempting '%s' to '%s', now at '%s'",
			    GetStringFromStateCode (dwOldState),
			    GetStringFromStateCode (dwNormalisedRequestedState),
			    GetStringFromStateCode (sSStat.dwCurrentState));

		RETURN_VALUE_IF_REQUIRED (pdwReturnedOldState,    dwOldState);
		RETURN_VALUE_IF_REQUIRED (pbReturnedStateChanged, TRUE);


		ft.hr = WaitForServiceToEnterState (shSCService, 15000, dwNormalisedRequestedState);

		if (ft.HrFailed ())
		    {
		    ft.Throw (VSSDBG_SHIM,
			      ft.hr,
			      L"WaitForServiceToEnterState() failed with 0x%08X",
			      ft.hr);
		    }

		}
	    }
	} VSS_STANDARD_CATCH (ft);



    /*
    **  Now close the service and service control manager handles
    */
    if (NULL != shSCService) CloseServiceHandle (shSCService);
    if (NULL != shSCManager) CloseServiceHandle (shSCManager);

    return (ft.hr);
    } /* VsServiceChangeState () */

/*
**++
**
**  Routine Description:
**
**	Deletes all the sub-directories and files in the specified
**	directory and then deletes the directory itself.
**
**
**
**  Arguments:
**
**	pucsDirectoryPath	The diretory path to clear out
**
**
**  Side Effects:
**
**	None
**
**
**  Return Value:
**
**	Out of memory or any HRESULT from
**
**		RemoveDirectory()
**		DeleteFile()
**		FindFirstFile()
**
**--
*/

HRESULT RemoveDirectoryTree (PUNICODE_STRING pucsDirectoryPath)
    {
    HRESULT		hrStatus                = NOERROR;
    HANDLE		hFileScan               = INVALID_HANDLE_VALUE;
    DWORD		dwSubDirectoriesEntered = 0;
    USHORT		usCurrentPathCursor     = 0;
    PWCHAR		pwchLastSlash           = NULL;
    BOOL		bContinue               = TRUE;
    BOOL		bSucceeded;
    UNICODE_STRING	ucsCurrentPath;
    WIN32_FIND_DATAW	FileFindData;


    StringInitialise (&ucsCurrentPath);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromString (&ucsCurrentPath, pucsDirectoryPath, MAX_PATH);
	}


    pwchLastSlash = wcsrchr (ucsCurrentPath.Buffer, DIR_SEP_CHAR);

    usCurrentPathCursor = (USHORT)(pwchLastSlash - ucsCurrentPath.Buffer) + 1;



    while (SUCCEEDED (hrStatus) && bContinue)
	{
	if (HandleInvalid (hFileScan))
	    {
	    /*
	    ** No valid scan handle so start a new scan
	    */
	    hFileScan = FindFirstFileW (ucsCurrentPath.Buffer, &FileFindData);

	    hrStatus = GET_STATUS_FROM_HANDLE (hFileScan);

	    if (SUCCEEDED (hrStatus))
		{
		StringTruncate (&ucsCurrentPath, usCurrentPathCursor);

		hrStatus = StringAppendString (&ucsCurrentPath, FileFindData.cFileName);
		}
	    }

	else
	    {
	    /*
	    ** Continue with the existing scan
	    */
	    bSucceeded = FindNextFileW (hFileScan, &FileFindData);

	    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	    if (SUCCEEDED (hrStatus))
		{
		StringTruncate (&ucsCurrentPath, usCurrentPathCursor);

		hrStatus = StringAppendString (&ucsCurrentPath, FileFindData.cFileName);
		}
		
	    else if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_FILES) == hrStatus)
		{
		FindClose (hFileScan);
		hFileScan = INVALID_HANDLE_VALUE;

		if (dwSubDirectoriesEntered > 0)
		    {
		    /*
		    ** This is a scan of a sub-directory that is now 
		    ** complete so delete the sub-directory itself.
		    */
		    StringTruncate (&ucsCurrentPath, usCurrentPathCursor - 1);

		    bSucceeded = RemoveDirectory (ucsCurrentPath.Buffer);

		    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);


		    dwSubDirectoriesEntered--;
		    }


		if (0 == dwSubDirectoriesEntered)
		    {
		    /*
		    ** We are back to where we started except that the 
		    ** requested directory is now gone. Time to leave.
		    */
		    bContinue = FALSE;
		    hrStatus  = NOERROR;
		    }

		else
		    {
		    /*
		    ** Move back up one directory level, reset the cursor 
		    ** and prepare the path buffer to begin a new scan.
		    */
		    pwchLastSlash = wcsrchr (ucsCurrentPath.Buffer, DIR_SEP_CHAR);

		    usCurrentPathCursor = (USHORT)(pwchLastSlash - ucsCurrentPath.Buffer) + 1;


		    StringTruncate (&ucsCurrentPath, usCurrentPathCursor);
		    StringAppendString (&ucsCurrentPath, L"*");
		    }


		/*
		** No files to be processed on this pass so go back and try to 
		** find another or leave the loop as we've finished the task. 
		*/
		continue;
		}
	    }



	if (SUCCEEDED (hrStatus))
	    {
	    if (FileFindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
		{
		SetFileAttributesW (ucsCurrentPath.Buffer, 
				    FileFindData.dwFileAttributes ^ (FILE_ATTRIBUTE_READONLY));
		}


	    if (!NameIsDotOrDotDot (FileFindData.cFileName))
		{
		if ( (FileFindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) ||
		    !(FileFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
		    {
		    bSucceeded = DeleteFileW (ucsCurrentPath.Buffer);

		    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);
		    }

		else
		    {
		    bSucceeded = RemoveDirectory (ucsCurrentPath.Buffer);

		    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);


		    if (HRESULT_FROM_WIN32 (ERROR_DIR_NOT_EMPTY) == hrStatus)
			{
			/*
			** The directory wasn't empty so move down one level, 
			** close the old scan and start a new one. 
			*/
			FindClose (hFileScan);
			hFileScan = INVALID_HANDLE_VALUE;


			hrStatus = StringAppendString (&ucsCurrentPath, DIR_SEP_STRING L"*");

			if (SUCCEEDED (hrStatus))
			    {
			    usCurrentPathCursor = (ucsCurrentPath.Length / sizeof (WCHAR)) - 1;

			    dwSubDirectoriesEntered++;
			    }
			}
		    }
		}
	    }
	}



    if (!HandleInvalid (hFileScan)) FindClose (hFileScan);

    StringFree (&ucsCurrentPath);


    return (hrStatus);
    } /* RemoveDirectoryTree () */

/*
**++
**
**  Routine Description:
**
**	Moves the contents of the source directory to the target directory.
**
**
**  Arguments:
**
**	pucsSourceDirectoryPath	Source directory for the files to be moved
**	pucsTargetDirectoryPath	Target directory for the files to be moved
**
**
**  Side Effects:
**
**	Will append a trailing '\' character on the directory paths if 
**	not already present
**
**	An intermediate error can leave directory in a partial moved
**	state where some of the files have been moved but not all.
**
**
**  Return Value:
**
**	Any HRESULT from FindFirstFile() etc or from MoveFileEx()
**
**-- 
*/

HRESULT MoveFilesInDirectory (PUNICODE_STRING pucsSourceDirectoryPath,
			      PUNICODE_STRING pucsTargetDirectoryPath)
    {
    HRESULT		hrStatus              = NOERROR;
    HANDLE		hFileScan             = INVALID_HANDLE_VALUE;
    BOOL		bMoreFiles;
    BOOL		bSucceeded;
    USHORT		usOriginalSourcePathLength;
    USHORT		usOriginalTargetPathLength;
    WIN32_FIND_DATA	sFileInformation;


    if (DIR_SEP_CHAR != pucsSourceDirectoryPath->Buffer [(pucsSourceDirectoryPath->Length / sizeof (WCHAR)) - 1])
	{
	StringAppendString (pucsSourceDirectoryPath, DIR_SEP_STRING);
	}


    if (DIR_SEP_CHAR != pucsTargetDirectoryPath->Buffer [(pucsTargetDirectoryPath->Length / sizeof (WCHAR)) - 1])
	{
	StringAppendString (pucsTargetDirectoryPath, DIR_SEP_STRING);
	}


    usOriginalSourcePathLength = pucsSourceDirectoryPath->Length / sizeof (WCHAR);
    usOriginalTargetPathLength = pucsTargetDirectoryPath->Length / sizeof (WCHAR);

    StringAppendString (pucsSourceDirectoryPath, L"*");
	

    hFileScan = FindFirstFileW (pucsSourceDirectoryPath->Buffer,
				&sFileInformation);

    hrStatus = GET_STATUS_FROM_BOOL (INVALID_HANDLE_VALUE != hFileScan);



    if (SUCCEEDED (hrStatus))
	{
	do
	    {
	    if (!NameIsDotOrDotDot (sFileInformation.cFileName))
		{
		StringTruncate (pucsSourceDirectoryPath, usOriginalSourcePathLength);
		StringTruncate (pucsTargetDirectoryPath, usOriginalTargetPathLength);

		StringAppendString (pucsSourceDirectoryPath, sFileInformation.cFileName);
		StringAppendString (pucsTargetDirectoryPath, sFileInformation.cFileName);

		bSucceeded = MoveFileExW (pucsSourceDirectoryPath->Buffer,
					  pucsTargetDirectoryPath->Buffer,
					  MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING);

		hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);
		}

	    bMoreFiles = FindNextFileW (hFileScan, &sFileInformation);
	    } while (SUCCEEDED (hrStatus) && bMoreFiles);


	if (SUCCEEDED (hrStatus))
	    {
	    /*
	    ** If the last move operation was successful determine the
	    ** reason for terminating the scan. No need to report an
	    ** error if all that happened was that we have finished
	    ** what we were asked to do.
	    */
	    hrStatus = GET_STATUS_FROM_FILESCAN (bMoreFiles);
	    }

	bSucceeded = FindClose (hFileScan);
	}



    /*
    ** No matter what, make sure that the path going back out is no
    ** longer than the source string plus a possible trailing '\'
    */
    StringTruncate (pucsSourceDirectoryPath, usOriginalSourcePathLength);
    StringTruncate (pucsTargetDirectoryPath, usOriginalTargetPathLength);

    return (hrStatus);
    }

/*
**++
**
**  Routine Description:
**
**	Checks a path against an array of pointers to volume names to
**	see if path is affected by any of the volumes in the array
**
**
**  Arguments:
**
**	pwszPath			Path to be checked
**	ulVolumeCount			Number of volumes in volume array
**	ppwszVolumeNamesArray		address of the array
**	pbReturnedFoundInVolumeArray	pointer to a location to store the 
**					result of the check
**
**
**  Side Effects:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from:-
**		GetVolumePathNameW()
**		GetVolumeNameForVolumeMountPoint()
**
**-- 
*/

HRESULT IsPathInVolumeArray (IN LPCWSTR      pwszPath,
			     IN const ULONG  ulVolumeCount,
			     IN LPCWSTR     *ppwszVolumeNamesArray,
			     OUT PBOOL       pbReturnedFoundInVolumeArray) 
    {
    HRESULT		hrStatus  = NOERROR;
    BOOL		bFound    = FALSE;
    BOOL		bContinue = TRUE;
    ULONG		ulIndex;
    WCHAR		wszVolumeName [MAX_VOLUMENAME_LENGTH];
    UNICODE_STRING	ucsVolumeMountPoint;


    StringInitialise (&ucsVolumeMountPoint);


    if ((0 == ulVolumeCount) || (NULL == pbReturnedFoundInVolumeArray))
	{
	BS_ASSERT (false);

	bContinue = FALSE;
	}



    if (bContinue) 
	{
	/*
	** We need a string that is at least as big as the supplied
	** path. 
	*/
	hrStatus = StringAllocate (&ucsVolumeMountPoint, wcslen (pwszPath) * sizeof (WCHAR));

	bContinue = SUCCEEDED (hrStatus);
	}



    if (bContinue) 
	{
	/*
	** Get the volume mount point
	*/
	bContinue = GetVolumePathNameW (pwszPath, 
					ucsVolumeMountPoint.Buffer, 
					ucsVolumeMountPoint.MaximumLength / sizeof (WCHAR));

	hrStatus = GET_STATUS_FROM_BOOL (bContinue);
	}



    if (bContinue)
	{
	/*
	** Get the volume name
	*/
	bContinue = GetVolumeNameForVolumeMountPointW (ucsVolumeMountPoint.Buffer, 
						       wszVolumeName, 
						       SIZEOF_ARRAY (wszVolumeName));

	hrStatus = GET_STATUS_FROM_BOOL (bContinue);
	}


    if (bContinue)
	{
	/*
	** Search to see if that volume is within snapshotted volumes
	*/
	for (ulIndex = 0; !bFound && (ulIndex < ulVolumeCount); ulIndex++)
	    {
	    BS_ASSERT (NULL != ppwszVolumeNamesArray [ulIndex]);

	    if (0 == wcscmp (wszVolumeName, ppwszVolumeNamesArray [ulIndex]))
		{
		bFound = TRUE;
		}
	    }
	}



    RETURN_VALUE_IF_REQUIRED (pbReturnedFoundInVolumeArray, bFound);

    StringFree (&ucsVolumeMountPoint);

    return (hrStatus);
    } /* IsPathInVolumeArray () */

/*
**++
**
**  Routine Description:
**
**	Routine to classify the many assorted internal writer errors
**	into one of the narrow set of responses a writer is permitted
**	to send back to the requestor.
**
**
**  Arguments:
**
**	hrStatus	HRESULT to be classified
**
**
**  Return Value:
**
**	One of the following list depending upon the supplied status.
**
**		VSS_E_WRITERERROR_OUTOFRESOURCES
**		VSS_E_WRITERERROR_RETRYABLE
**		VSS_E_WRITERERROR_NONRETRYABLE
**		VSS_E_WRITERERROR_TIMEOUT
**		VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
**		
**
**-- 
*/

const HRESULT ClassifyWriterFailure (HRESULT hrWriterFailure)
    {
    BOOL bStatusUpdated;

    return (ClassifyWriterFailure (hrWriterFailure, bStatusUpdated));
    } /* ClassifyWriterFailure () */

/*
**++
**
**  Routine Description:
**
**	Routine to classify the many assorted internal writer errors
**	into one of the narrow set of responses a writer is permitted
**	to send back to the requestor.
**
**
**  Arguments:
**
**	hrStatus	HRESULT to be classified
**	bStatusUpdated	TRUE if the status is re-mapped 
**
**
**  Return Value:
**
**	One of the following list depending upon the supplied status.
**
**		VSS_E_WRITERERROR_OUTOFRESOURCES
**		VSS_E_WRITERERROR_RETRYABLE
**		VSS_E_WRITERERROR_NONRETRYABLE
**		VSS_E_WRITERERROR_TIMEOUT
**		VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
 **		
**
**-- 
*/

const HRESULT ClassifyWriterFailure (HRESULT hrWriterFailure, BOOL &bStatusUpdated)
    {
    HRESULT hrStatus;


    switch (hrWriterFailure)
	{
	case NOERROR:
	case VSS_E_WRITERERROR_OUTOFRESOURCES:
	case VSS_E_WRITERERROR_RETRYABLE:
	case VSS_E_WRITERERROR_NONRETRYABLE:
	case VSS_E_WRITERERROR_TIMEOUT:
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:
	    /*
	    ** These are ok as they are so no need to transmogrify them.
	    */
	    hrStatus       = hrWriterFailure;
	    bStatusUpdated = FALSE;
	    break;


	case E_OUTOFMEMORY:
	case HRESULT_FROM_WIN32 (ERROR_NOT_ENOUGH_MEMORY):
	case HRESULT_FROM_WIN32 (ERROR_NO_MORE_SEARCH_HANDLES):
	case HRESULT_FROM_WIN32 (ERROR_NO_MORE_USER_HANDLES):
	case HRESULT_FROM_WIN32 (ERROR_NO_LOG_SPACE):
	case HRESULT_FROM_WIN32 (ERROR_DISK_FULL):
	    hrStatus = VSS_E_WRITERERROR_OUTOFRESOURCES;
	    bStatusUpdated = TRUE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_NOT_READY):
	    hrStatus       = VSS_E_WRITERERROR_RETRYABLE;
	    bStatusUpdated = TRUE;
            break;


	case HRESULT_FROM_WIN32 (ERROR_TIMEOUT):
	    hrStatus       = VSS_E_WRITERERROR_TIMEOUT;
	    bStatusUpdated = TRUE;
	    break;



	case E_UNEXPECTED:
	case E_INVALIDARG:	// equal to HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER)
	case E_ACCESSDENIED:
	case HRESULT_FROM_WIN32 (ERROR_PATH_NOT_FOUND):
	case HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND):
	case HRESULT_FROM_WIN32 (ERROR_PRIVILEGE_NOT_HELD):
	case HRESULT_FROM_WIN32 (ERROR_NOT_LOCKED):
	case HRESULT_FROM_WIN32 (ERROR_LOCKED):

	default:
	    hrStatus       = VSS_E_WRITERERROR_NONRETRYABLE;
	    bStatusUpdated = TRUE;
	    break;
	}


    return (hrStatus);
    } /* ClassifyWriterFailure () */

/*
**++
**
**  Routine Description:
**
**	Routine to classify the many assorted internal shim errors
**	into one of the narrow set of responses a writer is permitted
**	to send back to the requestor.
**
**
**  Arguments:
**
**	hrStatus	HRESULT to be classified
**
**
**  Return Value:
**
**	One of the following list depending upon the supplied status.
**
**		E_OUTOFMEMORY
**		E_ACCESSDENIED
**		E_INVALIDARG
**		E_UNEXPECTED
**		VSS_E_WRITERERROR_OUTOFRESOURCES
**		VSS_E_WRITERERROR_RETRYABLE
**		VSS_E_WRITERERROR_NONRETRYABLE
**		VSS_E_WRITERERROR_TIMEOUT
**		VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
 **--
*/

const HRESULT ClassifyShimFailure (HRESULT hrWriterFailure)
    {
    BOOL bStatusUpdated;

    return (ClassifyShimFailure (hrWriterFailure, bStatusUpdated));
    } /* ClassifyShimFailure () */

/*
**++
**
**  Routine Description:
**
**	Routine to classify the many assorted internal shim errors
**	into one of the narrow set of responses a writer is permitted
**	to send back to the requestor.
**
**
**  Arguments:
**
**	hrStatus	HRESULT to be classified
**	bStatusUpdated	TRUE if the status is re-mapped 
**
**
**  Return Value:
**
**	One of the following list depending upon the supplied status.
**
**		E_OUTOFMEMORY
**		E_ACCESSDENIED
**		E_INVALIDARG
**		E_UNEXPECTED
**		VSS_E_BAD_STATE
**		VSS_E_SNAPSHOT_SET_IN_PROGRESS
**		VSS_E_WRITERERROR_OUTOFRESOURCES
**		VSS_E_WRITERERROR_RETRYABLE
**		VSS_E_WRITERERROR_NONRETRYABLE
**		VSS_E_WRITERERROR_TIMEOUT
**		VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
 **--
*/

const HRESULT ClassifyShimFailure (HRESULT hrWriterFailure, BOOL &bStatusUpdated)
    {
    HRESULT hrStatus;


    switch (hrWriterFailure)
	{
	case NOERROR:
	case E_OUTOFMEMORY:
	case E_ACCESSDENIED:
	case E_INVALIDARG:	// equal to HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER)
	case E_UNEXPECTED:
	case VSS_E_BAD_STATE:
	case VSS_E_SNAPSHOT_SET_IN_PROGRESS:
	case VSS_E_WRITERERROR_RETRYABLE:
	case VSS_E_WRITERERROR_NONRETRYABLE:
	case VSS_E_WRITERERROR_TIMEOUT:
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:
	case VSS_E_WRITERERROR_OUTOFRESOURCES:
	    /*
	    ** These are ok as they are so no need to transmogrify them.
	    */
	    hrStatus       = hrWriterFailure;
	    bStatusUpdated = FALSE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_NOT_LOCKED):
	    hrStatus       = VSS_E_BAD_STATE;
	    bStatusUpdated = TRUE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_LOCKED):
	    hrStatus       = VSS_E_SNAPSHOT_SET_IN_PROGRESS;
	    bStatusUpdated = TRUE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_NOT_ENOUGH_MEMORY):
	case HRESULT_FROM_WIN32 (ERROR_NO_MORE_SEARCH_HANDLES):
	case HRESULT_FROM_WIN32 (ERROR_NO_MORE_USER_HANDLES):
	case HRESULT_FROM_WIN32 (ERROR_NO_LOG_SPACE):
	case HRESULT_FROM_WIN32 (ERROR_DISK_FULL):
	    hrStatus       = E_OUTOFMEMORY;
	    bStatusUpdated = TRUE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_PRIVILEGE_NOT_HELD):
	    hrStatus       = E_ACCESSDENIED;
	    bStatusUpdated = TRUE;
	    break;


	case HRESULT_FROM_WIN32 (ERROR_TIMEOUT):
	case HRESULT_FROM_WIN32 (ERROR_PATH_NOT_FOUND):
	case HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND):
	case HRESULT_FROM_WIN32 (ERROR_NOT_READY):

	default:
	    hrStatus       = E_UNEXPECTED;
	    bStatusUpdated = TRUE;
	    break;
	}


    return (hrStatus);
    } /* ClassifyShimFailure () */

/*
**++
**
**  Routine Description:
**
**	Routine to classify the many assorted internal shim or shim
**	writer errors into one of the narrow set of responses we are
**	permitted to send back to the requestor.
**
**	The determination is made to classify either as a shim error
**	or as a writer error based upon whether or not a writer name
**	is supplied. If it is supplied then the assumption is made
**	that this is a writer failure and so the error is classified
**	accordingly.
**
**	Note that this is a worker routine for the LogFailure() macro
**	and the two are intended to be used in concert.
**
**
**  Arguments:
**
**	pft			Pointer to a Function trace class
**	pwszNameWriter		The name of the applicable writer or NULL or L""
**	pwszNameCalledRoutine	The name of the routine that returned the failure status
**
**
**  Side Effects:
**
**	hr field of *pft updated 
**
**
**  Return Value:
**
**	One of the following list depending upon the supplied status.
**
**		E_OUTOFMEMORY
**		E_ACCESSDENIED
**		E_INVALIDARG
**		E_UNEXPECTED
**		VSS_E_BAD_STATE
**		VSS_E_SNAPSHOT_SET_IN_PROGRESS
**		VSS_E_WRITERERROR_OUTOFRESOURCES
**		VSS_E_WRITERERROR_RETRYABLE
**		VSS_E_WRITERERROR_NONRETRYABLE
**		VSS_E_WRITERERROR_TIMEOUT
**		VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT
**
**--
*/

HRESULT LogFailureWorker (CVssFunctionTracer	*pft,
			  LPCWSTR		 pwszNameWriter,
			  LPCWSTR		 pwszNameCalledRoutine)
    {
    if (pft->HrFailed ())
	{
	BOOL	bStatusRemapped;
	HRESULT	hrStatusClassified = ((NULL == pwszNameWriter) || (L'\0' == pwszNameWriter [0])) 
						? ClassifyShimFailure   (pft->hr, bStatusRemapped)
						: ClassifyWriterFailure (pft->hr, bStatusRemapped);

	if (bStatusRemapped)
	    {
	    if (((NULL == pwszNameCalledRoutine) || (L'\0' == pwszNameCalledRoutine [0])) &&
		((NULL == pwszNameWriter)        || (L'\0' == pwszNameWriter [0])))
		{
		pft->LogError (VSS_ERROR_SHIM_GENERAL_FAILURE,
			       VSSDBG_SHIM << pft->hr << hrStatusClassified);

		pft->Trace (VSSDBG_SHIM, 
			    L"FAILED with status 0x%08lX (converted to 0x%08lX)",
			    pft->hr,
			    hrStatusClassified);
		}


	    else if ((NULL == pwszNameCalledRoutine) || (L'\0' == pwszNameCalledRoutine [0]))
		{
		pft->LogError (VSS_ERROR_SHIM_WRITER_GENERAL_FAILURE,
			       VSSDBG_SHIM << pft->hr << hrStatusClassified << pwszNameWriter);

		pft->Trace (VSSDBG_SHIM, 
			    L"FAILED in writer %s with status 0x%08lX (converted to 0x%08lX)",
			    pwszNameWriter,
			    pft->hr,
			    hrStatusClassified);
		}


	    else if ((NULL == pwszNameWriter) || (L'\0' == pwszNameWriter [0]))
		{
		pft->LogError (VSS_ERROR_SHIM_FAILED_SYSTEM_CALL,
			       VSSDBG_SHIM << pft->hr << hrStatusClassified <<  pwszNameCalledRoutine);

		pft->Trace (VSSDBG_SHIM, 
			    L"FAILED calling routine %s with status 0x%08lX (converted to 0x%08lX)",
			    pwszNameCalledRoutine,
			    pft->hr,
			    hrStatusClassified);
		}


	    else
		{
		pft->LogError (VSS_ERROR_SHIM_WRITER_FAILED_SYSTEM_CALL,
			       VSSDBG_SHIM << pft->hr << hrStatusClassified << pwszNameWriter << pwszNameCalledRoutine);

		pft->Trace (VSSDBG_SHIM, 
			    L"FAILED in writer %s calling routine %s with status 0x%08lX (converted to 0x%08lX)",
			    pwszNameWriter,
			    pwszNameCalledRoutine,
			    pft->hr,
			    hrStatusClassified);
		}

	    pft->hr = hrStatusClassified;
	    }
	}


    return (pft->hr);
    } /* LogFailureWorker () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrdefs.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrdefs.h

Abstract:

    Definitions for snapshot shim writers

Author:

    Stefan R. Steiner   [ssteiner]        01-31-2000

Revision History:

	X-10	MCJ		Michael C. Johnson		21-Sep-2000
		185047: Need to distinguish Thaw event from Abort events.

	X-9	MCJ		Michael C. Johnson		 8-Aug-2000
		153807: Replace CleanDirectory() and EmptyDirectory() with a 
		        more comprehensive directory tree cleanup routine
			RemoveDirectoryTree() (not in CShimWriter class).

	X-8	MCJ		Michael C. Johnson		12-Jun-2000
		Have the shim writers reposnd to OnIdentify events from the 
		snapshot coordinator. This requies splitting the shim writers 
		into two groups (selected by BootableState)

	X-7	MCJ		Michael C. Johnson		 6-Jun-2000
		Add method CShimWriter::CreateTargetPath() to aid in moving
		common target directory processing to method 
		CShimWriter::PrepareForSnapshot()

	X-6	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-5	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-4	MCJ		Michael C. Johnson		18-Feb-2000
		Added ConfigDir writer to the writers function table.

	X-3	MCJ		Michael C. Johnson		09-Feb-2000
		Added Registry and Event log writers to the writers
		function table.

	X-2	MCJ		Michael C. Johnson		08-Feb-2000
		Added IIS Metabase writer to the writers function
		table.

--*/

#ifndef __H_WRTRDEFS_
#define __H_WRTRDEFS_

#pragma once

#ifdef  __cplusplus
extern "C" {
#endif


/*
** Possible state to put a shim writer into. If this is changed you
** MUST change the state table manipulated by CShimWriter::SetState()
*/
typedef enum _ShimWriterState
    {
     stateUnknown = 0
    ,stateStarting
    ,stateStarted
    ,statePreparingForSnapshot
    ,statePreparedForSnapshot
    ,stateFreezing
    ,stateFrozen
    ,stateThawing
    ,stateAborting
    ,stateThawed
    ,stateFinishing
    ,stateFinished
    ,stateMaximumValue
    } SHIMWRITERSTATE;



class CShimWriter
    {
public:
    CShimWriter (LPCWSTR pwszApplicationString);
    CShimWriter (LPCWSTR pwszApplicationString, BOOL bParticipateInBootableState);
    CShimWriter (LPCWSTR pwszApplicationString, LPCWSTR pwszTargetPath);
    CShimWriter (LPCWSTR pwszApplicationString, LPCWSTR pwszTargetPath, BOOL bParticipateInBootableState);

    virtual ~CShimWriter (VOID);

    HRESULT Startup  (void);
    HRESULT Shutdown (void);

    HRESULT Identify (IN IVssCreateWriterMetadata *pIVssCreateWriterMetadata);

    HRESULT PrepareForSnapshot (
				IN BOOL     bBootableStateBackup,
				IN ULONG    ulVolumeCount,
				IN LPCWSTR *ppwszVolumeNamesList);

    HRESULT Freeze ();
    HRESULT Thaw   ();
    HRESULT Abort  ();

private:
    HRESULT SetState (SHIMWRITERSTATE ssNewWriterState, HRESULT hrNewStatus);
    LPCWSTR GetStringFromStateCode (SHIMWRITERSTATE ssStateCode);


    /*
    ** These DoXxxx() are the routines that an individual writer may
    ** choose to over-ride.
    */
    virtual HRESULT DoStartup            (void);
    virtual HRESULT DoIdentify           (void);
    virtual HRESULT DoPrepareForBackup   (void);
    virtual HRESULT DoPrepareForSnapshot (void);
    virtual HRESULT DoFreeze             (void);
    virtual HRESULT DoThaw               (void);
    virtual HRESULT DoAbort              (void);
    virtual HRESULT DoBackupComplete     (void);
    virtual HRESULT DoShutdown           (void);


public:
    const BOOL			 m_bBootableStateWriter;
    const LPCWSTR		 m_pwszWriterName;

protected:
    const LPCWSTR		 m_pwszTargetPath;
    SHIMWRITERSTATE		 m_ssCurrentState;
    HRESULT			 m_hrStatus;
    BOOL			 m_bParticipateInBackup;
    ULONG			 m_ulVolumeCount;
    LPCWSTR			*m_ppwszVolumeNamesArray;
    IVssCreateWriterMetadata	*m_pIVssCreateWriterMetadata;
    IVssWriterComponents	*m_pIVssWriterComponents;
    };


typedef CShimWriter *PCShimWriter;



} // extern "C"

#endif // __H_WRTRDEFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\common.h ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrcomdb.cpp | Implementation of SnapshotWriter for COM+ Registration Database



Author:

    Michael C. Johnson [mikejohn] 03-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-15	MCJ		Michael C. Johnson		18-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-14	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of Bootable (aka System) state directories
		        and add one for Service state
		        Added new variations of StringCreateFromExpandedString()
		        StringInitialise() and StringCreateFromString() 
		153807: Replace CleanDirectory() and EmptyDirectory() with a 
		        more comprehensive directory tree cleanup routine
			RemoveDirectoryTree().

	X-13	MCJ		Michael C. Johnson		19-Jun-2000
		Apply code review comments.
			Remove ANSI version of StringXxxx() routines.
			Remove VsGetVolumeNameFromPath()
			Remove VsCheckPathAgainstVolumeNameList()
			Remove CheckShimPrivileges()

	X-12	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-11	MCJ		Michael C. Johnson		15-May-2000
		108586: Add CheckShimPrivileges() to check for the privs we 
		        require to invoke the public shim routines.

	X-10	MCJ		Michael C. Johnson		23-Mar-2000
		Add routines MoveFilesInDirectory() and EmptyDirectory()

	X-9	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-8	MCJ		Michael C. Johnson		 6-Mar-2000
		Add VsServiceChangeState () which should deal with all the
		service states that we are interested in.

	X-7	MCJ		Michael C. Johnson		29-Feb-2000
		Add macro to determine error code associated with termination
		of a filescan loop.

	X-6	MCJ		Michael C. Johnson		23-Feb-2000
		Add common context manipulation routines including state
		tracking and checking.

	X-5	MCJ		Michael C. Johnson		22-Feb-2000
		Add definition of SYSTEM_STATE_SUBDIR to allow further
		separation of writers involved in system state related
		backups.

	X-4	MCJ		Michael C. Johnson		17-Feb-2000
		Move definition of ROOT_BACKUP_DIR here from common.cpp

	X-3	MCJ		Michael C. Johnson		11-Feb-2000
		Added additional StringXxxx () routines and routines to
		turn on backup priviledges and restore priviledges.

	X-2	MCJ		Michael C. Johnson		08-Feb-2000
		Added a declaration of CommonCloseHandle().

	X-1	MCJ		Michael C. Johnson		03-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.


--*/



#ifndef __H_COMMON_
#define __H_COMMON_

#pragma once


typedef PBYTE	*PPBYTE;
typedef	ULONG64	 FILEID,   *PFILEID;
typedef	DWORD	 VOLUMEID, *PVOLUMEID;
typedef	DWORD	 THREADID, *PTHREADID;
typedef PTCHAR	*PPTCHAR;
typedef PWCHAR	*PPWCHAR;
typedef PVOID	*PPVOID;

typedef VSS_ID	*PVSS_ID, **PPVSS_ID;




#define ROOT_BACKUP_DIR		L"%SystemRoot%\\Repair\\Backup"
#define BOOTABLE_STATE_SUBDIR	L"\\BootableSystemState"
#define SERVICE_STATE_SUBDIR	L"\\ServiceState"




/*
** In a number of places we need a buffer into which to fetch registry
** values. Define a common buffer size for the mini writers to use
*/
#ifndef REGISTRY_BUFFER_SIZE
#define REGISTRY_BUFFER_SIZE	(4096)
#endif

#ifndef MAX_VOLUMENAME_LENGTH
#define MAX_VOLUMENAME_LENGTH	(50)
#endif

#ifndef MAX_VOLUMENAME_SIZE
#define MAX_VOLUMENAME_SIZE	(MAX_VOLUMENAME_LENGTH * sizeof (WCHAR))
#endif

#ifndef DIR_SEP_STRING
#define DIR_SEP_STRING		L"\\"
#endif

#ifndef DIR_SEP_CHAR
#define DIR_SEP_CHAR		L'\\'
#endif


#ifndef UMIN
#define UMIN(_P1, _P2) (((_P1) < (_P2)) ? (_P1) : (_P2))
#endif


#ifndef UMAX
#define UMAX(_P1, _P2) (((_P1) > (_P2)) ? (_P1) : (_P2))
#endif


#define HandleInvalid(_Handle)			((NULL == (_Handle)) || (INVALID_HANDLE_VALUE == (_Handle)))

#define	GET_STATUS_FROM_BOOL(_bSucceeded)	((_bSucceeded)             ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_HANDLE(_handle)		((!HandleInvalid(_handle)) ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_POINTER(_ptr)		((NULL != (_ptr))          ? NOERROR : E_OUTOFMEMORY)

#define GET_STATUS_FROM_FILESCAN(_bMoreFiles)	((_bMoreFiles)					\
						 ? NOERROR 					\
						 : ((ERROR_NO_MORE_FILES == GetLastError())	\
						    ? NOERROR					\
						    : HRESULT_FROM_WIN32 (GetLastError())))


#define ROUNDUP(_value, _boundary) (((_value) + (_boundary) - 1) & ( ~((_boundary) - 1)))


#define NameIsDotOrDotDot(_ptszName)	(( '.'  == (_ptszName) [0]) &&					\
					 (('\0' == (_ptszName) [1]) || (('.'  == (_ptszName) [1]) && 	\
									('\0' == (_ptszName) [2]))))


#define DeclareStaticUnicodeString(_StringName, _StringValue)								\
				static UNICODE_STRING (_StringName) = {sizeof (_StringValue) - sizeof (UNICODE_NULL),	\
								       sizeof (_StringValue),				\
								       _StringValue}


#define RETURN_VALUE_IF_REQUIRED(_Ptr, _Value) {if (NULL != (_Ptr)) *(_Ptr) = (_Value);}

#define SIZEOF_ARRAY(_aBase)	               (sizeof (_aBase) / sizeof ((_aBase)[0]))




HRESULT StringInitialise                  (PUNICODE_STRING pucsString);
HRESULT StringInitialise                  (PUNICODE_STRING pucsString, PWCHAR pwszString);
HRESULT StringInitialise                  (PUNICODE_STRING pucsString, LPCWSTR pwszString);
HRESULT StringTruncate                    (PUNICODE_STRING pucsString, USHORT usSizeInChars);
HRESULT StringSetLength                   (PUNICODE_STRING pucsString);
HRESULT StringAllocate                    (PUNICODE_STRING pucsString, USHORT usMaximumStringLengthInBytes);
HRESULT StringFree                        (PUNICODE_STRING pucsString);
HRESULT StringCreateFromString            (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString);
HRESULT StringCreateFromString            (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString, DWORD dwExtraChars);
HRESULT StringCreateFromString            (PUNICODE_STRING pucsNewString, LPCWSTR         pwszOriginalString);
HRESULT StringCreateFromString            (PUNICODE_STRING pucsNewString, LPCWSTR         pwszOriginalString, DWORD dwExtraChars);
HRESULT StringAppendString                (PUNICODE_STRING pucsTarget,    PUNICODE_STRING pucsSource);
HRESULT StringAppendString                (PUNICODE_STRING pucsTarget,    PWCHAR          pwszSource);
HRESULT StringCreateFromExpandedString    (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString);
HRESULT StringCreateFromExpandedString    (PUNICODE_STRING pucsNewString, PUNICODE_STRING pucsOriginalString, DWORD dwExtraChars);
HRESULT StringCreateFromExpandedString    (PUNICODE_STRING pucsNewString, LPCWSTR         pwszOriginalString);
HRESULT StringCreateFromExpandedString    (PUNICODE_STRING pucsNewString, LPCWSTR         pwszOriginalString, DWORD dwExtraChars);

HRESULT CommonCloseHandle                 (PHANDLE phHandle);


HRESULT VsServiceChangeState (IN  LPCWSTR pwszServiceName, 
			      IN  DWORD   dwRequestedState, 
			      OUT PDWORD  pdwReturnedOldState,
			      OUT PBOOL   pbReturnedStateChanged);

BOOL VsCreateDirectories (IN LPCWSTR               pwszPathName, 
			  IN LPSECURITY_ATTRIBUTES lpSecurityAttribute,
			  IN DWORD                 dwExtraAttributes);

HRESULT RemoveDirectoryTree (PUNICODE_STRING pucsDirectoryPath);

HRESULT MoveFilesInDirectory (PUNICODE_STRING pucsSourceDirectoryPath,
			      PUNICODE_STRING pucsTargetDirectoryPath);


HRESULT IsPathInVolumeArray (IN LPCWSTR      pwszPath,
			     IN const ULONG  ulVolumeCount,
			     IN LPCWSTR     *ppwszVolumeNamesArray,
			     OUT PBOOL       pbReturnedFoundInVolumeArray);


const HRESULT ClassifyShimFailure   (HRESULT hrShimFailure);
const HRESULT ClassifyShimFailure   (HRESULT hrShimFailure, BOOL &bStatusUpdated);
const HRESULT ClassifyWriterFailure (HRESULT hrWriterFailure);
const HRESULT ClassifyWriterFailure (HRESULT hrWriterFailure, BOOL &bStatusUpdated);



HRESULT LogFailureWorker (CVssFunctionTracer	*pft,
			  LPCWSTR		 pwszNameWriter,
			  LPCWSTR		 pwszNameCalledRoutine);


#define LogFailure(_pft, _hrStatus, _hrStatusRemapped, _pwszNameWriter, _pwszNameCalledRoutine, _pwszNameCallingRoutine)				\
		{																	\
		if (FAILED (_hrStatus))															\
		    {																	\
		    if (CVssFunctionTracer  *_pftLocal = (NULL != (_pft)) ? (_pft) : new CVssFunctionTracer (VSSDBG_SHIM, (_pwszNameCallingRoutine)))	\
				{															\
    		    _pftLocal->hr = (_hrStatus);													\
    																			\
    		    (_hrStatusRemapped) = LogFailureWorker (_pftLocal, (_pwszNameWriter), (_pwszNameCalledRoutine));					\
    																			\
    		    if (NULL == (_pft)) delete _pftLocal;												\
	    	    }                                                               \
		    }																	\
		}


#define LogAndThrowOnFailure(_ft, _pwszNameWriter, _pwszNameFailedRoutine)									\
			{															\
			HRESULT		_hrStatusRemapped;											\
																		\
			if (FAILED ((_ft).hr))													\
			    {															\
			    LogFailure (&(_ft), (_ft).hr, _hrStatusRemapped, (_pwszNameWriter), (_pwszNameFailedRoutine), L"(UNKNOWN)");	\
																		\
			    throw (_hrStatusRemapped);												\
			    }															\
			}



#endif // __H_COMMON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrci.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrci.cpp

Abstract:

    Writer shim module for Ci

Author:

    Stefan R. Steiner   [ssteiner]        02-08-2000

Revision History:

	X-8	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-7	MCJ		Michael C. Johnson		18-Jul-2000
		143435: Change name of target path

	X-6	MCJ		Michael C. Johnson		18-Jul-2000
		144027: Add an exclude list which covers the CI indices.

	X-5	MCJ		Michael C. Johnson		19-Jun-2000
		Apply code review comments.

	X-4	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-3	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-2	MCJ		Michael C. Johnson		 7-Mar-2000
		Instead of stopping the CI service, just pause it. This will
		allow queries to continue but stop updates until we continue
		it.

--*/

#include "stdafx.h"

#include "wrtrdefs.h"
#include "common.h"
#include <winsvc.h>

#pragma warning(disable:4100)

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHCIC"
//
////////////////////////////////////////////////////////////////////////


#define APPLICATION_STRING		L"ContentIndexingService"
#define COMPONENT_NAME			L"Content Indexing Service"

#define	CI_CATALOG_LIST_KEY		L"SYSTEM\\CurrentControlset\\Control\\ContentIndex\\Catalogs"
#define CI_CATALOG_VALUENAME_LOCATION	L"Location"

#define CATALOG_BUFFER_SIZE		(4096)

DeclareStaticUnicodeString (ucsIndexSubDirectoryName, L"\\catalog.wci");


/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterCI : public CShimWriter
    {
public:
    CShimWriterCI (LPCWSTR pwszWriterName) : 
		CShimWriter (pwszWriterName), 
		m_dwPreviousServiceState(0),
		m_bStateChangeOutstanding(FALSE) {};


private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    HRESULT DoThaw (VOID);
    HRESULT DoShutdown (VOID);

    DWORD m_dwPreviousServiceState;
    BOOL  m_bStateChangeOutstanding;
    };


static CShimWriterCI ShimWriterCI (APPLICATION_STRING);

PCShimWriter pShimWriterCI = &ShimWriterCI;



/*
**++
**
** Routine Description:
**
**	The Cluster database snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterCI::DoIdentify ()
    {
    HRESULT		hrStatus;
    DWORD		winStatus;
    DWORD		dwIndex                    = 0;
    HKEY		hkeyCatalogList            = NULL;
    BOOL		bCatalogListKeyOpened      = FALSE;
    BOOL		bContinueCatalogListSearch = TRUE;
    UNICODE_STRING	ucsValueData;
    UNICODE_STRING	ucsSubkeyName;


    StringInitialise (&ucsValueData);
    StringInitialise (&ucsSubkeyName);


    hrStatus = StringAllocate (&ucsSubkeyName, CATALOG_BUFFER_SIZE * sizeof (WCHAR));

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, CATALOG_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							      NULL,
							      COMPONENT_NAME,
							      COMPONENT_NAME,
							      NULL, // icon
							      0,
							      true,
							      false,
							      false);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"IVssCreateWriterMetadata::AddComponent", 
		    L"CShimWriterCI::DoIdentify");
	}



    if (SUCCEEDED (hrStatus))
	{
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   CI_CATALOG_LIST_KEY,
				   0L,
				   KEY_READ,
				   &hkeyCatalogList);

	hrStatus = HRESULT_FROM_WIN32 (winStatus); 

	bCatalogListKeyOpened = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (catalog list)", 
		    L"CShimWriterCI::DoIdentify");
	}



    while (SUCCEEDED (hrStatus) && bContinueCatalogListSearch)
	{
	HKEY	hkeyCatalogName    = NULL;
 	DWORD	dwSubkeyNameLength = ucsSubkeyName.MaximumLength / sizeof (WCHAR);


	StringTruncate (&ucsSubkeyName, 0);

	winStatus = RegEnumKeyExW (hkeyCatalogList,
				   dwIndex,
				   ucsSubkeyName.Buffer,
				   &dwSubkeyNameLength,
				   NULL,
				   NULL,
				   NULL,
				   NULL);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);


	if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hrStatus)
	    {
	    hrStatus = NOERROR;

	    bContinueCatalogListSearch = FALSE;
	    }

	else if (FAILED (hrStatus))
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegEnumKeyExW", 
			L"CShimWriterCI::DoIdentify");
	    }

	else
	    {
	    ucsSubkeyName.Length = (USHORT)(dwSubkeyNameLength * sizeof (WCHAR));

	    ucsSubkeyName.Buffer [ucsSubkeyName.Length / sizeof (WCHAR)] = UNICODE_NULL;


	    winStatus = RegOpenKeyExW (hkeyCatalogList,
				       ucsSubkeyName.Buffer,
				       0L,
				       KEY_QUERY_VALUE,
				       &hkeyCatalogName);

	    hrStatus = HRESULT_FROM_WIN32 (winStatus);

	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegOpenKeyExW (catalog value)", 
			L"CShimWriterCI::DoIdentify");


	    if (SUCCEEDED (hrStatus))
		{
		DWORD	dwValueDataLength = ucsValueData.MaximumLength;
		DWORD	dwValueType       = REG_NONE;


		StringTruncate (&ucsValueData, 0);

		winStatus = RegQueryValueExW (hkeyCatalogName,
					      CI_CATALOG_VALUENAME_LOCATION,
					      NULL,
					      &dwValueType,
					      (PBYTE)ucsValueData.Buffer,
					      &dwValueDataLength);

		hrStatus = HRESULT_FROM_WIN32 (winStatus);

		LogFailure (NULL, 
			    hrStatus, 
			    hrStatus, 
			    m_pwszWriterName, 
			    L"RegQueryValueExW", 
			    L"CShimWriterCI::DoIdentify");



		if (SUCCEEDED (hrStatus) && (REG_SZ == dwValueType))
		    {
		    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

		    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;

		    StringAppendString (&ucsValueData, &ucsIndexSubDirectoryName);


		    hrStatus = m_pIVssCreateWriterMetadata->AddExcludeFiles (ucsValueData.Buffer,
									     L"*",
									     true);

		    LogFailure (NULL, 
				hrStatus, 
				hrStatus, 
				m_pwszWriterName, 
				L"IVssCreateWriterMetadata::AddExcludeFiles", 
				L"CShimWriterCI::DoIdentify");
		    }

		RegCloseKey (hkeyCatalogName);
		}




	    /*
	    ** Done with this value so go look for another.
	    */
	    dwIndex++;
	    }
	}



    if (bCatalogListKeyOpened)
	{
	RegCloseKey (hkeyCatalogList);
	}



    StringFree (&ucsValueData);
    StringFree (&ucsSubkeyName);

    return (hrStatus);
    } /* CShimWriterCI::DoIdentify () */


/*++

Routine Description:

    The CI writer PrepareForSnapshot function.  Currently all of the
    real work for this writer happens here. Pause the service if we can.

Arguments:

    Same arguments as those passed in the PrepareForSnapshot event.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterCI::DoPrepareForSnapshot ()
    {
    HRESULT hrStatus = VsServiceChangeState (L"cisvc",
					     SERVICE_PAUSED,
					     &m_dwPreviousServiceState,
					     &m_bStateChangeOutstanding);

    m_bParticipateInBackup = m_bStateChangeOutstanding;

    LogFailure (NULL, 
		hrStatus, 
		hrStatus, 
		m_pwszWriterName, 
		L"VsServiceChangeState", 
		L"CShimWriterCI::DoPrepareForSnapshot");


    return (hrStatus);
    } /* CShimWriterCI::DoPrepareForSnapshot () */



/*++

Routine Description:

    The CI writer Thaw function.  Return the service to 
    state in which we found it.

Arguments:

    Same arguments as those passed in the Thaw event.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterCI::DoThaw ()
    {
    HRESULT hrStatus = NOERROR;

    if (m_bStateChangeOutstanding)
	{
	hrStatus = VsServiceChangeState (L"cisvc",
					 m_dwPreviousServiceState,
					 NULL,
					 NULL);

	m_bStateChangeOutstanding = FAILED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"VsServiceChangeState", 
		    L"CShimWriterCI::DoThaw/DoAbort");

	}


    return (hrStatus);
    } /* CShimWriterCI::DoThaw () */



/*++

Routine Description:

    The CI writer Shutdown function.  Return the service to state in
    which we found it. We do our level best to put things back the way
    they were even if this writer has previously failed but only if we
    originally changed the state.

Arguments:

    None.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterCI::DoShutdown ()
    {
    HRESULT hrStatus = NOERROR;

    if (m_bStateChangeOutstanding)
	{
	hrStatus = VsServiceChangeState (L"cisvc",
					 m_dwPreviousServiceState,
					 NULL,
					 NULL);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"VsServiceChangeState", 
		    L"CShimWriterCI::DoShutdown");

	}


    return (hrStatus);
    } /* CShimWriterCI::DoShutdown () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\vswriter\vswrtimp.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module VsWrtImp.cpp | Implementation of Writer
    @end

Author:

    Adi Oltean  [aoltean]  02/02/2000

TBD:
    
    Add comments.

    Remove the C++ exception-handler related code.

Revision History:

    Name        Date        Comments
    aoltean     02/02/2000  Created
    brianb      03/25/2000  modified to include additional events
    brianb      03/28/2000  modified to include timeouts and sync for OnPrepareBackup
    brianb      03/28/2000  renamed to vswrtimp.cpp to separate internal state from external interface
    brianb      04/19/2000  added security checks
    brianb      05/03/2000  new security model
    brianb      05/09/2000  fix problem with autolocks

--*/


#include <stdafx.hxx>
#include <eventsys.h>
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "vs_idl.hxx"
#include "vscoordint.h"
#include "comadmin.hxx"
#include "vsevent.h"
#include "vswriter.h"
#include "vsbackup.h"
#include "vssmsg.h"

#include "vswrtimp.h"


// xml support
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"



#include "rpcdce.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WRTWRTIC"
//
////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// Constants


const WCHAR g_wszPublisherID[]          = L"VSS Publisher";

// event names
const WCHAR g_wszRequestInfoMethodName[]        = L"RequestWriterInfo";
const WCHAR g_wszPrepareForBackupMethodName[]   = L"PrepareForBackup";
const WCHAR g_wszBackupCompleteMethodName[]     = L"BackupComplete";

const WCHAR g_wszPrepareForSnapshotMethodName[] = L"PrepareForSnapshot";
const WCHAR g_wszFreezeMethodName[]             = L"Freeze";
const WCHAR g_wszThawMethodName[]               = L"Thaw";
const WCHAR g_wszPostSnapshotMethodName[]       = L"PostSnapshot";
const WCHAR g_wszAbortMethodName[]              = L"Abort";

const WCHAR g_wszPreRestoreMethodName[]         = L"PreRestore";
const WCHAR g_wszPostRestoreMethodName[]        = L"PostRestore";

// List of received volumes is in the following formatDate
// <Volume Name 1>;<Volume Name 2>: ... :<Volume Name N>
const WCHAR VSS_VOLUME_DELIMITERS[] = L";";

// class describing state machine for writer
class CVssWriterImplStateMachine
    {
private:
    // disable default and copy constructors        
    CVssWriterImplStateMachine();

public:
    CVssWriterImplStateMachine
        (
        VSS_WRITER_STATE previousState,
        VSS_WRITER_STATE successfulExitState,
        VSS_WRITER_STATE failureExitState,
        bool bBeginningState,
        bool bSuccessiveState,
        bool bResetSequenceOnLeave
        ) :
        m_previousState(previousState),
        m_successfulExitState(successfulExitState),
        m_failureExitState(failureExitState),
        m_bBeginningState(bBeginningState),
        m_bSuccessiveState(bSuccessiveState),
        m_bResetSequenceOnLeave(bResetSequenceOnLeave)
        {
        }

    // previous state writer must be in to enter the current
    // state unless this is the first state of a sequence
    VSS_WRITER_STATE m_previousState;

    // state we are in if the operation is successful
    VSS_WRITER_STATE m_successfulExitState;

    // state we are in if the operation is uncessful
    VSS_WRITER_STATE m_failureExitState;

    // is this state a possible state for the beginning of the sequence
    bool m_bBeginningState;

    // is this a possible non-beginning state in a sequence
    bool m_bSuccessiveState;

    // should the sequence be reset on successful exit of the state
    bool m_bResetSequenceOnLeave;
    };


// definition of state machine
static CVssWriterImplStateMachine s_rgWriterStates[] =
    {
    // OnPrepareBackup
    CVssWriterImplStateMachine
        (
        VSS_WS_STABLE,                      // previous state
        VSS_WS_STABLE,                      // next state if successful
        VSS_WS_FAILED_AT_PREPARE_BACKUP,    // next state if failure
        true,                               // this can be a first state
        false,                              // this must be a first state
        false                               // do not reset sequence on leaving this state
        ),

    // OnPrepareSnapshot
    CVssWriterImplStateMachine
        (
        VSS_WS_STABLE,                      // previous state
        VSS_WS_WAITING_FOR_FREEZE,          // next state if successful
        VSS_WS_FAILED_AT_PREPARE_SNAPSHOT,  // next state if failure
        true,                               // this can be a first state
        true,                               // this can be a follow on state
        false                               // do not reset sequence on leaving this state
        ),


    // OnFreeze
    CVssWriterImplStateMachine
        (
        VSS_WS_WAITING_FOR_FREEZE,          // previous state
        VSS_WS_WAITING_FOR_THAW,            // next state if successful
        VSS_WS_FAILED_AT_FREEZE,            // next state if unsuccessful
        false,                              // this may not be a first state
        true,                               // this must be a follow on state
        false                               // do not reset sequence on leaving this state
        ),

    // OnThaw
    CVssWriterImplStateMachine
        (
        VSS_WS_WAITING_FOR_THAW,            // previous state
        VSS_WS_WAITING_FOR_POST_SNAPSHOT,   // next state if successful
        VSS_WS_FAILED_AT_THAW,              // next state if unsuccessful
        false,                              // this may not be a first state
        true,                               // this must be a follow on state   
        false                               // reset sequence on leaving this state
        ),

    // OnPostSnapshot
    CVssWriterImplStateMachine
        (
        VSS_WS_WAITING_FOR_POST_SNAPSHOT,   // previous state
        VSS_WS_WAITING_FOR_BACKUP_COMPLETE, // next state if successful
        VSS_WS_FAILED_AT_POST_SNAPSHOT,     // next state if unsuccessful
        false,                              // this may not be a first state
        true,                               // this must be a follow on state   
        true                                // reset sequence on leaving this state
        )


    };

// state ids
static const unsigned s_ivwsmPrepareForBackup = 0;
static const unsigned s_ivwsmPrepareForSnapshot = 1;
static const unsigned s_ivwsmFreeze = 2;
static const unsigned s_ivwsmThaw = 3;
static const unsigned s_ivwsmPostSnapshot = 4;



/////////////////////////////////////////////////////////////////////////////
// CVssWriterImpl constructors/destructors


// constructor
CVssWriterImpl::CVssWriterImpl():
    m_WriterID(GUID_NULL),
    m_InstanceID(GUID_NULL),
    m_usage(VSS_UT_UNDEFINED),
    m_source(VSS_ST_UNDEFINED),
    m_nLevel(VSS_APP_FRONT_END),
    m_dwTimeoutFreeze(VSS_TIMEOUT_FREEZE),
    m_CurrentSnapshotSetId(GUID_NULL),
    m_nVolumesCount(0),
    m_ppwszVolumesArray(NULL),
    m_pwszLocalVolumeNameList(NULL),
    m_dwEventMask(0),
    m_wszWriterName(NULL),
    m_hevtTimerThread(NULL),
    m_hmtxTimerThread(NULL),
    m_hThreadTimerThread(NULL),
    m_bLocked(false),
    m_bLockCreated(false),
    m_command(VSS_TC_UNDEFINED),
    m_cbstrSubscriptionId(0),
    m_bOnAbortPermitted(false),
    m_bSequenceInProgress(false)
    {
    }

// destructor
CVssWriterImpl::~CVssWriterImpl()
    {
    // terminate timer thread if it is still running
    if (m_bLockCreated)
        {
        Lock();
        TerminateTimerThread();
        Unlock();
        }

    // delete volume array
    delete[] m_ppwszVolumesArray;

    // delete volume list string
    ::VssFreeString(m_pwszLocalVolumeNameList);
    

    // delete writer name
    free(m_wszWriterName);


    if (m_hevtTimerThread)
        CloseHandle(m_hevtTimerThread);

    if (m_hmtxTimerThread)
        CloseHandle(m_hmtxTimerThread);
    }


// create an event
void CVssWriterImpl::SetupEvent(IN HANDLE *phevt)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImple::SetupEvent");

    BS_ASSERT(phevt);
    // setup events as enabled and manual reset
    *phevt = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (*phevt == NULL)
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Failure to create event object due to error %d.",
            GetLastError()
            );
    }

const WCHAR SETUP_KEY[] = L"SYSTEM\\Setup";

const WCHAR SETUP_INPROGRESS_REG[]  = L"SystemSetupInProgress";

const WCHAR UPGRADE_INPROGRESS_REG[] = L"UpgradeInProgress";


// initialize writer object
void CVssWriterImpl::Initialize
    (
    IN VSS_ID WriterID,             // writer class id
    IN LPCWSTR wszWriterName,       // friendly name of writer  
    IN VSS_USAGE_TYPE usage,        // usage type   
    IN VSS_SOURCE_TYPE source,      // data source type
    IN VSS_APPLICATION_LEVEL nLevel, // which freeze event this writer handles
    IN DWORD dwTimeoutFreeze         // timeout between freeze and thaw
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::Initialize");

        {
        // determine if we are in setup.  If we are then reject the
        // initialize call and log an error in the application log
        CRegKey cRegKeySetup;
        DWORD dwRes;
        bool fInSetup = false;

        dwRes = cRegKeySetup.Create(HKEY_LOCAL_MACHINE, SETUP_KEY);
        if (dwRes == ERROR_SUCCESS)
            {
            DWORD dwValue;
            dwRes = cRegKeySetup.QueryValue(dwValue, SETUP_INPROGRESS_REG);
            if (dwRes == ERROR_SUCCESS && dwValue > 0)
                fInSetup = true;
            dwRes = cRegKeySetup.QueryValue(dwValue, UPGRADE_INPROGRESS_REG);
            if (dwRes == ERROR_SUCCESS && dwValue > 0)
                fInSetup = true;
            }

        if (fInSetup)
            ft.Throw(VSSDBG_WRITER, VSS_E_BAD_STATE, L"Calling Initialize during setup");
        }

    // Testing arguments validity
    if (wszWriterName == NULL)
        ft.Throw
            (
            VSSDBG_WRITER,
            E_INVALIDARG,
            L"NULL writer name"
            );
    
    switch(nLevel) {
    case VSS_APP_SYSTEM:
    case VSS_APP_BACK_END:
    case VSS_APP_FRONT_END:
        break;
    default:
        ft.Throw
            (
            VSSDBG_WRITER,
            E_INVALIDARG,
            L"Invalid app level %d", nLevel
            );
    }

    m_cs.Init();  // Warning - may throw NT exceptions...
    m_bLockCreated = true;

    // initialize writer state
    m_writerstate.Initialize();

    // save writer class id
    m_WriterID = WriterID;

    // save writer name
    m_wszWriterName = _wcsdup(wszWriterName);
    if (m_wszWriterName == NULL)
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Cannot allocate writer name"
            );

    // save usage type
    m_usage = usage;

    // save source type
    m_source = source;

    // create guid for this instance
    ft.hr = ::CoCreateGuid(&m_InstanceID);
    ft.CheckForError(VSSDBG_WRITER, L"CoCreateGuid");
    ft.Trace
        (
        VSSDBG_WRITER,
        L"     InstanceId for Writer %s is" WSTR_GUID_FMT,
        m_wszWriterName,
        GUID_PRINTF_ARG(m_InstanceID)
        );

    // save app level
    m_nLevel = nLevel;

    // save timeout
    m_dwTimeoutFreeze = dwTimeoutFreeze;

    // setup thread mutex
    m_hmtxTimerThread = CreateMutex(NULL, FALSE, NULL);
    if (m_hmtxTimerThread == NULL)
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Failure to create mutex object due to error %d.",
            GetLastError()
            );

    // setup event used to control the timer thread
    SetupEvent(&m_hevtTimerThread);
    }


// start a sequence
// critical section (m_cs) must be locked upone entry to this routine
void CVssWriterImpl::BeginSequence
    (
    IN CVssID &SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::BeginSequence");

    AssertLocked();

    // terminate timer thread if it is still operating
    TerminateTimerThread();

    // setup current snapshot set id
    m_CurrentSnapshotSetId = SnapshotSetId;

    BS_ASSERT(m_bOnAbortPermitted == false);

    // initialize writer state for this snapshot set
    m_writerstate.InitializeCurrentState(SnapshotSetId);

    // indicate we are currently in a snapshot sequence.
    m_bSequenceInProgress = true;
    }





//  Reset the sequence-related data members
// critical section must be locked prior to entering this state
void CVssWriterImpl::ResetSequence(bool bCalledFromTimerThread)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::ResetSequence");

    AssertLocked();

    // save current state to stack of previous snapshot set states
    m_writerstate.PushCurrentState();

    // indicate we are no longer within a sequence
    m_bSequenceInProgress = false;

    // abort is no longer permitted
    m_bOnAbortPermitted = false;

    // reset writer callback function
    m_pWriterCallback = NULL;

    // reset volumes array
    m_nVolumesCount = 0;
    delete[] m_ppwszVolumesArray;
    m_ppwszVolumesArray = NULL;

    ::VssFreeString(m_pwszLocalVolumeNameList);
    
    m_CurrentSnapshotSetId = GUID_NULL;

    // if bCalledFromTimerThread is true, this means that the timer
    // thread is causing the sequence to be reset.  We are in the timer
    // thread already and it will terminate upon completion of this call
    // so we shouldn't try causing it to terminate again.
    if (!bCalledFromTimerThread)
        TerminateTimerThread();

    }

// indicate why the writer failed
HRESULT CVssWriterImpl::SetWriterFailure(HRESULT hr)
    {
    // validate failure is one that is allowed
    if (hr != VSS_E_WRITERERROR_TIMEOUT &&
        hr != VSS_E_WRITERERROR_RETRYABLE &&
        hr != VSS_E_WRITERERROR_NONRETRYABLE &&
        hr != VSS_E_WRITERERROR_OUTOFRESOURCES &&
        hr != VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT)
        return E_INVALIDARG;

    // set failure
    m_writerstate.SetCurrentFailure(hr);
    return S_OK;
    }



// determine if path specified is on one of the volumes that is snapshot
bool CVssWriterImpl::IsPathAffected
    (
    IN  LPCWSTR wszPath
    ) const
    {
    // Test the status
    if (!m_bSequenceInProgress)
        return false;

    // check for empty volume count
    if (m_nVolumesCount == 0)
        return false;

    // Get the volume mount point
    WCHAR wszVolumeMP[MAX_PATH];
    BOOL bRes = ::GetVolumePathNameW(wszPath, wszVolumeMP, MAX_PATH);
    if (!bRes)
        return false;

    // Get the volume name
    WCHAR wszVolumeName[MAX_PATH];
    bRes = ::GetVolumeNameForVolumeMountPointW(wszVolumeMP, wszVolumeName, MAX_PATH);
    if (!bRes)
        return false;

    // Search to see if that volume is within snapshotted volumes
    for (int nIndex = 0; nIndex < m_nVolumesCount; nIndex++)
        {
        BS_ASSERT(m_ppwszVolumesArray[nIndex]);
        if (::wcscmp(wszVolumeName, m_ppwszVolumesArray[nIndex]) == 0)
            return true;
        }

    return false;
    }


// obtain IVssWriterCallback from IDispatch pointer
// caller is responsible for releasing interface that is returned
void CVssWriterImpl::GetCallback
	(
	IN IDispatch *pWriterCallback,
	OUT IVssWriterCallback **ppCallback,
	IN BOOL bAllowImpersonate
	)
	{
	CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::GetCallback");

    // check that pointer is supplied
    BS_ASSERT(pWriterCallback != NULL);

	// try QueryInterface for IVssWriterCallback interface
	ft.hr = pWriterCallback->SafeQI(IVssWriterCallback, ppCallback);
	if (FAILED(ft.hr))
		{
		if (m_writerstate.GetCurrentFailure() == S_OK)
			m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

        ft.LogError(VSS_ERROR_QI_IVSSWRITERCALLBACK, VSSDBG_WRITER << ft.hr);
        ft.Throw
            (
            VSSDBG_WRITER,
            E_UNEXPECTED,
            L"Error querying for IVssWriterCallback interface.  hr = 0x%08lx",
            ft.hr
            );
        }

    if ( !bAllowImpersonate )
    {
    	ft.hr = CoSetProxyBlanket
    				(
    				*ppCallback,
    				RPC_C_AUTHN_DEFAULT,
    				RPC_C_AUTHZ_DEFAULT,
    				NULL,
    				RPC_C_AUTHN_LEVEL_CONNECT,
    				RPC_C_IMP_LEVEL_IDENTIFY,
    				NULL,
    				EOAC_NONE
    				);

        // note E_NOINTERFACE means that the pWriterCallback is a in-proc callback
    	// and there is no proxy
        if (FAILED(ft.hr) && ft.hr != E_NOINTERFACE)
    		{
    		if (m_writerstate.GetCurrentFailure() == S_OK)
    			m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

    		ft.LogError(VSS_ERROR_BLANKET_FAILED, VSSDBG_WRITER << ft.hr);
    		ft.Throw
    			(
    			VSSDBG_WRITER,
    			E_UNEXPECTED,
    			L"Call to CoSetProxyBlanket failed.  hr = 0x%08lx", ft.hr
    			);
            }
        }
	}

// create basic writer metadata for OnIdentify method
CVssCreateWriterMetadata *CVssWriterImpl::CreateBasicWriterMetadata()
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::CreateBasicWriterMetadata");

    // create object supporting IVssCreateMetadata interface
    CVssCreateWriterMetadata *pMetadata = new CVssCreateWriterMetadata;
    if (pMetadata == NULL)
        {
        // indicate we failed due to an out of resources failure
        m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Cannot create CVssCreateWriterMetadata due to allocation failure."
            );
        }


    // call initialize to create IDENTIFICATION section
    ft.hr = pMetadata->Initialize
                    (
                    m_InstanceID,
                    m_WriterID,
                    m_wszWriterName,
                    m_usage,
                    m_source
                    );

    if (ft.HrFailed())
        {
        // indicate that we failed due to an out of resources failure
        m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
        delete pMetadata;
        ft.Throw
            (
            VSSDBG_WRITER,
            ft.hr,
            L"CVssCreateWriterMetadata::Initialize failed. hr = 0x%08lx",
            ft.hr
            );
        }


    // return object
    return pMetadata;
    }

static LPCWSTR x_wszElementRoot = L"root";
static LPCWSTR x_wszElementWriterComponents = L"WRITER_COMPONENTS";

// get writer components for OnPrepareBackup, OnBackupComplete, and OnPostRestore
// methods
void CVssWriterImpl::InternalGetWriterComponents
    (
    IN IVssWriterCallback *pCallback,
    OUT IVssWriterComponentsInt **ppWriter,
    IN bool bWriteable
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::InternalGetWriterComponents");

    BS_ASSERT(pCallback);
    BS_ASSERT(ppWriter);

    *ppWriter = NULL;

    // call GetContent callback method on the backup application
    CComBSTR bstrId(m_InstanceID);
    if (!bstrId)
        {
        // indicate we failed due to an out of resources failure
        m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Cannot allocate instance Id string"
            );
        }

    try
        {
        ft.hr = pCallback->GetBackupState
            (
            &m_bComponentsSelected,
            &m_bBootableSystemStateBackup,
            &m_backupType,
            &m_bPartialFileSupport
            );
        }
    catch(...)
        {
        ft.Trace(VSSDBG_WRITER, L"IVssWriterCallback::GetBackupState threw an exception.");
        throw;
        }

    if (ft.HrFailed())
        {
        // if GetBackupState failed assumed that it might work if the
        // backup is retried.
        m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
        ft.Throw
            (
            VSSDBG_WRITER,
            ft.hr,
            L"IVssWriterCallback::GetBackupState failed.  hr = 0x%08lx",
            ft.hr
            );
        }


    CComBSTR bstrWriterComponentsDoc;
    try
        {
        ft.hr = pCallback->GetContent(bstrId, &bstrWriterComponentsDoc);
        }
    catch(...)
        {
        // if GetContent threw assume that the backup application is broken
        // the backup should not be retried
        m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);
        ft.Trace(VSSDBG_WRITER, L"IVssWriterCallback::GetContent threw an exception.");
        throw;
        }

    if (ft.HrFailed())
        {
        // if GetContent failed assume that the backup might work if
        // the backup was retried
        m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
        ft.Throw
            (
            VSSDBG_WRITER,
            ft.hr,
            L"Cannot get WRITER_COMPONENTS document.  hr = 0x%08lx",
            ft.hr
            );
        }

    if (ft.hr == S_FALSE)
        {
        // reset status code
        ft.hr = S_OK;
        *ppWriter = (IVssWriterComponentsInt *) new CVssNULLWriterComponents
                                (
                                m_InstanceID,
                                m_WriterID
                                );

        if (*ppWriter == NULL)
            {
            // indicate that the writer failed due to an out of resources condition
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            ft.Throw (VSSDBG_WRITER, E_OUTOFMEMORY, L"Can't allocate CVssWriterComponents object");
            }

        (*ppWriter)->AddRef();
        }

    else
        {
        CXMLDocument doc;
        if (!doc.LoadFromXML(bstrWriterComponentsDoc) ||
            !doc.FindElement(x_wszElementRoot, true))
            {
            // if the XML document is not valid then assume that the backup
            // application is broken.  The backup should not be retried.

            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            ft.LogError(VSS_ERROR_WRITER_COMPONENTS_CORRUPT, VSSDBG_WRITER);
            ft.Throw
                (
                VSSDBG_WRITER,
                VSS_E_CORRUPT_XML_DOCUMENT,
                L"Internally transferred WRITER_COMPONENTS document is invalid"
                );
            }

        doc.SetToplevel();

        *ppWriter = (IVssWriterComponentsInt *)
                        new CVssWriterComponents
                            (
                            doc.GetCurrentNode(),
                            doc.GetInterface(),
                            bWriteable,
                            false,
                            m_writerstate.IsInRestore()
                            );

        if (*ppWriter == NULL)
            {
            // indicate that the writer failed due to an out of resources condition
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            ft.Throw (VSSDBG_WRITER, E_OUTOFMEMORY, L"Can't allocate CVssWriterComponents object");
            }

        (*ppWriter)->AddRef();
        ft.hr = (*ppWriter)->Initialize(true);
        if (ft.HrFailed())
            {
            // if Initialize failed, assume that the failure is due to an
            // out of resources conditition.
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            (*ppWriter)->Release();
            *ppWriter = NULL;
            ft.Throw
                (
                VSSDBG_WRITER,
                ft.hr,
                L"Failed to initialize WRITER_COMPONENTS document.  hr = 0x%08lx",
                ft.hr
                );
            }
        }
    }
    

// called when entering a state to verify whether this state can be
// validly entered and generate appropriate error if not.
// this routine always obtains the critical section.  If this routine
// is called then LeaveState must also be called in order to free the
// critical section.
bool CVssWriterImpl::EnterState
    (
    IN const CVssWriterImplStateMachine &vwsm,
    IN BSTR bstrSnapshotSetId
    ) throw(HRESULT)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::EnterState");

    CVssID id;

    // obtain lock just in case next call throws
    // no matter how this routine exits, the critical section must be locked
    Lock();

    // initialize id to snapshot set id
    id.Initialize(ft, (LPWSTR)bstrSnapshotSetId, E_OUTOFMEMORY);

    // If failed on Identify then we cannot enter in a new state until
    // subsequent Identify calls will succeed
    if (m_writerstate.GetFailedAtIdentify())
        return false;

    if (!m_bSequenceInProgress)
        {
        if (!vwsm.m_bBeginningState)
            // not a beginning state.  Sequence must have been
            // interrupted.
            return false;
        else
            {
            // BUG 219757 - PrepareForSnapshot, etc. cannot be
            // called for the same Snapshot Set if PrepareForBackup failed
            // Also we assume here that each new sequence have an UNIQUE SSID.

            // This check is needed since the PrepareForBackup phase is optional
            // and can be skipped sometimes. Therefore we need to distinguish between
            // the case when PrepareForBackup was skipped and the case when PrepareForBackup
            // was called and failed.

            // Search for a previous sequence with the same Snapshot Set ID.
            // If found (this means that a PrepareForBackup was called),
            // then reject the call.
            if (m_writerstate.IsSnapshotSetIdValid(id))
                return false;
            
            // it is a beginning state, start the sequence
            BeginSequence(id);
            return true;
            }
        }
    else
        {
        if (vwsm.m_bSuccessiveState)
            {
            // it is a valid non-beginning state in the sequence
            if (id != m_CurrentSnapshotSetId)
                {
                // if snapshot set id doesn't match and this is not
                // a beginning state, then the event must be ignored.
                // We must have aborted the sequence it references.
                if (!vwsm.m_bBeginningState)
                    return false;
                }
            else
                {
                // make sure current state matches previous state
                // of state we are about to enter
                return m_writerstate.GetCurrentState() == vwsm.m_previousState;
                }
            }
        }

    // We are trying to start a new sequence.
    // This means that the previous sequence was not properly
    // terminated.  Abort the previous sequence and then
    // start a new one.
    ft.Trace(VSSDBG_WRITER,
        L"*** Warning ***: Writer %s with ID "WSTR_GUID_FMT
        L"attempts to reset the previous sequence with Snapshot Set ID "WSTR_GUID_FMT
        L". Current state = %d",
        m_wszWriterName, GUID_PRINTF_ARG(m_InstanceID), GUID_PRINTF_ARG(m_CurrentSnapshotSetId), (INT)m_writerstate.GetCurrentState());

    DoAbort(false);
    BeginSequence(id);
    return true;
    }

// do abort on failure of the sequence
// critical section must be locked prior to entering this state
void CVssWriterImpl::DoAbort
    (
    IN bool bCalledFromTimerThread
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::DoAbort");

    AssertLocked();
    // do nothing if in a sequence
    if (!m_bSequenceInProgress)
        return;

    BS_ASSERT(m_pWriter);

    // catch any exceptions so that we properly reset the
    // sequence
    try
        {
        // call writer's abort function (depending on the state)
        switch(m_writerstate.GetCurrentState())
            {
            default:
                BS_ASSERT(m_bOnAbortPermitted == false);
                break;
            case VSS_WS_STABLE:
                // This is possible since you may get an Abort
                // in (or after) PrepareForBackup (BUG # 301686)
                BS_ASSERT(m_bOnAbortPermitted == true);
                break;

            case VSS_WS_WAITING_FOR_FREEZE:
            case VSS_WS_WAITING_FOR_THAW:
            case VSS_WS_WAITING_FOR_BACKUP_COMPLETE:
            case VSS_WS_FAILED_AT_THAW:
            case VSS_WS_FAILED_AT_PREPARE_BACKUP:
            case VSS_WS_FAILED_AT_PREPARE_SNAPSHOT:
            case VSS_WS_FAILED_AT_FREEZE:
                // Fixing bug 225936
                if (m_bOnAbortPermitted)
                    m_pWriter->OnAbort();
                else
                    ft.Trace(VSSDBG_WRITER, L"Abort skipped in state %d", m_writerstate.GetCurrentState());
                m_bOnAbortPermitted = false;
                break;
            }
        }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ft.Trace
            (
            VSSDBG_WRITER,
            L"OnAbort failed. hr = 0x%08lx",
            ft.hr
            );

    // set appropriate failure state
    switch(m_writerstate.GetCurrentState())
        {
        default:
            m_writerstate.SetCurrentState(VSS_WS_UNKNOWN);
            BS_ASSERT(false);
            break;

        // This state is not really kept in the m_state member
        case VSS_WS_FAILED_AT_IDENTIFY:
            BS_ASSERT(false);
            break;

        case VSS_WS_FAILED_AT_PREPARE_BACKUP:
        case VSS_WS_FAILED_AT_PREPARE_SNAPSHOT:
        case VSS_WS_FAILED_AT_FREEZE:
        case VSS_WS_FAILED_AT_THAW:
            // don't change state if already in a failure state
            break;

        case VSS_WS_STABLE:
            // if current state is STABLE then it means
            // we were in PrepareBackup
            m_writerstate.SetCurrentState(VSS_WS_FAILED_AT_PREPARE_BACKUP);
            break;

        case VSS_WS_WAITING_FOR_FREEZE:
            // if we were waiting for freeze then we failed
            // between PrepareSync and Freeze
            m_writerstate.SetCurrentState(VSS_WS_FAILED_AT_PREPARE_SNAPSHOT);
            break;

        case VSS_WS_WAITING_FOR_THAW:
            // if we were waiting for thaw then we failed
            // between freeze and thaw
            m_writerstate.SetCurrentState(VSS_WS_FAILED_AT_FREEZE);
            break;

        case VSS_WS_WAITING_FOR_BACKUP_COMPLETE:
            // if we were waiting for completion then
            // we failed after thaw.
            m_writerstate.SetCurrentState(VSS_WS_FAILED_AT_THAW);
            break;
        }

    if (bCalledFromTimerThread && m_writerstate.GetCurrentFailure() == S_OK)
        m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_TIMEOUT);

    // reset sequence
    ResetSequence(bCalledFromTimerThread);
    }

// exit a state.  This routine must be called with the critical
// section acquired.  For a state, EnterState is called first, then work is
// done, then LeaveState is called.  This routine will set the state upon
// exit and possibly reset the snapshot sequence if we are at the end of the
// sequence or the sequence is aborted.
void CVssWriterImpl::LeaveState
    (
    IN const CVssWriterImplStateMachine &vwsm,  // current state
    IN bool bSucceeded                          // did operation succeed
    )
    {
    AssertLocked();

    m_writerstate.ExitOperation();

    // don't change state or call abort if we are not in a sequence
    if (m_bSequenceInProgress)
        {
        m_writerstate.SetCurrentState
            (bSucceeded ? vwsm.m_successfulExitState
                        : vwsm.m_failureExitState);

        // call abort on failure when we are not in the exit state
        if ((!bSucceeded || m_writerstate.GetCurrentFailure() == VSS_E_WRITER_NOT_RESPONDING) &&
            !vwsm.m_bResetSequenceOnLeave)
            DoAbort(false);                                                 
        else if (vwsm.m_bResetSequenceOnLeave)
            // if sequence ends at this state (THAW) then
            // reset variables
            ResetSequence(false);
        }

    Unlock();
    }
            


// arguments to timer function
class CVssTimerArgs
    {
private:
    CVssTimerArgs();

public:
    CVssTimerArgs(CVssWriterImpl *pWriter, VSS_ID id) :
        m_snapshotSetId(id),
        m_pWriter(pWriter)
        {
        }

    // snapshot set that we are monitoring
    VSS_ID m_snapshotSetId;

    // pointer to writer
    CVssWriterImpl *m_pWriter;
    };


// timer thread startup routine
DWORD CVssWriterImpl::StartTimerThread(void *pv)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::StartTimerThread");
    CVssTimerArgs *pArgs = (CVssTimerArgs *) pv;
    BS_ASSERT(pArgs);
    BS_ASSERT(pArgs->m_pWriter);

    bool bCoInitializeSucceeded = false;
    try
        {
        // coinitialize thread

        ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if (ft.HrFailed())
            {
            pArgs->m_pWriter->m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            ft.TranslateError
                (
                VSSDBG_WRITER,
                ft.hr,
                L"CoInitializeEx"
                );
            }

        bCoInitializeSucceeded = true;
        // call timer func
        pArgs->m_pWriter->TimerFunc(pArgs->m_snapshotSetId);
        }
    VSS_STANDARD_CATCH(ft)

    if (bCoInitializeSucceeded)
        CoUninitialize();

    // delete timer arguments
    delete pArgs;
    return 0;
    }



// function implementing timer functionality
void CVssWriterImpl::TimerFunc(VSS_ID snapshotSetId)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::TimerFunc");

    // wait on event to insure that only one timer is active at
    // any point in time
    if (WaitForSingleObject(m_hmtxTimerThread, INFINITE) == WAIT_FAILED)
        {
        DWORD dwErr = GetLastError();
        ft.Trace(VSSDBG_WRITER, L"WaitForSingleObject failed with error %d", dwErr);
        BS_ASSERT(FALSE && "WaitForSingleObject failed");
        }

    // reset timer event
    if (!ResetEvent(m_hevtTimerThread))
        {
        DWORD dwErr = GetLastError();
        ft.Trace(VSSDBG_WRITER, L"ResetEvent failed with error %d", dwErr);
        BS_ASSERT(FALSE && "ResetEvent failed");
        }

    Lock();
    // make sure that we are still in a snapshot sequence
    if (!m_bSequenceInProgress || snapshotSetId != GetCurrentSnapshotSetId())
        {
        // not in sequence, exit function
        Unlock();
        // allow another timer thread to start
        ReleaseMutex(m_hmtxTimerThread);
        return;
        }

    // initial command is to abort the current sequence on timeout
    m_command = VSS_TC_ABORT_CURRENT_SEQUENCE;

    Unlock();
    DWORD dwTimeout = m_dwTimeoutFreeze;

    if (WaitForSingleObject(m_hevtTimerThread, dwTimeout) == WAIT_FAILED)
        {
        ft.Trace
            (
            VSSDBG_WRITER,
            L"Wait in timer thread failed due to reason %d.",
            GetLastError()
            );

        // allow another thread to start
        ReleaseMutex(m_hmtxTimerThread);
        return;
        }

    CVssWriterImplLock lock(this);
    if (m_command != VSS_TC_TERMINATE_THREAD)
        {
        BS_ASSERT(m_command == VSS_TC_ABORT_CURRENT_SEQUENCE);

        // cause current sequence to abort
        ft.Trace(VSSDBG_WRITER, L"Aborting due to timeout\n");
        DoAbort(true);
        }

    // allow another timer thread to start
    ReleaseMutex(m_hmtxTimerThread);
    }



/////////////////////////////////////////////////////////////////////////////
// IVssWriter implementation


STDMETHODIMP CVssWriterImpl::RequestWriterInfo
    (
    IN      BSTR bstrSnapshotSetId,
    IN      BOOL bWriterMetadata,
    IN      BOOL bWriterState,
    IN      IDispatch* pWriterCallback      
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::RequestWriterInfo" );


    // created metadata, deleted on exit from routine
    CVssCreateWriterMetadata *pcwm = NULL;
    try
        {
        // validate that the flags make sense
        if (bWriterMetadata && bWriterState ||
            !bWriterMetadata && !bWriterState)
            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"Incorrect flags");

        // if we are requesting writer state then we must have a snapshot
        // set id
        if (bWriterState && bstrSnapshotSetId == NULL)
            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"NULL required input parameter.");

        if (pWriterCallback == NULL)
            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"NULL required input parameter.");

        if (!IsBackupOperator())
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"Backup Operator privileges are not set");

        if (bWriterMetadata)
            {
            // obtain writer metadata

            // MTA synchronization: The critical section will be left automatically at the end of scope.
            CVssWriterImplLock lock(this);

            // BUG 219757: The identify phase marked as failed
            m_writerstate.SetFailedAtIdentify(true);

            // indicate that we are in an operation
            m_writerstate.SetInOperation(VSS_IN_IDENTIFY);


            try
                {
                // get IVssWriterCallback interface
                CComPtr<IVssWriterCallback> pCallback;
                GetCallback(pWriterCallback, &pCallback);


                // create basic metadata using initialization parameters
                pcwm = CreateBasicWriterMetadata();

                // call writer's OnIdentify method to get more metadata
                BS_ASSERT(m_pWriter);
                bool bSucceeded;
                try
                    {
                    bSucceeded = m_pWriter->OnIdentify
                                    (
                                    (IVssCreateWriterMetadata *) pcwm
                                    );
                    }
                catch(...)
                    {
                    ft.Trace(VSSDBG_WRITER, L"Writer's OnIdentify method threw and exception.");
                    throw;
                    }

                if (!bSucceeded)
                    {
                    // indicate failure if writer fails OnIdentify
                    ft.Throw(VSSDBG_WRITER, S_FALSE, L"Writer's OnIdentify method returned false.");
                    }

                CComBSTR bstrXML;
                CComBSTR bstrInstanceId(m_InstanceID);
                CComBSTR bstrWriterId(m_WriterID);
                CComBSTR bstrWriterName(m_wszWriterName);
                if (!bstrInstanceId ||
                    !bstrWriterId ||
                    !bstrWriterName)
                    ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Couldn't allocate memory for ids or name");

                // save WRITER_METADATA document as XML string
                ft.hr = pcwm->SaveAsXML(&bstrXML);
                if (FAILED(ft.hr))
                    ft.Throw
                        (
                        VSSDBG_WRITER,
                        E_OUTOFMEMORY,
                        L"Cannot save XML document as string. hr = 0x%08lx",
                        ft.hr
                        );

                // callback through ExposeWriterMetadata method
                try
                    {
                    ft.hr = pCallback->ExposeWriterMetadata
                            (
                            bstrInstanceId,
                            bstrWriterId,
                            bstrWriterName,
                            bstrXML
                            );
                    }
                catch(...)
                    {
                    ft.Trace(VSSDBG_WRITER, L"IVssWriterCallback::ExposeWriterMetadata threw an exception.");
                    throw;
                    }
            
                // BUG 219757: The identify phase marked as succeeded.
                m_writerstate.SetFailedAtIdentify(false);
                }
            catch(...)
                {
                }

            m_writerstate.ExitOperation();
            }
        else
            {
            // get writer state

            CComBSTR bstrInstanceId(m_InstanceID);
            if (!bstrInstanceId)
                ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Couldn't allocate memory for ids or name");

            CVssID id;
            id.Initialize(ft, (LPCWSTR) bstrSnapshotSetId, E_INVALIDARG);

            // get IVssWriterCallback interface
            CComPtr<IVssWriterCallback> pCallback;
            GetCallback(pWriterCallback, &pCallback);

            VSWRITER_STATE state;
            bool bFailedAtIdentify;
_retry:
            m_writerstate.GetStateForSnapshot(id, state, bFailedAtIdentify);

            // BUG 219757 - deal with the Identify failures correctly.
            if (m_writerstate.GetFailedAtIdentify())
                state.m_state = VSS_WS_FAILED_AT_IDENTIFY;
            else if (state.m_bInOperation)
                {
                if (state.m_state != VSS_WS_FAILED_AT_PREPARE_BACKUP &&
                    state.m_state != VSS_WS_FAILED_AT_PREPARE_SNAPSHOT &&
                    state.m_state != VSS_WS_FAILED_AT_FREEZE &&
                    state.m_state != VSS_WS_FAILED_AT_THAW &&
                    state.m_state != VSS_WS_FAILED_AT_IDENTIFY)
                    {
                    state.m_hrWriterFailure = VSS_E_WRITER_NOT_RESPONDING;
                    switch(state.m_currentOperation)
                        {
                        default:
                            state.m_state = VSS_WS_UNKNOWN;
                            BS_ASSERT(false);
                            break;

                        case VSS_IN_PREPAREBACKUP:
                            state.m_state = VSS_WS_FAILED_AT_PREPARE_BACKUP;
                            break;

                        case VSS_IN_PREPARESNAPSHOT:
                            state.m_state = VSS_WS_FAILED_AT_PREPARE_SNAPSHOT;
                            break;

                        case VSS_IN_FREEZE:
                            state.m_state = VSS_WS_FAILED_AT_FREEZE;
                            break;

                        case VSS_IN_THAW:
                            state.m_state = VSS_WS_FAILED_AT_THAW;
                            break;

                        case VSS_IN_POSTSNAPSHOT:
                            state.m_state = VSS_WS_FAILED_AT_POST_SNAPSHOT;
                            break;
                            
                        case VSS_IN_BACKUPCOMPLETE:
                            state.m_state = VSS_WS_FAILED_AT_BACKUP_COMPLETE;
                            break;

                        case VSS_IN_PRERESTORE:
                            state.m_state = VSS_WS_FAILED_AT_PRE_RESTORE;
                            break;

                        case VSS_IN_POSTRESTORE:
                            state.m_state = VSS_WS_FAILED_AT_POST_RESTORE;
                            break;
                        }

                    if (!m_writerstate.SetNoResponseFailure(state))
                        goto _retry;
                    }
                }


            // call Backup's ExposeCurrentState callback method
            try
                {
                ft.hr = pCallback->ExposeCurrentState
                                (
                                bstrInstanceId,
                                state.m_state,
                                state.m_hrWriterFailure
                                );
                }
            catch(...)
                {
                ft.Trace(VSSDBG_WRITER, L"IVssWriterCallback::ExposeCurrentState threw an exception");
                throw;
                }
            }
        }
    VSS_STANDARD_CATCH(ft)

    delete pcwm;

    // Bug 255996
    return S_OK;
    }


// process PrepareForBackup event
STDMETHODIMP CVssWriterImpl::PrepareForBackup
    (
    IN      BSTR bstrSnapshotSetId,                 
    IN      IDispatch* pWriterCallback
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::PrepareForBackup" );

    try
        {
        ft.Trace(VSSDBG_WRITER, L"\nReceived Event: PrepareForBackup\nParameters:\n");
        ft.Trace(VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);

        if (pWriterCallback == NULL || bstrSnapshotSetId == NULL)
            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"NULL required input parameter.");


        // access check
        if (!IsBackupOperator())
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"Backup Operator privileges are not set");
            }

        // enter PrepareForBackup state
        if (!EnterState
                (
                s_rgWriterStates[s_ivwsmPrepareForBackup],
                bstrSnapshotSetId
                ))
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Couldn't properly begin sequence"
                );
            }


        AssertLocked();

        // indicate we are in an operation
        m_writerstate.SetInOperation(VSS_IN_PREPAREBACKUP);

        // get IVssWriterCallback interface
        CComPtr<IVssWriterCallback> pCallback;
        GetCallback(pWriterCallback, &pCallback);

        // get IVssWriterComponentsExt interface
        CComPtr<IVssWriterComponentsInt> pComponents;
        InternalGetWriterComponents(pCallback, &pComponents, true);

        BS_ASSERT(m_pWriter);

        // call writer's OnPrepareBackup method
        bool bResult;
        try
            {
            bResult = m_pWriter->OnPrepareBackup(pComponents);
            BS_ASSERT(m_bOnAbortPermitted == false);
            m_bOnAbortPermitted = true;
            }
        catch(...)
            {
            ft.Trace(VSSDBG_WRITER, L"Writer's OnPrepareBackup method threw an exception");
            if (m_writerstate.GetCurrentFailure() == S_OK)
                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

            throw;
            }

        if (!bResult)
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the preparebackup");


        // save changes to components if any
        if (pComponents)
            SaveChangedComponents(pCallback, pComponents);
        }
    VSS_STANDARD_CATCH(ft)

    // leave PrepareBackup state
    LeaveState(s_rgWriterStates[s_ivwsmPrepareForBackup], ft.HrSucceeded());

    // Bug 255996
    return S_OK;
    }


// if the writer components were changed, save them back to the requestor's
// XML document.
void CVssWriterImpl::SaveChangedComponents
    (
    IN IVssWriterCallback *pCallback,
    IN IVssWriterComponentsInt *pComponents
    )
    {
    CVssFunctionTracer ft(VSSDBG_XML, L"CVssWriterImpl::SaveChangedComponents");

    bool bChanged;

    // determine if components are changed
    ft.hr = pComponents->IsChanged(&bChanged);
    BS_ASSERT(ft.hr == S_OK);
    if (bChanged)
        {
        // get instance id
        CComBSTR bstrWriterInstanceId(m_InstanceID);
        if (!bstrWriterInstanceId)
            ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Couldn't allocate instance id string");

        // get WRITER_COMPONENTS XML document
        CComBSTR bstrWriterComponentsDocument;
        ft.hr = pComponents->SaveAsXML(&bstrWriterComponentsDocument);
        if (ft.HrFailed())
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_OUTOFMEMORY,
                L"Saving WRITER_COMPONENTS document as XML failed.  hr = 0x%08lx",
                ft.hr
                );
            }

        // callback to set component in BACKUP_COMPONENTS document
        try
            {
            ft.hr = pCallback->SetContent(bstrWriterInstanceId, bstrWriterComponentsDocument);
            }
        catch(...)
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
            ft.Trace(VSSDBG_WRITER, L"IVssWriterCallback::SetContent threw an exception.");
            throw;
            }

        if (ft.HrFailed() && m_writerstate.GetCurrentFailure() == S_OK)
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
            ft.Throw
                (
                VSSDBG_WRITER,
                ft.hr,
                L"IVssWriterCallback::SetContent failed.  hr = 0x%08lx",
                ft.hr
                );
            }
        }
    }


// process PrepareForSnapshot event
STDMETHODIMP CVssWriterImpl::PrepareForSnapshot
    (
    IN  BSTR    bstrSnapshotSetId,          // snapshot set id
    IN  BSTR    bstrVolumeNamesList         // list of volume names separated by ';'
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::PrepareForSnapshot" );

    try
        {
        ft.Trace(VSSDBG_WRITER, L"\nReceived Event: PrepareForSnapshot\nParameters:\n");
        ft.Trace(VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);
        ft.Trace(VSSDBG_WRITER, L"\tVolumeNamesList = %s\n", (LPWSTR)bstrVolumeNamesList);

        // should only be called by coordinator
        // check for admin privileges
        if (!IsAdministrator())
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"ADMIN privileges are not set");
            }

        // enter PrepareForSnapshot state
        if (!EnterState
                (
                s_rgWriterStates[s_ivwsmPrepareForSnapshot],
                bstrSnapshotSetId
                ))
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"improper state transition"
                );
            }

        AssertLocked();

        // indicate that we are in an operation
        m_writerstate.SetInOperation(VSS_IN_PREPARESNAPSHOT);

        // Get the array of volume names
        BS_ASSERT(m_pwszLocalVolumeNameList == NULL);
        ::VssSafeDuplicateStr(ft, m_pwszLocalVolumeNameList, (LPWSTR)bstrVolumeNamesList);

        // Get the number of volumes
        BS_ASSERT(m_nVolumesCount == 0);
        m_nVolumesCount = 0; // For safety
        LPWSTR pwszVolumesToBeParsed = m_pwszLocalVolumeNameList;

        // parse volume name string
        while(true)
            {
            // get pointer to next volume
            WCHAR* pwszNextVolume = ::wcstok(pwszVolumesToBeParsed, VSS_VOLUME_DELIMITERS);
            pwszVolumesToBeParsed = NULL;

            if (pwszNextVolume == NULL)
                // no more volumes
                break;

            // skip if volume name is empty
            if (pwszNextVolume[0] == L'\0')
                continue;

            // count of volumes
            m_nVolumesCount++;
            }

        // make sure there is at least one volume
        if (m_nVolumesCount == 0)
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
            ft.LogError(VSS_ERROR_EMPTY_SNAPSHOT_SET, VSSDBG_WRITER);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"No volumes in the snapshot set"
                );
            }
    
        // Allocate the array of pointers to volume names
        BS_ASSERT(m_nVolumesCount > 0);
        BS_ASSERT(m_ppwszVolumesArray == NULL);
        m_ppwszVolumesArray = new LPWSTR[m_nVolumesCount];
        if (m_ppwszVolumesArray == NULL)
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            ft.Throw( VSSDBG_WRITER, E_OUTOFMEMORY, L"Memory allocation error");
            }

        //
        // Copy the volume names into the array.
        //

        // re-copy the whole volume list
        ::wcscpy(m_pwszLocalVolumeNameList, (LPWSTR)bstrVolumeNamesList);

        // Fill the array by re-parsing the volume list.
        INT nVolumesIndex = 0;
        pwszVolumesToBeParsed = m_pwszLocalVolumeNameList;
        while(true)
            {
            WCHAR* pwszNextVolume = ::wcstok(pwszVolumesToBeParsed, VSS_VOLUME_DELIMITERS);
            pwszVolumesToBeParsed = NULL;

            if (pwszNextVolume == NULL)
                break;

            if (pwszNextVolume[0] == L'\0')
                continue;

            BS_ASSERT(nVolumesIndex < m_nVolumesCount);
            m_ppwszVolumesArray[nVolumesIndex] = pwszNextVolume;
            
            nVolumesIndex++;
            }

        BS_ASSERT(nVolumesIndex == m_nVolumesCount);

        // Call the writer's OnPrepareSnapshot method
        BS_ASSERT(m_pWriter);

        bool bResult;
        try
            {
            bResult = m_pWriter->OnPrepareSnapshot();
            m_bOnAbortPermitted = true;
            }
        catch(...)
            {
            if (m_writerstate.GetCurrentFailure() == S_OK)
                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            ft.Trace(VSSDBG_WRITER, L"Writer's OnPrepareSnapshot method threw an execption");
            throw;
            }

        if (!bResult)
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the prepare snapshot");
        }
    VSS_STANDARD_CATCH(ft)

    // leave PrepareSnapshot state
    LeaveState(s_rgWriterStates[s_ivwsmPrepareForSnapshot], ft.HrSucceeded());

    // Bug 255996
    return S_OK;
    }


// process freeze event
STDMETHODIMP CVssWriterImpl::Freeze
    (
    IN  BSTR    bstrSnapshotSetId,
    IN  INT     nLevel
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::Freeze" );

    try
        {
        ft.Trace( VSSDBG_WRITER, L"\nReceived Event: Freeze\nParameters:\n");
        ft.Trace( VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);
        ft.Trace( VSSDBG_WRITER, L"\tLevel = %d\n", nLevel);
        
        // should only be called by the coordinator, access check for admin privileges
        if (!IsAdministrator())
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"ADMIN privileges are not set");

        // Ignore other Levels
        if (m_nLevel != nLevel)
            return S_OK;

        // enter freeze state
        if (!EnterState
                (
                s_rgWriterStates[s_ivwsmFreeze],
                bstrSnapshotSetId
                ))
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Improper entry into state"
                );
            }

        AssertLocked();

        // indicate that we are in an operation
        m_writerstate.SetInOperation(VSS_IN_FREEZE);

        // Call writer's OnFreeze
        BS_ASSERT(m_pWriter);

        bool bResult;
        try
            {
            bResult = m_pWriter->OnFreeze();
            BS_ASSERT(m_bOnAbortPermitted == true);
            }
        catch(...)
            {
            if (m_writerstate.GetCurrentFailure() == S_OK)
                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            ft.Trace(VSSDBG_WRITER, L"Writer's OnFreeze Method threw and exception");
            throw;
            }

        if (!bResult)
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the freeze");


        // setup arguments to timer thread
        CVssTimerArgs *pArgs = new CVssTimerArgs(this, m_CurrentSnapshotSetId);
        if (pArgs == NULL)
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_OUTOFMEMORY,
                L"Cannot create timer args due to allocation failure"
                );
            }

        DWORD tid;

        // create timer thread
        m_hThreadTimerThread =
            CreateThread
                (
                NULL,
                VSS_STACK_SIZE,
                &CVssWriterImpl::StartTimerThread,
                pArgs,
                0,
                &tid
                );

        if (m_hThreadTimerThread == NULL)
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_OUTOFRESOURCES);
            delete pArgs;
            ft.Throw
                (
                VSSDBG_WRITER,
                E_OUTOFMEMORY,
                L"Failure to create thread due to error %d.",
                GetLastError()
                );
           }
        }
    VSS_STANDARD_CATCH(ft)

    // leave OnFreeze state
    LeaveState( s_rgWriterStates[s_ivwsmFreeze], ft.HrSucceeded());

    // Bug 255996
    return S_OK;
    }


// handle IVssWriter::Thaw event
STDMETHODIMP CVssWriterImpl::Thaw
    (
    IN  BSTR    bstrSnapshotSetId
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::Thaw" );

    try
        {
        ft.Trace( VSSDBG_WRITER, L"\nReceived Event: Thaw\nParameters:\n");
        ft.Trace( VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);

        // should only be called by coordinator.  Access check for admin
        if (!IsAdministrator())
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"ADMIN privileges are not set");
            }


        // enter Thaw state
        if (!EnterState
                (
                s_rgWriterStates[s_ivwsmThaw],
                bstrSnapshotSetId
                ))
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Improper entry into state"
                );
            }


        // indicate that we are in an operation
        m_writerstate.SetInOperation(VSS_IN_THAW);

        AssertLocked();

        // terminate timer thread as we are about to thaw the operation
        TerminateTimerThread();

        // We should "live" in a sequence since Thaw is not the first phase of the sequence.
        BS_ASSERT(m_bSequenceInProgress);

        // Call writer's OnThaw
        BS_ASSERT(m_pWriter);

        bool bResult;
        try
            {
            bResult = m_pWriter->OnThaw();
            }
        catch(...)
            {
            if (m_writerstate.GetCurrentFailure() == S_OK)
                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

            ft.Trace(VSSDBG_WRITER, L"Writer's OnThaw method threw an exception");
            throw;
            }

        // throw veto if writer vetoes the event
        if (!bResult)
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the thaw");
        }
    VSS_STANDARD_CATCH(ft)

    // leave OnThaw state
    LeaveState(s_rgWriterStates[s_ivwsmThaw], ft.HrSucceeded());
    // Bug 255996
    return S_OK;
    }

// process PostSnapshot event
STDMETHODIMP CVssWriterImpl::PostSnapshot
    (
    IN      BSTR bstrSnapshotSetId,
    IN      IDispatch* pWriterCallback
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::PostSnapshot" );

    

    try
        {
        ft.Trace(VSSDBG_WRITER, L"\nReceived Event: PostSnapshot\nParameters:\n");
        ft.Trace(VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);

        if (pWriterCallback == NULL || bstrSnapshotSetId == NULL)
            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"NULL required input parameter.");

		// access check
		if (!IsAdministrator())
			{
			m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);
			ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"Backup Operator privileges are not set");
			}

        // enter PostSnapshot state
        if (!EnterState
                (
                s_rgWriterStates[s_ivwsmPostSnapshot],
                bstrSnapshotSetId
                ))
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_RETRYABLE);
            ft.Throw
                (
                VSSDBG_WRITER,
                E_UNEXPECTED,
                L"Couldn't properly begin sequence"
                );
            }


        AssertLocked();

        // indicate we are in an operation
        m_writerstate.SetInOperation(VSS_IN_POSTSNAPSHOT);

		// get IVssWriterCallback interface
		CComPtr<IVssWriterCallback> pCallback;
		
		//
		//  This is a special case where the writer calls VSS instead of
		//  the requestor.  In this case we have to allow impersonation.
		//
		GetCallback(pWriterCallback, &pCallback, TRUE);

        // get IVssWriterComponentsExt interface
        CComPtr<IVssWriterComponentsInt> pComponents;
        InternalGetWriterComponents(pCallback, &pComponents, true);

        BS_ASSERT(m_pWriter);

        // call writer's OnPostSnapshot method
        bool bResult;
        try
            {
            bResult = m_pWriter->OnPostSnapshot(pComponents);
            }
        catch(...)
            {
            ft.Trace(VSSDBG_WRITER, L"Writer's OnPostSnapshot method threw an exception");
            if (m_writerstate.GetCurrentFailure() == S_OK)
                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

            throw;
            }

        if (!bResult)
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the post Snapshot");

        // save changes to components if any
        if (pComponents)
            SaveChangedComponents(pCallback, pComponents);
        }
    VSS_STANDARD_CATCH(ft)

    // leave PostSnapshot state
    LeaveState(s_rgWriterStates[s_ivwsmPostSnapshot], ft.HrSucceeded());

    // Bug 255996
    return S_OK;
    }



// process backup complete event
STDMETHODIMP CVssWriterImpl::BackupComplete
    (
    IN      BSTR bstrSnapshotSetId,
    IN      IDispatch* pWriterCallback
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::BackupComplete" );

    // MTA synchronization: The critical section will be left automatically at the end of scope.
    CVssWriterImplLock lock(this);
    CVssID id;
    bool bIdInitialized = false;


    try
        {

        if (pWriterCallback == NULL || bstrSnapshotSetId == NULL)
            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"NULL required input parameter.");

        ft.Trace(VSSDBG_WRITER, L"\nReceived Event: OnBackupComplete\nParameters:\n");
        ft.Trace(VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);

        m_writerstate.SetInOperation(VSS_IN_BACKUPCOMPLETE);


        // access check
        if (!IsBackupOperator())
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"Backup Operator privileges are not set");
            }

        BS_ASSERT(!m_bSequenceInProgress);
        BS_ASSERT(m_CurrentSnapshotSetId == GUID_NULL);

        id.Initialize(ft, (LPCWSTR) bstrSnapshotSetId, E_INVALIDARG);
        bIdInitialized = true;

        m_writerstate.FinishBackupComplete(id);

        // get IVssWriterCallback interface
        CComPtr<IVssWriterCallback> pCallback;
        GetCallback(pWriterCallback, &pCallback);


        // get IVssWriterComponentsInt object
        CComPtr<IVssWriterComponentsInt> pComponents;
        InternalGetWriterComponents(pCallback, &pComponents, false);

        // call writer's OnBackupComplete method
        BS_ASSERT(m_pWriter);
        try
            {
            if (!m_pWriter->OnBackupComplete(pComponents))
                ft.hr = S_FALSE;
            }
        catch(...)
            {
            if (m_writerstate.GetCurrentFailure() == S_OK)
                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

            ft.Trace(VSSDBG_WRITER, L"Writer's OnBackupComplete method threw an exception.");
            throw;
            }

        if (ft.hr == S_FALSE)
            ft.Throw(VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the backup complete");
        }
    VSS_STANDARD_CATCH(ft)

    // indicate that sequence is complete
    if (m_writerstate.GetCurrentState() == VSS_WS_WAITING_FOR_BACKUP_COMPLETE)
        m_writerstate.SetCurrentState(VSS_WS_STABLE);

    m_writerstate.SetBackupCompleteStatus(id, ft.hr);

    m_writerstate.ExitOperation();
    
    // Bug 255996
    return S_OK;
    }


// handle IVssWriter::Abort event
STDMETHODIMP CVssWriterImpl::Abort
    (
    IN  BSTR    bstrSnapshotSetId
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::Abort" );

    ft.Trace( VSSDBG_WRITER, L"\nReceived Event: Abort\nParameters:\n");
    ft.Trace( VSSDBG_WRITER, L"\tSnapshotSetID = %s\n", (LPWSTR)bstrSnapshotSetId);

    if (!IsBackupOperator())
        ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"Backup privileges are not set");

    Lock();
    
    // call do abort function
    DoAbort(false);
    
    Unlock();

    return S_OK;
    }

// process prerestore event
STDMETHODIMP CVssWriterImpl::PreRestore
    (
    IN      IDispatch* pWriterCallback
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::PreRestore" );

    ft.Trace(VSSDBG_WRITER, L"\nReceived Event: PreRestore\n");

    // MTA synchronization: The critical section will be left automatically at the end of scope.
    CVssWriterImplLock lock(this);
    m_writerstate.SetInOperation(VSS_IN_PRERESTORE);
    m_writerstate.SetCurrentFailure(S_OK);

    try
        {
        if (pWriterCallback == NULL)
            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"NULL required input parameter.");

        // access check
        if (!IsRestoreOperator())
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"Backup Operator privileges are not set");
            }

        // get writer callback interface
        CComPtr<IVssWriterCallback> pCallback;
        GetCallback(pWriterCallback, &pCallback);
        CComPtr<IVssWriterComponentsInt> pComponents;

        // get IVssWriterComponentsInt object
        InternalGetWriterComponents(pCallback, &pComponents, true);

        // call writer's OnPreRestore method
        BS_ASSERT(m_pWriter);
        try
            {
            if (!m_pWriter->OnPreRestore(pComponents))
                ft.hr = S_FALSE;
            }
        catch(...)
            {
            if (m_writerstate.GetCurrentFailure() == S_OK)
                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

            ft.Trace(VSSDBG_WRITER, L"Writer's OnPreRestore method threw an exception");
            throw;
            }

        if (ft.hr == S_FALSE)
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the prerestore");

        if (pComponents)
            SaveChangedComponents(pCallback, pComponents);
        }
    VSS_STANDARD_CATCH(ft)

    if (FAILED(ft.hr))
        m_writerstate.SetCurrentState(VSS_WS_FAILED_AT_PRE_RESTORE);
    else
        m_writerstate.SetCurrentState(VSS_WS_STABLE);


    m_writerstate.ExitOperation();
    // Bug 255996
    return S_OK;
    }



// process post restore event
STDMETHODIMP CVssWriterImpl::PostRestore
    (
    IN      IDispatch* pWriterCallback
    )
    {
    CVssFunctionTracer ft( VSSDBG_WRITER, L"CVssWriterImpl::PostRestore" );

    ft.Trace(VSSDBG_WRITER, L"\nReceived Event: PostRestore\n");

    // MTA synchronization: The critical section will be left automatically at the end of scope.
    CVssWriterImplLock lock(this);
    m_writerstate.SetInOperation(VSS_IN_POSTRESTORE);
    m_writerstate.SetCurrentFailure(S_OK);

    try
        {
        if (pWriterCallback == NULL)
            ft.Throw(VSSDBG_WRITER, E_INVALIDARG, L"NULL required input parameter.");

        // access check
        if (!IsRestoreOperator())
            {
            m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);
            ft.Throw(VSSDBG_WRITER, E_ACCESSDENIED, L"Backup Operator privileges are not set");
            }

        // get writer callback interface
        CComPtr<IVssWriterCallback> pCallback;
        GetCallback(pWriterCallback, &pCallback);
        CComPtr<IVssWriterComponentsInt> pComponents;

        // get IVssWriterComponentsInt object
        InternalGetWriterComponents(pCallback, &pComponents, true);

        // call writer's OnPostRestore method
        BS_ASSERT(m_pWriter);
        try
            {
            if (!m_pWriter->OnPostRestore(pComponents))
                ft.hr = S_FALSE;
            }
        catch(...)
            {
            if (m_writerstate.GetCurrentFailure() == S_OK)
                m_writerstate.SetCurrentFailure(VSS_E_WRITERERROR_NONRETRYABLE);

            ft.Trace(VSSDBG_WRITER, L"Writer's OnPostRestore method threw an exception");
            throw;
            }

        if (ft.hr == S_FALSE)
            ft.Throw( VSSDBG_WRITER, E_UNEXPECTED, L"Writer rejected the postrestore");

        if (pComponents)
            SaveChangedComponents(pCallback, pComponents);
        }
    VSS_STANDARD_CATCH(ft)

    if (FAILED(ft.hr))
        m_writerstate.SetCurrentState(VSS_WS_FAILED_AT_POST_RESTORE);
    else
        m_writerstate.SetCurrentState(VSS_WS_STABLE);


    m_writerstate.ExitOperation();
    // Bug 255996
    return S_OK;
    }


// table of names of events that we are subscribing to
// NOTE: this table is based on definition of VSS_EVENT_MASK.  Each
// offset corresponds to a bit on that mask
const WCHAR *g_rgwszSubscriptions[] =
    {
    g_wszPrepareForBackupMethodName,        // VSS_EVENT_PREPAREBackup
    g_wszPrepareForSnapshotMethodName,      // VSS_EVENT_PREPARESnapshot
    g_wszFreezeMethodName,                  // VSS_EVENT_FREEZE
    g_wszThawMethodName,                    // VSS_EVENT_THAW
    g_wszPostSnapshotMethodName,            // VSS_EVENT_POST_SNAPSHOT
    g_wszAbortMethodName,                   // VSS_EVENT_ABORT
    g_wszBackupCompleteMethodName,          // VSS_EVENT_BACKUPCOMPLETE
    g_wszRequestInfoMethodName,             // VSS_EVENT_REQUESTINFO
    g_wszPreRestoreMethodName,              // VSS_EVENT_RESTORE
    g_wszPostRestoreMethodName              // VSS_EVENT_POST_RESTORE
    };


/////////////////////////////////////////////////////////////////////////////
//  Subscription-related members


// create subscriptions
void CVssWriterImpl::Subscribe()
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::Subscribe");

    // validate that caller can subscribe to the event
    if (!IsProcessBackupOperator() &&
        !IsProcessLocalService() &&
        !IsProcessNetworkService())
        ft.Throw
            (
            VSSDBG_WRITER,
            E_ACCESSDENIED,
            L"Caller is not either a backup operator, administrator, local service, or network service"
            );

    // currently we subscribe to all events
    m_dwEventMask = VSS_EVENT_ALL;

    if (m_bstrSubscriptionName.Length() > 0)
        ft.Throw
            (
            VSSDBG_XML,
            VSS_E_WRITER_ALREADY_SUBSCRIBED,
            L"The writer has already called the Subscribe function."
            );

    // create event system
    CComPtr<IEventSystem> pSystem;
    ft.hr = CoCreateInstance
                (
                CLSID_CEventSystem,
                NULL,
                CLSCTX_SERVER,
                IID_IEventSystem,
                (void **) &pSystem
                );

    ft.CheckForError(VSSDBG_WRITER, L"CoCreateInstance");
    CComBSTR bstrClassId = CLSID_VssEvent;
    CComBSTR bstrIID = IID_IVssWriter;
    CComBSTR bstrProgId = PROGID_EventSubscription;

    // see if event class already exists
    CComBSTR bstrQuery = "EventClassID == ";
    if (!bstrQuery)
        ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Cannot allocate BSTR.");

    bstrQuery.Append(bstrClassId);
    if (!bstrQuery)
        ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"Cannot allocate BSTR.");

    int location;
    CComPtr<IEventObjectCollection> pCollection;
    ft.hr = pSystem->Query
                (
                PROGID_EventClassCollection,
                bstrQuery,
                &location,
                (IUnknown **) &pCollection
                );

    ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Query");
    long cEvents;
    ft.hr = pCollection->get_Count(&cEvents);
    ft.CheckForError(VSSDBG_WRITER, L"IEventObjectCollection::get_Count");
    if (cEvents == 0)
        {
        // event class does not exist, create it.  Note that there is a
        // potential race condition here if two writers try creating the event
        // class at the same time.  We create the event class during installation
        // so that this should rarely happen
        CComPtr<IEventClass> pEvent;

        CComBSTR bstrEventClassName = L"VssEvent";
        WCHAR buf[MAX_PATH*2];

        // event class typelib
        UINT cwc = ExpandEnvironmentStrings
                        (
                        L"%systemroot%\\system32\\eventcls.dll",
                        buf,
                        sizeof(buf)/sizeof(WCHAR)
                        );

        if (cwc == 0)
            {
            ft.hr = HRESULT_FROM_WIN32(GetLastError());
            ft.CheckForError(VSSDBG_WRITER, L"ExpandEnvironmentStrings");
            }

        CComBSTR bstrTypelib = buf;

        // create event class
        ft.hr = CoCreateInstance
                    (
                    CLSID_CEventClass,
                    NULL,
                    CLSCTX_SERVER,
                    IID_IEventClass,
                    (void **) &pEvent
                    );

        ft.CheckForError(VSSDBG_WRITER, L"CoCreatInstance");

        // setup class id
        ft.hr = pEvent->put_EventClassID(bstrClassId);
        ft.CheckForError(VSSDBG_WRITER, L"IEventClass::put_EventClassID");

        // set up class name
        ft.hr = pEvent->put_EventClassName(bstrEventClassName);
        ft.CheckForError(VSSDBG_WRITER, L"IEventClass::put_EventClassName");

        // set up typelib
        ft.hr = pEvent->put_TypeLib(bstrTypelib);
        ft.CheckForError(VSSDBG_WRITER, L"IEventClass::put_TypeLib");

        // store event class
        ft.hr = pSystem->Store(PROGID_EventClass, pEvent);
        ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Store");
        }

    // create subscription id
    VSS_ID SubscriptionId;
    ft.hr = ::CoCreateGuid(&SubscriptionId);
    ft.CheckForError(VSSDBG_WRITER, L"CoCreateGuid");
    m_bstrSubscriptionName = SubscriptionId;

    // get IUnknown for subscribers class
    IUnknown *pUnkSubscriber = GetUnknown();
    UINT iwsz, mask;

    try
        {
        // loop through subscriptions
        for(mask = 1, iwsz = 0; mask < VSS_EVENT_ALL; mask = mask << 1, iwsz++)
            {
            if (m_dwEventMask & mask && g_rgwszSubscriptions[iwsz] != NULL)
                {
                // create IEventSubscription object
                CComPtr<IEventSubscription> pSubscription;
                ft.hr = CoCreateInstance
                            (
                            CLSID_CEventSubscription,
                            NULL,
                            CLSCTX_SERVER,
                            IID_IEventSubscription,
                            (void **) &pSubscription
                            );

                ft.CheckForError(VSSDBG_WRITER, L"CoCreateInstance");

                // set subscription name
                ft.hr = pSubscription->put_SubscriptionName(m_bstrSubscriptionName);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_SubscriptionName");

                // set event class id
                ft.hr = pSubscription->put_EventClassID(bstrClassId);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_EventClassID");

                // set interface id
                ft.hr = pSubscription->put_InterfaceID(bstrIID);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_InterfaceID");

                // set subcriber interface
                ft.hr = pSubscription->put_SubscriberInterface(pUnkSubscriber);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_SubscriberInterface");

                // make subscription per user since this is not necessarily in local system
                ft.hr = pSubscription->put_PerUser(TRUE);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_PerUser");

                // set method name for subscrpition
                ft.hr = pSubscription->put_MethodName(CComBSTR(g_rgwszSubscriptions[iwsz]));
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::put_MethodName");

                // setup InstanceId and WriterId subscription properties
                VARIANT varWriterId;
                VARIANT varInstanceId;

                CComBSTR bstrWriterId = m_WriterID;
                CComBSTR bstrInstanceId = m_InstanceID;

                varWriterId.vt = VT_BSTR;
                varWriterId.bstrVal = bstrWriterId;
                varInstanceId.vt = VT_BSTR;
                varInstanceId.bstrVal = bstrInstanceId;

                ft.hr = pSubscription->PutSubscriberProperty(L"WriterId", &varWriterId);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::PutSubscriberProperty");

                ft.hr = pSubscription->PutSubscriberProperty(L"WriterInstanceId", &varInstanceId);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::PutSubscriberProperty");

                // store subscription
                ft.hr = pSystem->Store(bstrProgId, pSubscription);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Store");

                // get constructed subscription id and save it
                ft.hr = pSubscription->get_SubscriptionID(&m_rgbstrSubscriptionId[m_cbstrSubscriptionId]);
                ft.CheckForError(VSSDBG_WRITER, L"IEventSubscription::get_SubscriptionID");

                // increment count of
                m_cbstrSubscriptionId++;
                }
            }
        }
    VSS_STANDARD_CATCH(ft)

    // if the operation fails with us partially subscribed, then unsubscribe
    if (ft.HrFailed() && m_cbstrSubscriptionId)
        {
        Unsubscribe();
        ft.Throw(VSSDBG_WRITER, ft.hr, L"Rethrowing exception");
        }
    }


// terminate timer thread
// assumes caller has the critical section locked
void CVssWriterImpl::TerminateTimerThread()
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::TerminateTimerThread");

    AssertLocked();
    if (m_hThreadTimerThread)
        {
        // cause timer thread to terminate
        m_command = VSS_TC_TERMINATE_THREAD;
        if (!SetEvent(m_hevtTimerThread))
            {
            DWORD dwErr = GetLastError();
            ft.Trace(VSSDBG_WRITER, L"SetEvent failed with error %d\n", dwErr);
            BS_ASSERT(FALSE && "SetEvent failed");
            }


        // get thread handle
        HANDLE hThread = m_hThreadTimerThread;
        m_hThreadTimerThread = NULL;

        // unlock during wait
        Unlock();
        if (WaitForSingleObject(hThread, INFINITE) == WAIT_FAILED)
            {
            DWORD dwErr = GetLastError();
            ft.Trace(VSSDBG_WRITER, L"WaitForSingleObject failed with error %d\n", dwErr);
            BS_ASSERT(FALSE && "WaitForSingleObject failed");
            }
            
        CloseHandle(hThread);
        Lock();
        }
    }


// unsubscribe this writer from IVssWriter events
void CVssWriterImpl::Unsubscribe()
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::Unsubscribe");

    // terminate timer thread if active
    Lock();
    TerminateTimerThread();
    Unlock();

    // make sure subscription name was assigned; if not assume subscriptions
    // weren't created
    if (m_bstrSubscriptionName.Length() == 0)
        return;

    // create event system
    CComPtr<IEventSystem> pSystem;
    ft.hr = CoCreateInstance
                (
                CLSID_CEventSystem,
                NULL,
                CLSCTX_SERVER,
                IID_IEventSystem,
                (void **) &pSystem
                );

    ft.CheckForError(VSSDBG_WRITER, L"CoCreateInstance");

#if 0
    WCHAR buf[256];
    int location;
    swprintf(buf, L"SubscriptionName = \"%s\"", m_bstrSubscriptionName);
    
    CComPtr<IEventObjectCollection> pCollection;
    
    ft.hr = pSystem->Query
        (
        PROGID_EventSubscriptionCollection,
        buf,
        &location,
        (IUnknown **) &pCollection
        );

    ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Query");

    long cSub;
    ft.hr = pCollection->get_Count(&cSub);
    ft.CheckForError(VSSDBG_WRITER, L"IEventObjectCollection::get_Count");
    pCollection = NULL;
#endif

    for(UINT iSubscription = 0; iSubscription < m_cbstrSubscriptionId; iSubscription++)
        {
        // setup query string
        CComBSTR bstrQuery = L"SubscriptionID == ";
        if (!bstrQuery)
            ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"allocation of BSTR failed");

        // if subscription exists, then remove it
        if (m_rgbstrSubscriptionId[iSubscription])
            {
            bstrQuery.Append(m_rgbstrSubscriptionId[iSubscription]);
            if (!bstrQuery)
                ft.Throw(VSSDBG_WRITER, E_OUTOFMEMORY, L"allocation of BSTR failed");

            int location;

            // remove subscription
            ft.hr = pSystem->Remove(PROGID_EventSubscription, bstrQuery, &location);
            ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Remove");

            // indicate that subscription was removed
            m_rgbstrSubscriptionId[iSubscription].Empty();
            }
        }
#if 0
    ft.hr = pSystem->Query
        (
        PROGID_EventSubscriptionCollection,
        buf,
        &location,
        (IUnknown **) &pCollection
        );

    ft.CheckForError(VSSDBG_WRITER, L"IEventSystem::Query");

    ft.hr = pCollection->get_Count(&cSub);
    ft.CheckForError(VSSDBG_WRITER, L"IEventObjectCollection::get_Count");
    pCollection = NULL;
#endif

    // reset subscription name so unsubscribe does nothing if called again
    m_bstrSubscriptionName.Empty();
    m_cbstrSubscriptionId = 0;
    }

// create a internal writer class and link it up to the external writer class
void CVssWriterImpl::CreateWriter
    (
    CVssWriter *pWriter,            // external writer
    IVssWriterImpl **ppImpl         // interface to be used by external writer
    )
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterImpl::CreateWriter");

    BS_ASSERT(ppImpl);
    BS_ASSERT(pWriter);

    *ppImpl = NULL;

    // create internal wrier class
    CComObject<CVssWriterImpl> *pImpl;
    // create CVssWriterImpl object <core writer class>
    ft.hr = CComObject<CVssWriterImpl>::CreateInstance(&pImpl);
    if (ft.HrFailed())
        ft.Throw
            (
            VSSDBG_WRITER,
            E_OUTOFMEMORY,
            L"Failed to create CVssWriterImpl.  hr = 0x%08lx",
            ft.hr
            );

    // set reference count of internal writer to 1
    pImpl->GetUnknown()->AddRef();

    // link external writer into internal writer
    pImpl->SetWriter(pWriter);

    // return internal writer interface
    *ppImpl = (IVssWriterImpl *) pImpl;
    }

// constructor for writer state
CVssWriterState::CVssWriterState() :
    m_iPreviousSnapshots(0),
    m_bFailedAtIdentify(false),
    m_bSequenceInProgress(false)
    {
    // initialize current state
    m_currentState.m_state = VSS_WS_STABLE;
    m_currentState.m_idSnapshotSet = GUID_NULL;
    m_currentState.m_bInOperation = false;
    m_currentState.m_hrWriterFailure = S_OK;

    // initialize stack
    for(UINT i = 0; i < MAX_PREVIOUS_SNAPSHOTS; i++)
        {
        m_rgPreviousStates[i].m_idSnapshotSet = GUID_NULL;
        m_rgPreviousStates[i].m_state = VSS_WS_UNKNOWN;
        m_rgPreviousStates[i].m_bInOperation = false;
        m_rgPreviousStates[i].m_hrWriterFailure = E_UNEXPECTED;
        }
    }

// setup state at the beginning of a snapshot
void CVssWriterState::InitializeCurrentState(IN const VSS_ID &idSnapshot)
    {
    m_cs.Lock();

    // initalize snapshot id
    m_currentState.m_idSnapshotSet = idSnapshot;

    // current state is STABLE (i.e., beginning of sequence, clears
    // any completion state we were in)
    m_currentState.m_state = VSS_WS_STABLE;

    // indicate that there is no failure
    m_currentState.m_hrWriterFailure = S_OK;

    // clear that we are in an operation
    m_currentState.m_bInOperation = false;

    // indicate that sequence is in progress
    m_bSequenceInProgress = true;
    
    m_cs.Unlock();
    }

// push the current state
void CVssWriterState::PushCurrentState()
    {
    m_cs.Lock();

    if (m_bSequenceInProgress)
        {
        // Reset the sequence-related data members
        m_bSequenceInProgress = false;

        // We need to test to not add the same SSID twice - bug 228622.
        if (SearchForPreviousSequence(m_currentState.m_idSnapshotSet) == INVALID_SEQUENCE_INDEX)
            {
            BS_ASSERT(m_iPreviousSnapshots < MAX_PREVIOUS_SNAPSHOTS);
            VSWRITER_STATE *pState = &m_rgPreviousStates[m_iPreviousSnapshots];
            memcpy(pState, &m_currentState, sizeof(m_currentState));
            m_iPreviousSnapshots = (m_iPreviousSnapshots + 1) % MAX_PREVIOUS_SNAPSHOTS;
            }
        else
            BS_ASSERT(false); // The same SSID was already added - programming error.
        }

    m_cs.Unlock();
    }

// find the state for a previous snapshot set
INT CVssWriterState::SearchForPreviousSequence(IN const VSS_ID& idSnapshotSet) const
    {
    for(INT iSeqIndex = 0;
        iSeqIndex < MAX_PREVIOUS_SNAPSHOTS;
        iSeqIndex++)
        {
        if (idSnapshotSet == m_rgPreviousStates[iSeqIndex].m_idSnapshotSet)
            return iSeqIndex;
        } // end for
        
    return INVALID_SEQUENCE_INDEX;
    }


// obtain the state given the snapshot id
void CVssWriterState::GetStateForSnapshot
    (
    IN const VSS_ID &id,
    OUT VSWRITER_STATE &state,
    OUT bool &bFailedAtIdentify
    )
    {
    // get lock on state class
    m_cs.Lock();
    if (id == GUID_NULL ||
        m_bSequenceInProgress && id == m_currentState.m_idSnapshotSet)
        {
        // get state for current snapshot set
        state = m_currentState;
        bFailedAtIdentify = m_bFailedAtIdentify;
        }
    else
        {
        // return state for a previously created snapshot set
        bFailedAtIdentify = false;

        // Search for the previous sequence with the same ID
        INT nPreviousSequence = SearchForPreviousSequence(id);
        if (nPreviousSequence == INVALID_SEQUENCE_INDEX)
            {
            // don't have any information about the snapshot set
            state.m_idSnapshotSet = id;
            state.m_bInOperation = false;
            state.m_state = VSS_WS_UNKNOWN;
            state.m_hrWriterFailure = E_UNEXPECTED;
            }
        else
            {
            BS_ASSERT(m_rgPreviousStates[nPreviousSequence].m_idSnapshotSet == id);

            // return state from snapshot set
            state = m_rgPreviousStates[nPreviousSequence];
            }
        }

    // unlock class
    m_cs.Unlock();
    }



// handle completion of the BackupComplete state.
void CVssWriterState::FinishBackupComplete(const VSS_ID &id)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterState::FinishBackupComplete");

    // lock class
    m_cs.Lock();

    // We must search for a previous state - Thaw already ended the sequence.
    INT iPreviousSequence = SearchForPreviousSequence(id);
    if (iPreviousSequence == INVALID_SEQUENCE_INDEX)
        {
        // couldn't find snapshot set.  We will indicate that this is
        // a retryable error
        m_currentState.m_hrWriterFailure = VSS_E_WRITERERROR_RETRYABLE;

        // unlock class before throwing
        m_cs.Unlock();
        ft.Throw
            (
            VSSDBG_WRITER,
            E_UNEXPECTED,
            L"Couldn't find a previous sequence with the same Snapshot Set ID"
            );
        }

    // We found a previous sequence with the same SSID.
    BS_ASSERT(id == m_rgPreviousStates[iPreviousSequence].m_idSnapshotSet);

    // BUG 228622 - If we do not have a previous successful Thaw transition
    // then we cannot call BackupComplete
    if (m_rgPreviousStates[iPreviousSequence].m_state != VSS_WS_WAITING_FOR_BACKUP_COMPLETE)
        {
        m_currentState.m_hrWriterFailure = VSS_E_WRITERERROR_RETRYABLE;

        // unlock object before throwing
        m_cs.Unlock();
        ft.Throw
            (
            VSSDBG_WRITER,
            E_UNEXPECTED,
            L"Couldn't call BackupComplete without OnThaw as a previous state [%d]",
            m_rgPreviousStates[iPreviousSequence].m_state
            );
        }

    // BUG 219692 - indicate that sequence is complete even in the saved states
    m_rgPreviousStates[iPreviousSequence].m_state = VSS_WS_STABLE;
    m_rgPreviousStates[iPreviousSequence].m_bInOperation = true;
    m_rgPreviousStates[iPreviousSequence].m_currentOperation = VSS_IN_BACKUPCOMPLETE;
    m_cs.Unlock();
    }

// indicate that backup complete failed
void CVssWriterState::SetBackupCompleteStatus(const VSS_ID &id, HRESULT hr)
    {
    CVssFunctionTracer ft(VSSDBG_WRITER, L"CVssWriterState::SetBackupCompleteFailed");

    // lock class
    m_cs.Lock();

    // We must search for a previous state - Thaw already ended the sequence.
    INT iPreviousSequence = SearchForPreviousSequence(id);
    if (iPreviousSequence == INVALID_SEQUENCE_INDEX)
        return;

    // We found a previous sequence with the same SSID.
    BS_ASSERT(id == m_rgPreviousStates[iPreviousSequence].m_idSnapshotSet);

    
    if (m_rgPreviousStates[iPreviousSequence].m_state == VSS_WS_STABLE ||
        m_rgPreviousStates[iPreviousSequence].m_state == VSS_WS_WAITING_FOR_BACKUP_COMPLETE)
        {
        if (FAILED(hr))
            {
            // indicate failure and use current failure as the backup completion failure
            m_rgPreviousStates[iPreviousSequence].m_state = VSS_WS_FAILED_AT_BACKUP_COMPLETE;
            m_rgPreviousStates[iPreviousSequence].m_hrWriterFailure = m_currentState.m_hrWriterFailure;
            }

        m_rgPreviousStates[iPreviousSequence].m_bInOperation = false;
        }

    m_cs.Unlock();
    }


// no response error.  It first checks to see if we are still
// in the operation.  If not, then we need to retry obtaining
// the writer's state
bool CVssWriterState::SetNoResponseFailure(const VSWRITER_STATE &state)
    {
    // lock object
    m_cs.Lock();

    if (m_currentState.m_idSnapshotSet == state.m_idSnapshotSet)
        {
        if (!m_currentState.m_bInOperation ||
            m_currentState.m_currentOperation != state.m_currentOperation)
            {
            // no longer in the operation.  Should not return a no-response
            // failure.  Instead requery the current state
            m_cs.Unlock();
            return false;
            }

        m_currentState.m_hrWriterFailure = VSS_E_WRITER_NOT_RESPONDING;
        m_currentState.m_state = state.m_state;
        m_cs.Unlock();
        return true;
        }

    INT iPreviousSequence = SearchForPreviousSequence(state.m_idSnapshotSet);
    if (iPreviousSequence == INVALID_SEQUENCE_INDEX)
        return true;

    VSWRITER_STATE *pState = &m_rgPreviousStates[iPreviousSequence];
    if (!pState->m_bInOperation ||
        pState->m_currentOperation != state.m_currentOperation)
        {
        // no longer in the operation.  We should not return an no-response
        // failure.  Instead requery the state of the snapshot set.
        m_cs.Unlock();
        return false;
        }

    // indicate that writer is not responding
    pState->m_hrWriterFailure = VSS_E_WRITER_NOT_RESPONDING;

    // get last known state of writer
    pState->m_state = state.m_state;
    m_cs.Unlock();
    return true;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\vswriter.cpp ===
/*++
Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module VsWriter.cpp | Implementation of Writer
    @end

Author:

    Adi Oltean  [aoltean]  02/02/2000

TBD:
	
	Add comments.

Revision History:

	
    Name        Date        Comments
    brianb     03/28/2000   Created
    mikejohn   05/18/2000   ~CVssWriter() should check that wrapper exists
                            before calling it
    mikejohn   06/23/2000   Add external entry point for SetWriterFailure()
    mikejohn   09/01/2000   Add extra tracing to identify writers in trace output
    mikejohn   09/18/2000   176860: Added calling convention methods where missing
    ssteiner   02/14/2001   Changed class interface to version 2.

--*/


#include <stdafx.h>
#include <comadmin.h>

extern CComModule _Module;
#include <atlcom.h>

#include "vs_idl.hxx"
#include "comadmin.hxx"
#include "vswriter.h"
#include "vsbackup.h"
#include "vsevent.h"
#include "vswrtimp.h"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"
#include "vs_sec.hxx"

extern WCHAR g_ComponentMetadataXML[];
static LPCWSTR x_wszElementRoot = L"root";
static LPCWSTR x_wszElementSnapshotSetDescription = L"SNAPSHOT_SET_DESCRIPTION";
static LPCWSTR x_wszAttrSnapshotSetId = L"snapshotSetId";
static LPCWSTR x_wszAttrXmlns = L"xmlns";
static LPCWSTR x_wszValueXmlns = L"x-schema:#VssComponentMetadata";
static LPCWSTR x_wszAttrContext = L"context";


////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHVWRTC"
//
////////////////////////////////////////////////////////////////////////


static LPCWSTR GetStringFromUsageType (VSS_USAGE_TYPE eUsageType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eUsageType)
	{
	case VSS_UT_BOOTABLESYSTEMSTATE: pwszRetString = L"BootableSystemState"; break;
	case VSS_UT_SYSTEMSERVICE:       pwszRetString = L"SystemService";       break;
	case VSS_UT_USERDATA:            pwszRetString = L"UserData";            break;
	case VSS_UT_OTHER:               pwszRetString = L"Other";               break;
					
	default:
	    break;
	}


    return (pwszRetString);
    }



static LPCWSTR GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eSourceType)
	{
	case VSS_ST_TRANSACTEDDB:    pwszRetString = L"TransactionDb";    break;
	case VSS_ST_NONTRANSACTEDDB: pwszRetString = L"NonTransactionDb"; break;
	case VSS_ST_OTHER:           pwszRetString = L"Other";            break;

	default:
	    break;
	}


    return (pwszRetString);
    }

static LPCWSTR GetStringFromAlternateWriterState (VSS_ALTERNATE_WRITER_STATE aws)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (aws)
	{
	case VSS_AWS_UNDEFINED:                pwszRetString = L"Undefined";   					break;
	case VSS_AWS_NO_ALTERNATE_WRITER:      pwszRetString = L"No alternate writer";    		break;
	case VSS_AWS_ALTERNATE_WRITER_EXISTS:  pwszRetString = L"Alternate writer exists";   	break;
	case VSS_AWS_THIS_IS_ALTERNATE_WRITER: pwszRetString = L"This is the alternate writer"; break;

	default:
	    break;
	}


    return (pwszRetString);
    }
	
static LPCWSTR GetStringFromApplicationLevel (VSS_APPLICATION_LEVEL eApplicationLevel)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eApplicationLevel)
	{
	case VSS_APP_UNKNOWN:   pwszRetString = L"Unknown";   break;
	case VSS_APP_SYSTEM:    pwszRetString = L"System";    break;
	case VSS_APP_BACK_END:  pwszRetString = L"BackEnd";   break;
	case VSS_APP_FRONT_END: pwszRetString = L"FrontEnd";  break;
	case VSS_APP_AUTO:      pwszRetString = L"Automatic"; break;

	default:
	    break;
	}


    return (pwszRetString);
    }





// constructor
__declspec(dllexport)
STDMETHODCALLTYPE CVssWriter::CVssWriter() :
	m_pWrapper(NULL)
	{
	}

// destructor
__declspec(dllexport)
STDMETHODCALLTYPE CVssWriter::~CVssWriter()
	{
	if (NULL != m_pWrapper)
	    {
#ifdef _DEBUG
	    LONG cRef =
#endif
	    m_pWrapper->Release();

//  disable for now
//	    BS_ASSERT(cRef == 0);
	    }

	}

// default OnPrepareBackup method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnPrepareBackup(IN IVssWriterComponents *pComponent)
	{
	UNREFERENCED_PARAMETER(pComponent);

	return true;
	}

// default OnIdentify method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
	{
	UNREFERENCED_PARAMETER(pMetadata);

	return true;
	}

// default OnBackupComplete method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnBackupComplete(IN IVssWriterComponents *pComponent)
	{
	UNREFERENCED_PARAMETER(pComponent);

	return true;
	}

// default OnPreRestore method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnPreRestore(IN IVssWriterComponents *pComponent)
	{
	UNREFERENCED_PARAMETER(pComponent);

	return true;
	}

// default OnPostRestore method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnPostRestore(IN IVssWriterComponents *pComponent)
	{
	UNREFERENCED_PARAMETER(pComponent);

	return true;
	}

// default OnPostSnapshot method
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnPostSnapshot(IN IVssWriterComponents *pComponent)
	{
	UNREFERENCED_PARAMETER(pComponent);

	return true;
	}

// default OnBackOffIOOnVolume
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnBackOffIOOnVolume
    (
    IN VSS_PWSZ wszVolumeName,
    IN VSS_ID snapshotId,
    IN VSS_ID providerId
    )
{
	UNREFERENCED_PARAMETER(wszVolumeName);
	UNREFERENCED_PARAMETER(snapshotId);
	UNREFERENCED_PARAMETER(providerId);

	return true;
}

// default OnContinueIOOnVolume
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnContinueIOOnVolume
    (
    IN VSS_PWSZ wszVolumeName,
    IN VSS_ID snapshotId,
    IN VSS_ID providerId
    )
{
	UNREFERENCED_PARAMETER(wszVolumeName);
	UNREFERENCED_PARAMETER(snapshotId);
	UNREFERENCED_PARAMETER(providerId);

	return true;
}

// default OnVSSShutdown
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnVSSShutdown()
{
	return true;
}

// default OnVSSApplicationStartup
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::OnVSSApplicationStartup()
{
	return true;
}



// initialize the writer
__declspec(dllexport)
HRESULT STDMETHODCALLTYPE CVssWriter::Initialize
	(
	IN VSS_ID WriterID,
	IN LPCWSTR wszWriterName,
	IN VSS_USAGE_TYPE ut,
	IN VSS_SOURCE_TYPE st,
	IN VSS_APPLICATION_LEVEL nLevel,
	IN DWORD dwTimeoutFreeze,
    IN VSS_ALTERNATE_WRITER_STATE aws,
    IN bool bIOThrottlingOnly
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::Initialize");

	try
		{
		ft.Trace (VSSDBG_SHIM, L"Called CVssWriter::Initialize() with:");
		ft.Trace (VSSDBG_SHIM, L"    WriterId             = " WSTR_GUID_FMT, GUID_PRINTF_ARG (WriterID));
		ft.Trace (VSSDBG_SHIM, L"    WriterName           = %s",      (NULL == wszWriterName) ? L"(NULL)" : wszWriterName);
		ft.Trace (VSSDBG_SHIM, L"    UsageType            = %s",      GetStringFromUsageType (ut));
		ft.Trace (VSSDBG_SHIM, L"    SourceType           = %s",      GetStringFromSourceType (st));
		ft.Trace (VSSDBG_SHIM, L"    AppLevel             = %s",      GetStringFromApplicationLevel (nLevel));
		ft.Trace (VSSDBG_SHIM, L"    FreezeTimeout        = %d (ms)", dwTimeoutFreeze);
		ft.Trace (VSSDBG_SHIM, L"    AlternateWriterState = %s",      GetStringFromAlternateWriterState(aws));
		ft.Trace (VSSDBG_SHIM, L"    IOThrottlingOnly     = %s",      bIOThrottlingOnly ? L"True" : L"False");

		// The V2 parameters can only be set with default values
		if (aws != VSS_AWS_NO_ALTERNATE_WRITER ||
			bIOThrottlingOnly != false)
			return E_INVALIDARG;
		
		if (ut != VSS_UT_BOOTABLESYSTEMSTATE &&
			ut != VSS_UT_SYSTEMSERVICE &&
			ut != VSS_UT_USERDATA &&
			ut != VSS_UT_OTHER)
			return E_INVALIDARG;
// [aoltean] Previous comment was:
// return S_OK for now since there is a bug in the iis writer
//			return S_OK;

		if (st != VSS_ST_NONTRANSACTEDDB &&
			st != VSS_ST_TRANSACTEDDB &&
			st != VSS_ST_OTHER)
			return E_INVALIDARG;
// [aoltean] Previous comment was:
// return S_OK for now since there is a bug in the IIS writer
//			return S_OK;

		CVssWriterImpl::CreateWriter(this, &m_pWrapper);
		BS_ASSERT(m_pWrapper);

		// call Initialize method on core instance
		m_pWrapper->Initialize
			(
			WriterID,
			wszWriterName,
			ut,
			st,
			nLevel,
			dwTimeoutFreeze
			);
        }
	VSS_STANDARD_CATCH(ft)
	return ft.hr;
	}



__declspec(dllexport)
HRESULT STDMETHODCALLTYPE CVssWriter::Subscribe
	(
  	IN DWORD dwEventFlags	
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::Subscribe");

	try
		{
		ft.Trace (VSSDBG_SHIM, L"Called CVssWriter::Subscribe() with:");
		ft.Trace (VSSDBG_SHIM, L"    dwEventFlags = 0x%08x ", dwEventFlags);
		//  Only the default parameter setting is supported in V1
		if ( dwEventFlags != ( VSS_SM_BACKUP_EVENTS_FLAG | VSS_SM_RESTORE_EVENTS_FLAG ) )
			return E_INVALIDARG;

		if (m_pWrapper == NULL)
			ft.Throw(VSSDBG_GEN, E_FAIL, L"CVssWriter class was not initialized.");

		m_pWrapper->Subscribe();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

__declspec(dllexport)
HRESULT STDMETHODCALLTYPE CVssWriter::Unsubscribe()
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::Unsubscribe");

	try
		{
		if (m_pWrapper == NULL)
			ft.Throw(VSSDBG_GEN, E_FAIL, L"CVssWriter class was not initialized.");

		m_pWrapper->Unsubscribe();
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}

__declspec(dllexport)
HRESULT STDMETHODCALLTYPE CVssWriter::InstallAlternateWriter
    (
    IN VSS_ID writerId,
    IN CLSID persistentWriterClassId
    )
	{
	UNREFERENCED_PARAMETER(writerId);
	UNREFERENCED_PARAMETER(persistentWriterClassId);

	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::InstallAlternateWriter");

	// Not supported in V1
	ft.hr = E_NOTIMPL;

	return ft.hr;
	}


__declspec(dllexport)
LPCWSTR* STDMETHODCALLTYPE CVssWriter::GetCurrentVolumeArray() const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetCurrentVolumeArray");

	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return NULL;
	else
		return m_pWrapper->GetCurrentVolumeArray();
	}

__declspec(dllexport)
UINT STDMETHODCALLTYPE CVssWriter::GetCurrentVolumeCount() const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetCurrentVolumeCount");

	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return 0;
	else
		return m_pWrapper->GetCurrentVolumeCount();
	}

__declspec(dllexport)
VSS_ID STDMETHODCALLTYPE CVssWriter::GetCurrentSnapshotSetId() const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetCurrentSnapshotSetId");
	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return GUID_NULL;
	else
		return m_pWrapper->GetCurrentSnapshotSetId();
	}

__declspec(dllexport)
VSS_APPLICATION_LEVEL STDMETHODCALLTYPE CVssWriter::GetCurrentLevel() const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetCurrentLevel");

	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return VSS_APP_AUTO;
	else
		return m_pWrapper->GetCurrentLevel();
	}

__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::IsPathAffected(IN	LPCWSTR wszPath) const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::IsPathAffected");

	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return NULL;
	else
		return m_pWrapper->IsPathAffected(wszPath);
	}


// determine if bootable state is backed up
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::IsBootableSystemStateBackedUp() const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::IsBootableSystemStateBackedUp");

	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return false;
	else
		return m_pWrapper->IsBootableSystemStateBackedUp();
	}


// determine if bootable state is backed up
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::IsPartialFileSupportEnabled() const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::IsPartialFileSupportEnabled");

	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return false;
	else
		return m_pWrapper->IsPartialFileSupportEnabled();
	}


// determine if the backup application is selecting components
__declspec(dllexport)
bool STDMETHODCALLTYPE CVssWriter::AreComponentsSelected() const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::AreComponentsSelected");
	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return false;
	else
		return m_pWrapper->AreComponentsSelected();
	}

__declspec(dllexport)
VSS_BACKUP_TYPE STDMETHODCALLTYPE CVssWriter::GetBackupType() const
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::GetBackupType");

	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return VSS_BT_UNDEFINED;
	else
		return m_pWrapper->GetBackupType();
	}

__declspec(dllexport)
HRESULT STDMETHODCALLTYPE CVssWriter::SetWriterFailure(IN HRESULT hrStatus)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CVssWriter::SetWriterFailure");

	BS_ASSERT(m_pWrapper);
	if (m_pWrapper == NULL)
		return VSS_BT_UNDEFINED;
	else
		return m_pWrapper->SetWriterFailure(hrStatus);
	}

// create backup components
//
// Returns:
//		S_OK if the operation is successful
//		E_INVALIDARG if ppBackup is NULL
//		E_ACCESSDENIED if the caller does not have backup privileges or
//			is an administrator

__declspec(dllexport)
HRESULT STDAPICALLTYPE CreateVssBackupComponents(IVssBackupComponents **ppBackup)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CreateVssBackupComponents");

	try
		{
		if (ppBackup == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output pointer");

		*ppBackup = NULL;

		if (!IsProcessBackupOperator())
			ft.Throw
				(
				VSSDBG_XML,
				E_ACCESSDENIED,
				L"The client process is not running under an administrator account or does not have backup privilege enabled"
				);

		CComObject<CVssBackupComponents> *pvbc;
		CComObject<CVssBackupComponents>::CreateInstance(&pvbc);
		pvbc->GetUnknown()->AddRef();
		*ppBackup = (IVssBackupComponents *) pvbc;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}



__declspec(dllexport)
HRESULT STDAPICALLTYPE CreateVssExamineWriterMetadata
	(
	IN BSTR bstrXML,
	OUT IVssExamineWriterMetadata **ppMetadata
	)
	{
	CVssFunctionTracer ft(VSSDBG_GEN, L"CreateVssExamineWriterMetadata");

	CVssExamineWriterMetadata *pMetadata = NULL;
	try
		{
		if (ppMetadata == NULL)
			ft.Throw(VSSDBG_GEN, E_INVALIDARG, L"NULL output pointer");

		*ppMetadata = NULL;
		pMetadata = new CVssExamineWriterMetadata;
		if (pMetadata == NULL)
			ft.Throw(VSSDBG_GEN, E_OUTOFMEMORY, L"Cannot allocate CVssExamineWriterMetadata");

		if (!pMetadata->Initialize(bstrXML))
			ft.Throw
				(
				VSSDBG_GEN,
				VSS_E_INVALID_XML_DOCUMENT,
				L"XML passed to CreateVssExamineWriterMetdata was invalid"
				);

		*ppMetadata = (IVssExamineWriterMetadata *) pMetadata;
		pMetadata->AddRef();
		}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		delete pMetadata;

	return ft.hr;
	}

// create a snapshot set description
//
// Returns:
//		S_OK if it is successful
//		E_OUTOFMEMORY if memory could not be allocated

__declspec(dllexport)
HRESULT STDAPICALLTYPE CreateVssSnapshotSetDescription
	(
	VSS_ID idSnapshotSet,
	LONG lContext,
	OUT IVssSnapshotSetDescription **ppSnapshotSet
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"CreateVssSnapshotSsetDescription");

	CVssSnapshotSetDescription *pSnapshotSetTemp = NULL;

	try
		{
		CXMLDocument doc;

		if (ppSnapshotSet == NULL)
			ft.Throw(VSSDBG_XML, E_INVALIDARG, L"NULL output parameter.");

		// intialize document with <root><schema></root>
		doc.LoadFromXML(g_ComponentMetadataXML);

		// find toplevel <root> element
		if (!doc.FindElement(x_wszElementRoot, true))
			ft.Throw(VSSDBG_XML, VSS_E_INVALID_XML_DOCUMENT, L"Missing root element");

		// create BACKUP_COMPONENTS element under <root> element
		CXMLNode nodeRoot(doc.GetCurrentNode(), doc.GetInterface());

		CXMLNode nodeSnapshotSet = doc.CreateNode
			(
			x_wszElementSnapshotSetDescription,
			NODE_ELEMENT
			);

		nodeSnapshotSet.SetAttribute(x_wszAttrSnapshotSetId, idSnapshotSet);
		nodeSnapshotSet.SetAttribute(x_wszAttrContext, lContext);
		nodeSnapshotSet.SetAttribute(x_wszAttrXmlns, x_wszValueXmlns);
		CXMLNode nodeToplevel = nodeRoot.InsertNode(nodeSnapshotSet);
		doc.SetToplevelNode(nodeSnapshotSet);
		pSnapshotSetTemp = new CVssSnapshotSetDescription
									(
									doc.GetCurrentNode(),
									doc.GetInterface()
									);

        if (pSnapshotSetTemp == NULL)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Can't allocate snapshot set description.");

        pSnapshotSetTemp->Initialize(ft);

		*ppSnapshotSet = (IVssSnapshotSetDescription *) pSnapshotSetTemp;
		((IVssSnapshotSetDescription *) pSnapshotSetTemp)->AddRef();
		pSnapshotSetTemp = NULL;
		}
	VSS_STANDARD_CATCH(ft)

	delete pSnapshotSetTemp;

	return ft.hr;
	}

__declspec(dllexport)
HRESULT STDAPICALLTYPE LoadVssSnapshotSetDescription
	(
	IN  LPCWSTR wszXML,
	OUT IVssSnapshotSetDescription **ppSnapshotSet
	)
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"LoadVssSnapshotSetDescription");

	try
		{
		CVssSnapshotSetDescription *pSnapshotSetDescription = new CVssSnapshotSetDescription;
		if (pSnapshotSetDescription == NULL)
			ft.Throw(VSSDBG_XML, E_OUTOFMEMORY, L"Cannot allocate snapshot set description.");

		pSnapshotSetDescription->Initialize(ft);
		pSnapshotSetDescription->LoadFromXML(wszXML);
		((IVssSnapshotSetDescription *) pSnapshotSetDescription)->AddRef();
		*ppSnapshotSet = (IVssSnapshotSetDescription *) pSnapshotSetDescription;
		}
	VSS_STANDARD_CATCH(ft)

	return ft.hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\stdafx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    StdAfx.h

Abstract:

    Precompiled header file.

Author:

    Stefan R. Steiner   [ssteiner]        02-01-2000

Revision History:

	X-3	MCJ		Michael C. Johnson		12-Jun-2000
		Added vswriter.h and vsbackup.h

	X-2	MCJ		Michael C. Johnson		 6-Mar-2000
		Added coord.h and vsevent.h to include list.

--*/

#ifndef __H_STDAFX_
#define __H_STDAFX_

#pragma once

//
// C4290: C++ Exception Specification ignored
//
#pragma warning(disable:4290)
#pragma warning(disable:4201)    // C4201: nonstandard extension used : nameless struct/union

// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
#undef _ASSERTE

#include <windows.h>

#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stdlib.h>
#include <errno.h>
#include <devioctl.h>
#include <ntddstor.h>

#include "vs_assert.hxx"

#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <stddef.h>
#include <oleauto.h>
#include <atlconv.h>
#include <atlbase.h>

#include "vs_inc.hxx"
#include "vs_idl.hxx"

#include <vswriter.h>
#include <vsbackup.h>


#endif // __H_STDAFX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrclus.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrclus.cpp | Implementation of SnapshotWriter for Cluster Database

    NOTE: This module is not used/compiled anymore since Clusters has its own snapshot writer.

Author:

    Michael C. Johnson [mikejohn] 31-Jan-2000


Description:
	
    Add comments.


Revision History:

	X-13	MCJ		Michael C. Johnson		22-Oct-2000
		209095: Dynamically load the cluster and net libraries to
		reduce the foot print for the unclustered.
 
	X-12	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-11	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-10	MCJ		Michael C. Johnson		18-Jul-2000
		144027: Remove trailing '\' from Include/Exclude lists.

	X-9	MCJ		Michael C. Johnson		12-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-8	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()
 
	X-7	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-6	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-5	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.
		Move save path under SystemState target path.

	X-4	MCJ		Michael C. Johnson		17-Feb-2000
		Modify save path to be consistent with standard.

	X-3	MCJ		Michael C. Johnson		11-Feb-2000
		Update to use some new StringXxxx() routines and fix a
		length check bug along the way.

	X-2	MCJ		Michael C. Johnson		08-Feb-2000
		Fix broken assert in shutdown code, some path length checks
		and calculations.

	X-1	MCJ		Michael C. Johnson		31-Jan-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.

--*/


#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"
#include <clusapi.h>
#include <lmshare.h>
#include <lmaccess.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHCLUSC"
//
////////////////////////////////////////////////////////////////////////

/*
** The save path has a standard form which is
**
**	%SystemRoot%\Repair\Backup,
**
** followed by the application writer string as publised in the export
** table followed by whatever else the writer requires.
*/
#define APPLICATION_STRING	L"ClusterDatabase"
#define COMPONENT_NAME		L"Cluster Database"
#define TARGET_PATH		ROOT_BACKUP_DIR BOOTABLE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING


DeclareStaticUnicodeString (ucsShareName, L"__NtBackup_cluster");


typedef DWORD		(WINAPI *PFnGetNodeClusterState)(LPCWSTR, PDWORD);
typedef HCLUSTER	(WINAPI *PFnOpenCluster)(LPCWSTR);
typedef DWORD		(WINAPI *PFnBackupClusterDatabase)(HCLUSTER, LPCWSTR);
typedef BOOL		(WINAPI *PFnCloseCluster)(HCLUSTER);

typedef NET_API_STATUS	(WINAPI *PFnNetShareAdd)(LPWSTR, DWORD, LPBYTE, LPDWORD);
typedef NET_API_STATUS	(WINAPI *PFnNetShareDel)(LPWSTR, LPWSTR, DWORD);



/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/
class CShimWriterClusterDb : public CShimWriter
    {
public:
    CShimWriterClusterDb (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath, BOOL bBootableState) : 
		CShimWriter (pwszWriterName, pwszTargetPath, bBootableState),
		m_pfnDynamicGetNodeClusterState   (NULL),
		m_pfnDynamicOpenCluster           (NULL),
		m_pfnDynamicCloseCluster          (NULL),
		m_pfnDynamicBackupClusterDatabase (NULL),
		m_pfnDynamicNetShareAdd           (NULL),
		m_pfnDynamicNetShareDel           (NULL),
		m_hmodClusApi                     (NULL),
		m_hmodNetApi32                    (NULL) {};


private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);

    HRESULT DoClusterDatabaseBackup (VOID);

    HRESULT DynamicRoutinesLoadCluster (VOID);
    HRESULT DynamicRoutinesLoadNetwork (VOID);
    HRESULT DynamicRoutinesUnloadAll   (VOID);


    PFnGetNodeClusterState	m_pfnDynamicGetNodeClusterState;
    PFnOpenCluster		m_pfnDynamicOpenCluster;
    PFnCloseCluster		m_pfnDynamicCloseCluster;
    PFnBackupClusterDatabase	m_pfnDynamicBackupClusterDatabase;
    PFnNetShareAdd		m_pfnDynamicNetShareAdd;
    PFnNetShareDel		m_pfnDynamicNetShareDel;
    HMODULE			m_hmodClusApi;
    HMODULE			m_hmodNetApi32;
    };


static CShimWriterClusterDb ShimWriterClusterDb (APPLICATION_STRING, TARGET_PATH, TRUE);

PCShimWriter pShimWriterClusterDb = &ShimWriterClusterDb;



/*
**++
**
** Routine Description:
**
**	This routine loads the required Cluster DLL and obtains the
**	entry points of the routines we care about. All the pertinent
**	information is tucked away safely in the class.
**
**
** Arguments:
**
**	None
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterClusterDb::DynamicRoutinesLoadCluster ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterClusterDb::DynamicRoutinesLoadCluster");


    try 
	{
	if ((NULL != m_pfnDynamicGetNodeClusterState)   ||
	    (NULL != m_pfnDynamicOpenCluster)           ||
	    (NULL != m_pfnDynamicCloseCluster)          ||
	    (NULL != m_pfnDynamicBackupClusterDatabase) ||
	    !HandleInvalid (m_hmodClusApi))
	    {
	    ft.hr = HRESULT_FROM_WIN32 (ERROR_ALREADY_INITIALIZED);

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"CheckingVariablesClean");
	    }



	m_hmodClusApi = LoadLibraryW (L"ClusApi.dll");

	ft.hr = GET_STATUS_FROM_HANDLE (m_hmodClusApi);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"LoadLibraryW (ClusApi.dll)");



	m_pfnDynamicGetNodeClusterState = (PFnGetNodeClusterState) GetProcAddress (m_hmodClusApi, "GetNodeClusterState");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicGetNodeClusterState);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (GetNodeClusterState)");



	m_pfnDynamicOpenCluster = (PFnOpenCluster) GetProcAddress (m_hmodClusApi, "OpenCluster");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicOpenCluster);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (OpenCluster)");



	m_pfnDynamicCloseCluster = (PFnCloseCluster) GetProcAddress (m_hmodClusApi, "CloseCluster");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicCloseCluster);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (CloseCluster)");



	m_pfnDynamicBackupClusterDatabase = (PFnBackupClusterDatabase) GetProcAddress (m_hmodClusApi, "BackupClusterDatabase");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicBackupClusterDatabase);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (BackupClusterDatabase)");

	} VSS_STANDARD_CATCH (ft)



    if (ft.HrFailed ())
	{
	if (!HandleInvalid (m_hmodClusApi)) FreeLibrary (m_hmodClusApi);

	m_pfnDynamicGetNodeClusterState   = NULL;
	m_pfnDynamicOpenCluster           = NULL;
	m_pfnDynamicCloseCluster          = NULL;
	m_pfnDynamicBackupClusterDatabase = NULL;
	m_hmodClusApi                     = NULL;
	}


    return (ft.hr);
    } /* CShimWriterClusterDb::DynamicRoutinesLoadCluster () */

/*
**++
**
** Routine Description:
**
**	This routine loads the required Network DLL and obtains the
**	entry points of the routines we care about. All the pertinent
**	information is tucked away safely in the class.
**
**
** Arguments:
**
**	None
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterClusterDb::DynamicRoutinesLoadNetwork ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterClusterDb::DynamicRoutinesLoadNetwork");


    try 
	{
	if ((NULL != m_pfnDynamicNetShareAdd) ||
	    (NULL != m_pfnDynamicNetShareDel) ||
	    !HandleInvalid (m_hmodNetApi32))
	    {
	    ft.hr = HRESULT_FROM_WIN32 (ERROR_ALREADY_INITIALIZED);

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"CheckingVariablesClean");
	    }



	m_hmodNetApi32 = LoadLibraryW (L"NetApi32.dll");

	ft.hr = GET_STATUS_FROM_HANDLE (m_hmodNetApi32);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"LoadLibraryW (NetApi32.dll)");



	m_pfnDynamicNetShareAdd = (PFnNetShareAdd) GetProcAddress (m_hmodNetApi32, "NetShareAdd");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicNetShareAdd);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (NetShareAdd)");



	m_pfnDynamicNetShareDel = (PFnNetShareDel) GetProcAddress (m_hmodNetApi32, "NetShareDel");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicNetShareDel);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (NetShareDel)");

	} VSS_STANDARD_CATCH (ft)



    if (ft.HrFailed ())
	{
	if (!HandleInvalid (m_hmodNetApi32)) FreeLibrary (m_hmodNetApi32);

	m_pfnDynamicNetShareAdd = NULL;
	m_pfnDynamicNetShareDel = NULL;
	m_hmodNetApi32          = NULL;
	}


    return (ft.hr);
    } /* CShimWriterClusterDb::DynamicRoutinesLoadNetwork () */

/*
**++
**
** Routine Description:
**
**	This routine loads the required Network DLL and obtains the
**	entry points of the routines we care about. All the pertinent
**	information is tucked away safely in the class.
**
**
** Arguments:
**
**	None
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterClusterDb::DynamicRoutinesUnloadAll ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterClusterDb::DynamicRoutinesUnloadAll");


    try 
	{
	if (!HandleInvalid (m_hmodNetApi32)) FreeLibrary (m_hmodNetApi32);

	m_pfnDynamicNetShareAdd = NULL;
	m_pfnDynamicNetShareDel = NULL;
	m_hmodNetApi32          = NULL;



	if (!HandleInvalid (m_hmodClusApi)) FreeLibrary (m_hmodClusApi);

	m_pfnDynamicGetNodeClusterState   = NULL;
	m_pfnDynamicOpenCluster           = NULL;
	m_pfnDynamicCloseCluster          = NULL;
	m_pfnDynamicBackupClusterDatabase = NULL;
	m_hmodClusApi                     = NULL;
	} VSS_STANDARD_CATCH (ft)


    return (ft.hr);
    } /* CShimWriterClusterDb::DynamicRoutinesUnloadAll () */

/*
**++
**
** Routine Description:
**
**	The Cluster database snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterClusterDb::DoIdentify ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterClusterDb::DoIdentify");

    DWORD		winStatus;
    DWORD		dwClusterNodeState;
    BOOL		bClusterRunning = FALSE;



    try 
	{
	ft.hr = DynamicRoutinesLoadCluster ();

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"DynamicRoutinesLoadCluster");



	winStatus = m_pfnDynamicGetNodeClusterState (NULL, &dwClusterNodeState);

	ft.hr = HRESULT_FROM_WIN32 (winStatus);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetNodeClusterState");
 
	bClusterRunning = (ClusterStateRunning == dwClusterNodeState);



	if (bClusterRunning)
	    {
	    ft.hr = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							       NULL,
							       COMPONENT_NAME,
							       COMPONENT_NAME,
							       NULL, // icon
							       0,
							       true,
							       false,
							       false);

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddComponent");


	    ft.hr= m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								     COMPONENT_NAME,
								     m_pwszTargetPath,
								     L"*",
								     true,
								     NULL);

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddFilesToFileGroup");
 	    }
	} VSS_STANDARD_CATCH (ft)


    DynamicRoutinesUnloadAll ();

    return (ft.hr);
    } /* CShimWriterClusterDb::DoIdentify () */


/*++

Routine Description:

    The Cluster database snapshot writer PrepareForSnapshot function.
    Currently all of the real work for this writer happens here.

Arguments:

    Same arguments as those passed in the PrepareForSnapshot event.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterClusterDb::DoPrepareForSnapshot ()
    {
    HRESULT	hrStatus = NOERROR;
    DWORD	winStatus;
    DWORD	dwClusterNodeState;


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = DynamicRoutinesLoadCluster ();
	}


    if (SUCCEEDED (hrStatus))
	{
	winStatus = m_pfnDynamicGetNodeClusterState (NULL, &dwClusterNodeState);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	m_bParticipateInBackup = SUCCEEDED (hrStatus) && (ClusterStateRunning == dwClusterNodeState);


	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetNodeClusterState", 
		    L"CShimWriterClusterDb::DoPrepareForSnapshot");
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	hrStatus = DynamicRoutinesLoadNetwork ();
	}


    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	hrStatus = DoClusterDatabaseBackup ();
	}


    DynamicRoutinesUnloadAll ();


    return (hrStatus);
    } /* CShimWriterClusterDb::PrepareForFreeze () */



HRESULT CShimWriterClusterDb::DoClusterDatabaseBackup ()
    {
    HRESULT			hrStatus       = NOERROR;
    HCLUSTER			hCluster       = NULL;
    BOOL			bNetShareAdded = FALSE;
    BOOL			bSucceeded;
    SHARE_INFO_502		ShareInfo;
    UNICODE_STRING		ucsComputerName;
    UNICODE_STRING		ucsBackupPathLocal;
    UNICODE_STRING		ucsBackupPathNetwork;


    BS_ASSERT (MAX_COMPUTERNAME_LENGTH <= ((MAXUSHORT / sizeof (WCHAR)) - sizeof (UNICODE_NULL)));


    StringInitialise (&ucsComputerName);
    StringInitialise (&ucsBackupPathLocal);
    StringInitialise (&ucsBackupPathNetwork);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsBackupPathLocal,
						   m_pwszTargetPath,
						   0);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsComputerName,
				   (MAX_COMPUTERNAME_LENGTH * sizeof (WCHAR)) + sizeof (UNICODE_NULL));
	}


    if (SUCCEEDED (hrStatus))
	{
	DWORD	dwNameLength = ucsComputerName.MaximumLength / sizeof (WCHAR);
	BOOL	bSucceeded   = GetComputerNameW (ucsComputerName.Buffer, &dwNameLength);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	if (SUCCEEDED (hrStatus))
	    {
	    ucsComputerName.Length = (USHORT) (dwNameLength * sizeof (WCHAR));
	    }
	else
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"GetComputerNameW", 
			L"CShimWriterClusterDb::DoClusterDatabaseBackup");
	    }
	}



    if (SUCCEEDED (hrStatus))
	{
	if ((ucsComputerName.Length + ucsShareName.Length) > (MAXUSHORT - (sizeof (UNICODE_NULL) + 3 * sizeof (L'\\'))))
	    {
	    hrStatus = HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
	    }
	else
	    {
	    hrStatus = StringAllocate (&ucsBackupPathNetwork,
				       (USHORT) (sizeof (L'\\')
						 + sizeof (L'\\')
						 + ucsComputerName.Length
						 + sizeof (L'\\')
						 + ucsShareName.Length
						 + sizeof (UNICODE_NULL)));
	    }
	}



    if (SUCCEEDED (hrStatus))
	{
	NET_API_STATUS	netStatus;

	/*
	** Should we uniquify the directory name at all here
	** to cater for the possiblity that we may be involved
	** in more than one snapshot at a time?
	*/
	StringAppendString (&ucsBackupPathNetwork, L"\\\\");
	StringAppendString (&ucsBackupPathNetwork, &ucsComputerName);
	StringAppendString (&ucsBackupPathNetwork, L"\\");
	StringAppendString (&ucsBackupPathNetwork, &ucsShareName);


	memset (&ShareInfo, 0, sizeof (ShareInfo));

	ShareInfo.shi502_netname     = ucsShareName.Buffer;
	ShareInfo.shi502_type        = STYPE_DISKTREE;
	ShareInfo.shi502_permissions = ACCESS_READ | ACCESS_WRITE | ACCESS_CREATE;
	ShareInfo.shi502_max_uses    = 1;
	ShareInfo.shi502_path        = ucsBackupPathLocal.Buffer;

        /*
        ** Make sure to try to delete the share first in case for some reason it exists.  This
        ** could happen if the previous shim instance was killed right after creating the
        ** share. Ignore the return code. Bug #280746.
        */
        m_pfnDynamicNetShareDel (NULL, ucsShareName.Buffer, 0);

	/*
	** Create the backup directory and share it out. Note that we
	** don't care if the CreateDirectoryW() fails: it could fail
	** for a number of legitimate reasons (eg already exists). If
	** the failure was significant then we won't be able to add
	** the share and we'll detect a problem at that point.
	*/
	netStatus = m_pfnDynamicNetShareAdd (NULL, 502, (LPBYTE)(&ShareInfo), NULL);
	hrStatus  = HRESULT_FROM_WIN32 (netStatus);

	bNetShareAdded = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"NetShareAdd", 
		    L"CShimWriterClusterDb::DoClusterDatabaseBackup");
	}


    if (SUCCEEDED (hrStatus))
	{
	hCluster = m_pfnDynamicOpenCluster (NULL);

	hrStatus = GET_STATUS_FROM_HANDLE (hCluster);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"OpenCluster", 
		    L"CShimWriterClusterDb::DoClusterDatabaseBackup");
	}


    if (SUCCEEDED (hrStatus))
	{
	DWORD	winStatus = m_pfnDynamicBackupClusterDatabase (hCluster, ucsBackupPathNetwork.Buffer);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"BackupClusterDatabase", 
		    L"CShimWriterClusterDb::DoClusterDatabaseBackup");
	}


    /*
    ** All the cleanup code.
    */
    if (!HandleInvalid (hCluster)) m_pfnDynamicCloseCluster (hCluster);
    if (bNetShareAdded)            m_pfnDynamicNetShareDel (NULL, ucsShareName.Buffer, 0);

    StringFree (&ucsComputerName);
    StringFree (&ucsBackupPathLocal);
    StringFree (&ucsBackupPathNetwork);

    return (hrStatus);
    } /* DoClusterDatabaseBackup () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrmetabase.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrmetabase.cpp | Implementation of SnapshotWriter for IIS MetaBase.bin file

    NOTE: This module is not used/compiled anymore since IIS has its own snapshot writer.

Author:

    Michael C. Johnson [mikejohn] 06-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-9	MCJ		Michael C. Johnson		18-Jul-2000
		144027: Remove trailing '\' from Include/Exclude lists.

	X-8	MCJ		Michael C. Johnson		12-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-7	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-6	MCJ		Michael C. Johnson		23-Mar-2000
		Fix bug where we didn't allow for the possibility that IIS
		may not be running on the machine.

	X-5	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-4	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.

	X-3	MCJ		Michael C. Johnson		17-Feb-2000
		Modify save path to be consistent with standard.

	X-2	MCJ		Michael C. Johnson		11-Feb-2000
		Update to use some new StringXxxx() routines and fix a
		length check bug along the way.

	X-1	MCJ		Michael C. Johnson		06-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.


--*/


#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"



#define APPLICATION_STRING	L"IisMetaBase"
#define COMPONENT_NAME		L"IIS Metabase"
#define METABASE_DIRECTORY	L"%SystemRoot%\\system32\\inetsrv"
#define METABASE_FILENAME	L"Metabase.bin"
#define METABASE_PATH		METABASE_DIRECTORY DIR_SEP_STRING METABASE_FILENAME




/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterMetabase : public CShimWriter
    {
public:
    CShimWriterMetabase(LPCWSTR pwszWriterName, BOOL bParticipateInBootableState) : 
		CShimWriter (pwszWriterName, bParticipateInBootableState), 
		m_hMetabaseFile(INVALID_HANDLE_VALUE) {};


private:
    HRESULT DoIdentify (VOID);
    HRESULT DoFreeze   (VOID);
    HRESULT DoThaw     (VOID);

    HANDLE  m_hMetabaseFile;
    };


static CShimWriterMetabase ShimWriterMetabase (APPLICATION_STRING, TRUE);

PCShimWriter pShimWriterIisMetabase = &ShimWriterMetabase;



/*
**++
**
** Routine Description:
**
**	The IIS metabase snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterMetabase::DoIdentify ()
    {
    HRESULT	hrStatus;


    hrStatus = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							  NULL,
							  COMPONENT_NAME,
							  COMPONENT_NAME,
							  NULL, // icon
							  0,
							  true,
							  false,
							  false);

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								     COMPONENT_NAME,
								     METABASE_DIRECTORY,
								     METABASE_FILENAME,
								     false,
								     NULL);
	}



    return (hrStatus);
    } /* CShimWriterMetabase::DoIdentify () */



HRESULT CShimWriterMetabase::DoFreeze ()
    {
    UNICODE_STRING	ucsMetabasePath;
    HRESULT		hrStatus;


    StringInitialise (&ucsMetabasePath);

    hrStatus = StringCreateFromExpandedString (&ucsMetabasePath,
					       METABASE_PATH,
					       0);


    /*
    ** Attempt to acquire read access to the file. This will stop
    ** anyone else opening it for updates until we release the open
    ** during the Thaw call.
    */
    if (SUCCEEDED (hrStatus))
	{
	m_hMetabaseFile = CreateFileW (ucsMetabasePath.Buffer,
				       GENERIC_READ,
				       FILE_SHARE_READ,
				       NULL,
				       OPEN_EXISTING,
				       FILE_FLAG_BACKUP_SEMANTICS,
				       NULL);

	hrStatus = GET_STATUS_FROM_BOOL (INVALID_HANDLE_VALUE != m_hMetabaseFile);

	if ((HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus) ||
	    (HRESULT_FROM_WIN32 (ERROR_PATH_NOT_FOUND) == hrStatus))
	    {
	    /*
	    ** Failure to find the file just means that IIS is not
	    ** running here and so there is no file to prevent writes
	    ** to.
	    */
	    hrStatus = NOERROR;
	    }
	}
	

    StringFree (&ucsMetabasePath);

    return (hrStatus);
    } /* CShimWriterMetabase::DoFreeze () */



HRESULT CShimWriterMetabase::DoThaw ()
    {
    HRESULT	hrStatus;


    /*
    ** Note that the handle may be invalid if we did not open the
    ** metabase file, but CommonCloseHandle() can cope with that case.
    */
    hrStatus = CommonCloseHandle (&m_hMetabaseFile);


    return (hrStatus);
    } /* CShimWriterMetabase::DoThaw () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrwmi.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrwmi.cpp

Abstract:

    Writer shim module for WMI Database
    
    NOTE: This module is not used/compiled anymore since WMI has its own snapshot writer.
    
Author:

    Michael C. Johnson [mikejohn]	22-Jun--2000

Revision History:

	X-7	MCJ		Michael C. Johnson		 7-Dec-2000
		235991: Remove workaround for the now re-instated WMI backup API

	X-6	MCJ		Michael C. Johnson		17-Nov-2000
		235987: Add workaround for broken WMI backup API

	X-5	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-4	MCJ		Michael C. Johnson		13-Sep-2000
		178282: Writer should only generate backup file if source 
			path is in volume list.

	X-3	MCJ		Michael C. Johnson		22-Aug-2000
		167335: Pull workaround for broken WMI backup API.
		169412: Add repository to the exclude list.

	X-2	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-1	MCJ		Michael C. Johnson		 9-Mar-2000
		Initial version based upon code originally in NtBackup.

--*/

#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"
#include <wbemcli.h>



#define APPLICATION_STRING	L"WmiDatabase"
#define COMPONENT_NAME		L"WMI Database"

#define TARGET_PATH		ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING

#define REPOSITORY_PATH		L"%SystemRoot%\\system32\\wbem\\Repository"

DeclareStaticUnicodeString (ucsBackupFilename, L"\\WBEM.bak");



/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterWMI : public CShimWriter
    {
public:
    CShimWriterWMI (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) : 
		CShimWriter (pwszWriterName, pwszTargetPath) {};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    };


static CShimWriterWMI ShimWriterWMI (APPLICATION_STRING, TARGET_PATH);

PCShimWriter pShimWriterWMI = &ShimWriterWMI;




/*
**++
**
**  Routine Description:
**
**	The Terminal Services Licensing Server database snapshot
**	writer DoIdentify() function.
**
**
**  Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
**  Return Value:
**
**	Any HRESULT from adding items to backup metadata document.
**
**-- 
*/

HRESULT CShimWriterWMI::DoIdentify ()
    {
    HRESULT	hrStatus;


    hrStatus = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							  NULL,
							  COMPONENT_NAME,
							  COMPONENT_NAME,
							  NULL, // icon
							  0,
							  true,
							  false,
							  false);

    LogFailure (NULL, 
		hrStatus, 
		hrStatus, 
		m_pwszWriterName, 
		L"IVssCreateWriterMetadata::AddComponent", 
		L"CShimWriterWMI::DoIdentify");



    if (SUCCEEDED (hrStatus))
	{
	hrStatus = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								     COMPONENT_NAME,
								     m_pwszTargetPath,
								     L"*",
								     true,
								     NULL);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"IVssCreateWriterMetadata::AddFilesToFileGroup", 
		    L"CShimWriterWMI::DoIdentify");
	}



    if (SUCCEEDED (hrStatus))
	{
	hrStatus = m_pIVssCreateWriterMetadata->AddExcludeFiles (REPOSITORY_PATH,
								 L"*",
								 true);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"IVssCreateWriterMetadata::AddExcludeFiles", 
		    L"CShimWriterWMI::DoIdentify");
	}


    return (hrStatus);
    } /* CShimWriterWMI::DoIdentify () */


/*
**++
**
**  Routine Description:
**
**	The WMI writer PrepareForFreeze function.  Currently all of the
**	real work for this writer happens here.
**
**
**  Arguments:
**
**	Same arguments as those passed in the PrepareForFreeze event.
**
**
**  Return Value:
**
**	Any HRESULT from string allocation or Wbem calls to create an
**	interface pointer or calls to backup through that interface.
**
**--
*/

HRESULT CShimWriterWMI::DoPrepareForSnapshot ()
    {
    HRESULT		 hrStatus            = NOERROR;
    BOOL		 bInstanceCreated    = FALSE;
    IWbemBackupRestore	*pIWbemBackupRestore = NULL ;
    UNICODE_STRING	 ucsTargetPath;
    UNICODE_STRING	 ucsSourcePath;



    StringInitialise (&ucsSourcePath);
    StringInitialise (&ucsTargetPath);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsSourcePath,
						   REPOSITORY_PATH);
	}



    if (SUCCEEDED (hrStatus))
	{
	hrStatus = IsPathInVolumeArray (ucsSourcePath.Buffer,
					m_ulVolumeCount,
					m_ppwszVolumeNamesArray,
					&m_bParticipateInBackup);
	}



    if (SUCCEEDED (hrStatus) && m_bParticipateInBackup)
	{
	hrStatus = StringCreateFromExpandedString (&ucsTargetPath,
						   m_pwszTargetPath,
						   ucsBackupFilename.Length);
	}



    if (SUCCEEDED (hrStatus) && m_bParticipateInBackup)
	{
	StringAppendString (&ucsTargetPath, &ucsBackupFilename);


	/*
	** We can be certain that we've already had a call to
	** CoInitialzeEx() in this thread, so we can just go ahead and
	** make our COM calls.
	*/
	hrStatus = CoCreateInstance (CLSID_WbemBackupRestore, 
				     NULL, 
				     CLSCTX_LOCAL_SERVER, 
				     IID_IWbemBackupRestore, 
				     (LPVOID*)&pIWbemBackupRestore);

	bInstanceCreated = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"CoCreateInstance", 
		    L"CShimWriterWMI::DoPrepareForSnapshot");
	}



    if (SUCCEEDED (hrStatus) && m_bParticipateInBackup)
	{
	hrStatus = pIWbemBackupRestore->Backup (ucsTargetPath.Buffer, 
						WBEM_FLAG_BACKUP_RESTORE_DEFAULT);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"IWbemBackupRestore::Backup", 
		    L"CShimWriterWMI::DoPrepareForSnapshot");
	}




    if (bInstanceCreated) pIWbemBackupRestore->Release ();

    StringFree (&ucsTargetPath);
    StringFree (&ucsSourcePath);


    return (hrStatus);
    } /* CShimWriterWMI::DoPrepareForSnapshot () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\samples\requestor\main.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	main.cpp
**
**
** Abstract:
**
**	Sample program to
**      - obtain and display the Writer metadata.
**      - create a snapshot set
**
** Author:
**
**	Adi Oltean      [aoltean]       05-Dec-2000
**
**  The sample is based on the Metasnap test program  written by Michael C. Johnson.
**
**
** Revision History:
**
**--
*/


///////////////////////////////////////////////////////////////////////////////
// Includes

#include "vsreq.h"


///////////////////////////////////////////////////////////////////////////////
// Main functions


extern "C" __cdecl wmain(int argc, WCHAR **argv)
{
    INT     nReturnCode = 0;

    try
	{
        CVssSampleRequestor requestor;

        // Parsing the command line
        // Eliminate the first argument (program name)
        requestor.ParseCommandLine( argc-1, argv+1 );

        // Initialize internal objects
        requestor.Initialize();

        // Gather writer status
        requestor.GatherWriterMetadata();

        // Create snapshot set, if needed
        requestor.CreateSnapshotSet();

        // Wait for user input
        wprintf(L"\nPress <Enter> to continue...\n");
        getwchar();

        // Complete the backup
        requestor.BackupComplete();
	}
    catch(INT nCatchedReturnCode)
	{
    	nReturnCode = nCatchedReturnCode;
	}

    return (nReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrconfig.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrconfig.cpp | Implementation of SnapshotWriter for Config directory



Author:

    Michael C. Johnson [mikejohn] 18-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-11	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-20	MCJ		Michael C. Johnson		13-Sep-2000
		178282: Writer should only generate backup file if source 
			path is in volume list.

	X-19	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-18	MCJ		Michael C. Johnson		20-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.

	X-17	MCJ		Michael C. Johnson		12-Jun-2000
		Generate metadata in new DoIdentify() routine. Also this is
		not a bootable state writer.

	X-16	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()

	X-15	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-5	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-4	MCJ		Michael C. Johnson		 3-Mar-2000
		Determine correct errors (if any) during copy file scan loop
		in PrepareToSync and fail the operation if appropriate.

	X-3	MCJ		Michael C. Johnson		 2-Mar-2000
		Do a preparatory cleanup of the target save directory to make
		sure we don't have to deal with any junk left from a previous
		invokcation.
		Also be smarter about what we copy. In particular, there is
		no need to copy the registry related files or the event logs.

	X-2	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.

	X-1	MCJ		Michael C. Johnson		18-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.


--*/


#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHCONFC"
//
////////////////////////////////////////////////////////////////////////

/*
** The save path has a standard form which is
**
**	%SystemRoot%\Repair\Backup,
**
** followed by the application writer string as publised in the export
** table followed by whatever else the writer requires.
*/
#define APPLICATION_STRING			L"ConfigDirectory"
#define COMPONENT_NAME				L"Config Directory"

#define TARGET_PATH				ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING
#define CONFIGDIR_SOURCE_PATH			L"%SystemRoot%\\system32\\config"


#define REGISTRY_SUBKEY_HIVELIST		L"SYSTEM\\CurrentControlSet\\Control\\hivelist"

#define EVENTLOG_SUBKEY_EVENTLOG		L"SYSTEM\\CurrentControlSet\\Services\\Eventlog"
#define EVENTLOG_VALUENAME_FILE			L"File"


#define REGISTRY_BUFFER_SIZE			(4096)
#define EVENTLOG_BUFFER_SIZE			(4096)

DeclareStaticUnicodeString (ucsHiveRecognitionPrefix, L"\\Device\\");


typedef struct _VertexRecord
    {
    UNICODE_STRING	ucsVertexName;
    } VERTEXRECORD, *PVERTEXRECORD, **PPVERTEXRECORD;


static PVOID NTAPI VertexAllocateNode (PRTL_GENERIC_TABLE pTable,
				       CLONG              clByteSize);

static VOID NTAPI VertexFreeNode (PRTL_GENERIC_TABLE pTable,
				  PVOID              pvBuffer);

static RTL_GENERIC_COMPARE_RESULTS NTAPI VertexCompareNode (PRTL_GENERIC_TABLE pTable,
							    PVOID              pvNode1,
							    PVOID              pvNode2);


/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterConfigDir : public CShimWriter
    {
public:
    CShimWriterConfigDir (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) : 
		CShimWriter (pwszWriterName, pwszTargetPath) 
	{
	PVOID	pvTableContext = NULL;

	RtlInitializeGenericTable (&m_StopList,
				   VertexCompareNode,
				   VertexAllocateNode,
				   VertexFreeNode,
				   pvTableContext);
	};


private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);

    HRESULT CopyConfigDirFiles       (VOID);
    HRESULT PopulateStopList         (VOID);
    HRESULT PopulateStopListEventlog (VOID);
    HRESULT PopulateStopListRegistry (VOID);
    HRESULT CleanupStopList          (VOID);
    BOOL    FileInStopList           (PWCHAR pwszFilename);
    HRESULT VertexAdd                (PUNICODE_STRING pucsVertexName);

    RTL_GENERIC_TABLE	m_StopList;
    };


static CShimWriterConfigDir ShimWriterConfigDir (APPLICATION_STRING, TARGET_PATH);

PCShimWriter pShimWriterConfigDir = &ShimWriterConfigDir;



static PVOID NTAPI VertexAllocateNode (PRTL_GENERIC_TABLE pTable,
				       CLONG              clByteSize)
    {
    PVOID	pvBuffer;

    pvBuffer = HeapAlloc (GetProcessHeap (), HEAP_ZERO_MEMORY, clByteSize);

    return (pvBuffer);
    }



static VOID NTAPI VertexFreeNode (PRTL_GENERIC_TABLE pTable,
				  PVOID              pvBuffer)
    {
    HeapFree (GetProcessHeap (), 0, pvBuffer);

    return;
    }



/*
** In this usage of the package I don't actually care about ordering,
** just so long as I can re-find vertex information. To this end we
** need to specify the search 'key'. So, the 'key' is defined to be
** the file name and is expected to be unique to a vertex. If this
** changes then we'll need to re-visit this.
*/

static RTL_GENERIC_COMPARE_RESULTS NTAPI VertexCompareNode (PRTL_GENERIC_TABLE pTable,
							    PVOID              pvNode1,
							    PVOID              pvNode2)
    {
    PVERTEXRECORD		pVertex1   = (PVERTEXRECORD) pvNode1;
    PVERTEXRECORD		pVertex2   = (PVERTEXRECORD) pvNode2;
    RTL_GENERIC_COMPARE_RESULTS	Result;
    INT				iStringCompareResult;


    iStringCompareResult = RtlCompareUnicodeString (&pVertex1->ucsVertexName,
						    &pVertex2->ucsVertexName,
						    TRUE);

    if (iStringCompareResult < 0)
	{
	Result = GenericLessThan;
	}

    else if (iStringCompareResult > 0)
	{
	Result = GenericGreaterThan;
	}

    else
	{
	Result = GenericEqual;
	}


    return (Result);
    }



HRESULT CShimWriterConfigDir::VertexAdd (PUNICODE_STRING pucsVertexName)
    {
    HRESULT		Status = NOERROR;
    PVERTEXRECORD	pVertexRecord;
    PVERTEXRECORD	pNewVertexRecord;
    BOOLEAN		bNewElement;
    ULONG		ulVertexNodeSize = sizeof (VERTEXRECORD) +
					   sizeof (UNICODE_NULL) +
					   pucsVertexName->Length;


    pVertexRecord = (PVERTEXRECORD) HeapAlloc (GetProcessHeap(),
					       HEAP_ZERO_MEMORY,
					       ulVertexNodeSize);

    Status = GET_STATUS_FROM_POINTER (pVertexRecord);



    if (SUCCEEDED (Status))
	{
	/*
	** Fill in enough of the node to allow it to be inserted into
	** the table. We will need to fix up the unicode string buffer
	** address after insertion.
	*/
	pVertexRecord->ucsVertexName.Buffer        = (PWCHAR)((PBYTE)pVertexRecord + sizeof (VERTEXRECORD));
	pVertexRecord->ucsVertexName.Length        = 0;
	pVertexRecord->ucsVertexName.MaximumLength = (USHORT)(sizeof (UNICODE_NULL) + pucsVertexName->Length);

	RtlCopyUnicodeString (&pVertexRecord->ucsVertexName, pucsVertexName);


	pNewVertexRecord = (PVERTEXRECORD) RtlInsertElementGenericTable (&m_StopList,
									 pVertexRecord,
									 ulVertexNodeSize,
									 &bNewElement);


	if (NULL == pNewVertexRecord)
	    {
	    /*
	    ** An allocation attempt failed. Setup an appropriate return
	    ** status
	    */
	    Status = E_OUTOFMEMORY;
	    }

	else if (!bNewElement)
	    {
	    /*
	    ** Oh oh, this is a duplicate. Setup an appropriate return
	    ** status.
	    */
	    Status = HRESULT_FROM_WIN32 (ERROR_DUP_NAME);
	    }

	else
	    {
	    /*
	    ** If we have a record and it's a new record then we need to
	    ** fix up the address of the unicode string to make it point
	    ** to the string in the newly inserted node rather than the
	    ** record we constructed to do the insertion.
	    */
	    pNewVertexRecord->ucsVertexName.Buffer = (PWCHAR)((PBYTE)pNewVertexRecord + sizeof (VERTEXRECORD));
	    }
	}


    if (NULL != pVertexRecord)
	{
	HeapFree (GetProcessHeap(), 0, pVertexRecord);
	}


    return (Status);
    } /* VertexAdd () */


/*
**++
**
** Routine Description:
**
**	The configuration directory snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterConfigDir::DoIdentify ()
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriterConfigDir::DoIdentify");


    try
	{
	ft.hr = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							   NULL,
							   COMPONENT_NAME,
							   COMPONENT_NAME,
							   NULL, // icon
							   0,
							   true,
							   false,
							   false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddComponent");




	ft.hr = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								  COMPONENT_NAME,
								  m_pwszTargetPath,
								  L"*",
								  true,
								  NULL);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddFilesToFileGroup");



	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (CONFIGDIR_SOURCE_PATH,
							      L"*",
							      true);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles");

	} VSS_STANDARD_CATCH (ft)



    return (ft.hr);
    } /* CShimWriterConfigDir::DoIdentify () */



/*++

Routine Description:

    The Cluster database snapshot writer PrepareForSnapshot function.
    Currently all of the real work for this writer happens here.

Arguments:

    Same arguments as those passed in the PrepareForSnapshot event.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterConfigDir::DoPrepareForSnapshot ()
    {
    HRESULT		hrStatus;
    UNICODE_STRING	ucsSourcePath;


    StringInitialise (&ucsSourcePath);

    hrStatus = StringCreateFromExpandedString (&ucsSourcePath,
					       CONFIGDIR_SOURCE_PATH);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = IsPathInVolumeArray (ucsSourcePath.Buffer,
					m_ulVolumeCount,
					m_ppwszVolumeNamesArray,
					&m_bParticipateInBackup);
	}



    if (SUCCEEDED (hrStatus) && m_bParticipateInBackup)
	{
	hrStatus = PopulateStopList ();
	}


    if (SUCCEEDED (hrStatus) && m_bParticipateInBackup)
	{
	hrStatus = CopyConfigDirFiles ();
	}


    CleanupStopList ();
    StringFree (&ucsSourcePath);

    return (hrStatus);
    } /* CShimWriterConfigDir::DoPrepareForSnapshot () */



HRESULT CShimWriterConfigDir::PopulateStopList ()
    {
    HRESULT	hrStatus;


    /*
    ** We have a table (initialized in the constructor. Now we need to
    ** get the names of the files to add to the StopList. This will
    ** prevent the copy from attempting to copy these files. First we
    ** populate with registry files we don't want to copy, then with
    ** event log files that we don't want either.
    */
    hrStatus = PopulateStopListRegistry ();

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = PopulateStopListEventlog ();
	}


    return (hrStatus);
    } /* CShimWriterConfigDir::PopulateStopList () */



HRESULT CShimWriterConfigDir::PopulateStopListEventlog ()
    {
    HRESULT		hrStatus                    = NOERROR;
    DWORD		winStatus;
    DWORD		dwIndex                     = 0;
    HKEY		hkeyEventLogList            = NULL;
    BOOL		bSucceeded                  = FALSE;
    BOOL		bEventLogListKeyOpened      = FALSE;
    BOOL		bEventLogValueFileKeyOpened = FALSE;
    BOOL		bContinueEventLogSearch     = TRUE;
    UNICODE_STRING	ucsConfigDirSourcePath;
    UNICODE_STRING	ucsEventLogSourcePath;
    UNICODE_STRING	ucsValueData;
    UNICODE_STRING	ucsSubkeyName;


    StringInitialise (&ucsConfigDirSourcePath);
    StringInitialise (&ucsValueData);
    StringInitialise (&ucsSubkeyName);


    hrStatus = StringAllocate (&ucsSubkeyName, EVENTLOG_BUFFER_SIZE * sizeof (WCHAR));

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, EVENTLOG_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsConfigDirSourcePath,
						   CONFIGDIR_SOURCE_PATH,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	StringAppendString (&ucsConfigDirSourcePath, DIR_SEP_STRING);


	/*
	** We now have all the pieces in place so go search the eventlog list
	** for the logs to deal with.
	*/
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   EVENTLOG_SUBKEY_EVENTLOG,
				   0L,
				   KEY_READ,
				   &hkeyEventLogList);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	bEventLogListKeyOpened = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (eventlog list)", 
		    L"CShimWriterConfigDir::PopulateStopListEventlog");
	}



    while (SUCCEEDED (hrStatus) && bContinueEventLogSearch)
	{
	HKEY	hkeyEventLogValueFile       = NULL;
 	DWORD	dwSubkeyNameLength          = ucsSubkeyName.MaximumLength / sizeof (WCHAR);


	StringTruncate (&ucsSubkeyName, 0);

	winStatus = RegEnumKeyExW (hkeyEventLogList,
				   dwIndex,
				   ucsSubkeyName.Buffer,
				   &dwSubkeyNameLength,
				   NULL,
				   NULL,
				   NULL,
				   NULL);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);


	if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hrStatus)
	    {
	    hrStatus = NOERROR;

	    bContinueEventLogSearch = FALSE;
	    }

	else if (FAILED (hrStatus))
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegEnumKeyExW", 
			L"CShimWriterConfigDir::PopulateStopListEventlog");
	    }

	else
	    {
	    ucsSubkeyName.Length = (USHORT)(dwSubkeyNameLength * sizeof (WCHAR));

	    ucsSubkeyName.Buffer [ucsSubkeyName.Length / sizeof (WCHAR)] = UNICODE_NULL;



	    winStatus = RegOpenKeyExW (hkeyEventLogList,
				       ucsSubkeyName.Buffer,
				       0L,
				       KEY_QUERY_VALUE,
				       &hkeyEventLogValueFile);

	    hrStatus = HRESULT_FROM_WIN32 (winStatus);

	    bEventLogValueFileKeyOpened = SUCCEEDED (hrStatus);

	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegOpenKeyExW (eventlog name)", 
			L"CShimWriterConfigDir::PopulateStopListEventlog");



	    if (SUCCEEDED (hrStatus))
		{
		DWORD	dwValueDataLength = ucsValueData.MaximumLength;
		DWORD	dwValueType       = REG_NONE;


		StringTruncate (&ucsValueData, 0);

		winStatus = RegQueryValueExW (hkeyEventLogValueFile,
					      EVENTLOG_VALUENAME_FILE,
					      NULL,
					      &dwValueType,
					      (PBYTE)ucsValueData.Buffer,
					      &dwValueDataLength);

		hrStatus = HRESULT_FROM_WIN32 (winStatus);

		LogFailure (NULL, 
			    hrStatus, 
			    hrStatus, 
			    m_pwszWriterName, 
			    L"RegQueryValueExW", 
			    L"CShimWriterConfigDir::PopulateStopListEventlog");



		if (SUCCEEDED (hrStatus) && (REG_EXPAND_SZ == dwValueType))
		    {
		    HANDLE	hEventLog    = NULL;
		    PWCHAR	pwszFilename;


		    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

		    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;



		    StringInitialise (&ucsEventLogSourcePath);

		    hrStatus = StringCreateFromExpandedString (&ucsEventLogSourcePath,
							       ucsValueData.Buffer,
							       0);



		    if (SUCCEEDED (hrStatus))
			{
			BOOL	bInConfigDir = RtlPrefixUnicodeString (&ucsConfigDirSourcePath,
								       &ucsEventLogSourcePath,
								       TRUE);

			if (bInConfigDir)
			    {
			    pwszFilename = wcsrchr (ucsEventLogSourcePath.Buffer, DIR_SEP_CHAR);

			    pwszFilename = (NULL == pwszFilename)
						? ucsEventLogSourcePath.Buffer
						: pwszFilename + 1;

			    StringTruncate (&ucsValueData, 0);
			    StringAppendString (&ucsValueData, pwszFilename);

			    hrStatus = VertexAdd (&ucsValueData);
			    }
			}


		    StringFree (&ucsEventLogSourcePath);
		    }
		}


	    if (bEventLogValueFileKeyOpened)
		{
		RegCloseKey (hkeyEventLogValueFile);
		}


	    /*
	    ** Done with this value so go look for another.
	    */
	    dwIndex++;
	    }
	}




    if (bEventLogListKeyOpened)
	{
	RegCloseKey (hkeyEventLogList);
	}


    StringFree (&ucsValueData);
    StringFree (&ucsSubkeyName);
    StringFree (&ucsConfigDirSourcePath);


    return (hrStatus);
    } /* CShimWriterConfigDir::PopulateStopListEventlog () */


HRESULT CShimWriterConfigDir::PopulateStopListRegistry ()
    {
    HRESULT		hrStatus            = NOERROR;
    HKEY		hkeyHivelist        = NULL;
    INT			iIndex              = 0;
    BOOL		bHivelistKeyOpened  = FALSE;
    BOOL		bContinueHiveSearch = TRUE;
    DWORD		winStatus;
    PWCHAR		pwchLastSlash;
    PWCHAR		pwszFilename;
    USHORT		usRegistryHivePathOriginalLength;
    UNICODE_STRING	ucsRegistryHivePath;
    UNICODE_STRING	ucsHiveRecognitionPostfix;
    UNICODE_STRING	ucsValueName;
    UNICODE_STRING	ucsValueData;


    StringInitialise (&ucsRegistryHivePath);
    StringInitialise (&ucsHiveRecognitionPostfix);
    StringInitialise (&ucsValueName);
    StringInitialise (&ucsValueData);


    hrStatus = StringAllocate (&ucsValueName, REGISTRY_BUFFER_SIZE * sizeof (WCHAR));

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, REGISTRY_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsRegistryHivePath,
						   CONFIGDIR_SOURCE_PATH,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	DWORD	dwCharIndex;


	StringAppendString (&ucsRegistryHivePath, DIR_SEP_STRING);

	usRegistryHivePathOriginalLength = ucsRegistryHivePath.Length / sizeof (WCHAR);



	/*
	** Now we know the location of the hive files, determine the
	** postfix we are going to use to recognise hives when we
	** search the active hivelist key. To do this we just need to
	** lose the drive letter and the colon in the path, or to put
	** it another way, lose everthing before the first '\'. When
	** we are done, if everything works ucsRegistryHivePath will
	** look something like '\Windows\system32\config\'
	*/
	for (dwCharIndex = 0;
	     (dwCharIndex < (ucsRegistryHivePath.Length / sizeof (WCHAR)))
		 && (DIR_SEP_CHAR != ucsRegistryHivePath.Buffer [dwCharIndex]);
	     dwCharIndex++)
	    {
	    /*
	    ** Empty loop body
	    */
	    }

	BS_ASSERT (dwCharIndex < (ucsRegistryHivePath.Length / sizeof (WCHAR)));

	hrStatus = StringCreateFromString (&ucsHiveRecognitionPostfix, 
					   &ucsRegistryHivePath.Buffer [dwCharIndex]);
	}


    if (SUCCEEDED (hrStatus))
	{
	/*
	** We now have all the pieces in place so go search the
	** hivelist for the hives to deal with.
	*/
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   REGISTRY_SUBKEY_HIVELIST,
				   0L,
				   KEY_QUERY_VALUE,
				   &hkeyHivelist);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	bHivelistKeyOpened = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (hive list)", 
		    L"CShimWriterConfigDir::PopulateStopListRegistry");
	}



    while (SUCCEEDED (hrStatus) && bContinueHiveSearch)
	{
	DWORD	dwValueNameLength = ucsValueName.MaximumLength / sizeof (WCHAR);
	DWORD	dwValueDataLength = ucsValueData.MaximumLength;
	DWORD	dwValueType       = REG_NONE;
	BOOL	bMatchPrefix;
	BOOL	bMatchPostfix;


	StringTruncate (&ucsValueName, 0);
	StringTruncate (&ucsValueData, 0);


	/*
	** should be of type REG_SZ
	*/
	winStatus = RegEnumValueW (hkeyHivelist,
				   iIndex,
				   ucsValueName.Buffer,
				   &dwValueNameLength,
				   NULL,
				   &dwValueType,
				   (PBYTE)ucsValueData.Buffer,
				   &dwValueDataLength);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);


	if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hrStatus)
	    {
	    hrStatus = NOERROR;

	    bContinueHiveSearch = FALSE;
	    }

	else if (FAILED (hrStatus))
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegEnumValueW", 
			L"CShimWriterConfigDir::PopulateStopListEventlog");
	    }

	else
	    {
	    UNICODE_STRING	ucsPostFix;

	    BS_ASSERT ((REG_SZ == dwValueType) && L"Not REG_SZ string as expected");

	    ucsValueName.Length = (USHORT)(dwValueNameLength * sizeof (WCHAR));
	    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

	    ucsValueName.Buffer [ucsValueName.Length / sizeof (WCHAR)] = UNICODE_NULL;
	    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;


	    /*
	    ** If it's to be considered part of system state the hive
	    ** file itself must live in %SystemRoot%\system32\config
	    ** so we attempt to find something in the returned value
	    ** name which looks like it might match. The format of the
	    ** name we are expecting is something like
	    **
	    **	\Device\<Volume>\Windows\system32\config\filename
	    **
	    ** for a system which has system32 in the 'Windows'
	    ** directory.  
	    **
	    ** Now, we have a known prefix, '\Device\', and the
	    ** postfix before and including the last '\', something
	    ** like '\Windows\system32\config\' as we determined
	    ** earlier. So we should be in a position to identify the
	    ** hives files we are interested in. Remember, we don't
	    ** know the piece representing the actual volume which is
	    ** why we are doing all this matching of pre and
	    ** post-fixs.
	    */
	    bMatchPrefix = RtlPrefixUnicodeString (&ucsHiveRecognitionPrefix,
						   &ucsValueData,
						   TRUE);


	    /*
	    ** Locate the last '\' in the value data. After this will
	    ** be the filename (eg 'SAM') which we will want later and
	    ** before that should be the postfix (eg
	    ** '\Windows\system32\config\') by which we will recognise
	    ** this as a registry hive.
	    */
	    pwchLastSlash = wcsrchr (ucsValueData.Buffer, DIR_SEP_CHAR);

	    if ((NULL == pwchLastSlash) ||
		(ucsValueData.Length < (ucsHiveRecognitionPrefix.Length + ucsHiveRecognitionPostfix.Length)))
		{
		/*
		** We coundn't find a '\' or the value data wasn't
		** long enough.
		*/
		bMatchPostfix = FALSE;
		}
	    else
		{
		/*
		** Determine the name of the give file.
		*/
		pwszFilename = pwchLastSlash + 1;


		/*
		** Determine the postfix we are going to try to match
		** against. This should look something like
		** '\Windows\system32\config\SAM'.
		*/
		StringInitialise (&ucsPostFix,
				  pwszFilename - (ucsHiveRecognitionPostfix.Length / sizeof (WCHAR)));


		/*
		** See if the recognition string (eg
		** '\Windows\system32\config\') is a prefix of the
		** location of this hive file (eg
		** '\Windows\system32\config\SAM')
		*/
		bMatchPostfix = RtlPrefixUnicodeString (&ucsHiveRecognitionPostfix,
							&ucsPostFix,
							TRUE);
		}


	    if (bMatchPrefix && bMatchPostfix)
		{
		USHORT	usOriginalFilenameLength;


		/*
		** We got ourselves a real live registry hive! The
		** means we add the filename itself along with the
		** same name with .sav, .alt and .log extensions.
		*/
		StringTruncate (&ucsRegistryHivePath, 0);
		StringAppendString (&ucsRegistryHivePath, pwszFilename);

		usOriginalFilenameLength = ucsRegistryHivePath.Length / sizeof (WCHAR);


		hrStatus = VertexAdd (&ucsRegistryHivePath);

		if (SUCCEEDED (hrStatus))
		    {
		    StringAppendString (&ucsRegistryHivePath, L".alt");

		    hrStatus = VertexAdd (&ucsRegistryHivePath);
		    }

		if (SUCCEEDED (hrStatus))
		    {
		    StringTruncate     (&ucsRegistryHivePath, usOriginalFilenameLength);
		    StringAppendString (&ucsRegistryHivePath, L".sav");

		    hrStatus = VertexAdd (&ucsRegistryHivePath);
		    }

		if (SUCCEEDED (hrStatus))
		    {
		    StringTruncate     (&ucsRegistryHivePath, usOriginalFilenameLength);
		    StringAppendString (&ucsRegistryHivePath, L".log");

		    hrStatus = VertexAdd (&ucsRegistryHivePath);
		    }
		}


	    /*
	    ** Done with this value so go look for another.
	    */
	    iIndex++;
	    }
	}




    if (bHivelistKeyOpened)
	{
	RegCloseKey (hkeyHivelist);
	}

    StringFree (&ucsHiveRecognitionPostfix);
    StringFree (&ucsRegistryHivePath);
    StringFree (&ucsValueData);
    StringFree (&ucsValueName);



    return (hrStatus);
    } /* CShimWriterConfigDir::PopulateStopListRegistry () */



HRESULT CShimWriterConfigDir::CleanupStopList ()
    {
    HRESULT		hrStatus          = NOERROR;
    ULONG		ulNumberOfEntries = RtlNumberGenericTableElements (&m_StopList);
    BOOL		bSucceeded        = FALSE;
    PVERTEXRECORD	pSearchRecord     = NULL;
    PVERTEXRECORD	pStopListEntry;


    pSearchRecord = (PVERTEXRECORD) HeapAlloc (GetProcessHeap (),
					       HEAP_ZERO_MEMORY,
					       sizeof (VERTEXRECORD) + (MAX_PATH * sizeof (WCHAR)));

    hrStatus = GET_STATUS_FROM_POINTER (pSearchRecord);



    if (SUCCEEDED (hrStatus))
	{
	StringInitialise (&pSearchRecord->ucsVertexName);

	pSearchRecord->ucsVertexName.Buffer = (PWCHAR)((PBYTE)pSearchRecord + sizeof (VERTEXRECORD));
	}



    while (SUCCEEDED (hrStatus) && ulNumberOfEntries--)
	{
	pStopListEntry = (PVERTEXRECORD) RtlGetElementGenericTable (&m_StopList, ulNumberOfEntries);

	StringCreateFromString (&pSearchRecord->ucsVertexName, &pStopListEntry->ucsVertexName);

	bSucceeded = RtlDeleteElementGenericTable (&m_StopList, pSearchRecord);
	}



    BS_ASSERT (RtlIsGenericTableEmpty (&m_StopList));


    if (NULL != pSearchRecord)
	{
	HeapFree (GetProcessHeap (), 0, pSearchRecord);
	}


    return (hrStatus);
    } /* CShimWriterConfigDir::CleanupStopList () */


BOOL CShimWriterConfigDir::FileInStopList (PWCHAR pwszFilename)
    {
    BOOL		bFoundInStoplist;
    VERTEXRECORD	SearchRecord;
    PVERTEXRECORD	pVertexRecord;



    bFoundInStoplist = NameIsDotOrDotDot (pwszFilename);

    if (!bFoundInStoplist)
	{
	StringCreateFromString (&SearchRecord.ucsVertexName, pwszFilename);

	pVertexRecord = (PVERTEXRECORD) RtlLookupElementGenericTable (&m_StopList, (PVOID) &SearchRecord);

	bFoundInStoplist = (NULL != pVertexRecord);

	StringFree (&SearchRecord.ucsVertexName);
	}


    return (bFoundInStoplist);
    } /* CShimWriterConfigDir::FileInStopList () */


HRESULT CShimWriterConfigDir::CopyConfigDirFiles ()
    {
    CVssFunctionTracer ft( VSSDBG_SHIM, L"CShimWriterConfigDir::CopyConfigDirFiles" );        
    HRESULT		hrStatus   = NOERROR;
    BOOL		bMoreFiles = FALSE;
    BOOL		bSucceeded;
    HANDLE		hFileScan;
    WIN32_FIND_DATA	sFileInformation;
    UNICODE_STRING	ucsFileSourcePath;
    UNICODE_STRING	ucsFileTargetPath;
    USHORT		usFileSourcePathOriginalLength;
    USHORT		usFileTargetPathOriginalLength;

    StringInitialise (&ucsFileSourcePath);
    StringInitialise (&ucsFileTargetPath);


    hrStatus = StringCreateFromExpandedString (&ucsFileSourcePath,
					       CONFIGDIR_SOURCE_PATH,
					       MAX_PATH);

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsFileTargetPath,
						   m_pwszTargetPath,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	StringAppendString (&ucsFileSourcePath, DIR_SEP_STRING);
	StringAppendString (&ucsFileTargetPath, DIR_SEP_STRING);


	usFileSourcePathOriginalLength = ucsFileSourcePath.Length / sizeof (WCHAR);
	usFileTargetPathOriginalLength = ucsFileTargetPath.Length / sizeof (WCHAR);


	StringAppendString (&ucsFileSourcePath, L"*");


	hFileScan = FindFirstFileW (ucsFileSourcePath.Buffer,
				    &sFileInformation);

	hrStatus = GET_STATUS_FROM_HANDLE (hFileScan);

	LogFailure (&ft, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"FindFirstFileW", 
		    L"CShimWriterConfigDir::CopyConfigDirFiles");
	}


    if (SUCCEEDED (hrStatus))
	{
	do
	    {
	    if (!FileInStopList (sFileInformation.cFileName))
		{
		StringTruncate (&ucsFileSourcePath, usFileSourcePathOriginalLength);
		StringTruncate (&ucsFileTargetPath, usFileTargetPathOriginalLength);

		StringAppendString (&ucsFileSourcePath, sFileInformation.cFileName);
		StringAppendString (&ucsFileTargetPath, sFileInformation.cFileName);


		bSucceeded = CopyFileExW (ucsFileSourcePath.Buffer,
					  ucsFileTargetPath.Buffer,
					  NULL,
					  NULL,
					  FALSE,
					  0);

		hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

                if ( FAILED( hrStatus ) )
                    {
                    ft.Trace( VSSDBG_SHIM, L"CopyFileExW( '%s', '%s', ... ) failed with rc: %d", 
                            ucsFileSourcePath.Buffer, ucsFileTargetPath.Buffer, ::GetLastError() );
                    hrStatus = S_OK;   // Make sure to clear out the error
                    }
                }


	    bMoreFiles = FindNextFileW (hFileScan, &sFileInformation);
	    } while ( bMoreFiles );


	bSucceeded = FindClose (hFileScan);
	}



    StringFree (&ucsFileTargetPath);
    StringFree (&ucsFileSourcePath);

    return (hrStatus);
    } /* CShimWriterConfigDir::CopyConfigDirFiles () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\samples\requestor\vsreq.h ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	    vsreq.h
**
**
** Abstract:
**
**	Sample program to
**      - obtain and display the Writer metadata.
**      - create a snapshot set
**
** Author:
**
**	Adi Oltean      [aoltean]       05-Dec-2000
**
**  The sample is based on the Metasnap test program  written by Michael C. Johnson.
**
**
** Revision History:
**
**--
*/

/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/

#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string.h>

#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>


#include <oleauto.h>

#define ATLASSERT(_condition)

#include <atlconv.h>
#include <atlbase.h>

extern CComModule _Module;
#include <atlcom.h>


///////////////////////////////////////////////////////////////////////////////
// Useful macros 

#define WSTR_GUID_FMT  L"{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}"

#define GUID_PRINTF_ARG( X )                                \
    (X).Data1,                                              \
    (X).Data2,                                              \
    (X).Data3,                                              \
    (X).Data4[0], (X).Data4[1], (X).Data4[2], (X).Data4[3], \
    (X).Data4[4], (X).Data4[5], (X).Data4[6], (X).Data4[7]


// Execute the given call and check that the return code must be S_OK
#define CHECK_SUCCESS( Call )                                                                           \
    {                                                                                                   \
        m_hr = Call;                                                                                    \
        if (m_hr != S_OK)                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, m_hr, GetStringFromFailureType(m_hr));                       \
    }

#define CHECK_NOFAIL( Call )                                                                            \
    {                                                                                                   \
        m_hr = Call;                                                                                    \
        if (FAILED(m_hr))                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, m_hr, GetStringFromFailureType(m_hr));                       \
    }


///////////////////////////////////////////////////////////////////////////////
// Constants

const MAX_VOLUMES       = 64;
const MAX_TEXT_BUFFER   = 512;


///////////////////////////////////////////////////////////////////////////////
// Main class


class CVssSampleRequestor
{
// Constructors& destructors
public:
    CVssSampleRequestor();
    ~CVssSampleRequestor();

// Attributes
public:

// Operations
public:

    // Initialize internal members
    void Initialize();

    // Parse command line arguments 
    void ParseCommandLine(
        IN  INT nArgsCount,
        IN  WCHAR ** ppwszArgsArray
        );

    // Creates a snapshot set
    void CreateSnapshotSet();

    // Completes the backup
    void BackupComplete();

    void GatherWriterMetadata();

    void GatherWriterStatus(
        IN  LPCWSTR wszWhen
        );

// Private methods:
private:
    LPCWSTR GetStringFromUsageType (VSS_USAGE_TYPE eUsageType);
    LPCWSTR GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType);
    LPCWSTR GetStringFromRestoreMethod (VSS_RESTOREMETHOD_ENUM eRestoreMethod);
    LPCWSTR GetStringFromWriterRestoreMethod (VSS_WRITERRESTORE_ENUM eWriterRestoreMethod);
    LPCWSTR GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType);
    LPCWSTR GetStringFromFailureType (HRESULT hrStatus);
    LPCWSTR GetStringFromWriterStatus(VSS_WRITER_STATE eWriterStatus);

    void PrintUsage();
    void Error(INT nReturnCode, const WCHAR* pwszMsgFormat, ...);
    void PrintFiledesc (IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription);

    void AddVolumeForComponent( IN IVssWMFiledesc* pFileDesc );
    bool AddVolume( IN WCHAR* pwszVolume, OUT bool & bAdded );

// Implementation
private:
    CComPtr<IVssBackupComponents>   m_pBackupComponents;
    bool        m_bCoInitializeSucceeded;
    bool        m_bBootableSystemState;
    bool        m_bComponentSelectionEnabled;
    INT         m_nVolumesCount;
    WCHAR*      m_ppwszVolumesList[MAX_VOLUMES];
    WCHAR*      m_ppwszVolumeNamesList[MAX_VOLUMES];
    HRESULT     m_hr;
    bool        m_bMetadataGathered;
    WCHAR*      m_pwszXmlFile;
    FILE*       m_pXmlFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrregistry.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtrregistry.cpp | Implementation of SnapshotWriter for Registry hives



Author:

    Michael C. Johnson [mikejohn] 08-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-14	MCJ		Michael C. Johnson		22-Oct-2000
		209095: Dynamically load the cluster library to reduce the 
		foot print for the unclustered.

	X-13	MCJ		Michael C. Johnson		18-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-12	MCJ		Michael C. Johnson		25-Sep-2000
		185047: Leave copies of registry files in repair directory
			for compatibility with Win2k behaviour.
		182895: Need to collect cluster registry hive too.

	X-11	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-10	MCJ		Michael C. Johnson		20-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.

	X-9	MCJ		Michael C. Johnson		12-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-8	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()
 
	X-7	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-6	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-5	MCJ		Michael C. Johnson		 2-Mar-2000
		Do not copy the extra registry files as it turns out we have
		no need for them after all.
		Also do a preparatory cleanup of the save location to remove
		any old stuff left around from a previous run.

	X-4	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.

	X-3	MCJ		Michael C. Johnson		22-Feb-2000
		Add SYSTEM_STATE_SUBDIR to registry save path.

	X-2	MCJ		Michael C. Johnson		17-Feb-2000
		Modify save path to be consistent with standard.

	X-1	MCJ		Michael C. Johnson		08-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.


--*/


#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"
#include <aclapi.h>
#include <clusapi.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHREGC"
//
////////////////////////////////////////////////////////////////////////

/*
** The save path has a standard form which is
**
**	%SystemRoot%\Repair\Backup,
**
** followed by the application writer string as publised in the export
** table followed by whatever else the writer requires.
*/
#define APPLICATION_STRING			L"Registry"
#define COMPONENT_NAME				APPLICATION_STRING

#define TARGET_PATH				ROOT_BACKUP_DIR BOOTABLE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING
#define REGISTRY_HIVE_PATH			L"%SystemRoot%\\system32\\config"

#define REGISTRY_SUBKEY_HIVELIST		L"SYSTEM\\CurrentControlSet\\Control\\hivelist"

#define REGISTRY_BUFFER_SIZE			(4096)

#define REPAIR_PATH				L"%SystemRoot%\\Repair\\"

#define	CLUSTER_HIVE_PATH			L"%SystemRoot%\\Cluster"
#define	CLUSTER_SUBKEY_HIVE_NAME		L"Cluster"


DeclareStaticUnicodeString (ucsHiveRecognitionPrefix,    L"\\Device\\");
DeclareStaticUnicodeString (ucsValueNameMachinePrefix,   L"\\REGISTRY\\MACHINE\\");
DeclareStaticUnicodeString (ucsValueNameUserPrefix,      L"\\REGISTRY\\USER\\");

DeclareStaticUnicodeString (ucsValuenameClusterHivefile, L"\\REGISTRY\\MACHINE\\Cluster");
DeclareStaticUnicodeString (ucsClusterHiveFilename,      L"ClusDb");



typedef DWORD	(WINAPI *PFnGetNodeClusterState)(LPCWSTR, PDWORD);


/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterRegistry : public CShimWriter
    {
public:
    CShimWriterRegistry (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath, BOOL bParticipateInBootableState) :
		CShimWriter (pwszWriterName, pwszTargetPath, bParticipateInBootableState),
		m_pfnDynamicGetNodeClusterState (NULL),
		m_hmodClusApi                   (NULL) {};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    HRESULT DoThaw (VOID);
    HRESULT DoAbort (VOID);

    HRESULT BackupRegistryHives (VOID);
    HRESULT BackupClusterHives (VOID);

    HRESULT DynamicRoutinesLoadCluster (VOID);
    HRESULT DynamicRoutinesUnloadAll   (VOID);


    PFnGetNodeClusterState	m_pfnDynamicGetNodeClusterState;
    HMODULE			m_hmodClusApi;
    };


static CShimWriterRegistry ShimWriterRegistry (APPLICATION_STRING, TARGET_PATH, TRUE);

PCShimWriter pShimWriterRegistry = &ShimWriterRegistry;



/*
**++
**
** Routine Description:
**
**	This routine loads the required Cluster DLL and obtains the
**	entry points of the routines we care about. All the pertinent
**	information is tucked away safely in the class.
**
**
** Arguments:
**
**	None
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRegistry::DynamicRoutinesLoadCluster ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterRegistry::DynamicRoutinesLoadCluster");


    try 
	{
	if ((NULL != m_pfnDynamicGetNodeClusterState)   ||
	    !HandleInvalid (m_hmodClusApi))
	    {
	    ft.hr = HRESULT_FROM_WIN32 (ERROR_ALREADY_INITIALIZED);

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"CheckingVariablesClean");
	    }



	m_hmodClusApi = LoadLibraryW (L"ClusApi.dll");

	ft.hr = GET_STATUS_FROM_HANDLE (m_hmodClusApi);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"LoadLibraryW (ClusApi.dll)");



	m_pfnDynamicGetNodeClusterState = (PFnGetNodeClusterState) GetProcAddress (m_hmodClusApi, "GetNodeClusterState");

	ft.hr = GET_STATUS_FROM_BOOL (NULL != m_pfnDynamicGetNodeClusterState);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetProcAddress (GetNodeClusterState)");

	} VSS_STANDARD_CATCH (ft)



    if (ft.HrFailed ())
	{
	if (!HandleInvalid (m_hmodClusApi)) FreeLibrary (m_hmodClusApi);

	m_pfnDynamicGetNodeClusterState   = NULL;
	m_hmodClusApi                     = NULL;
	}


    return (ft.hr);
    } /* CShimWriterRegistry::DynamicRoutinesLoadCluster () */

/*
**++
**
** Routine Description:
**
**	This routine loads the required Network DLL and obtains the
**	entry points of the routines we care about. All the pertinent
**	information is tucked away safely in the class.
**
**
** Arguments:
**
**	None
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRegistry::DynamicRoutinesUnloadAll ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterRegistry::DynamicRoutinesUnloadAll");


    try 
	{
	if (!HandleInvalid (m_hmodClusApi)) FreeLibrary (m_hmodClusApi);

	m_pfnDynamicGetNodeClusterState   = NULL;
	m_hmodClusApi                     = NULL;
	} VSS_STANDARD_CATCH (ft)


    return (ft.hr);
    } /* CShimWriterRegistry::DynamicRoutinesUnloadAll () */

/*
**++
**
** Routine Description:
**
**	The Registry snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRegistry::DoIdentify ()
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriterRegistry::DoIdentify");

    DWORD		winStatus;
    DWORD		dwClusterNodeState;
    BOOL		bClusterRunning = FALSE;



    try
	{
	ft.hr = DynamicRoutinesLoadCluster ();

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"DynamicRoutinesLoadCluster");



	winStatus = m_pfnDynamicGetNodeClusterState (NULL, &dwClusterNodeState);

	ft.hr = HRESULT_FROM_WIN32 (winStatus);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetNodeClusterState");
 
	bClusterRunning = (ClusterStateRunning == dwClusterNodeState);



	ft.hr = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							   NULL,
							   COMPONENT_NAME,
							   COMPONENT_NAME,
							   NULL, // icon
							   0,
							   true,
							   false,
							   false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddComponent");



	ft.hr = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								  COMPONENT_NAME,
								  m_pwszTargetPath,
								  L"*",
								  true,
								  NULL);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddFilesToFileGroup");



	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (REGISTRY_HIVE_PATH,
							      L"*.log",
							      false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles (*.log)");



	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (REGISTRY_HIVE_PATH,
							      L"*.sav",
							      false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles (*.sav)");



	if (bClusterRunning)
	    {
	    ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (CLUSTER_HIVE_PATH,
								  ucsClusterHiveFilename.Buffer,
								  false);

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles");
	    }

	} VSS_STANDARD_CATCH (ft)


    DynamicRoutinesUnloadAll ();

    return (ft.hr);
    } /* CShimWriterRegistry::DoIdentify () */

/*
**++
**
**  Routine Description:
**
**	This routine invokes all the necessary functions to save all 
**	of the interesting 'system' hives.
**
**
**  Arguments:
**
**	Implicit through class
**
**
**  Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRegistry::DoPrepareForSnapshot ()
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CShimWriterRegistry::DoPrepareForSnapshot");
    DWORD		winStatus;
    DWORD		dwClusterNodeState;
    BOOL		bClusterRunning = FALSE;



    try
	{
	ft.hr = DynamicRoutinesLoadCluster ();

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"DynamicRoutinesLoadCluster");



	winStatus = m_pfnDynamicGetNodeClusterState (NULL, &dwClusterNodeState);

	ft.hr = HRESULT_FROM_WIN32 (winStatus);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"GetNodeClusterState");
 
	bClusterRunning = (ClusterStateRunning == dwClusterNodeState);



	ft.hr = BackupRegistryHives ();

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CShimWriterRegistry::BackupRegistryHives");



	if (bClusterRunning)
	    {
	    ft.hr = BackupClusterHives ();

	    LogAndThrowOnFailure (ft, m_pwszWriterName, L"CShimWriterRegistry::BackupClusterHives");
	    }
	} VSS_STANDARD_CATCH (ft)


    DynamicRoutinesUnloadAll ();

    return (ft.hr);
    } /* CShimWriterRegistry::DoPrepareForSnapshot () */

/*
**++
**
**  Routine Description:
**
**	Captures the standard registry hives.
**
**
**  Arguments:
**
**	Implicit through the class
**
**
**  Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRegistry::BackupRegistryHives ()
    {
    HRESULT		hrStatus;
    DWORD		winStatus;
    HKEY		hkeyHivelist        = NULL;
    HKEY		hkeyRoot            = NULL;
    HKEY		hkeyBackup          = NULL;
    INT			iIndex              = 0;
    BOOL		bSucceeded          = FALSE;
    BOOL		bHivelistKeyOpened  = FALSE;
    BOOL		bContinueHiveSearch = TRUE;
    PWCHAR		pwchLastSlash;
    PWCHAR		pwszFilename;
    PWCHAR		pwszKeyName;
    UNICODE_STRING	ucsRegistrySavePath;
    UNICODE_STRING	ucsRegistryHivePath;
    UNICODE_STRING	ucsHiveRecognitionPostfix;
    UNICODE_STRING	ucsValueName;
    UNICODE_STRING	ucsValueData;
    USHORT		usRegistrySavePathRootLength = 0;


    StringInitialise (&ucsRegistrySavePath);
    StringInitialise (&ucsRegistryHivePath);
    StringInitialise (&ucsHiveRecognitionPostfix);
    StringInitialise (&ucsValueName);
    StringInitialise (&ucsValueData);


    hrStatus = StringAllocate (&ucsValueName, REGISTRY_BUFFER_SIZE * sizeof (WCHAR));

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, REGISTRY_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsRegistryHivePath,
						   REGISTRY_HIVE_PATH,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsRegistrySavePath,
						   m_pwszTargetPath,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	DWORD	dwCharIndex;


	StringAppendString (&ucsRegistryHivePath, DIR_SEP_STRING);
	StringAppendString (&ucsRegistrySavePath, DIR_SEP_STRING);

	usRegistrySavePathRootLength = ucsRegistrySavePath.Length / sizeof (WCHAR);


	/*
	** Now we know the location of the hive files, determine the
	** postfix we are going to use to recognise hives when we
	** search the active hivelist key. To do this we just need to
	** lose the drive letter and the colon in the path, or to put
	** it another way, lose everthing before the first '\'. When
	** we are done, if everything works ucsRegistryHivePath will
	** look something like '\Windows\system32\config\'
	*/
	for (dwCharIndex = 0;
	     (dwCharIndex < (ucsRegistryHivePath.Length / sizeof (WCHAR)))
		 && (DIR_SEP_CHAR != ucsRegistryHivePath.Buffer [dwCharIndex]);
	     dwCharIndex++)
	    {
	    /*
	    ** Empty loop body
	    */
	    }

	BS_ASSERT(dwCharIndex < (ucsRegistryHivePath.Length / sizeof (WCHAR)));

	hrStatus = StringCreateFromString (&ucsHiveRecognitionPostfix, &ucsRegistryHivePath.Buffer [dwCharIndex]);
	}



    if (SUCCEEDED (hrStatus))
	{
	/*
	** We now have all the pieces in place so go search the
	** hivelist for the hives to deal with.
	*/
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   REGISTRY_SUBKEY_HIVELIST,
				   0L,
				   KEY_QUERY_VALUE,
				   &hkeyHivelist);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	bHivelistKeyOpened = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (hive list)", 
		    L"CShimWriterRegistry::BackupRegistryHives");
	}



    while (SUCCEEDED (hrStatus) && bContinueHiveSearch)
	{
	DWORD	dwValueNameLength = ucsValueName.MaximumLength / sizeof (WCHAR);
	DWORD	dwValueDataLength = ucsValueData.MaximumLength;
	DWORD	dwValueType       = REG_NONE;
	BOOL	bMatchPrefix;
	BOOL	bMatchPostfix;


	StringTruncate (&ucsValueName, 0);
	StringTruncate (&ucsValueData, 0);


	/*
	** should be of type REG_SZ
	*/
	winStatus = RegEnumValueW (hkeyHivelist,
				   iIndex,
				   ucsValueName.Buffer,
				   &dwValueNameLength,
				   NULL,
				   &dwValueType,
				   (PBYTE)ucsValueData.Buffer,
				   &dwValueDataLength);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);


	if (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hrStatus)
	    {
	    hrStatus = NOERROR;

	    bContinueHiveSearch = FALSE;
	    }

	else if (FAILED (hrStatus))
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegEnumValueW", 
			L"CShimWriterRegistry::BackupRegistryHives");
	    }

	else
	    {
	    UNICODE_STRING	ucsPostFix;

	    BS_ASSERT ((REG_SZ == dwValueType) && L"Not REG_SZ string as expected");

	    ucsValueName.Length = (USHORT)(dwValueNameLength * sizeof (WCHAR));
	    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

	    ucsValueName.Buffer [ucsValueName.Length / sizeof (WCHAR)] = UNICODE_NULL;
	    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;


	    /*
	    ** If it's to be considered part of system state the hive
	    ** file itself must live in %SystemRoot%\system32\config
	    ** so we attempt to find something in the returned value
	    ** name which looks like it might match. The format of the
	    ** name we are expecting is something like
	    **
	    **	\Device\<Volume>\Windows\system32\config\filename
	    **
	    ** for a system which has system32 in the 'Windows'
	    ** directory.  
	    **
	    ** Now, we have the known prefix, '\Device\', and the
	    ** postfix before and including the last '\', something
	    ** like '\Windows\system32\config\' as we determined
	    ** earlier. So we should be in a position to identify the
	    ** hives files we are interested in. Remember, we don't
	    ** know the piece representing the actual volume which is
	    ** why we are doing all this matching of pre and
	    ** post-fixs.
	    */
	    bMatchPrefix = RtlPrefixUnicodeString (&ucsHiveRecognitionPrefix,
						   &ucsValueData,
						   TRUE);


	    /*
	    ** Locate the last '\' in the value data. After this will
	    ** be the filename (eg 'SAM') which we will want later and
	    ** before that should be the postfix (eg
	    ** '\Windows\system32\config\') by which we will recognise
	    ** this as a registry hive.
	    */
	    pwchLastSlash = wcsrchr (ucsValueData.Buffer, DIR_SEP_CHAR);

	    if ((NULL == pwchLastSlash) ||
		(ucsValueData.Length < (ucsHiveRecognitionPrefix.Length + ucsHiveRecognitionPostfix.Length)))
		{
		/*
		** We coundn't find a '\' or the value data wasn't
		** long enough.
		*/
		bMatchPostfix = FALSE;
		}
	    else
		{
		/*
		** Determine the name of the give file.
		*/
		pwszFilename = pwchLastSlash + 1;


		/*
		** Determine the postfix we are going to try to match
		** against. This should look something like
		** '\Windows\system32\config\SAM'.
		*/
		StringInitialise (&ucsPostFix,
				  pwszFilename - (ucsHiveRecognitionPostfix.Length / sizeof (WCHAR)));



		/*
		** See if the recognition string (eg
		** '\Windows\system32\config\') is a prefix of the
		** location of this hive file (eg
		** '\Windows\system32\config\SAM')
		*/
		bMatchPostfix = RtlPrefixUnicodeString (&ucsHiveRecognitionPostfix,
							&ucsPostFix,
							TRUE);
		}


	    if (bMatchPrefix && bMatchPostfix)
		{
		/*
		** We got ourselves a real live registry hive!
		*/
		/*
		** generate savename from hive name.
		*/
		StringAppendString (&ucsRegistrySavePath, pwszFilename);


		/*
		** Decide which registry root this is under by
		** comparing the value name we retrieved earlier (eg
		** '\REGISTRY\MACHINE\SAM') against the
		** '\REGISTRY\MACHINE' prefix.
		**
		** Note that we only expect either HKLM or HKLU so we
		** assume if it's not HKLM it must be HKLU. If that
		** changes this test must be re-visited.
		*/
		hkeyRoot = RtlPrefixUnicodeString (&ucsValueNameMachinePrefix,
						   &ucsValueName,
						   TRUE)
				? HKEY_LOCAL_MACHINE
				: HKEY_USERS;


		BS_ASSERT ((HKEY_LOCAL_MACHINE == hkeyRoot) ||
			   (RtlPrefixUnicodeString (&ucsValueNameUserPrefix,
						    &ucsValueName,
						    TRUE)));
						    

		/*
		** Need to find what name to use for the key we are
		** going to do the registry save from. In most cases
		** this is going to be the same as the filename, eg
		** the 'HKLM\SAM' for the 'SAM' hive file, but in some
		** (e.g. for the default user stuff) it's going to
		** have a '.' prefix, eg 'HKLU\.DEFAULT' for the
		** 'default' hive file. So we do the generic thing and
		** use whatever is after the last '\' in the value
		** name.
		*/
		pwszKeyName = wcsrchr (ucsValueName.Buffer, DIR_SEP_CHAR) + 1;

		winStatus = RegCreateKeyEx (hkeyRoot,
					    pwszKeyName,
					    0,
					    NULL,
					    REG_OPTION_BACKUP_RESTORE,
					    MAXIMUM_ALLOWED,
					    NULL,
					    &hkeyBackup,
					    NULL);
	
		hrStatus = HRESULT_FROM_WIN32 (winStatus);

		LogFailure (NULL, 
			    hrStatus, 
			    hrStatus, 
			    m_pwszWriterName, 
			    L"RegCreateKeyEx", 
			    L"CShimWriterRegistry::BackupRegistryHives");


		if (SUCCEEDED (hrStatus))
		    {
		    //
		    //  Use the new RegSaveKeyExW with REG_NO_COMPRESSION option to 
		    //  quickly spit out the hives.
		    //
		    winStatus = RegSaveKeyExW (hkeyBackup, ucsRegistrySavePath.Buffer, NULL, REG_NO_COMPRESSION);

		    hrStatus = HRESULT_FROM_WIN32 (winStatus);

		    LogFailure (NULL, 
				hrStatus, 
				hrStatus, 
				m_pwszWriterName, 
				L"RegSaveKey", 
				L"CShimWriterRegistry::BackupRegistryHives");


		    RegCloseKey (hkeyBackup);
		    }


		StringTruncate (&ucsRegistrySavePath, usRegistrySavePathRootLength);
		}


	    /*
	    ** Done with this value so go look for another.
	    */
	    iIndex++;
	    }
	}



    if (bHivelistKeyOpened)
	{
	RegCloseKey (hkeyHivelist);
	}

    StringFree (&ucsHiveRecognitionPostfix);
    StringFree (&ucsRegistryHivePath);
    StringFree (&ucsRegistrySavePath);
    StringFree (&ucsValueData);
    StringFree (&ucsValueName);

    return (hrStatus);
    } /* CShimWriterRegistry::BackupRegistryHives () */

/*
**++
**
**  Routine Description:
**
**	Captures the cluster registry hive.
**
**
**  Arguments:
**
**	Implicit through the class
**
**
**  Return Value:
**
**	Any HRESULT
**
**--
*/


HRESULT CShimWriterRegistry::BackupClusterHives ()
    {
    HRESULT		hrStatus           = NOERROR;
    DWORD		winStatus;
    DWORD		dwValueType        = REG_NONE;
    DWORD		dwValueDataLength;
    HCLUSTER		hCluster           = NULL;
    HKEY		hkeyHivelist       = NULL;
    HKEY		hkeyBackup         = NULL;
    BOOL		bHivelistKeyOpened = FALSE;
    BOOL		bClusterPresent    = FALSE;
    BOOL		bSucceeded;
    UNICODE_STRING	ucsValueData;
    UNICODE_STRING	ucsBackupPath;
    UNICODE_STRING	ucsBackupHiveFilename;



    StringInitialise (&ucsValueData);
    StringInitialise (&ucsBackupPath);
    StringInitialise (&ucsBackupHiveFilename);


    hrStatus = StringCreateFromExpandedString (&ucsBackupPath,
					       m_pwszTargetPath,
					       0);

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, REGISTRY_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsBackupHiveFilename, ucsBackupPath.Length
								+ sizeof (DIR_SEP_CHAR)
								+ ucsClusterHiveFilename.Length
								+ sizeof (UNICODE_NULL));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAppendString (&ucsBackupHiveFilename, &ucsBackupPath);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAppendString (&ucsBackupHiveFilename, DIR_SEP_STRING);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAppendString (&ucsBackupHiveFilename, &ucsClusterHiveFilename);
	}



    /*
    ** Check for presence of cluster hive in hivelist. That should be
    ** there (error out if missing) and have the value we expect. Then
    ** do a RegSaveKey() to collect a copy of the hive.
    */
    if (SUCCEEDED (hrStatus))
	{
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   REGISTRY_SUBKEY_HIVELIST,
				   0L,
				   KEY_QUERY_VALUE,
				   &hkeyHivelist);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	bHivelistKeyOpened = SUCCEEDED (hrStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (cluster hive)", 
		    L"CShimWriterRegistry::BackupClusterHives");
	}



    if (SUCCEEDED (hrStatus))
	{
	dwValueDataLength = ucsValueData.MaximumLength;

	winStatus = RegQueryValueExW (hkeyHivelist,
				      ucsValuenameClusterHivefile.Buffer,
				      NULL,
				      &dwValueType,
				      (PBYTE)ucsValueData.Buffer,
				      &dwValueDataLength);

	hrStatus = (REG_SZ == dwValueType) 
			? HRESULT_FROM_WIN32 (winStatus)
			: HRESULT_FROM_WIN32 (ERROR_CLUSTER_INVALID_NODE);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegQueryValueExW", 
		    L"CShimWriterRegistry::BackupClusterHives");
	}



    if (SUCCEEDED (hrStatus))
	{
	ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

	ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;


	/*
	** Looks like the cluster hive exists. Try to back it up to
	** the spit directory.
	*/
	winStatus = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
				    CLUSTER_SUBKEY_HIVE_NAME,
				    0,
				    NULL,
				    REG_OPTION_BACKUP_RESTORE,
				    MAXIMUM_ALLOWED,
				    NULL,
				    &hkeyBackup,
				    NULL);
	
	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegCreateKeyEx", 
		    L"CShimWriterRegistry::BackupClusterHives");

	if (SUCCEEDED (hrStatus))
	    {
	    winStatus = RegSaveKey (hkeyBackup, 
				    ucsBackupHiveFilename.Buffer, 
				    NULL);

	    hrStatus = HRESULT_FROM_WIN32 (winStatus);

	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegSaveKey", 
			L"CShimWriterRegistry::BackupClusterHives");

	    RegCloseKey (hkeyBackup);
	    }
	}



    /*
    ** All the cleanup code.
    */
    if (bHivelistKeyOpened)        RegCloseKey (hkeyHivelist);

    StringFree (&ucsBackupHiveFilename);
    StringFree (&ucsBackupPath);
    StringFree (&ucsValueData);

    return (hrStatus);
    } /* CShimWriterRegistry::BackupClusterHives () */

/*
**++
**
** Routine Description:
**
**	The Registry snapshot writer DoThaw() function. This will
**	place a copy of all the generated registry hives in the repair
**	directory to maintain backwards compatibility with Win2k and
**	so keep PSS happy.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**-- 
*/

HRESULT CShimWriterRegistry::DoThaw ()
    {
    HRESULT		hrStatus;
    UNICODE_STRING	ucsWriterResultPath;
    UNICODE_STRING	ucsRepairDirectory;


    StringInitialise (&ucsWriterResultPath);
    StringInitialise (&ucsRepairDirectory);


    hrStatus = StringCreateFromExpandedString (&ucsWriterResultPath, m_pwszTargetPath, MAX_PATH);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsRepairDirectory, REPAIR_PATH, MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = MoveFilesInDirectory (&ucsWriterResultPath, &ucsRepairDirectory);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"MoveFilesInDirectory", 
		    L"CShimWriterRegistry::DoThaw");
	}


    StringFree (&ucsWriterResultPath);
    StringFree (&ucsRepairDirectory);

    return (hrStatus);
    } /* CShimWriterRegistry::DoThaw() */

/*
**++
**
** Routine Description:
**
**	The Registry snapshot writer DoAbort() function. Since the
**	default action for DoAbort() is to call DoThaw() and we don't
**	want to copy the possibly incomplete set of registry files to
**	the repair directory..
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**-- 
*/

HRESULT CShimWriterRegistry::DoAbort ()
    {
    /*
    ** We don't actually need to do anything here as the cleanup will
    ** happen automatically in the calling code. We just need to
    ** prevent the default DoAbort() method call.
    */

    return (NOERROR);
    } /* CShimWriterRegistry::DoAbort() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrshim.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrshim.cpp

Abstract:

    Contains the exported DLL functions for VssAPI.dll.
    BUGBUG: Uses code that currently sets the SE handler.  Since the SEH is process
        wide, this can/will effect the user of this DLL.  Need to fix.

Author:

    SSteiner    1/27/2000

Revision History:

	Name		Date		Comments
    SSteiner    2/10/2000   Added single instance support to the shim dll
    MikeJohn    2/17/2000   Added test entry point TestShimWriter()
    MikeJohn    2/23/2000   Stop phaseAll invoking freeze levels 2 and 1
                            Add new entry points to allow triggering shim
                            without snapshots.
    mikejohn	03/09/2000  Move to using CVssWriter class
    mikejohn	03/24/2000  Fix minor problem in TestShimWriters() causing
                            freeze to be skipped
    mikejohn    04/28/2000  Rename vswrshim.dll to VssAPI.dll
    mikejohn	05/15/2000  107129: Ensure that all the writers receive all
			            the events even in the presence of
				    earlier failures.
			    108586: Check the privs of the callers of all the
			            public entry points. Also remove the
				    TestShimWriters() entry point.
			    108543: Ensure that SimulateXxxx() calls work once
				    the shim has had a successful invocation
				    of RegisterSnapshotSubscriptions()
    mikejohn	05/26/2000  120443: Make shim listen to all OnAbort events
			    120445: Ensure shim never quits on first error
				    when delivering events
			    108580: SimulateSnapshotFreeze can be called
				    asynchronously
			    123097: Allow selection of bootable state
			    General clean up and removal of boiler-plate code,
			    correct state engine and ensure shim can undo
			    everything it did.
    mikejohn	06/02/2000  Make shim sensitive to volume list
    mikejohn	06/06/2000  Move common target directory cleanup and creation
			    into CShimWriter::PrepareForSnapshot()
    mikejohn	06/14/2000  Change the return code from async freeze to be
			    compatible with the snapshot coordinator
    mikejohn	06/15/2000  Temporarily remove the debug trace statement for
			    thread creation/deletion in the vssapi dll to see
			    if ameliorates effects of the rapid thread
			    creation/deletion problem.
    mikejohn	06/16/2000  Have the shim writers respond to OnIdentify events
			    from the snapshot coordinator. This requies
			    splitting the shim writers into two groups
			    (selected by BootableState)
    mikejohn	06/19/2000  Apply code review comments.
			    128883: Add shim writer for WMI database
    mikejohn	07/05/2000  143367: Do all shim writer processing in a worker
			    thread to allow the acquisition of a mutex that can
			    be held over the Prepare to Thaw/Abort codepath.
			    Also remove the spit directory cleanup calls for paths
			    not protected by the mutex.
			    141305: Ensure Writers call SetWriterFailure() if they
			    are about to fail in response to an OnXxxx() event.
    mikejohn	08/08/2000  94487:  Add an ACL to the spit directory tree to limit
			            access to members of the Administrators group
				    or those holding the Backup privilege.
			    153807: Replace CleanDirectory() and EmptyDirectory()
				    with a more comprehensive directory tree
				    cleanup routine RemoveDirectoryTree() (not in
				    CShimWriter class).
    mikejohn	09/12/2000  177925: Check option flags argument unused bits are
				    all set to zero (ie MBZ bits)
			    180192: Fix PREFIX bug in DllMain()
    mikejohn	10/04/2000  177624: Apply error scrub changes and log errors to
				    event log
    mikejohn	10/21/2000  209047: Remove the metabase shim writer now that
				    there is a real one.
    mikejohn	10/23/2000  210070: Test for NULL ptr in SimulatesnapshotFreeze() rather
				    than taking AV exception
			    210264: Prevent SimulateXxxx() calls from returning
				    Win32 errors.
			    210305: Check SnapshotSetId on SimulateSnapshotXxxx() calls
			    210393: Return appropriate error message for an invalid arg.
    ssteiner	11/10/2000  143810 Move SimulateSnapshotXxxx() calls to be hosted by VsSvc.
    mikejohn	11/30/2000  245587: Return the correct error codes for access denied.
			    245896: Build security descriptors correctly
    ssteiner   	03/09/2001  289822, 321150, 323786 Removed mutexes, changed state table, changed
                shutdown.

--*/


#include "stdafx.h"

#include <aclapi.h>
#include <comadmin.h>

/*
** ATL
*/
CComModule _Module;
#include <atlcom.h>

#include "comadmin.hxx"

#include "vssmsg.h"
#include "wrtrdefs.h"
#include "common.h"
#include "vs_sec.hxx"


/*
** We just need the following to obtain the definition of UnregisterSnapshotSubscriptions()
*/
#include "vs_idl.hxx"
#include "vs_wmxml.hxx"
#include "vs_cmxml.hxx"

#include "vs_reg.hxx"
#include "vs_vol.hxx"
#include "ichannel.hxx"

#include "ntddsnap.h"



BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHWSHMC"

/*
** External definitions to allow us to link in the various shim writer
** instances. No need to place these in a header file as this is the
** only place they are or should be used
*/

extern PCShimWriter pShimWriterCI;		// in wrtrci.cpp
extern PCShimWriter pShimWriterClusterDb;	// in wrtrclus.cpp
extern PCShimWriter pShimWriterComPlusRegDb;	// in wrtrcomdb.cpp
extern PCShimWriter pShimWriterConfigDir;	// in wrtrconfig.cpp
extern PCShimWriter pShimWriterEventLog;	// in wrtreventlog.cpp
extern PCShimWriter pShimWriterRegistry;	// in wrtrregistry.cpp
extern PCShimWriter pShimWriterRSM;		// in wrtrrsm.cpp
extern PCShimWriter pShimWriterTLS;		// in wrtrtls.cpp
extern PCShimWriter pShimWriterWMI;		// in wrtrwmi.cpp


#define SHIM_APPLICATION_NAME_BOOTABLE_STATE	L"Microsoft Snapshot Writer (Bootable State)"
#define SHIM_APPLICATION_NAME_SERVICE_STATE	L"Microsoft Snapshot Writer (Service State)"


#define WORKER_THREAD_SHUTDOWN_TIMEOUT	(2 * 1000)
#define WORKER_THREAD_REQUEST_TIMEOUT	(5 * 60 * 1000)

// the name of the Volume Snapshot Service
const LPCWSTR wszVssvcServiceName = L"VSS";


typedef enum _SecurityAttributeType
    {
    esatUndefined = 0,
    esatMutex,
    esatFile
    } SecurityAttributeType;


typedef enum _WriterType
    {
    eWriterTypeUndefined = 0,
    eBootableStateOnly,
    eNonBootableStateOnly,
    eAllWriters
    } WriterType;


typedef enum _RequestOpCode
    {
    eOpUndefined = 0,
    eOpDeliverEventStartup,
    eOpDeliverEventIdentify,
    eOpDeliverEventPrepareForBackup,
    eOpDeliverEventPrepareForSnapshot,
    eOpDeliverEventFreeze,
    eOpDeliverEventThaw,
    eOpDeliverEventAbort,
    eOpWorkerThreadShutdown
    } RequestOpCode;


typedef enum _ThreadStatus
    {
    eStatusUndefined = 0,
    eStatusWaitingForOpRequest,
    eStatusProcessingOpRequest,
    eStatusNotRunning
    } ThreadStatus;


typedef struct _ArgsIdentify
    {
    IVssCreateWriterMetadata *pIVssCreateWriterMetadata;
    } ArgsIdentify;


typedef struct _ArgsPrepareForSnapshot
    {
    GUID     guidSnapshotSetId;
    BOOL     bBootableStateBackup;
    ULONG    ulVolumeCount;
    LPCWSTR *ppwszVolumeNamesArray;
    volatile bool *pbCancelAsync;
    } ArgsPrepareForSnapshot;


typedef struct _ArgsFreeze
    {
    GUID     guidSnapshotSetId;
    volatile bool *pbCancelAsync;
    } ArgsFreeze;


typedef struct _ArgsThaw
    {
    GUID     guidSnapshotSetId;
    } ArgsThaw;


typedef struct _ArgsAbort
    {
    GUID     guidSnapshotSetId;
    } ArgsAbort;


typedef union _ThreadArgs
    {
    ArgsIdentify		wtArgsIdentify;
    ArgsPrepareForSnapshot	wtArgsPrepareForSnapshot;
    ArgsFreeze			wtArgsFreeze;
    ArgsThaw			wtArgsThaw;
    ArgsAbort			wtArgsAbort;
    } ThreadArgs, *PThreadArgs;

class CVssWriterShim : public CVssWriter
    {
public:
 	CVssWriterShim ();
	CVssWriterShim (LPCWSTR       pwszWriterName,
			LPCWSTR       pwszWriterSpitDirectoryRoot,
			VSS_ID        idWriter,
			BOOL	      bBootableState,
			ULONG         ulWriterCount,
			PCShimWriter *prpCShimWriterArray);

	~CVssWriterShim ();

	HRESULT	RegisterWriterShim (VOID);
	HRESULT	UnRegisterWriterShim (VOID);

	HRESULT WorkerThreadStartup (void);
	HRESULT WorkerThreadRequestOperation (RequestOpCode eOperation,
					      PThreadArgs   pwtArgs);

	virtual bool STDMETHODCALLTYPE OnIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata);
	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot ();
	virtual bool STDMETHODCALLTYPE OnFreeze ();
	virtual bool STDMETHODCALLTYPE OnThaw ();
	virtual bool STDMETHODCALLTYPE OnAbort ();


private:
	static DWORD WINAPI RegisterWriterShimThreadFunc (void *pv);
	void	DoRegistration (void);


	static DWORD WINAPI WorkerThreadJacket (void *pvThisPtr);

	HRESULT WorkerThread (void);
	HRESULT WorkerThreadRequestProcessor (void);


	HRESULT	DeliverEventStartup  (void);
	HRESULT	DeliverEventShutdown (void);

	HRESULT	DeliverEventIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata);

	HRESULT	DeliverEventPrepareForSnapshot (BOOL     bBootableStateBackup,
						GUID     guidSnapshotSetId,
						ULONG    ulVolumeCount,
						LPCWSTR *ppwszVolumeNamesArray,
                                                volatile bool *pbCancelAsync );

	HRESULT	DeliverEventFreeze (GUID guidSnapshotSetId, volatile bool *pbCancelAsync );	
	HRESULT	DeliverEventThaw   (GUID guidSnapshotSetId);
	HRESULT	DeliverEventAbort  (GUID guidSnapshotSetId);

	const LPCWSTR		 m_pwszWriterName;
	const VSS_ID		 m_idWriter;
	const BOOL		 m_bBootableState;
	const LPCWSTR		 m_pwszWriterSpitDirectoryRoot;
	const ULONG		 m_ulWriterCount;
	const PCShimWriter	*m_prpCShimWriterArray;


	HRESULT		m_hrInitialize;
	BOOL		m_bSubscribed;

	BOOL		m_bRegisteredInThisProcess;
	BOOL		m_bDirectStartupCalled;

	RequestOpCode	m_eRequestedOperation;
	HRESULT		m_hrStatusRequestedOperation;
	HANDLE		m_hEventOperationRequest;
	HANDLE		m_hEventOperationCompleted;

	HANDLE		m_hWorkerThread;
	HRESULT		m_hrWorkerThreadCompletionStatus;
	ThreadStatus	m_eThreadStatus;
	ThreadArgs	m_wtArgs;
	
	CBsCritSec	m_cCriticalSection;

};

typedef CVssWriterShim *PCVssWriterShim;


// VssApi shim exports
typedef HRESULT ( APIENTRY *PFunc_SimulateSnapshotFreezeInternal ) (
    IN GUID     guidSnapshotSetId,
    IN ULONG    ulOptionFlags,
    IN ULONG    ulVolumeCount,
    IN LPWSTR  *ppwszVolumeNamesArray,
    IN volatile bool *pbCancelAsync
    );

typedef HRESULT ( APIENTRY *PFunc_SimulateSnapshotThawInternal ) (
    IN GUID guidSnapshotSetId
    );

HRESULT APIENTRY SimulateSnapshotFreezeInternal (
    IN GUID     guidSnapshotSetId,
    IN ULONG    ulOptionFlags,
    IN ULONG    ulVolumeCount,
    IN LPWSTR *ppwszVolumeNamesArray,
    IN volatile bool *pbCancelAsync
    );

HRESULT APIENTRY SimulateSnapshotThawInternal (
    IN GUID guidSnapshotSetId );

static HRESULT NormaliseVolumeArray (ULONG   ulVolumeCount,
				     LPWSTR pwszVolumeNameArray[],
				     PPWCHAR ppwszReturnedVolumeNameArray[]);

static VOID CleanupVolumeArray (PPWCHAR prpwszNormalisedVolumeNameArray[]);


static HRESULT InitialiseGlobalState ();
static HRESULT CleanupGlobalState (void);


static VOID    CleanupSecurityAttributes   (PSECURITY_ATTRIBUTES  psaSecurityAttributes);
static HRESULT ConstructSecurityAttributes (PSECURITY_ATTRIBUTES  psaSecurityAttributes,
					    SecurityAttributeType eSaType,
					    BOOL                  bIncludeBackupOperator);

static HRESULT CleanupTargetPath (LPCWSTR pwszTargetPath);
static HRESULT CreateTargetPath  (LPCWSTR pwszTargetPath);




static PCShimWriter g_rpShimWritersArrayBootableState[] = {
							  pShimWriterComPlusRegDb,	// The COM+ registration Db writer
							  pShimWriterRegistry};	// The Registry writer

static PCShimWriter g_rpShimWritersArrayServiceState[] = {
							  pShimWriterRSM,		// The Remote Storage Manager writer
							  pShimWriterCI,		// The Content Indexing writer
							  pShimWriterTLS,		// The TermServer Licencing service writer
							  pShimWriterConfigDir,		// The Configuration directory writer
							  pShimWriterEventLog};		// The Event Log writer

#define COUNT_SHIM_WRITERS_BOOTABLE_STATE	(SIZEOF_ARRAY (g_rpShimWritersArrayBootableState))
#define COUNT_SHIM_WRITERS_SERVICE_STATE	(SIZEOF_ARRAY (g_rpShimWritersArrayServiceState))


static PCVssWriterShim	g_pCVssWriterShimBootableState = NULL;
static PCVssWriterShim	g_pCVssWriterShimServiceState  = NULL;
static ULONG		g_ulThreadAttaches             = 0;
static ULONG		g_ulThreadDetaches             = 0;
static BOOL		g_bGlobalStateInitialised      = FALSE;
static CBsCritSec	g_cCritSec;
static HRESULT          g_hrSimulateFreezeStatus       = NOERROR;

static GUID		g_guidSnapshotInProgress       = GUID_NULL;

static IVssShim         *g_pIShim = NULL;  //  Used by the simulate functions.  Note it is NOT used in the
                                            //  simulateInternal functions.

/*
**++
**
**  Routine Description:
**
**	The DllMain entry point for this DLL.  Note that this must be called by the
**	CRT DLL Start function since the CRT must be initialized.
**
**
**  Arguments:
**	hInstance
**	dwReason
**	lpReserved
**
**
**  Return Value:
**
**	TRUE - Successful function execution
**	FALSE - Error when executing the function
**
**--
*/

BOOL APIENTRY DllMain (IN HINSTANCE hInstance,
		       IN DWORD     dwReason,
		       IN LPVOID    lpReserved)
    {
    BOOL bSuccessful = TRUE;

    UNREFERENCED_PARAMETER (hInstance);
    UNREFERENCED_PARAMETER (lpReserved);



    if (DLL_PROCESS_ATTACH == dwReason)
	{
	try
	    {
	    /*
	    **  Set the correct tracing context. This is an inproc DLL		
	    */
	    g_cDbgTrace.SetContextNum (VSS_CONTEXT_DELAYED_DLL);
	    }

	catch (...)
	    {
	    /*
	    ** Can't trace from here so just ASSERT() (checked builds only)
	    */
	    bSuccessful = FALSE;


	    BS_ASSERT (bSuccessful && "FAILED to initialise tracing sub-system");
	    }
	}


    if (bSuccessful)
	{
	try
	    {
	    switch (dwReason)
		{
		case DLL_PROCESS_ATTACH:
		    BsDebugTrace (0,
				  DEBUG_TRACE_VSS_SHIM,
				  (L"VssAPI: DllMain - DLL_PROCESS_ATTACH called, %s",
				   lpReserved ? L"Static load" : L"Dynamic load"));


		    /*
		    **  Don't need to know when threads start and stop - Wrong
		    **
		    ** DisableThreadLibraryCalls (hInstance);
		    */
		    _Module.Init (ObjectMap, hInstance);

		    break;
    		
	
		case DLL_PROCESS_DETACH:
		    BsDebugTrace (0,
				  DEBUG_TRACE_VSS_SHIM,
				  (L"VssAPI: DllMain - DLL_PROCESS_DETACH called %s",
				   lpReserved ? L"during process termination" : L"by FreeLibrary"));

			{
			CVssFunctionTracer ft (VSSDBG_SHIM, L"DllMain::ProcessDetach");

			try
			    {
			    CleanupGlobalState ();
			    } VSS_STANDARD_CATCH (ft);
			}

		    _Module.Term();

		    break;


		case DLL_THREAD_ATTACH:
		    g_ulThreadAttaches++;

		    if (0 == (g_ulThreadAttaches % 1000))
			{
			BsDebugTrace (0,
				      DEBUG_TRACE_VSS_SHIM,
				      (L"VssAPI: DllMain thread attaches = %u, detaches = %u, outstanding = %u",
				       g_ulThreadAttaches,
				       g_ulThreadDetaches,
				       g_ulThreadAttaches - g_ulThreadDetaches));
			}
		    break;


		case DLL_THREAD_DETACH:
		    g_ulThreadDetaches++;

		    if (0 == (g_ulThreadDetaches % 1000))
			{
			BsDebugTrace (0,
				      DEBUG_TRACE_VSS_SHIM,
				      (L"VssAPI: DllMain thread attaches = %u, detaches = %u, outstanding = %u",
				       g_ulThreadAttaches,
				       g_ulThreadDetaches,
				       g_ulThreadAttaches - g_ulThreadDetaches));
			}
		    break;


		default:
		    BsDebugTrace (0,
				  DEBUG_TRACE_VSS_SHIM,
				  (L"VssAPI: DllMain got unexpected reason code, lpReserved: %sNULL",
				   dwReason,
				   lpReserved ? L"non-" : L""));
		    break;
		}
	    }


	catch (...)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"VssAPI: DllMain - Error, unknown exception caught"));

	    bSuccessful = FALSE;
	    }
	}



    return (bSuccessful);
    } /* DllMain () */

/*
**++
**
**  Routine Description:
**
**	Converts the supplied array of volume names into something we
**	trust. Once the array is finished with a call must be made to
**	CleanupVolumeArray().
**
**
**  Arguments:
**
**	ulVolumeCount                Number of volumes in the supplied array
**	pwszVolumeNameArray          supplied array of volume names
**	ppwszReturnedVolumeNameArray returned array of volume names
**	
**
**  Return Value:
**
**	Any HRESULT from memory allocation, or volume name conversions.
**
**--
*/

static HRESULT NormaliseVolumeArray (ULONG   ulVolumeCount,
				     LPWSTR pwszVolumeNamesArray[],
				     PPWCHAR ppwszReturnedVolumeNamesArray[])
    {
    HRESULT	hrStatus                       = NOERROR;
    PPWCHAR	pwszNormalisedVolumeNamesArray = NULL;
    BOOL	bSucceeded;



    if ((0 < ulVolumeCount) && (NULL != pwszVolumeNamesArray))
	{
	pwszNormalisedVolumeNamesArray = (PPWCHAR) HeapAlloc (GetProcessHeap (),
							      HEAP_ZERO_MEMORY,
							      (ulVolumeCount * (MAX_VOLUMENAME_SIZE + sizeof (PWCHAR))));

	hrStatus = GET_STATUS_FROM_POINTER (pwszNormalisedVolumeNamesArray);


	for (ULONG ulIndex = 0; SUCCEEDED (hrStatus) && (ulIndex < ulVolumeCount); ulIndex++)
	    {
	    pwszNormalisedVolumeNamesArray [ulIndex] = (PWCHAR)((PBYTE)pwszNormalisedVolumeNamesArray
								+ (ulVolumeCount * sizeof (PWCHAR))
								+ (ulIndex * MAX_VOLUMENAME_SIZE));

	    bSucceeded = GetVolumeNameForVolumeMountPointW (pwszVolumeNamesArray [ulIndex],
							    pwszNormalisedVolumeNamesArray [ulIndex],
							    MAX_VOLUMENAME_SIZE);

            if ( !bSucceeded )
                {
                //
                //  See if this is one of the object not found errors.  Bug #223058.
                //
                DWORD dwErr = ::GetLastError();
                if ( dwErr == ERROR_FILE_NOT_FOUND || dwErr == ERROR_DEVICE_NOT_CONNECTED
                     || dwErr == ERROR_NOT_READY )
                    {
                    hrStatus = VSS_E_OBJECT_NOT_FOUND;
                    }
                else
                    {
                    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);
                    }

	        LogFailure (NULL,
		    	    hrStatus,
			    hrStatus,
			    NULL,
			    L"GetVolumeNameForVolumeMountPointW",
			    L"NormaliseVolumeArray");
	        }
	    }
        }

    if (SUCCEEDED (hrStatus))
	{
	*ppwszReturnedVolumeNamesArray = pwszNormalisedVolumeNamesArray;
	}

    else
	{
	*ppwszReturnedVolumeNamesArray = NULL;

	if (NULL != pwszNormalisedVolumeNamesArray)
	    {
	    HeapFree (GetProcessHeap (), 0, pwszNormalisedVolumeNamesArray);
	    }
	}


    return (hrStatus);
    } /* NormaliseVolumeArray () */

/*
**++
**
**  Routine Description:
**
**	Cleans up whatever was allocated by NormaliseVolumeArray.
**
**
**  Arguments:
**
**	prpwszNormalisedVolumeNameArray	array of volume names
**	
**
**  Return Value:
**
**	None
**
**--
*/

static VOID CleanupVolumeArray (PPWCHAR prpwszNormalisedVolumeNameArray[])
    {
    if (NULL != *prpwszNormalisedVolumeNameArray)
	{
	HeapFree (GetProcessHeap (), 0, *prpwszNormalisedVolumeNameArray);
	*prpwszNormalisedVolumeNameArray = NULL;
	}
    } /* CleanupVolumeArray () */

/*
**++
**
**  Routine Description:
**
**	The exported function that is called to register the COM event
**	subscriptions for Snapshot event notifications and to prepare
**	the shim writers to be invoked either via the snapshot event
**	delivery mechanisim or via a call to the SimulateSnapshotXxxx()
**	routines.
**
**
**  Arguments:
**
**      ppFuncFreeze - Returns a pointer to the internal simulate freeze
**          function.
**      ppFuncThaw - Returns a pointer to the internal simulate thaw
**          function.
**
**	None
**
**  Return Value:
**
**	Any HRESULT from COM Event subscription functions or from the Snapshot writer
**	Init functions.
**
**--
*/
__declspec(dllexport) HRESULT APIENTRY RegisterSnapshotSubscriptions (
    OUT PFunc_SimulateSnapshotFreezeInternal *ppFuncFreeze,
    OUT PFunc_SimulateSnapshotThawInternal *ppFuncThaw
    )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::RegisterSnapshotSubscriptions");

    BOOL		bPrivilegesSufficient = FALSE;


    try
	{
	CBsAutoLock cAutoLock (g_cCritSec);

	bPrivilegesSufficient = IsProcessBackupOperator ();

	ft.ThrowIf (!bPrivilegesSufficient,
		    VSSDBG_SHIM,
		    E_ACCESSDENIED,
		    L"FAILED as insuficient privileges to call shim");

	ft.ThrowIf ( ( ppFuncFreeze == NULL ) || ( ppFuncThaw == NULL ),
		    VSSDBG_SHIM,
		    E_INVALIDARG,
		    L"FAILED internal function pointers are NULL");

        *ppFuncFreeze = NULL;
  	*ppFuncThaw = NULL;

	ft.hr = InitialiseGlobalState ();

        //
        //  Set up pointers to the internal snapshot freeze and thaw
        //
        *ppFuncFreeze = &SimulateSnapshotFreezeInternal;
  	*ppFuncThaw = &SimulateSnapshotThawInternal;
	}
    VSS_STANDARD_CATCH (ft);


    return (ft.hr);
    } /* RegisterSnapshotSubscriptions () */

/*
**++
**
**  Routine Description:
**
**	The exported function that is called to unregister the COM event subscriptions
**	for Snapshot event notifications and to cleanup any outstanding shim writer state.
**
**  Arguments:
**
**	None
**
**  Return Value:
**
**	Any HRESULT from COM Event unregister subscription functions or from the Snapshot
**	writer Finished functions.
**
**--
*/

__declspec(dllexport) HRESULT APIENTRY UnregisterSnapshotSubscriptions (void)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"VssAPI::UnregisterSnapshotSubscriptions");

    BOOL		bPrivilegesSufficient;


    try
	{
	bPrivilegesSufficient = IsProcessBackupOperator ();

	ft.ThrowIf (!bPrivilegesSufficient,
		    VSSDBG_SHIM,
		    E_ACCESSDENIED,
		    L"FAILED as inssuficient privileges to call shim");


	CBsAutoLock cAutoLock (g_cCritSec);

	g_pCVssWriterShimServiceState->WorkerThreadRequestOperation  (eOpWorkerThreadShutdown, NULL);
	g_pCVssWriterShimBootableState->WorkerThreadRequestOperation (eOpWorkerThreadShutdown, NULL);


	CleanupGlobalState ();
	} VSS_STANDARD_CATCH (ft);


    return (ft.hr);
    } /* UnregisterSnapshotSubscriptions () */

/*
**++
**
**  Routine Description:
**
**	Initializes the shim global state in preparation for
**	responding to either writer requests or calls to
**	SimulateSnapshotFreeze and SimulateSnapshotThaw.
**
**
**
**  Arguments:
**
**      NONE
**
**  Return Value:
**
**	Any HRESULT from COM Event register subscription functions, Snapshot
**	writer startup functions, thread, event or mutex creation.
**	
**
**--
*/

static HRESULT InitialiseGlobalState ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::InitialiseGlobalState");

    PCVssWriterShim	pCVssWriterShimBootableStateLocal = NULL;
    PCVssWriterShim	pCVssWriterShimServiceStateLocal  = NULL;

    try
	{
	if ((g_bGlobalStateInitialised)              ||
	    (NULL != g_pCVssWriterShimBootableState) ||
	    (NULL != g_pCVssWriterShimServiceState))
	    {
	    /*
	    ** The following condition should never occur on a user system
	    ** but may well be seen by application developers.
	    */
	    ft.LogError (VSS_ERROR_SHIM_ALREADY_INITIALISED,
			 VSSDBG_SHIM);

	    BS_ASSERT (FALSE && "Illegal second attempt to initialise global state");

	    ft.Throw (VSSDBG_SHIM,
		      E_UNEXPECTED,
		      L"FAILED as writer instances already exist");
	    }


	/*
	** Create the writer shim instances.
	*/
	pCVssWriterShimBootableStateLocal = new CVssWriterShim (SHIM_APPLICATION_NAME_BOOTABLE_STATE,
								ROOT_BACKUP_DIR BOOTABLE_STATE_SUBDIR,
								idWriterBootableState,
								TRUE,
								COUNT_SHIM_WRITERS_BOOTABLE_STATE,
								g_rpShimWritersArrayBootableState);

	if (NULL == pCVssWriterShimBootableStateLocal)
	    {
	    ft.LogError (VSS_ERROR_SHIM_FAILED_TO_ALLOCATE_WRITER_INSTANCE,
			 VSSDBG_SHIM << SHIM_APPLICATION_NAME_BOOTABLE_STATE);

	    ft.Throw (VSSDBG_SHIM,
		      E_OUTOFMEMORY,
		      L"FAILED to allocate CvssWriterShim object for BootableState");
	    }



	pCVssWriterShimServiceStateLocal  = new CVssWriterShim (SHIM_APPLICATION_NAME_SERVICE_STATE,
								ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR,
								idWriterServiceState,
								FALSE,
								COUNT_SHIM_WRITERS_SERVICE_STATE,
								g_rpShimWritersArrayServiceState);

	if (NULL == pCVssWriterShimServiceStateLocal)
	    {
	    ft.LogError (VSS_ERROR_SHIM_FAILED_TO_ALLOCATE_WRITER_INSTANCE,
			 VSSDBG_SHIM << SHIM_APPLICATION_NAME_SERVICE_STATE);

	    ft.Throw (VSSDBG_SHIM,
		      E_OUTOFMEMORY,
		      L"FAILED to allocate CvssWriterShim object for ServiceState.");
	    }



	ft.hr = pCVssWriterShimBootableStateLocal->WorkerThreadStartup ();

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"FAILED to start the BootableState shim writer worker thread");



	ft.hr = pCVssWriterShimServiceStateLocal->WorkerThreadStartup ();

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"FAILED to start the ServiceState shim writer worker thread");


	/*
	** Do the startup work.
	*/
	ft.hr = pCVssWriterShimBootableStateLocal->RegisterWriterShim ();

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"FAILED to register the BootableState shim writer class");



	ft.hr = pCVssWriterShimServiceStateLocal->RegisterWriterShim ();

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"FAILED to register the ServiceState shim writer class");

	/*
	** Now that everything is ok, transfer ownership of the
	** instances of the shim writer class to the final locations
	*/
	g_pCVssWriterShimBootableState = pCVssWriterShimBootableStateLocal;
	g_pCVssWriterShimServiceState  = pCVssWriterShimServiceStateLocal;

	pCVssWriterShimBootableStateLocal = NULL;
	pCVssWriterShimServiceStateLocal  = NULL;

	g_bGlobalStateInitialised = TRUE;
	} VSS_STANDARD_CATCH (ft);



    delete pCVssWriterShimBootableStateLocal;
    delete pCVssWriterShimServiceStateLocal;

    return (ft.hr);
    } /* InitialiseGlobalState () */


/*
**++
**
**  Routine Description:
**
**	Cleans up the shim global state in preparation for a dll
**	unload/process shutdown.
**
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT thrown by CVssWriterShim object destruction.
**	
**
**--
*/

static HRESULT CleanupGlobalState (void)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"VssAPI::CleanupGlobalState");

    PCVssWriterShim	pCVssWriterShimBootableStateLocal;
    PCVssWriterShim	pCVssWriterShimServiceStateLocal;


    try
	{
	if ( g_bGlobalStateInitialised )
	        {
        	g_bGlobalStateInitialised = FALSE;
        	
        	pCVssWriterShimBootableStateLocal = g_pCVssWriterShimBootableState;
        	pCVssWriterShimServiceStateLocal  = g_pCVssWriterShimServiceState;

        	g_pCVssWriterShimBootableState = NULL;
        	g_pCVssWriterShimServiceState  = NULL;


        	delete pCVssWriterShimBootableStateLocal;
        	delete pCVssWriterShimServiceStateLocal;
        	}
	}
    VSS_STANDARD_CATCH (ft);

    return (ft.hr);
    } /* CleanupGlobalState () */

/*
**++
**
**  Routine Description:
**
**	Routines to construct and cleanup a security descriptor which
**	can be applied to limit access to an object to member of
**	either the Administrators or Backup Operators group.
**
**
**  Arguments:
**
**	psaSecurityAttributes	Pointer to a SecurityAttributes
**				structure which has already been
**				setup to point to a blank
**				security descriptor
**
**	eSaType			What we are building the SA for
**
**	bIncludeBackupOperator	Whether or not to include an ACE to
**				grant BackupOperator access
**
**
**  Return Value:
**
**	Any HRESULT from
**		InitializeSecurityDescriptor()
**		AllocateAndInitializeSid()
**		SetEntriesInAcl()
**		SetSecurityDescriptorDacl()
**
**--
*/

static HRESULT ConstructSecurityAttributes (PSECURITY_ATTRIBUTES  psaSecurityAttributes,
					    SecurityAttributeType eSaType,
					    BOOL                  bIncludeBackupOperator)
    {
    HRESULT			hrStatus             = NOERROR;
    DWORD			dwStatus;
    DWORD			dwAccessMask         = 0;
    BOOL			bSucceeded;
    PSID			psidBackupOperators  = NULL;
    PSID			psidAdministrators   = NULL;
    PACL			paclDiscretionaryAcl = NULL;
    SID_IDENTIFIER_AUTHORITY	sidNtAuthority       = SECURITY_NT_AUTHORITY;
    EXPLICIT_ACCESS		eaExplicitAccess [2];



    switch (eSaType)
	{
	case esatMutex: dwAccessMask = MUTEX_ALL_ACCESS; break;
	case esatFile:  dwAccessMask = FILE_ALL_ACCESS;  break;

	default:
	    BS_ASSERT (FALSE && "Improper access mask requested");

	    hrStatus = HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER);
	    break;
	}



    /*
    ** Initialise the security descriptor.
    */
    if (SUCCEEDED (hrStatus))
	{
	bSucceeded = InitializeSecurityDescriptor (psaSecurityAttributes->lpSecurityDescriptor,
						   SECURITY_DESCRIPTOR_REVISION);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	LogFailure (NULL, hrStatus, hrStatus, NULL, L"GetVolumeNameForVolumeMountPointW", L"NormaliseVolumeArray");
	}



    if (SUCCEEDED (hrStatus) && bIncludeBackupOperator)
	{
	/*
	** Create a SID for the Backup Operators group.
	*/
        bSucceeded = AllocateAndInitializeSid (&sidNtAuthority,
					       2,
					       SECURITY_BUILTIN_DOMAIN_RID,
					       DOMAIN_ALIAS_RID_BACKUP_OPS,
					       0, 0, 0, 0, 0, 0,
					       &psidBackupOperators);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	LogFailure (NULL, hrStatus, hrStatus, NULL, L"AllocateAndInitializeSid", L"NormaliseVolumeArray");
	}



    if (SUCCEEDED (hrStatus))
	{
        /*
	** Create a SID for the Administrators group.
	*/
	bSucceeded = AllocateAndInitializeSid (&sidNtAuthority,
					       2,
					       SECURITY_BUILTIN_DOMAIN_RID,
					       DOMAIN_ALIAS_RID_ADMINS,
					       0, 0, 0, 0, 0, 0,
					       &psidAdministrators);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	LogFailure (NULL, hrStatus, hrStatus, NULL, L"AllocateAndInitializeSid", L"NormaliseVolumeArray");
	}



    if (SUCCEEDED (hrStatus))
	{
        /*
	** Initialize the array of EXPLICIT_ACCESS structures for an
	** ACEs we are setting.
	**
        ** The first ACE allows the Backup Operators group full access
        ** and the second, allowa the Administrators group full
        ** access.
	*/
        eaExplicitAccess[0].grfAccessPermissions             = dwAccessMask;
        eaExplicitAccess[0].grfAccessMode                    = SET_ACCESS;
        eaExplicitAccess[0].grfInheritance                   = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
	eaExplicitAccess[0].Trustee.pMultipleTrustee         = NULL;
	eaExplicitAccess[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
        eaExplicitAccess[0].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
        eaExplicitAccess[0].Trustee.TrusteeType              = TRUSTEE_IS_ALIAS;
        eaExplicitAccess[0].Trustee.ptstrName                = (LPTSTR) psidAdministrators;


	if (bIncludeBackupOperator)
	    {
	    eaExplicitAccess[1].grfAccessPermissions             = dwAccessMask;
	    eaExplicitAccess[1].grfAccessMode                    = SET_ACCESS;
	    eaExplicitAccess[1].grfInheritance                   = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
	    eaExplicitAccess[1].Trustee.pMultipleTrustee         = NULL;
	    eaExplicitAccess[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
	    eaExplicitAccess[1].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
	    eaExplicitAccess[1].Trustee.TrusteeType              = TRUSTEE_IS_ALIAS;
	    eaExplicitAccess[1].Trustee.ptstrName                = (LPTSTR) psidBackupOperators;
	    }


        /*
	** Create a new ACL that contains the new ACEs.
	*/
        dwStatus = SetEntriesInAcl (bIncludeBackupOperator ? 2 : 1,
				    eaExplicitAccess,
				    NULL,
				    &paclDiscretionaryAcl);

	hrStatus = HRESULT_FROM_WIN32 (dwStatus);

	LogFailure (NULL, hrStatus, hrStatus, NULL, L"SetEntriesInAcl", L"NormaliseVolumeArray");
	}


    if (SUCCEEDED (hrStatus))
	{
        /*
	** Add the ACL to the security descriptor.
	*/
        bSucceeded = SetSecurityDescriptorDacl (psaSecurityAttributes->lpSecurityDescriptor,
						TRUE,
						paclDiscretionaryAcl,
						FALSE);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	LogFailure (NULL, hrStatus, hrStatus, NULL, L"SetSecurityDescriptorDacl", L"NormaliseVolumeArray");
	}


    if (SUCCEEDED (hrStatus))
	{
	paclDiscretionaryAcl = NULL;
	}



    /*
    ** Clean up any left over junk.
    */
    if (NULL != psidAdministrators)    FreeSid (psidAdministrators);
    if (NULL != psidBackupOperators)   FreeSid (psidBackupOperators);
    if (NULL != paclDiscretionaryAcl)  LocalFree (paclDiscretionaryAcl);


    return (hrStatus);
    } /* ConstructSecurityAttributes () */


static VOID CleanupSecurityAttributes (PSECURITY_ATTRIBUTES psaSecurityAttributes)
    {
    BOOL	bSucceeded;
    BOOL	bDaclPresent         = FALSE;
    BOOL	bDaclDefaulted       = TRUE;
    PACL	paclDiscretionaryAcl = NULL;


    bSucceeded = GetSecurityDescriptorDacl (psaSecurityAttributes->lpSecurityDescriptor,
					    &bDaclPresent,
					    &paclDiscretionaryAcl,
					    &bDaclDefaulted);


    if (bSucceeded && bDaclPresent && !bDaclDefaulted && (NULL != paclDiscretionaryAcl))
	{
	LocalFree (paclDiscretionaryAcl);
	}

    } /* CleanupSecurityAttributes () */

/*
**++
**
**  Routine Description:
**
**	Creates a new target directory specified by the target path
**	member variable if not NULL. It will create any necessary
**	parent directories too.
**
**	NOTE: already exists type errors are ignored.
**
**
**  Arguments:
**
**	pwszTargetPath	directory to create and apply security attributes
**
**
**  Return Value:
**
**	Any HRESULT resulting from memory allocation or directory creation attempts.
**--
*/

HRESULT CreateTargetPath (LPCWSTR pwszTargetPath)
    {
    HRESULT		hrStatus = NOERROR;
    UNICODE_STRING	ucsTargetPath;
    ACL			DiscretionaryAcl;
    SECURITY_ATTRIBUTES	saSecurityAttributes;
    SECURITY_DESCRIPTOR	sdSecurityDescriptor;
    BOOL		bSucceeded;
    BOOL		bSecurityAttributesConstructed = FALSE;
    DWORD		dwFileAttributes               = 0;
    const DWORD		dwExtraAttributes              = FILE_ATTRIBUTE_ARCHIVE |
							 FILE_ATTRIBUTE_HIDDEN  |
							 FILE_ATTRIBUTE_SYSTEM  |
							 FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;


    if (NULL != pwszTargetPath)
	{
	StringInitialise (&ucsTargetPath);

	hrStatus = StringCreateFromExpandedString (&ucsTargetPath,
						   pwszTargetPath,
						   MAX_PATH);


	if (SUCCEEDED (hrStatus))
	    {
	    /*
	    ** We really want a no access acl on this directory but
	    ** because of various problems with the EventLog and
	    ** ConfigDir writers we will settle for admin or backup
	    ** operator access only. The only possible accessor is
	    ** Backup which is supposed to have the SE_BACKUP_NAME
	    ** priv which will effectively bypass the ACL. No one else
	    ** needs to see this stuff.
	    */
	    saSecurityAttributes.nLength              = sizeof (saSecurityAttributes);
	    saSecurityAttributes.lpSecurityDescriptor = &sdSecurityDescriptor;
	    saSecurityAttributes.bInheritHandle       = FALSE;

	    hrStatus = ConstructSecurityAttributes (&saSecurityAttributes, esatFile, FALSE);

	    bSecurityAttributesConstructed = SUCCEEDED (hrStatus);
	    }


	if (SUCCEEDED (hrStatus))
	    {
	    bSucceeded = VsCreateDirectories (ucsTargetPath.Buffer,
					      &saSecurityAttributes,
					      dwExtraAttributes);


	    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

	    if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_ALREADY_EXISTS) == hrStatus))
		{
		hrStatus = NOERROR;
		}


	    CleanupSecurityAttributes (&saSecurityAttributes);
	    }


	StringFree (&ucsTargetPath);
	}

    return (hrStatus);
    } /* CreateTargetPath () */

/*
**++
**
**  Routine Description:
**
**	Deletes all the files present in the directory pointed at by the target
**	path member variable if not NULL. It will also remove the target directory
**	itself, eg for a target path of c:\dir1\dir2 all files under dir2 will be
**	removed and then dir2 itself will be deleted.
**
**
**  Arguments:
**
**	pwszTargetPath
**
**
**  Return Value:
**
**	Any HRESULT resulting from memory allocation or file and
**	directory deletion attempts.
**--
*/

HRESULT CleanupTargetPath (LPCWSTR pwszTargetPath)
    {
    HRESULT		hrStatus         = NOERROR;
    DWORD		dwFileAttributes = 0;
    BOOL		bSucceeded;
    WCHAR		wszTempBuffer [50];
    UNICODE_STRING	ucsTargetPath;
    UNICODE_STRING	ucsTargetPathAlternateName;



    StringInitialise (&ucsTargetPath);
    StringInitialise (&ucsTargetPathAlternateName);


    if (NULL != pwszTargetPath)
	{
	hrStatus = StringCreateFromExpandedString (&ucsTargetPath,
						   pwszTargetPath,
						   MAX_PATH);


	if (SUCCEEDED (hrStatus))
	    {
	    hrStatus = StringCreateFromString (&ucsTargetPathAlternateName,
					       &ucsTargetPath,
					       MAX_PATH);
	    }


	if (SUCCEEDED (hrStatus))
	    {
	    dwFileAttributes = GetFileAttributesW (ucsTargetPath.Buffer);


	    hrStatus = GET_STATUS_FROM_BOOL ( -1 != dwFileAttributes);


	    if ((HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus) ||
		(HRESULT_FROM_WIN32 (ERROR_PATH_NOT_FOUND) == hrStatus))
		{
		hrStatus         = NOERROR;
		dwFileAttributes = 0;
		}

	    else if (SUCCEEDED (hrStatus))
		{
		/*
		** If there is a file there then blow it away, or if it's
		** a directory, blow it and all it's contents away. This
		** is our directory and no one but us gets to play there.
		*/
		hrStatus = RemoveDirectoryTree (&ucsTargetPath);

		if (FAILED (hrStatus))
		    {
		    srand ((unsigned) time (NULL));

		    _itow (rand (), wszTempBuffer, 16);

		    StringAppendString (&ucsTargetPathAlternateName, wszTempBuffer);

		    bSucceeded = MoveFileW (ucsTargetPath.Buffer,
					    ucsTargetPathAlternateName.Buffer);

		    if (bSucceeded)
			{
			BsDebugTraceAlways (0,
					    DEBUG_TRACE_VSS_SHIM,
					    (L"VSSAPI::CleanupTargetPath: "
					     L"FAILED to delete %s with status 0x%08X so renamed to %s",
					     ucsTargetPath.Buffer,
					     hrStatus,
					     ucsTargetPathAlternateName.Buffer));
			}
		    else
			{
			BsDebugTraceAlways (0,
					    DEBUG_TRACE_VSS_SHIM,
					    (L"VSSAPI::CleanupTargetPath: "
					     L"FAILED to delete %s with status 0x%08X and "
					     L"FAILED to rename to %s with status 0x%08X",
					     ucsTargetPath.Buffer,
					     hrStatus,
					     ucsTargetPathAlternateName.Buffer,
					     GET_STATUS_FROM_BOOL (bSucceeded)));
			}
		    }
		}
	    }
	}


    StringFree (&ucsTargetPathAlternateName);
    StringFree (&ucsTargetPath);

    return (hrStatus);
    } /* CleanupTargetPath () */

/*
**++
**
**  Routine Description:
**
**	The exported function that is called to simulate a snapshot creation to allow
**	backup to drive the shim writers rather than having the snapshot co-ordinator
**	do so.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the simulated prepare/freeze
**	ulOptionFlags		Options required for this freeze selected from the following list:-
**				    VSS_SW_BOOTABLE_STATE
**
**	ulVolumeCount		Number of volumes in the volume array
**	ppwszVolumeNamesArray   Array of pointer to volume name strings
**	hCompletionEvent	Handle to an event which will be set when the asynchronous freeze completes
**	phrCompletionStatus	Pointer to an HRESULT which will receive the completion status when the
**				asynchronous freeze completes
**
**
**  Return Value:
**
**	Any HRESULT from the Snapshot writer PrepareForFreeze or Freeze functions.
**
**--
*/

__declspec(dllexport) HRESULT APIENTRY SimulateSnapshotFreeze (
    IN GUID         guidSnapshotSetId,
    IN ULONG        ulOptionFlags,	
    IN ULONG        ulVolumeCount,	
    IN LPWSTR     *ppwszVolumeNamesArray,
    OUT IVssAsync **ppAsync )							
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::SimulateSnapshotFreeze");
    BOOL		bSucceeded;

    try
	{
	/*
	** WARNING: If SimulateSnapshotFreeze can ever be called from inside the VsSvc process,
	** the following critical section entry can cause a deadlock.  The assumption is that
	** g_cCritSec is different from the one acquired in SimulateSnapshotFreezeInternal().
	*/
	CBsAutoLock cAutoLock (g_cCritSec);
	
        BOOL  bPrivilegesSufficient = FALSE;
	bPrivilegesSufficient = IsProcessBackupOperator ();

	ft.ThrowIf (!bPrivilegesSufficient,
		    VSSDBG_SHIM,
		    E_ACCESSDENIED,
		    L"FAILED as insufficient privileges to call shim");

        //
        //  Most parameter checks should be done here in the VssApi DLL and not in the
        //  IVssCoordinator::SimulateSnapshotFreeze method since the shim DLL can be
        //  changed independently from the service.  The service is just a forwarding
        //  agent to get SimulateSnapshotFreezeInternal called within one of the
        //  service's threads.
        //

	ft.ThrowIf ((ulOptionFlags & ~VSS_SW_BOOTABLE_STATE) != 0,
		    VSSDBG_SHIM,
		    E_INVALIDARG,
		    L"FAILED as illegal option flags set");


	ft.ThrowIf (!((ulOptionFlags & VSS_SW_BOOTABLE_STATE) || (ulVolumeCount > 0)),
		    VSSDBG_SHIM,
		    E_INVALIDARG,
		    L"FAILED as need either BootableState or a volume list");


	ft.ThrowIf ((ulVolumeCount > 0) && (NULL == ppwszVolumeNamesArray),
		    VSSDBG_SHIM,
		    E_INVALIDARG,
		    L"FAILED as need at least a one volume in the list if not bootable state");


	ft.ThrowIf ((GUID_NULL == guidSnapshotSetId),
		    VSSDBG_SHIM,
		    E_INVALIDARG,
		    L"FAILED as supplied SnapshotSetId should not be GUID_NULL");

	ft.ThrowIf ((NULL == ppAsync),
		    VSSDBG_SHIM,
		    E_INVALIDARG,
		    L"FAILED as supplied ppAsync parameter is NULL");

        *ppAsync = NULL;

	/*
	** Try to scan all the volume names in an attempt to trigger
	** an access violation to catch it here rather than in an
	** unfortunate spot later on. It also gives us the
	** opportinutiy to do some very basic validity checks.
	*/
	for (ULONG ulIndex = 0; ulIndex < ulVolumeCount; ulIndex++)
	    {
	    ft.ThrowIf (NULL == ppwszVolumeNamesArray [ulIndex],
			VSSDBG_SHIM,
			E_INVALIDARG,
			L"FAILED as NULL value in volume array");

	    ft.ThrowIf (wcslen (L"C:") > wcslen (ppwszVolumeNamesArray [ulIndex]),
			VSSDBG_SHIM,
			E_INVALIDARG,
			L"FAILED as volume name too short");
	    }

	/*
	** Now we need to connect to the VssSvc service's IVssCoordinator object
	** and make the simulate freeze happen.
	*/
	ft.ThrowIf ( g_pIShim != NULL,
	             VSSDBG_SHIM,
	             VSS_E_SNAPSHOT_SET_IN_PROGRESS,
                     L"SimulateSnapshotThaw() must first be called by this process before calling SimulateSnapshotFreeze() again." );

    ft.LogVssStartupAttempt();
	ft.hr = CoCreateInstance(
	                        CLSID_VSSCoordinator,
				NULL,
				CLSCTX_LOCAL_SERVER,
				IID_IVssShim,
				(void **) &g_pIShim
				);
    LogAndThrowOnFailure (ft, NULL, L"CoCreateInstance( CLSID_VSSCoordinator, IID_IVssShim)");

	BS_ASSERT( g_pIShim != NULL );
	
    g_guidSnapshotInProgress = guidSnapshotSetId;

    /*
    ** Now call the simulate freeze method in the coordinator
    */
    ft.hr = g_pIShim->SimulateSnapshotFreeze(
            guidSnapshotSetId,
            ulOptionFlags,	
            ulVolumeCount,	
            ppwszVolumeNamesArray,
            ppAsync );
    LogAndThrowOnFailure (ft, NULL, L"IVssShim::SimulateSnapshotFreeze()");

	/*
	** The simulate freeze operation is now running in a thread in VssSvc.
	*/
	}
    VSS_STANDARD_CATCH (ft);

    return (ft.hr);
    } /* SimulateSnapshotFreeze () */

/*
**++
**
**  Routine Description:
**
**	The exported function that is called to simulate a snapshot thaw to allow
**	backup to drive the shim writers rather than having the snapshot co-ordinator
**	do so.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the simulated prepare/freeze
**
**
**  Return Value:
**
**	Any HRESULT from the Snapshot writer Thaw functions.
**
**--
*/

__declspec(dllexport) HRESULT APIENTRY SimulateSnapshotThaw (
    IN GUID guidSnapshotSetId )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::SimulateSnapshotThaw");
    BOOL        bPrivilegesSufficient = FALSE;
    HRESULT	hrBootableState       = NOERROR;
    HRESULT	hrServiceState        = NOERROR;
    ThreadArgs  wtArgs;

    try
	{
	/*
	** WARNING: If SimulateSnapshotThaw can ever be called from inside the VsSvc process,
	** the following critical section entry can cause a deadlock.  The assumption is that
	** g_cCritSec is different from the one acquired in SimulateSnapshotThawInternal().
	*/
	CBsAutoLock cAutoLock (g_cCritSec);
	
	bPrivilegesSufficient = IsProcessBackupOperator ();

	ft.ThrowIf (!bPrivilegesSufficient,
		    VSSDBG_SHIM,
		    E_ACCESSDENIED,
		    L"FAILED as inssuficient privileges to call shim");

	/*
	** We need to make sure a prior SimulateSnapshotFreeze happened.
	*/
	ft.ThrowIf ( g_pIShim == NULL,
	             VSSDBG_SHIM,
	             VSS_E_BAD_STATE,
                     L"Called SimulateSnapshotThaw() without first calling SimulateSnapshotFreeze()" );

	ft.ThrowIf ( g_guidSnapshotInProgress != guidSnapshotSetId,
	             VSSDBG_SHIM,
	             VSS_E_BAD_STATE,
                     L"Mismatch between guidSnapshotSetId and the one passed into SimulateSnapshotFreeze()" );
	
        /*
        ** Now call the simulate thaw method in the coordinator
        */
        ft.hr = g_pIShim->SimulateSnapshotThaw( guidSnapshotSetId );

        /*
        ** Regardless of the outcome of the SimulateSnapshotThaw, get rid of the shim interface.
        */
        g_pIShim->Release();
        g_pIShim = NULL;
        g_guidSnapshotInProgress = GUID_NULL;

        LogAndThrowOnFailure (ft, NULL, L"IVssShim::SimulateSnapshotThaw()");
	}
    VSS_STANDARD_CATCH (ft);

    return (ft.hr);
    } /* SimulateSnapshotThaw () */

/*
**++
**
**  Routine Description:
**
**	Internal routine to package up the calls to deliver the
**	PrepareForSnapshot and Freeze events.
**
**  NOTE: This function is called outside the DLL by a thread in the VsSvc process.  Its
**  entry point is returned from RegisterSnapshotSubscriptions and is NOT exported by
**  the DLL.
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the simulated prepare/freeze
**	ulOptionFlags		Options required for this freeze selected from the following list:-
**				    VSS_SW_BOOTABLE_STATE
**
**	ulVolumeCount		Number of volumes in the volume array
**	ppwszVolumeNamesArray   Array of pointer to volume name strings
**      pbCancelAsync           Pointer to a bool that may become set to true while the freeze
**                              operation is underway.  When it becomes true, the freeze operation
**                              should stop.
**
**  Return Value:
**
**	Any HRESULT from the Snapshot writer PrepareForFreeze or Freeze functions.
**
**--
*/

HRESULT APIENTRY SimulateSnapshotFreezeInternal (
    IN GUID     guidSnapshotSetId,
    IN ULONG    ulOptionFlags,
    IN ULONG    ulVolumeCount,
    IN LPWSTR  *ppwszVolumeNamesArray,
    IN volatile bool *pbCancelAsync )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::SimulateSnapshotFreezeInternal");

    HRESULT		hrBootableState = NOERROR;
    HRESULT		hrServiceState  = NOERROR;
    ThreadArgs		wtArgs;
    PPWCHAR		rpwszNormalisedVolumeNameArray = NULL;

    g_hrSimulateFreezeStatus = NOERROR;

    try
	{
	CBsAutoLock cAutoLock (g_cCritSec);

        ft.ThrowIf ( pbCancelAsync == NULL,
                     VSSDBG_SHIM,
                     E_INVALIDARG,
                     L"pbCancelAsync is NULL" );

        ft.ThrowIf ( *pbCancelAsync,
                     VSSDBG_SHIM,
                     VSS_S_ASYNC_CANCELLED,
                     L"User cancelled async operation - 1" );

	if (!g_bGlobalStateInitialised)
	    {
	    // This should be impossible since the only way an external caller of this
	    // DLL can call this function is by getting the address of this function
	    // by calling RegisterSnapshotSubscriptions first.
	    ft.Throw ( VSSDBG_SHIM,
		       VSS_E_BAD_STATE,
			L"SimulateSnapshotFreezeInternal called before RegisterSnapshotSubscriptions was called or after UnregisterSnapshotSubscriptions was called");
	    }
	
	BS_ASSERT ((g_bGlobalStateInitialised)              &&
		   (NULL != g_pCVssWriterShimBootableState) &&
		   (NULL != g_pCVssWriterShimServiceState));

	ft.hr = NormaliseVolumeArray (ulVolumeCount,
				      ppwszVolumeNamesArray,
				      &rpwszNormalisedVolumeNameArray);

	ft.ThrowIf (ft.HrFailed (),
		    VSSDBG_SHIM,
		    ft.hr,
		    L"FAILED as unable to normalise volume array");

	ft.ThrowIf (g_guidSnapshotInProgress != GUID_NULL,
		    VSSDBG_SHIM,
		    VSS_E_SNAPSHOT_SET_IN_PROGRESS,
		    L"FAILED due to unmatched SimulateSnapshotFreeze()");

        ft.ThrowIf ( *pbCancelAsync,
                     VSSDBG_SHIM,
                     VSS_S_ASYNC_CANCELLED,
                     L"User cancelled async operation - 2" );

	g_guidSnapshotInProgress = guidSnapshotSetId;

	wtArgs.wtArgsPrepareForSnapshot.bBootableStateBackup  = ((ulOptionFlags & VSS_SW_BOOTABLE_STATE) != 0);
	wtArgs.wtArgsPrepareForSnapshot.guidSnapshotSetId     = guidSnapshotSetId;
	wtArgs.wtArgsPrepareForSnapshot.ulVolumeCount         = ulVolumeCount;
	wtArgs.wtArgsPrepareForSnapshot.ppwszVolumeNamesArray = (LPCWSTR *)rpwszNormalisedVolumeNameArray;
	wtArgs.wtArgsPrepareForSnapshot.pbCancelAsync         = pbCancelAsync;

	hrServiceState  = g_pCVssWriterShimServiceState->WorkerThreadRequestOperation  (eOpDeliverEventPrepareForSnapshot,
											&wtArgs);

	hrBootableState = g_pCVssWriterShimBootableState->WorkerThreadRequestOperation (eOpDeliverEventPrepareForSnapshot,
											&wtArgs);

	ft.ThrowIf (FAILED (hrServiceState),
		    VSSDBG_SHIM,
		    hrServiceState,
		    L"FAILED sending PrepareForSnapshot events to Service state writers");

	ft.ThrowIf (FAILED (hrBootableState),
		    VSSDBG_SHIM,
		    hrBootableState,
		    L"FAILED sending PrepareForSnapshot events to Bootable state writers");

        ft.ThrowIf ( *pbCancelAsync,
                     VSSDBG_SHIM,
                     VSS_S_ASYNC_CANCELLED,
                     L"User cancelled async operation - 3" );
	
	wtArgs.wtArgsFreeze.guidSnapshotSetId = guidSnapshotSetId;
	wtArgs.wtArgsFreeze.pbCancelAsync     = pbCancelAsync;

	hrServiceState  = g_pCVssWriterShimServiceState->WorkerThreadRequestOperation  (eOpDeliverEventFreeze, &wtArgs);
	hrBootableState = g_pCVssWriterShimBootableState->WorkerThreadRequestOperation (eOpDeliverEventFreeze, &wtArgs);

	ft.ThrowIf (FAILED (hrServiceState),
		    VSSDBG_SHIM,
		    hrServiceState,
		    L"FAILED sending Freeze events to Service state writers");

	ft.ThrowIf (FAILED (hrBootableState),
		    VSSDBG_SHIM,
		    hrBootableState,
		    L"FAILED sending Freeze events to Bootable state writers");

	}
    VSS_STANDARD_CATCH (ft);

    CleanupVolumeArray (&rpwszNormalisedVolumeNameArray);

    // Store away the freeze status
    g_hrSimulateFreezeStatus = ft.hr;

    return (ft.hr);
    } /* SimulateSnapshotFreezeInternal () */

/*
**++
**
**  Routine Description:
**
**  NOTE: This function is called outside the DLL by a thread in the VsSvc process.  Its
**  entry point is returned from RegisterSnapshotSubscriptions and is NOT exported by
**  the DLL.
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the simulated prepare/freeze
**
**
**  Return Value:
**
**	Any HRESULT from the Snapshot writer Thaw functions.
**
**--
*/

HRESULT APIENTRY SimulateSnapshotThawInternal (
    IN GUID guidSnapshotSetId )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::SimulateSnapshotThawInternal");
    HRESULT		hrBootableState       = NOERROR;
    HRESULT		hrServiceState        = NOERROR;
    ThreadArgs		wtArgs;

    try
	{
	CBsAutoLock cAutoLock (g_cCritSec);

	if (!g_bGlobalStateInitialised)
	    {
	    // This should be impossible since the only way an external caller of this
	    // DLL can call this function is by getting the address of this function
	    // by calling RegisterSnapshotSubscriptions first.
	    ft.Throw ( VSSDBG_SHIM,
		       VSS_E_BAD_STATE,
			L"SimulateSnapshotThawInternal called before RegisterSnapshotSubscriptions was called or after UnregisterSnapshotSubscriptions was called");
	    }
	
	ft.ThrowIf (g_guidSnapshotInProgress == GUID_NULL && SUCCEEDED( g_hrSimulateFreezeStatus ),
		    VSSDBG_SHIM,
		    VSS_E_BAD_STATE,
		    L"FAILED as SimulateSnapshotFreezeInternal() has not been called");

	ft.ThrowIf (g_guidSnapshotInProgress != guidSnapshotSetId,
		    VSSDBG_SHIM,
		    VSS_E_BAD_STATE,
		    L"FAILED due to incorrect SnapshotSetId");

	BS_ASSERT ((g_bGlobalStateInitialised)              &&
		   (NULL != g_pCVssWriterShimBootableState) &&
		   (NULL != g_pCVssWriterShimServiceState));

        // If the simulate snapshot freeze was successful, send thaw events to the mini-writers otherwise send
        // abort events.  Bug # 286927.
        if ( SUCCEEDED( g_hrSimulateFreezeStatus ) )
            {
            wtArgs.wtArgsThaw.guidSnapshotSetId = guidSnapshotSetId;
	    hrServiceState  = g_pCVssWriterShimServiceState->WorkerThreadRequestOperation  (eOpDeliverEventThaw, &wtArgs);
	    hrBootableState = g_pCVssWriterShimBootableState->WorkerThreadRequestOperation (eOpDeliverEventThaw, &wtArgs);
            }
        else
            {
            wtArgs.wtArgsAbort.guidSnapshotSetId = guidSnapshotSetId;
	    hrServiceState  = g_pCVssWriterShimServiceState->WorkerThreadRequestOperation  (eOpDeliverEventAbort, &wtArgs);
	    hrBootableState = g_pCVssWriterShimBootableState->WorkerThreadRequestOperation (eOpDeliverEventAbort, &wtArgs);
            }

	ft.ThrowIf (FAILED (hrServiceState),
		    VSSDBG_SHIM,
		    hrServiceState,
		    L"FAILED sending Thaw events to Service state writers");

	ft.ThrowIf (FAILED (hrBootableState),
		    VSSDBG_SHIM,
		    hrBootableState,
		    L"FAILED sending Thaw events to Bootable state writers");

	g_guidSnapshotInProgress = GUID_NULL;
	g_hrSimulateFreezeStatus = NOERROR;
	}
    VSS_STANDARD_CATCH (ft);

    return (ft.hr);
    } /* SimulateSnapshotThawInternal () */

/*
**++
**
**  Routine Description:
**
**	The exported function that is called to check if a volume is snapshotted
**
**
**  Arguments:
**
**      IN VSS_PWSZ pwszVolumeName      - The volume to be checked.
**      OUT BOOL * pbSnapshotsPresent   - Returns TRUE if the volume is snapshotted.
**
**
**  Return Value:
**
**	Any HRESULT from the IVssCoordinator::IsVolumeSnapshotted.
**
**--
*/

__declspec(dllexport) HRESULT APIENTRY IsVolumeSnapshotted (
        IN VSS_PWSZ pwszVolumeName,
        OUT BOOL *  pbSnapshotsPresent,
    	OUT LONG *  plSnapshotCompatibility
        )
{
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::IsVolumeSnapshotted");
    BOOL		bPrivilegesSufficient = FALSE;
    SC_HANDLE		shSCManager = NULL;
    SC_HANDLE		shSCService = NULL;
    DWORD		dwOldState  = 0;

    try
	{
	    // Zero out the out parameter
	    ::VssZeroOut(pbSnapshotsPresent);
	    ::VssZeroOut(plSnapshotCompatibility);
	
    	bPrivilegesSufficient = IsProcessAdministrator ();
    	ft.ThrowIf (!bPrivilegesSufficient,
    		    VSSDBG_SHIM,
    		    E_ACCESSDENIED,
    		    L"FAILED as insufficient privileges to call shim");

    	ft.ThrowIf ( (pwszVolumeName == NULL) || (pbSnapshotsPresent == NULL),
    		    VSSDBG_SHIM,
    		    E_INVALIDARG,
    		    L"FAILED as invalid parameters");

    	CBsAutoLock cAutoLock (g_cCritSec);

        //
        //  Check to see if VSSVC is running. If not ,we are supposing that no snapshots are present on the system.
        //

    	// Connect to the local service control manager
        shSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_CONNECT);
        if (!shSCManager)
            ft.TranslateGenericError(VSSDBG_SHIM, HRESULT_FROM_WIN32(GetLastError()),
                L"OpenSCManager(NULL,NULL,SC_MANAGER_CONNECT)");

    	// Get a handle to the service
        shSCService = OpenService (shSCManager, wszVssvcServiceName, SERVICE_QUERY_STATUS);
        if (!shSCService)
            ft.TranslateGenericError(VSSDBG_SHIM, HRESULT_FROM_WIN32(GetLastError()),
                L" OpenService (shSCManager, \'%s\', SERVICE_QUERY_STATUS)", wszVssvcServiceName);

    	// Now query the service to see what state it is in at the moment.
        SERVICE_STATUS	sSStat;
        if (!QueryServiceStatus (shSCService, &sSStat))
            ft.TranslateGenericError(VSSDBG_SHIM, HRESULT_FROM_WIN32(GetLastError()),
                L"QueryServiceStatus (shSCService, &sSStat)");

        // BUG 250943: Only if the service is running then check to see if there are any snapsnots
        if (sSStat.dwCurrentState == SERVICE_RUNNING) {

            // Create the coordinator interface
        	CComPtr<IVssCoordinator> pCoord;

            // The service is already started, but...
            // We still log here in order to make our code more robust.
            ft.LogVssStartupAttempt();

            // Create the instance.
        	ft.hr = pCoord.CoCreateInstance(CLSID_VSSCoordinator);
        	if (ft.HrFailed())
                ft.TranslateGenericError(VSSDBG_SHIM, ft.hr, L"CoCreateInstance(CLSID_VSSCoordinator)");
            BS_ASSERT(pCoord);

            // Call IsVolumeSnapshotted on the coordinator
            ft.hr = pCoord->IsVolumeSnapshotted(
                        GUID_NULL,
                        pwszVolumeName,
                        pbSnapshotsPresent,
                        plSnapshotCompatibility);
        }
        else
        {
            // If the service is not running, then try to see if we have only MS Software Provider installed
            
			// Open the "Providers" key. Throw an error if the key does not exist.
            CVssRegistryKey keyProviders;
            if (!keyProviders.Open( HKEY_LOCAL_MACHINE, L"%s\\%s", wszVSSKey, wszVSSKeyProviders))
                ft.TranslateGenericError(VSSDBG_SHIM, ft.hr, L"RegOpenKeyExW(%ld,%s\\%s,...) = ERROR_FILE_NOT_FOUND", 
                    HKEY_LOCAL_MACHINE, wszVSSKey, wszVSSKeyProviders);
                
            // Attach an enumerator to the subkeys the subkeys 
            CVssRegistryKeyIterator iter;
            iter.Attach(keyProviders);
            BS_ASSERT(!iter.IsEOF());

            // Get the number of subkeys. If different than one, the we sould go with the standard path
            // If it is only one, this is the MS software provider (since it is always registered)
            if (iter.GetSubkeysCount() != 1)
            {
                // Create the instance.
            	CComPtr<IVssCoordinator> pCoord;
            	ft.hr = pCoord.CoCreateInstance(CLSID_VSSCoordinator);
            	if (ft.HrFailed())
                    ft.TranslateGenericError(VSSDBG_SHIM, ft.hr, L"CoCreateInstance(CLSID_VSSCoordinator)");
                BS_ASSERT(pCoord);

                // Call IsVolumeSnapshotted on the coordinator
                ft.hr = pCoord->IsVolumeSnapshotted(
                            GUID_NULL,
                            pwszVolumeName,
                            pbSnapshotsPresent,
                            plSnapshotCompatibility);
            }
            else
            {
            	// Getting the volume name
            	WCHAR wszVolumeNameInternal[nLengthOfVolMgmtVolumeName + 1];
            	if (!::GetVolumeNameForVolumeMountPointW( pwszVolumeName,
            			wszVolumeNameInternal, ARRAY_LEN(wszVolumeNameInternal)))
            		ft.Throw( VSSDBG_SHIM, VSS_E_OBJECT_NOT_FOUND,
            				  L"GetVolumeNameForVolumeMountPoint(%s,...) "
            				  L"failed with error code 0x%08lx", pwszVolumeName, GetLastError());
            	BS_ASSERT(::wcslen(wszVolumeNameInternal) != 0);
            	BS_ASSERT(::IsVolMgmtVolumeName( wszVolumeNameInternal ));
            	
                // Check if the volume is fixed (i.e. no CD-ROM, no removable)
                UINT uDriveType = ::GetDriveTypeW(wszVolumeNameInternal);
                if ( uDriveType != DRIVE_FIXED) 
                    ft.Throw( VSSDBG_SHIM, VSS_E_VOLUME_NOT_SUPPORTED, 
                            L"Encountering a non-fixed volume (%s) - %ud",
                            pwszVolumeName, uDriveType);

                // Open the volume. Throw "object not found" if needed.
            	CVssIOCTLChannel volumeIChannel;	
            	ft.hr = volumeIChannel.Open(ft, wszVolumeNameInternal, true, false, VSS_ICHANNEL_LOG_NONE);
            	if (ft.HrFailed())
                    ft.Throw( VSSDBG_SHIM, VSS_E_VOLUME_NOT_SUPPORTED, 
                            L"Volume (%s) not supported for snapshots 0x%08lx",
                            pwszVolumeName, ft.hr);

                // Check to see if there are existing snapshots
            	ft.hr = volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, false);
            	if (ft.HrFailed())
                    ft.Throw( VSSDBG_SHIM, VSS_E_VOLUME_NOT_SUPPORTED, 
                            L"Volume (%s) not supported for snapshots 0x%08lx",
                            pwszVolumeName, ft.hr);

            	// Get the length of snapshot names multistring
            	ULONG ulMultiszLen;
            	volumeIChannel.Unpack(ft, &ulMultiszLen);

                // If the multistring is empty, then ulMultiszLen is necesarily 2
                // (i.e. two l"\0' characters)
                // Then mark the volume as snapshotted.
            	if (ulMultiszLen != nEmptyVssMultiszLen) 
            	{
            	    (*pbSnapshotsPresent) = TRUE;
            	    (*plSnapshotCompatibility) = (VSS_SC_DISABLE_DEFRAG|VSS_SC_DISABLE_CONTENTINDEX);
            	}
            }
        }
	} VSS_STANDARD_CATCH (ft);

    // Close handles
    if (NULL != shSCService) CloseServiceHandle (shSCService);
    if (NULL != shSCManager) CloseServiceHandle (shSCManager);

    // Convert the "volume not supported into S_OK.
    if (ft.hr == VSS_E_VOLUME_NOT_SUPPORTED)
        ft.hr = S_OK;

    return (ft.hr);
} /* IsVolumeSnapshotted () */


/*
**++
**
**  Routine Description:
**
**	This routine is used to free the contents of hte VSS_SNASPHOT_PROP structure
**
**
**  Arguments:
**
**      IN VSS_SNAPSHOT_PROP*  pProp
**
**--
*/

__declspec(dllexport) void APIENTRY VssFreeSnapshotProperties (
        IN VSS_SNAPSHOT_PROP*  pProp
        )
{
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"VssAPI::VssFreeSnapshotProperties");

    if (pProp) {
        ::CoTaskMemFree(pProp->m_pwszSnapshotDeviceObject);
        ::CoTaskMemFree(pProp->m_pwszOriginalVolumeName);
        ::CoTaskMemFree(pProp->m_pwszOriginatingMachine);
        ::CoTaskMemFree(pProp->m_pwszServiceMachine);
        ::CoTaskMemFree(pProp->m_pwszExposedName);
        ::CoTaskMemFree(pProp->m_pwszExposedPath);
    }
} /* VssFreeSnapshotProperties () */


/*
**************************************************************
**************************************************************
**
** CShimWriter implementation
**
**
**************************************************************
**************************************************************
*/

/*
**++
**
**  Routine Description:
**
**	Set of constructors for the CShimWriter class which
**	iniatialise all of the data member of the class, either to
**	default values or to some supplied parameters.
**
**	This class is used to manage instance of a single sub or
**	mini-writer which does basic backup of a single service or
**	entity.
**
**	A collection of these mini-writers is managed by the
**	CVssWriterShim class which connects this group of mini-writers
**	to the main snapshot coordination engine.
**
**	Effectively the CShimWriter class looks down to the
**	mini-writer and the CVssWriterShim class looks up up to the
**	coordinator.
**
**
**  Arguments:
**
**	swtWriterType                             Does this writer need to be invoked
**						  for bootable (aka System) state backups
**	pwszWriterName	                          Name of the shim writer
**	pwszTargetPath	(optional, default NULL)  Path used to save any 'spit' files
**
**
**  Return Value:
**
**	None
**--
*/

CShimWriter::CShimWriter(LPCWSTR pwszWriterName) :
	m_bBootableStateWriter(FALSE),
	m_pwszWriterName(pwszWriterName),
	m_pwszTargetPath(NULL),
	m_ssCurrentState(stateUnknown),
	m_hrStatus(NOERROR),
	m_bParticipateInBackup(FALSE),
	m_ulVolumeCount(0),
	m_ppwszVolumeNamesArray(NULL),
	m_pIVssCreateWriterMetadata(NULL),
	m_pIVssWriterComponents(NULL)
    {
    }


CShimWriter::CShimWriter(LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) :
	m_bBootableStateWriter(FALSE),
	m_pwszWriterName(pwszWriterName),
	m_pwszTargetPath(pwszTargetPath),
	m_ssCurrentState(stateUnknown),
	m_hrStatus(NOERROR),
	m_bParticipateInBackup(FALSE),
	m_ulVolumeCount(0),
	m_ppwszVolumeNamesArray(NULL),
	m_pIVssCreateWriterMetadata(NULL),
	m_pIVssWriterComponents(NULL)
    {
    }


CShimWriter::CShimWriter(LPCWSTR pwszWriterName, BOOL bBootableStateWriter) :
	m_bBootableStateWriter(bBootableStateWriter),
	m_pwszWriterName(pwszWriterName),
	m_pwszTargetPath(NULL),
	m_ssCurrentState(stateUnknown),
	m_hrStatus(NOERROR),
	m_bParticipateInBackup(FALSE),
	m_ulVolumeCount(0),
	m_ppwszVolumeNamesArray(NULL),
	m_pIVssCreateWriterMetadata(NULL),
	m_pIVssWriterComponents(NULL)
    {
    }


CShimWriter::CShimWriter(LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath, BOOL bBootableStateWriter) :
	m_bBootableStateWriter(bBootableStateWriter),
	m_pwszWriterName(pwszWriterName),
	m_pwszTargetPath(pwszTargetPath),
	m_ssCurrentState(stateUnknown),
	m_hrStatus(NOERROR),
	m_bParticipateInBackup(FALSE),
	m_ulVolumeCount(0),
	m_ppwszVolumeNamesArray(NULL),
	m_pIVssCreateWriterMetadata(NULL),
	m_pIVssWriterComponents(NULL)
    {
    }



/*
**++
**
**  Routine Description:
**
**	Destructor for the CShimWriter class.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	None
**--
*/

CShimWriter::~CShimWriter()
    {
    }

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoStartup() method and to set the writer state
**	appropriately.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoStartup() method.
**--
*/

HRESULT CShimWriter::Startup ()
    {
    HRESULT hrStatus = SetState (stateStarting, NOERROR);

    if (SUCCEEDED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Startup: Sending Startup to %s", m_pwszWriterName));

	hrStatus = SetState (stateStarted, DoStartup ());

	LogFailure (NULL, hrStatus, hrStatus, m_pwszWriterName, L"CShimWriter::DoStartup", L"CShimWriter::Startup");
	}


    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Startup: FAILURE (0x%08X) in state %s sending Startup to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::Startup () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoIdentify() method and to update the writer metadata
**	appropriately.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoThaw() method.
**--
*/

HRESULT CShimWriter::Identify (IN IVssCreateWriterMetadata *pIVssCreateWriterMetadata)
    {
    HRESULT	hrStatus = NOERROR;

    BsDebugTraceAlways (0,
			DEBUG_TRACE_VSS_SHIM,
			(L"CShimWriter::Identify: Sending Identify to %s", m_pwszWriterName));

    m_pIVssCreateWriterMetadata = pIVssCreateWriterMetadata;


    hrStatus = DoIdentify ();

    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Identify: FAILURE (0x%08X) in state %s sending Identify to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    m_pIVssCreateWriterMetadata = NULL;

    return (hrStatus);
    } /* CShimWriter::Identify () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoPrepareForSnapshot() method and to set the writer state
**	appropriately.
**
**	It also checks to see if this shim writer is a bootable
**	state writer and if so only calls it on a bootable state
**	backup.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoPrepareForSnapshot() method.
**--
*/

HRESULT CShimWriter::PrepareForSnapshot (
					 IN BOOL     bBootableStateBackup,
					 IN ULONG    ulVolumeCount,
					 IN LPCWSTR *ppwszVolumeNamesArray)
    {
    HRESULT	hrStatus = SetState (statePreparingForSnapshot, NOERROR);


    if (SUCCEEDED (hrStatus))
	{
	/*
	** Ensure no garbage left over from a previous run
	*/
	hrStatus = CleanupTargetPath (m_pwszTargetPath);

        if ( FAILED( hrStatus ) )                
            {
            LogFailure (NULL, hrStatus, hrStatus, m_pwszWriterName, L"CleanupTargetPath", L"CShimWriter::PrepareForSnapshot");
            }
        }

    if (SUCCEEDED( hrStatus ) )
        {
	m_ulVolumeCount         = ulVolumeCount;
	m_ppwszVolumeNamesArray = ppwszVolumeNamesArray;
	m_bParticipateInBackup  = TRUE;


	if (( m_bBootableStateWriter && bBootableStateBackup) ||
	    (!m_bBootableStateWriter && (ulVolumeCount > 0)))
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"CShimWriter::PrepareForSnapshot: Sending PrepareForSnapshot to %s",
				 m_pwszWriterName));


	    hrStatus = CreateTargetPath (m_pwszTargetPath);

	    if (SUCCEEDED (hrStatus))
		{
		hrStatus = DoPrepareForSnapshot ();
		}

	    if (!m_bParticipateInBackup)
		{
		/*
		** The writer has chosen to exclude itself so we should
		** clean up the target path to prevent confusing the
		** backup app.
		*/
		BsDebugTraceAlways (0,
				    DEBUG_TRACE_VSS_SHIM,
				    (L"CShimWriter::PrepareForSnapshot: Self-exclusion from further participation by %s",
				     m_pwszWriterName));

		CleanupTargetPath (m_pwszTargetPath);
		}
	    }

	else
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"CShimWriter::PrepareForSnapshot: Wrong WriterType/BackupType/VolumeCount combination - "
				 L"no further participation from %s",
				 m_pwszWriterName));

	    m_bParticipateInBackup = FALSE;
	    }


	hrStatus = SetState (statePreparedForSnapshot, hrStatus);
	}


    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::PrepareForSnapshot: FAILURE (0x%08X) in state %s sending PrepareForSnapshot to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::PrepareForSnapshot () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoFreeze() method and to set the writer state
**	appropriately.
**
**	It also checks to see if this shim writer is a bootable
**	state writer and if so only calls it on a bootable state
**	backup.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoFreeze() method.
**--
*/

HRESULT CShimWriter::Freeze ()
    {
    HRESULT	hrStatus = NOERROR;

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = SetState (stateFreezing, NOERROR);
	}

    if (SUCCEEDED (hrStatus))
	{
	if (m_bParticipateInBackup)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"CShimWriter::Freeze: Sending Freeze to %s", m_pwszWriterName));

	    hrStatus = DoFreeze ();
	    }

	hrStatus = SetState (stateFrozen, hrStatus);
	}


    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Freeze: FAILURE (0x%08X) in state %s sending Freeze to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::Freeze () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoThaw() method and to set the writer state
**	appropriately.
**
**	It also checks to see if this shim writer is a bootable
**	state writer and if so only calls it on a bootable state
**	backup.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoThaw() method.
**--
*/

HRESULT CShimWriter::Thaw ()
    {
    HRESULT	hrStatus = NOERROR;

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = SetState (stateThawing, NOERROR);
	}

    if (SUCCEEDED (hrStatus))
	{
	if (m_bParticipateInBackup)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"CShimWriter::Thaw: Sending Thaw to %s", m_pwszWriterName));

	    hrStatus = DoThaw ();
	    }

	hrStatus = SetState (stateThawed, hrStatus);
	}

    //  Clean up
    CleanupTargetPath (m_pwszTargetPath);

    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Thaw: FAILURE (0x%08X) in state %s sending Thaw to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::Thaw () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoAbort() method and to set the writer state
**	appropriately.
**
**	It also checks to see if this shim writer is a bootable
**	state writer and if so only calls it on a bootable state
**	backup.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoThaw() method.
**--
*/

HRESULT CShimWriter::Abort ()
    {
    //  The global snapshot set id may be NULL in certain cases.  Bug #289822.
    HRESULT	hrStatus = NOERROR;

    if (SUCCEEDED (hrStatus))
	{
	hrStatus = SetState (stateAborting, NOERROR);
	}

    if (SUCCEEDED (hrStatus))
	{
	if (m_bParticipateInBackup)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"CShimWriter::Abort: Sending Abort to %s", m_pwszWriterName));

	    hrStatus = DoAbort ();
	    }

	hrStatus = SetState (stateThawed, hrStatus);
	}


    //  Clean up
    CleanupTargetPath (m_pwszTargetPath);

    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Abort: FAILURE (0x%08X) in state %s sending Abort to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::Abort () */

/*
**++
**
**  Routine Description:
**
**	Wrapper to invoke either the default or overridden
**	DoShutdown() method and to set the writer state
**	appropriately.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from the shim writer DoShutdown() method.
**--
*/

HRESULT CShimWriter::Shutdown ()
    {
    HRESULT hrStatus = SetState (stateFinishing, NOERROR);

    if (SUCCEEDED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Shutdown: Sending Shutdown to %s", m_pwszWriterName));

	hrStatus = SetState (stateFinished, DoShutdown ());
	}


    if (FAILED (hrStatus))
	{
	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::Shutdown: FAILURE (0x%08X) in state %s sending Shutdown to %s",
			     hrStatus,
			     GetStringFromStateCode (m_ssCurrentState),
			     m_pwszWriterName));
	}


    return (hrStatus);
    } /* CShimWriter::Shutdown () */

/*
**++
**
**  Routine Description:
**
**	Routine (and associated table) describing the states the shim
**	writers can get in to. Shim writer always follow this table and
**	if they fail, can deposit the failure code in the status member
**	variable under the control of this routine.
**
**	Note that entering the Thawing or Finishing states are kind of
**	like a reset on the status as one of the requirements on the
**	shim is that a Thaw event or unload need to make sure that the
**	writers have cleaned up.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Success
**	HRESULT for ERROR_INVALID_STATE for an illegal transition attempt
**	failure code from a previous (failed) operation
**--
*/


/*
** This table describes the set of legal state transitions that a shim
** writer should follow. That is, for a given current state
** ('CurState'), which new states ('NewState') are legal. For example,
** going from 'Started' to 'Preparing' is leagal but from Started' to
** 'Freezing' is no.
**
** Each externally visible state is actually a combination of an
** 'step-in-progress' state and a 'step-completed state eg 'starting'
** and 'started'.
**
** The normal sequence of states for a writer is expected to be :-
**
**	   Unknown
**	to Started
**	to Prepared
**	to Frozen
**	to Thawed
**	to Finished or Prepared
**
** There are a couple of exceptions. For example, since for the shim
** writers a 'Thaw' request is equivalent to 'Abort' the 'Thawing'
** state can be reached from 'Prepared', 'Frozen' or 'Thawed'
*/
static BOOL StateTransitionTable [stateMaximumValue][stateMaximumValue] = {
    /*      NewState   Unknown Starting Started Preparing Prepared Freezing Frozen Thawing Aborting Thawed Finishing Finished */
    /* CurState                                                                                                      */
    /*    Unknown   */ {FALSE, TRUE,    FALSE,  FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   FALSE, TRUE,    FALSE },
    /*    Starting  */ {FALSE, FALSE,   TRUE,   FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   FALSE, TRUE,    FALSE },
    /*    Started   */ {FALSE, TRUE,    FALSE,  TRUE,     FALSE,   FALSE,   FALSE, FALSE,  TRUE,    FALSE, TRUE,     FALSE },
    /*    Preparing */ {FALSE, FALSE,   FALSE,  FALSE,    TRUE,    FALSE,   FALSE, FALSE,  TRUE,    FALSE, TRUE,    FALSE },
    /*    Prepared  */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   TRUE,    FALSE, FALSE,  TRUE,    FALSE, TRUE,     FALSE },
    /*    Freezing  */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   FALSE,   TRUE,  FALSE,  TRUE,    FALSE, TRUE,    FALSE },
    /*    Frozen    */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   FALSE,   FALSE, TRUE,   TRUE,    FALSE, TRUE,     FALSE },
    /*    Thawing   */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   TRUE,  TRUE,    FALSE },
    /*    Aborting  */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   TRUE,  TRUE,    FALSE },
    /*    Thawed    */ {FALSE, TRUE,    FALSE,  TRUE,     FALSE,   FALSE,   FALSE, FALSE,  TRUE,    FALSE, TRUE,     FALSE },
    /*    Finishing */ {FALSE, FALSE,   FALSE,  FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   FALSE, FALSE,    TRUE  },
    /*    Finished  */ {FALSE, TRUE,    FALSE,  FALSE,    FALSE,   FALSE,   FALSE, FALSE,  FALSE,   FALSE, TRUE,     TRUE  }};

LPCWSTR CShimWriter::GetStringFromStateCode (SHIMWRITERSTATE ssStateCode)
    {
    LPCWSTR pwszReturnedString = L"";

    switch (ssStateCode)
	{
	case stateUnknown:              pwszReturnedString = L"Unknown";              break;
	case stateStarting:             pwszReturnedString = L"Starting";             break;
	case stateStarted:              pwszReturnedString = L"Started";              break;
	case statePreparingForSnapshot: pwszReturnedString = L"PreparingForSnapshot"; break;
	case statePreparedForSnapshot:  pwszReturnedString = L"PreparedForSnapshot";  break;
	case stateFreezing:             pwszReturnedString = L"Freezing";             break;
	case stateFrozen:               pwszReturnedString = L"Frozen";               break;
	case stateThawing:              pwszReturnedString = L"Thawing";              break;
	case stateThawed:               pwszReturnedString = L"Thawed";               break;
	case stateAborting:             pwszReturnedString = L"Aborting";             break;
	case stateFinishing:            pwszReturnedString = L"Finishing";            break;
	case stateFinished:             pwszReturnedString = L"Finished";             break;
	default:                        pwszReturnedString = L"UNDEFINED STATE";      break;
	}

    return (pwszReturnedString);
    }


HRESULT CShimWriter::SetState (SHIMWRITERSTATE	ssNewState,
			       HRESULT		hrWriterStatus)
    {
    HRESULT hrStatus = S_OK;

    if (!StateTransitionTable [m_ssCurrentState][ssNewState])
	{
	//  Bad transition.  Only print out function tracer enter/exit stuff in this error case, otherwise
	//  we'll have too many trace messages.
        CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriter::SetState - INVALID STATE" );
	ft.Trace(VSSDBG_SHIM, L"MiniWriter: %s, OldState: %s, NewState: %s, hrWriterStatus: 0x%08x",
                m_pwszWriterName, GetStringFromStateCode( m_ssCurrentState ), GetStringFromStateCode( ssNewState ),
       	        hrWriterStatus);
	hrStatus = HRESULT_FROM_WIN32 (ERROR_INVALID_STATE);
	ft.hr = hrStatus;       //  Will print out in function exit trace.
	}
    else
	{
	/*
	** The status maintained by the shim writer class is the last
	** status returned by the writer where any failure status
	** 'latches' and cannot be overriden until we are entering
	** either a 'Aborting' or 'Finishing' state. In those cases
	** the maintained status is updated (effectively reset) with
	** whatever has been specified.
	*/
	if (SUCCEEDED (m_hrStatus)         ||
	    (stateAborting  == ssNewState) ||
	    (stateFinishing == ssNewState))
	    {
	    m_hrStatus = hrWriterStatus;
	    }

	m_ssCurrentState = ssNewState;

	hrStatus = m_hrStatus;
	}


    return (hrStatus);
    } /* CShimWriter::SetState () */

/*
**++
**
**  Routine Description:
**
**	Default implementations of the shim writer event routines that an
**	individual shim writer can choose to implement (over-ride) or not
**	as it sees fit.
**
**
**  Arguments (implicit):
**
**	None except m_pwszTargetPath for DoThaw() and DoShutdown()
**
**
**  Return Value:
**
**	NOERROR for the default routines
**	Any HRESULT from the shim writer overridden functions.
**--
*/

HRESULT CShimWriter::DoStartup ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoIdentify ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoPrepareForBackup ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoPrepareForSnapshot ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoFreeze ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoThaw ()
    {
    CleanupTargetPath (m_pwszTargetPath);

    return (NOERROR);
    }


HRESULT CShimWriter::DoAbort ()
    {
    return (DoThaw ());
    }


HRESULT CShimWriter::DoBackupComplete ()
    {
    return (NOERROR);
    }


HRESULT CShimWriter::DoShutdown ()
    {
    return (NOERROR);
    }




/*
**************************************************************
**************************************************************
**
** CVssWriterShim implementation
**
**
**************************************************************
**************************************************************
*/

/*
**++
**
**  Routine Description:
**
**	Constructor for the CVssWriterShim class which iniatialise all
**	of the data member of the class, either to default values or
**	to some supplied parameters.
**
**	This class is used to respond to events from the snapshot
**	coordinator and to distribute those events to a collection of
**	sub or mini-writers, a single instance of which is managed by
**	the CShimWriter class.
**
**	Effectively the CShimWriter class looks down to the
**	mini-writer and the CVssWriterShim lookup up to the
**	coordinator.
**
**
**  Arguments:
**
**	pwszWriterName		Name of the shim writer
**	idWriter		Id of the writer
**	bBootableState		Set for a bootable state writer
**	ulWriterCount		How many sub or mini-writers are managed
**	prpCShimWriterArray	Array of function pointer tables for mini-writers
**
**
**  Return Value:
**
**	None
**--
*/

CVssWriterShim::CVssWriterShim (LPCWSTR       pwszWriterName,
				LPCWSTR       pwszWriterSpitDirectoryRoot,
				VSS_ID        idWriter,
				BOOL          bBootableState,
				ULONG         ulWriterCount,
				PCShimWriter *prpCShimWriterArray) :
	m_pwszWriterName(pwszWriterName),
	m_pwszWriterSpitDirectoryRoot(pwszWriterSpitDirectoryRoot),
	m_idWriter(idWriter),
	m_bBootableState(bBootableState),
	m_hrInitialize(HRESULT_FROM_WIN32 (ERROR_NOT_READY)),
	m_bSubscribed(FALSE),
	m_ulWriterCount(ulWriterCount),
	m_prpCShimWriterArray(prpCShimWriterArray),
	m_bRegisteredInThisProcess(FALSE),
	m_bDirectStartupCalled(FALSE),
	m_eRequestedOperation(eOpUndefined),
	m_hrStatusRequestedOperation(HRESULT_FROM_WIN32 (ERROR_NOT_READY)),
	m_hEventOperationRequest(INVALID_HANDLE_VALUE),
	m_hEventOperationCompleted(INVALID_HANDLE_VALUE),
	m_hWorkerThread(INVALID_HANDLE_VALUE),
	m_eThreadStatus(eStatusNotRunning),
	m_hrWorkerThreadCompletionStatus(NOERROR)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CVssWriterShim::CVssWriterShim");

    memset (&m_wtArgs, 0x00, sizeof (m_wtArgs));
    } /* CVssWriterShim::CVssWriterShim () */


/*
**++
**
**  Routine Description:
**
**	Destructor for the CVssWriterShim class.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	None
**--
*/

CVssWriterShim::~CVssWriterShim ()
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CVssWriterShim::~CVssWriterShim");

    UnRegisterWriterShim ();

    DeliverEventShutdown ();

    CommonCloseHandle (&m_hEventOperationCompleted);
    CommonCloseHandle (&m_hEventOperationRequest);
    CommonCloseHandle (&m_hWorkerThread);
    } /* CVssWriterShim::~CVssWriterShim () */

/*
**++
**
**  Routine Description:
**
**	Registers all of the COM Event subscriptions by creating a
**	thread to call the event subscription routines. A thread is
**	used to ensure that there are no thread dependencies on any of
**	the shims thread when the COM event system delivers events.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT returned from the COM Subscription methods.
**	S_OK if no errors.
**
**--
*/

HRESULT CVssWriterShim::RegisterWriterShim (VOID)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"RegisterCVssWriterShim");

    try
	{
	/*
	** Do the subscriptions in a multithreaded apartment so
	** that callbacks come in on a separate thread.
	*/
	DWORD tid;
	DWORD dwStatusWait;
	HANDLE hThread = CreateThread (NULL,
				       256 * 1024,
				       CVssWriterShim::RegisterWriterShimThreadFunc,
				       this,
				       0,
				       &tid);


	ft.hr = GET_STATUS_FROM_HANDLE (hThread);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CreateThread");



	/*
	** wait for thread to complete
	*/
	dwStatusWait = WaitForSingleObject (hThread, INFINITE);

	if (WAIT_FAILED == dwStatusWait)
	    {
	    ft.hr = GET_STATUS_FROM_BOOL (FALSE);
	    }


	CloseHandle (hThread);


	LogAndThrowOnFailure (ft,
			      m_pwszWriterName,
			      L"WaitForSingleObject");


	ft.hr = m_hrInitialize;

	} VSS_STANDARD_CATCH (ft)


    return (ft.hr);
    } /* CVssWriterShim::RegisterCVssWriterShim () */


/*
**++
**
**  Routine Description:
**
**	Wrapper routine to get from a thread start point into the
**	class based CVssWriterShim::DoRegistration()
**
**
**  Arguments:
**
**	pv	Address of an argument block
**
**
**  Return Value:
**
**	Any HRESULT returned from the COM Subscription methods.
**	S_OK if no errors.
**
**--
*/

DWORD WINAPI CVssWriterShim::RegisterWriterShimThreadFunc (void *pv)
	{
	CVssWriterShim *pShim = (CVssWriterShim *) pv;

	pShim->DoRegistration ();
	return 0;
	} /* CVssWriterShim::RegisterWriterShimThreadFunc () */

/*
**++
**
**  Routine Description:
**
**	Registers all of the COM Event subscriptions. The actual
**	writer initialisation and subscription happens here.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT returned from the COM Subscription methods.
**	S_OK if no errors.
**
**--
*/

void CVssWriterShim::DoRegistration (void)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CVssWriterShim::DoRegistration");

    BOOL fCoinitializeSucceeded = false;

    try
	{
	ft.Trace (VSSDBG_SHIM, L"Registering Subscriptions");

	if (m_bSubscribed)
	    {
	    /*
	    ** Shouldn't be seen by an end user but might be seen by a developer
	    */
	    ft.hr = HRESULT_FROM_WIN32 (ERROR_ALREADY_INITIALIZED);

	    BS_ASSERT (false && L"FAILED as already initialized/subscribed CVssWriterShim class");

	    LogAndThrowOnFailure (ft, m_pwszWriterName, NULL);
	    }



	/*
	** Set ourselves up in a multi-threaded apartment
	*/
	ft.hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CoInitializeEx");


	fCoinitializeSucceeded = true;


	/*
	** Try enabling SE_BACKUP_NAME privilege
	*/
	ft.hr = TurnOnSecurityPrivilegeBackup();

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"TurnOnSecurityPrivilegeBackup");



	/*
	** Initialize the writer class
	*/
	ft.hr = Initialize (m_idWriter,
			    m_pwszWriterName,
			    m_bBootableState ? VSS_UT_BOOTABLESYSTEMSTATE : VSS_UT_SYSTEMSERVICE,
			    VSS_ST_OTHER,
			    VSS_APP_SYSTEM);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::Initialize");



	/*
	** Get all the mini-writers ready to receive events
	*/
	ft.hr = DeliverEventStartup ();

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::DeliverEventStartup");


	/*
	** Connect the writer to the COM event system
	*/
	ft.hr = Subscribe ();

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::Subscribe");



	/*
	** We are officially subscribed and ready to do work.
	*/
	m_bSubscribed = TRUE;

	} VSS_STANDARD_CATCH(ft);


    if (fCoinitializeSucceeded)
	{
	CoUninitialize();
	}

    m_hrInitialize = ft.hr;
    } /* CVssWriterShim::DoRegistration () */

/*
**++
**
**  Routine Description:
**
**	Disconnect the writer from the COM Event subscriptions.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT returned from the COM UnSubscription methods.
**	S_OK if no errors.
**
**--
*/

HRESULT CVssWriterShim::UnRegisterWriterShim (VOID)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"UnRegisterCVssWriterShim");


    if (m_bSubscribed)
	{
	/*
	** First remove all the subscriptions and when that is safely
	** done call all Finished functions in function table and then
	** close the mutex handle.
	**
	** Note that we have to persevere in the case of errors as we
	** cannot assume that the caller will ever re-attempt the
	** unregister following a failure and we need to make sure
	** that we limit the damage as much as possible (ie we restart
	** paused services etc). The best we can do is trace/log the
	** problem.
	*/
	ft.hr = Unsubscribe ();

	LogFailure (&ft,
		    ft.hr,
		    ft.hr,
		    m_pwszWriterName,
		    L"CVssWriterShim::Unsubscribe",
		    L"CVssWriterShim::UnRegisterWriterShim");

	m_bSubscribed = FALSE;
	}


    return (ft.hr);
    } /* UnRegisterCVssWriterShim () */


/*
**++
**
**  Routine Description:
**
**	Event handling routines to take the OnXxxx() method calls
**	invoked by the COM event delivery mechanism and request the
**	internal worker thread to spread the word to the individual
**	mini-writers being managed by this class.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT returned from the COM UnSubscription methods.
**	S_OK if no errors.
**
**--
*/


bool STDMETHODCALLTYPE CVssWriterShim::OnIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata)
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CVssWriterShim::OnIdentify");
    ThreadArgs	wtArgs;


    try
	{
	wtArgs.wtArgsIdentify.pIVssCreateWriterMetadata = pIVssCreateWriterMetadata;

	ft.Trace (VSSDBG_SHIM, L"Received Event: OnIdentify for %s", m_pwszWriterName);


	ft.hr = WorkerThreadRequestOperation (eOpDeliverEventIdentify, &wtArgs);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::WorkerThreadRequestOperation");

	} VSS_STANDARD_CATCH( ft );


    if (ft.HrFailed ())
	{
	SetWriterFailure (ft.hr);
	}

    return (ft.HrSucceeded ());
    } /* CVssWriterShim::OnIdentify () */



bool STDMETHODCALLTYPE CVssWriterShim::OnPrepareSnapshot ()
    {
    CVssFunctionTracer   ft (VSSDBG_SHIM, L"CVssWriterShim::OnPrepareSnapshot");
    ThreadArgs		 wtArgs;


    try
	{
	wtArgs.wtArgsPrepareForSnapshot.bBootableStateBackup  = IsBootableSystemStateBackedUp ();
	wtArgs.wtArgsPrepareForSnapshot.guidSnapshotSetId     = GetCurrentSnapshotSetId ();
	wtArgs.wtArgsPrepareForSnapshot.ulVolumeCount         = GetCurrentVolumeCount ();
	wtArgs.wtArgsPrepareForSnapshot.ppwszVolumeNamesArray = GetCurrentVolumeArray ();
	wtArgs.wtArgsPrepareForSnapshot.pbCancelAsync         = NULL;

	ft.Trace (VSSDBG_SHIM, L"Received Event: OnPrepareSnapshot for %s", m_pwszWriterName);
	ft.Trace (VSSDBG_SHIM, L"Parameters:");
	ft.Trace (VSSDBG_SHIM, L"    BootableState = %s", wtArgs.wtArgsPrepareForSnapshot.bBootableStateBackup ? L"yes" : L"no");
	ft.Trace (VSSDBG_SHIM, L"    SnapshotSetID = " WSTR_GUID_FMT, GUID_PRINTF_ARG (wtArgs.wtArgsPrepareForSnapshot.guidSnapshotSetId));
	ft.Trace (VSSDBG_SHIM, L"    VolumeCount   = %d", wtArgs.wtArgsPrepareForSnapshot.ulVolumeCount);


	for (UINT iVolumeCount = 0;
	     iVolumeCount < wtArgs.wtArgsPrepareForSnapshot.ulVolumeCount;
	     iVolumeCount++)
	    {
	    ft.Trace (VSSDBG_SHIM,
		      L"        VolumeNamesList [%d] = %s",
		      iVolumeCount,
		      wtArgs.wtArgsPrepareForSnapshot.ppwszVolumeNamesArray [iVolumeCount]);
	    }



	ft.hr = WorkerThreadRequestOperation (eOpDeliverEventPrepareForSnapshot, &wtArgs);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::WorkerThreadRequestOperation");

	} VSS_STANDARD_CATCH( ft );


    if (ft.HrFailed ())
	{
	SetWriterFailure (ft.hr);
	}

    return (ft.HrSucceeded ());
    } /* CVssWriterShim::OnPrepare () */



bool STDMETHODCALLTYPE CVssWriterShim::OnFreeze ()
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CVssWriterShim::OnFreeze");
    ThreadArgs		wtArgs;


    try
	{
	wtArgs.wtArgsFreeze.guidSnapshotSetId = GetCurrentSnapshotSetId ();
	wtArgs.wtArgsFreeze.pbCancelAsync     = NULL;

	ft.Trace (VSSDBG_SHIM, L"Received Event: OnFreeze for %s", m_pwszWriterName);
	ft.Trace (VSSDBG_SHIM, L"Parameters:");
	ft.Trace (VSSDBG_SHIM, L"\tSnapshotSetID = " WSTR_GUID_FMT, GUID_PRINTF_ARG (wtArgs.wtArgsFreeze.guidSnapshotSetId));


	ft.hr = WorkerThreadRequestOperation (eOpDeliverEventFreeze, &wtArgs);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::WorkerThreadRequestOperation");

	} VSS_STANDARD_CATCH( ft );


    if (ft.HrFailed ())
	{
	SetWriterFailure (ClassifyWriterFailure (ft.hr));
	}

    return (ft.HrSucceeded ());
    } /* CVssWriterShim::OnFreeze () */



bool STDMETHODCALLTYPE CVssWriterShim::OnThaw ()
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CVssWriterShim::OnThaw");
    ThreadArgs		wtArgs;


    try
	{
	wtArgs.wtArgsThaw.guidSnapshotSetId = GetCurrentSnapshotSetId ();

	ft.Trace (VSSDBG_SHIM, L"Received Event: OnThaw for %s", m_pwszWriterName);
	ft.Trace (VSSDBG_SHIM, L"Parameters:");
	ft.Trace (VSSDBG_SHIM, L"\tSnapshotSetID = " WSTR_GUID_FMT, GUID_PRINTF_ARG (wtArgs.wtArgsThaw.guidSnapshotSetId));


	ft.hr = WorkerThreadRequestOperation (eOpDeliverEventThaw, &wtArgs);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::WorkerThreadRequestOperation");

	} VSS_STANDARD_CATCH( ft );


    if (ft.HrFailed ())
	{
	SetWriterFailure (ClassifyWriterFailure (ft.hr));
	}

    return (ft.HrSucceeded ());
    } /* CVssWriterShim::OnThaw () */



bool STDMETHODCALLTYPE CVssWriterShim::OnAbort ()
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CVssWriterShim::OnAbort");
    ThreadArgs		wtArgs;
    const GUID		guidSnapshotSetId = GetCurrentSnapshotSetId ();


    try
	{
	wtArgs.wtArgsAbort.guidSnapshotSetId = GetCurrentSnapshotSetId ();

	ft.Trace (VSSDBG_SHIM, L"Received Event: OnAbort for %s", m_pwszWriterName);
	ft.Trace (VSSDBG_SHIM, L"Parameters:");
	ft.Trace (VSSDBG_SHIM, L"\tSnapshotSetID = " WSTR_GUID_FMT, GUID_PRINTF_ARG (wtArgs.wtArgsAbort.guidSnapshotSetId));


	ft.hr = WorkerThreadRequestOperation (eOpDeliverEventAbort, &wtArgs);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::WorkerThreadRequestOperation");

	} VSS_STANDARD_CATCH( ft );


    if (ft.HrFailed ())
	{
	SetWriterFailure (ClassifyWriterFailure (ft.hr));
	}

    return (ft.HrSucceeded ());
    } /* CVssWriterShim::OnAbort () */


/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver an 'Identify' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the current snapshot
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Identify() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata)
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventIdentify");
    HRESULT		hrLastFailure = NOERROR;
    BOOL		bCallWriter;


    /*
    ** First setup the Restore Method.  Specify a custom restore method.
    */
    ft.hr = pIVssCreateWriterMetadata->SetRestoreMethod (VSS_RME_CUSTOM,
                                                         NULL,
                                                         NULL,
                                                         VSS_WRE_NEVER,
                                                         true);
    LogAndThrowOnFailure (ft, m_pwszWriterName, L"CVssWriterShim::DeliverEventIdentify");
	
    /*
    ** Send Identify to selected group of writer in function
    ** table. Keep going for all the writers in the group even if one
    ** of them fails. Everyone should get to hear about the Identify.
    */
    for (ULONG ulIndex = 0; ulIndex < m_ulWriterCount; ++ulIndex)
	{
	ft.hr = (m_prpCShimWriterArray [ulIndex]->Identify)(pIVssCreateWriterMetadata);

	LogFailure (&ft,
		    ft.hr,
		    ft.hr,
		    m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
		    L"CShimWriter::Identify",
		    L"CVssWriterShim::DeliverEventIdentify");

	if (ft.HrFailed ())
	    {
	    hrLastFailure = ft.hr;
	    }
	}


    ft.hr = hrLastFailure;

    return (ft.hr);
    } /* CVssWriterShim::DeliverEventIdentify () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver a 'PrepareForSnapshot' event
**	by processing each of the class instances in the rgpShimWriters[] array and calling
**	the appropriate entry point.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the current snapshot
**	ulOptionFlags		Options required for this freeze selected from the following list:-
**				    VSS_SW_BOOTABLE_STATE
**
**	ulVolumeCount		Number of volumes in the volume array
**	ppwszVolumeNamesArray   Array of pointer to volume name strings
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer PrepareForSnapshot() functions.
**
**
**--
*/

HRESULT CVssWriterShim::DeliverEventPrepareForSnapshot (BOOL     bBootableStateBackup,
							GUID     guidSnapshotSetId,
							ULONG    ulVolumeCount,
							LPCWSTR *ppwszVolumeNamesArray,
                                                        volatile bool *pbCancelAsync )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventPrepareForSnapshot");
    HRESULT		hrLastFailure = NOERROR;
    LPCWSTR		pwszTraceStringWriterType;
    UNICODE_STRING	ucsWriterRootDirectory;


    try
	{
	ft.Trace (VSSDBG_SHIM, L"Parameters:");
	ft.Trace (VSSDBG_SHIM, L"    BootableState = %s",   bBootableStateBackup ? L"yes" : L"no");
	ft.Trace (VSSDBG_SHIM, L"    SnapshotSetID = "      WSTR_GUID_FMT, GUID_PRINTF_ARG (guidSnapshotSetId));
	ft.Trace (VSSDBG_SHIM, L"    VolumeCount   = %d",   ulVolumeCount);

	for (UINT iVolumeCount = 0; iVolumeCount < ulVolumeCount; iVolumeCount++)
	    {
	    ft.Trace (VSSDBG_SHIM,
		      L"        VolumeNamesList [%d] = %s",
		      iVolumeCount,
		      ppwszVolumeNamesArray [iVolumeCount]);
	    }

	/*
	** Send PrepareForSnapshot to selected group of writers in
	** function table. We are going to do all of the writers in
	** the group even if one of them fails partway
	** through. However we will skip sending the freeze event if a
	** writer fails the prepare.
	*/
	for (ULONG ulIndex = 0; ulIndex < m_ulWriterCount; ++ulIndex)
	    {
	    ft.hr = (m_prpCShimWriterArray [ulIndex]->PrepareForSnapshot) (bBootableStateBackup,
									   ulVolumeCount,
									   ppwszVolumeNamesArray);

	    LogFailure (&ft,
			ft.hr,
			ft.hr,
			m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
			L"CShimWriter::PrepareForSnapshot",
			L"CVssWriterShim::DeliverEventPrepareForSnapshot");

	    if (ft.HrFailed ())
		{
		hrLastFailure = ft.hr;
		}

            ft.ThrowIf ( pbCancelAsync != NULL && *pbCancelAsync,
                         VSSDBG_SHIM,
                         VSS_S_ASYNC_CANCELLED,
                         L"User cancelled async operation" );	
	    }


	ft.hr = hrLastFailure;

	} VSS_STANDARD_CATCH (ft)


    return (ft.hr);
    } /* CVssWriterShim::DeliverEventPrepareForSnapshot () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver a 'Freeze' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the current snapshot
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Freeze() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventFreeze (GUID guidSnapshotSetId,
                                            volatile bool *pbCancelAsync )
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventFreeze");
    HRESULT		hrLastFailure = NOERROR;


    try
	{
	/*
	** Send Freeze to a selected group of writers in function
	** table. Note that all writers in the group get called and
	** for freezing at level2
	*/
	for (ULONG ulIndex = 0; ulIndex < m_ulWriterCount; ++ulIndex)
	    {
	    ft.hr = (m_prpCShimWriterArray [ulIndex]->Freeze)();

	    LogFailure (&ft,
			ft.hr,
			ft.hr,
			m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
			L"CShimWriter::Freeze",
			L"CVssWriterShim::DeliverEventFreeze");

	    if (ft.HrFailed ())
		{
		hrLastFailure = ft.hr;
		}
	
            ft.ThrowIf ( pbCancelAsync != NULL && *pbCancelAsync,
                         VSSDBG_SHIM,
                         VSS_S_ASYNC_CANCELLED,
                         L"User cancelled async operation - 2" );	
	    }

	ft.hr = hrLastFailure;

	} VSS_STANDARD_CATCH (ft)


    return (ft.hr);
    } /* CVssWriterShim::DeliverEventFreeze () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver a 'Thaw' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the current snapshot
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Thaw() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventThaw (GUID guidSnapshotSetId)
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventThaw");

    UNICODE_STRING	ucsWriterRootDirectory;
    HRESULT		hrStatus;
    HRESULT		hrLastFailure = NOERROR;
    ULONG		ulIndex       = m_ulWriterCount;


    try
	{
	/*
	** Send Thaw to selected group of writers in the function
	** table. Keep going for all the writers in the group even if
	** one of them fails. Everyone MUST get to hear about the
	** Thaw.
	*/
	while (ulIndex--)
	    {
	    ft.hr = (m_prpCShimWriterArray [ulIndex]->Thaw)();

	    LogFailure (&ft,
			ft.hr,
			ft.hr,
			m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
			L"CShimWriter::Thaw",
			L"CVssWriterShim::DeliverEventThaw");

	    if (ft.HrFailed ())
		{
		hrLastFailure = ft.hr;
		}
	    }

	} VSS_STANDARD_CATCH (ft)



    return (ft.hr);
    } /* CVssWriterShim::DeliverEventThaw () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver an 'Abort' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	guidSnapshotSetId	Identifier used to identify the current snapshot
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Abort() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventAbort (GUID guidSnapshotSetId)
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventAbort");


    UNICODE_STRING	ucsWriterRootDirectory;
    HRESULT		hrStatus;
    HRESULT		hrLastFailure = NOERROR;
    ULONG		ulIndex       = m_ulWriterCount;


    try
	{
	/*
	** Send Abort to selected group of writers in the function
	** table. Keep going for all the writers in the group even if
	** one of them fails. Everyone MUST get to hear about the
	** Abort.
	*/
	while (ulIndex--)
	    {
	    ft.hr = (m_prpCShimWriterArray [ulIndex]->Abort)();

	    LogFailure (&ft,
			ft.hr,
			ft.hr,
			m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
			L"CShimWriter::Abort",
			L"CVssWriterShim::DeliverEventAbort");

	    if (ft.HrFailed ())
		{
		hrLastFailure = ft.hr;
		}
	    }

	} VSS_STANDARD_CATCH (ft)



    return (ft.hr);
    } /* CVssWriterShim::DeliverEventAbort () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver a 'Startup' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point. This gives the shim writer the
**	chance to set up some initial state. This is called once in response to
**	a registration of the shim writer. It is NOT called for each individual
**	Prepare/Freeze/Thaw sequence.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Startup() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventStartup ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventStartup");
    HRESULT		hrLastFailure = NOERROR;


    /*
    ** Send Startup to selected group of writers in the function
    ** table. Keep going for all the writers in the group even if one
    ** of them fails. Everyone MUST get to hear about the Startup.
    */
    for (ULONG ulIndex = 0; ulIndex < m_ulWriterCount; ++ulIndex)
	{
	ft.hr = (m_prpCShimWriterArray [ulIndex]->Startup)();

	LogFailure (&ft,
		    ft.hr,
		    ft.hr,
		    m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
		    L"CShimWriter::Startup",
		    L"CVssWriterShim::DeliverEventStartup");

	if (ft.HrFailed ())
	    {
	    hrLastFailure = ft.hr;
	    }
	}


    ft.hr = hrLastFailure;

    return (ft.hr);
    } /* CVssWriterShim::DeliverEventStartup () */

/*
**++
**
**  Routine Description:
**
**	Routine to call each of the shim writers and deliver a 'Shutdown' event
**	by processing each of the class instances in the rgpShimWriters[] array
**	and calling the appropriate entry point. This gives the shim writer the
**	chance to cleanup any oustanding state. It is expected that Shutdown might
**	be called at any time as a reponse to an unload of the DLL housing this
**	code. A call to the shutdown routines may be follwed by either a call to
**	the destructor for the class instance or the startup function. This
**	routine is NOT called for each individual Prepare/Freeze/Thaw sequence.
**
**	Note that each of the shim writers is called even in the presence of failures. This
**	is one of the garuntees made to the shim writers and the state machine depends upon
**	this.
**
**      This method is NOT called by the worker thread, it is only called in the CVssWriterShim
**      destructor.
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from any of the shim writer Shutdown() functions.
**
**--
*/

HRESULT CVssWriterShim::DeliverEventShutdown ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::DeliverEventShutdown");
    HRESULT		hrLastFailure = NOERROR;


    /*
    ** Send Shutdown to selected group of writers in the function
    ** table. Keep going for all the writers in the group even if one
    ** of them fails. Everyone MUST get to hear about the Shutdown.
    */
    for (ULONG ulIndex = 0; ulIndex < m_ulWriterCount; ++ulIndex)
	{
	ft.hr = (m_prpCShimWriterArray [ulIndex]->Shutdown)();

	LogFailure (&ft,
		    ft.hr,
		    ft.hr,
		    m_prpCShimWriterArray [ulIndex]->m_pwszWriterName,
		    L"CShimWriter::Shutdown",
		    L"CVssWriterShim::DeliverEventShutdown");

	if (ft.HrFailed ())
	    {
	    hrLastFailure = ft.hr;
	    }
	}


    ft.hr = hrLastFailure;

    return (ft.hr);
    } /* CVssWriterShim::DeliverEventShutdown () */


/*
**++
**
**  Routine Description:
**
**	Routines to operate a worker thread which is used to provide a
**	stable context under which to call the mini-writers.
**
**	The prime need for this statble context is the mutex (which
**	must belong to a thread) which is used to protect the
**	PrepareForSnapshot, Freeze, Thaw/Abort event sequence as
**	executed by the writer from that executed by direct calls to
**	the SimulateSnapshotXxxx() routines.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT from
**		CreateEventW()
**		CreateThread()
**		ConstructSecurityAttributes()
**
**--
*/

HRESULT CVssWriterShim::WorkerThreadStartup (void)
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CVssWriterShim::WorkerThreadStartup");

    HRESULT		hrStatusClassified = NOERROR;

    SECURITY_DESCRIPTOR	sdSecurityDescriptor;


    try
	{
	if (!HandleInvalid (m_hWorkerThread)          ||
	    !HandleInvalid (m_hEventOperationRequest) ||
	    !HandleInvalid (m_hEventOperationCompleted))
	    {
	    ft.LogError (VSS_ERROR_SHIM_WORKER_THREAD_ALREADY_RUNNING,
			 VSSDBG_SHIM << m_pwszWriterName);

	    ft.Throw (VSSDBG_SHIM,
		      E_UNEXPECTED,
		      L"FAILED with invalid handle for worker thread, mutex or events");
	    }


	m_hEventOperationRequest = CreateEventW (NULL, FALSE, FALSE, NULL);

	ft.hr = GET_STATUS_FROM_HANDLE (m_hEventOperationRequest);

	if (ft.HrFailed ())
	    {
	    hrStatusClassified = ClassifyShimFailure (ft.hr);

	    ft.LogError (VSS_ERROR_SHIM_FAILED_TO_CREATE_WORKER_REQUEST_EVENT,
			 VSSDBG_SHIM << ft.hr << hrStatusClassified << m_pwszWriterName);

	    ft.Throw (VSSDBG_SHIM,
		      hrStatusClassified,
		      L"FAILED to create OperationRequest event for the %s writer due to status %0x08lX (converted to %0x08lX)",
		      m_pwszWriterName,
		      ft.hr,
		      hrStatusClassified);
	    }


	m_hEventOperationCompleted = CreateEventW (NULL, FALSE, FALSE, NULL);

	ft.hr = GET_STATUS_FROM_HANDLE (m_hEventOperationCompleted);

	if (ft.HrFailed ())
	    {
	    hrStatusClassified = ClassifyShimFailure (ft.hr);

	    ft.LogError (VSS_ERROR_SHIM_FAILED_TO_CREATE_WORKER_COMPLETION_EVENT,
			 VSSDBG_SHIM << ft.hr << hrStatusClassified << m_pwszWriterName);

	    ft.Throw (VSSDBG_SHIM,
		      hrStatusClassified,
		      L"FAILED to create OperationCompleted event for the %s writer due to status %0x08lX (converted to %0x08lX)",
		      m_pwszWriterName,
		      ft.hr,
		      hrStatusClassified );
	    }


	m_hWorkerThread = CreateThread (NULL,
					0,
					CVssWriterShim::WorkerThreadJacket,
					this,
					0,
					NULL);

	ft.hr = GET_STATUS_FROM_HANDLE (m_hWorkerThread);

	if (ft.HrFailed ())
	    {
	    hrStatusClassified = ClassifyShimFailure (ft.hr);

	    ft.LogError (VSS_ERROR_SHIM_FAILED_TO_CREATE_WORKER_THREAD,
			 VSSDBG_SHIM << ft.hr << hrStatusClassified << m_pwszWriterName);

	    ft.Throw (VSSDBG_SHIM,
		      hrStatusClassified,
		      L"FAILED creating worker thread for the %s writer due to status %0x08lX (converted to %0x08lX)",
		      m_pwszWriterName,
		      ft.hr,
		      hrStatusClassified );
	    }



	ft.Trace (VSSDBG_SHIM, L"Created worker thread for writer %s", m_pwszWriterName);

	} VSS_STANDARD_CATCH (ft);



    if (ft.HrFailed ())
	{
	CommonCloseHandle (&m_hEventOperationCompleted);
	CommonCloseHandle (&m_hEventOperationRequest);

	m_eThreadStatus = eStatusNotRunning;
	m_hWorkerThread = INVALID_HANDLE_VALUE;
	}

    return (ft.hr);
    } /* CVssWriterShim::WorkerThreadStartup () */

/*
**++
**
**  Routine Description:
**
**	Wrapper routine to get from a thread start point into the
**	class based CVssWriterShim::WorkerThread()
**
**
**  Arguments:
**
**	pvThisPtr	Address of an class 'this' pointer
**
**
**  Return Value:
**
**	None
**
**--
*/

DWORD WINAPI CVssWriterShim::WorkerThreadJacket (void *pvThisPtr)
    {
    PCVssWriterShim pCVssWriterShim = (PCVssWriterShim) pvThisPtr;

    pCVssWriterShim->WorkerThread ();

    return (0);
    } /* CVssWriterShim::WorkerThreadJacket () */

/*
**++
**
**  Routine Description:
**
**	Worker thread to deliver requested events to mini-writers.
**
**
**  Arguments:
**
**	None
**
**
**  Return Value:
**
**	Any HRESULT generated by the mini-writers.
**
**--
*/

HRESULT CVssWriterShim::WorkerThread (void)
    {
    HRESULT	hrStatus  = NOERROR;
    BOOL	bContinue = TRUE;
    BOOL	bSucceeded;
    DWORD	dwStatusWait;


    while (bContinue)
	{
	m_eThreadStatus = eStatusWaitingForOpRequest;

	dwStatusWait = WaitForSingleObject (m_hEventOperationRequest, INFINITE);


	m_eThreadStatus = eStatusProcessingOpRequest;

	switch (dwStatusWait)
	    {
	    case WAIT_OBJECT_0:
		hrStatus = NOERROR;
		break;


	    case WAIT_FAILED:
		hrStatus = GET_STATUS_FROM_BOOL (FALSE);
		break;


	    default:
		hrStatus = HRESULT_FROM_WIN32 (ERROR_INVALID_STATE);
		break;
	    }



	if (FAILED (hrStatus))
	    {
	    /*
	    ** If we have had any failures operating the thread then
	    ** it's time to leave.
	    */
	    LogFailure (NULL,
			hrStatus,
			m_hrStatusRequestedOperation,
			m_pwszWriterName,
			L"WaitForSingleObject",
			L"CVssWriterShim::WorkerThread");

	    m_hrStatusRequestedOperation = hrStatus;

	    bContinue = FALSE;
	    }
	else
	    {
	    /*
	    ** We've been asked to do something. find out what and go do it.
	    */
	    switch (m_eRequestedOperation)
		{
		case eOpDeliverEventStartup:
		    m_hrStatusRequestedOperation = DeliverEventStartup ();
		    break;

		case eOpDeliverEventIdentify:
		    m_hrStatusRequestedOperation = DeliverEventIdentify (m_wtArgs.wtArgsIdentify.pIVssCreateWriterMetadata);
		    break;
			
		case eOpDeliverEventPrepareForBackup:
		    m_hrStatusRequestedOperation = NOERROR;
		    break;

		case eOpDeliverEventPrepareForSnapshot:
		    m_hrStatusRequestedOperation = DeliverEventPrepareForSnapshot (m_wtArgs.wtArgsPrepareForSnapshot.bBootableStateBackup,
										   m_wtArgs.wtArgsPrepareForSnapshot.guidSnapshotSetId,
										   m_wtArgs.wtArgsPrepareForSnapshot.ulVolumeCount,
										   m_wtArgs.wtArgsPrepareForSnapshot.ppwszVolumeNamesArray,
										   m_wtArgs.wtArgsPrepareForSnapshot.pbCancelAsync);
		    break;
		
		case eOpDeliverEventFreeze:
		    m_hrStatusRequestedOperation = DeliverEventFreeze (m_wtArgs.wtArgsFreeze.guidSnapshotSetId,
							                 m_wtArgs.wtArgsFreeze.pbCancelAsync);
		    break;

		case eOpDeliverEventThaw:
		    m_hrStatusRequestedOperation = DeliverEventThaw (m_wtArgs.wtArgsThaw.guidSnapshotSetId);
		    break;

		case eOpDeliverEventAbort:
		    m_hrStatusRequestedOperation = DeliverEventAbort (m_wtArgs.wtArgsAbort.guidSnapshotSetId);
		    break;

		case eOpWorkerThreadShutdown:
		    m_hrStatusRequestedOperation = NOERROR;
		    hrStatus                     = NOERROR;

		    bContinue = FALSE;
		    break;

		default:
		    LogFailure (NULL,
				HRESULT_FROM_WIN32 (ERROR_INVALID_OPERATION),
				m_hrStatusRequestedOperation,
				m_pwszWriterName,
				L"CVssWriterShim::DeliverEventUnknown",
				L"CVssWriterShim::WorkerThread");

		    break;
		}
	    }



	if (!bContinue)
	    {
	    m_eThreadStatus                  = eStatusNotRunning;
	    m_hWorkerThread                  = INVALID_HANDLE_VALUE;
	    m_hrWorkerThreadCompletionStatus = hrStatus;
	    }



	/*
	** The SetEvent() must be the last call on a shutdown to touch
	** the class as by the very next instruction it may no longer
	** be there.
	*/
	bSucceeded = SetEvent (m_hEventOperationCompleted);

	LogFailure (NULL,
		    GET_STATUS_FROM_BOOL (bSucceeded),
		    hrStatus,
		    L"(UNKNOWN)",
		    L"SetEvent",
		    L"CVssWriterShim::WorkerThread");


	bContinue &= bSucceeded;
	}


    return (hrStatus);
    } /* CVssWriterShim::WorkerThread () */

/*
**++
**
**  Routine Description:
**
**	Routine to request an operation of the worker thread for this
**	class. Uses a critical section to ensure only on operation can
**	be outstanding at any one time.
**
**
**  Arguments:
**
**	eOperation	Code to selct the required operation
**	pThreadArgs	Pointer to a block of args specific to the operation
**
**
**  Return Value:
**
**	Any HRESULT generated by the operation.
**
**--
*/

HRESULT CVssWriterShim::WorkerThreadRequestOperation (RequestOpCode eOperation, PThreadArgs pThreadArgs)
    {
    CVssFunctionTracer  ft (VSSDBG_SHIM, L"CVssWriterShim::RequestOperation");

    DWORD	dwStatusWait;
    BOOL	bSucceeded;


    try
	{
        CBsAutoLock cAutoLock (m_cCriticalSection);


	if (HandleInvalid (m_hWorkerThread))
	    {
	    ft.LogError (VSS_ERROR_SHIM_WRITER_NO_WORKER_THREAD,
			 VSSDBG_SHIM << m_pwszWriterName << eOperation);

	    ft.Throw (VSSDBG_SHIM,
		      E_UNEXPECTED,
		      L"FAILED requesting operation 0x%02X in %s due to missing worker thread",
		      eOperation,
		      m_pwszWriterName);
	    }


	if (NULL != pThreadArgs)
	    {
	    m_wtArgs = *pThreadArgs;
	    }

	m_eRequestedOperation = eOperation;

	bSucceeded = SetEvent (m_hEventOperationRequest);

	ft.hr = GET_STATUS_FROM_BOOL (bSucceeded);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"SetEvent");




	dwStatusWait = WaitForSingleObject (m_hEventOperationCompleted, INFINITE);

	switch (dwStatusWait)
	    {
	    case WAIT_OBJECT_0:

		ft.hr = m_hrStatusRequestedOperation;

		ft.ThrowIf (ft.HrFailed (),
			    VSSDBG_SHIM,
			    ft.hr,
			    L"FAILED whilst processing requested operation 0x%02X", eOperation);

		break;


	    case WAIT_FAILED:
		ft.hr = GET_STATUS_FROM_BOOL (FALSE);
		break;


	    default:
		ft.hr = HRESULT_FROM_WIN32 (ERROR_INVALID_STATE);
		break;
	    }


	if (ft.HrFailed ())
	    {
	    HRESULT hrStatusClassified = ClassifyWriterFailure (ft.hr);

	    ft.LogError (VSS_ERROR_SHIM_WRITER_FAILED_OPERATION,
			 VSSDBG_SHIM << ft.hr << hrStatusClassified<< m_pwszWriterName << eOperation );

	    ft.Throw (VSSDBG_SHIM,
		      hrStatusClassified,
		      L"FAILED with 0x%08lX (converted to 0x%08lX) waiting for completion of requested operation 0x%02X in writer %s",
		      ft.hr,
		      hrStatusClassified,
		      eOperation,
		      m_pwszWriterName);
	    }
	} VSS_STANDARD_CATCH (ft);


    return (ft.hr);
    } /* CVssWriterShim::RequestOperation () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrtls.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrtls.cpp

Abstract:

    Writer shim module for Terminal Server Licensing

Author:

    Stefan R. Steiner   [ssteiner]        02-13-2000

Revision History:

	X-9	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-8	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path
		141365: Workaround problem in loading tls236.dll by 
		        pre-loading user32

	X-7	MCJ		Michael C. Johnson		21-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.

	X-6	MCJ		Michael C. Johnson		15-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-5	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()

	X-4	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-3	MCJ		Michael C. Johnson		23-Mar-2000
		Get writer to use same context mechanism as most of the other
		writers.

	X-2	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

--*/

#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHTLSC"
//
////////////////////////////////////////////////////////////////////////


#define APPLICATION_STRING	L"TerminalServicesLicensingServer"
#define COMPONENT_NAME		L"Terminal Services Licensing Server"

#define TARGET_PATH		ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING


#define	EXPORTPATH_SUBKEY	L"System\\CurrentControlSet\\services\\TermServLicensing\\Parameters"
#define	EXPORTPATH_VALUENAME	L"DBPath"
#define EXPORTPATH_DIRECTORY	L"\\Export\\"


/*
**  Terminal service licensing DLL function prototype
*/
typedef DWORD (WINAPI *PFUNC_ExportTlsDatabaseC)(VOID);



/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterTLS : public CShimWriter
    {
public:
    CShimWriterTLS (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) : 
		CShimWriter (pwszWriterName, pwszTargetPath) {};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    };


static CShimWriterTLS ShimWriterTLS (APPLICATION_STRING, TARGET_PATH);

PCShimWriter pShimWriterTLS = &ShimWriterTLS;




/*
**++
**
** Routine Description:
**
**	The Terminal Services Licensing Server database snapshot
**	writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**-- */

HRESULT CShimWriterTLS::DoIdentify ()
    {
    HRESULT	hrStatus;


    hrStatus = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							  NULL,
							  COMPONENT_NAME,
							  COMPONENT_NAME,
							  NULL, // icon
							  0,
							  true,
							  false,
							  false);

    LogFailure (NULL, 
		hrStatus, 
		hrStatus, 
		m_pwszWriterName, 
		L"IVssCreateWriterMetadata::AddComponent", 
		L"CShimWriterTLS::DoIdentify");


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								     COMPONENT_NAME,
								     m_pwszTargetPath,
								     L"*",
								     true,
								     NULL);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"IVssCreateWriterMetadata::AddFilesToFileGroup", 
		    L"CShimWriterTLS::DoIdentify");
	}


    return (hrStatus);
    } /* CShimWriterTLS::DoIdentify () */


/*
**++
**
**  Routine Description:
**
**	The TLS writer PrepareForFreeze function.  Currently all of the
**	real work for this writer happens here.
**
**  Arguments:
**
**	Same arguments as those passed in the PrepareForFreeze event.
**
**  Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterTLS::DoPrepareForSnapshot ()
    {
    HRESULT			hrStatus;
    DWORD			dwStatus;
    DWORD			dwValueDataLength;
    DWORD			dwValueType;
    BOOL			bSucceeded;
    BOOL			bExportPathKeyOpened = FALSE;
    UNICODE_STRING		ucsTargetPath;
    UNICODE_STRING		ucsSourcePath;
    UNICODE_STRING		ucsValueData;
    PFUNC_ExportTlsDatabaseC	ExportTlsDatabaseC   = NULL;
    HMODULE			hLibraryTermServ     = NULL;
    HMODULE			hLibraryUser32       = NULL;
    HKEY			hkeyExportPath       = NULL;



    StringInitialise (&ucsTargetPath);
    StringInitialise (&ucsSourcePath);
    StringInitialise (&ucsValueData);


    hrStatus = StringAllocate (&ucsValueData,
			       REGISTRY_BUFFER_SIZE * sizeof (WCHAR));


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsTargetPath,
						   m_pwszTargetPath,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	StringAppendString (&ucsTargetPath, DIR_SEP_STRING);


	dwStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				  EXPORTPATH_SUBKEY,
				  0,
				  KEY_QUERY_VALUE,
				  &hkeyExportPath);

	hrStatus = HRESULT_FROM_WIN32 (dwStatus);

	bExportPathKeyOpened = SUCCEEDED (hrStatus);


	if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"Appears Terminal Service Licensing service is not installed, "
				 L"no exportpath subkey entry"));

	    hrStatus               = NOERROR;
	    m_bParticipateInBackup = FALSE;
	    }

	
	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}


    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	/*
	** Everything is setup, so first check to see if there is a
	** registry key present which will tell us where the
	** ExportTlsDatabaseC() call is going to dump it's file. Also,
	** if it's got environment variables in it make sure they get
	** expanded.
	*/
	dwValueDataLength = ucsValueData.MaximumLength;
	dwValueType       = REG_NONE;

	dwStatus = RegQueryValueExW (hkeyExportPath,
				     EXPORTPATH_VALUENAME,
				     NULL,
				     &dwValueType,
				     (PBYTE) ucsValueData.Buffer,
				     &dwValueDataLength);

	hrStatus = HRESULT_FROM_WIN32 (dwStatus);


	if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus)
	    {
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"Appears Terminal Service Licensing service is not installed, "
				 L"no DBPath entry"));

	    hrStatus               = NOERROR;
	    m_bParticipateInBackup = FALSE;
	    }

	
	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegQueryValueExW", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus) && (REG_EXPAND_SZ == dwValueType))
	{
	ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

	ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;


	hrStatus = StringCreateFromExpandedString (&ucsSourcePath,
						   ucsValueData.Buffer,
						   MAX_PATH);


	if (SUCCEEDED (hrStatus))
	    {
	    /*
	    **  That gets us the root, now append the actual directory
	    */
	    StringAppendString (&ucsSourcePath, EXPORTPATH_DIRECTORY);
	    }
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	/*
	** As a workaround to a problem with unloading - reloading
	** user32 pre-load things so we can guarantee at least one
	** reference on it and stop it going away over the critical
	** point.
	*/
	hLibraryUser32 = LoadLibraryW (L"user32.dll");

	hrStatus = GET_STATUS_FROM_HANDLE (hLibraryUser32);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"LoadLibraryW (user32.dll)", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
        /*
	**  Now tell TLS to export the database
        **
	**
        **  First load the TLS backup DLL
	*/
        hLibraryTermServ = LoadLibraryW (L"tls236.dll");

	hrStatus = GET_STATUS_FROM_HANDLE (hLibraryTermServ);


	if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus)
	    {
	    /*
	    **  Terminal Server Licensing service probably not installed
	    */
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"Appears Terminal Service Licensing service is not installed, "
				 L"no tls236.dll found"));

	    hrStatus               = NOERROR;
	    m_bParticipateInBackup = FALSE;
	    }


	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"LoadLibraryW (tls236.dll)", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
        /*
	** Now setup the function pointer to the export function
	*/
	ExportTlsDatabaseC = (PFUNC_ExportTlsDatabaseC) GetProcAddress (hLibraryTermServ, 
									"ExportTlsDatabaseC");

	hrStatus = GET_STATUS_FROM_BOOL (NULL != ExportTlsDatabaseC);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetProcAddress (ExportTlsDatabaseC)", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}


    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	try
	    {
	    /*
	    ** Perform the export
	    */
	    dwStatus = ExportTlsDatabaseC();

	    hrStatus = HRESULT_FROM_WIN32 (dwStatus);
	    }

	catch (DWORD dwStatus)
	    {
	    hrStatus = HRESULT_FROM_WIN32 (dwStatus);
	    }

	catch (...)
	    {
	    hrStatus = E_UNEXPECTED;
	    }



	if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hrStatus)
	    {
	    /*
	    **  Terminal Server Licensing service probably not running
	    */
	    BsDebugTraceAlways (0,
				DEBUG_TRACE_VSS_SHIM,
				(L"Appears Terminal Service Licensing service is not running, "
				 L"perhaps not a DomainController?"));

	    hrStatus               = NOERROR;
	    m_bParticipateInBackup = FALSE;
	    }

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"ExportTlsDatabaseC", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}



    if (m_bParticipateInBackup && SUCCEEDED (hrStatus))
	{
	/*
	**  Now move the files in the export directory to the TLS backup directory
	*/
	hrStatus = MoveFilesInDirectory (&ucsSourcePath, &ucsTargetPath);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"MoveFilesInDirectory", 
		    L"CShimWriterTLS::DoPrepareForSnapshot");
	}





    /*
    ** Release the libraries
    */
    if (bExportPathKeyOpened)              RegCloseKey (hkeyExportPath);
    if (!HandleInvalid (hLibraryTermServ)) FreeLibrary (hLibraryTermServ);
    if (!HandleInvalid (hLibraryUser32))   FreeLibrary (hLibraryUser32);

    StringFree (&ucsTargetPath);
    StringFree (&ucsSourcePath);
    StringFree (&ucsValueData);

    return (hrStatus);
    } /* CShimWriterTLS::DoPrepareForSnapshot () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtreventlog.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    module wrtreventlog.cpp | Implementation of SnapshotWriter for Event logs



Author:

    Michael C. Johnson [mikejohn] 14-Feb-2000


Description:
	
    Add comments.


Revision History:

	X-11	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

	X-10	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path

	X-9	MCJ		Michael C. Johnson		20-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.


	X-8	MCJ		Michael C. Johnson		15-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-7	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()

	X-6	MCJ		Michael C. Johnson		02-Jun-2000
		Make event log writer sensitive to which volumes are being 
		backed up/snapshotted.

	X-5	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-4	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

	X-3	MCJ		Michael C. Johnson		 3-Mar-2000
		Remove inner registry search loop, instead use a direct
		lookup.
		Do a preparatory cleanup of the target save directory to make
		sure we don't have to deal with any junk left from a previous
		invokcation.
		

	X-2	MCJ		Michael C. Johnson		23-Feb-2000
		Move context handling to common code.
		Add checks to detect/prevent unexpected state transitions.
		Remove references to 'Melt' as no longer present. Do any
		cleanup actions in 'Thaw'.

	X-1	MCJ		Michael C. Johnson		14-Feb-2000
		Initial creation. Based upon skeleton writer module from
		Stefan Steiner, which in turn was based upon the sample
		writer module from Adi Oltean.


--*/


#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHEVLGC"
//
////////////////////////////////////////////////////////////////////////

/*
** The save path has a standard form which is
**
**	%SystemRoot%\Repair\Backup,
**
** followed by the application writer string as publised in the export
** table followed by whatever else the writer requires.
*/
#define APPLICATION_STRING			L"EventLogs"
#define COMPONENT_NAME				L"Event Logs"
#define TARGET_PATH				ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING

#define EVENTLOG_SUBKEY_EVENTLOG		L"SYSTEM\\CurrentControlSet\\Services\\Eventlog"
#define EVENTLOG_VALUENAME_FILE			L"File"

#define EVENTLOG_BUFFER_SIZE			(4096)

DeclareStaticUnicodeString (ucsValueRecognitionFile, EVENTLOG_VALUENAME_FILE);


/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterEventLog : public CShimWriter
    {
public:
    CShimWriterEventLog (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) : 
		CShimWriter (pwszWriterName, pwszTargetPath) {};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);
    };


static CShimWriterEventLog ShimWriterEventLog (APPLICATION_STRING, TARGET_PATH);

PCShimWriter pShimWriterEventLog = &ShimWriterEventLog;




/*
**++
**
** Routine Description:
**
**	The Cluster database snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterEventLog::DoIdentify ()
    {
    CVssFunctionTracer ft (VSSDBG_SHIM, L"CShimWriterEventLog::DoIdentify");


    try
	{
	ft.hr = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							   NULL,
							   COMPONENT_NAME,
							   COMPONENT_NAME,
							   NULL, // icon
							   0,
							   true,
							   false,
							   false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddComponent");




	ft.hr = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								  COMPONENT_NAME,
								  m_pwszTargetPath,
								  L"*",
								  true,
								  NULL);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddFilesToFileGroup");




	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (L"%SystemRoot%\\system32\\config",
								 L"*.evt",
								 false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles");

	} VSS_STANDARD_CATCH (ft)



    return (ft.hr);
    } /* CShimWriterEventLog::DoIdentify () */


/*++

Routine Description:

    The Cluster database snapshot writer PrepareForSnapshot function.
    Currently all of the real work for this writer happens here.

Arguments:

    Same arguments as those passed in the PrepareForSnapshot event.

Return Value:

    Any HRESULT from HapeAlloc(), RegXxxx() or event log operations

--*/

HRESULT CShimWriterEventLog::DoPrepareForSnapshot ()
    {
    HRESULT		hrStatus;
    DWORD		winStatus;
    DWORD		dwIndex                     = 0;
    HKEY		hkeyEventLogList            = NULL;
    BOOL		bSucceeded                  = FALSE;
    BOOL		bEventLogListKeyOpened      = FALSE;
    BOOL		bEventLogValueFileKeyOpened = FALSE;
    BOOL		bContinueEventLogSearch     = TRUE;
    UNICODE_STRING	ucsEventLogSourcePath;
    UNICODE_STRING	ucsEventLogTargetPath;
    UNICODE_STRING	ucsValueData;
    UNICODE_STRING	ucsSubkeyName;
    USHORT		usEventLogTargetPathRootLength;



    StringInitialise (&ucsEventLogTargetPath);
    StringInitialise (&ucsValueData);
    StringInitialise (&ucsSubkeyName);


    hrStatus = StringAllocate (&ucsSubkeyName, EVENTLOG_BUFFER_SIZE * sizeof (WCHAR));


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, EVENTLOG_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringCreateFromExpandedString (&ucsEventLogTargetPath,
						   m_pwszTargetPath,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	StringAppendString (&ucsEventLogTargetPath, DIR_SEP_STRING);

	usEventLogTargetPathRootLength = ucsEventLogTargetPath.Length / sizeof (WCHAR);



	/*
	** We now have all the pieces in place so go search the eventlog list
	** for the logs to deal with.
	*/
	winStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
				   EVENTLOG_SUBKEY_EVENTLOG,
				   0L,
				   KEY_READ,
				   &hkeyEventLogList);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);

	bEventLogListKeyOpened = SUCCEEDED (hrStatus);


	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"RegOpenKeyExW (eventlog list)", 
		    L"CShimWriterEventLog::DoPrepareForSnapshot");
	}



    while (SUCCEEDED (hrStatus) && bContinueEventLogSearch)
	{
	HKEY	hkeyEventLogValueFile       = NULL;
 	DWORD	dwSubkeyNameLength          = ucsSubkeyName.MaximumLength / sizeof (WCHAR);


	StringTruncate (&ucsSubkeyName, 0);

	winStatus = RegEnumKeyExW (hkeyEventLogList,
				   dwIndex,
				   ucsSubkeyName.Buffer,
				   &dwSubkeyNameLength,
				   NULL,
				   NULL,
				   NULL,
				   NULL);

	hrStatus = HRESULT_FROM_WIN32 (winStatus);



	if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_NO_MORE_ITEMS) == hrStatus))
	    {
	    hrStatus = NOERROR;

	    bContinueEventLogSearch = FALSE;
	    }

	else if (FAILED (hrStatus))
	    {
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegEnumKeyExW", 
			L"CShimWriterEventLog::DoPrepareForSnapshot");
	    }

	else
	    {
	    ucsSubkeyName.Length = (USHORT)(dwSubkeyNameLength * sizeof (WCHAR));

	    ucsSubkeyName.Buffer [ucsSubkeyName.Length / sizeof (WCHAR)] = UNICODE_NULL;



	    winStatus = RegOpenKeyExW (hkeyEventLogList,
				       ucsSubkeyName.Buffer,
				       0L,
				       KEY_QUERY_VALUE,
				       &hkeyEventLogValueFile);

	    hrStatus = HRESULT_FROM_WIN32 (winStatus);

	    bEventLogValueFileKeyOpened = SUCCEEDED (hrStatus);

	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegOpenKeyExW (eventlog name)", 
			L"CShimWriterEventLog::DoPrepareForSnapshot");


	    if (SUCCEEDED (hrStatus))
		{
		DWORD	dwValueDataLength = ucsValueData.MaximumLength;
		DWORD	dwValueType       = REG_NONE;

		StringTruncate (&ucsValueData, 0);
		StringTruncate (&ucsEventLogTargetPath, usEventLogTargetPathRootLength);		


		winStatus = RegQueryValueExW (hkeyEventLogValueFile,
					      EVENTLOG_VALUENAME_FILE,
					      NULL,
					      &dwValueType,
					      (PBYTE)ucsValueData.Buffer,
					      &dwValueDataLength);


		hrStatus = HRESULT_FROM_WIN32 (winStatus);

		LogFailure (NULL, 
			    hrStatus, 
			    hrStatus, 
			    m_pwszWriterName, 
			    L"RegQueryValueExW", 
			    L"CShimWriterEventLog::DoPrepareForSnapshot");



		if (SUCCEEDED (hrStatus) && (REG_EXPAND_SZ == dwValueType))
		    {
		    HANDLE	hEventLog          = NULL;
		    BOOL	bIncludeInSnapshot = FALSE;
		    PWCHAR	pwszFilename;


		    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

		    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;



		    StringInitialise (&ucsEventLogSourcePath);

		    hrStatus = StringCreateFromExpandedString (&ucsEventLogSourcePath,
							       ucsValueData.Buffer,
							       0);


		    if (SUCCEEDED (hrStatus))
			{
			hrStatus = IsPathInVolumeArray (ucsEventLogSourcePath.Buffer,
							m_ulVolumeCount,
							m_ppwszVolumeNamesArray,
							&bIncludeInSnapshot);
			}



		    if (SUCCEEDED (hrStatus) && bIncludeInSnapshot)
			{
			pwszFilename = wcsrchr (ucsEventLogSourcePath.Buffer, DIR_SEP_CHAR);

			pwszFilename = (NULL == pwszFilename)
						? ucsEventLogSourcePath.Buffer
						: pwszFilename + 1;

			StringAppendString (&ucsEventLogTargetPath, pwszFilename);



			hEventLog = OpenEventLogW (NULL,
						   ucsSubkeyName.Buffer);

			hrStatus = GET_STATUS_FROM_BOOL (NULL != hEventLog);

			LogFailure (NULL, 
				    hrStatus, 
				    hrStatus, 
				    m_pwszWriterName, 
				    L"OpenEventLogW", 
				    L"CShimWriterEventLog::DoPrepareForSnapshot");
			}


		    if (SUCCEEDED (hrStatus) && bIncludeInSnapshot)
			{
			bSucceeded = BackupEventLogW (hEventLog,
						      ucsEventLogTargetPath.Buffer);

			hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

			LogFailure (NULL, 
				    hrStatus, 
				    hrStatus, 
				    m_pwszWriterName, 
				    L"BackupEventLogW", 
				    L"CShimWriterEventLog::DoPrepareForSnapshot");


			bSucceeded = CloseEventLog (hEventLog);
			}


		    StringFree (&ucsEventLogSourcePath);
		    }
		}


	    if (bEventLogValueFileKeyOpened)
		{
		RegCloseKey (hkeyEventLogValueFile);
		}


	    /*
	    ** Done with this value so go look for another.
	    */
	    dwIndex++;
	    }
	}



    if (bEventLogListKeyOpened)
	{
	RegCloseKey (hkeyEventLogList);
	}


    StringFree (&ucsEventLogTargetPath);
    StringFree (&ucsValueData);
    StringFree (&ucsSubkeyName);

    return (hrStatus);
    } /* DoEventLogFreeze () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\samples\requestor\util.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	util.cpp
**
**
** Abstract:
**
**	Sample program to
**      - obtain and display the Writer metadata.
**      - create a snapshot set
**
** Author:
**
**	Adi Oltean      [aoltean]       05-Dec-2000
**
**  The sample is based on the Metasnap test program  written by Michael C. Johnson.
**
**
** Revision History:
**
**--
*/

///////////////////////////////////////////////////////////////////////////////
// Includes

#include "vsreq.h"



///////////////////////////////////////////////////////////////////////////////
// Print usage


void CVssSampleRequestor::PrintUsage()
{
    wprintf(
        L"\nUsage:\n"
        L"      vsreq [-b] [-s] [-x <file.xml>] [<volumes>]\n"
        L"\nOptions:\n"
        L"      -b              Backup includes bootable & system state.\n"
        L"      -s              Enable component selection.\n"
        L"      -x <file.xml>   Generate an XML file containing the backup metadata\n"
        L"      <volumes>       Specifies the volumes to be part of the snapshot set\n"
        L"                      The volumes in the list must be distinct and \n"
        L"                      must be separated by space. A volume must be \n"
        L"                      terminated with a trailing backslask (for example C:\\).\n"
        L"\n"
        L"\nExample:\n"
        L"      The following command will create a snapshot set\n"
        L"      on the volumes mounted under c:\\ and d:\\\n"
        L"\n"
        L"              vsreq c:\\ d:\\ \n"
        L"\n"
        L"      The following command will create a snapshot set on the volumes \n"
        L"      that contain selected components and also the volume c:\\\n"
        L"      Also, the backup will contain bootable and system state.\n"
        L"      The XML results will be stored in file.xml\n"
        L"\n"
        L"              vsreq -b -s -x file.xml c:\\ \n"
        );
    throw(2);
}


void CVssSampleRequestor::ParseCommandLine(
        IN  INT nArgsCount,
        IN  WCHAR ** ppwszArgsArray
        )
{
    if (nArgsCount == 0)
        PrintUsage();

    // For each argument in the command line
    bool bParsingVolumes = false;
    INT nCurrentArg = nArgsCount;
    WCHAR ** ppwszCurrentArg = ppwszArgsArray;
    for(; nCurrentArg--; ppwszCurrentArg++)
    {
        if (!bParsingVolumes) {
            // Check for Bootable & system state option
            if (!m_bBootableSystemState && !wcscmp(*ppwszCurrentArg, L"-b")) {
                m_bBootableSystemState = true;
                continue;
            }

            // Check for Selected components option
            if (!m_bComponentSelectionEnabled && !wcscmp(*ppwszCurrentArg, L"-s")) {
                m_bComponentSelectionEnabled = true;
                continue;
            }

            // Check for Xml file option
            if (!m_pwszXmlFile && !wcscmp(*ppwszCurrentArg, L"-x")) {
                if (nCurrentArg-- == 0)
                    return PrintUsage();
                ppwszCurrentArg++;
                m_pwszXmlFile = *ppwszCurrentArg;
                continue;
            }
        }

        // We suppose that the next arguments are the volumes
        bParsingVolumes = true;

        // Add the volume to the list of snapshotting volumes
        // Make sure that the volume name is valid
        bool bAdded = false;
        if (!AddVolume(*ppwszCurrentArg, bAdded)) {
            wprintf(L"\nError while parsing the command line:\n"
                L"\t%s is not a valid option or a mount point [0x%08lx]\n\n",
                *ppwszCurrentArg, GetLastError() );
            PrintUsage();
        }

        // Check if the same volume is added twice
        if (!bAdded) {
            wprintf(L"\nError while parsing the command line:\n"
                L"\tThe volume %s is specified twice\n\n", *ppwszCurrentArg );
            PrintUsage();
        }
    }

    // Check if we added at least one volume
    if ((m_nVolumesCount == 0) && !m_bComponentSelectionEnabled) {
        wprintf(L"\nError while parsing the command line:\n"
            L"\t- You should specify at least one volume or enable component selection\n\n");
        PrintUsage();
    }
}


// Add the given volume by the contained path
void CVssSampleRequestor::AddVolumeForComponent(
    IN IVssWMFiledesc* pFileDesc
    )
{
    // Get the component path
	CComBSTR bstrPath;
	CHECK_SUCCESS(pFileDesc->GetPath(&bstrPath));
	
	// Trying to find the volume that will contain the path.
	WCHAR wszExpandedPath[MAX_TEXT_BUFFER];
    if (!ExpandEnvironmentStringsW(bstrPath, wszExpandedPath, MAX_TEXT_BUFFER))
        Error( 1, L"\nExpandEnvironmentStringsW(%s, wszExpandedPath, MAX_TEXT_BUFFER) failed with [0x%08lx]\n",
            bstrPath, GetLastError());

	// Eliminate one by one the terminating folder names, until we reach an existing path.
	// Then get the volume name for that path
	WCHAR wszMountPoint[MAX_TEXT_BUFFER];
	while(true) {
        if (GetVolumePathNameW(wszExpandedPath, wszMountPoint, MAX_TEXT_BUFFER))
            break;
        if (GetLastError() != ERROR_FILE_NOT_FOUND)
            Error( 1, L"\nGetVolumePathNameW(%s, wszMountPoint, MAX_TEXT_BUFFER) failed with [0x%08lx]\n",
                wszExpandedPath, GetLastError());
        WCHAR* pwszLastBackslashIndex = wcsrchr(wszExpandedPath, L'\\');
        if (!pwszLastBackslashIndex)
            Error( 1, L"\nCannot find anymore a backslash in path %s. \n"
                L"The original path %s seems invalid.\n", wszExpandedPath, bstrPath);
        // Eliminate the last folder name
        pwszLastBackslashIndex[0] = L'\0';
    }

    // Add the volume, if possible
    bool bAdded = false;
    if (!AddVolume( wszMountPoint, bAdded ))
            Error( 1, L"\nUnexpected error: cannot add volume %s to the snapshot set.\n", wszMountPoint);
   	wprintf (L"          [Volume %s (that contains the file) %s marked as a candidate for snapshot]\n",
   	    wszMountPoint, bAdded? L"is": L"is already");
}


// Add the given volume in the list of potential candidates for snapshots
// - Returns "false" if the volume does not correspond to a real mount point
//   (and GetLastError() will contain the correct Win32 error code)
// - Sets "true" in the bAdded parameter if the volume is actually added
bool CVssSampleRequestor::AddVolume(
    IN WCHAR* pwszVolume,
    OUT bool & bAdded
    )
{
    // Initialize [out] parameters
    bAdded = false;

    // Check if the volume represents a real mount point
    WCHAR wszVolumeName[MAX_TEXT_BUFFER];
    if (!GetVolumeNameForVolumeMountPoint(pwszVolume, wszVolumeName, MAX_TEXT_BUFFER))
        return false; // Invalid volume

    // Check if the volume is already added.
    for (INT nIndex = 0; nIndex < m_nVolumesCount; nIndex++)
        if (!wcscmp(wszVolumeName, m_ppwszVolumeNamesList[nIndex]))
            return true; // Volume already added. Stop here.

    // Check if we exceeded the maximum number of volumes
    if (m_nVolumesCount == MAX_VOLUMES)
        Error( 1, L"Maximum number of volumes exceeded");

    // Create a copy of the volume
    WCHAR* pwszNewVolume = _wcsdup(pwszVolume);
    if (pwszNewVolume == NULL)
        Error( 1, L"Memory allocation error");

    // Create a copy of the volume name
    WCHAR* pwszNewVolumeName = _wcsdup(wszVolumeName);
    if (pwszNewVolumeName == NULL) {
        free(pwszNewVolume);
        Error( 1, L"Memory allocation error");
    }

    // Add the volume in our internal list of snapshotted volumes
    m_ppwszVolumesList[m_nVolumesCount] = pwszNewVolume;
    m_ppwszVolumeNamesList[m_nVolumesCount] = pwszNewVolumeName;
    m_nVolumesCount++;
    bAdded = true;

    return true;
}


// This function displays the formatted message at the console and throws
// The passed return code will be returned by vsreq.exe
void CVssSampleRequestor::Error(
    IN  INT nReturnCode,
    IN  const WCHAR* pwszMsgFormat,
    IN  ...
    )
{
    va_list marker;
    va_start( marker, pwszMsgFormat );
    vwprintf( pwszMsgFormat, marker );
    va_end( marker );

    // throw that return code.
    throw(nReturnCode);
}


///////////////////////////////////////////////////////////////////////////////
// Utility functions


// Print a file description object
void CVssSampleRequestor::PrintFiledesc (IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription)
{
    CComBSTR bstrPath;
    CComBSTR bstrFilespec;
    CComBSTR bstrAlternate;
    bool     bRecursive;

    CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
    CHECK_SUCCESS(pFiledesc->GetFilespec (&bstrFilespec));
    CHECK_NOFAIL(pFiledesc->GetRecursive(&bRecursive));
    CHECK_NOFAIL(pFiledesc->GetAlternateLocation(&bstrAlternate));

    wprintf (L"%s\n"
        L"          Path = %s\n"
        L"          Filespec = %s\n"
        L"          Recursive = %s\n",
        wszDescription,
        bstrPath,
        bstrFilespec,
        bRecursive ? L"yes" : L"no");

    if (bstrAlternate && wcslen (bstrAlternate) > 0)
    	wprintf(L"          Alternate Location = %s\n", bstrAlternate);
}


// Convert a usage type into a string
LPCWSTR CVssSampleRequestor::GetStringFromUsageType (VSS_USAGE_TYPE eUsageType)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eUsageType)
	{
	case VSS_UT_BOOTABLESYSTEMSTATE: pwszRetString = L"BootableSystemState"; break;
	case VSS_UT_SYSTEMSERVICE:       pwszRetString = L"SystemService";       break;
	case VSS_UT_USERDATA:            pwszRetString = L"UserData";            break;
	case VSS_UT_OTHER:               pwszRetString = L"Other";               break;
					
	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a source type into a string
LPCWSTR CVssSampleRequestor::GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eSourceType)
	{
	case VSS_ST_TRANSACTEDDB:    pwszRetString = L"TransactionDb";    break;
	case VSS_ST_NONTRANSACTEDDB: pwszRetString = L"NonTransactionDb"; break;
	case VSS_ST_OTHER:           pwszRetString = L"Other";            break;

	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a restore method into a string
LPCWSTR CVssSampleRequestor::GetStringFromRestoreMethod (VSS_RESTOREMETHOD_ENUM eRestoreMethod)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eRestoreMethod)
	{
	case VSS_RME_RESTORE_IF_NOT_THERE:          pwszRetString = L"RestoreIfNotThere";          break;
	case VSS_RME_RESTORE_IF_CAN_REPLACE:        pwszRetString = L"RestoreIfCanReplace";        break;
	case VSS_RME_STOP_RESTORE_START:            pwszRetString = L"StopRestoreStart";           break;
	case VSS_RME_RESTORE_TO_ALTERNATE_LOCATION: pwszRetString = L"RestoreToAlternateLocation"; break;
	case VSS_RME_RESTORE_AT_REBOOT:             pwszRetString = L"RestoreAtReboot";            break;
	case VSS_RME_CUSTOM:                        pwszRetString = L"Custom";                     break;

	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a writer restore method into a string
LPCWSTR CVssSampleRequestor::GetStringFromWriterRestoreMethod (VSS_WRITERRESTORE_ENUM eWriterRestoreMethod)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eWriterRestoreMethod)
	{
	case VSS_WRE_NEVER:            pwszRetString = L"RestoreNever";           break;
	case VSS_WRE_IF_REPLACE_FAILS: pwszRetString = L"RestoreIfReplaceFailsI"; break;
	case VSS_WRE_ALWAYS:           pwszRetString = L"RestoreAlways";          break;

	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a component type into a string
LPCWSTR CVssSampleRequestor::GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eComponentType)
	{
	case VSS_CT_DATABASE:  pwszRetString = L"Database";  break;
	case VSS_CT_FILEGROUP: pwszRetString = L"FileGroup"; break;

	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a failure type into a string
LPCWSTR CVssSampleRequestor::GetStringFromFailureType(HRESULT hrStatus)
{
    LPCWSTR pwszFailureType = L"";

    switch (hrStatus)
	{
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:        pwszFailureType = L"VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT";    break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:              pwszFailureType = L"VSS_E_WRITERERROR_OUTOFRESOURCES";          break;
	case VSS_E_WRITERERROR_TIMEOUT:                     pwszFailureType = L"VSS_E_WRITERERROR_TIMEOUT";                 break;
	case VSS_E_WRITERERROR_NONRETRYABLE:                pwszFailureType = L"VSS_E_WRITERERROR_NONRETRYABLE";            break;
	case VSS_E_WRITERERROR_RETRYABLE:                   pwszFailureType = L"VSS_E_WRITERERROR_RETRYABLE";               break;
	case VSS_E_BAD_STATE:                               pwszFailureType = L"VSS_E_BAD_STATE";                           break;
	case VSS_E_PROVIDER_ALREADY_REGISTERED:             pwszFailureType = L"VSS_E_PROVIDER_ALREADY_REGISTERED";         break;
	case VSS_E_PROVIDER_NOT_REGISTERED:                 pwszFailureType = L"VSS_E_PROVIDER_NOT_REGISTERED";             break;
	case VSS_E_PROVIDER_VETO:                           pwszFailureType = L"VSS_E_PROVIDER_VETO";                       break;
	case VSS_E_PROVIDER_IN_USE:				            pwszFailureType = L"VSS_E_PROVIDER_IN_USE";                     break;
	case VSS_E_OBJECT_NOT_FOUND:						pwszFailureType = L"VSS_E_OBJECT_NOT_FOUND";                    break;						
	case VSS_S_ASYNC_PENDING:							pwszFailureType = L"VSS_S_ASYNC_PENDING";                       break;
	case VSS_S_ASYNC_FINISHED:						    pwszFailureType = L"VSS_S_ASYNC_FINISHED";                      break;
	case VSS_S_ASYNC_CANCELLED:						    pwszFailureType = L"VSS_S_ASYNC_CANCELLED";                     break;
	case VSS_E_VOLUME_NOT_SUPPORTED:					pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED";                break;
	case VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER:		pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER";    break;
	case VSS_E_OBJECT_ALREADY_EXISTS:					pwszFailureType = L"VSS_E_OBJECT_ALREADY_EXISTS";               break;
	case VSS_E_UNEXPECTED_PROVIDER_ERROR:				pwszFailureType = L"VSS_E_UNEXPECTED_PROVIDER_ERROR";           break;
	case VSS_E_CORRUPT_XML_DOCUMENT:				    pwszFailureType = L"VSS_E_CORRUPT_XML_DOCUMENT";                break;
	case VSS_E_INVALID_XML_DOCUMENT:					pwszFailureType = L"VSS_E_INVALID_XML_DOCUMENT";                break;
	case VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED:       pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED";   break;
	case VSS_E_FLUSH_WRITES_TIMEOUT:                    pwszFailureType = L"VSS_E_FLUSH_WRITES_TIMEOUT";                break;
	case VSS_E_HOLD_WRITES_TIMEOUT:                     pwszFailureType = L"VSS_E_HOLD_WRITES_TIMEOUT";                 break;
	case VSS_E_UNEXPECTED_WRITER_ERROR:                 pwszFailureType = L"VSS_E_UNEXPECTED_WRITER_ERROR";             break;
	case VSS_E_SNAPSHOT_SET_IN_PROGRESS:                pwszFailureType = L"VSS_E_SNAPSHOT_SET_IN_PROGRESS";            break;
	case VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED:     pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED"; break;
	case VSS_E_WRITER_INFRASTRUCTURE:	 		        pwszFailureType = L"VSS_E_WRITER_INFRASTRUCTURE";               break;
	case VSS_E_WRITER_NOT_RESPONDING:			        pwszFailureType = L"VSS_E_WRITER_NOT_RESPONDING";               break;
    case VSS_E_WRITER_ALREADY_SUBSCRIBED:		        pwszFailureType = L"VSS_E_WRITER_ALREADY_SUBSCRIBED";           break;
	
	case NOERROR:
	default:
	    break;
	}

    return (pwszFailureType);
}


// Convert a writer status into a string
LPCWSTR CVssSampleRequestor::GetStringFromWriterStatus(VSS_WRITER_STATE eWriterStatus)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eWriterStatus)
	{
	case VSS_WS_STABLE:                    pwszRetString = L"STABLE";                  break;
	case VSS_WS_WAITING_FOR_FREEZE:        pwszRetString = L"WAITING_FOR_FREEZE";      break;
	case VSS_WS_WAITING_FOR_THAW:          pwszRetString = L"WAITING_FOR_THAW";        break;
    case VSS_WS_WAITING_FOR_POST_SNAPSHOT: pwszRetString = L"WAITING_FOR_POST_SNAPSHOT"; break;
	case VSS_WS_WAITING_FOR_BACKUP_COMPLETE:    pwszRetString = L"WAITING_FOR_BACKUP_COMPLETION";  break;
	case VSS_WS_FAILED_AT_IDENTIFY:        pwszRetString = L"FAILED_AT_IDENTIFY";      break;
	case VSS_WS_FAILED_AT_PREPARE_BACKUP:  pwszRetString = L"FAILED_AT_PREPARE_BACKUP";break;
	case VSS_WS_FAILED_AT_PREPARE_SNAPSHOT:    pwszRetString = L"FAILED_AT_PREPARE_SNAPSHOT";  break;
	case VSS_WS_FAILED_AT_FREEZE:          pwszRetString = L"FAILED_AT_FREEZE";        break;
	case VSS_WS_FAILED_AT_THAW:			   pwszRetString = L"FAILED_AT_THAW";          break;
    case VSS_WS_FAILED_AT_POST_SNAPSHOT:   pwszRetString = L"FAILED_AT_POST_SNAPSHOT"; break;
    case VSS_WS_FAILED_AT_BACKUP_COMPLETE: pwszRetString = L"FAILED_AT_BACKUP_COMPLETE"; break;
    case VSS_WS_FAILED_AT_PRE_RESTORE:     pwszRetString = L"FAILED_AT_PRE_RESTORE"; break;
    case VSS_WS_FAILED_AT_POST_RESTORE:    pwszRetString = L"FAILED_AT_POST_RESTORE"; break;
	default:
	    break;
	}

    return (pwszRetString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\modules\wrtrshim\src\wrtrrsm.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    wrtrrsm.cpp

Abstract:

    Writer shim module for RSM

Author:

    Stefan R. Steiner   [ssteiner]        01-31-2000

Revision History:

	X-11	MCJ		Michael C. Johnson		20-Oct-2000
		177624: Apply error scrub changes and log errors to event log

 	X-10	MCJ		Michael C. Johnson		 2-Aug-2000
		143435: Change name of target path
		Also remove trailing '\' on export sibdurectory reported in 
		metadata.

	X-9	MCJ		Michael C. Johnson		18-Jul-2000
		145021: Load the Ntms dll dynamically to reduce footprint.

	X-8	MCJ		Michael C. Johnson		27-Jun-2000
		Add an alternative location mapping for the restore of the
		RSM spit files.
		Handle change in RSM startup behaviour which means calls to 
		OpenNtmsSession() may fail until service has started.

	X-7	MCJ		Michael C. Johnson		21-Jun-2000
		Apply code review comments.
		Remove trailing '\' from Include/Exclude lists.

	X-6	MCJ		Michael C. Johnson		15-Jun-2000
		Generate metadata in new DoIdentify() routine.

	X-5	MCJ		Michael C. Johnson		 6-Jun-2000
		Move common target directory cleanup and creation into
		method CShimWriter::PrepareForSnapshot()

	X-4	MCJ		Michael C. Johnson		26-May-2000
		General clean up and removal of boiler-plate code, correct
		state engine and ensure shim can undo everything it did.

		Also:
		120443: Make shim listen to all OnAbort events
		120445: Ensure shim never quits on first error 
			when delivering events

	X-3	MCJ		Michael C. Johnson		21-Mar-2000
		Get writer to use same context mechanism as most of the other
		writers.
		Check registry for presence of export path definition and use
		it if present.
		Also ensure it cleans up after itself.

	X-2	MCJ		Michael C. Johnson		 9-Mar-2000
		Updates to get shim to use CVssWriter class.
		Remove references to 'Melt'.

--*/

#include "stdafx.h"
#include "common.h"
#include "wrtrdefs.h"
#include <ntmsapi.h>

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "WSHRSMC"
//
////////////////////////////////////////////////////////////////////////


#define APPLICATION_STRING		L"RemovableStorageManager"
#define COMPONENT_NAME			L"Removable Storage Manager"
#define TARGET_PATH			ROOT_BACKUP_DIR SERVICE_STATE_SUBDIR DIR_SEP_STRING APPLICATION_STRING

#define EXPORT_SUBDIRECTORY		L"\\Export"

#define SUBKEY_SOURCE_PATH_ROOT		L"SYSTEM\\CurrentControlSet\\Control\\NTMS\\NtmsData"
#define DEFAULT_SOURCE_PATH_ROOT	L"%SystemRoot%\\system32\\NtmsData"


#define NTMS_OPEN_SESSION_RETRY_PERIOD		(20)		// in seconds
#define NTMS_OPEN_SESSION_POLLING_INTERVAL	(100)		// in milli-seconds
#define NTMS_OPEN_SESSION_ATTEMPTS		((NTMS_OPEN_SESSION_RETRY_PERIOD * 1000) / NTMS_OPEN_SESSION_POLLING_INTERVAL)


typedef HANDLE (WINAPI *PFnOpenNtmsSessionW)   (LPCWSTR, LPCWSTR, DWORD);
typedef DWORD  (WINAPI *PFnCloseNtmsSession)   (HANDLE);
typedef DWORD  (WINAPI *PFnExportNtmsDatabase) (HANDLE);


/*
** NOTE
**
** This module assumes that there will be at most one thread active in
** it any any particular instant. This means we can do things like not
** have to worry about synchronizing access to the (minimal number of)
** module global variables.
*/

class CShimWriterRSM : public CShimWriter
    {
public:
    CShimWriterRSM (LPCWSTR pwszWriterName, LPCWSTR pwszTargetPath) : 
		CShimWriter (pwszWriterName, pwszTargetPath) {};

private:
    HRESULT DoIdentify (VOID);
    HRESULT DoPrepareForSnapshot (VOID);

    HRESULT DetermineDatabaseLocation (PUNICODE_STRING pucsDatabasePath);
    };


static CShimWriterRSM ShimWriterRSM (APPLICATION_STRING, TARGET_PATH);

PCShimWriter pShimWriterRSM = &ShimWriterRSM;


/*
**++
**
** Routine Description:
**
**	DetermineDatabaseLocation() attempts to locate the RSM (aka
**	NTMS) database location following the same rules as RSM uses.
**
**
** Arguments:
**
**	pucsDatabasePath	initliased unicode string
**
**
** Return Value:
**
**	HRESULTS from memory allocation failures and registry operations 
**
**-- 
*/

HRESULT CShimWriterRSM::DetermineDatabaseLocation (PUNICODE_STRING pucsDatabasePath)
    {
    HRESULT		hrStatus = NOERROR;
    DWORD		dwStatus;
    DWORD		dwValueDataLength;
    DWORD		dwValueType;
    UNICODE_STRING	ucsValueData;


    StringInitialise (&ucsValueData);

    StringFree (pucsDatabasePath);


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = StringAllocate (&ucsValueData, 
				   REGISTRY_BUFFER_SIZE * sizeof (WCHAR));
	}


    if (SUCCEEDED (hrStatus))
	{
	/*
	** Everything is setup, so first check to see if there is a
	** registry key present which will tell us where the Ntms
	** database is supposed to live. If it's got environment
	** variables in it make sure they get expanded.
	**
	** If there is no key we fall back to the default location.
	*/
	dwValueDataLength = ucsValueData.MaximumLength;
	dwValueType       = REG_NONE;

	dwStatus = RegQueryValueExW (HKEY_LOCAL_MACHINE,
				     SUBKEY_SOURCE_PATH_ROOT,
				     NULL,
				     &dwValueType,
				     (PBYTE) ucsValueData.Buffer,
				     &dwValueDataLength);

	hrStatus = HRESULT_FROM_WIN32 (dwStatus);

	if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) != hrStatus))
	    {
	    /*
	    ** This may be a real failure so log it just in case
	    ** things stop working later on.
	    */
	    LogFailure (NULL, 
			hrStatus, 
			hrStatus, 
			m_pwszWriterName, 
			L"RegQueryValueExW", 
			L"CShimWriterRSM::DetermineDatabaseLocation");
	    }


	if (SUCCEEDED (hrStatus))
	    {
	    ucsValueData.Length = (USHORT)(dwValueDataLength - sizeof (UNICODE_NULL));

	    ucsValueData.Buffer [ucsValueData.Length / sizeof (WCHAR)] = UNICODE_NULL;
	    }



	if (SUCCEEDED (hrStatus) && (REG_EXPAND_SZ == dwValueType))
	    {
	    hrStatus = StringCreateFromExpandedString (pucsDatabasePath,
						       ucsValueData.Buffer,
						       MAX_PATH);
	    }

	else if (SUCCEEDED (hrStatus) && (REG_SZ == dwValueType))
	    {
	    hrStatus = StringAllocate (pucsDatabasePath,
				       MAX_PATH * sizeof (WCHAR));


	    if (SUCCEEDED (hrStatus))
		{
		StringAppendString (pucsDatabasePath, &ucsValueData);
		}
	    }

	else
	    {
	    /*
	    ** Ok we either failed to find the registry key or what we did
	    ** get wasn't suitable for us to use so fall back to the
	    ** 'standard default' location and just pray that's where the
	    ** ExportNtmsDatabase() call actually dumps it's data.
	    */
	    hrStatus = StringCreateFromExpandedString (pucsDatabasePath,
						       DEFAULT_SOURCE_PATH_ROOT,
						       MAX_PATH);
	    }
	}



    StringFree (&ucsValueData);


    return (hrStatus);
    } /* CShimWriterRSM::DetermineDatabaseLocation () */

/*
**++
**
** Routine Description:
**
**	The Removable Storage Manager database snapshot writer DoIdentify() function.
**
**
** Arguments:
**
**	m_pwszTargetPath (implicit)
**
**
** Return Value:
**
**	Any HRESULT
**
**--
*/

HRESULT CShimWriterRSM::DoIdentify ()
    {
    CVssFunctionTracer	ft (VSSDBG_SHIM, L"CShimWriterRSM::DoIdentify");
    UNICODE_STRING	ucsDatabaseLocation;


    StringInitialise (&ucsDatabaseLocation);



    try
	{
	ft.hr = DetermineDatabaseLocation (&ucsDatabaseLocation);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"CShimWriterRSM::DetermineDatabaseLocation");




	ft.hr = m_pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							   NULL,
							   COMPONENT_NAME,
							   COMPONENT_NAME,
							   NULL, // icon
							   0,
							   true,
							   false,
							   false);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddComponent");




	ft.hr = m_pIVssCreateWriterMetadata->AddExcludeFiles (ucsDatabaseLocation.Buffer,
							      L"*",
							      true);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddExcludeFiles");




	ft.hr = m_pIVssCreateWriterMetadata->AddFilesToFileGroup (NULL,
								  COMPONENT_NAME,
								  m_pwszTargetPath,
								  L"*",
								  true,
								  NULL);

	LogAndThrowOnFailure (ft, m_pwszWriterName, L"IVssCreateWriterMetadata::AddFilesToFileGroup");



	} 
    VSS_STANDARD_CATCH (ft)




    StringFree (&ucsDatabaseLocation);

    return (ft.hr);
    } /* CShimWriterRSM::DoIdentify () */

/*++

Routine Description:

    The RSM writer PrepareForFreeze function.  Currently all of the
    real work for this writer happens here.

Arguments:

    Same arguments as those passed in the PrepareForFreeze event.

Return Value:

    Any HRESULT

--*/

HRESULT CShimWriterRSM::DoPrepareForSnapshot ()
    {
    HRESULT			hrStatus = NOERROR;
    HANDLE			hRsm     = INVALID_HANDLE_VALUE;
    HMODULE			hNtmsDll = NULL;
    DWORD			dwStatus;
    UNICODE_STRING		ucsTargetPath;
    UNICODE_STRING		ucsSourcePath;
    PFnOpenNtmsSessionW		DynamicOpenNtmsSessionW;
    PFnExportNtmsDatabase	DynamicExportNtmsDatabase;
    PFnCloseNtmsSession		DynamicCloseNtmsSession;


    StringInitialise (&ucsTargetPath);
    StringInitialise (&ucsSourcePath);


    hNtmsDll = LoadLibraryW (L"ntmsapi.dll");

    hrStatus = GET_STATUS_FROM_HANDLE (hNtmsDll);

    LogFailure (NULL, 
		hrStatus, 
		hrStatus, 
		m_pwszWriterName, 
		L"LoadLibraryW (ntmsapi.dll)", 
		L"CShimWriterRSM::DoPrepareForSnapshot");



    if (SUCCEEDED (hrStatus))
	{
	DynamicOpenNtmsSessionW = (PFnOpenNtmsSessionW) GetProcAddress (hNtmsDll, "OpenNtmsSessionW");

	hrStatus = GET_STATUS_FROM_BOOL (NULL != DynamicOpenNtmsSessionW);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetProcAddress (OpenNtmsSessionW)", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}



    if (SUCCEEDED (hrStatus))
	{
	DynamicExportNtmsDatabase = (PFnExportNtmsDatabase) GetProcAddress (hNtmsDll, "ExportNtmsDatabase");

	hrStatus = GET_STATUS_FROM_BOOL (NULL != DynamicExportNtmsDatabase);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetProcAddress (ExportNtmsDatabase)", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}



    if (SUCCEEDED (hrStatus))
	{
	DynamicCloseNtmsSession = (PFnCloseNtmsSession) GetProcAddress (hNtmsDll, "CloseNtmsSession");

	hrStatus = GET_STATUS_FROM_BOOL (NULL != DynamicCloseNtmsSession);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"GetProcAddress (CloseNtmsSession)", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}



    if (SUCCEEDED (hrStatus))
	{
	/*
	** Get ourselves a copy of the target path we can play with
	*/
	hrStatus = StringCreateFromExpandedString (&ucsTargetPath,
						   m_pwszTargetPath,
						   MAX_PATH);
	}


    if (SUCCEEDED (hrStatus))
	{
	/*
	** Find the location of the database. The export files are
	** stored in a subdirectory off this.
	*/
	hrStatus = DetermineDatabaseLocation (&ucsSourcePath);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"DetermineDatabaseLocation", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}


    if (SUCCEEDED (hrStatus))
	{
	ULONG	ulOpenSessionRetryAttempts = NTMS_OPEN_SESSION_ATTEMPTS;
	BOOL	bRetryNtmsOpenSession;


	/*
	** Add the necessary trailing bits and pieces to the source
	** and target paths. Note that we know that there is enough
	** space already so this cannot fail.
	*/
	StringAppendString (&ucsSourcePath, EXPORT_SUBDIRECTORY);


	/*
	** Now connect to RSM and tell it to copy the database
	**
	** As far as we know the RSM should dump the database in the
	** location we've already determined. If not then we are
	** sunk. Not much we can do about that.
	**
	** 
	*/
	do 
	    {	
	    hRsm = DynamicOpenNtmsSessionW (NULL, L"RSM Snapshot Writer", 0);

	    hrStatus = GET_STATUS_FROM_BOOL (INVALID_HANDLE_VALUE != hRsm);

	    bRetryNtmsOpenSession = (HRESULT_FROM_WIN32 (ERROR_NOT_READY) == hrStatus);

	    if (bRetryNtmsOpenSession)
		{
		Sleep (NTMS_OPEN_SESSION_POLLING_INTERVAL);
		}
	    } while (bRetryNtmsOpenSession && (--ulOpenSessionRetryAttempts > 0));


	BsDebugTraceAlways (0,
			    DEBUG_TRACE_VSS_SHIM,
			    (L"CShimWriter::DoPrepareForSnapshot: OpenNtmsSession() took %u retries",
			     NTMS_OPEN_SESSION_ATTEMPTS - ulOpenSessionRetryAttempts));


	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"OpenNtmsSessionW", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}


    if (SUCCEEDED (hrStatus))
	{
	dwStatus = DynamicExportNtmsDatabase (hRsm);

	hrStatus = HRESULT_FROM_WIN32 (dwStatus);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"ExportNtmsDatabase", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");


	dwStatus = DynamicCloseNtmsSession (hRsm);
	}


    if (SUCCEEDED (hrStatus))
	{
	hrStatus = MoveFilesInDirectory (&ucsSourcePath, &ucsTargetPath);

	LogFailure (NULL, 
		    hrStatus, 
		    hrStatus, 
		    m_pwszWriterName, 
		    L"MoveFilesInDirectory", 
		    L"CShimWriterRSM::DoPrepareForSnapshot");
	}


    if (!HandleInvalid (hNtmsDll))
	{
	FreeLibrary (hNtmsDll);
	}

    StringFree (&ucsTargetPath);
    StringFree (&ucsSourcePath);

    return (hrStatus);
    } /* CShimWriterRSM::DoPrepareForSnapshot () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\betest\compont.cpp ===
#include "stdafx.hxx"
#include "vs_idl.hxx"
#include "vswriter.h"
#include "vsbackup.h"
#include "compont.h"
#include <debug.h>
#include <cwriter.h>
#include <lmshare.h>
#include <lmaccess.h>
#include <time.h>

//
//  CWriterComponentsSelection class  
//

CWriterComponentsSelection::CWriterComponentsSelection()
{
    m_WriterId = GUID_NULL;
    m_uNumComponents = 0;   
    m_ppwszComponentLogicalPathes = NULL;        
}

CWriterComponentsSelection::~CWriterComponentsSelection()
{
    if ((m_uNumComponents > 0) && (m_ppwszComponentLogicalPathes != NULL))
        {
        for (UINT i=0; i<m_uNumComponents; i++)
            {
            if (m_ppwszComponentLogicalPathes[i] != NULL)
                {
                free(m_ppwszComponentLogicalPathes[i]);
                m_ppwszComponentLogicalPathes[i] = NULL;
                }
            }

        free(m_ppwszComponentLogicalPathes);
        m_ppwszComponentLogicalPathes = NULL;
        m_uNumComponents = 0;
        }
}

void CWriterComponentsSelection::SetWriter
    (
	IN VSS_ID WriterId
	)
{
    m_WriterId = WriterId;
}

HRESULT	CWriterComponentsSelection::AddSelectedComponent
	(
	IN WCHAR* pwszComponentLogicalPath
	)
{
    if (m_WriterId == GUID_NULL)
        {
        // Don't allow adding components to NULL writer...
        return E_UNEXPECTED;
        }

    if (pwszComponentLogicalPath == NULL)
        {
        return E_INVALIDARG;
        }

    // A more clever implementation would allocate memory in chuncks, but this is just a test program...
    PWCHAR *ppwzTemp = (PWCHAR *) realloc(m_ppwszComponentLogicalPathes, (m_uNumComponents+1) * sizeof (PWCHAR));
    if (ppwzTemp != NULL)
        {
        m_ppwszComponentLogicalPathes = ppwzTemp;
        m_ppwszComponentLogicalPathes[m_uNumComponents] = NULL;
        }
    else
        {
        return E_OUTOFMEMORY;
        }

    m_ppwszComponentLogicalPathes[m_uNumComponents] = (PWCHAR) malloc((wcslen(pwszComponentLogicalPath) + 1) * sizeof (WCHAR));
    if (m_ppwszComponentLogicalPathes[m_uNumComponents] != NULL)
        {
        wcscpy(m_ppwszComponentLogicalPathes[m_uNumComponents], pwszComponentLogicalPath);
        m_uNumComponents++;
        }
    else
        {
        return E_OUTOFMEMORY;
        }

    return S_OK;    
}


BOOL CWriterComponentsSelection::IsComponentSelected
	(
	IN WCHAR* pwszComponentLogicalPath,
	IN WCHAR* pwszComponentName
	)
{
    if (m_WriterId == GUID_NULL)
        {
        // Don't allow query for NULL writer...
        return FALSE;
        }
    if (m_uNumComponents <= 0)
        {
        return FALSE;
        }

    // A component matches if:
    //  1. The selection criteria is on the logical-path of the leaf component  OR
    //  2. The selection criteria is <full-logical-path>\<component-name>
    //  3. The selction criteria is component-name (only if logical-path is NULL)
    
    for (UINT i=0; i<m_uNumComponents; i++)
        {
        DWORD dwLen;
        
        if (m_ppwszComponentLogicalPathes[i] == NULL)
            {
            continue;
            }
        
        dwLen = (DWORD)wcslen(m_ppwszComponentLogicalPathes[i]);

        if (pwszComponentLogicalPath != NULL)
            {
            // Case 1.
            if (_wcsnicmp(m_ppwszComponentLogicalPathes[i], pwszComponentLogicalPath, dwLen) == 0)
                {
                return TRUE;
                }

            // Case 2.
            if (pwszComponentName == NULL) 
                {
                continue;
                }
            WCHAR* pwszTemp = wcsrchr(m_ppwszComponentLogicalPathes[i], L'\\');
            if (pwszTemp == NULL) 
                {
                continue;
                }
            if ((pwszTemp != m_ppwszComponentLogicalPathes[i]) && (*(pwszTemp+1) != '\0'))
                {
                dwLen = (DWORD)(pwszTemp - m_ppwszComponentLogicalPathes[i]);
                if ((_wcsnicmp(m_ppwszComponentLogicalPathes[i], pwszComponentLogicalPath, dwLen) == 0) &&
                     (wcscmp(pwszTemp+1, pwszComponentName) == 0))
                    {
                    return TRUE;
                    }
                }
            }
        else
            {
            // Case 3.
            if (pwszComponentName == NULL) 
                {
                continue;
                }
            if (_wcsnicmp(m_ppwszComponentLogicalPathes[i], pwszComponentName, dwLen) == 0)
                {
                return TRUE;
                }
            }
        }

    return FALSE;            
}


//
//  CWritersSelection class  
//

CWritersSelection::CWritersSelection()
{
    m_lRef = 0;
}

CWritersSelection::~CWritersSelection()
{
	// Cleanup the Map
	for(int nIndex = 0; nIndex < m_WritersMap.GetSize(); nIndex++) 
	    {
		CWriterComponentsSelection* pComponentsSelection = m_WritersMap.GetValueAt(nIndex);
		if (pComponentsSelection)
		    {
    		delete pComponentsSelection;
		    }
	    }

	m_WritersMap.RemoveAll();
}

CWritersSelection* CWritersSelection::CreateInstance()
{
	CWritersSelection* pObj = new CWritersSelection;

	return pObj;
}

STDMETHODIMP CWritersSelection::QueryInterface(
	IN	REFIID iid,
	OUT	void** pp
	)
{
    if (pp == NULL)
        return E_INVALIDARG;
    if (iid != IID_IUnknown)
        return E_NOINTERFACE;

    AddRef();
    IUnknown** pUnk = reinterpret_cast<IUnknown**>(pp);
    (*pUnk) = static_cast<IUnknown*>(this);
	return S_OK;
}


ULONG CWritersSelection::AddRef()
{
    return ::InterlockedIncrement(&m_lRef);
}


ULONG CWritersSelection::Release()
{
    LONG l = ::InterlockedDecrement(&m_lRef);
    if (l == 0)
        delete this; // We assume that we always allocate this object on the heap!
    return l;
}


STDMETHODIMP CWritersSelection::BuildChosenComponents
    (
	WCHAR *pwszComponentsFileName
	)
{
    HRESULT hr = S_OK;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    DWORD dwBytesToRead = 0;
    DWORD dwBytesRead;
    
    // Create the file 
    hFile = CreateFile(pwszComponentsFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        {
        DWORD dwLastError = GetLastError();
  		wprintf(L"Invalid components file, CreateFile returned = %lu\n", dwLastError);
        return HRESULT_FROM_WIN32(dwLastError);
        }

    if ((dwBytesToRead = GetFileSize(hFile, NULL)) <= 0)
        {
        CloseHandle(hFile);
        DWORD dwLastError = GetLastError();
  		wprintf(L"Invalid components file, GetFileSize returned = %lu\n", dwLastError);
        return HRESULT_FROM_WIN32(dwLastError);
        }
    
    if (dwBytesToRead > 0x100000)
        {
        CloseHandle(hFile);
  		wprintf(L"Invalid components file, Provide a file with a size of less than 1 MB\n");
        return E_FAIL;
        }

    char * pcBuffer = (PCHAR) malloc (dwBytesToRead);
    if (! pcBuffer) 
        {
        CloseHandle(hFile);
        return E_OUTOFMEMORY;
        }
    
    // Read the components info
    if (! ReadFile(hFile, (LPVOID)pcBuffer, dwBytesToRead, &dwBytesRead, NULL))
        {
        DWORD dwLastError = GetLastError();
        CloseHandle(hFile);
        free (pcBuffer);
  		wprintf(L"Invalid components file, ReadFile returned = %lu\n", dwLastError);
        return HRESULT_FROM_WIN32(dwLastError);
        }
    
    CloseHandle(hFile);
    
    if (dwBytesToRead != dwBytesRead)
        {
        free (pcBuffer);
  		wprintf(L"Components selection file is supposed to have %lu bytes but only %lu bytes are read\n", dwBytesToRead, dwBytesRead);
        return E_FAIL;
        }

    // Allocate a buffer to work with
    WCHAR * pwcBuffer = (PWCHAR) malloc ((dwBytesToRead+1) * sizeof(WCHAR));
    if (! pwcBuffer) 
        {
        free (pcBuffer);
        return E_OUTOFMEMORY;
        }

    // Simple pasring, assume ANSI, Format:
    // "writer1-id": "component1.1-name", "component1.2-name",...        ; "writer2-id": "component2.1-name", ...
  	CWriterComponentsSelection* pWriterComponents = NULL;

    try 
        {
        VSS_ID WriterId = GUID_NULL;
        BOOL bBeforeWriter = TRUE;
        BOOL bInString = FALSE;
        char* pcStart = NULL;

        for (char* pcCurrent = pcBuffer; pcCurrent < (pcBuffer+dwBytesToRead); pcCurrent++)
            {
            switch (*pcCurrent) 
                {
                case ':':
                    if (bBeforeWriter && !bInString) 
                        {
                        bBeforeWriter = FALSE;
                        }
                    else
                        {
                        throw(E_FAIL);
                        }
                    break;
                    
                case ';':
                    if (bBeforeWriter || bInString) 
                        {
                        throw(E_FAIL);
                        }
                    else
                        {
                        // If we have a valid writer - add it to the map
                        if ((pWriterComponents != NULL) && (WriterId != GUID_NULL))
                            {
                        	if (!m_WritersMap.Add(WriterId, pWriterComponents))	
                        	    {
                        		delete pWriterComponents;
                        		throw E_OUTOFMEMORY;
                            	}

                            pWriterComponents = NULL;
                            WriterId = GUID_NULL;
                            }
                        
                        bBeforeWriter = TRUE;
                        }
                    break;
                    
                case ',':
                    if (bBeforeWriter || bInString) 
                        {
                        throw(E_FAIL);
                        }
                    break;
                    
                case '"':
                    if (! bInString)
                        {
                        // Mark string-start for later
                        pcStart = pcCurrent + 1;
                        }
                    else if (pcStart == pcCurrent)
                        {
                        // empty string - skip it
                        }
                    else
                        {
                        // String ends - convert to WCHAR and process
                        DWORD dwSize = (DWORD)mbstowcs(pwcBuffer, pcStart, pcCurrent - pcStart);
                        pwcBuffer[dwSize] = NULL;
                        if (dwSize <= 0) 
                            {
                            throw(E_FAIL);
                            }

                        if (bBeforeWriter)
                            {
                            // If before-writer - must be a writer GUID
                            HRESULT hrConvert = CLSIDFromString(pwcBuffer, &WriterId);
                            if ((! SUCCEEDED(hrConvert)) && (hrConvert != REGDB_E_WRITEREGDB))
                                {
                          		wprintf(L"A writer id in the components selection file is in invalid GUID format\n");
                                throw(E_FAIL);
                                }

                            if (pWriterComponents != NULL)
                                {
                                // Previous writer info was not ended correctly
                                throw(E_FAIL);
                                }

                        	pWriterComponents = new CWriterComponentsSelection;
                        	if (pWriterComponents == NULL)
                        	    {
                        	    throw(E_OUTOFMEMORY);
                        	    }
                            pWriterComponents->SetWriter(WriterId);
                            }
                        else
                            {
                            // Must be a component logical-path , name or logical-path\name
                            if (pWriterComponents != NULL)
                                {
                                pWriterComponents->AddSelectedComponent(pwcBuffer);
                                }
                            }
                        }

                    // Flip in-string flag
                    bInString = (! bInString);
                    
                    break;
                    
                case ' ':
                    break;
                    
                case '\n':
                case '\t':
                case '\r':
                    if (bInString)
                        {
                        throw(E_FAIL);
                        }
                    
                    break;
                    
                default:
                    if (! bInString)
                        {
                        throw(E_FAIL);
                        }
                    
                    break;
                    
                }
            }
         }
    
    catch (HRESULT hrParse)
        {
        hr = hrParse;

        if (hr == E_FAIL)
            {
      		wprintf(L"Invalid format of components selection file\n");
            }

        if (pWriterComponents != NULL)
            {
            // Error int he middle of writer-components creation (not added to the map yet...)
            delete pWriterComponents;
            }
        }

    free (pcBuffer);
    free (pwcBuffer);

    return hr;        
}
	
BOOL CWritersSelection::IsComponentSelected
	(
	IN VSS_ID WriterId,
	IN WCHAR* pwszComponentLogicalPath,
	IN WCHAR* pwszComponentName
	)
{
	CWriterComponentsSelection* pWriterComponents = m_WritersMap.Lookup(WriterId);
	if (pWriterComponents == NULL)
	    {
	    // No component is selected for this writer
	    return FALSE;
	    }

    // There are components selected for this writer, check if this specific one is selected
    return pWriterComponents->IsComponentSelected(pwszComponentLogicalPath, pwszComponentName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\samples\requestor\vsreq.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	vsreq.cpp
**
**
** Abstract:
**
**	Sample program to
**      - obtain and display the Writer metadata.
**      - create a snapshot set
**
** Author:
**
**	Adi Oltean      [aoltean]       05-Dec-2000
**
**  The sample is based on the Metasnap test program  written by Michael C. Johnson.
**
**
** Revision History:
**
**--
*/


///////////////////////////////////////////////////////////////////////////////
// Includes

#include "vsreq.h"


///////////////////////////////////////////////////////////////////////////////
// Processing functions

CVssSampleRequestor::CVssSampleRequestor()
{
    // Initialize data members
    m_bCoInitializeSucceeded = false;
    m_bBootableSystemState = false;
    m_bComponentSelectionEnabled = false;
    m_pBackupComponents = NULL;
    m_nVolumesCount = 0;
    m_hr = S_OK;
    m_pwszXmlFile = NULL;
    m_pXmlFile = NULL;

    // For safety
    for (int nIndex=0; nIndex<MAX_VOLUMES; nIndex++) {
        m_ppwszVolumesList[nIndex] = NULL;
        m_ppwszVolumeNamesList[nIndex] = NULL;
    }

    // Print display header
    wprintf(L"\nVSS Requestor Sample application, version 1.0\n");
}


CVssSampleRequestor::~CVssSampleRequestor()
{
    // Deallocate some internal strings
    delete m_pwszXmlFile;

    // delete the allocated volumes
    for (int nIndex=0; nIndex<m_nVolumesCount; nIndex++) {
        free(m_ppwszVolumesList[nIndex]);
        free(m_ppwszVolumeNamesList[nIndex]);
    }

    // Close the Xml file
    if (m_pXmlFile)
        fclose(m_pXmlFile);

    // Releasing backup components prior to the CoUninitialize call
    m_pBackupComponents = NULL;

    // Unloading the COM library
    if (m_bCoInitializeSucceeded)
        CoUninitialize();
}


void CVssSampleRequestor::Initialize()
{
    wprintf (L"\n----------------- Initializing ---------------------\n");

    // Initialize COM library
    CHECK_NOFAIL(CoInitializeEx (NULL, COINIT_MULTITHREADED));
	m_bCoInitializeSucceeded = true;
    wprintf (L"COM library initialized.\n");

    // Initialize COM security
    CHECK_SUCCESS
		(
		CoInitializeSecurity
			(
			NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
			-1,                                  //  IN LONG                         cAuthSvc,
			NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
			NULL,                                //  IN void                        *pReserved1,
			RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
			RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
			NULL,                                //  IN void                        *pAuthList,
			EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
			NULL                                 //  IN void                        *pReserved3
			)
		);
    wprintf (L"COM security initialized.\n");

    // Open the Xml file
    if (m_pwszXmlFile) {
        m_pXmlFile = _wfopen( m_pwszXmlFile, L"w");
        if (!m_pXmlFile)
            Error(1, L"\nError creating/opening the file %s\n", m_pwszXmlFile);
        wprintf (L"XML results file created: %s\n", m_pwszXmlFile);
    }

    // Create the Backup components object
	CHECK_NOFAIL(CreateVssBackupComponents(&m_pBackupComponents));
    wprintf (L"Backup components object created.\n");

    // Initialize the backup components object for backup
	CHECK_NOFAIL(m_pBackupComponents->InitializeForBackup());
	CHECK_SUCCESS(m_pBackupComponents->SetBackupState(
        m_bComponentSelectionEnabled, m_bBootableSystemState, VSS_BT_FULL, false));
    wprintf (L"Backup components object initialized for backup operations.\n");
}


void CVssSampleRequestor::CreateSnapshotSet()
{
	CComPtr<IVssAsync> pAsync;
	VSS_ID pSnapshotsArray[MAX_VOLUMES];
	VSS_ID SnapshotSetId = GUID_NULL;
	
    wprintf (L"\n---------- Starting backup/snapshot ----------------\n");

    // Starting a new snapshot set
    wprintf(L"Starting a new Snapshot Set\n");	
    CHECK_SUCCESS(m_pBackupComponents->StartSnapshotSet(&SnapshotSetId));
    wprintf(L"Snapshot Set created with ID = " WSTR_GUID_FMT L"\n", GUID_PRINTF_ARG(SnapshotSetId));

    // Add volumes to the snapshot set
    wprintf(L"Adding volumes to the Snapshot Set: \n");
    for (INT nIndex = 0; nIndex < m_nVolumesCount; nIndex++)
    {
		// Get the volume containing the path
        wprintf(L"\t- Adding volume containing %s ... ", m_ppwszVolumesList[nIndex] );

		// Add the volume to the snapshot set
        CHECK_SUCCESS(m_pBackupComponents->AddToSnapshotSet(m_ppwszVolumesList[nIndex],
            GUID_NULL, &(pSnapshotsArray[nIndex])));
        wprintf( L"OK\n");
    }

    wprintf (L"\n------------ Creating the snapshot -----------------\n");

    // Prepare for backup
    wprintf(L"Starting asynchronous PrepareForBackup. Please wait...\n");	
    HRESULT hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->PrepareForBackup(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));
	CHECK_NOFAIL((hr));
    wprintf(L"Asynchronous PrepareForBackup finished.\n");	

    // Gather writer status
    GatherWriterStatus(L"after PrepareForBackup");

    // Create the snapshot
    wprintf(L"\nStarting asynchronous DoSnapshotSet. Please wait...\n");	
    hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->DoSnapshotSet(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));
	CHECK_NOFAIL((hr));
    wprintf(L"Asynchronous DoSnapshotSet finished.\n");	

    // Gather writer status
    GatherWriterStatus(L"after DoSnapshotSet");

    wprintf(L"Snapshot set created\n");
    for (INT nIndex = 0; nIndex < m_nVolumesCount; nIndex++)
    {
        if (pSnapshotsArray[nIndex] == GUID_NULL)
            continue;
        VSS_SNAPSHOT_PROP prop;
        CHECK_SUCCESS(m_pBackupComponents->GetSnapshotProperties(pSnapshotsArray[nIndex], &prop));
        wprintf(L"\t- The snapshot on volume %s resides at %s\n",
            m_ppwszVolumesList[nIndex], prop.m_pwszSnapshotDeviceObject);
        ::VssFreeSnapshotProperties(&prop);
    }
}


void CVssSampleRequestor::BackupComplete()
{
	unsigned cWriterComponents;
	CComPtr<IVssAsync> pAsync;

    wprintf (L"\n------------ Completing backup phase ---------------\n");

	CHECK_SUCCESS(m_pBackupComponents->GetWriterComponentsCount(&cWriterComponents));

    // If component selection enabled,
    if (m_bComponentSelectionEnabled)
    {
		wprintf(L"Setting the succeeded state for the following components:\n");
        // For each component, mark the completion state as succeeded
    	for(unsigned iWriter = 0; iWriter < cWriterComponents; iWriter++)
        {
    	    CComPtr<IVssWriterComponentsExt> pWriter;
    	    CHECK_SUCCESS(m_pBackupComponents->GetWriterComponents(iWriter, &pWriter));

    	    unsigned cComponents;
    	    CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
    	    VSS_ID idWriter, idInstance;
    	    CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstance, &idWriter));
    	    for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
    		{
        		CComPtr<IVssComponent> pComponent;
        		CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
        				
        		VSS_COMPONENT_TYPE ct;
        		CComBSTR bstrLogicalPath;
        		CComBSTR bstrComponentName;

        		CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
        		CHECK_SUCCESS(pComponent->GetComponentType(&ct));
        		CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
        		wprintf(L"\t- %s\n", (LPWSTR)bstrComponentName);
        		
        		CHECK_SUCCESS(m_pBackupComponents->SetBackupSucceeded (idInstance,
        							idWriter,
        							ct,
        							bstrLogicalPath,
        							bstrComponentName,
        							true));
    		}
        }
		wprintf(L"\n");
    }

    // Save the XML file, if needed
    // The contents will be needed at restore, in the InitializeForRestore method.
    if (m_pXmlFile) {
    	CComBSTR bstrXML;
    	CHECK_SUCCESS(m_pBackupComponents->SaveAsXML(&bstrXML));
    	fwprintf( m_pXmlFile, L"%s", (WCHAR*)bstrXML);
        wprintf(L"XML results written in %s\n", m_pwszXmlFile);	
    }

	// Send the BackupComplete event
    wprintf(L"\nStarting asynchronous BackupComplete. Please wait...\n");	
    HRESULT hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->BackupComplete(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));
	CHECK_NOFAIL((hr));
    wprintf(L"Asynchronous BackupComplete finished.\n");	

    // Gather writer status
    GatherWriterStatus(L"after BackupComplete");
}


// Gather writera metadata and select components for backup, if needed
void CVssSampleRequestor::GatherWriterMetadata()
{
	unsigned cWriters;
	CComPtr<IVssAsync> pAsync;
	
    wprintf (L"\n---------- Gathering writer metadata ---------------\n");
	
    wprintf(L"Starting asynchronous GatherWriterMetadata. Please wait...\n");	
    HRESULT hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->GatherWriterMetadata(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));
	CHECK_NOFAIL((hr));
    wprintf(L"Asynchronous GatherWriterMetadata finished.\n");	
	
	CHECK_NOFAIL  (m_pBackupComponents->GetWriterMetadataCount (&cWriters));
    wprintf(L"Number of writers that responded: %u\n", cWriters);	
	
	for (unsigned iWriter = 0; iWriter < cWriters; iWriter++)
	{
		CComPtr<IVssExamineWriterMetadata> pMetadata;
		
		VSS_ID          idInstance;
		VSS_ID          idInstanceT;
		VSS_ID          idWriter;
		CComBSTR        bstrWriterName;
		VSS_USAGE_TYPE  usage;
		VSS_SOURCE_TYPE source;
		unsigned        cIncludeFiles, cExcludeFiles, cComponents;
		CComBSTR        bstrPath;
		CComBSTR        bstrFilespec;
		CComBSTR        bstrAlternate;
		CComBSTR        bstrDestination;
		
		CHECK_SUCCESS (m_pBackupComponents->GetWriterMetadata(iWriter, &idInstance, &pMetadata));
		
		CHECK_SUCCESS (pMetadata->GetIdentity (&idInstanceT,
			&idWriter,
			&bstrWriterName,
			&usage,
			&source));
		
		wprintf (L"\n*** WriterName = %s\n\n"
			L"    WriterId   = "WSTR_GUID_FMT L"\n"
			L"    InstanceId = "WSTR_GUID_FMT L"\n"
			L"    UsageType  = %d (%s)\n"
			L"    SourceType = %d (%s)\n",
			bstrWriterName,
			GUID_PRINTF_ARG(idWriter),
			GUID_PRINTF_ARG(idInstance),
			usage,
			GetStringFromUsageType (usage),
			source,
			GetStringFromSourceType (source));
		
		CHECK_SUCCESS(pMetadata->GetFileCounts (&cIncludeFiles,
			&cExcludeFiles,
			&cComponents));
		
		for(unsigned i = 0; i < cIncludeFiles; i++)
		{
			CComPtr<IVssWMFiledesc> pFiledesc;
			CHECK_SUCCESS (pMetadata->GetIncludeFile (i, &pFiledesc));
			PrintFiledesc(pFiledesc, L"\n    Include File");
		}
		
		
		for(i = 0; i < cExcludeFiles; i++)
		{
			CComPtr<IVssWMFiledesc> pFiledesc;
			CHECK_SUCCESS (pMetadata->GetExcludeFile (i, &pFiledesc));
			PrintFiledesc (pFiledesc, L"\n    Exclude File");
		}
		
		
		for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
			CComPtr<IVssWMComponent> pComponent;
			PVSSCOMPONENTINFO pInfo;
			
			CHECK_SUCCESS (pMetadata->GetComponent      (iComponent, &pComponent));
			CHECK_SUCCESS (pComponent->GetComponentInfo (&pInfo));
			
			wprintf (L"\n"
				L"    Component %d, type = %d (%s)\n"
				L"        LogicalPath = %s\n"
				L"        Name        = %s\n"
				L"        Caption     = %s\n",
				iComponent,
				pInfo->type,
				GetStringFromComponentType (pInfo->type),
				pInfo->bstrLogicalPath,
				pInfo->bstrComponentName,
				pInfo->bstrCaption);
			
			wprintf (L"        RestoreMetadata        = %s\n"
				L"        NotifyOnBackupComplete = %s\n"
				L"        Selectable             = %s\n",
				pInfo->bRestoreMetadata        ? L"yes" : L"no",
				pInfo->bNotifyOnBackupComplete ? L"yes" : L"no",
				pInfo->bSelectable             ? L"yes" : L"no");
			
            // If specified, add this component to the backup
            // Remark: A real backup app will first get from the user the list of components to be added
			if (m_bComponentSelectionEnabled) {
        		CHECK_SUCCESS(m_pBackupComponents->AddComponent(idInstance,
    						  idWriter,
    						  pInfo->type,
    						  pInfo->bstrLogicalPath,
    						  pInfo->bstrComponentName));
        		
    			wprintf (L"        [Component %d was added to the backup]\n", iComponent);
			}
			
			for(i = 0; i < pInfo->cFileCount; i++)
			{
				CComPtr<IVssWMFiledesc> pFiledesc;
				CHECK_SUCCESS (pComponent->GetFile (i, &pFiledesc));
				PrintFiledesc (pFiledesc, L"        FileGroupFile");

                // If we add the component, snapshot also the volume on which the file reside
				if (m_bComponentSelectionEnabled)
                    AddVolumeForComponent(pFiledesc);
			}
			
			for(i = 0; i < pInfo->cDatabases; i++)
			{
				CComPtr<IVssWMFiledesc> pFiledesc;
				CHECK_SUCCESS (pComponent->GetDatabaseFile (i, &pFiledesc));
				PrintFiledesc (pFiledesc, L"        DatabaseFile");
				
                // If we add the component, snapshot also the volume on which the file reside
				if (m_bComponentSelectionEnabled)
                    AddVolumeForComponent(pFiledesc);
				
			}
			
			
			for(i = 0; i < pInfo->cLogFiles; i++)
			{
				CComPtr<IVssWMFiledesc> pFiledesc;
				CHECK_SUCCESS (pComponent->GetDatabaseLogFile (i, &pFiledesc));
				PrintFiledesc (pFiledesc, L"        DatabaseLogFile");

                // If we add the component, snapshot also the volume on which the file reside
				if (m_bComponentSelectionEnabled)
                    AddVolumeForComponent(pFiledesc);
			}
			
			pComponent->FreeComponentInfo (pInfo);
		}
		
		VSS_RESTOREMETHOD_ENUM method;
		CComBSTR bstrUserProcedure;
		CComBSTR bstrService;
		VSS_WRITERRESTORE_ENUM writerRestore;
		unsigned cMappings;
		bool bRebootRequired;
		
		CHECK_NOFAIL (pMetadata->GetRestoreMethod (&method,
			&bstrService,
			&bstrUserProcedure,
			&writerRestore,
			&bRebootRequired,
			&cMappings));
		
		wprintf (L"\n"
			L"    Restore method = %d (%s)\n"
			L"    Service        = %d\n"
			L"    User Procedure = %s\n"
			L"    WriterRestore  = %d (%s)\n"
			L"    RebootRequired = %s\n",
			method,
			GetStringFromRestoreMethod (method),
			bstrService,
			bstrUserProcedure,
			writerRestore,
			GetStringFromWriterRestoreMethod (writerRestore),
			bRebootRequired ? L"yes" : L"no");
		
		for(i = 0; i < cMappings; i++)
		{
			CComPtr<IVssWMFiledesc> pFiledesc;
			CHECK_SUCCESS (pMetadata->GetAlternateLocationMapping (i, &pFiledesc));
			PrintFiledesc (pFiledesc, L"    AlternateMapping");
		}
	}
		
    // Gather writer status
    GatherWriterStatus(L"after GatherWriterMetadata");

	CHECK_SUCCESS (m_pBackupComponents->FreeWriterMetadata());
}


void CVssSampleRequestor::GatherWriterStatus(
    IN  LPCWSTR wszWhen
    )
{
    unsigned cWriters;
	CComPtr<IVssAsync> pAsync;

    wprintf (L"\nGathering writer status %s... ", wszWhen);
    HRESULT hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->GatherWriterStatus(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));
	CHECK_NOFAIL((hr));
	CHECK_NOFAIL(m_pBackupComponents->GetWriterStatusCount(&cWriters));
    wprintf (L"%d writers responded\n", cWriters);

    for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
	{
    	VSS_ID idInstance;
    	VSS_ID idWriter;
    	VSS_WRITER_STATE eWriterStatus;
    	CComBSTR bstrWriter;
    	HRESULT hrWriterFailure;

    	CHECK_SUCCESS(m_pBackupComponents->GetWriterStatus (iWriter,
    					     &idInstance,
    					     &idWriter,
    					     &bstrWriter,
    					     &eWriterStatus,
    					     &hrWriterFailure));

        WCHAR wszWriterFailure[MAX_TEXT_BUFFER];
        if (hrWriterFailure)
            swprintf(wszWriterFailure, L" Writer error code: %s [0x%08lx]",
                GetStringFromFailureType(hrWriterFailure), hrWriterFailure);
        else
            wszWriterFailure[0] = L'\0';

    	wprintf (L"\t- %s status for writer '%s'. %s\n",
    		 GetStringFromWriterStatus(eWriterStatus), bstrWriter, wszWriterFailure);
    }

    m_pBackupComponents->FreeWriterStatus();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\betest\cwriter.h ===
//
//  ATL debugging support turned on at debug version
//  BUGBUG: the ATL thunking support is not enable yet in IA64
//  When this will be enabled then enable it here also!
//
#ifdef _DEBUG
#ifdef _M_IX86
#define _ATL_DEBUG_INTERFACES
#define _ATL_DEBUG_QI
#define _ATL_DEBUG_REFCOUNT
#endif
#endif // _DEBUG

class CTestVssWriter : public CVssWriter
	{
public:
	CTestVssWriter(LONG lWait) : m_lWait(lWait)
		{
		}



	void Initialize();

	virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);

	virtual bool STDMETHODCALLTYPE OnPrepareBackup(IN IVssWriterComponents *pComponent);

	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot();

	virtual bool STDMETHODCALLTYPE OnFreeze();

	virtual bool STDMETHODCALLTYPE OnThaw();

	virtual bool STDMETHODCALLTYPE OnAbort();
    virtual bool STDMETHODCALLTYPE OnPostSnapshot(IN IVssWriterComponents *pComponent);


	virtual bool STDMETHODCALLTYPE OnBackupComplete(IN IVssWriterComponents *pComponent);

	virtual bool STDMETHODCALLTYPE OnPreRestore(IN IVssWriterComponents *pComponent);
	
	virtual bool STDMETHODCALLTYPE OnPostRestore(IN IVssWriterComponents *pComponent);
private:
	enum
		{
		x_bitWaitIdentify = 1,
		x_bitWaitPrepareForBackup = 2,
		x_bitWaitPostSnapshot = 4,
		x_bitWaitBackupComplete = 8,
		x_bitWaitPreRestore = 16,
		x_bitWaitPostRestore = 32,
		x_bitWaitPrepareSnapshot = 64,
		x_bitWaitFreeze = 128,
		x_bitWaitThaw = 256,
		x_bitWaitAbort = 512
		};

    LONG m_lWait;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\betest\compont.h ===
#ifndef _COMPONTH_
#define _COMPONTH_

#include "vs_hash.hxx"

class CWriterComponentsSelection
{
public:
	// Construction Destruction
	CWriterComponentsSelection();
	~CWriterComponentsSelection();

	// methods
	void SetWriter
		(
		IN VSS_ID WriterId
		);
	
	HRESULT	AddSelectedComponent
		(
		IN WCHAR* pwszComponentLogicalPath
		);

	BOOL IsComponentSelected
		(
		IN WCHAR* pwszComponentLogicalPath,
		IN WCHAR* pwszComponentName
		);
	
	
private:
	// Data members
	VSS_ID 			    m_WriterId;
    UINT                m_uNumComponents;
	WCHAR**				m_ppwszComponentLogicalPathes;
	
};


class CWritersSelection :
	public IUnknown            // Must be the FIRST base class since we use CComPtr<CVssSnapshotSetObject>

{
protected:
	// Construction Destruction
	CWritersSelection();
	~CWritersSelection();
	
public:
	// Creation
	static CWritersSelection* CreateInstance();

	// Chosen writers & components management
	STDMETHOD(BuildChosenComponents)
		(
		WCHAR *pwszComponentsFileName
		);
	
	BOOL IsComponentSelected
		(
		IN VSS_ID WriterId,
		IN WCHAR* pwszComponentLogicalPath,
		IN WCHAR* pwszComponentName
		);

	// IUnknown
	STDMETHOD(QueryInterface)(REFIID iid, void** pp);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	
private:
	// Chosen writers
	CVssSimpleMap<VSS_ID, CWriterComponentsSelection*> m_WritersMap;
	
    // For life management
	LONG 	m_lRef;
};

#endif	// _COMPONTH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\betest\cwriter.cpp ===
#include "stdafx.hxx"
#include "vss.h"
#include "vswriter.h"
#include "cwriter.h"
#include "debug.h"
#include "time.h"
#include "msxml.h"

#define IID_PPV_ARG( Type, Expr ) IID_##Type, reinterpret_cast< void** >( static_cast< Type** >( Expr ) )
#define SafeQI( Type, Expr ) QueryInterface( IID_PPV_ARG( Type, Expr ) )

static BYTE x_rgbIcon[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
static unsigned x_cbIcon = 10;


static VSS_ID s_WRITERID =
	{
	0xc0577ae6, 0xd741, 0x452a,
	0x8c, 0xba, 0x99, 0xd7, 0x44, 0x00, 0x8c, 0x04
	};

static LPCWSTR s_WRITERNAME = L"BeTest Writer";

void CTestVssWriter::Initialize()
	{
	HRESULT hr;

	CHECK_SUCCESS(CVssWriter::Initialize
					(
					s_WRITERID,
					s_WRITERNAME,
					VSS_UT_USERDATA,
					VSS_ST_OTHER
					));
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
	{
	HRESULT hr;

 	if (m_lWait & x_bitWaitIdentify)
		{
		wprintf(L"\nWaiting 30 seconds in OnIdentify.\n\n");
		Sleep(30000);
		}

	wprintf(L"\n\n***OnIdentify***\n");

	CHECK_SUCCESS(pMetadata->AddIncludeFiles
					(
					L"%systemroot%\\config",
					L"mytestfiles.*",
					false,
					NULL
					));

    CHECK_SUCCESS(pMetadata->AddExcludeFiles
						(
						L"%systemroot%\\config",
						L"*.tmp",
						true
						));

    CHECK_SUCCESS(pMetadata->AddComponent
						(
						VSS_CT_DATABASE,
						L"\\mydatabases",
						L"db1",
						L"this is my main database",
						x_rgbIcon,
						x_cbIcon,
						true,
						true,
						true
						));

    CHECK_SUCCESS(pMetadata->AddDatabaseFiles
					(
					L"\\mydatabases",
					L"db1",
					L"e:\\databases",
					L"foo1.db"
					));

    CHECK_SUCCESS(pMetadata->AddDatabaseFiles
					(
					L"\\mydatabases",
					L"db1",
					L"e:\\databases",
					L"foo2.db"
					));


    CHECK_SUCCESS(pMetadata->AddDatabaseLogFiles
					(
					L"\\mydatabases",
					L"db1",
					L"e:\\logs",
					L"foo.log"
					));

    CHECK_SUCCESS(pMetadata->SetRestoreMethod
					(
					VSS_RME_RESTORE_IF_NOT_THERE,
					NULL,
					NULL,
					VSS_WRE_ALWAYS,
					true
					));

    CHECK_SUCCESS(pMetadata->AddAlternateLocationMapping
					(
					L"c:\\databases",
					L"*.db",
					false,
					L"e:\\databases\\restore"
					));

    CHECK_SUCCESS(pMetadata->AddAlternateLocationMapping
					(
					L"d:\\logs",
					L"*.log",
					false,
					L"e:\\databases\\restore"
					));


	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnPrepareBackup(IN IVssWriterComponents *pWriterComponents)
	{
	if (m_lWait & x_bitWaitPrepareForBackup)
		{
		wprintf(L"\nWaiting 10 seconds in PrepareForBackup.\n\n");
		Sleep(10000);
		}

	unsigned cComponents;
	LPCWSTR wszBackupType;
	switch(GetBackupType())
		{
		default:
			wszBackupType = L"undefined";
			break;

		case VSS_BT_FULL:
			wszBackupType = L"full";
			break;

        case VSS_BT_INCREMENTAL:
			wszBackupType = L"incremental";
			break;

        case VSS_BT_DIFFERENTIAL:
			wszBackupType = L"differential";
			break;

        case VSS_BT_OTHER:
			wszBackupType = L"other";
			break;
		}

	wprintf(L"\n\n***OnPrepareBackup****\nBackup Type = %s\n", wszBackupType);

	wprintf
		(
		L"AreComponentsSelected = %s\n",
		AreComponentsSelected() ? L"yes" : L"no"
		);

	wprintf
		(
		L"BootableSystemStateBackup = %s\n\n",
		IsBootableSystemStateBackedUp() ? L"yes" : L"no"
		);

	pWriterComponents->GetComponentCount(&cComponents);
	for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
		HRESULT hr;

		CComPtr<IVssComponent> pComponent;
		VSS_COMPONENT_TYPE ct;
		CComBSTR bstrLogicalPath;
		CComBSTR bstrComponentName;


		CHECK_SUCCESS(pWriterComponents->GetComponent(iComponent, &pComponent));
		CHECK_SUCCESS(pComponent->GetLogicalPath(&bstrLogicalPath));
		CHECK_SUCCESS(pComponent->GetComponentType(&ct));
		CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
		if (ct != VSS_CT_DATABASE)
			{
			wprintf(L"component type is incorrect\n");
			DebugBreak();
			}

		wprintf
			(
			L"Backing up database %s\\%s.\n",
			bstrLogicalPath,
			bstrComponentName
			);


		WCHAR buf[100];
		wsprintf (buf, L"backupTime = %d\n", (INT) time(NULL));

		CHECK_SUCCESS(pComponent->SetBackupMetadata(buf));
		wprintf(L"\nBackupMetadata=%s\n", buf);

		CComBSTR bstrPreviousStamp;
		CHECK_NOFAIL(pComponent->GetPreviousBackupStamp(&bstrPreviousStamp));
		if (bstrPreviousStamp)
			wprintf(L"Previous stamp = %s\n", bstrPreviousStamp);

		CComBSTR bstrBackupOptions;
		CHECK_NOFAIL(pComponent->GetBackupOptions(&bstrBackupOptions));
		if (bstrBackupOptions)
			wprintf(L"Backup options = %s\n", bstrBackupOptions);

		WCHAR wszBackupStamp[32];
		swprintf(wszBackupStamp, L"B-%d-", clock());
		CHECK_SUCCESS(pComponent->SetBackupStamp(wszBackupStamp));
		wprintf(L"Backup stamp = %s\n\n", wszBackupStamp);
		}

	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnPrepareSnapshot()
	{
	if (m_lWait & x_bitWaitPrepareSnapshot)
		{
		wprintf(L"\nWaiting 10 seconds in PrepareSnapshot.\n\n");
		Sleep(10000);
		}

	wprintf(L"\n\n***OnPrepareSnapshot***\n");
	IsPathAffected(L"e:\\foobar");
	return true;
	}


bool STDMETHODCALLTYPE CTestVssWriter::OnFreeze()
	{
	if (m_lWait & x_bitWaitFreeze)
		{
		wprintf(L"\nWaiting 10 seconds in Freeze.\n\n");
		Sleep(10000);
		}

	wprintf(L"\n\n***OnFreeze***\n");
	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnThaw()
	{
	if (m_lWait & x_bitWaitThaw)
		{
		wprintf(L"\nWaiting 10 seconds in PrepareThaw.\n\n");
		Sleep(10000);
		}

	wprintf(L"\n\n***OnThaw***\n");
	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnBackupComplete(IN IVssWriterComponents *pWriterComponents)
	{
	if (m_lWait & x_bitWaitBackupComplete)
		{
		wprintf(L"\nWaiting 30 seconds in BackupComplete.\n\n");
		Sleep(30000);
		}

	wprintf(L"\n\n***OnBackupComplete***\n");
	unsigned cComponents;
	pWriterComponents->GetComponentCount(&cComponents);
	for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
		HRESULT hr;

		CComPtr<IVssComponent> pComponent;
		VSS_COMPONENT_TYPE ct;
		CComBSTR bstrLogicalPath;
		CComBSTR bstrComponentName;
		bool bBackupSucceeded;

		CHECK_SUCCESS(pWriterComponents->GetComponent(iComponent, &pComponent));
		CHECK_SUCCESS(pComponent->GetLogicalPath(&bstrLogicalPath));
		CHECK_SUCCESS(pComponent->GetComponentType(&ct));
		CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
		CHECK_SUCCESS(pComponent->GetBackupSucceeded(&bBackupSucceeded));
		if (ct != VSS_CT_DATABASE)
			{
			wprintf(L"component type is incorrect\n");
			DebugBreak();
			}

		wprintf
			(
			L"Database %s\\%s backup %s.\n",
			bstrLogicalPath,
			bstrComponentName,
			bBackupSucceeded ? L"succeeded" : L"failed"
			);

		CComBSTR bstrMetadata;
		CHECK_SUCCESS(pComponent->GetBackupMetadata(&bstrMetadata));
		wprintf(L"backupMetadata=%s\n", bstrMetadata);
		}

	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnPreRestore(IN IVssWriterComponents *pWriter)
	{
	if (m_lWait & x_bitWaitPreRestore)
		{
		wprintf(L"\nWaiting 10 seconds in PreRestore.\n\n");
		Sleep(10000);
		}

	HRESULT hr;

	wprintf(L"\n\n***OnPreRestore***\n");

	UINT cComponents;
	CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
	for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
		{
		CComPtr<IVssComponent> pComponent;

		CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));

		PrintRestoreSubcomponents(pComponent);

		CComBSTR bstrBackupMetadata;
		CHECK_NOFAIL(pComponent->GetBackupMetadata(&bstrBackupMetadata));

		if (bstrBackupMetadata)
			wprintf(L"BackupMetadata=%s\n", bstrBackupMetadata);

		WCHAR buf[100];
		wsprintf (buf, L"restoreTime = %d", (INT) time(NULL));

		CHECK_SUCCESS(pComponent->SetRestoreMetadata(buf));
		wprintf(L"\nRestoreMetadata=%s\n", buf);

		CComBSTR bstrRestoreOptions;
		bool bAdditionalRestores;
		bool bSelectedForRestore;
		CHECK_SUCCESS(pComponent->GetAdditionalRestores(&bAdditionalRestores));
		CHECK_SUCCESS(pComponent->IsSelectedForRestore(&bSelectedForRestore));
		CHECK_NOFAIL(pComponent->GetRestoreOptions(&bstrRestoreOptions));
		wprintf(L"SelectedForRestore=%s\n", bSelectedForRestore ? L"Yes" : L"No");
		wprintf(L"Additional restores=%s\n", bAdditionalRestores ? L"Yes" : L"No");
		if (bstrRestoreOptions)
			wprintf(L"Restore options=%s\n", bstrRestoreOptions);

		ULONG type = clock() % 47;
		VSS_RESTORE_TARGET rt;

		if (type < 15)
			rt = VSS_RT_NEW;
		else if (type >= 15 && type < 30 && IsPartialFileSupportEnabled())
			rt = VSS_RT_DIRECTED;
		else if (type >= 30 && type < 40)
			rt = VSS_RT_ORIGINAL;
		else
			rt = VSS_RT_ALTERNATE;

		wprintf(L"restore target = %s\n", WszFromRestoreTarget(rt));
		CHECK_SUCCESS(pComponent->SetRestoreTarget(rt));
		if (rt == VSS_RT_NEW)
			{
			CHECK_SUCCESS(pComponent->AddNewTarget
								(
								L"e:\\databases",
								L"foo1.db",
								false,
								L"e:\\newdatabases"
								));

			CHECK_SUCCESS(pComponent->AddNewTarget
								(
								L"e:\\databases",
								L"foo2.db",
								false,
								L"e:\\newdatabases"
								));

			PrintNewTargets(pComponent);
			}
		else if (rt == VSS_RT_DIRECTED)
			{
			CHECK_SUCCESS(pComponent->AddDirectedTarget
								(
								L"e:\\databases",
								L"foo1.db",
								L"0x8000:0x10000",
								L"e:\\newdatabases",
								L"copy1.db",
								L"0x0000:0x10000"
								));

			CHECK_SUCCESS(pComponent->AddDirectedTarget
								(
								L"e:\\databases",
								L"foo2.db",
								L"0x4000:0x1000",
								L"e:\\newdatabases",
								L"copy1.db",
								L"0x0000:0x1000"
								));

			PrintDirectedTargets(pComponent);
			}

		wprintf(L"\n");

		CHECK_SUCCESS(pComponent->SetPreRestoreFailureMsg(L"PreRestore Successfully Completed."));
		}

	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnPostRestore(IN IVssWriterComponents *pWriter)
	{
	if (m_lWait & x_bitWaitPostRestore)
		{
		wprintf(L"\nWaiting 10 seconds in PostRestore.\n\n");
		Sleep(10000);
		}

	HRESULT hr;

	wprintf(L"\n\n***OnPostRestore***\n");

	UINT cComponents;
	CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
	for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
		{
		CComPtr<IVssComponent> pComponent;

		CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));

		VSS_RESTORE_TARGET rt;
		CHECK_SUCCESS(pComponent->GetRestoreTarget(&rt));
		wprintf(L"RestoreTarget = %s\n", WszFromRestoreTarget(rt));
		if (rt == VSS_RT_NEW)
			PrintNewTargets(pComponent);
		else if (rt == VSS_RT_DIRECTED)
			PrintDirectedTargets(pComponent);

		VSS_FILE_RESTORE_STATUS rs;
		CHECK_SUCCESS(pComponent->GetFileRestoreStatus(&rs));
		wprintf(L"RestoreStatus = %s\n", WszFromFileRestoreStatus(rs));

		CComBSTR bstrRestoreMetadata;
		CComBSTR bstrBackupMetadata;
		CHECK_NOFAIL(pComponent->GetRestoreMetadata(&bstrRestoreMetadata));
		CHECK_NOFAIL(pComponent->GetBackupMetadata(&bstrBackupMetadata));
		if (bstrRestoreMetadata)
			wprintf(L"RestoreMetadata=%s\n", bstrRestoreMetadata);

		if (bstrBackupMetadata)
			wprintf(L"BackupMetadata=%s\n", bstrBackupMetadata);
		
		wprintf(L"\n");

		CHECK_SUCCESS(pComponent->SetPostRestoreFailureMsg(L"PostRestore Successfully Completed."));
		}

	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnAbort()
	{
	if (m_lWait & x_bitWaitAbort)
		{
		wprintf(L"\nWaiting 10 seconds in Abort.\n\n");
		Sleep(10000);
		}

	wprintf(L"\n\n***OnAbort***\n\n");
	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnPostSnapshot
	(
	IN IVssWriterComponents *pWriter
	)
	{
	if (m_lWait & x_bitWaitPostSnapshot)
		{
		wprintf(L"\nWaiting 10 seconds in PostSnapshot.\n\n");
		Sleep(10000);
		}

	HRESULT hr;
	wprintf(L"\n\n***OnPostSnapshot***\n\n");


	if (IsPartialFileSupportEnabled() &&
		GetBackupType() == VSS_BT_DIFFERENTIAL)
		{
		UINT cComponents;

		CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));

		for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
			{
			CComPtr<IVssComponent> pComponent;

			CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
			VSS_COMPONENT_TYPE ct;
			CHECK_SUCCESS(pComponent->GetComponentType(&ct));
			if (ct == VSS_CT_DATABASE)
				{
				CHECK_SUCCESS(pComponent->AddPartialFile
									(	
									L"e:\\databases",
									L"foo1.db",
									L"0x8000:0x10000, 0x100000:0x2000",
									L"Length=0x200000"
									));

				CHECK_SUCCESS(pComponent->AddPartialFile
								(	
								L"e:\\databases",
								L"foo2.db",
								L"0x4000:0x1000",
								L"Length=0x100000"
								));
				}

			PrintPartialFiles(pComponent);
			}

		}

	return true;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\betest\debug.h ===
// Execute the given call and check that the return code must be S_OK
#define CHECK_SUCCESS( Call )                                                                           \
    {                                                                                                   \
        hr = Call;                                                                                    \
        if (hr != S_OK)                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }

#define CHECK_NOFAIL( Call )                                                                            \
    {                                                                                                   \
        hr = Call;                                                                                    \
        if (FAILED(hr))                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }



void Error(INT nReturnCode, const WCHAR* pwszMsgFormat, ...);
LPCWSTR GetStringFromFailureType(HRESULT hrStatus);
LPCWSTR WszFromRestoreTarget(VSS_RESTORE_TARGET rt);
LPCWSTR WszFromFileRestoreStatus(VSS_FILE_RESTORE_STATUS rs);
void PrintPartialFiles(IVssComponent *pComponent);
void PrintNewTargets(IVssComponent *pComponent);
void PrintDirectedTargets(IVssComponent *pComponent);
void PrintRestoreSubcomponents(IVssComponent *pComponent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\betest\debug.cpp ===
#include "stdafx.hxx"
#include "vss.h"
#include "vswriter.h"
#include "vsbackup.h"
#include <debug.h>
#include <cwriter.h>
#include <lmshare.h>
#include <lmaccess.h>


LPCWSTR GetStringFromFailureType(HRESULT hrStatus)
{
    LPCWSTR pwszFailureType = L"";

    switch (hrStatus)
	{
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:        pwszFailureType = L"VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT";    break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:              pwszFailureType = L"VSS_E_WRITERERROR_OUTOFRESOURCES";          break;
	case VSS_E_WRITERERROR_TIMEOUT:                     pwszFailureType = L"VSS_E_WRITERERROR_TIMEOUT";                 break;
	case VSS_E_WRITERERROR_NONRETRYABLE:                pwszFailureType = L"VSS_E_WRITERERROR_NONRETRYABLE";            break;
	case VSS_E_WRITERERROR_RETRYABLE:                   pwszFailureType = L"VSS_E_WRITERERROR_RETRYABLE";               break;
	case VSS_E_BAD_STATE:                               pwszFailureType = L"VSS_E_BAD_STATE";                           break;
	case VSS_E_PROVIDER_ALREADY_REGISTERED:             pwszFailureType = L"VSS_E_PROVIDER_ALREADY_REGISTERED";         break;
	case VSS_E_PROVIDER_NOT_REGISTERED:                 pwszFailureType = L"VSS_E_PROVIDER_NOT_REGISTERED";             break;
	case VSS_E_PROVIDER_VETO:                           pwszFailureType = L"VSS_E_PROVIDER_VETO";                       break;
	case VSS_E_PROVIDER_IN_USE:				            pwszFailureType = L"VSS_E_PROVIDER_IN_USE";                     break;
	case VSS_E_OBJECT_NOT_FOUND:						pwszFailureType = L"VSS_E_OBJECT_NOT_FOUND";                    break;						
	case VSS_S_ASYNC_PENDING:							pwszFailureType = L"VSS_S_ASYNC_PENDING";                       break;
	case VSS_S_ASYNC_FINISHED:						    pwszFailureType = L"VSS_S_ASYNC_FINISHED";                      break;
	case VSS_S_ASYNC_CANCELLED:						    pwszFailureType = L"VSS_S_ASYNC_CANCELLED";                     break;
	case VSS_E_VOLUME_NOT_SUPPORTED:					pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED";                break;
	case VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER:		pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER";    break;
	case VSS_E_OBJECT_ALREADY_EXISTS:					pwszFailureType = L"VSS_E_OBJECT_ALREADY_EXISTS";               break;
	case VSS_E_UNEXPECTED_PROVIDER_ERROR:				pwszFailureType = L"VSS_E_UNEXPECTED_PROVIDER_ERROR";           break;
	case VSS_E_CORRUPT_XML_DOCUMENT:				    pwszFailureType = L"VSS_E_CORRUPT_XML_DOCUMENT";                break;
	case VSS_E_INVALID_XML_DOCUMENT:					pwszFailureType = L"VSS_E_INVALID_XML_DOCUMENT";                break;
	case VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED:       pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED";   break;
	case VSS_E_FLUSH_WRITES_TIMEOUT:                    pwszFailureType = L"VSS_E_FLUSH_WRITES_TIMEOUT";                break;
	case VSS_E_HOLD_WRITES_TIMEOUT:                     pwszFailureType = L"VSS_E_HOLD_WRITES_TIMEOUT";                 break;
	case VSS_E_UNEXPECTED_WRITER_ERROR:                 pwszFailureType = L"VSS_E_UNEXPECTED_WRITER_ERROR";             break;
	case VSS_E_SNAPSHOT_SET_IN_PROGRESS:                pwszFailureType = L"VSS_E_SNAPSHOT_SET_IN_PROGRESS";            break;
	case VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED:     pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED"; break;
	case VSS_E_WRITER_INFRASTRUCTURE:	 		        pwszFailureType = L"VSS_E_WRITER_INFRASTRUCTURE";               break;
	case VSS_E_WRITER_NOT_RESPONDING:			        pwszFailureType = L"VSS_E_WRITER_NOT_RESPONDING";               break;
    case VSS_E_WRITER_ALREADY_SUBSCRIBED:		        pwszFailureType = L"VSS_E_WRITER_ALREADY_SUBSCRIBED";           break;
	
	case NOERROR:
	default:
	    break;
	}

    return (pwszFailureType);
}


// This function displays the formatted message at the console and throws
// The passed return code will be returned by vsreq.exe
void Error(
    IN  INT nReturnCode,
    IN  const WCHAR* pwszMsgFormat,
    IN  ...
    )
{
    va_list marker;
    va_start( marker, pwszMsgFormat );
    vwprintf( pwszMsgFormat, marker );
    va_end( marker );

	BS_ASSERT(FALSE);
    // throw that return code.
    throw(nReturnCode);
}

// convert VSS_RESTORE_TARGET to string
LPCWSTR WszFromRestoreTarget
	(
	IN VSS_RESTORE_TARGET rt
	)
	{
	switch(rt)
		{
        default:
			return L"Undefined";

        case VSS_RT_ORIGINAL:
			return L"Original";

		case VSS_RT_ALTERNATE:
            return L"Alternate";

		case VSS_RT_NEW:
            return L"New";

        case VSS_RT_DIRECTED:
			return L"Directed";
        }
	}

// convert VSS_FILE_RESTORE_STATUS to string
LPCWSTR WszFromFileRestoreStatus
	(
	IN VSS_FILE_RESTORE_STATUS rs
	)
	{
	switch(rs)
		{
		default:
			return L"Undefined";

        case VSS_RS_NONE:
			return L"None";

		case VSS_RS_ALL:
            return L"All";

		case VSS_RS_FAILED:
            return L"Failed";
        }
	}

void PrintPartialFiles(IVssComponent *pComponent)
	{
	UINT cPartialFiles;
	HRESULT hr;

	CHECK_SUCCESS(pComponent->GetPartialFileCount(&cPartialFiles));
	if (cPartialFiles > 0)
		wprintf(L"\n%d Partial Files:\n\n", cPartialFiles);

	for(UINT iFile = 0; iFile < cPartialFiles; iFile++)
		{
		CComBSTR bstrPath;
		CComBSTR bstrFilename;
		CComBSTR bstrRanges;
		CComBSTR bstrMetadata;

		CHECK_SUCCESS(pComponent->GetPartialFile
							(
							iFile,
							&bstrPath,
							&bstrFilename,
							&bstrRanges,
							&bstrMetadata
							));

        wprintf(L"Path=%s, Name=%s\nRanges=%s\nMetadata=%s\n\n",
				bstrPath, bstrFilename, bstrRanges, bstrMetadata);

        }
	}

void PrintNewTargets(IVssComponent *pComponent)
	{
	UINT cTarget;
	HRESULT hr;

	CHECK_SUCCESS(pComponent->GetNewTargetCount(&cTarget));
	if (cTarget > 0)
		wprintf(L"\n%d Restore Targets:\n\n", cTarget);

	for(UINT iTarget = 0; iTarget < cTarget; iTarget++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;
		CHECK_SUCCESS(pComponent->GetNewTarget(iTarget, &pFiledesc));

        CComBSTR bstrPath;
		CComBSTR bstrFilespec;
		CComBSTR bstrAlternate;
		bool bRecursive;


		CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
		CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
		CHECK_NOFAIL(pFiledesc->GetRecursive(&bRecursive));
		CHECK_NOFAIL(pFiledesc->GetAlternateLocation(&bstrAlternate));
		wprintf(L"Path=%s, Name=%s\nRecursive=%s\nAlternatePath=%s\n\n",
				bstrPath,
				bstrFilespec,
				bRecursive ? L"yes" : L"no",
				bstrAlternate);
        }
	}

void PrintDirectedTargets(IVssComponent *pComponent)
	{
	UINT cTarget;
	HRESULT hr;

	CHECK_SUCCESS(pComponent->GetDirectedTargetCount(&cTarget));
	if (cTarget > 0)
		wprintf(L"\n%d Directed Targets:\n\n", cTarget);

	for(UINT iTarget = 0; iTarget < cTarget; iTarget++)
		{
		CComBSTR bstrSourcePath;
		CComBSTR bstrSourceFilespec;
		CComBSTR bstrSourceRanges;
		CComBSTR bstrTargetPath;
		CComBSTR bstrTargetFilespec;
		CComBSTR bstrTargetRanges;


		CHECK_SUCCESS(pComponent->GetDirectedTarget
			(
			iTarget,
			&bstrSourcePath,
			&bstrSourceFilespec,
			&bstrSourceRanges,
			&bstrTargetPath,
			&bstrTargetFilespec,
			&bstrTargetRanges
			));

		wprintf(L"Source Path=%s, Name=%s\nRanges=%s\nTarget Path=%s, Name=%s\nRanges=%s\n",
				bstrSourcePath,
				bstrSourceFilespec,
				bstrSourceRanges,
				bstrTargetPath,
				bstrTargetFilespec,
				bstrTargetRanges);
        }
	}


void PrintRestoreSubcomponents(IVssComponent *pComponent)
	{
	UINT cSub;
	HRESULT hr;

	CHECK_SUCCESS(pComponent->GetRestoreSubcomponentCount(&cSub));
	if (cSub > 0)
		wprintf(L"\n%d Restore Subcomponents:\n\n", cSub);

	for(UINT iSub = 0; iSub < cSub; iSub++)
		{
		CComBSTR bstrLogicalPath;
		CComBSTR bstrComponentName;
		bool bRepair;


		CHECK_SUCCESS(pComponent->GetRestoreSubcomponent
			(
			iSub,
			&bstrLogicalPath,
			&bstrComponentName,
			&bRepair
			));

		wprintf(L"Logical Path=%s, Name=%s, Repair=%s\n",
				bstrLogicalPath,
				bstrComponentName,
				bRepair ? L"Yes" : L"No");
        }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\betest\main.cpp ===
#include "stdafx.hxx"
#include "vs_idl.hxx"
#include "vswriter.h"
#include "vsbackup.h"
#include "compont.h"
#include <debug.h>
#include <cwriter.h>
#include <lmshare.h>
#include <lmaccess.h>
#include <time.h>


// Globals
BOOL g_bBackupOnly = FALSE;
BOOL g_bRestoreOnly = FALSE;
WCHAR g_wszBackupDocumentFileName[MAX_PATH];
WCHAR g_wszComponentsFileName[MAX_PATH];
LONG g_lWriterWait = 0;

CComPtr<CWritersSelection>	g_pWriterSelection;

void TestSnapshotXML();
void EnumVolumes();

// forward declarations
void CheckStatus(IVssBackupComponents *pvbc, LPCWSTR wszWhen);
HRESULT ParseCommnadLine (int argc, WCHAR **argv);
BOOL SaveBackupDocument(CComBSTR &bstr);
BOOL LoadBackupDocument(CComBSTR &bstr);

BOOL AssertPrivilege( LPCWSTR privName )
    {
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if ( OpenProcessToken (GetCurrentProcess(),
			   TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,
			   &tokenHandle))
	{
	LUID value;

	if ( LookupPrivilegeValue( NULL, privName, &value ) )
	    {
	    TOKEN_PRIVILEGES newState;
	    DWORD            error;

	    newState.PrivilegeCount           = 1;
	    newState.Privileges[0].Luid       = value;
	    newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED;

	    /*
	     * We will always call GetLastError below, so clear
	     * any prior error values on this thread.
	     */
	    SetLastError( ERROR_SUCCESS );

	    stat = AdjustTokenPrivileges (tokenHandle,
					  FALSE,
					  &newState,
					  (DWORD)0,
					  NULL,
					  NULL );

	    /*
	     * Supposedly, AdjustTokenPriveleges always returns TRUE
	     * (even when it fails). So, call GetLastError to be
	     * extra sure everything's cool.
	     */
	    if ( (error = GetLastError()) != ERROR_SUCCESS )
		{
		stat = FALSE;
		}

	    if ( !stat )
		{
		wprintf( L"AdjustTokenPrivileges for %s failed with %d",
			 privName,
			 error );
		}
	    }

	DWORD cbTokens;
	GetTokenInformation (tokenHandle,
			     TokenPrivileges,
			     NULL,
			     0,
			     &cbTokens);

	TOKEN_PRIVILEGES *pTokens = (TOKEN_PRIVILEGES *) new BYTE[cbTokens];
	GetTokenInformation (tokenHandle,
			     TokenPrivileges,
			     pTokens,
			     cbTokens,
			     &cbTokens);

	delete pTokens;
	CloseHandle( tokenHandle );
	}


    return stat;
    }


LPCWSTR GetStringFromUsageType (VSS_USAGE_TYPE eUsageType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eUsageType)
	{
	case VSS_UT_BOOTABLESYSTEMSTATE: pwszRetString = L"BootableSystemState"; break;
	case VSS_UT_SYSTEMSERVICE:       pwszRetString = L"SystemService";       break;
	case VSS_UT_USERDATA:            pwszRetString = L"UserData";            break;
	case VSS_UT_OTHER:               pwszRetString = L"Other";               break;
					
	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eSourceType)
	{
	case VSS_ST_TRANSACTEDDB:    pwszRetString = L"TransactionDb";    break;
	case VSS_ST_NONTRANSACTEDDB: pwszRetString = L"NonTransactionDb"; break;
	case VSS_ST_OTHER:           pwszRetString = L"Other";            break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromRestoreMethod (VSS_RESTOREMETHOD_ENUM eRestoreMethod)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eRestoreMethod)
	{
	case VSS_RME_RESTORE_IF_NOT_THERE:          pwszRetString = L"RestoreIfNotThere";          break;
	case VSS_RME_RESTORE_IF_CAN_REPLACE:        pwszRetString = L"RestoreIfCanReplace";        break;
	case VSS_RME_STOP_RESTORE_START:            pwszRetString = L"StopRestoreStart";           break;
	case VSS_RME_RESTORE_TO_ALTERNATE_LOCATION: pwszRetString = L"RestoreToAlternateLocation"; break;
	case VSS_RME_RESTORE_AT_REBOOT:             pwszRetString = L"RestoreAtReboot";            break;
	case VSS_RME_CUSTOM:                        pwszRetString = L"Custom";                     break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromWriterRestoreMethod (VSS_WRITERRESTORE_ENUM eWriterRestoreMethod)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eWriterRestoreMethod)
	{
	case VSS_WRE_NEVER:            pwszRetString = L"RestoreNever";           break;
	case VSS_WRE_IF_REPLACE_FAILS: pwszRetString = L"RestoreIfReplaceFailsI"; break;
	case VSS_WRE_ALWAYS:           pwszRetString = L"RestoreAlways";          break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eComponentType)
	{
	case VSS_CT_DATABASE:  pwszRetString = L"Database";  break;
	case VSS_CT_FILEGROUP: pwszRetString = L"FileGroup"; break;

	default:
	    break;
	}


    return (pwszRetString);
    }




void PrintFiledesc(IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription)
    {
    CComBSTR bstrPath;
    CComBSTR bstrFilespec;
    CComBSTR bstrAlternate;
    CComBSTR bstrDestination;
    bool bRecursive;
	HRESULT hr;

    CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
    CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
    CHECK_NOFAIL(pFiledesc->GetRecursive(&bRecursive));
    CHECK_NOFAIL(pFiledesc->GetAlternateLocation(&bstrAlternate));

    wprintf (L"%s\n            Path = %s, Filespec = %s, Recursive = %s\n",
	     wszDescription,
	     bstrPath,
	     bstrFilespec,
	     bRecursive ? L"yes" : L"no");

    if (bstrAlternate && wcslen(bstrAlternate) > 0)
	wprintf(L"            Alternate Location = %s\n", bstrAlternate);
    }


/*
void AddShares(IVssSnapshot **rgpSnapshot, UINT cSnapshot)
	{
	VSS_PWSZ wszDeviceName = NULL;

	try
		{
		for(UINT iSnapshot = 0; iSnapshot < cSnapshot; iSnapshot++)
			{
			SHARE_INFO_502 info;
			CHECK_SUCCESS(rgpSnapshot[iSnapshot]->GetDevice(&wszDeviceName));
			WCHAR *wszPath = new WCHAR[wcslen(wszDeviceName) + 2];
			if (wszPath != NULL)
				{
				wcscpy(wszPath, wszDeviceName);
				wcscat(wszPath, L"\\");
				memset(&info, 0, sizeof(info));
				WCHAR wszName[20];
				swprintf(wszName, L"Snapshot%d", iSnapshot);

				info.shi502_netname = wszName;
				info.shi502_type = STYPE_DISKTREE;
				info.shi502_permissions = ACCESS_READ;
				info.shi502_max_uses = 10;
				info.shi502_path = wszDeviceName;

				NET_API_STATUS status;
				DWORD parm_err;

				status = NetShareAdd(NULL, 502, (LPBYTE) &info, &parm_err);
				}

			CoTaskMemFree(wszDeviceName);
			wszDeviceName = NULL;
			}
		}
	catch(...)
		{
		}

	if (wszDeviceName)
		CoTaskMemFree(wszDeviceName);

	}

*/

// wait a maximum number of seconds before cancelling the operation
void LoopWait
	(
	IVssAsync *pAsync,
	LONG seconds,
	LPCWSTR wszOperation
	)
	{
    clock_t start = clock();
	HRESULT hr, hrStatus;
	while(TRUE)
		{
		Sleep(1000);
		CHECK_SUCCESS(pAsync->QueryStatus(&hrStatus, NULL));
		if (hrStatus != VSS_S_ASYNC_PENDING)
			break;

		if (((clock() - start)/CLOCKS_PER_SEC) >= seconds)
			break;
		}

	if (hrStatus == VSS_S_ASYNC_PENDING)
		{
		CHECK_NOFAIL(pAsync->Cancel());
		wprintf(L"Called cancelled for %s.\n", wszOperation);
		}

	CHECK_SUCCESS(pAsync->QueryStatus(&hrStatus, NULL));
	CHECK_NOFAIL(hrStatus);
	}


void DoPrepareBackup(IVssBackupComponents *pvbc)
	{
	CComPtr<IVssAsync> pAsync;
	INT nPercentDone;
	HRESULT hrResult;
	HRESULT hr;


	CHECK_SUCCESS(pvbc->PrepareForBackup(&pAsync));
	LoopWait(pAsync, 5, L"PrepareForBackup");
	CHECK_SUCCESS(pAsync->QueryStatus(&hrResult, &nPercentDone));
	CHECK_NOFAIL(hrResult);
	}


void DoSnapshotSet(IVssBackupComponents *pvbc, HRESULT &hrResult)
	{
	CComPtr<IVssAsync> pAsync;
	INT nPercentDone;
	HRESULT hr;

	CHECK_SUCCESS(pvbc->DoSnapshotSet (&pAsync));

	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hrResult, &nPercentDone));
	}


void DoBackupComplete(IVssBackupComponents *pvbc)
	{
	CComPtr<IVssAsync> pAsync;
	HRESULT hr;

	CHECK_SUCCESS(pvbc->BackupComplete(&pAsync));
	LoopWait(pAsync, 5, L"BackupComplete");
	}


void DoRestore(IVssBackupComponents *pvbc)
	{
	CComPtr<IVssAsync> pAsync;
	HRESULT hr;

	pvbc->GatherWriterMetadata(&pAsync);
    LoopWait(pAsync, 60, L"GetherWriterMetadata");
	pAsync = NULL;
	UINT cWriters, iWriter;

	CHECK_SUCCESS(pvbc->GetWriterMetadataCount(&cWriters));
	for(iWriter = 0; iWriter < cWriters; iWriter++)
		{
		CComPtr<IVssExamineWriterMetadata> pMetadata;
		VSS_ID idInstance;
		CHECK_SUCCESS(pvbc->GetWriterMetadata(iWriter, &idInstance, &pMetadata));
		}

	UINT cWriterComponents;
	CHECK_SUCCESS(pvbc->GetWriterComponentsCount(&cWriterComponents));
	for(UINT iWriterComponent = 0; iWriterComponent < cWriterComponents; iWriterComponent++)
		{
		CComPtr<IVssWriterComponentsExt> pWriter;

		CHECK_SUCCESS(pvbc->GetWriterComponents(iWriterComponent, &pWriter));
		VSS_ID idInstance;
		VSS_ID idWriter;
		UINT cComponents;
		CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
		CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstance, &idWriter));

		for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
			{
	    	CComPtr<IVssComponent> pComponent;

			CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
			
    		CComBSTR bstrLogicalPath;
			CComBSTR bstrComponentName;
			CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
			CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));

            // For RestoreOnly case, we check if the user provided a component selection
            BOOL bSelected = TRUE;
            if (g_bRestoreOnly && g_pWriterSelection)
                {
                // User provided a valid selection file
                bSelected = g_pWriterSelection->IsComponentSelected(idWriter, bstrLogicalPath, bstrComponentName);
                if (bSelected)
                    {
            		wprintf (L"\n        Component \"%s\" is selected for Restore\n", bstrComponentName);
                    }
                else
                    {
            		wprintf (L"\n        Component \"%s\" is NOT selected for Restore\n", bstrComponentName);
                    }
   	            }

            if (bSelected)
                {
    			VSS_COMPONENT_TYPE ct;
    			CHECK_SUCCESS(pComponent->GetComponentType(&ct));
    			if (ct == VSS_CT_DATABASE)
    				{
        			WCHAR wszPath[256];
    	    		if (!bstrLogicalPath)
    		    		wcscpy(wszPath, bstrComponentName);
    			    else
    				    wsprintf(wszPath, L"%s/%s", bstrLogicalPath, bstrComponentName);
    			    
    				CHECK_SUCCESS(pvbc->AddRestoreSubcomponent
    									(
    									idWriter,
    									VSS_CT_DATABASE,
    									bstrLogicalPath,
    									bstrComponentName,
    									wszPath,
    									L"dbFiles",
    									false
    									));

                    CHECK_SUCCESS(pvbc->SetSelectedForRestore
    									(
    									idWriter,
    									VSS_CT_DATABASE,
    									bstrLogicalPath,
    									bstrComponentName,
    									true
    									));

                    CHECK_SUCCESS(pvbc->SetRestoreOptions
    									(
    									idWriter,
    									VSS_CT_DATABASE,
    									bstrLogicalPath,
    									bstrComponentName,
    									L"DIFFRESTORE"));

    				CHECK_SUCCESS(pvbc->SetAdditionalRestores
    									(
    									idWriter,
    									VSS_CT_DATABASE,
    									bstrLogicalPath,
    									bstrComponentName,
    									false
    									));
    				}
    			else
    			    {
                    CHECK_SUCCESS(pvbc->SetSelectedForRestore
    									(
    									idWriter,
    									ct,
    									bstrLogicalPath,
    									bstrComponentName,
    									true
    									));
    			    }
                }
			}
		}

			

	CHECK_SUCCESS(pvbc->PreRestore(&pAsync));
	LoopWait(pAsync, 5, L"PreRestore");
	pAsync = NULL;

	CheckStatus(pvbc, L"After PreRestore");

	for(UINT iWriterComponent = 0; iWriterComponent < cWriterComponents; iWriterComponent++)
		{
		CComPtr<IVssWriterComponentsExt> pWriter;
		VSS_ID idWriter;
		VSS_ID idInstance;

		CHECK_SUCCESS(pvbc->GetWriterComponents(iWriterComponent, &pWriter));
		UINT cComponents;
		CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
		CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstance, &idWriter));

		for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
			{
			CComPtr<IVssComponent> pComponent;
			CComBSTR bstrLogicalPath;
			CComBSTR bstrComponentName;
			CComBSTR bstrFailureMsg;

			CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
			VSS_COMPONENT_TYPE ct;
			CHECK_SUCCESS(pComponent->GetComponentType(&ct));
			CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
			CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
			CHECK_NOFAIL(pComponent->GetPreRestoreFailureMsg(&bstrFailureMsg));

			VSS_RESTORE_TARGET rt;
			CHECK_SUCCESS(pComponent->GetRestoreTarget(&rt));

			if (bstrFailureMsg || rt != VSS_RT_ORIGINAL)
				{
				wprintf(L"\nComponent Path=%s Name=%s\n",
						bstrLogicalPath ? bstrLogicalPath : L"",
						bstrComponentName);

				if (bstrFailureMsg)
					wprintf(L"\nPreRestoreFailureMsg=%s\n", bstrFailureMsg);
			
				wprintf(L"restore target = %s\n", WszFromRestoreTarget(rt));
				if (rt == VSS_RT_NEW)
					PrintNewTargets(pComponent);
				else if (rt == VSS_RT_DIRECTED)
					PrintDirectedTargets(pComponent);

				wprintf(L"\n");
				}

			CHECK_SUCCESS(pvbc->SetFileRestoreStatus
							(
							idWriter,
							ct,
							bstrLogicalPath,
							bstrComponentName,
							VSS_RS_ALL
							));
			}
		}

	wprintf(L"\n");

	
	CHECK_SUCCESS(pvbc->PostRestore(&pAsync));
	LoopWait(pAsync, 5, L"PostRestore");
	pAsync = NULL;

	CheckStatus(pvbc, L"After PostRestore");

	for(UINT iWriterComponent = 0; iWriterComponent < cWriterComponents; iWriterComponent++)
		{
		CComPtr<IVssWriterComponentsExt> pWriter;

		CHECK_SUCCESS(pvbc->GetWriterComponents(iWriterComponent, &pWriter));
		UINT cComponents;
		CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));

		for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
			{
			CComPtr<IVssComponent> pComponent;
			CComBSTR bstrLogicalPath;
			CComBSTR bstrComponentName;
			CComBSTR bstrFailureMsg;

			CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
			VSS_COMPONENT_TYPE ct;
			CHECK_SUCCESS(pComponent->GetComponentType(&ct));
			CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
			CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
			CHECK_NOFAIL(pComponent->GetPostRestoreFailureMsg(&bstrFailureMsg));
			if (bstrFailureMsg)
				{
				wprintf(L"\nComponent Path=%s Name=%s\n",
						bstrLogicalPath ? bstrLogicalPath : L"",
						bstrComponentName);

				if (bstrFailureMsg)
					wprintf(L"\nPostRestoreFailureMsg=%s\n", bstrFailureMsg);

				wprintf(L"\n");
				}
			}
		}

	wprintf(L"\n");
	}


void DoAddToSnapshotSet
    (
    IN IVssBackupComponents *pvbc,
    IN BSTR bstrPath,
    IN LPWSTR wszVolumes,
	VSS_ID *rgpSnapshotId,
	UINT *pcSnapshot
    )
    {
    PWCHAR	pwszPath           = NULL;
    PWCHAR	pwszMountPointName = NULL;
    WCHAR	wszVolumeName [50];
    ULONG	ulPathLength;
    ULONG	ulMountpointBufferLength;
	HRESULT hr;


    ulPathLength = ExpandEnvironmentStringsW (bstrPath, NULL, 0);

    pwszPath = (PWCHAR) malloc (ulPathLength * sizeof (WCHAR));

    ulPathLength = ExpandEnvironmentStringsW (bstrPath, pwszPath, ulPathLength);


    ulMountpointBufferLength = GetFullPathName (pwszPath, 0, NULL, NULL);

    pwszMountPointName = (PWCHAR) malloc (ulMountpointBufferLength * sizeof (WCHAR));

	bool fSuccess = false;
	if (wcslen(pwszPath) >= 3 && pwszPath[1] == L':' && pwszPath[2] == L'\\')
		{
		wcsncpy(pwszMountPointName, pwszPath, 3);
		pwszMountPointName[3] = L'\0';
		fSuccess = true;
		}
	else
		{
		if (GetVolumePathNameW (pwszPath, pwszMountPointName, ulMountpointBufferLength))
			fSuccess = true;
		else
			printf("GetVolumeMountPointW failed with error %d\n", GetLastError());
		}

	if (fSuccess)
		{
		if (!GetVolumeNameForVolumeMountPointW (pwszMountPointName, wszVolumeName, sizeof (wszVolumeName) / sizeof (WCHAR)))
				printf("GetVolumeNameForVolumeMountPointW failed with error %d\n", GetLastError());
		else
            {
			if (NULL == wcsstr (wszVolumes, wszVolumeName))
				{
				if (L'\0' != wszVolumes [0])
					wcscat (wszVolumes, L";");

				wcscat (wszVolumes, wszVolumeName);

				CHECK_SUCCESS
					(
					pvbc->AddToSnapshotSet
						(
						wszVolumeName,
						GUID_NULL,
						&rgpSnapshotId[*pcSnapshot]
						)
					);
				wprintf(L"Volume <%s> <%s>\n", wszVolumeName, pwszMountPointName);
				wprintf(L"is added to the snapshot set\n\n");

				*pcSnapshot += 1;
				}
			}
		}

    if (NULL != pwszPath)           free (pwszPath);
    if (NULL != pwszMountPointName) free (pwszMountPointName);
    }

static LPCWSTR s_rgwszStates[] =
	{
	NULL,
	L"STABLE",
	L"WAIT_FOR_FREEZE",
	L"WAIT_FOR_THAW",
	L"WAIT_FOR_POST_SNAPSHOT",
	L"WAIT_FOR_BACKUP_COMPLETE",
	L"FAILED_AT_IDENTIFY",
	L"FAILED_AT_PREPARE_BACKUP",
	L"FAILED_AT_PREPARE_SNAPSHOT",
	L"FAILED_AT_FREEZE",
	L"FAILED_AT_THAW",
	L"FAILED_AT_POST_SNAPSHOT",
	L"FAILED_AT_BACKUP_COMPLETE",
	L"FAILED_AT_PRE_RESTORE",
	L"FAILED_AT_POST_RESTORE"
	};


void CheckStatus(IVssBackupComponents *pvbc, LPCWSTR wszWhen)
    {
    unsigned cWriters;
	CComPtr<IVssAsync> pAsync;
	HRESULT hr;

    CHECK_NOFAIL(pvbc->GatherWriterStatus(&pAsync));
	CHECK_NOFAIL(pAsync->Wait());
	CHECK_NOFAIL(pvbc->GetWriterStatusCount(&cWriters));


    wprintf(L"\n\nstatus %s (%d writers)\n\n", wszWhen, cWriters);

    for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
	{
	VSS_ID idInstance;
	VSS_ID idWriter;
	VSS_WRITER_STATE status;
	CComBSTR bstrWriter;
	HRESULT hrWriterFailure;

	CHECK_SUCCESS(pvbc->GetWriterStatus (iWriter,
					     &idInstance,
					     &idWriter,
					     &bstrWriter,
					     &status,
					     &hrWriterFailure));

	wprintf (L"Status for writer %s: %s(0x%08lx%s%s)\n",
		 bstrWriter,
		 s_rgwszStates[status],
		 hrWriterFailure,
		 SUCCEEDED (hrWriterFailure) ? L"" : L" - ",
		 GetStringFromFailureType (hrWriterFailure));
        }

    pvbc->FreeWriterStatus();
    }

void PrintPartialFilesForComponents(IVssBackupComponents *pvbc)
	{
	HRESULT hr;
	UINT cWriterComponents;

	CHECK_SUCCESS(pvbc->GetWriterComponentsCount(&cWriterComponents));
	for(UINT iWriterComponent = 0; iWriterComponent < cWriterComponents; iWriterComponent++)
		{
		CComPtr<IVssWriterComponentsExt> pWriter;

		CHECK_SUCCESS(pvbc->GetWriterComponents(iWriterComponent, &pWriter));
		UINT cComponents;
		CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));

		for(UINT iComponent = 0; iComponent < cComponents; iComponent++)
			{
			CComPtr<IVssComponent> pComponent;

			CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));

			CComBSTR bstrLogicalPath;
			CComBSTR bstrComponentName;

			CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
			CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
			UINT cPartialFiles;

			CHECK_SUCCESS(pComponent->GetPartialFileCount(&cPartialFiles));
			if (cPartialFiles > 0)
				{
				wprintf(L"\nPartial files for Component Path=%s Name=%s\n",
						bstrLogicalPath ? bstrLogicalPath : L"",
						bstrComponentName);

				PrintPartialFiles(pComponent);
				}
			}
		}
	}

BOOL SaveBackupDocument(CComBSTR &bstr)
    {
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    DWORD dwByteToWrite = (bstr.Length() + 1) * sizeof(WCHAR);
    DWORD dwBytesWritten;
    
    // Create the file (override if exists)
    hFile = CreateFile(g_wszBackupDocumentFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        {
        return FALSE;
        }

    // Write the XML string 
    if (! WriteFile(hFile, (LPVOID)(BSTR)bstr, dwByteToWrite, &dwBytesWritten, NULL))
        {
        CloseHandle(hFile);
        return FALSE;
        }

    CloseHandle(hFile);
    return TRUE;
    }

BOOL LoadBackupDocument(CComBSTR &bstr)
    {
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    DWORD dwBytesToRead = 0;
    DWORD dwBytesRead;
    
    // Create the file (must exist)
    hFile = CreateFile(g_wszBackupDocumentFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        {
        return FALSE;
        }

    if ((dwBytesToRead = GetFileSize(hFile, NULL)) <= 0)
        {
        CloseHandle(hFile);
        return FALSE;
        }

    WCHAR *pwszBuffer = NULL;
    DWORD dwNofChars = 0;

    if ((dwBytesToRead % sizeof(WCHAR)) != 0) 
        {
        CloseHandle(hFile);
  		wprintf(L"Invalid file lenght %lu for backup document file\n", dwBytesToRead);
        return FALSE;
        }
    else
        {
        dwNofChars = dwBytesToRead / sizeof(WCHAR);
        }
    
    pwszBuffer = (PWCHAR) malloc (dwNofChars * sizeof (WCHAR));
    if (! pwszBuffer) 
        {
        CloseHandle(hFile);
  		wprintf(L"Failed to allocate memory for backup document buffer\n");
        return FALSE;
        }
    
    // Read the XML string 
    if (! ReadFile(hFile, (LPVOID)pwszBuffer, dwBytesToRead, &dwBytesRead, NULL))
        {
        CloseHandle(hFile);
        free (pwszBuffer);
        return FALSE;
        }
    
    CloseHandle(hFile);
    
    if (dwBytesToRead != dwBytesRead)
        {
        free (pwszBuffer);
  		wprintf(L"Backup document file is supposed to have %lu bytes but only %lu bytes are read\n", dwBytesToRead, dwBytesRead);
        return FALSE;
        }

    // Copy to output bstr
    bstr.Empty();
    if (bstr.Append(pwszBuffer, dwNofChars-1) != S_OK)     // don't copy the NULL
        {
        free (pwszBuffer);
  		wprintf(L"Failed to copy from temporary buffer into Backup Document XML string\n");
        return FALSE;
        }

    return TRUE;
    }

HRESULT ParseCommnadLine (int argc, WCHAR **argv)
    {
    HRESULT hr = S_OK;
    int iArg;

    g_wszBackupDocumentFileName[0] = L'\0';
    g_wszComponentsFileName[0] = L'\0';
    
    try 
        {
        for (iArg=1; iArg<argc; iArg++)
            {
            if ((_wcsicmp(argv[iArg], L"/W") == 0) || (_wcsicmp(argv[iArg], L"-W") == 0))
                {
      	    	iArg++;
      	    	
                if (iArg >= argc)
                    {
            		wprintf(L"/W switch missing wait-time argument\n");
            		throw(E_INVALIDARG);
                    }
                if (argv[iArg][0] >= L'0' && argv[iArg][0] <= L'9'||
                    argv[iArg][0] >= L'a' && argv[iArg][0] <= L'f')
    		        {
    		        if (argv[iArg][0] >= L'0' && argv[iArg][0] <= L'9')
            			 g_lWriterWait = argv[iArg][0] - L'0';
            		 else
    	        		 g_lWriterWait = argv[iArg][0] - L'a' + 10;
        
        	    	 wprintf(L"Writer wait parameter=%ld.\n", g_lWriterWait);
                    }
                else
                    {
            		wprintf(L"/W switch is followed by invalid wait-time argument\n");
            		throw(E_INVALIDARG);
                    }
    		    }
            else if ((_wcsicmp(argv[iArg], L"/B") == 0) || (_wcsicmp(argv[iArg], L"-B") == 0))
                {
                g_bBackupOnly = TRUE;
    	    	wprintf(L"Asked to do Backup only\n");
                }
            else if ((_wcsicmp(argv[iArg], L"/R") == 0) || (_wcsicmp(argv[iArg], L"-R") == 0))
                {
                g_bRestoreOnly = TRUE;
    	    	wprintf(L"Asked to do Restore only\n");
                }
            else if ((_wcsicmp(argv[iArg], L"/S") == 0) || (_wcsicmp(argv[iArg], L"-S") == 0))
                {
      	    	iArg++;
      	    	
                if (iArg >= argc)
                    {
            		wprintf(L"/S switch missing file-name to save/load backup document\n");
            		throw(E_INVALIDARG);
                    }
                if (wcslen(argv[iArg]) >= MAX_PATH)
                    {
            		wprintf(L"Path for file-name to save/load backup document is limited to %d\n", MAX_PATH);
            		throw(E_INVALIDARG);
                    }
                wcscpy(g_wszBackupDocumentFileName, argv[iArg]);
    	    	wprintf(L"File name to save/load Backup Document is \"%s\"\n", g_wszBackupDocumentFileName);
                }
            else if ((_wcsicmp(argv[iArg], L"/C") == 0) || (_wcsicmp(argv[iArg], L"-C") == 0))
                {
      	    	iArg++;
      	    	
                if (iArg >= argc)
                    {
            		wprintf(L"/C switch missing file-name to load components selection from\n");
            		throw(E_INVALIDARG);
                    }
                if (wcslen(argv[iArg]) >= MAX_PATH)
                    {
            		wprintf(L"Path for file-name to load components selection is limited to %d\n", MAX_PATH);
            		throw(E_INVALIDARG);
                    }
                wcscpy(g_wszComponentsFileName, argv[iArg]);
    	    	wprintf(L"File name for Components Selection is \"%s\"\n", g_wszComponentsFileName);
                }
            else if ((_wcsicmp(argv[iArg], L"/?") == 0) || (_wcsicmp(argv[iArg], L"-?") == 0))
                {
                // Print help
                wprintf(L"BETEST [/B] [/R] [/S filename] [/C filename]\n\n");
                wprintf(L"/B\t\t Performs backup only\n");
                wprintf(L"/R\t\t Performs restore only\n");
                wprintf(L"\t\t Restore-only must be used with /S for a backup document file\n\n");
                wprintf(L"/S filename\t In case of backup, saves the backup document to file\n");
                wprintf(L"\t\t In case of restore-only, loads the backup document from file\n\n");
                wprintf(L"/C filename\t Selects which components to backup/restore based on the file\n\n");
                wprintf(L"Components selection file format:\n");
                wprintf(L"\"<writer-id>\": \"<component-logical-path>\", ...\"<component-logical-path>\";\n\n");
                wprintf(L"where several writers may be specified, each one with its own components\n");
                wprintf(L"<writer-id> is in standard GUID format\n");
                wprintf(L"<component-logical-path> is either logical-path, logical-path\\component-name\n");
                wprintf(L"or component-name-only (if there's no logical path)\n\n");
                wprintf(L"For example:\n");
                wprintf(L"\"{c0577ae6-d741-452a-8cba-99d744008c04}\": \"\\mydatabases\", \"\\mylogfiles\";\n");
                wprintf(L"\"{f2436e37-09f5-41af-9b2a-4ca2435dbfd5}\" : \"Registry\"  ;\n\n");
                wprintf(L"If no argument is specified, BETEST performs a backup followed by a restore\n");
                wprintf(L"choosing all components reported by all writers\n\n");
                
                // Set hr such that program terminates
                hr = S_FALSE;
                }
            else
                {
           		wprintf(L"Invalid switch\n");
           		throw(E_INVALIDARG);
                }
            }

        // Check for invalid combinations
        if (g_bBackupOnly && g_bRestoreOnly)
            {
           		wprintf(L"Cannot backup-only and restore-only at the same time...\n");
           		throw(E_INVALIDARG);
            }
        if (g_bRestoreOnly && (wcslen(g_wszBackupDocumentFileName) == 0))
            {
           		wprintf(L"Cannot restore-only with no backup-document to use.\nUse the /S switch for specifying a file name with backup document from a previous BETEST backup");
           		throw(E_INVALIDARG);
            }
           	
        }
    catch (HRESULT hrParse)
        {
        hr = hrParse;
        }

    return hr;
    }


extern "C" __cdecl wmain(int argc, WCHAR **argv)
    {
    WCHAR wszVolumes[2048];
    wszVolumes[0] = L'\0';

	UINT cSnapshot = 0;
	VSS_ID rgpSnapshotId[64];

    CTestVssWriter *pInstance = NULL;
    bool bCreated = false;
    bool bSubscribed = false;
    HRESULT hrMain = S_OK;
    bool bCoInitializeSucceeded = false;


    try
	{
	HRESULT hr = S_OK;
    CComBSTR bstrXML;
    BOOL bXMLSaved = FALSE;

	// Parse command line arguments
    if (ParseCommnadLine(argc, argv) != S_OK)
        {
        // Don't throw since we want to avoid assertions here - we can return safely
        return (3);        
        }

	CHECK_SUCCESS(CoInitializeEx(NULL, COINIT_MULTITHREADED));

    // Initialize COM security
    CHECK_SUCCESS
		(
		CoInitializeSecurity
			(
			NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
			-1,                                  //  IN LONG                         cAuthSvc,
			NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
			NULL,                                //  IN void                        *pReserved1,
			RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
			RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
			NULL,                                //  IN void                        *pAuthList,
			EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
			NULL                                 //  IN void                        *pReserved3
			)
		);

	bCoInitializeSucceeded = true;

	if ( !AssertPrivilege( SE_BACKUP_NAME ) )
	    {
	    wprintf( L"AssertPrivilege returned error, rc:%d\n", GetLastError() );
	    return 2;
	    }

    // Get chosen components for backup and/or restore
    if (wcslen(g_wszComponentsFileName) > 0)
        {
        g_pWriterSelection = CWritersSelection::CreateInstance();
    	if (g_pWriterSelection == NULL)
	        {
	        wprintf(L"allocation failure\n");
    	    DebugBreak();
	        }

        if (g_pWriterSelection->BuildChosenComponents(g_wszComponentsFileName) != S_OK)
            {
	        wprintf(L"Component selection in %s is ignored due to a failure in processing the file\n", g_wszComponentsFileName);
	        g_pWriterSelection = 0;
            }
        }
    
//	EnumVolumes();

	TestSnapshotXML();

	pInstance = new CTestVssWriter(g_lWriterWait);
	if (pInstance == NULL)
	    {
	    wprintf(L"allocation failure\n");
	    DebugBreak();
	    }

	bCreated = true;
	pInstance->Initialize();
	CHECK_SUCCESS(pInstance->Subscribe());
	bSubscribed = true;

    if (! g_bRestoreOnly)
        {
    	CComBSTR strSnapshotSetId = "12345678-1234-1234-1234-1234567890ab";

    	CComPtr<IVssBackupComponents> pvbc;

	    CHECK_SUCCESS(CreateVssBackupComponents(&pvbc));


    	CHECK_SUCCESS(pvbc->InitializeForBackup());
    	CHECK_SUCCESS(pvbc->SetBackupState (true,
    					    false,
    					    VSS_BT_DIFFERENTIAL,
    						true));


/*
    VSS_ID idWMIWriter =
		{
		0xa6ad56c2,
		0xb509, 0x4e6c,
		0xbb, 0x19, 0x49, 0xd8, 0xf4, 0x35, 0x32, 0xf0
		};

    pvbc->DisableWriterClasses(&idWMIWriter, 1);


    VSS_ID idCWriter =
		{
		0xc0577ae6, 0xd741, 0x452a,
		0x8c, 0xba, 0x99, 0xd7, 0x44, 0x00, 0x8c, 0x04
		};


    pvbc->EnableWriterClasses(&idCWriter, 1);
*/

    	unsigned cWriters;
    	CComPtr<IVssAsync> pAsync;
    	CHECK_NOFAIL(pvbc->GatherWriterMetadata(&pAsync));
    	LoopWait(pAsync, 30, L"GatherWriterMetadata");
    	CHECK_NOFAIL(pvbc->GetWriterMetadataCount(&cWriters));

    	VSS_ID id;

    	while(TRUE)
    		{
    		hr = pvbc->StartSnapshotSet(&id);
    		if (hr == S_OK)
    			break;

    		if (hr == VSS_E_SNAPSHOT_SET_IN_PROGRESS)
    			Sleep(1000);
    		else
    			CHECK_SUCCESS(hr);
    		}

        BOOL bAtLeastOneSelected = FALSE;
        
    	for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
    	    {
    	    CComPtr<IVssExamineWriterMetadata> pMetadata;
    	    VSS_ID idInstance;

    	    CHECK_SUCCESS(pvbc->GetWriterMetadata(iWriter, &idInstance, &pMetadata));
    	    VSS_ID idInstanceT;
    	    VSS_ID idWriter;
    	    CComBSTR bstrWriterName;
    	    VSS_USAGE_TYPE usage;
    	    VSS_SOURCE_TYPE source;

    	    CHECK_SUCCESS(pMetadata->GetIdentity (&idInstanceT,
    						  &idWriter,
    						  &bstrWriterName,
    						  &usage,
    						  &source));

    	    wprintf (L"\n\n");

                if (memcmp(&idInstance, &idInstanceT, sizeof(VSS_ID)) != 0)
    		{
    		wprintf(L"Instance id mismatch\n");
    		DebugBreak();
    		}

    	    WCHAR *pwszInstanceId;
    	    WCHAR *pwszWriterId;
    	    UuidToString(&idInstance, &pwszInstanceId);
    	    UuidToString(&idWriter, &pwszWriterId);
    	    wprintf (L"WriterName = %s\n\n"
    		     L"    WriterId   = %s\n"
    		     L"    InstanceId = %s\n"
    		     L"    UsageType  = %d (%s)\n"
    		     L"    SourceType = %d (%s)\n",
    		     bstrWriterName,
    		     pwszWriterId,
    		     pwszInstanceId,
    		     usage,
    		     GetStringFromUsageType (usage),
    		     source,
    		     GetStringFromSourceType (source));

    	    RpcStringFree(&pwszInstanceId);
    	    RpcStringFree(&pwszWriterId);

    	    unsigned cIncludeFiles, cExcludeFiles, cComponents;
    	    CHECK_SUCCESS(pMetadata->GetFileCounts (&cIncludeFiles,
    						    &cExcludeFiles,
    						    &cComponents));

    	    CComBSTR bstrPath;
    	    CComBSTR bstrFilespec;
    	    CComBSTR bstrAlternate;
    	    CComBSTR bstrDestination;

    	    for(unsigned i = 0; i < cIncludeFiles; i++)
    		{
    		CComPtr<IVssWMFiledesc> pFiledesc;
    		CHECK_SUCCESS(pMetadata->GetIncludeFile(i, &pFiledesc));

    		PrintFiledesc(pFiledesc, L"\n    Include File");
    		}

    	    for(i = 0; i < cExcludeFiles; i++)
    		{
    		CComPtr<IVssWMFiledesc> pFiledesc;
    		CHECK_SUCCESS(pMetadata->GetExcludeFile(i, &pFiledesc));
    		PrintFiledesc(pFiledesc, L"\n    Exclude File");
    		}

    	    for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
    		{
    		CComPtr<IVssWMComponent> pComponent;
    		PVSSCOMPONENTINFO pInfo;
    		CHECK_SUCCESS(pMetadata->GetComponent(iComponent, &pComponent));
    		CHECK_SUCCESS(pComponent->GetComponentInfo(&pInfo));
    		wprintf (L"\n"
    			 L"    Component %d, type = %d (%s)\n"
    			 L"        LogicalPath = %s\n"
    			 L"        Name        = %s\n"
    			 L"        Caption     = %s\n",
    			 iComponent,
    			 pInfo->type,
    			 GetStringFromComponentType (pInfo->type),
    			 pInfo->bstrLogicalPath,
    			 pInfo->bstrComponentName,
    			 pInfo->bstrCaption);

    					

                    if (pInfo->cbIcon > 0)
    		    {
    		    if (pInfo->cbIcon != 10 ||
    			pInfo->pbIcon[0] != 1 ||
    			pInfo->pbIcon[1] != 2 ||
    			pInfo->pbIcon[2] != 3 ||
    			pInfo->pbIcon[3] != 4 ||
    			pInfo->pbIcon[4] != 5 ||
    			pInfo->pbIcon[5] != 6 ||
    			pInfo->pbIcon[6] != 7 ||
    			pInfo->pbIcon[7] != 8 ||
    			pInfo->pbIcon[8] != 9 ||
    			pInfo->pbIcon[9] != 10)
    			{
    			wprintf(L"        Icon is not valid.\n");
    			DebugBreak();
    			}
    		    else
    			wprintf(L"        Icon is valid.\n");
    		    }

    		wprintf (L"        RestoreMetadata        = %s\n"
    			 L"        NotifyOnBackupComplete = %s\n"
    			 L"        Selectable             = %s\n",
    			 pInfo->bRestoreMetadata        ? L"yes" : L"no",
    			 pInfo->bNotifyOnBackupComplete ? L"yes" : L"no",
    			 pInfo->bSelectable             ? L"yes" : L"no");

            BOOL bSelected = TRUE;
            if (g_pWriterSelection)
                {
                // User provided a valid selection file
                bSelected = g_pWriterSelection->IsComponentSelected(idWriter, pInfo->bstrLogicalPath, pInfo->bstrComponentName);
                if (bSelected)
                    {
            		wprintf (L"\n        Component \"%s\" IS selected for Backup\n\n", pInfo->bstrComponentName);
                    }
                else
                    {
            		wprintf (L"\n        Component \"%s\" is NOT selected for Backup\n\n", pInfo->bstrComponentName);
                    }
   	            }

            if (bSelected)
                {
            
        		CHECK_SUCCESS(pvbc->AddComponent (idInstance,
        						  idWriter,
        						  pInfo->type,
        						  pInfo->bstrLogicalPath,
        						  pInfo->bstrComponentName));


        		if (pInfo->type == VSS_CT_DATABASE)
        			{
        			CHECK_SUCCESS
        				(
        				pvbc->SetPreviousBackupStamp
        					(
        					idWriter,
        					pInfo->type,
        					pInfo->bstrLogicalPath,
        					pInfo->bstrComponentName,
        					L"LASTFULLBACKUP"
        					));

        			CHECK_SUCCESS
        				(
        				pvbc->SetBackupOptions
        					(
        					idWriter,
        					pInfo->type,
        					pInfo->bstrLogicalPath,
        					pInfo->bstrComponentName,
        					L"DOFASTINCREMENAL"
        					));
                    }


        		if (pInfo->cFileCount > 0)
        		    {
        		    for(i = 0; i < pInfo->cFileCount; i++)
        			{
        			CComPtr<IVssWMFiledesc> pFiledesc;
        			CHECK_SUCCESS(pComponent->GetFile(i, &pFiledesc));

        			CComBSTR bstrPath;
        			CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
        			DoAddToSnapshotSet(pvbc, bstrPath, wszVolumes, rgpSnapshotId, &cSnapshot);
                    bAtLeastOneSelected = TRUE;
        			PrintFiledesc(pFiledesc, L"        FileGroupFile");
        			}
        		    }

        		if (pInfo->cDatabases > 0)
        		    {
        		    for(i = 0; i < pInfo->cDatabases; i++)
        			{
        			CComPtr<IVssWMFiledesc> pFiledesc;
        			CHECK_SUCCESS(pComponent->GetDatabaseFile(i, &pFiledesc));

        			CComBSTR bstrPath;
        			CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
        			DoAddToSnapshotSet(pvbc, bstrPath, wszVolumes, rgpSnapshotId, &cSnapshot);
                    bAtLeastOneSelected = TRUE;
        			PrintFiledesc(pFiledesc, L"        DatabaseFile");
        			}
        		    }

        		if (pInfo->cLogFiles > 0)
        		    {
        		    for(i = 0; i < pInfo->cLogFiles; i++)
        			{
        			CComPtr<IVssWMFiledesc> pFiledesc;
        			CHECK_SUCCESS(pComponent->GetDatabaseLogFile(i, &pFiledesc));

        			CComBSTR bstrPath;
        			CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
        			DoAddToSnapshotSet(pvbc, bstrPath, wszVolumes, rgpSnapshotId, &cSnapshot);
                    bAtLeastOneSelected = TRUE;
        			PrintFiledesc(pFiledesc, L"        DatabaseLogFile");
        			}
        		    }
                }

    		pComponent->FreeComponentInfo(pInfo);
    		}

    	    VSS_RESTOREMETHOD_ENUM method;
    	    CComBSTR bstrUserProcedure;
    	    CComBSTR bstrService;
    	    VSS_WRITERRESTORE_ENUM writerRestore;
    	    unsigned cMappings;
    	    bool bRebootRequired;

    	    CHECK_NOFAIL(pMetadata->GetRestoreMethod (&method,
    						      &bstrService,
    						      &bstrUserProcedure,
    						      &writerRestore,
    						      &bRebootRequired,
    						      &cMappings));


    	    wprintf (L"\n"
    		     L"    Restore method = %d (%s)\n"
    		     L"    Service        = %s\n"
    		     L"    User Procedure = %s\n"
    		     L"    WriterRestore  = %d (%s)\n"
    		     L"    RebootRequired = %s\n",
    		     method,
    		     GetStringFromRestoreMethod (method),
    		     bstrService,
    		     bstrUserProcedure,
    		     writerRestore,
    		     GetStringFromWriterRestoreMethod (writerRestore),
    		     bRebootRequired ? L"yes" : L"no");

    	    for(i = 0; i < cMappings; i++)
    		{
    		CComPtr<IVssWMFiledesc> pFiledesc;

    		CHECK_SUCCESS(pMetadata->GetAlternateLocationMapping(i, &pFiledesc));

    		PrintFiledesc(pFiledesc, L"AlternateMapping");
    		}
    	
    		CComBSTR bstrMetadata;
    		CHECK_SUCCESS(pMetadata->SaveAsXML(&bstrMetadata));
    		CComPtr<IVssExamineWriterMetadata> pMetadataNew;
    		CHECK_SUCCESS(CreateVssExamineWriterMetadata(bstrMetadata, &pMetadataNew));
    	    CHECK_SUCCESS(pMetadataNew->GetIdentity (&idInstanceT,
    						  &idWriter,
    						  &bstrWriterName,
    						  &usage,
    						  &source));

    	    wprintf (L"\n\n");

    		if (memcmp(&idInstance, &idInstanceT, sizeof(VSS_ID)) != 0)
    			{
    			wprintf(L"Instance id mismatch\n");
    			DebugBreak();
    			}

    	    UuidToString(&idInstance, &pwszInstanceId);
    	    UuidToString(&idWriter, &pwszWriterId);
    	    wprintf (L"WriterName = %s\n\n"
    		     L"    WriterId   = %s\n"
    		     L"    InstanceId = %s\n"
    		     L"    UsageType  = %d (%s)\n"
    		     L"    SourceType = %d (%s)\n",
    		     bstrWriterName,
    		     pwszWriterId,
    		     pwszInstanceId,
    		     usage,
    		     GetStringFromUsageType (usage),
    		     source,
    		     GetStringFromSourceType (source));

    	    RpcStringFree(&pwszInstanceId);
    	    RpcStringFree(&pwszWriterId);
    		}

    	CHECK_SUCCESS(pvbc->FreeWriterMetadata());

        //
        // Proceed with backup only if at least one component and one volume was selected for backup
        //
        if (bAtLeastOneSelected)
            {
            
        	DoPrepareBackup(pvbc);

        	CheckStatus(pvbc, L"After Prepare Backup");

        	unsigned cWriterComponents;
        	CHECK_SUCCESS(pvbc->GetWriterComponentsCount(&cWriterComponents));

        	for(iWriter = 0; iWriter < cWriterComponents; iWriter++)
        	    {
        	    CComPtr<IVssWriterComponentsExt> pWriter;
        	    CHECK_SUCCESS(pvbc->GetWriterComponents(iWriter, &pWriter));

        	    unsigned cComponents;
        	    CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
        	    VSS_ID idWriter, idInstance;
        	    CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstance, &idWriter));
        	    for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
        		{
        		CComPtr<IVssComponent> pComponent;
        		CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
        				
        		VSS_COMPONENT_TYPE ct;
        		CComBSTR bstrLogicalPath;
        		CComBSTR bstrComponentName;

        		CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
        		CHECK_SUCCESS(pComponent->GetComponentType(&ct));
        		CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
        		CComBSTR bstrStamp;

        		CHECK_NOFAIL(pComponent->GetBackupStamp(&bstrStamp));
        		if (bstrStamp)
        			wprintf(L"Backup stamp for component %s = %s\n", bstrComponentName, bstrStamp);

        		CHECK_SUCCESS(pvbc->SetBackupSucceeded (idInstance,
        							idWriter,
        							ct,
        							bstrLogicalPath,
        							bstrComponentName,
        							true));
        		}
        	    }


        	HRESULT hrResult;
        	DoSnapshotSet(pvbc, hrResult);

            if (FAILED(hrResult))
        	    {
        		wprintf(L"Creating the snapshot failed.  hr = 0x%08lx\n", hrResult);
        	    CheckStatus(pvbc, L"After Do Snapshot");
        	    }
        	else
        	    {
        	    CheckStatus(pvbc, L"After Do Snapshot");

        		PrintPartialFilesForComponents(pvbc);
        		

        		DoBackupComplete(pvbc);
        	    CheckStatus(pvbc, L"After Backup Complete");

                // Save backup document in a string
        		CHECK_SUCCESS(pvbc->SaveAsXML(&bstrXML));
                bXMLSaved = TRUE;

                // Save backup document (XML string) in a file
                if (wcslen(g_wszBackupDocumentFileName) > 0)
                    {
                    if (SaveBackupDocument(bstrXML))
                        {
                	    wprintf(L"Backup document saved successfully in %s\n", g_wszBackupDocumentFileName);
                        }
                    else
                        {
                	    wprintf(L"Failed to save backup document: SaveBackupDocument returned error %d\n", GetLastError());
                        }
                    }

                // Delete the snapshot set
        		LONG lSnapshotsNotDeleted;
        	    VSS_ID rgSnapshotsNotDeleted[10];

        	    hr  = pvbc->DeleteSnapshots (id,
        					 VSS_OBJECT_SNAPSHOT_SET,
        					 false,
        					 &lSnapshotsNotDeleted,
        					 rgSnapshotsNotDeleted);

        	    if (FAILED(hr))
        			wprintf(L"Deletion of Snapshots failed.  hr = 0x%08lx\n", hr);
        	    }
            }
        else
            {
       	    wprintf(L"\nBackup test is aborted since no component is selected, therefore, there are no volumes added to the snapshot set\n\n");
            }
        }

	// Restore is done if
	//  1. User did not ask backup-only AND
	//  2. User asked restore-only OR user asked both, and backup succeeded
	if (! g_bBackupOnly)
	    {
        if (g_bRestoreOnly || bXMLSaved)
            {
            BOOL bXMLLoaded = FALSE;

            // Load XML string only in Restore-only case
            if (g_bRestoreOnly)
                {
                if (LoadBackupDocument(bstrXML)) 
                    {
                    bXMLLoaded = TRUE;
            	    wprintf(L"Backup document was loaded from %s\n", g_wszBackupDocumentFileName);
                    }
                else
                    {
        	        wprintf(L"Failed to load backup document: LoadBackupDocument returned error %d\n", GetLastError());
                    }
                }

            // If we have a backup document from current backup or loaded successfully froma previous backup
            if (bXMLSaved || bXMLLoaded)
                {
        		// Prepare for restore
        		CComPtr<IVssBackupComponents> pvbcRestore;
        		
        		CHECK_SUCCESS(CreateVssBackupComponents(&pvbcRestore));
        		CHECK_SUCCESS(pvbcRestore->InitializeForRestore(bstrXML));
        		wprintf(L"InitializeForRestore succeeded.\n");

                // Do the restore
        		DoRestore(pvbcRestore);
                }
            }
        else 
            {
       	    wprintf(L"\nRestore test is not done due to a failure in the preceding Backup test\n\n");
            }
	    }
	}
    
    catch(...)
	{
	BS_ASSERT(FALSE);
	hrMain = E_UNEXPECTED;
	}

    if (bSubscribed)
		pInstance->Unsubscribe();

    if (bCreated)
		delete pInstance;

    if (FAILED(hrMain))
	wprintf(L"Failed with %08x.\n", hrMain);

    if (bCoInitializeSucceeded)
	CoUninitialize();

    return(0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\hwprv\src\stdafx.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module stdafx.cxx | The file used to compile the precompiled header
    @end

Author:

    Adi Oltean  [aoltean]   06/30/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.

--*/


#include "stdafx.hxx"
#include "hwprv.hxx"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#pragma warning( disable: 4189 )  /* local variable is initialized but not referenced */
#include <atlimpl.cpp>
#pragma warning( default: 4189 )  /* local variable is initialized but not referenced */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\failsnap\failsnap.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	simsnap.cpp
**
**
** Abstract:
**
**	Test program to drive the VSS Writer Shim contained in VssAPI.DLL
**
**
** Author:
**
**	Michael C. Johnson   [mikejohn]        24-May-2000
**
**
** Revision History:
**
**	X-5	MCJ		Michael C. Johnson		18-Sep-2000
**		176860: Add the missing calling convention specifiers
**
**	X-4	MCJ		Michael C. Johnson		23-Jun-2000
**		Set the writer failure status.
**
**	X-3	MCJ		Michael C. Johnson		15-Jun-2000
**		Add some additional event routines and the ability to act
**		as various types of writer.
**
**	X-2	MCJ		Michael C. Johnson		26-May-2000
**		Add some extra tests to validate shim is properly sensitive
**		to volume name array contents.
**--
*/

/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/
#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <assert.h>

#include <vss.h>
#include <vswriter.h>



#define	GET_STATUS_FROM_BOOL(_bSucceeded)	((_bSucceeded)       ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_HANDLE(_handle)		((NULL != (_handle)) ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_POINTER(_ptr)		((NULL != (_ptr))    ? NOERROR : E_OUTOFMEMORY)

#define SIZEOF_ARRAY(_aBase)			(sizeof (_aBase) / sizeof ((_aBase)[0]))



typedef enum FAIL_PHASE
    {
    PHASE_UNDEFINED = 0,
    PHASE_IDENTIFY,
    PHASE_PREPARE_FOR_BACKUP,
    PHASE_PREPARE_FOR_SNAPSHOT,
    PHASE_FREEZE,
    PHASE_THAW,
    PHASE_ABORT,
    PHASE_BACKUP_COMPLETE,
    PHASE_RESTORE
    } FAIL_PHASE;


HRESULT SelectFailureStatus (VOID)
    {
    HRESULT	hrStatus;

    switch (rand () / (RAND_MAX / 5))
	{
	case 0: hrStatus = VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT; break;
	case 1: hrStatus = VSS_E_WRITERERROR_OUTOFRESOURCES;       break;
	case 2: hrStatus = VSS_E_WRITERERROR_TIMEOUT;              break;
	case 3: hrStatus = VSS_E_WRITERERROR_NONRETRYABLE;         break;
	case 4: hrStatus = VSS_E_WRITERERROR_RETRYABLE;            break;

	default:
	    assert (FALSE);
	    break;
	}

    return (hrStatus);
    }



LPCWSTR GetStringFromFailureType (HRESULT hrStatus)
    {
    LPCWSTR pwszFailureType;

    switch (hrStatus)
	{
	case NOERROR:                                pwszFailureType = L"";                     break;
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT: pwszFailureType = L"InconsistentSnapshot"; break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:       pwszFailureType = L"OutOfResources";       break;
	case VSS_E_WRITERERROR_TIMEOUT:              pwszFailureType = L"Timeout";              break;
	case VSS_E_WRITERERROR_NONRETRYABLE:         pwszFailureType = L"Non-Retryable";        break;
	case VSS_E_WRITERERROR_RETRYABLE:            pwszFailureType = L"Retryable";            break;
	default:                                     pwszFailureType = L"UNDEFINED";            break;
	}

    return (pwszFailureType);
    }



LPCWSTR GetStringFromWriterType (VSS_USAGE_TYPE wtWriterType)
    {
    LPCWSTR pwszWriterType;

    switch (wtWriterType)
	{
	case VSS_UT_BOOTABLESYSTEMSTATE: pwszWriterType = L"BootableSystemState"; break;
	case VSS_UT_SYSTEMSERVICE:       pwszWriterType = L"SystemServiceState";  break;
	case VSS_UT_USERDATA:            pwszWriterType = L"UserData";            break;
	case VSS_UT_OTHER:               pwszWriterType = L"Other";               break;
	default:                         pwszWriterType = L"UNDEFINED";           break;
	}

    return (pwszWriterType);
    }



LPCWSTR GetStringFromFailPhase (FAIL_PHASE fpFailPhase)
    {
    LPCWSTR pwszFailPhase;


    switch (fpFailPhase)
	{
	case PHASE_IDENTIFY:             pwszFailPhase = L"Identify";           break;
	case PHASE_PREPARE_FOR_BACKUP:   pwszFailPhase = L"PrepareForBackup";   break;
	case PHASE_PREPARE_FOR_SNAPSHOT: pwszFailPhase = L"PrepareForSnapshot"; break;
	case PHASE_FREEZE:               pwszFailPhase = L"Freeze";             break;
	case PHASE_THAW:                 pwszFailPhase = L"Thaw";               break;
	case PHASE_ABORT:                pwszFailPhase = L"Abort";              break;
	case PHASE_BACKUP_COMPLETE:      pwszFailPhase = L"BackupComplete";     break;
	case PHASE_RESTORE:              pwszFailPhase = L"Restore";            break;
	default:                         pwszFailPhase = L"UNDEFINED";          break;
	}
    
    return (pwszFailPhase);
    }





static volatile BOOL       bContinue   = TRUE;
static volatile FAIL_PHASE fpFailPhase = PHASE_FREEZE;


class CVssWriterFailSnap : public CVssWriter
	{
public:
	    bool STDMETHODCALLTYPE OnIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata);
	    bool STDMETHODCALLTYPE OnPrepareBackup (IVssWriterComponents *pIVssWriterComponents);
	    bool STDMETHODCALLTYPE OnPrepareSnapshot ();
	    bool STDMETHODCALLTYPE OnFreeze ();
	    bool STDMETHODCALLTYPE OnThaw ();
	    bool STDMETHODCALLTYPE OnAbort ();
	    bool STDMETHODCALLTYPE OnBackupComplete (IVssWriterComponents *pIVssWriterComponents);
	    bool STDMETHODCALLTYPE OnPostRestore (IVssWriterComponents *pIVssWriterComponents);
};



bool STDMETHODCALLTYPE CVssWriterFailSnap::OnIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata)
    {
    bool	bPhaseSucceeded = (PHASE_IDENTIFY != fpFailPhase);
    HRESULT	hrStatus        = SelectFailureStatus ();

    if (bPhaseSucceeded)
	{
	hrStatus = pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							    NULL,
							    L"Failsnap Writer Component",
							    L"Failsnap Writer Caption",
							    NULL, // icon
							    0,
							    true,
							    false,
							    false);

	bPhaseSucceeded = SUCCEEDED (hrStatus);
	}


    wprintf (L"\nThreadId 0x%04x - Received event - OnIdentify ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnPrepareBackup (IVssWriterComponents *pIVssWriterComponents)
    {
    bool	bPhaseSucceeded = (PHASE_PREPARE_FOR_BACKUP != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnPrepareBackup ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnPrepareSnapshot ()
    {
    bool	bPhaseSucceeded = (PHASE_PREPARE_FOR_SNAPSHOT != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnPrepareSnapshot ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnFreeze ()
    {
    bool	bPhaseSucceeded = (PHASE_FREEZE != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnFreeze ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnThaw ()
    {
    bool	bPhaseSucceeded = (PHASE_THAW != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnThaw ()%s%s", 
	     GetCurrentThreadId (),
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnAbort ()
    {
    bool	bPhaseSucceeded = (PHASE_ABORT != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnAbort ()%s%s",
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnBackupComplete (IVssWriterComponents *pIVssWriterComponents)
    {
    bool	bPhaseSucceeded = (PHASE_BACKUP_COMPLETE != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnBackupComplete ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnPostRestore (IVssWriterComponents *pIVssWriterComponents)
    {
    bool	bPhaseSucceeded = (PHASE_RESTORE != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnPostRestore ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }






static BOOL AssertPrivilege (LPCWSTR privName)
    {
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if (OpenProcessToken (GetCurrentProcess (), TOKEN_ADJUST_PRIVILEGES, &tokenHandle))
	{
        LUID value;

        if (LookupPrivilegeValue (NULL, privName, &value))
	    {
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            /*
            ** We will always call GetLastError below, so clear
            ** any prior error values on this thread.
            */
            SetLastError (ERROR_SUCCESS);

            stat = AdjustTokenPrivileges (tokenHandle,
					  FALSE,
					  &newState,
					  (DWORD)0,
					  NULL,
					  NULL);

            /*
            ** Supposedly, AdjustTokenPriveleges always returns TRUE
            ** (even when it fails). So, call GetLastError to be
            ** extra sure everything's cool.
            */
            if ((error = GetLastError()) != ERROR_SUCCESS)
		{
                stat = FALSE;
		}

            if (!stat)
		{
                wprintf (L"AdjustTokenPrivileges for %s failed with 0x%08X",
			 privName,
			 error);
		}
	    }


        CloseHandle (tokenHandle);
	}

    return stat;
    }



BOOL WINAPI CtrlC_HandlerRoutine (IN DWORD /* dwType */)
	{
	bContinue = FALSE;

	// Mark that the break was handled.
	return TRUE;
	}



extern "C" int __cdecl wmain (int argc, WCHAR *argv[])
    {
    HRESULT		 hrStatus            = NOERROR;
    CVssWriterFailSnap	*pCVssWriterFailSnap = NULL;
    BOOL		 bSucceeded          = FALSE;
    BOOL		 bComInitialized     = FALSE;
    BOOL		 bSubscribed         = FALSE;
    VSS_USAGE_TYPE	 wtWriterType        = VSS_UT_USERDATA;
    const GUID		 guidIdWriter        = {0xd335a99e,
						0x57fb,
						0x4b80,
						    {0x85, 0xb1, 0x15, 0xda, 0xa7, 0xc7, 0x4e, 0x14}};


    srand ((unsigned)time (NULL));

    SetConsoleCtrlHandler(CtrlC_HandlerRoutine, TRUE);


    if ((argc >= 2) && (wcslen (argv[1]) > 0))
	{
	switch (*argv[1])
	    {
	    case L'I': case L'i': fpFailPhase = PHASE_IDENTIFY;             break;
	    case L'B': case L'b': fpFailPhase = PHASE_PREPARE_FOR_BACKUP;   break;
	    case L'S': case L's': fpFailPhase = PHASE_PREPARE_FOR_SNAPSHOT; break;
	    case L'F': case L'f': fpFailPhase = PHASE_FREEZE;               break;
	    case L'T': case L't': fpFailPhase = PHASE_THAW;                 break;
	    case L'A': case L'a': fpFailPhase = PHASE_ABORT;                break;
	    case L'C': case L'c': fpFailPhase = PHASE_BACKUP_COMPLETE;      break;
	    case L'R': case L'r': fpFailPhase = PHASE_RESTORE;              break;

	    default:
		wprintf (L"\nFAILSNAP [phase] [writer type]"
			 L"\n\n\tFailPhases"
			 L"\n\t\ti - Identify"
			 L"\n\t\tb - PrepareForBackup"
			 L"\n\t\ts - PrepareForSnapshot"
			 L"\n\t\tf - Freeze                (default)"
			 L"\n\t\tt - Thaw"
			 L"\n\t\ta - Abort"
			 L"\n\t\tc - BackupComplete"
			 L"\n\t\tr - PostRestore"

			 L"\n\n\tWriterTypes"
			 L"\n\t\tb - BootableState writer"
			 L"\n\t\ts - ServiceState writer"
			 L"\n\t\tu - UserData writer       (default)"
			 L"\n\t\to - Other writer"
			 L"\n");



		bContinue = FALSE;
		break;
	    }
	}



    if ((argc >= 3) && (wcslen (argv[2]) > 0))
	{
	switch (*argv[2])
	    {
	    case L'B': case L'b': wtWriterType = VSS_UT_BOOTABLESYSTEMSTATE; break;
	    case L'S': case L's': wtWriterType = VSS_UT_SYSTEMSERVICE;       break;
	    case L'U': case L'u': wtWriterType = VSS_UT_USERDATA;            break;
	    case L'O': case L'o': wtWriterType = VSS_UT_OTHER;               break;

	    default:
		bContinue = FALSE;
		break;
	    }
	}





    if (bContinue)
	{
	wprintf (L"\nSetting up %s writer to fail %s requests (ProcessId 0x%04x)",
		 GetStringFromWriterType (wtWriterType),
		 GetStringFromFailPhase  (fpFailPhase),
		 GetCurrentProcessId ());


	wprintf (L"\nChecking privileges");

	bSubscribed = AssertPrivilege (SE_BACKUP_NAME);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);


	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nAssertPrivilege returned error 0x%08X", hrStatus);
	    }

	}


    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nInitializing COM");

	hrStatus = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nCoInitialize() returned error 0x%08X", hrStatus);
	    }

	else
	    {
	    bComInitialized = TRUE;
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nConstructing Writer");

	pCVssWriterFailSnap = new CVssWriterFailSnap;

	if (NULL == pCVssWriterFailSnap)
	    {
	    hrStatus = HRESULT_FROM_WIN32 (ERROR_NOT_ENOUGH_MEMORY);

	    wprintf (L"\nFailed to allocate CVssWriterFailSnap : 0x%08X", hrStatus);
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	WCHAR	awchWriterName [256];


	wprintf (L"\nInitialising the writer");

	_snwprintf (awchWriterName, 
		    SIZEOF_ARRAY (awchWriterName), 
		    L"Microsoft Test Writer - FailSnap (%s/%s/0x%04x)",
		    GetStringFromWriterType (wtWriterType),
		    GetStringFromFailPhase  (fpFailPhase),
		    GetCurrentProcessId ());


	hrStatus = pCVssWriterFailSnap->Initialize (guidIdWriter,
						    awchWriterName,
						    wtWriterType,
						    VSS_ST_OTHER);

	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nFailed to initialize the writer : 0x%08X", hrStatus);
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nSubscribing to snapshot events");

	hrStatus = pCVssWriterFailSnap->Subscribe ();

	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nFailed to subscribe to snapshot events : 0x%08X", hrStatus);
	    }

	else
	    {
	    bSubscribed = TRUE;
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nWaiting for snapshot events (or Ctrl-C)");
	
	while (bContinue)
	    {
	    Sleep (100);
	    }
	}



    if (bSubscribed)
	{
	wprintf (L"\nUn-Subscribing from snapshot events");

	pCVssWriterFailSnap->Unsubscribe ();
	}


    if (NULL != pCVssWriterFailSnap)
	{
	wprintf (L"\nDeconstructing Writer");

	delete pCVssWriterFailSnap;
	}


    if (bComInitialized)
	{
	wprintf (L"\nUnInitialising COM");

	CoUninitialize();
	}

    return (hrStatus);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\betest\snapxml.cxx ===
#include "stdafx.hxx"
#include "vss.h"
#include "vswriter.h"
#include "vsbackup.h"
#include <debug.h>
#include <time.h>
#include <ntddstor.h>

#include <vs_inc.hxx>
#include <vsevent.h>
#include <vdslun.h>
#include <vscoordint.h>
#include <vs_wmxml.hxx>
#include <vs_cmxml.hxx>
#include <vs_trace.hxx>




static VSS_ID x_idSnapSet =
	{
	0xD79FE5AD, 0x767F, 0x4251,
	0xA9, 0x7A, 0x37, 0x37, 0xd0, 0xf9, 0xf7, 0x4f
	};



static VSS_ID x_idSnap1 =
	{
    0x78B049FB, 0x9D12, 0x40A6,
	0x82, 0x6C, 0xED, 0x8A, 0x80, 0x4E, 0xB4, 0xAA
	};

static VSS_ID x_idSnap2 =
	{
	0xE700B0EC, 0xA993, 0x4B1B,
	0xAD, 0xDA, 0xC2, 0xAA, 0x08, 0x53, 0x6F, 0x27
	};

static VSS_ID x_idProv =
	{
	0x587E6660, 0x3FEF, 0x45D6,
	0x8D, 0x91, 0xB1, 0x2E, 0x16, 0xAC, 0x5C, 0x18
	};

void GetAndValidateSnapshots
	(
	IN IVssSnapshotSetDescription *pSnapshotSet,
	OUT IVssSnapshotDescription **ppSnapshot1,
	OUT IVssSnapshotDescription **ppSnapshot2,
	OUT VSS_ID &idSnap1,
	OUT VSS_ID &idSnap2
	)
	{
	HRESULT hr;

	UINT cSnapshots;
	CHECK_SUCCESS(pSnapshotSet->GetSnapshotCount(&cSnapshots));
	if (cSnapshots != 2)
		{
		wprintf(L"Number of snapshots %d is not correct.\n");
		BS_ASSERT(FALSE);
		throw(E_UNEXPECTED);
		}

	VSS_ID idProv;
	CHECK_SUCCESS(pSnapshotSet->GetSnapshotDescription(0, ppSnapshot1));
	CHECK_SUCCESS(pSnapshotSet->GetSnapshotDescription(1, ppSnapshot2));
	CHECK_SUCCESS((*ppSnapshot1)->GetSnapshotId(&idSnap1));
	CHECK_SUCCESS((*ppSnapshot2)->GetSnapshotId(&idSnap2));
	if ((idSnap1 != x_idSnap1 || idSnap2 != x_idSnap2) &&
		(idSnap1 != x_idSnap2 || idSnap2 != x_idSnap1))
		Error(E_UNEXPECTED,
			  L"Snapshots were not added properly.  Added snapshots are:\n"
			  WSTR_GUID_FMT L" and " WSTR_GUID_FMT
			  L"\nFound snapshots are" WSTR_GUID_FMT L" and "
			  WSTR_GUID_FMT L"\n",
			  GUID_PRINTF_ARG(x_idSnap1),
			  GUID_PRINTF_ARG(x_idSnap2),
			  GUID_PRINTF_ARG(idSnap1),
			  GUID_PRINTF_ARG(idSnap2));


	CHECK_SUCCESS((*ppSnapshot1)->GetProviderId(&idProv));
	if (idProv != x_idProv)
		Error(E_UNEXPECTED,
			  L"Provider id was not correct.\n"
			  WSTR_GUID_FMT L" != " WSTR_GUID_FMT L".\n",
			  GUID_PRINTF_ARG(idProv),
			  GUID_PRINTF_ARG(x_idProv));


	CHECK_SUCCESS((*ppSnapshot2)->GetProviderId(&idProv));
	if (idProv != x_idProv)
		Error(E_UNEXPECTED,
			  L"Provider id was not correct.\n"
			  WSTR_GUID_FMT L" != " WSTR_GUID_FMT L".\n",
			  GUID_PRINTF_ARG(idProv),
			  GUID_PRINTF_ARG(x_idProv));

	}


void ValidateSnapshotSet(IVssSnapshotSetDescription *pSnapshotSet)
	{
	HRESULT hr;
	VSS_ID idSnapSet;

	CHECK_SUCCESS(pSnapshotSet->GetSnapshotSetId(&idSnapSet));
	if (idSnapSet != x_idSnapSet)
		Error(E_UNEXPECTED, L"snapshot set id does not match: "
			  WSTR_GUID_FMT L" != " WSTR_GUID_FMT,
			  GUID_PRINTF_ARG(idSnapSet),
			  GUID_PRINTF_ARG(x_idSnapSet));


	CComBSTR bstrDescription;
	CComBSTR bstrMetadata;
	CHECK_SUCCESS(pSnapshotSet->GetDescription(&bstrDescription));
	if (wcscmp(bstrDescription, L"This is a test snapshot set") != 0)
		Error(E_UNEXPECTED, L"Snapshot description is invalid:\n%s", bstrDescription);

	CHECK_SUCCESS(pSnapshotSet->GetMetadata(&bstrMetadata));
	if (wcscmp(bstrMetadata, L"This is some test metadata for the snapshot set.") != 0)
		Error(E_UNEXPECTED, L"Snapshot metadata is invalid:\n%s", bstrMetadata);

	LONG lContext;
	CHECK_SUCCESS(pSnapshotSet->GetContext(&lContext));
	if (lContext != VSS_CTX_BACKUP)
		Error(E_UNEXPECTED, L"Context is invalid. lContext=%d\n", lContext);
	}

VSS_SNAPSHOT_PROP rgSnapshotProp[2];

static UCHAR x_DeviceType1 = 1;
static UCHAR x_DeviceType2 = 2;

static UCHAR x_DeviceTypeModifier1 = 100;
static UCHAR x_DeviceTypeModifier2 = 200;

static ULONGLONG x_rgDiskExtents1[] = {10L, 2000L, 4000L, 1000L};
static UINT x_cDiskExtents1 = 2;

static ULONGLONG x_rgDiskExtents2[] = {100L, 1000L, 2000L, 10000L, 100000L, 4000L};
static UINT x_cDiskExtents2 = 3;

static LPCSTR x_szVendorId1 = "MICROSOFT";
static LPCSTR x_szVendorId2 = "PLATFORMS";

static LPCSTR x_szProductId1 = "LVM";
static LPCSTR x_szProductId2 = "VDS";

static LPCSTR x_szProductRevision1 = "1.0";
static LPCSTR x_szProductRevision2 = "2.1";

static LPCSTR x_szSerialNumber1S = "123987";
static LPCSTR x_szSerialNumber1D = "343434";

static LPCSTR x_szSerialNumber2S = "999999-1111";
static LPCSTR x_szSerialNumber2D = "888888-2222";


static VDS_STORAGE_BUS_TYPE x_busType1 = VDSBusTypeScsi;
static VDS_STORAGE_BUS_TYPE x_busType2 = VDSBusTypeFibre;



static VSS_ID x_idDiskSignature1 =
	{
    0xF1CFF9EC, 0xB0A3, 0x408C,
	0xB5, 0xC9, 0x0C, 0x98, 0xDF, 0xFD, 0xDA, 0xED
	};

static VSS_ID x_idDiskSignature2 =
	{
    0xB33FF922, 0xB0A3, 0x408C,
	0xB5, 0xC9, 0x0C, 0x98, 0xDF, 0xFD, 0xDA, 0xED
	};

static VDS_INTERCONNECT_ADDRESS_TYPE x_rgIAType1S[] = {VDS_IA_FCFS, VDS_IA_FCFS, VDS_IA_FCFS};
static LPCSTR x_rgszAddresses1S[] = {"CAB1.BUS10.SLOT10", "CAB1.BUS20.SLOT30", "CAB20.BUS3.SLOT100"};
static UINT x_cInterconnectAddresses1S = 3;

static VDS_INTERCONNECT_ADDRESS_TYPE x_rgIAType1D[] = {VDS_IA_FCFS, VDS_IA_FCFS, VDS_IA_FCFS};
static LPCSTR x_rgszAddresses1D[] = {"CAB1.BUS1.SLOT10", "CAB1.BUS2.SLOT30", "CAB2.BUS3.SLOT10"};
static UINT x_cInterconnectAddresses1D = 3;


static VDS_INTERCONNECT_ADDRESS_TYPE rgIAType2S[] = {VDS_IA_FCPH};
static LPCSTR x_rgszAddresses2S[] = {"10.1.1.4.BUS1.SLOT10"};
static UINT x_cInterconnectAddresses2S = 1;

static VDS_INTERCONNECT_ADDRESS_TYPE rgIAType2D[] = {VDS_IA_FCPH};
static LPCSTR x_rgszAddresses2D[] = {"100.2.3.8.BUS11.SLOT10"};
static UINT x_cInterconnectAddresses2D = 1;

static STORAGE_IDENTIFIER x_storeid1 = {StorageIdCodeSetBinary, StorageIdTypeVendorId, 8, 0, StorageIdAssocDevice, 0};
static STORAGE_IDENTIFIER x_storeid2 = {StorageIdCodeSetBinary, StorageIdTypeVendorSpecific, 20, 0, StorageIdAssocDevice, 0};
static STORAGE_IDENTIFIER x_storeid3 = {StorageIdCodeSetAscii, StorageIdTypeFCPHName, 32, 0, StorageIdAssocDevice, 0};
static STORAGE_IDENTIFIER x_storeid4 = {StorageIdCodeSetBinary, StorageIdTypeEUI64, 8, 0, StorageIdAssocDevice, 0};

void AddIdentifier(BYTE **ppb, STORAGE_IDENTIFIER *pid, UINT &ib)
	{
	if (pid)
		{
		UINT cb = pid->IdentifierSize + FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);

		memcpy(*ppb, pid, FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier));
		ib += cb;
		((STORAGE_IDENTIFIER *) (*ppb))->NextOffset = (USHORT) ib;
		memset(*ppb + FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier), 0x10, pid->IdentifierSize);
		*ppb += cb;
		}
	}

void BuildStorageIdDescriptor
	(
	STORAGE_DEVICE_ID_DESCRIPTOR **ppstore,
	STORAGE_IDENTIFIER *pid1,
	STORAGE_IDENTIFIER *pid2,
	STORAGE_IDENTIFIER *pid3,
	STORAGE_IDENTIFIER *pid4
	)
	{
	UINT cid = 0;
	UINT cb = FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR, Identifiers);
	if (pid1)
		{
		cid++;
		cb += pid1->IdentifierSize + FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);
		}

	if (pid2)
		{
		cid++;
		cb += pid2->IdentifierSize + FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);
		}

	if (pid3)
		{
		cid++;
		cb += pid3->IdentifierSize + FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);
		}

	if (pid4)
		{
		cid++;
		cb += pid4->IdentifierSize + FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);
		}

	BYTE *pb = new BYTE[cb];
	STORAGE_DEVICE_ID_DESCRIPTOR *pstore = (STORAGE_DEVICE_ID_DESCRIPTOR *) pb;
	pstore->Version = 10;
	pstore->Size = cb;
	pstore->NumberOfIdentifiers = cid;
	pb = pstore->Identifiers;
	UINT ib = FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR, Identifiers);

	AddIdentifier(&pb, pid1, ib);
	AddIdentifier(&pb, pid2, ib);
	AddIdentifier(&pb, pid3, ib);
	AddIdentifier(&pb, pid4, ib);

	BS_ASSERT(ib == cb);
	*ppstore = pstore;
	}

typedef struct _BETEST_LUN_INFO
	{
	UCHAR DeviceType;
	UCHAR DeviceTypeModifier;
	ULONGLONG *rgDiskExtents;
	UINT cDiskExtents;
	LPCSTR szVendorId;
	LPCSTR szProductId;
	LPCSTR szProductRevision;
	LPCSTR szSerialNumberSource;
	LPCSTR szSerialNumberDest;
	VDS_STORAGE_BUS_TYPE busType;
	VSS_ID idDiskSignature;
	VDS_INTERCONNECT_ADDRESS_TYPE *rgiatypeS;
	VDS_INTERCONNECT_ADDRESS_TYPE *rgiatypeD;
	LPCSTR	*rgszIAS;
	LPCSTR *rgszIAD;
	UINT cIAS;
	UINT cIAD;
	STORAGE_DEVICE_ID_DESCRIPTOR *pstoreS;
	STORAGE_DEVICE_ID_DESCRIPTOR *pstoreD;
	} BETEST_LUN_INFO;


void BuildLunInfo (UINT i, BETEST_LUN_INFO &info)
	{
	if (i == 1)
		{
		info.DeviceType = x_DeviceType1;
		info.DeviceTypeModifier = x_DeviceTypeModifier1;
		info.rgDiskExtents = x_rgDiskExtents1;
		info.cDiskExtents = x_cDiskExtents1;
		info.szVendorId = x_szVendorId1;
		info.szProductId = x_szProductId1;
		info.szProductRevision = x_szProductRevision1;
		info.szSerialNumberSource = x_szSerialNumber1S;
		info.szSerialNumberDest = x_szSerialNumber1D;
		info.busType = x_busType1;
		info.idDiskSignature = x_idDiskSignature1;
		info.rgiatypeS = x_rgIAType1S;
		info.rgiatypeD = x_rgIAType1D;
		info.rgszIAS = x_rgszAddresses1S;
		info.rgszIAD = x_rgszAddresses1D;
		info.cIAS = x_cInterconnectAddresses1S;
		info.cIAD = x_cInterconnectAddresses1D;
		BuildStorageIdDescriptor(&info.pstoreS, &x_storeid1, &x_storeid3, NULL, NULL);
		BuildStorageIdDescriptor(&info.pstoreD, &x_storeid1, &x_storeid3, &x_storeid4, NULL);
		}
	else
		{
		info.DeviceType = x_DeviceType2;
		info.DeviceTypeModifier = x_DeviceTypeModifier2;
		info.rgDiskExtents = x_rgDiskExtents2;
		info.cDiskExtents = x_cDiskExtents2;
		info.szVendorId = x_szVendorId2;
		info.szProductId = x_szProductId2;
		info.szProductRevision = x_szProductRevision2;
		info.szSerialNumberSource = x_szSerialNumber2S;
		info.szSerialNumberDest = x_szSerialNumber2D;
		info.busType = x_busType2;
		info.idDiskSignature = x_idDiskSignature2;
		info.rgiatypeS = rgIAType2S;
		info.rgiatypeD = rgIAType2D;
		info.rgszIAS = x_rgszAddresses2S;
		info.rgszIAD = x_rgszAddresses2D;
		info.cIAS = x_cInterconnectAddresses2S;
		info.cIAD = x_cInterconnectAddresses2D;
		BuildStorageIdDescriptor(&info.pstoreS, &x_storeid1, &x_storeid2, NULL, NULL);
		BuildStorageIdDescriptor(&info.pstoreD, &x_storeid1, &x_storeid2, &x_storeid3, &x_storeid4);
		}
	}


void AddLunInfo(IVssLunMapping *pLunMapping, UINT i)
	{
	HRESULT hr;

	CComPtr<IVssLunInformation> pSourceLun;
	CComPtr<IVssLunInformation> pDestLun;
	BETEST_LUN_INFO info;

	BuildLunInfo(i, info);

	CHECK_SUCCESS(pLunMapping->GetSourceLun(&pSourceLun));
	CHECK_SUCCESS(pLunMapping->GetDestinationLun(&pDestLun));

	CHECK_SUCCESS(pSourceLun->SetLunBasicType
					  (
					  info.DeviceType,
					  info.DeviceTypeModifier,
					  true,
					  info.szVendorId,
					  info.szProductId,
					  info.szProductRevision,
					  info.szSerialNumberSource,
					  info.busType
					  ));

	CHECK_SUCCESS(pDestLun->SetLunBasicType
					  (
					  info.DeviceType,
					  info.DeviceTypeModifier,
					  true,
					  info.szVendorId,
					  info.szProductId,
					  info.szProductRevision,
					  info.szSerialNumberDest,
					  info.busType
					  ));

	CHECK_SUCCESS(pSourceLun->SetDiskSignature(info.idDiskSignature));
	CHECK_SUCCESS(pDestLun->SetDiskSignature(info.idDiskSignature));
	for(UINT iExtent = 0; iExtent < info.cDiskExtents; iExtent++)
		CHECK_SUCCESS(pLunMapping->AddDiskExtent
						(
						info.rgDiskExtents[iExtent * 2],
						info.rgDiskExtents[iExtent * 2 + 1]
						));

	for(UINT iIAS = 0; iIAS < info.cIAS; iIAS++)
		CHECK_SUCCESS(pSourceLun->AddInterconnectAddress
							(
							info.rgiatypeS[iIAS],
							0,
							NULL,
							(UINT) (strlen(info.rgszIAS[iIAS]) + 1),
							(const BYTE *) info.rgszIAS[iIAS]
							));

	for(UINT iIAD = 0; iIAD < info.cIAD; iIAD++)
		CHECK_SUCCESS(pDestLun->AddInterconnectAddress
							(
							info.rgiatypeD[iIAD],
							3,
							(BYTE *) "foo",
							(UINT) (strlen(info.rgszIAD[iIAD]) + 1),
							(const BYTE *) info.rgszIAD[iIAD]
							));

	CHECK_SUCCESS(pSourceLun->SetStorageDeviceIdDescriptor(info.pstoreS));
	CHECK_SUCCESS(pDestLun->SetStorageDeviceIdDescriptor(info.pstoreD));
    }

bool cmp_str_eq(LPCSTR sz1, LPCSTR sz2)
	{
	return (sz1 == NULL && sz2 == NULL) ||
	       (sz1 != NULL && sz2 != NULL && strcmp(sz1, sz2) == 0);
	}

void DoCoTaskFree
	(
	LPSTR &str1,
	LPSTR &str2,
	LPSTR &str3,
	LPSTR &str4
	)
	{
	if (str1)
		{
		CoTaskMemFree(str1);
		str1 = NULL;
		}

	if (str2)
		{
		CoTaskMemFree(str2);
		str2 = NULL;
		}

	if (str3)
		{
		CoTaskMemFree(str3);
		str3 = NULL;
		}

	if (str4)
		{
		CoTaskMemFree(str4);
		str4 = NULL;
		}
	}

void ValidateLunInfo(IVssLunMapping *pLunMapping, UINT i)
	{
	HRESULT hr;

	CComPtr<IVssLunInformation> pSourceLun;
	CComPtr<IVssLunInformation> pDestLun;
	BETEST_LUN_INFO info;

	BuildLunInfo(i, info);

	CHECK_SUCCESS(pLunMapping->GetSourceLun(&pSourceLun));
	CHECK_SUCCESS(pLunMapping->GetDestinationLun(&pDestLun));

	UINT cExtents;
	CHECK_SUCCESS(pLunMapping->GetDiskExtentCount(&cExtents));
	if (cExtents != info.cDiskExtents)
		Error(E_UNEXPECTED, L"Invalid number of extents for lun %d", i);

	for(UINT iExtent = 0; iExtent < cExtents; iExtent++)
		{
		ULONGLONG start, length;
		CHECK_SUCCESS(pLunMapping->GetDiskExtent(iExtent, &start, &length));
		if (start != info.rgDiskExtents[iExtent * 2] ||
			length != info.rgDiskExtents[iExtent * 2 + 1])
			Error(E_UNEXPECTED, L"Invalid extent %d for lun %d", iExtent, i);
		}

	LPSTR strVendorId;
	LPSTR strProductId;
	LPSTR strProductRevision;
	LPSTR strSerialNumber;
	VDS_STORAGE_BUS_TYPE busTypeFound;
	UCHAR DeviceTypeFound;
	UCHAR DeviceTypeModifierFound;
	BOOL bCommandQueueing;

	CHECK_SUCCESS(pSourceLun->GetLunBasicType
					  (
					  &DeviceTypeFound,
					  &DeviceTypeModifierFound,
					  &bCommandQueueing,
					  &strVendorId,
					  &strProductId,
					  &strProductRevision,
					  &strSerialNumber,
					  &busTypeFound
					  ));

    if (DeviceTypeFound != info.DeviceType ||
		DeviceTypeModifierFound != info.DeviceTypeModifier ||
		busTypeFound != info.busType ||
		!bCommandQueueing ||
		!cmp_str_eq(strVendorId, info.szVendorId) ||
		!cmp_str_eq(strProductId, info.szProductId) ||
		!cmp_str_eq(strProductRevision, info.szProductRevision) ||
		!cmp_str_eq(strSerialNumber, info.szSerialNumberSource))
		{
		DoCoTaskFree(strVendorId, strProductId, strProductRevision, strSerialNumber);
		Error(E_UNEXPECTED, L"Problem in basic LUN information for source %d.\n", i);
		}

	DoCoTaskFree(strVendorId, strProductId, strProductRevision, strSerialNumber);

	CHECK_SUCCESS(pDestLun->GetLunBasicType
					  (
					  &DeviceTypeFound,
					  &DeviceTypeModifierFound,
					  &bCommandQueueing,
					  &strVendorId,
					  &strProductId,
					  &strProductRevision,
					  &strSerialNumber,
					  &busTypeFound
					  ));

    if (DeviceTypeFound != info.DeviceType ||
		DeviceTypeModifierFound != info.DeviceTypeModifier ||
		busTypeFound != info.busType ||
		!cmp_str_eq(strVendorId, info.szVendorId) ||
		!cmp_str_eq(strProductId, info.szProductId)  ||
		!cmp_str_eq(strProductRevision, info.szProductRevision) ||
		!cmp_str_eq(strSerialNumber, info.szSerialNumberDest))
		{
		DoCoTaskFree(strVendorId, strProductId, strProductRevision, strSerialNumber);
		Error(E_UNEXPECTED, L"Problem in basic LUN information four destination %d.\n", i);
		}

	DoCoTaskFree(strVendorId, strProductId, strProductRevision, strSerialNumber);

	VSS_ID idDiskSignatureFound;

	CHECK_SUCCESS(pSourceLun->GetDiskSignature(&idDiskSignatureFound));
	if (info.idDiskSignature != idDiskSignatureFound)
		Error(E_UNEXPECTED, L"Disk signatures do not match for source %d.\n", i);

	CHECK_SUCCESS(pDestLun->GetDiskSignature(&idDiskSignatureFound));
	if (info.idDiskSignature != idDiskSignatureFound)
		Error(E_UNEXPECTED, L"Disk signatures do not match for destination %d.\n", i);

	UINT cia;

	CHECK_SUCCESS(pSourceLun->GetInterconnectAddressCount(&cia));
	if (cia != info.cIAS)
		Error(E_UNEXPECTED, L"Interconnect address count does not match for source %d", i);

	CHECK_SUCCESS(pDestLun->GetInterconnectAddressCount(&cia));
	if (cia != info.cIAD)
		Error(E_UNEXPECTED, L"Interconnect address count does not match for source %d", i);

	for(UINT iIAS = 0; iIAS < info.cIAS; iIAS++)
		{
		VDS_INTERCONNECT_ADDRESS_TYPE iat;
		LPBYTE pbAddress, pbPort;
		ULONG cbAddress, cbPort;

		CHECK_SUCCESS(pSourceLun->GetInterconnectAddress
						(
						iIAS,
						&iat,
						&cbPort,
						&pbPort,
						&cbAddress,
						&pbAddress
						));
		if (iat != info.rgiatypeS[iIAS] ||
			cbPort != 0 ||
			pbPort != NULL ||
			cbAddress != strlen(info.rgszIAS[iIAS]) + 1 ||
			strcmp((char *) pbAddress, info.rgszIAS[iIAS]) != 0)
			{
			CoTaskMemFree(pbAddress);
			Error(E_UNEXPECTED, L"Interconnect address %d does not match for source %d", iIAS, i);
			}

		if (pbAddress)
			CoTaskMemFree(pbAddress);

		if (pbPort)
			CoTaskMemFree(pbPort);
		}

	for(UINT iIAD = 0; iIAD < info.cIAD; iIAD++)
		{
		VDS_INTERCONNECT_ADDRESS_TYPE iat;
		LPBYTE pbAddress, pbPort;
		ULONG cbAddress, cbPort;

		CHECK_SUCCESS(pDestLun->GetInterconnectAddress
						(
						iIAD,
						&iat,
						&cbPort,
						&pbPort,
						&cbAddress,
						&pbAddress
						));
		if (iat != info.rgiatypeD[iIAD] ||
			cbPort != 3 ||
			memcmp(pbPort, "foo", 3) != 0  ||
			cbAddress != strlen(info.rgszIAD[iIAD]) + 1 ||
			strcmp((char *) pbAddress, info.rgszIAD[iIAD]) != 0)
			{
			CoTaskMemFree(pbAddress);
			CoTaskMemFree(pbPort);
			Error(E_UNEXPECTED, L"Interconnect address %d does not match for destination %d", iIAS, i);
			}

		if (pbPort)
			CoTaskMemFree(pbPort);

		if (pbAddress)
			CoTaskMemFree(pbAddress);
		}


	STORAGE_DEVICE_ID_DESCRIPTOR *pstoreFound;

	CHECK_SUCCESS(pSourceLun->GetStorageDeviceIdDescriptor(&pstoreFound));
	if (memcmp(pstoreFound, info.pstoreS, info.pstoreS->Size) != 0)
		{
		CoTaskMemFree(pstoreFound);
		Error(E_UNEXPECTED, L"Storage device descriptor does not match for source %d", i);
		}

	CoTaskMemFree(pstoreFound);

	CHECK_SUCCESS(pDestLun->GetStorageDeviceIdDescriptor(&pstoreFound));
	if (memcmp(pstoreFound, info.pstoreD, info.pstoreD->Size) != 0)
		{
		CoTaskMemFree(pstoreFound);
		Error(E_UNEXPECTED, L"Storage device descriptor does not match for destination %d", i);
		}

	CoTaskMemFree(pstoreFound);
	}		



void AddLunMappings(IVssSnapshotDescription *pSnapshot)
	{
	HRESULT hr;

	CComPtr<IVssLunMapping> pLunMapping1;
	CComPtr<IVssLunMapping> pLunMapping2;


	CHECK_SUCCESS(pSnapshot->AddLunMapping());
	CHECK_SUCCESS(pSnapshot->AddLunMapping());
	CHECK_SUCCESS(pSnapshot->GetLunMapping(0, &pLunMapping1));
	CHECK_SUCCESS(pSnapshot->GetLunMapping(1, &pLunMapping2));
	AddLunInfo(pLunMapping1, 1);
	AddLunInfo(pLunMapping2, 2);
	}

void ValidateLunMappings(IVssSnapshotDescription *pSnapshot)
	{
	HRESULT hr;

	CComPtr<IVssLunMapping> pLunMapping1;
	CComPtr<IVssLunMapping> pLunMapping2;
	UINT cMappings;

	CHECK_SUCCESS(pSnapshot->GetLunCount(&cMappings));
	if (cMappings != 2)
		Error(E_UNEXPECTED, L"Lun mapping count is incorrect");

	CHECK_SUCCESS(pSnapshot->GetLunMapping(0, &pLunMapping1));
	CHECK_SUCCESS(pSnapshot->GetLunMapping(1, &pLunMapping2));
	ValidateLunInfo(pLunMapping1, 1);
	ValidateLunInfo(pLunMapping2, 2);
	}


void ValidateSnapshot(IVssSnapshotDescription *pSnapshot, UINT iSnapshot)
	{
	HRESULT hr;

	VSS_SNAPSHOT_PROP *pProp = &rgSnapshotProp[iSnapshot];

	VSS_TIMESTAMP timestamp;
	LONG lAttributes;
	CComBSTR bstrOriginatingMachine;
	CComBSTR bstrServiceMachine;
	CComBSTR bstrOriginalVolumeName;
	CComBSTR bstrSnapshotDevice;

	CHECK_SUCCESS(pSnapshot->GetTimestamp(&timestamp));
	if (timestamp != pProp->m_tsCreationTimestamp)
		Error(E_UNEXPECTED, L"Timestamp mismatch on snapshot %d", iSnapshot);

	CHECK_SUCCESS(pSnapshot->GetAttributes(&lAttributes))
	if (lAttributes != pProp->m_lSnapshotAttributes)
		Error(E_UNEXPECTED, L"Attributes mismatch on snapshot %d", iSnapshot);

	CHECK_SUCCESS(pSnapshot->GetOrigin
						(
						&bstrOriginatingMachine,
						&bstrOriginalVolumeName
						));

	CHECK_SUCCESS(pSnapshot->GetServiceMachine
						(
						&bstrServiceMachine
						));

    if (wcscmp(bstrOriginatingMachine, pProp->m_pwszOriginatingMachine) != 0)
		Error(E_UNEXPECTED, L"Originating machine mismatch on snapshot %d.", iSnapshot);

	if (wcscmp(bstrOriginalVolumeName, pProp->m_pwszOriginalVolumeName) != 0)
		Error(E_UNEXPECTED, L"Original volume name mismatch on snapshot %d.", iSnapshot);

    if (wcscmp(bstrServiceMachine, pProp->m_pwszServiceMachine) != 0)
		Error(E_UNEXPECTED, L"Service machine mismatch on snapshot %d.", iSnapshot);

	CHECK_SUCCESS(pSnapshot->GetDeviceName(&bstrSnapshotDevice));
	if (wcscmp(bstrSnapshotDevice, pProp->m_pwszSnapshotDeviceObject) != 0)
		Error(E_UNEXPECTED, L"Snapshot device name mismatch on snapshot %d.", iSnapshot);

	if (iSnapshot == 2)
		{
		CComBSTR bstrExposedShare;
		CComBSTR bstrExposedPath;
		CHECK_SUCCESS(pSnapshot->GetExposure(&bstrExposedShare, &bstrExposedPath));

		if (wcscmp(bstrExposedShare, L"exposed1") != 0)
			Error(E_UNEXPECTED, L"Exposed share mismatch on snapshot %d.", iSnapshot);

		if (wcscmp(bstrExposedPath, L"thePath") != 0)
			Error(E_UNEXPECTED, L"Exposed path mismatch on snapshot %d.", iSnapshot);
		}

	ValidateLunMappings(pSnapshot);
	}

void AddSnapshotData(IVssSnapshotDescription *pSnapshot, UINT iSnapshot)
	{
	HRESULT hr;

	SYSTEMTIME time;

	VSS_SNAPSHOT_PROP *pProp = &rgSnapshotProp[iSnapshot];
	GetSystemTime(&time);
	LONGLONG timestamp;

	timestamp = time.wYear * 400 + time.wMonth * 31 + time.wDay;
	timestamp *= 3600000 * 24;
	timestamp += time.wMilliseconds + time.wSecond * 1000 + time.wMinute*60000+ time.wHour * 3600000;
	pProp->m_tsCreationTimestamp = timestamp;
	pProp->m_pwszSnapshotDeviceObject = iSnapshot == 1 ? L"Snapshot1" : L"Snapshot2";
	pProp->m_pwszOriginalVolumeName = iSnapshot == 1 ? L"Disk1" : L"Disk2";
	pProp->m_lSnapshotAttributes = VSS_CTX_BACKUP | VSS_VOLSNAP_ATTR_DIFFERENTIAL;
	WCHAR buf[1024];
	DWORD cb = 1024;
	GetComputerNameEx(ComputerNameDnsFullyQualified, buf, &cb);
	pProp->m_pwszOriginatingMachine = _wcsdup(buf);
    pProp->m_pwszServiceMachine = _wcsdup(buf);
	CHECK_SUCCESS(pSnapshot->SetTimestamp(pProp->m_tsCreationTimestamp));
	CHECK_SUCCESS(pSnapshot->SetAttributes(pProp->m_lSnapshotAttributes));
	CHECK_SUCCESS(pSnapshot->SetOrigin
						(
						pProp->m_pwszOriginatingMachine,
						pProp->m_pwszOriginalVolumeName
						));
	CHECK_SUCCESS(pSnapshot->SetServiceMachine
						(
						pProp->m_pwszServiceMachine
						));

	CHECK_SUCCESS(pSnapshot->SetDeviceName(pProp->m_pwszSnapshotDeviceObject));
	if (iSnapshot == 2)
		CHECK_SUCCESS(pSnapshot->SetExposure(L"exposed1", L"thePath"));

	AddLunMappings(pSnapshot);
	ValidateSnapshot(pSnapshot, iSnapshot);
	}




void TestSnapshotXML()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"TestSnapshotXML");

	HRESULT hr;

	try
		{
		CComPtr<IVssSnapshotSetDescription> pSnapshotSet;

		CHECK_SUCCESS(CreateVssSnapshotSetDescription
						(
						x_idSnapSet,
						VSS_CTX_BACKUP,
						&pSnapshotSet
						));



		CHECK_SUCCESS(pSnapshotSet->SetDescription(L"This is a test snapshot set"));
		CHECK_SUCCESS(pSnapshotSet->SetMetadata(L"This is some test metadata for the snapshot set."));

		ValidateSnapshotSet(pSnapshotSet);

		CHECK_SUCCESS(pSnapshotSet->AddSnapshotDescription(x_idSnap1, x_idProv));
		CHECK_SUCCESS(pSnapshotSet->AddSnapshotDescription(x_idSnap2, x_idProv));

		VSS_ID idSnap1, idSnap2;
		CComPtr<IVssSnapshotDescription> pSnapshot1;
		CComPtr<IVssSnapshotDescription> pSnapshot2;

		GetAndValidateSnapshots(pSnapshotSet, &pSnapshot1, &pSnapshot2, idSnap1, idSnap2);

		AddSnapshotData(pSnapshot1, idSnap1 == x_idSnap1 ? 1 : 2);
		AddSnapshotData(pSnapshot2, idSnap2 == x_idSnap1 ? 1 : 2);
		pSnapshot1 = NULL;
		pSnapshot2 = NULL;

		CComBSTR bstrXML;
		CHECK_SUCCESS(pSnapshotSet->SaveAsXML(&bstrXML));
		pSnapshotSet = NULL;

		CHECK_SUCCESS(LoadVssSnapshotSetDescription(bstrXML, &pSnapshotSet));

		ValidateSnapshotSet(pSnapshotSet);
		GetAndValidateSnapshots(pSnapshotSet, &pSnapshot1, &pSnapshot2, idSnap1, idSnap2);
        ValidateSnapshot(pSnapshot1, idSnap1 == x_idSnap1 ? 1 : 2);
		ValidateSnapshot(pSnapshot2, idSnap2 == x_idSnap1 ? 1 : 2);
		}
	VSS_STANDARD_CATCH(ft)

	if (ft.HrFailed())
		wprintf(L"Snapshot XML test failed with hr = 0x%08lx\n", ft.hr);
	else
		wprintf(L"Snapshot XML test succeeded\n");
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\hwprv\src\hwprv.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module hwprv.hxx | Definition the COM server of the Software Snapshot provider
    @end

Author:

    Adi Oltean  [aoltean]   07/13/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.
    aoltean     09/09/1999  dss->vss

--*/


///////////////////////////////////////////////////////////////////////////////
//   Includes
//


#include "stdafx.hxx"
#include <process.h>
#include "initguid.h"

// Generated MIDL header
#include "vss.h"
#include "vdslun.h"
#include "vsprov.h"
#include "vscoordint.h"

#include "resource.h"
#include "vs_inc.hxx"
#include "vssmsg.h"

#include "hwprv.hxx"
#include "hwprv.h"

#include "provider.hxx"

#include <comadmin.h>
#include "comadmin.hxx"

VSS_ID g_ProviderId =
	{
	0x04AAF00B, 0xF272, 0x4449,
	0xAE, 0x63, 0xE8, 0xAC, 0x93, 0x5A, 0x10, 0x2B
	};


VSS_ID g_ProviderVersion =
	{
	0xEE12C84C, 0x9345, 0x4FE8,
	0xBB, 0xA8, 0x67, 0xC1, 0x7D, 0xE4, 0x75, 0x34
	};

/////////////////////////////////////////////////////////////////////////////
// Constants



const WCHAR g_wszAppName[]  = L"MS Test Hardware Snapshot Provider";
const WCHAR g_wszSvcName[]  = L"HwPrv";
const WCHAR g_wszDllName[]  = L"\\HWPRV.DLL";

const MAX_STRING_RESOURCE_LEN = 1024;

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "THWHWPRC"
//
////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//   Static objects
//

CHwPrvSnapshotSrvModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_HardwareTestProvider, CHardwareTestProvider)
END_OBJECT_MAP()


///////////////////////////////////////////////////////////////////////////////////////
//  COM Server registration
//

HRESULT GetDllPathName(
	IN	INT nBufferLength, // Does not include terminating zero character
    IN  LPCWSTR wszDllName,
    OUT LPWSTR wszDllPath
    )
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"GetDllPathName" );

    try
    {
		WCHAR wszDir[MAX_PATH];
        if (!::GetCurrentDirectory(MAX_PATH, wszDir)) {
            ft.LogError(VSS_ERROR_GETTING_CURRENT_DIR, VSSDBG_VSSTEST << HRESULT_FROM_WIN32(GetLastError()) );
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED,
				L"Error on getting the current path. hr = 0x%08lx",
                HRESULT_FROM_WIN32(GetLastError()));
        }

        if ( ::wcslen(wszDir) +
			 ::wcslen(wszDllName) >= (size_t) nBufferLength )
            ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

        ::_snwprintf(wszDllPath, nBufferLength,
				L"%s%s", wszDir, wszDllName);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}

void MakeChangeable(bool fChangeable)
	{
	CVssFunctionTracer ft(VSSDBG_VSSTEST, L"MakeChangeable");

	CVssCOMAdminCatalog     catalog;
	ft.hr = catalog.Attach(g_wszAppName);
	if (ft.HrFailed())
		ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in initializing the catalog object 0x%08lx", ft.hr);

	// Get the list of applications
	CVssCOMCatalogCollection appsList(VSS_COM_APPLICATIONS);
	ft.hr = appsList.Attach(catalog);
	if (ft.HrFailed())
		ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in initializing the apps collection object 0x%08lx", ft.hr);

	CVssCOMApplication application;
	ft.hr = application.AttachByName( appsList, catalog.GetAppName() );
	if (ft.HrFailed())
		ft.LogError(VSS_ERROR_ATTACH_COLL_BY_NAME, VSSDBG_VSSTEST << catalog.GetAppName() << ft.hr);


	// if the application doesn't exist then return
	if (ft.hr == S_FALSE)
		return;

	application.m_bChangeable = fChangeable;
	application.m_bDeleteable = fChangeable;
	ft.hr = appsList.SaveChanges();
	if (ft.HrFailed())
		{
		ft.TraceComError();
		ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in commiting changes. hr = 0x%08lx", ft.hr);
		}
	}

HRESULT RegisterNewCOMApp()
{
    CVssFunctionTracer ft( VSSDBG_VSSTEST, L"RegisterNewCOMApp" );

    try
    {
		MakeChangeable(true);
        //
        // Initialize the catalog
        //

        CVssCOMAdminCatalog     catalog;
        ft.hr = catalog.Attach(g_wszAppName);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in initializing the catalog object 0x%08lx", ft.hr);

        //
        //  Create a new application, if doesn't exist yet.
        //

        // Get the list of applications
        CVssCOMCatalogCollection appsList(VSS_COM_APPLICATIONS);
        ft.hr = appsList.Attach(catalog);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in initializing the apps collection object 0x%08lx", ft.hr);

		// Check if the application already exists - to solve the upgrade between different OS versions.
		// If the application doesn't exist then insert a new application
        CVssCOMApplication application;
		ft.hr = application.AttachByName( appsList, catalog.GetAppName() );
		if (ft.HrFailed()) {
            ft.LogError(VSS_ERROR_ATTACH_COLL_BY_NAME, VSSDBG_VSSTEST << catalog.GetAppName() << ft.hr);
		}
		
		if (ft.hr == S_OK)
			{
			// the application exits.  delete it
			LONG lIndex = application.GetIndex();
			BS_ASSERT(lIndex != -1);
			ft.hr = appsList.GetInterface()->Remove(lIndex);
			if (ft.HrFailed())
				{
				ft.LogError(VSS_ERROR_REMOVING_APPLICATION, VSSDBG_COORD << catalog.GetAppName() << ft.hr);
				ft.TraceComError();
				ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"Failure to remove eventcls application object 0x %08lx", ft.hr);
				}

			// commit changes
			ft.hr = appsList.SaveChanges();
			if (ft.HrFailed())
				{
                ft.TraceComError();
				ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"Failure in commiting changes. hr = 0x%08lx", ft.hr);
				}
			ft.hr = application.AttachByName( appsList, catalog.GetAppName() );
			if (ft.HrFailed())
				{
				ft.LogError(VSS_ERROR_ATTACH_COLL_BY_NAME, VSSDBG_COORD << catalog.GetAppName() << ft.hr);
				ft.Throw(VSSDBG_COORD, E_UNEXPECTED, L"Failure in initializing the apps collection object 0x%08lx", ft.hr);
				}
			}

		// The application doesn't exist.
		ft.hr = application.InsertInto(appsList);
		if (ft.HrFailed())
			ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in creating a new application object 0x%08lx", ft.hr);

		// Set application name
		application.m_bstrName = catalog.GetAppName();

        // Loads the application description
        WCHAR wszBuffer[MAX_STRING_RESOURCE_LEN];
        if (0 == ::LoadStringW(_Module.GetModuleInstance(),
            IDS_SERVICE_DESCRIPTION, wszBuffer, MAX_STRING_RESOURCE_LEN - 1))
        {
            BS_ASSERT(false);
            ft.Throw(VSSDBG_VSSTEST, HRESULT_FROM_WIN32(GetLastError()),
    			L"Error on loading the app description. [0x%08lx]",
    			HRESULT_FROM_WIN32(GetLastError()));
        }

        CComBSTR bstrAppDescription = wszBuffer;
        if ((LPWSTR)bstrAppDescription == NULL)
            ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error.");
		application.m_bstrDescription = bstrAppDescription;
		
		// Register as Server package
		application.m_lActivation = COMAdminActivationLocal;

		// Commit changes
		ft.hr = appsList.SaveChanges();
		if (ft.HrFailed())
			{
			ft.TraceComError();
			ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Failure in commiting changes. hr = 0x%08lx", ft.hr);
    	    }
		// Make the application a true NT service
//			BS_ASSERT(false);
		ft.hr = catalog.CreateServiceForApplication(g_wszSvcName);
		if (ft.HrFailed())
			{
			BS_ASSERT(false);
			ft.TraceComError();
			ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Error on installing the service. hr = 0x%08lx", ft.hr);
            }

        //
        //  Insert this component into the application
        //

        WCHAR wszFileName[MAX_PATH];
        ft.hr = GetDllPathName(MAX_PATH - 1, g_wszDllName, wszFileName);
        if (ft.HrFailed())
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Error in getting the DLL path. hr = 0x%08lx", ft.hr);

        // Install the component
        ft.hr = catalog.InstallComponent(wszFileName, NULL, NULL);
        if (ft.HrFailed()) {
            ft.TraceComError();
            ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Error on install the event class. hr = 0x%08lx", ft.hr);
			}

	    BS_ASSERT(ft.hr != S_FALSE);

		MakeChangeable(false);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}



///////////////////////////////////////////////////////////////////////////////
//   DLL Entry point
//

//
// The real DLL Entry Point is _DLLMainCrtStartup (initializes global objects and after that calls DllMain
// this is defined in the runtime libaray
//

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        //  Set the correct tracing context. This is an inproc DLL
        g_cDbgTrace.SetContextNum(VSS_CONTEXT_DELAYED_DLL);

        // Set the proper way for displaying asserts
//        ::VssSetDebugReport(VSS_DBG_TO_DEBUG_CONSOLE);

        //  initialize COM module
        _Module.Init(ObjectMap, hInstance);

        //  optimization
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
//   DLL Exports
//


// Used to determine whether the DLL can be unloaded by OLE
STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}


// DllUnregisterServer - Removes entries from the system registry
STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}

HRESULT RegisterProvider()
	{
	CVssFunctionTracer ft(VSSDBG_VSSTEST, L"RegisterProvider");
	try
		{
		CComPtr<IVssAdmin> pAdmin;
		ft.hr = CoCreateInstance
					(
                    CLSID_VSSCoordinator,
					NULL,
					CLSCTX_ALL,
					IID_IVssAdmin,
					(void **) (IVssAdmin **) &pAdmin
					);

       ft.CheckForError(VSSDBG_VSSTEST, L"CoCreateInstance");

	   ft.hr = pAdmin->RegisterProvider
			 		(
					g_ProviderId,
					CLSID_HardwareTestProvider,
					L"HardwareTestProvider",
					VSS_PROV_HARDWARE,
					L"1.0",
					g_ProviderVersion
					);

       ft.CheckForError(VSSDBG_VSSTEST, L"IVssAdmin::RegisterProvider");
	   }
   VSS_STANDARD_CATCH(ft)

   return ft.hr;
   }

HRESULT UnregisterProvider()
	{
	CVssFunctionTracer ft(VSSDBG_VSSTEST, L"UnregisterProvider");
	try
		{
		CComPtr<IVssAdmin> pAdmin;
		ft.hr = CoCreateInstance
					(
                    CLSID_VSSCoordinator,
					NULL,
					CLSCTX_ALL,
					IID_IVssAdmin,
					(void **) (IVssAdmin **) &pAdmin
					);

       ft.CheckForError(VSSDBG_VSSTEST, L"CoCreateInstance");

	   ft.hr = pAdmin->UnregisterProvider(g_ProviderId);
       ft.CheckForError(VSSDBG_VSSTEST, L"IVssAdmin::UnregisterProvider");
	   }
   VSS_STANDARD_CATCH(ft)

   return ft.hr;
   }





					




// DllInstall - install the component into the COM+ catalog.
STDAPI DllInstall(	
	IN	BOOL bInstall,
	IN	LPCWSTR /* pszCmdLine */
)
{
	HRESULT hr = S_OK;

	// Registers the COM+ application
	// This will implicitely call DllRegisterServer
	if (bInstall)
		{
		hr = RegisterNewCOMApp();
		if (SUCCEEDED(hr))
			RegisterProvider();
		}
	else
		UnregisterProvider();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\hwprv\src\provider.cxx ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module Provider.hxx | Declarations used by the Software Snapshot Provider interface
    @end

Author:

    Adi Oltean  [aoltean]   07/13/1999

Revision History:

    Name        Date        Comments

    aoltean     07/13/1999  Created.
    aoltean     08/17/1999  Change CommitSnapshots to CommitSnapshot
    aoltean     09/23/1999  Using CComXXX classes for better memory management
                            Renaming back XXXSnapshots -> XXXSnapshot
    aoltean     09/26/1999  Returning a Provider Id in OnRegister
    aoltean     09/09/1999  Adding PostCommitSnapshots
                            dss->vss
    aoltean     09/20/1999  Making asserts more cleaner.
    aoltean     09/21/1999  Small renames

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include "stdafx.hxx"
#include <winnt.h>

//  Generated MIDL header
#include "vss.h"
#include "vdslun.h"
#include "vsprov.h"
#include "vscoordint.h"
#include "hwprv.h"


#include "resource.h"
#include "vs_inc.hxx"
#include "vs_sec.hxx"
#include "vs_reg.hxx"
#include "hwprv.hxx"


#include "provider.hxx"

////////////////////////////////////////////////////////////////////////
//  Standard foo for file name aliasing.  This code block must be after
//  all includes of VSS header files.
//
#ifdef VSS_FILE_ALIAS
#undef VSS_FILE_ALIAS
#endif
#define VSS_FILE_ALIAS "TSTHWPRC"
//
////////////////////////////////////////////////////////////////////////

CHardwareTestProvider::CHardwareTestProvider () :
    m_SnapshotSetId(GUID_NULL),
    m_maskSnapshotDisks(0),
    m_cDiskIds(0)
    {
    for(UINT i = 0; i < 32; i++)
        {
        m_rgpSourceLuns[i] = NULL;
        m_rgpDestinationLuns[i] = NULL;
        }
    }

CHardwareTestProvider::~CHardwareTestProvider()
    {
    ClearConfiguration();
    }




STDMETHODIMP CHardwareTestProvider::OnLoad
    (
    IN      IUnknown* pCallback
    )
    {
    UNREFERENCED_PARAMETER(pCallback);

    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::OnLoad");

    ClearConfiguration();
    LoadConfigurationData();

    return ft.hr;
    }

STDMETHODIMP CHardwareTestProvider::OnUnload
    (
    IN      BOOL    bForceUnload
    )
    {
    UNREFERENCED_PARAMETER(bForceUnload);

    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::OnUnload");

    ClearConfiguration();

    return ft.hr;
    }


    //
    //  IVssHardwareSnapshotProvider
    //

STDMETHODIMP CHardwareTestProvider::AreLunsSupported
    (
    IN  LONG lLunCount,
    IN  LONG lContext,
    IN  VDS_LUN_INFORMATION *rgLunInformation,
    OUT BOOL *pbIsSupported
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::AreLunsSupported");
    try
        {
        if (pbIsSupported == NULL || rgLunInformation == NULL)
            throw(VSSDBG_VSSTEST, E_INVALIDARG, L"NULL output parameter");

        *pbIsSupported = FALSE;
        VDS_LUN_INFORMATION *pLunInformation = rgLunInformation;
        bool bFound = false;

        for(LONG iLun = 0; iLun < lLunCount; iLun++, pLunInformation++)
            {
            bFound = false;
            for(DWORD iSourceLun = 0; iSourceLun < m_cDiskIds; iSourceLun++)
                {
                if (IsMatchLun(*pLunInformation, *(m_rgpSourceLuns[iSourceLun])))
                    {
                    bFound = true;
                    break;
                    }
                }

            if (!bFound)
                break;
            }

        if (bFound)
            {
            pLunInformation = rgLunInformation;
            for(LONG iLun = 0; iLun < lLunCount; iLun++, pLunInformation++)
                {
                pLunInformation->m_rgInterconnects = (VDS_INTERCONNECT *) CoTaskMemAlloc(sizeof(VDS_INTERCONNECT));
                if (pLunInformation->m_rgInterconnects == NULL)
                    ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

                memset(pLunInformation->m_rgInterconnects, 0, sizeof(VDS_INTERCONNECT));
                pLunInformation->m_cInterconnects = 1;
                pLunInformation->m_rgInterconnects->m_pbAddress = (BYTE *) CoTaskMemAlloc(sizeof(ULONG));
                if (pLunInformation->m_rgInterconnects->m_pbAddress == NULL)
                    ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

                pLunInformation->m_rgInterconnects->m_cbAddress = sizeof(ULONG);
                pLunInformation->m_rgInterconnects->m_addressType = VDS_IA_FCPH;
                pLunInformation->m_rgInterconnects->m_pbPort = (BYTE *) CoTaskMemAlloc(sizeof(ULONG));
                if (pLunInformation->m_rgInterconnects->m_pbPort == NULL)
                    ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

                *((ULONG *) (pLunInformation->m_rgInterconnects->m_pbPort)) = 0x8828080;
                pLunInformation->m_rgInterconnects->m_cbPort = sizeof(ULONG);
                for(DWORD iSourceLun = 0; iSourceLun < m_cDiskIds; iSourceLun++)
                    {
                    if (IsMatchLun(*pLunInformation, *(m_rgpSourceLuns[iSourceLun])))
                        {
                        *(ULONG *) (pLunInformation->m_rgInterconnects->m_pbAddress) = iSourceLun;
                        break;
                        }
                    }
                }

            *pbIsSupported = true;
            }
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }


STDMETHODIMP CHardwareTestProvider::BeginPrepareSnapshot
    (
    IN      VSS_ID          SnapshotSetId,
    IN      VSS_ID          SnapshotId,
    IN      LONG            lContext,
    IN      LONG            lLunCount,
    IN      VDS_LUN_INFORMATION *rgLunInformation
    )
    {
    UNREFERENCED_PARAMETER(SnapshotId);
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::BeginPrepareSnapshot");
    try
        {
        if (m_SnapshotSetId == GUID_NULL)
            {
            m_lContext = lContext;
            m_SnapshotSetId = SnapshotSetId;
            m_maskSnapshotDisks = 0;
            }

        VDS_LUN_INFORMATION *pLunInformation = rgLunInformation;

        for(LONG iLun = 0; iLun < lLunCount; iLun++, pLunInformation++)
            {
            if (pLunInformation->m_cInterconnects != 1 ||
                pLunInformation->m_rgInterconnects == NULL ||
                pLunInformation->m_rgInterconnects[0].m_cbAddress != sizeof(ULONG) ||
                pLunInformation->m_rgInterconnects[0].m_cbPort != sizeof(ULONG) ||
                *(ULONG *) (pLunInformation->m_rgInterconnects[0].m_pbPort) != 0x8828080)
                ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"Drive not supported");

            ULONG iDisk = *(ULONG *) (pLunInformation->m_rgInterconnects[0].m_pbAddress);

            m_maskSnapshotDisks |= 1 << iDisk;
            }
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// free all the components of a VDS_LUN_INFO structure
void CHardwareTestProvider::FreeLunInfo
    (
    IN VDS_LUN_INFORMATION *rgLunInfo,
    UINT cLuns
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssTestHardwareProvider::FreeLunInfo");

    // check if pointer is NULL
    if (rgLunInfo == NULL)
        return;

    // loop through individual luns
    for(DWORD iLun = 0; iLun < cLuns; iLun++)
        {
        // get lun info
        VDS_LUN_INFORMATION *pLun = &rgLunInfo[iLun];

        // free up strings
        if (pLun->m_szVendorId)
            CoTaskMemFree(pLun->m_szVendorId);

        if (pLun->m_szProductId)
            CoTaskMemFree(pLun->m_szProductId);

        if (pLun->m_szProductRevision)
            CoTaskMemFree(pLun->m_szProductRevision);

        if (pLun->m_szSerialNumber)
            CoTaskMemFree(pLun->m_szSerialNumber);


        // point to VDS_STORAGE_DEVICE_ID_DESCRIPTOR
        // get number of VDS_STORAGE_IDENTIFIERs in the descriptor
        ULONG cIds = pLun->m_deviceIdDescriptor.m_cIdentifiers;

        // point to first VDS_STORAGE_IDENTIFIER
        VDS_STORAGE_IDENTIFIER *pvsi = pLun->m_deviceIdDescriptor.m_rgIdentifiers;
        for(ULONG iId = 0; iId < cIds; iId++, pvsi++)
            {
            // free up data for identifier
            if (pvsi->m_rgbIdentifier)
                CoTaskMemFree(pvsi->m_rgbIdentifier);
            }

        // free up array of identifiers
        if (pLun->m_deviceIdDescriptor.m_rgIdentifiers)
            CoTaskMemFree(pLun->m_deviceIdDescriptor.m_rgIdentifiers);

        // point to first VDS_INTERCONNECT
        VDS_INTERCONNECT *pInterconnect = pLun->m_rgInterconnects;

        for(ULONG iInterconnect = 0; iInterconnect < pLun->m_cInterconnects; iInterconnect++, pInterconnect++)
            {
            // free up address if there is one
            if (pInterconnect->m_pbAddress)
                CoTaskMemFree(pInterconnect->m_pbAddress);

            if (pInterconnect->m_pbPort)
                CoTaskMemFree(pInterconnect->m_pbPort);
            }

        // free up array of interconnects
        if (pLun->m_rgInterconnects)
            CoTaskMemFree(pLun->m_rgInterconnects);
        }

    // free up array of lun information
    CoTaskMemFree(rgLunInfo);
    }

void CHardwareTestProvider::CopyString(LPSTR &szCopy, LPCSTR szSource)
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::CopyString");

    if (szSource == NULL)  {
        szCopy = NULL;
        return;
    }
    szCopy = (LPSTR) CoTaskMemAlloc(strlen(szSource) + 1);
    if (szCopy == NULL)
        ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

    strcpy(szCopy, szSource);
    }

void CHardwareTestProvider::CopyBinaryData
    (
    LPBYTE &rgb,
    UINT cbSource,
    const BYTE *rgbSource
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::CopyBinaryData");

    rgb = (BYTE *) CoTaskMemAlloc(cbSource);
    if (rgb == NULL)
        ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

    memcpy(rgb, rgbSource, cbSource);
    }



STDMETHODIMP CHardwareTestProvider::GetTargetLuns
    (
    IN      LONG        lLunCount,
    IN      VDS_LUN_INFORMATION *rgSourceLuns,
    OUT     VDS_LUN_INFORMATION **prgDestinationLuns
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::GetTargetLuns");

    VDS_LUN_INFORMATION *rgDestinationLuns = NULL;
    try
        {
        rgDestinationLuns = (VDS_LUN_INFORMATION *) CoTaskMemAlloc(lLunCount * sizeof(VDS_LUN_INFORMATION));
        memset(rgDestinationLuns, 0, lLunCount * sizeof(VDS_LUN_INFORMATION));
        for(LONG iLun = 0; iLun < lLunCount; iLun++)
            {
            VDS_LUN_INFORMATION *pLunInfo = NULL;
            for(DWORD iDisk = 0; iDisk < m_cDiskIds; iDisk++)
                {
                if (IsMatchLun(*m_rgpSourceLuns[iDisk], rgSourceLuns[iLun]))
                    pLunInfo = m_rgpDestinationLuns[iLun];
                }

            if (pLunInfo == NULL)
                ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Can't find source lun");

            VDS_LUN_INFORMATION *pDestLun = &rgDestinationLuns[iLun];

            pDestLun->m_BusType = pLunInfo->m_BusType;
            pDestLun->m_DeviceType = pLunInfo->m_DeviceType;
            pDestLun->m_DeviceTypeModifier = pLunInfo->m_DeviceTypeModifier;
            pDestLun->m_bCommandQueueing = pLunInfo->m_bCommandQueueing;
            pDestLun->m_diskSignature = pLunInfo->m_diskSignature;
            CopyString(pDestLun->m_szVendorId, pLunInfo->m_szVendorId);
            CopyString(pDestLun->m_szProductId, pLunInfo->m_szProductId);
            CopyString(pDestLun->m_szProductRevision, pLunInfo->m_szProductRevision);
            CopyString(pDestLun->m_szSerialNumber, pLunInfo->m_szSerialNumber);
            ULONG cIds = pLunInfo->m_deviceIdDescriptor.m_cIdentifiers;
            pDestLun->m_deviceIdDescriptor.m_version = pLunInfo->m_deviceIdDescriptor.m_version;
            pDestLun->m_deviceIdDescriptor.m_cIdentifiers = cIds;
            pDestLun->m_deviceIdDescriptor.m_rgIdentifiers = (VDS_STORAGE_IDENTIFIER *) CoTaskMemAlloc(cIds * sizeof(VDS_STORAGE_DEVICE_ID_DESCRIPTOR));
            memset(pDestLun->m_deviceIdDescriptor.m_rgIdentifiers, 0, cIds * sizeof(VDS_STORAGE_DEVICE_ID_DESCRIPTOR));
            VDS_STORAGE_IDENTIFIER *pSourceId = pLunInfo->m_deviceIdDescriptor.m_rgIdentifiers;
            VDS_STORAGE_IDENTIFIER *pDestId = pDestLun->m_deviceIdDescriptor.m_rgIdentifiers;
            for(ULONG iId = 0; iId < cIds; iId++, pSourceId++, pDestId++)
                {
                memcpy(pDestId, pSourceId, FIELD_OFFSET(VDS_STORAGE_IDENTIFIER, m_rgbIdentifier));
                CopyBinaryData(pDestId->m_rgbIdentifier, pSourceId->m_cbIdentifier, pSourceId->m_rgbIdentifier);
                }

            pDestLun->m_cInterconnects = 1;
            pDestLun->m_rgInterconnects = (VDS_INTERCONNECT *) CoTaskMemAlloc(sizeof(VDS_INTERCONNECT));
            memset(pDestLun->m_rgInterconnects, 0, sizeof(VDS_INTERCONNECT));
            VDS_INTERCONNECT *pDestInterconnect = pDestLun->m_rgInterconnects;
            pDestInterconnect->m_addressType = VDS_IA_FCPH;
            pDestInterconnect->m_pbAddress = (BYTE *) CoTaskMemAlloc(sizeof(ULONG));
            if (pDestInterconnect->m_pbAddress == NULL)
                ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

            pDestInterconnect->m_cbAddress = sizeof(ULONG);
            *(ULONG *) (pDestInterconnect->m_pbAddress) = iDisk;
            pDestInterconnect->m_pbPort = (BYTE *) CoTaskMemAlloc(sizeof(ULONG));
            if (pDestInterconnect->m_pbPort == NULL)
                ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Out of memory.");

            *(ULONGLONG *) (pDestInterconnect->m_pbPort) = 0x9364321;
            pDestInterconnect->m_cbPort = sizeof(ULONG);
            }

        *prgDestinationLuns = rgDestinationLuns;
        rgDestinationLuns = NULL;
        }
    VSS_STANDARD_CATCH(ft)

    FreeLunInfo(rgDestinationLuns, lLunCount);

    return ft.hr;
    }

STDMETHODIMP CHardwareTestProvider::LocateLuns
    (
    IN      LONG        lLunCount,
    IN      VDS_LUN_INFORMATION *rgSourceLuns
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::LocateLuns");

    try
        {
        for(LONG iLun = 0; iLun < lLunCount; iLun++)
            {
            for(DWORD iDisk = 0; iDisk < m_cDiskIds; iDisk++)
                {
                if (IsMatchLun(*(m_rgpDestinationLuns[iDisk]), rgSourceLuns[iLun]))
                    break;
                }

            if (iDisk == m_cDiskIds)
                ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"Cannot locate lun");
            }
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// perform a device i/o control, growing the buffer if necessary
BOOL CHardwareTestProvider::DoDeviceIoControl
    (
    IN HANDLE hDevice,              // handle
    IN DWORD ioctl,                 // device ioctl to perform
    IN const LPBYTE pbQuery,        // input buffer
    IN DWORD cbQuery,               // size of input buffer
    IN OUT LPBYTE *ppbOut,          // pointer to output buffer
    IN OUT DWORD *pcbOut            // pointer to size of output buffer
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::DoDeviceIoControl");

    // loop in case buffer is too small for query result.
    while(TRUE)
        {
        DWORD dwSize;
        if (*ppbOut == NULL)
            {
            // allocate buffer for result of query
            *ppbOut = new BYTE[*pcbOut];
            if (*ppbOut == NULL)
                ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Couldn't allocate query results buffer");
            }

        // do query
        if (!DeviceIoControl
                (
                hDevice,
                ioctl,
                pbQuery,
                cbQuery,
                *ppbOut,
                *pcbOut,
                &dwSize,
                NULL
                ))
            {
            // query failed
            DWORD dwErr = GetLastError();

            if (dwErr == ERROR_INVALID_FUNCTION ||
                dwErr == ERROR_NOT_SUPPORTED)
                return FALSE;


            if (dwErr == ERROR_INSUFFICIENT_BUFFER ||
                dwErr == ERROR_MORE_DATA)
                {
                // buffer wasn't big enough allocate a new
                // buffer of the specified return size
                delete *ppbOut;
                *ppbOut = NULL;
                *pcbOut *= 2;
                continue;
                }

            // all other errors are remapped (and potentially logged)
            ft.hr = HRESULT_FROM_WIN32(dwErr);
            ft.CheckForError(VSSDBG_VSSTEST, L"DeviceIoControl %d");
            }

        break;
        }

    return TRUE;
    }


bool CHardwareTestProvider::BuildLunInfoFromDrive
    (
    IN HANDLE hDrive,
    OUT VDS_LUN_INFORMATION **ppLun,
    OUT DWORD &cPartitions
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::BuildLunInfoFromDrive");

    LPBYTE bufQuery = NULL;
    VDS_LUN_INFORMATION *pLun;
    try
        {
        BOOL b;

        // allocate lun information
        pLun = (VDS_LUN_INFORMATION *) CoTaskMemAlloc(sizeof(VDS_LUN_INFORMATION));
        if (pLun == NULL)
            ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Cannot allocate LUN information array");

        // clear lun information in case we throw
        memset(pLun, 0, sizeof(VDS_LUN_INFORMATION));

        // query to get STORAGE_DEVICE_OBJECT
        STORAGE_PROPERTY_QUERY query;
        DWORD cbQuery = 1024;


        query.PropertyId = StorageDeviceProperty;
        query.QueryType = PropertyStandardQuery;
        b = DoDeviceIoControl
                (
                hDrive,
                IOCTL_STORAGE_QUERY_PROPERTY,
                (LPBYTE) &query,
                sizeof(query),
                (LPBYTE *) &bufQuery,
                &cbQuery
                );

        if (!b)
            {
            delete bufQuery;
            CoTaskMemFree(pLun);
            return false;
            }


        // coerce to STORAGE_DEVICE_DESCRIPTOR
        STORAGE_DEVICE_DESCRIPTOR *pDesc = (STORAGE_DEVICE_DESCRIPTOR *) bufQuery;

        pLun->m_version = VER_VDS_LUN_INFORMATION;
        pLun->m_DeviceType = pDesc->DeviceType;
        pLun->m_DeviceTypeModifier = pDesc->DeviceTypeModifier;
        pLun->m_bCommandQueueing = pDesc->CommandQueueing;

        // copy bus type
        pLun->m_BusType = (VDS_STORAGE_BUS_TYPE) pDesc->BusType;

        // copy in various strings
        if (pDesc->VendorIdOffset)
            CopySDString(&pLun->m_szVendorId, pDesc, pDesc->VendorIdOffset);

        if (pDesc->ProductIdOffset)
            CopySDString(&pLun->m_szProductId, pDesc, pDesc->ProductIdOffset);

        if (pDesc->ProductRevisionOffset)
            CopySDString(&pLun->m_szProductRevision, pDesc, pDesc->ProductRevisionOffset);

        if (pDesc->SerialNumberOffset)
            CopySDString(&pLun->m_szSerialNumber, pDesc, pDesc->SerialNumberOffset);

        // query for STORAGE_DEVICE_ID_DESCRIPTOR
        query.PropertyId = StorageDeviceIdProperty;
        query.QueryType = PropertyStandardQuery;

        if (DoDeviceIoControl
                (
                hDrive,
                IOCTL_STORAGE_QUERY_PROPERTY,
                (LPBYTE) &query,
                sizeof(query),
                (LPBYTE *) &bufQuery,
                &cbQuery
                ))
            {
            // coerce buffer to STORAGE_DEVICE_ID_DESCRIPTOR
            STORAGE_DEVICE_ID_DESCRIPTOR *pDevId = (STORAGE_DEVICE_ID_DESCRIPTOR *) bufQuery;
            CopyStorageDeviceIdDescriptorToLun(pDevId, pLun);
            }

        if (DoDeviceIoControl
                (
                hDrive,
                IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                NULL,
                0,
                (LPBYTE *) &bufQuery,
                &cbQuery
                ))
            {
            // compute signature from layout
            DRIVE_LAYOUT_INFORMATION_EX *pLayout = (DRIVE_LAYOUT_INFORMATION_EX *) bufQuery;
            VSS_ID signature = GUID_NULL;

            cPartitions = pLayout->PartitionCount;

            switch(pLayout->PartitionStyle)
                {
                default:
                    BS_ASSERT(FALSE);
                    break;

                case PARTITION_STYLE_RAW:
                    break;

                case PARTITION_STYLE_GPT:
                    // use GPT DiskId as signature
                    signature = pLayout->Gpt.DiskId;
                    break;

                case PARTITION_STYLE_MBR:
                    // use 32 bit Mbr signature as high part of guid.  Remainder
                    // of guid is 0.
                    signature.Data1 = pLayout->Mbr.Signature;
                    break;
                }

            // save disk signature
            pLun->m_diskSignature = signature;
            }
        }
    VSS_STANDARD_CATCH(ft)

    delete bufQuery;
    if (ft.HrFailed())
        {
        FreeLunInfo(pLun, 1);
        ft.Throw(VSSDBG_VSSTEST, ft.hr, L"Rethrowing");
        }

    *ppLun = pLun;

    return TRUE;
    }



STDMETHODIMP CHardwareTestProvider::OnLunEmpty
    (
    IN VDS_LUN_INFORMATION *pInfo
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::OnLunEmpty");

    try
        {
        for(DWORD iDisk = 0; iDisk < m_cDiskIds; iDisk++)
            {
            if (IsMatchLun(*(m_rgpDestinationLuns[iDisk]), *pInfo))
                break;
            }

        if (iDisk == m_cDiskIds)
            ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"Cannot locate lun");

        // reexpose partitions after lun is freed so we see something change
        HideAndExposePartitions(m_rgDestinationDiskIds[iDisk], m_rgcDestinationPartitions[iDisk], false, true);
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

// IVssProviderCreateSnapshotSet interface
STDMETHODIMP CHardwareTestProvider::EndPrepareSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::EndPrepareSnapshots");
    try
        {
        if (SnapshotSetId != m_SnapshotSetId)
            ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"snapshot set mismatch");
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

STDMETHODIMP CHardwareTestProvider::PreCommitSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::PreCommitSnapshots");
    try
        {
        if (SnapshotSetId != m_SnapshotSetId)
            ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"snapshot set mismatch");
        }
    VSS_STANDARD_CATCH(ft)
    return ft.hr;
    }

STDMETHODIMP CHardwareTestProvider::CommitSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::CommitSnapshots");

    try
        {
        if (SnapshotSetId != m_SnapshotSetId)
            ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"snapshot set mismatch");

        m_bHidden = true;
        LONG mask = 1;
        for(UINT Disk = 0; mask != 0; mask = mask << 1, Disk++)
            {
            if ((m_maskSnapshotDisks & mask) != 0)
                HideAndExposePartitions(m_rgDestinationDiskIds[Disk], m_rgcDestinationPartitions[Disk], true, false);
            }
        }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
    }

STDMETHODIMP CHardwareTestProvider::PostCommitSnapshots
    (
    IN      VSS_ID          SnapshotSetId,
    IN      LONG            lSnapshotsCount
    )
    {
    UNREFERENCED_PARAMETER(lSnapshotsCount);

    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::PostCommitSnapshots");

    try
        {
        if (SnapshotSetId != m_SnapshotSetId)
            ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"snapshot set mismatch");
        }
    VSS_STANDARD_CATCH(ft)

    m_SnapshotSetId = GUID_NULL;
    m_maskSnapshotDisks = 0;
    m_bHidden = false;

    return ft.hr;
    }

STDMETHODIMP CHardwareTestProvider::AbortSnapshots
    (
    IN      VSS_ID          SnapshotSetId
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::AbortSnapshots");

    try
        {
        if (SnapshotSetId != m_SnapshotSetId)
            ft.Throw(VSSDBG_VSSTEST, VSS_E_PROVIDER_VETO, L"snapshot set mismatch");

        if (m_bHidden)
            {
            UINT Disk = 0;
            for(LONG mask = 1; mask != 0; mask = mask << 1)
                {
                if ((m_maskSnapshotDisks & mask) != 0)
                    HideAndExposePartitions(m_rgDestinationDiskIds[Disk], m_rgcDestinationPartitions[Disk], false, true);

                Disk++;
                }
            }

        m_bHidden = false;
        m_SnapshotSetId = GUID_NULL;
        m_maskSnapshotDisks = 0;
        }
    VSS_STANDARD_CATCH(ft)


    return ft.hr;
    }

bool CHardwareTestProvider::cmp_str_eq(LPCSTR sz1, LPCSTR sz2)
    {
    if (sz1 == NULL && sz2 == NULL)
        return true;
    else if (sz1 != NULL && sz2 != NULL)
        {
        while(*sz1 == *sz2 && *sz1 != '\0')
            {
            sz1++;
            sz2++;
            }

        if (*sz1 == *sz2)
            return true;

        if (*sz1 == '\0' && *sz2 == ' ')
            {
            while(*sz2 != '\0')
                {
                if (*sz2 != ' ')
                    return false;

                sz2++;
                }

            return true;
            }
        else if (*sz1 == ' ' && *sz2 == ' ')
            {
            while(*sz1 != '\0')
                {
                if (*sz1 != ' ')
                    return false;

                sz1++;
                }

            return true;
            }

        return false;
        }
    else
        return false;
    }




// determine if two VDS_LUN_INFORMATION structures match
bool CHardwareTestProvider::IsMatchLun
    (
    const VDS_LUN_INFORMATION &info1,
    const VDS_LUN_INFORMATION &info2
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::IsMatchLun");

    if (info1.m_DeviceType != info2.m_DeviceType)
        return false;

    if (info1.m_DeviceTypeModifier != info2.m_DeviceTypeModifier)
        return false;

    if (info1.m_BusType != info2.m_BusType)
        return false;

    if (!cmp_str_eq(info1.m_szSerialNumber, info2.m_szSerialNumber))
        return false;

    if (!cmp_str_eq(info1.m_szVendorId, info2.m_szVendorId))
        return false;

    if (!cmp_str_eq(info1.m_szProductId, info2.m_szProductId))
        return false;

    if (!cmp_str_eq(info1.m_szProductRevision, info2.m_szProductRevision))
        return false;

    if (info1.m_diskSignature != info2.m_diskSignature)
        return false;

    if (!IsMatchDeviceIdDescriptor(info1.m_deviceIdDescriptor, info2.m_deviceIdDescriptor))
        return false;

    return true;
    }


// make sure that the storage device id descriptors match
bool CHardwareTestProvider::IsMatchDeviceIdDescriptor
    (
    IN const VDS_STORAGE_DEVICE_ID_DESCRIPTOR &desc1,
    IN const VDS_STORAGE_DEVICE_ID_DESCRIPTOR &desc2
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::IsMatchDeviceIdDescriptor");

    VDS_STORAGE_IDENTIFIER *pId1 = desc1.m_rgIdentifiers;
    VDS_STORAGE_IDENTIFIER *rgId2 = desc2.m_rgIdentifiers;

    for(ULONG iIdentifier = 0; iIdentifier < desc1.m_cIdentifiers; iIdentifier++, pId1++)
        {
        if (IsConflictingIdentifier(pId1, rgId2, desc2.m_cIdentifiers))
            return false;
        }

    return true;
    }

// determine if there is a conflicting identifier in an array of storage
// identifiers
bool CHardwareTestProvider::IsConflictingIdentifier
    (
    IN const VDS_STORAGE_IDENTIFIER *pId1,
    IN const VDS_STORAGE_IDENTIFIER *rgId2,
    IN ULONG cId2
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::IsConflictingIdentifier");

    const VDS_STORAGE_IDENTIFIER *pId2 = rgId2;

    for(UINT iid = 0; iid < cId2; iid++)
        {
        if (pId1->m_Type == pId2->m_Type)
            {
            if (pId1->m_CodeSet != pId2->m_CodeSet ||
                pId1->m_cbIdentifier != pId2->m_cbIdentifier ||
                memcmp(pId1->m_rgbIdentifier, pId2->m_rgbIdentifier, pId1->m_cbIdentifier) != 0)
                return true;
            }
        }

    return false;
    }

// copy a string from a STORAGE_DEVICE_DESCRIPTOR.  It is returned as a
// CoTaskAllocated string.
void CHardwareTestProvider::CopySDString
    (
    LPSTR *ppszNew,
    STORAGE_DEVICE_DESCRIPTOR *pdesc,
    DWORD offset
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::CopySDString");

    // point to start of string
    LPSTR szId = (LPSTR)((BYTE *) pdesc + offset);
    UINT cwc = (UINT) strlen(szId);
    while(cwc > 0 && szId[cwc-1] == ' ')
        cwc--;

    if (cwc == 0)
        *ppszNew = NULL;
    else
        {
        // allocate string
        *ppszNew = (LPSTR) CoTaskMemAlloc(cwc + 1);
        if (*ppszNew == NULL)
            ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Cannot allocate string.");

        // copy value into string
        memcpy(*ppszNew, szId, cwc);
        (*ppszNew)[cwc] = L'\0';
        }
    }



void CHardwareTestProvider::HideAndExposePartitions
    (
    UINT DiskNo,
    DWORD cPartitions,
    bool fHide,
    bool fExpose
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::HideAndExposePartitions");

    HANDLE hVol = INVALID_HANDLE_VALUE;

    try
        {
        WCHAR volName[128];
        for(UINT iPartition = 0; iPartition < cPartitions; iPartition++)
            {
            swprintf
                (
                volName,
                L"\\\\?\\GlobalRoot\\Device\\Harddisk%d\\Partition%d",
                DiskNo,
                iPartition
                );

            hVol = CreateFile
                    (
                    volName,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

            if (hVol == INVALID_HANDLE_VALUE)
                {
                DWORD dwErr = GetLastError();
                if (dwErr == ERROR_FILE_NOT_FOUND ||
                    dwErr == ERROR_PATH_NOT_FOUND)
                    continue;

                ft.hr = HRESULT_FROM_WIN32(dwErr);
                ft.CheckForError(VSSDBG_VSSTEST, L"CreateFile(VOLUME)");
                }


            DWORD size;
            VOLUME_GET_GPT_ATTRIBUTES_INFORMATION   getAttributesInfo;
            VOLUME_SET_GPT_ATTRIBUTES_INFORMATION setAttributesInfo;

            if (!DeviceIoControl
                    (
                    hVol,
                    IOCTL_VOLUME_GET_GPT_ATTRIBUTES,
                    NULL,
                    0,
                    &getAttributesInfo,
                    sizeof(getAttributesInfo),
                    &size,
                    NULL
                    ))
                {
                DWORD dwErr = GetLastError();
                if (dwErr == ERROR_INVALID_FUNCTION)
                    goto skipVol;

                ft.hr = HRESULT_FROM_WIN32(dwErr);
                ft.CheckForError(VSSDBG_VSSTEST, L"DeviceIoControl(IOCTL_VOLUME_GET_GPT_ATTRIBUTES)");
                }

            memset(&setAttributesInfo, 0, sizeof(setAttributesInfo));
            setAttributesInfo.GptAttributes = getAttributesInfo.GptAttributes;
            setAttributesInfo.ApplyToAllConnectedVolumes = TRUE;
            if (fHide)
                {
                // dismount volume before seting read-only bits
                if (!DeviceIoControl
                        (
                        hVol,
                        FSCTL_DISMOUNT_VOLUME,
                        NULL,
                        0,
                        NULL,
                        0,
                        &size,
                        NULL
                        ))
                    {
                    DWORD dwErr = GetLastError();
                    if (dwErr == ERROR_INVALID_FUNCTION)
                        goto skipVol;

                    ft.hr = HRESULT_FROM_WIN32(dwErr);
                    ft.CheckForError(VSSDBG_VSSTEST, L"DeviceIoControl(IOCTL_VOLUME_SET_GPT_ATTRIBUTES)");
                    }

                setAttributesInfo.GptAttributes |= GPT_BASIC_DATA_ATTRIBUTE_HIDDEN;
                if (!DeviceIoControl
                        (
                        hVol,
                        IOCTL_VOLUME_SET_GPT_ATTRIBUTES,
                        &setAttributesInfo,
                        sizeof(setAttributesInfo),
                        NULL,
                        0,
                        &size,
                        NULL
                        ))
                    {
                    DWORD dwErr = GetLastError();
                    if (dwErr == ERROR_INVALID_FUNCTION)
                        goto skipVol;

                    ft.hr = HRESULT_FROM_WIN32(dwErr);
                    ft.CheckForError(VSSDBG_VSSTEST, L"DeviceIoControl(IOCTL_VOLUME_SET_GPT_ATTRIBUTES)");
                    }
                }

            if (fExpose)
                {
                setAttributesInfo.GptAttributes &= ~GPT_BASIC_DATA_ATTRIBUTE_HIDDEN;
                if (!DeviceIoControl
                        (
                        hVol,
                        IOCTL_VOLUME_SET_GPT_ATTRIBUTES,
                        &setAttributesInfo,
                        sizeof(setAttributesInfo),
                        NULL,
                        0, &size,
                        NULL
                        ))
                    {
                    ft.hr = HRESULT_FROM_WIN32(GetLastError());
                    ft.CheckForError(VSSDBG_VSSTEST, L"DeviceIoControl(IOCTL_VOLUME_SET_GPT_ATTRIBUTES)");
                    }
                }

skipVol:
            CloseHandle(hVol);
            hVol = INVALID_HANDLE_VALUE;
            }
        }
    VSS_STANDARD_CATCH(ft)

    if (hVol != INVALID_HANDLE_VALUE)
        CloseHandle(hVol);
    }

// copy a storage device id descriptor to the VDS_LUN_INFORMATION structure.
// note that lun is modified whether an execption occurs or not.  FreeLunInfo
// will free up any data allocated here.
void CHardwareTestProvider::CopyStorageDeviceIdDescriptorToLun
    (
    IN STORAGE_DEVICE_ID_DESCRIPTOR *pDevId,
    IN VDS_LUN_INFORMATION *pLun
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::CopyStorageDeviceIdDescriptorToLun");

    BS_ASSERT(StorageIdTypeVendorSpecific == VDSStorageIdTypeVendorSpecific);
    BS_ASSERT(StorageIdTypeVendorId == VDSStorageIdTypeVendorId);
    BS_ASSERT(StorageIdTypeEUI64 == VDSStorageIdTypeEUI64);
    BS_ASSERT(StorageIdTypeFCPHName == VDSStorageIdTypeFCPHName);
    BS_ASSERT(StorageIdCodeSetAscii == VDSStorageIdCodeSetAscii);
    BS_ASSERT(StorageIdCodeSetBinary == VDSStorageIdCodeSetBinary);

    // get count of ids
    DWORD cIds = pDevId->NumberOfIdentifiers;

    // copy over version number and count of ids
    pLun->m_deviceIdDescriptor.m_version = pDevId->Version;
    pLun->m_deviceIdDescriptor.m_cIdentifiers = cIds;

    // allocate array of identifiers
    pLun->m_deviceIdDescriptor.m_rgIdentifiers =
        (VDS_STORAGE_IDENTIFIER *) CoTaskMemAlloc(sizeof(VDS_STORAGE_IDENTIFIER) * cIds);

    if (pLun->m_deviceIdDescriptor.m_rgIdentifiers == NULL)
        ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Cannot allocate device id descriptors");

    // clear descriptor.  If we throw, we want to make sure that all pointers
    // are null
    memset(pLun->m_deviceIdDescriptor.m_rgIdentifiers, 0, sizeof(VDS_STORAGE_IDENTIFIER) * cIds);

    // get pointer to first identifier in both STORAGE_DEVICE_ID_DESCRIPTOR and
    // VDS_STORAGE_DEVICE_ID_DESCRIPTOR
    STORAGE_IDENTIFIER *pId = (STORAGE_IDENTIFIER *) pDevId->Identifiers;
    VDS_STORAGE_IDENTIFIER *pvsi = (VDS_STORAGE_IDENTIFIER *) pLun->m_deviceIdDescriptor.m_rgIdentifiers;

    for(UINT i = 0; i < cIds; i++)
        {
        // copy over size of identifier
        pvsi->m_cbIdentifier = pId->IdentifierSize;

        // allocate space for identifier
        pvsi->m_rgbIdentifier = (BYTE *) CoTaskMemAlloc(pvsi->m_cbIdentifier);
        if (pvsi->m_rgbIdentifier == NULL)
            ft.Throw(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Cannot allocate storage identifier");

        // copy type and code set over
        pvsi->m_Type = (VDS_STORAGE_IDENTIFIER_TYPE) pId->Type;
        pvsi->m_CodeSet = (VDS_STORAGE_IDENTIFIER_CODE_SET) pId->CodeSet;

        // copy identifier
        memcpy(pvsi->m_rgbIdentifier, pId->Identifier, pvsi->m_cbIdentifier);

        // move to next identifier
        pId = (STORAGE_IDENTIFIER *) ((BYTE *) pId + pId->NextOffset);
        pvsi++;
        }
    }

void CHardwareTestProvider::LoadConfigurationData()
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::LoadConfigurationData");

    VSS_PWSZ wszSourceDisks = NULL;
    VSS_PWSZ wszDestinationDisks = NULL;
    m_cDiskIds = 0;
    try
        {
        CVssRegistryKey key;
        key.Open(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Services\\HardwareTestProvider");
        key.GetValue(L"SourceDisks", wszSourceDisks);
        key.GetValue(L"DestinationDisks", wszDestinationDisks);
        LPWSTR wszSource = wszSourceDisks;
        LPWSTR wszDestination = wszDestinationDisks;

        while(wszSource != NULL &&
              wszDestination != NULL &&
              *wszSource != L'\0' &&
              *wszDestination != L'\0')
            {
            WCHAR *wszSourceNext = wcschr(wszSource, L',');
            WCHAR *wszDestinationNext = wcschr(wszDestination, L',');
            if (wszSourceNext != NULL)
                *wszSourceNext = L'\0';

            if (wszDestinationNext != NULL)
                *wszDestinationNext = L'\0';

            int Source = _wtoi(wszSource);
            int Destination = _wtoi(wszDestination);
            m_rgSourceDiskIds[m_cDiskIds] = Source;
            m_rgDestinationDiskIds[m_cDiskIds] = Destination;
            wszSource = wszSourceNext;
            wszDestination = wszDestinationNext;
            m_cDiskIds++;
            if (m_cDiskIds == 32)
                break;
            }

        for(DWORD iDisk = 0; iDisk < m_cDiskIds; iDisk++)
            {
            BuildLunInfoForDisk(m_rgSourceDiskIds[iDisk], &m_rgpSourceLuns[iDisk], &m_rgcSourcePartitions[iDisk]);
            BuildLunInfoForDisk(m_rgDestinationDiskIds[iDisk], &m_rgpDestinationLuns[iDisk], &m_rgcDestinationPartitions[iDisk]);
            }
        }
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        ClearConfiguration();

    if (wszSourceDisks)
        CoTaskMemFree(wszSourceDisks);

    if (wszDestinationDisks)
        CoTaskMemFree(wszDestinationDisks);
    }



void CHardwareTestProvider::BuildLunInfoForDisk
    (
    IN DWORD Drive,
    OUT VDS_LUN_INFORMATION **ppLunInfo,
    OUT DWORD *pcPartitions
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::BuildLunInfoForDisk");

    WCHAR wszbuf[32];
    swprintf(wszbuf, L"\\\\.\\PHYSICALDRIVE%u", Drive);
    CVssAutoWin32Handle hDisk = CreateFile
                    (
                    wszbuf,
                    GENERIC_READ|GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    if (hDisk == INVALID_HANDLE_VALUE)
        {
        ft.hr = HRESULT_FROM_WIN32(GetLastError());
        ft.CheckForError(VSSDBG_VSSTEST, L"CreateFile(DRIVE)");
        }

    DWORD cPartitions;
    if (!BuildLunInfoFromDrive(hDisk, ppLunInfo, *pcPartitions))
        ft.Throw(VSSDBG_VSSTEST, E_UNEXPECTED, L"Can't build lun info for drive %d", Drive);
    }

void CHardwareTestProvider::ClearConfiguration()
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CHardwareTestProvider::ClearConfiguration");

    for(DWORD i = 0; i < m_cDiskIds; i++)
        {
        if (m_rgpSourceLuns[i] != NULL)
            {
            FreeLunInfo(m_rgpSourceLuns[i], 1);
            m_rgpSourceLuns[i] = NULL;
            }

        if (m_rgpDestinationLuns[i] != NULL)
            {
            FreeLunInfo(m_rgpDestinationLuns[i], 1);
            m_rgpDestinationLuns[i] = NULL;
            }
        }

    m_cDiskIds = 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\hwprv\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hwprv.rc
//
#define IDS_PROJNAME                    100
#define IDR_HWPRV                       101
#define IDS_SERVICE_DESCRIPTION         102

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\hwprv\vsnap\debug.cpp ===
#include "stdafx.hxx"
#include "vss.h"
#include "vswriter.h"
#include "vsbackup.h"
#include <debug.h>


LPCWSTR GetStringFromFailureType(HRESULT hrStatus)
{
    LPCWSTR pwszFailureType = L"";

    switch (hrStatus)
	{
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:        pwszFailureType = L"VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT";    break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:              pwszFailureType = L"VSS_E_WRITERERROR_OUTOFRESOURCES";          break;
	case VSS_E_WRITERERROR_TIMEOUT:                     pwszFailureType = L"VSS_E_WRITERERROR_TIMEOUT";                 break;
	case VSS_E_WRITERERROR_NONRETRYABLE:                pwszFailureType = L"VSS_E_WRITERERROR_NONRETRYABLE";            break;
	case VSS_E_WRITERERROR_RETRYABLE:                   pwszFailureType = L"VSS_E_WRITERERROR_RETRYABLE";               break;
	case VSS_E_BAD_STATE:                               pwszFailureType = L"VSS_E_BAD_STATE";                           break;
	case VSS_E_PROVIDER_ALREADY_REGISTERED:             pwszFailureType = L"VSS_E_PROVIDER_ALREADY_REGISTERED";         break;
	case VSS_E_PROVIDER_NOT_REGISTERED:                 pwszFailureType = L"VSS_E_PROVIDER_NOT_REGISTERED";             break;
	case VSS_E_PROVIDER_VETO:                           pwszFailureType = L"VSS_E_PROVIDER_VETO";                       break;
	case VSS_E_PROVIDER_IN_USE:				            pwszFailureType = L"VSS_E_PROVIDER_IN_USE";                     break;
	case VSS_E_OBJECT_NOT_FOUND:						pwszFailureType = L"VSS_E_OBJECT_NOT_FOUND";                    break;						
	case VSS_S_ASYNC_PENDING:							pwszFailureType = L"VSS_S_ASYNC_PENDING";                       break;
	case VSS_S_ASYNC_FINISHED:						    pwszFailureType = L"VSS_S_ASYNC_FINISHED";                      break;
	case VSS_S_ASYNC_CANCELLED:						    pwszFailureType = L"VSS_S_ASYNC_CANCELLED";                     break;
	case VSS_E_VOLUME_NOT_SUPPORTED:					pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED";                break;
	case VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER:		pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER";    break;
	case VSS_E_OBJECT_ALREADY_EXISTS:					pwszFailureType = L"VSS_E_OBJECT_ALREADY_EXISTS";               break;
	case VSS_E_UNEXPECTED_PROVIDER_ERROR:				pwszFailureType = L"VSS_E_UNEXPECTED_PROVIDER_ERROR";           break;
	case VSS_E_CORRUPT_XML_DOCUMENT:				    pwszFailureType = L"VSS_E_CORRUPT_XML_DOCUMENT";                break;
	case VSS_E_INVALID_XML_DOCUMENT:					pwszFailureType = L"VSS_E_INVALID_XML_DOCUMENT";                break;
	case VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED:       pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED";   break;
	case VSS_E_FLUSH_WRITES_TIMEOUT:                    pwszFailureType = L"VSS_E_FLUSH_WRITES_TIMEOUT";                break;
	case VSS_E_HOLD_WRITES_TIMEOUT:                     pwszFailureType = L"VSS_E_HOLD_WRITES_TIMEOUT";                 break;
	case VSS_E_UNEXPECTED_WRITER_ERROR:                 pwszFailureType = L"VSS_E_UNEXPECTED_WRITER_ERROR";             break;
	case VSS_E_SNAPSHOT_SET_IN_PROGRESS:                pwszFailureType = L"VSS_E_SNAPSHOT_SET_IN_PROGRESS";            break;
	case VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED:     pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED"; break;
	case VSS_E_WRITER_INFRASTRUCTURE:	 		        pwszFailureType = L"VSS_E_WRITER_INFRASTRUCTURE";               break;
	case VSS_E_WRITER_NOT_RESPONDING:			        pwszFailureType = L"VSS_E_WRITER_NOT_RESPONDING";               break;
    case VSS_E_WRITER_ALREADY_SUBSCRIBED:		        pwszFailureType = L"VSS_E_WRITER_ALREADY_SUBSCRIBED";           break;
	
	case NOERROR:
	default:
	    break;
	}

    return (pwszFailureType);
}


// This function displays the formatted message at the console and throws
// The passed return code will be returned by vsreq.exe
void Error(
    IN  INT nReturnCode,
    IN  const WCHAR* pwszMsgFormat,
    IN  ...
    )
{
    va_list marker;
    va_start( marker, pwszMsgFormat );
    vwprintf( pwszMsgFormat, marker );
    va_end( marker );

	BS_ASSERT(FALSE);
    // throw that return code.
    throw(nReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\betest\voltest.cxx ===
#include "stdafx.hxx"
#include "vss.h"
#include "vswriter.h"
#include "vsbackup.h"
#include <debug.h>
#include <time.h>

#include <vs_inc.hxx>
#include <vsevent.h>
#include <vscoordint.h>
#include <vdslun.h>
#include <vs_wmxml.hxx>
#include <vs_cmxml.hxx>
#include <vs_trace.hxx>

void PrintVolumeInfo(LPWSTR wszVolume)
	{
	wprintf(L"\n\nInformation for volume %s\n\n", wszVolume);
	// get rid of last backslash
	wszVolume[wcslen(wszVolume)-1] = L'\0';

	HANDLE hVol = CreateFile
					(
					wszVolume,
					GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL
					);

    if (hVol == INVALID_HANDLE_VALUE)
		{
		DWORD dwErr = GetLastError();
		wprintf(L"CreateFile of volume failed with error %d.\n", dwErr);
		return;
		}

	WCHAR bufExtents[1024];
	DWORD size;
	BOOL b = DeviceIoControl
			(
			hVol,
			IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
			NULL,
			0,
			(PVOID) bufExtents,
			sizeof(bufExtents),
			&size,
			NULL
			);

    if (!b)
		{
		DWORD dwErr = GetLastError();
		wprintf(L"IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS failed with error %d.\n", dwErr);
		CloseHandle(hVol);
		return;
		}

	VOLUME_DISK_EXTENTS *pDiskExtents = (VOLUME_DISK_EXTENTS *) bufExtents;

	ULONG PrevDiskNo = 0xffffffff;
	printf("# of extents = %d\n\n", pDiskExtents->NumberOfDiskExtents);

	for(UINT iExtent = 0; iExtent < pDiskExtents->NumberOfDiskExtents; iExtent++)
		{
		ULONG DiskNo = pDiskExtents->Extents[iExtent].DiskNumber;
		printf("Extent %d:\nDisk %d, Low=0x%I64lx, Length=0x%I64lx\n\n",
			   iExtent,
		       DiskNo,
               pDiskExtents->Extents[iExtent].StartingOffset,
               pDiskExtents->Extents[iExtent].ExtentLength
			   );

		if (DiskNo != PrevDiskNo)
			{
			PrevDiskNo = DiskNo;
			WCHAR wszbuf[32];
			swprintf(wszbuf, L"\\\\.\\PHYSICALDRIVE%u", DiskNo);
			HANDLE hDisk = CreateFile
								(
								wszbuf,
								GENERIC_READ|GENERIC_WRITE,
								FILE_SHARE_READ,
								NULL,
								OPEN_EXISTING,
								0,
								NULL
								);

            if (hDisk == INVALID_HANDLE_VALUE)
				{
				DWORD dwErr = GetLastError();
				wprintf(L"Cannot open disk %d due to error %d.  Skipping\n", DiskNo, dwErr);
				continue;
				}

			STORAGE_PROPERTY_QUERY query;
			query.PropertyId = StorageDeviceProperty;
			query.QueryType = PropertyStandardQuery;
			BYTE buf[1024];
			DWORD dwSize;

			if (!DeviceIoControl
						(
						hDisk,
						IOCTL_STORAGE_QUERY_PROPERTY,
						&query,
						sizeof(query),
						buf,
						1024,
						&dwSize,
						NULL
						))
                {
				DWORD dwErr = GetLastError();
				if (dwErr != ERROR_NOT_SUPPORTED)
					wprintf(L"IOCTL_STORAGE_QUERY_PROPERTY failed due to error %d.\n", dwErr);

				CloseHandle(hDisk);
				continue;
				}

			STORAGE_DEVICE_DESCRIPTOR *pDesc = (STORAGE_DEVICE_DESCRIPTOR *) buf;
			printf("Information for disk %d.\n\nbus=", DiskNo);

			switch (pDesc->BusType)
                {
				default:
					printf("(other)\n");
					break;
					

				case BusTypeScsi:
					printf("(SCSI)\n");
					break;

				case BusTypeAtapi:
					printf("(ATAPI)\n");
					break;

                case BusTypeAta:
					printf("(ATA)\n");
					break;

				case BusType1394:
					printf("(1394)\n");
					break;

				case BusTypeSsa:
					printf("(SSA)\n");
					break;

				case BusTypeFibre:
					printf("(Fibre)\n");
					break;

				case BusTypeUsb:
					printf("(Usb)\n");
					break;

				case BusTypeRAID:
					printf("(RAID)\n");
					break;
                }

            if (pDesc->VendorIdOffset)
				{
                LPSTR szVendor = (LPSTR)((BYTE *) pDesc + pDesc->VendorIdOffset);
				printf("VendorId: %s\n", szVendor);
                }

			if (pDesc->ProductIdOffset)
                {
				LPSTR szProduct = (LPSTR)((BYTE *) pDesc + pDesc->ProductIdOffset);
				printf("ProductId: %s\n", szProduct);
                }
			if (pDesc->ProductRevisionOffset)
                {
				LPSTR szRevision = (LPSTR)((BYTE *) pDesc + pDesc->ProductRevisionOffset);
				printf("RevisionId: %s\n", szRevision);
                }

			if (pDesc->SerialNumberOffset)
				{
				LPSTR szSerialNo = (LPSTR)((BYTE *) pDesc + pDesc->SerialNumberOffset);
				printf("Serial#: %s\n", szSerialNo);
				}

			query.PropertyId = StorageDeviceIdProperty;
			query.QueryType = PropertyStandardQuery;

			if (!DeviceIoControl
						(
						hDisk,
						IOCTL_STORAGE_QUERY_PROPERTY,
						&query,
						sizeof(query),
						buf,
						1024,
						&dwSize,
						NULL
						))
                {
				DWORD dwErr = GetLastError();
			    if (dwErr != ERROR_NOT_SUPPORTED)
					wprintf(L"IOCTL_STORAGE_QUERY_PROPERTY failed due to error %d.\n", dwErr);

				CloseHandle(hDisk);
				continue;
				}

			STORAGE_DEVICE_ID_DESCRIPTOR *pDevId = (STORAGE_DEVICE_ID_DESCRIPTOR *) buf;
			printf("# of identifiers = %d\n", pDevId->NumberOfIdentifiers);

			STORAGE_IDENTIFIER *pId = (STORAGE_IDENTIFIER *) pDevId->Identifiers;
			for(UINT i = 0; i < pDevId->NumberOfIdentifiers; i++)
				{
				switch(pId->Type)
					{
					default:
						printf("(other) ");
						break;

                    case StorageIdTypeVendorSpecific:
						printf("(vendor specific) ");
						break;

                    case StorageIdTypeVendorId:
						printf("(vendor id) ");
						break;

                    case StorageIdTypeEUI64:
						printf("(EUI64) ");
						break;

                    case StorageIdTypeFCPHName:
						printf("(FCPHName) ");
						break;
                    }

				if (pId->CodeSet == StorageIdCodeSetAscii)
					printf("%s\n", pId->Identifier);
				else
					{
					for(UINT i = 0; i < pId->IdentifierSize; i++)
						{
						printf("%2x ", pId->Identifier[i]);
						if ((i % 16) == 0 && i > 0)
							printf("\n");
						}
					}

				pId = (STORAGE_IDENTIFIER *) ((BYTE *) pId + pId->NextOffset);
				}
				

			CloseHandle(hDisk);
			}
		}
	}



				



void EnumVolumes()
	{
	CVssFunctionTracer ft(VSSDBG_XML, L"EnumVolumes");

	HANDLE h = INVALID_HANDLE_VALUE;
	try
		{
		WCHAR volName[1024];

		h = FindFirstVolume(volName, sizeof(volName)/sizeof(WCHAR));
		if (h == INVALID_HANDLE_VALUE)
			{
			DWORD dwErr = GetLastError();
			Error(E_UNEXPECTED, L"FindFirstVolume failed due to error %d.\n", dwErr);
			}

		while(TRUE)
			{
			PrintVolumeInfo(volName);
			if (!FindNextVolume(h, volName, sizeof(volName)/ sizeof(WCHAR)))
				{
				DWORD dwErr = GetLastError();
				if (dwErr == ERROR_NO_MORE_FILES)
					break;
				else
					Error(E_UNEXPECTED, L"Unexpected error %d from FindNextVolume.\n", dwErr);
				}
			}

		if (!FindVolumeClose(h))
			{
			DWORD dwErr = GetLastError();
			Error(E_UNEXPECTED, L"Cannot close volume handle due to error %d.\n", dwErr);
			}

		h = INVALID_HANDLE_VALUE;
		}
	VSS_STANDARD_CATCH(ft)

	if (h != INVALID_HANDLE_VALUE)
		FindClose(h);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\jettest\stdafx.h ===
#include <wtypes.h>
#pragma warning( disable: 4201 )    // C4201: nonstandard extension used : nameless struct/union
#include <winioctl.h>
#pragma warning( default: 4201 )	// C4201: nonstandard extension used : nameless struct/union
#include <winbase.h>



#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <stdio.h>
#include <stdlib.h>

#include <vs_assert.hxx>

#include <stddef.h>
#include <atlconv.h>
#include <atlbase.h>
CComModule _Module;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\hwprv\vsnap\debug.h ===
// Execute the given call and check that the return code must be S_OK
#define CHECK_SUCCESS( Call )                                                                           \
    {                                                                                                   \
        hr = Call;                                                                                    \
        if (hr != S_OK)                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }

#define CHECK_NOFAIL( Call )                                                                            \
    {                                                                                                   \
        hr = Call;                                                                                    \
        if (FAILED(hr))                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }



void Error(INT nReturnCode, const WCHAR* pwszMsgFormat, ...);
LPCWSTR GetStringFromFailureType(HRESULT hrStatus);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\metasnap\metasnap.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	metasnap.cpp
**
**
** Abstract:
**
**	Test program to obtain and display the Writer metadata.
**
**
** Author:
**
**	Michael C. Johnson   [mikejohn]        21-Jul-2000
**
**	(Based on another test program BETEST by Brian Berkowitz)
**
**
** Revision History:
**
**--
*/

/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/
#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>


#include <oleauto.h>

#define ATLASSERT(_condition)

#include <atlconv.h>
#include <atlbase.h>

extern CComModule _Module;
#include <atlcom.h>



inline void CHECK_SUCCESS (HRESULT hr)
    {
    if (hr != S_OK)
	{
	wprintf(L"operation failed with HRESULT =0x%08x\n", hr);
	DebugBreak();
	}
    }

inline void CHECK_NOFAIL (HRESULT hr)
    {
    if (FAILED(hr))
	{
	wprintf(L"operation failed with HRESULT =0x%08x\n", hr);
	DebugBreak();
	}
    }



BOOL AssertPrivilege( LPCWSTR privName )
    {
    HANDLE		 tokenHandle;
    TOKEN_PRIVILEGES	 newState;
    TOKEN_PRIVILEGES	*pTokens = NULL;
    BOOL		 stat    = FALSE;
    LUID		 value;
    DWORD		 error;
    DWORD		 cbTokens;


    if (OpenProcessToken (GetCurrentProcess(),
			  TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,
			  &tokenHandle))
	{

	if (LookupPrivilegeValue (NULL, privName, &value))
	    {
	    newState.PrivilegeCount            = 1;
	    newState.Privileges [0].Luid       = value;
	    newState.Privileges [0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED;

	    /*
	    ** We will always call GetLastError below, so clear
	    ** any prior error values on this thread.
	    */
	    SetLastError (ERROR_SUCCESS);

	    stat = AdjustTokenPrivileges (tokenHandle,
					  FALSE,
					  &newState,
					  (DWORD)0,
					  NULL,
					  NULL);

	    /*
	    ** Supposedly, AdjustTokenPriveleges always returns TRUE
	    ** (even when it fails). So, call GetLastError to be
	    ** extra sure everything's cool.
	    */
	    if ((error = GetLastError()) != ERROR_SUCCESS)
		{
		stat = FALSE;
		}

	    if (!stat)
		{
		wprintf (L"AdjustTokenPrivileges for %s failed with %d",
			 privName,
			 error);
		}
	    }



	GetTokenInformation (tokenHandle,
			     TokenPrivileges,
			     NULL,
			     0,
			     &cbTokens);


	pTokens = (TOKEN_PRIVILEGES *) new BYTE[cbTokens];

	GetTokenInformation (tokenHandle,
			     TokenPrivileges,
			     pTokens,
			     cbTokens,
			     &cbTokens);

	delete pTokens;
	CloseHandle (tokenHandle);
	}


    return stat;
    }


LPCWSTR GetStringFromUsageType (VSS_USAGE_TYPE eUsageType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eUsageType)
	{
	case VSS_UT_BOOTABLESYSTEMSTATE: pwszRetString = L"BootableSystemState"; break;
	case VSS_UT_SYSTEMSERVICE:       pwszRetString = L"SystemService";       break;
	case VSS_UT_USERDATA:            pwszRetString = L"UserData";            break;
	case VSS_UT_OTHER:               pwszRetString = L"Other";               break;
					
	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eSourceType)
	{
	case VSS_ST_TRANSACTEDDB:    pwszRetString = L"TransactionDb";    break;
	case VSS_ST_NONTRANSACTEDDB: pwszRetString = L"NonTransactionDb"; break;
	case VSS_ST_OTHER:           pwszRetString = L"Other";            break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromRestoreMethod (VSS_RESTOREMETHOD_ENUM eRestoreMethod)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eRestoreMethod)
	{
	case VSS_RME_RESTORE_IF_NOT_THERE:          pwszRetString = L"RestoreIfNotThere";          break;
	case VSS_RME_RESTORE_IF_CAN_REPLACE:        pwszRetString = L"RestoreIfCanReplace";        break;
	case VSS_RME_STOP_RESTORE_START:            pwszRetString = L"StopRestoreStart";           break;
	case VSS_RME_RESTORE_TO_ALTERNATE_LOCATION: pwszRetString = L"RestoreToAlternateLocation"; break;
	case VSS_RME_RESTORE_AT_REBOOT:             pwszRetString = L"RestoreAtReboot";            break;
	case VSS_RME_CUSTOM:                        pwszRetString = L"Custom";                     break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromWriterRestoreMethod (VSS_WRITERRESTORE_ENUM eWriterRestoreMethod)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eWriterRestoreMethod)
	{
	case VSS_WRE_NEVER:            pwszRetString = L"RestoreNever";           break;
	case VSS_WRE_IF_REPLACE_FAILS: pwszRetString = L"RestoreIfReplaceFailsI"; break;
	case VSS_WRE_ALWAYS:           pwszRetString = L"RestoreAlways";          break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eComponentType)
	{
	case VSS_CT_DATABASE:  pwszRetString = L"Database";  break;
	case VSS_CT_FILEGROUP: pwszRetString = L"FileGroup"; break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromFailureType (HRESULT hrStatus)
    {
    LPCWSTR pwszFailureType;

    switch (hrStatus)
	{
	case NOERROR:                                pwszFailureType = L"";                     break;
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT: pwszFailureType = L"InconsistentSnapshot"; break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:       pwszFailureType = L"OutOfResources";       break;
	case VSS_E_WRITERERROR_TIMEOUT:              pwszFailureType = L"Timeout";              break;
	case VSS_E_WRITERERROR_NONRETRYABLE:         pwszFailureType = L"Non-Retryable";        break;
	case VSS_E_WRITERERROR_RETRYABLE:            pwszFailureType = L"Retryable";            break;
	default:                                     pwszFailureType = L"UNDEFINED";            break;
	}

    return (pwszFailureType);
    }





void PrintFiledesc (IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription)
    {
    CComBSTR bstrPath;
    CComBSTR bstrFilespec;
    CComBSTR bstrAlternate;
    bool     bRecursive;


    CHECK_SUCCESS (pFiledesc->GetPath (&bstrPath));
    CHECK_SUCCESS (pFiledesc->GetFilespec (&bstrFilespec));
    CHECK_NOFAIL  (pFiledesc->GetRecursive (&bRecursive));
    CHECK_NOFAIL  (pFiledesc->GetAlternateLocation (&bstrAlternate));

    wprintf (L"%s\n            Path = %s, Filespec = %s, Recursive = %s\n",
	     wszDescription,
	     bstrPath,
	     bstrFilespec,
	     bRecursive ? L"yes" : L"no");

    if (bstrAlternate && wcslen (bstrAlternate) > 0)
	{
	wprintf(L"            Alternate Location = %s\n", bstrAlternate);
	}
    }



extern "C" __cdecl wmain(int argc, WCHAR **argv)
    {
    HRESULT	hr                     = NOERROR;
    bool	bCoInitializeSucceeded = false;


    UNREFERENCED_PARAMETER (argc);
    UNREFERENCED_PARAMETER (argv);


    try
	{
	unsigned cWriters;
	CComBSTR bstrXML;
	CComBSTR bstrXMLOut;
	CComBSTR strSnapshotSetId = "12345678-1234-1234-1234-1234567890ab";
	CComPtr<IVssBackupComponents> pvbc;
	CComPtr<IVssAsync> pAsync;


        CHECK_SUCCESS (CoInitializeEx (NULL, COINIT_MULTITHREADED));

	bCoInitializeSucceeded = true;

	if (!AssertPrivilege (SE_BACKUP_NAME))
	    {
	    wprintf(L"AssertPrivilege returned error, rc:%d\n", GetLastError ());
	    return 2;
	    }

	CHECK_SUCCESS (CreateVssBackupComponents (&pvbc));

	CHECK_SUCCESS (pvbc->InitializeForBackup  ());
	CHECK_SUCCESS (pvbc->SetBackupState       (true, false, VSS_BT_FULL, false));
	CHECK_NOFAIL  (pvbc->GatherWriterMetadata (&pAsync));
	CHECK_NOFAIL  (pAsync->Wait ());
	CHECK_NOFAIL  (pvbc->GetWriterMetadataCount (&cWriters));


	for (unsigned iWriter = 0; iWriter < cWriters; iWriter++)
	    {
	    CComPtr<IVssExamineWriterMetadata> pMetadata;

	    VSS_ID           idInstance;
	    VSS_ID           idInstanceT;
	    VSS_ID           idWriter;
	    CComBSTR         bstrWriterName;
	    VSS_USAGE_TYPE   usage;
	    VSS_SOURCE_TYPE  source;
	    WCHAR           *pwszInstanceId;
	    WCHAR           *pwszWriterId;
	    unsigned cIncludeFiles, cExcludeFiles, cComponents;
	    CComBSTR bstrPath;
	    CComBSTR bstrFilespec;
	    CComBSTR bstrAlternate;
	    CComBSTR bstrDestination;



	    CHECK_SUCCESS (pvbc->GetWriterMetadata(iWriter, &idInstance, &pMetadata));

	    CHECK_SUCCESS (pMetadata->GetIdentity (&idInstanceT,
						   &idWriter,
						   &bstrWriterName,
						   &usage,
						   &source));

	    wprintf (L"\n\n");

            if (memcmp (&idInstance, &idInstanceT, sizeof(VSS_ID)) != 0)
		{
		wprintf(L"Instance id mismatch\n");
		DebugBreak();
		}


	    UuidToString (&idInstance, &pwszInstanceId);
	    UuidToString (&idWriter,   &pwszWriterId);

	    wprintf (L"WriterName = %s\n\n"
		     L"    WriterId   = %s\n"
		     L"    InstanceId = %s\n"
		     L"    UsageType  = %d (%s)\n"
		     L"    SourceType = %d (%s)\n",
		     bstrWriterName,
		     pwszWriterId,
		     pwszInstanceId,
		     usage,
		     GetStringFromUsageType (usage),
		     source,
		     GetStringFromSourceType (source));

	    RpcStringFree (&pwszInstanceId);
	    RpcStringFree (&pwszWriterId);

	    CHECK_SUCCESS(pMetadata->GetFileCounts (&cIncludeFiles,
						    &cExcludeFiles,
						    &cComponents));

	    for(unsigned i = 0; i < cIncludeFiles; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;

		CHECK_SUCCESS (pMetadata->GetIncludeFile (i, &pFiledesc));

		PrintFiledesc(pFiledesc, L"\n    Include File");
		}


	    for(i = 0; i < cExcludeFiles; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;

		CHECK_SUCCESS (pMetadata->GetExcludeFile (i, &pFiledesc));

		PrintFiledesc (pFiledesc, L"\n    Exclude File");
		}


	    for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
		CComPtr<IVssWMComponent> pComponent;
		PVSSCOMPONENTINFO pInfo;

		CHECK_SUCCESS (pMetadata->GetComponent      (iComponent, &pComponent));
		CHECK_SUCCESS (pComponent->GetComponentInfo (&pInfo));

		wprintf (L"\n"
			 L"    Component %d, type = %d (%s)\n"
			 L"        LogicalPath = %s\n"
			 L"        Name        = %s\n"
			 L"        Caption     = %s\n",
			 iComponent,
			 pInfo->type,
			 GetStringFromComponentType (pInfo->type),
			 pInfo->bstrLogicalPath,
			 pInfo->bstrComponentName,
			 pInfo->bstrCaption);

					

                if (pInfo->cbIcon > 0)
		    {
		    if (pInfo->cbIcon != 10 ||
			pInfo->pbIcon[0] != 1 ||
			pInfo->pbIcon[1] != 2 ||
			pInfo->pbIcon[2] != 3 ||
			pInfo->pbIcon[3] != 4 ||
			pInfo->pbIcon[4] != 5 ||
			pInfo->pbIcon[5] != 6 ||
			pInfo->pbIcon[6] != 7 ||
			pInfo->pbIcon[7] != 8 ||
			pInfo->pbIcon[8] != 9 ||
			pInfo->pbIcon[9] != 10)
			{
			wprintf(L"        Icon is not valid.\n");
			DebugBreak();
			}
		    else
			wprintf(L"        Icon is valid.\n");
		    }

		wprintf (L"        RestoreMetadata        = %s\n"
			 L"        NotifyOnBackupComplete = %s\n"
			 L"        Selectable             = %s\n",
			 pInfo->bRestoreMetadata        ? L"yes" : L"no",
			 pInfo->bNotifyOnBackupComplete ? L"yes" : L"no",
			 pInfo->bSelectable             ? L"yes" : L"no");


		if (pInfo->cFileCount > 0)
		    {
		    for(i = 0; i < pInfo->cFileCount; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;

			CHECK_SUCCESS (pComponent->GetFile (i, &pFiledesc));

			PrintFiledesc (pFiledesc, L"        FileGroupFile");
			}
		    }

		if (pInfo->cDatabases > 0)
		    {
		    for(i = 0; i < pInfo->cDatabases; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;

			CHECK_SUCCESS (pComponent->GetDatabaseFile (i, &pFiledesc));

			PrintFiledesc (pFiledesc, L"        DatabaseFile");
			}
		    }


		if (pInfo->cLogFiles > 0)
		    {
		    for(i = 0; i < pInfo->cLogFiles; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;

			CHECK_SUCCESS (pComponent->GetDatabaseLogFile (i, &pFiledesc));

			PrintFiledesc (pFiledesc, L"        DatabaseLogFile");
			}
		    }

		pComponent->FreeComponentInfo (pInfo);
		}



	    VSS_RESTOREMETHOD_ENUM method;
	    CComBSTR bstrUserProcedure;
	    CComBSTR bstrService;
	    VSS_WRITERRESTORE_ENUM writerRestore;
	    unsigned cMappings;
	    bool bRebootRequired;

	    CHECK_NOFAIL (pMetadata->GetRestoreMethod (&method,
						       &bstrService,
						       &bstrUserProcedure,
						       &writerRestore,
						       &bRebootRequired,
						       &cMappings));


	    wprintf (L"\n"
		     L"    Restore method = %d (%s)\n"
		     L"    Service        = %d\n"
		     L"    User Procedure = %s\n"
		     L"    WriterRestore  = %d (%s)\n"
		     L"    RebootRequired = %s\n",
		     method,
		     GetStringFromRestoreMethod (method),
		     bstrService,
		     bstrUserProcedure,
		     writerRestore,
		     GetStringFromWriterRestoreMethod (writerRestore),
		     bRebootRequired ? L"yes" : L"no");

	    for(i = 0; i < cMappings; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;

		CHECK_SUCCESS (pMetadata->GetAlternateLocationMapping (i, &pFiledesc));

		PrintFiledesc (pFiledesc, L"    AlternateMapping");
		}
	    }


	CHECK_SUCCESS (pvbc->FreeWriterMetadata());
	}
    catch(...)
	{
	hr = E_UNEXPECTED;
	}


    if (FAILED(hr))             wprintf (L"Failed with 0x%08X.\n", hr);
    if (bCoInitializeSucceeded) CoUninitialize();

    return (0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\multilayer\ml.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	    ml.cpp
**
**
** Abstract:
**
**	    Test program to exercise backup and multilayer snapshots
**
** Author:
**
**	    Adi Oltean      [aoltean]       02/22/2001
**
**
** Revision History:
**
**--
*/


///////////////////////////////////////////////////////////////////////////////
// Includes

#include "ml.h"

#include "vsbackup.h"

#include "ntddsnap.h"
#include <initguid.h>
#include "ichannel.hxx"

#include "copy.hxx"
#include "pointer.hxx"
#include "enum.hxx"

#include "qsnap.hxx"



///////////////////////////////////////////////////////////////////////////////
// Processing functions

void CVssMultilayerTest::Initialize()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::Initialize");

    wprintf (L"\n----------------- Initializing ---------------------\n");

    // Initialize the random starting point.
    srand(m_uSeed);

    // Initialize COM library
    CHECK_NOFAIL(CoInitializeEx (NULL, COINIT_MULTITHREADED));
	m_bCoInitializeSucceeded = true;
    wprintf (L"COM library initialized.\n");

    // Initialize COM security
    CHECK_SUCCESS
		(
		CoInitializeSecurity
			(
			NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
			-1,                                  //  IN LONG                         cAuthSvc,
			NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
			NULL,                                //  IN void                        *pReserved1,
			RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
			RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
			NULL,                                //  IN void                        *pAuthList,
			EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
			NULL                                 //  IN void                        *pReserved3
			)
		);
    wprintf (L"COM security initialized.\n");
}


// Run the tests
void CVssMultilayerTest::Run()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::Run");

    BS_ASSERT(!m_bAttachYourDebuggerNow);

    switch(m_eTest)
    {
    case VSS_TEST_QUERY_VOLUMES:
        QuerySupportedVolumes();
        break;

    case VSS_TEST_QUERY_SNAPSHOTS:
        QuerySnapshots();
        break;

    case VSS_TEST_VOLSNAP_QUERY:
        QueryVolsnap();
        break;

    case VSS_TEST_DELETE_BY_SNAPSHOT_ID:
        DeleteBySnapshotId();
        break;

    case VSS_TEST_DELETE_BY_SNAPSHOT_SET_ID:
        DeleteBySnapshotSetId();
        break;

    case VSS_TEST_QUERY_SNAPSHOTS_ON_VOLUME:
        QuerySnapshotsByVolume();
        break;

    case VSS_TEST_CREATE:
        // Preload the list of existing snapshots
        PreloadExistingSnapshots();

        if (m_lContext)
            CreateTimewarpSnapshotSet();
        else
            CreateBackupSnapshotSet();
        break;

    case VSS_TEST_ADD_DIFF_AREA:
        AddDiffArea();
        break;

    case VSS_TEST_REMOVE_DIFF_AREA:
        RemoveDiffArea();
        break;

    case VSS_TEST_CHANGE_DIFF_AREA_MAX_SIZE:
        ChangeDiffAreaMaximumSize();
        break;

    case VSS_TEST_QUERY_SUPPORTED_VOLUMES_FOR_DIFF_AREA:
        QueryVolumesSupportedForDiffAreas();
        break;

    case VSS_TEST_QUERY_DIFF_AREAS_FOR_VOLUME:
        QueryDiffAreasForVolume();
        break;

    case VSS_TEST_QUERY_DIFF_AREAS_ON_VOLUME:
        QueryDiffAreasOnVolume();
        break;

    case VSS_TEST_IS_VOLUME_SNAPSHOTTED_C:
        IsVolumeSnapshotted_C();
        break;

    default:
        BS_ASSERT(false);
    }
}


// Querying supported volumes
void CVssMultilayerTest::QuerySupportedVolumes()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::QuerySupportedVolumes");

    wprintf (L"\n---------- Querying supported volumes ----------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_SUCCESS(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get list all snapshots
	CComPtr<IVssEnumMgmtObject> pIEnum;
	CHECK_NOFAIL( pMgmt->QueryVolumesSupportedForSnapshots( m_ProviderId, m_lContext, &pIEnum ) )
	if (ft.hr == S_FALSE) {
        wprintf(L"Query: Empty result...\n");
        return;
	}

    wprintf(L"\n%-50s %-15s\n", L"Volume Name", L"Display name");
    wprintf(L"--------------------------------------------------------------------------------\n");

	// For all volumes do...
	VSS_MGMT_OBJECT_PROP Prop;
	VSS_VOLUME_PROP& Vol = Prop.Obj.Vol;
	for(;;) {
		// Get next element
		ULONG ulFetched;
		CHECK_NOFAIL( pIEnum->Next( 1, &Prop, &ulFetched ) );
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        wprintf(L"%-50s %-15s\n",
            Vol.m_pwszVolumeName,
            Vol.m_pwszVolumeDisplayName
            );

        ::CoTaskMemFree(Vol.m_pwszVolumeName);
        ::CoTaskMemFree(Vol.m_pwszVolumeDisplayName);
	}

    wprintf(L"--------------------------------------------------------------------------------\n");

}


// Querying snapshots
void CVssMultilayerTest::QuerySnapshotsByVolume()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::QuerySnapshotsByVolume");

    wprintf (L"\n---------- Querying snapshots on volume ----------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_NOFAIL(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get list all snapshots
	CComPtr<IVssEnumObject> pIEnumSnapshots;
	CHECK_NOFAIL( pMgmt->QuerySnapshotsByVolume( m_pwszVolume, m_ProviderId, &pIEnumSnapshots ) );
	if (ft.hr == S_FALSE) {
        wprintf(L"Query: Empty result...\n");
        return;
	}

    wprintf(L"\n%-8s %-38s %-50s %-50s\n", L"Attrib.", L"Snapshot ID", L"Original Volume Name", L"Snapshot device name");
    wprintf(L"--------------------------------------------------------------------------------------------------------------------------------------------------------------\n");
	// For all snapshots do...
	VSS_OBJECT_PROP Prop;
	VSS_SNAPSHOT_PROP& Snap = Prop.Obj.Snap;
	for(;;) {
		// Get next element
		ULONG ulFetched;
		CHECK_NOFAIL( pIEnumSnapshots->Next( 1, &Prop, &ulFetched ) );
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        wprintf(L"%08lx " WSTR_GUID_FMT L" %-50s %-50s\n",
            Snap.m_lSnapshotAttributes,
            GUID_PRINTF_ARG(Snap.m_SnapshotId),
            Snap.m_pwszOriginalVolumeName,
            Snap.m_pwszSnapshotDeviceObject
            );

        ::VssFreeSnapshotProperties(&Snap);
	}

    wprintf(L"--------------------------------------------------------------------------------------------------------------------------------------------------------------\n");

}

// Querying snapshots
void CVssMultilayerTest::QuerySnapshots()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::QuerySnapshots");

    wprintf (L"\n---------- Querying existing snapshots ----------------\n");

    // Create a Coordinator interface
    CComPtr<IVssCoordinator> pCoord;
    CHECK_NOFAIL(pCoord.CoCreateInstance( CLSID_VSSCoordinator ));
    if (m_lContext)
        CHECK_NOFAIL(pCoord->SetContext(m_lContext));
    wprintf (L"Coordinator object created with context 0x%08lx.\n", m_lContext);

	// Get list all snapshots
	CComPtr<IVssEnumObject> pIEnumSnapshots;
	CHECK_NOFAIL( pCoord->Query( GUID_NULL, VSS_OBJECT_NONE, VSS_OBJECT_SNAPSHOT, &pIEnumSnapshots ) );
	if (ft.hr == S_FALSE) {
        wprintf(L"Query: Empty result...\n");
        return;
	}

    wprintf(L"\n%-8s %-38s %-50s %-50s\n", L"Attrib.", L"Snapshot ID", L"Original Volume Name", L"Snapshot device name");
    wprintf(L"--------------------------------------------------------------------------------------------------------------------------------------------------------------\n");
	// For all snapshots do...
	VSS_OBJECT_PROP Prop;
	VSS_SNAPSHOT_PROP& Snap = Prop.Obj.Snap;
	for(;;) {
		// Get next element
		ULONG ulFetched;
		CHECK_NOFAIL( pIEnumSnapshots->Next( 1, &Prop, &ulFetched ));
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        wprintf(L"%08lx " WSTR_GUID_FMT L" %-50s %-50s\n",
            Snap.m_lSnapshotAttributes,
            GUID_PRINTF_ARG(Snap.m_SnapshotId),
            Snap.m_pwszOriginalVolumeName,
            Snap.m_pwszSnapshotDeviceObject
            );

        ::CoTaskMemFree(Snap.m_pwszOriginalVolumeName);
        ::CoTaskMemFree(Snap.m_pwszSnapshotDeviceObject);
	}

    wprintf(L"--------------------------------------------------------------------------------------------------------------------------------------------------------------\n");

}


// Delete by snapshot Id
void CVssMultilayerTest::DeleteBySnapshotId()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::DeleteBySnapshotId");

    // Create a Timewarp Coordinator interface
    CHECK_NOFAIL(m_pTimewarpCoord.CoCreateInstance( CLSID_VSSCoordinator ));
    CHECK_NOFAIL(m_pTimewarpCoord->SetContext(m_lContext));
    wprintf (L"Timewarp Coordinator object created.\n");

    wprintf (L"\n---------- Deleting TIMEWARP snapshot ----------------\n");

    LONG lDeletedSnapshots = 0;
    VSS_ID ProblemSnapshotId = GUID_NULL;
    ft.hr = m_pTimewarpCoord->DeleteSnapshots(m_SnapshotId,
                VSS_OBJECT_SNAPSHOT,
                TRUE,
                &lDeletedSnapshots,
                &ProblemSnapshotId
                );

    if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
        wprintf( L"Snapshot with ID " WSTR_GUID_FMT L" not found in any provider\n", GUID_PRINTF_ARG(m_SnapshotId));
    else if (ft.hr == S_OK)
        wprintf( L"Snapshot with ID " WSTR_GUID_FMT L" successfully deleted\n", GUID_PRINTF_ARG(m_SnapshotId));
    else
        wprintf( L"Error deleting Snapshot with ID " WSTR_GUID_FMT L" 0x%08lx\n"
                 L"Deleted Snapshots %ld\n",
                 L"Snapshot with problem: " WSTR_GUID_FMT L"\n",
                 GUID_PRINTF_ARG(m_SnapshotId),
                 lDeletedSnapshots,
                 GUID_PRINTF_ARG(ProblemSnapshotId)
                 );

    wprintf (L"\n------------------------------------------------------\n");
}


// Delete by snapshot set Id
void CVssMultilayerTest::DeleteBySnapshotSetId()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::DeleteBySnapshotSetId");

    // Create a Timewarp Coordinator interface
    CHECK_NOFAIL(m_pTimewarpCoord.CoCreateInstance( CLSID_VSSCoordinator ));
    CHECK_NOFAIL(m_pTimewarpCoord->SetContext(m_lContext));
    wprintf (L"Timewarp Coordinator object created.\n");

    wprintf (L"\n---------- Deleting TIMEWARP snapshot set ------------\n");

    LONG lDeletedSnapshots = 0;
    VSS_ID ProblemSnapshotId = GUID_NULL;
    ft.hr = m_pTimewarpCoord->DeleteSnapshots(m_SnapshotSetId,
                VSS_OBJECT_SNAPSHOT_SET,
                TRUE,
                &lDeletedSnapshots,
                &ProblemSnapshotId
                );

    if (ft.hr == VSS_E_OBJECT_NOT_FOUND)
        wprintf( L"Snapshot set with ID " WSTR_GUID_FMT L" not found\n", GUID_PRINTF_ARG(m_SnapshotSetId));
    else if (ft.hr == S_OK)
        wprintf( L"Snapshot set with ID " WSTR_GUID_FMT L" successfully deleted\n", GUID_PRINTF_ARG(m_SnapshotSetId));
    else
        wprintf( L"Error deleting Snapshot set with ID " WSTR_GUID_FMT L" 0x%08lx\n"
                 L"Deleted Snapshots %ld\n",
                 L"Snapshot with problem: " WSTR_GUID_FMT L"\n",
                 GUID_PRINTF_ARG(m_SnapshotSetId),
                 lDeletedSnapshots,
                 GUID_PRINTF_ARG(ProblemSnapshotId)
                 );

    wprintf (L"\n------------------------------------------------------\n");
}


// Querying snapshots using the IOCTL
void CVssMultilayerTest::QueryVolsnap()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::QueryVolsnap");

    // The GUID that corresponds to the format used to store the
    // Backup Snapshot Application Info in Client SKU
    // {BCF5D39C-27A2-4b4c-B9AE-51B111DC9409}
    const GUID VOLSNAP_APPINFO_GUID_BACKUP_CLIENT_SKU = 
    { 0xbcf5d39c, 0x27a2, 0x4b4c, { 0xb9, 0xae, 0x51, 0xb1, 0x11, 0xdc, 0x94, 0x9 } };
/*
    // The GUID that corresponds to the format used to store the
    // Backup Snapshot Application Info in Server SKU
    // {BAE53126-BC65-41d6-86CC-3D56A5CEE693}
    const GUID VOLSNAP_APPINFO_GUID_BACKUP_SERVER_SKU = 
    { 0xbae53126, 0xbc65, 0x41d6, { 0x86, 0xcc, 0x3d, 0x56, 0xa5, 0xce, 0xe6, 0x93 } };


    // The GUID that corresponds to the format used to store the
    // Hidden (Inaccessible) Snapshot Application Info
    // {F12142B4-9A4B-49af-A851-700C42FDC2BE}
    static const GUID VOLSNAP_APPINFO_GUID_HIDDEN = 
    { 0xf12142b4, 0x9a4b, 0x49af, { 0xa8, 0x51, 0x70, 0xc, 0x42, 0xfd, 0xc2, 0xbe } };
*/

    wprintf (L"\n---------- Querying existing snapshots ----------------\n");

    // Check if the volume represents a real mount point
    WCHAR wszVolumeName[MAX_TEXT_BUFFER];
    if (!GetVolumeNameForVolumeMountPoint(m_pwszVolume, wszVolumeName, MAX_TEXT_BUFFER))
        CHECK_NOFAIL(HRESULT_FROM_WIN32(GetLastError()));

    wprintf(L"Querying snapshots on volume %s\n[From oldest to newest]\n\n", wszVolumeName);

	// Check if the snapshot is belonging to that volume
	// Open a IOCTL channel on that volume
	// Eliminate the last backslash in order to open the volume
	CVssIOCTLChannel volumeIChannel;
	CHECK_NOFAIL(volumeIChannel.Open(ft, wszVolumeName, true, false, VSS_ICHANNEL_LOG_NONE));

	// Get the list of snapshots
	// If IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS not
	// supported then try with the next volume.
	CHECK_NOFAIL(volumeIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_NAMES_OF_SNAPSHOTS, false, VSS_ICHANNEL_LOG_NONE));

	// Get the length of snapshot names multistring
	ULONG ulMultiszLen;
	volumeIChannel.Unpack(ft, &ulMultiszLen);

	// Try to find the snapshot with the corresponding Id
	DWORD dwInitialOffset = volumeIChannel.GetCurrentOutputOffset();

	CVssAutoPWSZ pwszSnapshotName;
	while(volumeIChannel.UnpackZeroString(ft, pwszSnapshotName.GetRef())) {
	
		// Compose the snapshot name in a user-mode style
		WCHAR wszUserModeSnapshotName[MAX_PATH];
        ::VssConcatenate( ft, wszUserModeSnapshotName, MAX_PATH - 1,
            wszGlobalRootPrefix, pwszSnapshotName );
		
		// Open that snapshot
		// Do not eliminate the trailing backslash
		// Do not throw on error
    	CVssIOCTLChannel snapshotIChannel;
		CHECK_NOFAIL(snapshotIChannel.Open(ft, wszUserModeSnapshotName, false, false, VSS_ICHANNEL_LOG_NONE));

		// Send the IOCTL to get the application buffer
		CHECK_NOFAIL(snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_APPLICATION_INFO, false, VSS_ICHANNEL_LOG_NONE));

		// Unpack the length of the application buffer
		ULONG ulLen;
		snapshotIChannel.Unpack(ft, &ulLen);

		if (ulLen == 0) {
            wprintf(L"Zero-size snapshot detected: %s\n", pwszSnapshotName);
			continue;
		}

		// Get the application Id
		VSS_ID AppinfoId;
		snapshotIChannel.Unpack(ft, &AppinfoId);

		// Get the snapshot Id
		VSS_ID CurrentSnapshotId;
		snapshotIChannel.Unpack(ft, &CurrentSnapshotId);

		// Get the snapshot set Id
		VSS_ID CurrentSnapshotSetId;
		snapshotIChannel.Unpack(ft, &CurrentSnapshotSetId);

        LONG lStructureContext = -1;
        if (AppinfoId != VOLSNAP_APPINFO_GUID_BACKUP_CLIENT_SKU)
        {
            // Get the snapshot context
    		snapshotIChannel.Unpack(ft, &lStructureContext);
        }

        // Get the snapshot counts
        LONG lSnapshotsCount;
		snapshotIChannel.Unpack(ft, &lSnapshotsCount);

        // Reset the ichannel
		snapshotIChannel.ResetOffsets();

    	// Get the original volume name
    	CHECK_NOFAIL(snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_ORIGINAL_VOLUME_NAME, false, VSS_ICHANNEL_LOG_NONE));

    	// Load the Original volume name
    	VSS_PWSZ pwszOriginalVolumeName = NULL;
    	snapshotIChannel.UnpackSmallString(ft, pwszOriginalVolumeName);

        // Reset the ichannel
		snapshotIChannel.ResetOffsets();

    	// Get the timestamp
    	CHECK_NOFAIL(snapshotIChannel.Call(ft, IOCTL_VOLSNAP_QUERY_CONFIG_INFO, false, VSS_ICHANNEL_LOG_NONE));

    	// Load the Original volume name
        VOLSNAP_CONFIG_INFO configStruct;
    	snapshotIChannel.Unpack(ft, &configStruct);

		// Print the snapshot
		wprintf(
		    L" * Snapshot with name %s:\n"
		    L"      Application Info: " WSTR_GUID_FMT L"\n"
		    L"      SnapshotID: " WSTR_GUID_FMT L"\n"
		    L"      SnapshotSetID: " WSTR_GUID_FMT L"\n"
		    L"      Context: 0x%08lx\n"
		    L"      Snapshot count: %d\n"
		    L"      Original volume: %s\n"
		    L"      Internal attributes: 0x%08lx\n"
		    L"      Reserved config info: 0x%08lx\n"
		    L"      Timestamp: %I64x\n\n"
		    ,
		    pwszSnapshotName.GetRef(),
		    GUID_PRINTF_ARG(AppinfoId),
		    GUID_PRINTF_ARG(CurrentSnapshotId),
		    GUID_PRINTF_ARG(CurrentSnapshotSetId),
		    lStructureContext,
		    lSnapshotsCount,
		    pwszOriginalVolumeName,
		    configStruct.Attributes,
		    configStruct.Reserved,
		    configStruct.SnapshotCreationTime
		    );

		::VssFreeString(pwszOriginalVolumeName);
	}

	// Check if all strings were browsed correctly
	DWORD dwFinalOffset = volumeIChannel.GetCurrentOutputOffset();
	BS_VERIFY( (dwFinalOffset - dwInitialOffset == ulMultiszLen));

    wprintf(L"----------------------------------------------------------\n");

}


// Checks if hte volume is snapshotted using the C API
void CVssMultilayerTest::IsVolumeSnapshotted_C()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::IsVolumeSnapshotted_C");

    wprintf (L"\n---------- Querying IsVolumeSnapshotted ---------------\n");

    BOOL bSnapshotsPresent = FALSE;
    LONG lSnapshotCompatibility = 0;
    CHECK_NOFAIL(IsVolumeSnapshotted(m_pwszVolume, &bSnapshotsPresent, &lSnapshotCompatibility));

    wprintf(L"\n IsVolumeSnapshotted(%s) returned:\n\tSnapshots present = %s\n\tCompatibility flags = 0x%08lx\n\n",
        m_pwszVolume, bSnapshotsPresent? L"True": L"False", lSnapshotCompatibility);

    wprintf(L"----------------------------------------------------------\n");

}


// Preloading  snapshots
void CVssMultilayerTest::PreloadExistingSnapshots()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::PreloadExistingSnapshots");

    wprintf (L"\n---------- Preloading existing snapshots ----------------\n");

    // Create a Timewarp Coordinator interface
    CHECK_NOFAIL(m_pAllCoord.CoCreateInstance( CLSID_VSSCoordinator ));
    CHECK_NOFAIL(m_pAllCoord->SetContext(VSS_CTX_ALL));
    wprintf (L"Timewarp Coordinator object created.\n");

	// Get list all snapshots
	CComPtr<IVssEnumObject> pIEnumSnapshots;
	CHECK_NOFAIL( m_pAllCoord->Query( GUID_NULL,
				VSS_OBJECT_NONE,
				VSS_OBJECT_SNAPSHOT,
				&pIEnumSnapshots ) );

    wprintf(L"\n%-8s %-38s %-50s %-50s\n", L"Attrib.", L"Snapshot ID", L"Original Volume Name", L"Snapshot device name");
    wprintf(L"--------------------------------------------------------------------------------------------------------------------------------------------------------------\n");
	// For all snapshots do...
	VSS_OBJECT_PROP Prop;
	VSS_SNAPSHOT_PROP& Snap = Prop.Obj.Snap;
	for(;;) {
		// Get next element
		ULONG ulFetched;
		CHECK_NOFAIL( pIEnumSnapshots->Next( 1, &Prop, &ulFetched ));
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        wprintf(L"%08lx " WSTR_GUID_FMT L" %-50s %-50s\n",
            Snap.m_lSnapshotAttributes,
            GUID_PRINTF_ARG(Snap.m_SnapshotId),
            Snap.m_pwszOriginalVolumeName,
            Snap.m_pwszSnapshotDeviceObject
            );

        //
        // Adding the snapshot to the internal list
        //

        // Create the new snapshot set object, if not exists
        CVssSnapshotSetInfo* pSet = m_pSnapshotSetCollection.Lookup(Snap.m_SnapshotSetId);
        bool bSetNew = false;
        if (pSet == NULL) {
            pSet = new CVssSnapshotSetInfo(Snap.m_SnapshotSetId);
            if (pSet == NULL)
            {
                ::CoTaskMemFree(Snap.m_pwszOriginalVolumeName);
                ::CoTaskMemFree(Snap.m_pwszSnapshotDeviceObject);
                ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
            }
            bSetNew = true;
        }

        // Create the snapshot info object
        CVssSnapshotInfo* pSnap = new CVssSnapshotInfo(
            true, Snap.m_lSnapshotAttributes,
            Snap.m_SnapshotSetId,
            Snap.m_pwszSnapshotDeviceObject,
            Snap.m_pwszOriginalVolumeName,
            NULL);
        if (pSnap == NULL)
        {
            ::CoTaskMemFree(Snap.m_pwszOriginalVolumeName);
            ::CoTaskMemFree(Snap.m_pwszSnapshotDeviceObject);
            if (bSetNew)
                delete pSet;
            ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
        }

        ::CoTaskMemFree(Snap.m_pwszSnapshotDeviceObject);

        // Add the snapshot to the snapshot set's internal list
        if (!pSet->Add(Snap.m_pwszOriginalVolumeName, pSnap))
        {
            ::CoTaskMemFree(Snap.m_pwszOriginalVolumeName);
            delete pSnap;
            if (bSetNew)
                delete pSet;
            ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
        }

        ::CoTaskMemFree(Snap.m_pwszOriginalVolumeName);

        // Add the snapshot set info to the global list, if needed
        if (bSetNew)
            if (!m_pSnapshotSetCollection.Add(Snap.m_SnapshotSetId, pSet))
                ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
	}

    wprintf(L"--------------------------------------------------------------------------------------------------------------------------------------------------------------\n");

}


// Creating a backup snapshot
void CVssMultilayerTest::CreateTimewarpSnapshotSet()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::CreateTimewarpSnapshotSet");

    // Create a Timewarp Coordinator interface
    CHECK_NOFAIL(m_pTimewarpCoord.CoCreateInstance( CLSID_VSSCoordinator ));
    CHECK_NOFAIL(m_pTimewarpCoord->SetContext(m_lContext));
    wprintf (L"Timewarp Coordinator object created.\n");

    wprintf (L"\n---------- Starting TIMEWARP snapshot ----------------\n");

    CVssVolumeMapNoRemove mapVolumes;
    if (m_uSeed != VSS_SEED)
    {
        // Select one volume. Make sure that we have enough iterations
        for(INT nIterations = 0; nIterations < MAX_VOL_ITERATIONS; nIterations++)
        {
            // If we succeeded to select some volumes then continue;
            if (mapVolumes.GetSize())
                break;

            // Try to select some volumes for backup
            for (INT nIndex = 0; nIndex < m_mapVolumes.GetSize(); nIndex++)
            {
                // Arbitrarily skip volumes
                if (RndDecision())
                    continue;

                CVssVolumeInfo* pVol = m_mapVolumes.GetValueAt(nIndex);
                BS_ASSERT(pVol);

                // WARNING: the test assumes that VSS can have multiple backup snapshots at once.
                if (!mapVolumes.Add(pVol->GetVolumeDisplayName(), pVol))
                    ft.Err(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allcation error");

                // Add only one volume!
                break;
            }
        }
        if (nIterations >= MAX_VOL_ITERATIONS)
        {
            wprintf (L"Warning: a backup snapshot cannot be created. Insufficient volumes?\n");
            wprintf (L"\n---------- Ending TIMEWARP snapshot ----------------\n");
            return;
        }
    }
    else
    {
        // Select all volumes
        for (INT nIndex = 0; nIndex < m_mapVolumes.GetSize(); nIndex++)
        {
            CVssVolumeInfo* pVol = m_mapVolumes.GetValueAt(nIndex);
            BS_ASSERT(pVol);

            // WARNING: the test assumes that VSS can have multiple backup snapshots at once.
            if (!mapVolumes.Add(pVol->GetVolumeDisplayName(), pVol))
                ft.Err(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allcation error");
        }
    }

    wprintf(L"\tCurrent volume set:\n");
    for (INT nIndex = 0; nIndex < mapVolumes.GetSize(); nIndex++)
    {
        CVssVolumeInfo* pVol = mapVolumes.GetValueAt(nIndex);
        BS_ASSERT(pVol);

		// Get the volume containing the path
        wprintf(L"\t- Volume %s mounted on %s\n", pVol->GetVolumeName(), pVol->GetVolumeDisplayName() );
    }
	
    wprintf (L"\n---------- starting the snapshot set ---------------\n");

	CComPtr<IVssAsync> pAsync;
	CSimpleArray<VSS_ID > pSnapshotIDsArray;
	VSS_ID SnapshotSetId = GUID_NULL;

    // Starting a new snapshot set
    wprintf(L"Starting a new Snapshot Set\n");	
    CHECK_SUCCESS(m_pTimewarpCoord->StartSnapshotSet(&SnapshotSetId));
    wprintf(L"Snapshot Set created with ID = " WSTR_GUID_FMT L"\n", GUID_PRINTF_ARG(SnapshotSetId));

    // Add volumes to the snapshot set
    wprintf(L"Adding volumes to the Snapshot Set: \n");
    for (INT nIndex = 0; nIndex < mapVolumes.GetSize(); nIndex++)
    {
        CVssVolumeInfo* pVol = mapVolumes.GetValueAt(nIndex);
        BS_ASSERT(pVol);

		// Get the volume containing the path
        wprintf(L"\t- Adding volume %s ... ", pVol->GetVolumeDisplayName() );

		// Add the volume to the snapshot set
		VSS_ID SnapshotId;
        CHECK_SUCCESS(m_pTimewarpCoord->AddToSnapshotSet(pVol->GetVolumeName(),
            GUID_NULL, &SnapshotId));

        // Add the snapshot to the array
        pSnapshotIDsArray.Add(SnapshotId);
        BS_ASSERT(nIndex + 1 == pSnapshotIDsArray.GetSize());
        wprintf( L"OK\n");
    }

    wprintf (L"\n------------ Creating the snapshot -----------------\n");

    // Create the snapshot
    wprintf(L"\nStarting asynchronous DoSnapshotSet. Please wait...\n");	
    ft.hr = S_OK;
    pAsync = NULL;
    CHECK_SUCCESS(m_pTimewarpCoord->DoSnapshotSet(NULL, &pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	HRESULT hrReturned = S_OK;
	CHECK_SUCCESS(pAsync->QueryStatus(&hrReturned, NULL));
	CHECK_NOFAIL(hrReturned);
    wprintf(L"Asynchronous DoSnapshotSet finished.\n");	

    wprintf(L"Snapshot set created\n");

    // Create the new snapshot set object
    CVssSnapshotSetInfo* pSet = new CVssSnapshotSetInfo(SnapshotSetId);
    if (pSet == NULL)
        ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");

    for (INT nIndex = 0; nIndex < mapVolumes.GetSize(); nIndex++)
    {
        CVssVolumeInfo* pVol = mapVolumes.GetValueAt(nIndex);
        BS_ASSERT(pVol);

        if (pSnapshotIDsArray[nIndex] == GUID_NULL)
            continue;

        VSS_SNAPSHOT_PROP prop;
        CHECK_SUCCESS(m_pTimewarpCoord->GetSnapshotProperties(pSnapshotIDsArray[nIndex], &prop));
        wprintf(L"\t- The snapshot on volume %s resides at %s\n",
            pVol->GetVolumeDisplayName(), prop.m_pwszSnapshotDeviceObject);

        // Create the snapshot info object
        CVssSnapshotInfo* pSnap = new CVssSnapshotInfo(
            true, VSS_CTX_CLIENT_ACCESSIBLE, SnapshotSetId, prop.m_pwszSnapshotDeviceObject, pVol->GetVolumeName(), pVol);
        if (pSnap == NULL)
        {
            ::VssFreeSnapshotProperties(&prop);
            delete pSet;
            ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
        }

        ::VssFreeSnapshotProperties(&prop);

        // Add the snapshot to the snapshot set's internal list
        if (!pSet->Add(pVol->GetVolumeName(), pSnap))
        {
            delete pSnap;
            delete pSet;
            ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
        }
    }

    // Add the snapshot set info to the global list
    if (!m_pSnapshotSetCollection.Add(SnapshotSetId, pSet))
    {
        delete pSet;
        ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
    }

    wprintf (L"\n---------- TIMEWARP snapshot created -----------------\n");

    // Wait for user input
    wprintf(L"\nPress <Enter> to continue...\n");
    getwchar();

}


// Creating a backup snapshot
void CVssMultilayerTest::CreateBackupSnapshotSet()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::CreateBackupSnapshotSet");

    // Create the Backup components object and initialize for backup
	CHECK_NOFAIL(CreateVssBackupComponents(&m_pBackupComponents));
	CHECK_NOFAIL(m_pBackupComponents->InitializeForBackup());
	CHECK_SUCCESS(m_pBackupComponents->SetBackupState( false, true, VSS_BT_FULL, false));
    wprintf (L"Backup components object created.\n");

    // Gather writer metadata
    GatherWriterMetadata();

    wprintf (L"\n---------- Starting BACKUP snapshot ----------------\n");

    // Compute a set of volumes.
    // Select at least one volume. Make sure that we have enough iterations
    CVssVolumeMapNoRemove mapVolumes;
    if (m_uSeed != VSS_SEED)
    {
        for(INT nIterations = 0; nIterations < MAX_VOL_ITERATIONS; nIterations++)
        {
            // If we succeeded to select some volumes then continue;
            if (mapVolumes.GetSize())
                break;

            // Try to select some volumes for backup
            for (INT nIndex = 0; nIndex < m_mapVolumes.GetSize(); nIndex++)
            {
                // Arbitrarily skip volumes
                if (RndDecision())
                    continue;

                CVssVolumeInfo* pVol = m_mapVolumes.GetValueAt(nIndex);
                BS_ASSERT(pVol);

                // WARNING: the test assumes that VSS can have multiple backup snapshots at once.
                if (!mapVolumes.Add(pVol->GetVolumeDisplayName(), pVol))
                    ft.Err(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allcation error");
            }
        }
        if (nIterations >= MAX_VOL_ITERATIONS)
        {
            wprintf (L"Warning: a backup snapshot cannot be created. Insufficient volumes?\n");
            wprintf (L"\n---------- Ending BACKUP snapshot ----------------\n");
            return;
        }
    }
    else
    {
        // Select all volumes
        for (INT nIndex = 0; nIndex < m_mapVolumes.GetSize(); nIndex++)
        {
            CVssVolumeInfo* pVol = m_mapVolumes.GetValueAt(nIndex);
            BS_ASSERT(pVol);

            // WARNING: the test assumes that VSS can have multiple backup snapshots at once.
            if (!mapVolumes.Add(pVol->GetVolumeDisplayName(), pVol))
                ft.Err(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allcation error");
        }
    }

    wprintf(L"\tCurrent volume set:\n");
    for (INT nIndex = 0; nIndex < mapVolumes.GetSize(); nIndex++)
    {
        CVssVolumeInfo* pVol = mapVolumes.GetValueAt(nIndex);
        BS_ASSERT(pVol);

		// Get the volume containing the path
        wprintf(L"\t- Volume %s mounted on %s\n", pVol->GetVolumeName(), pVol->GetVolumeDisplayName() );
    }
	
    wprintf (L"\n---------- starting the snapshot set ---------------\n");

	CComPtr<IVssAsync> pAsync;
	CSimpleArray<VSS_ID > pSnapshotIDsArray;
	VSS_ID SnapshotSetId = GUID_NULL;

    // Starting a new snapshot set
    wprintf(L"Starting a new Snapshot Set\n");	
    CHECK_SUCCESS(m_pBackupComponents->StartSnapshotSet(&SnapshotSetId));
    wprintf(L"Snapshot Set created with ID = " WSTR_GUID_FMT L"\n", GUID_PRINTF_ARG(SnapshotSetId));

    // Add volumes to the snapshot set
    wprintf(L"Adding volumes to the Snapshot Set: \n");
    for (INT nIndex = 0; nIndex < mapVolumes.GetSize(); nIndex++)
    {
        CVssVolumeInfo* pVol = mapVolumes.GetValueAt(nIndex);
        BS_ASSERT(pVol);

		// Get the volume containing the path
        wprintf(L"\t- Adding volume %s ... ", pVol->GetVolumeDisplayName() );

		// Add the volume to the snapshot set
		VSS_ID SnapshotId;
        CHECK_SUCCESS(m_pBackupComponents->AddToSnapshotSet(pVol->GetVolumeName(),
            GUID_NULL, &SnapshotId));

        // Add the snapshot to the array
        pSnapshotIDsArray.Add(SnapshotId);
        BS_ASSERT(nIndex + 1 == pSnapshotIDsArray.GetSize());
        wprintf( L"OK\n");
    }

    wprintf (L"\n------------ Creating the snapshot -----------------\n");

    // Prepare for backup
    wprintf(L"Starting asynchronous PrepareForBackup. Please wait...\n");	
    ft.hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->PrepareForBackup(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	HRESULT hrReturned = S_OK;
	CHECK_SUCCESS(pAsync->QueryStatus(&hrReturned, NULL));
	CHECK_NOFAIL(hrReturned);
    wprintf(L"Asynchronous PrepareForBackup finished.\n");	

    // Create the snapshot
    wprintf(L"\nStarting asynchronous DoSnapshotSet. Please wait...\n");	
    ft.hr = S_OK;
    pAsync = NULL;
    CHECK_SUCCESS(m_pBackupComponents->DoSnapshotSet(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hrReturned, NULL));
	CHECK_NOFAIL(hrReturned);
    wprintf(L"Asynchronous DoSnapshotSet finished.\n");	

    wprintf(L"Snapshot set created\n");

    // Create the new snapshot set object
    CVssSnapshotSetInfo* pSet = new CVssSnapshotSetInfo(SnapshotSetId);
    if (pSet == NULL)
        ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");

    for (INT nIndex = 0; nIndex < mapVolumes.GetSize(); nIndex++)
    {
        CVssVolumeInfo* pVol = mapVolumes.GetValueAt(nIndex);
        BS_ASSERT(pVol);

        if (pSnapshotIDsArray[nIndex] == GUID_NULL)
            continue;

        VSS_SNAPSHOT_PROP prop;
        CHECK_SUCCESS(m_pBackupComponents->GetSnapshotProperties(pSnapshotIDsArray[nIndex], &prop));
        wprintf(L"\t- The snapshot on volume %s resides at %s\n",
            pVol->GetVolumeDisplayName(), prop.m_pwszSnapshotDeviceObject);

        // Create the snapshot info object
        CVssSnapshotInfo* pSnap = new CVssSnapshotInfo(
            true, VSS_CTX_BACKUP, SnapshotSetId, prop.m_pwszSnapshotDeviceObject, pVol->GetVolumeName(), pVol);
        if (pSnap == NULL)
        {
            ::VssFreeSnapshotProperties(&prop);
            delete pSet;
            ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
        }

        ::VssFreeSnapshotProperties(&prop);

        // Add the snapshot to the snapshot set's internal list
        if (!pSet->Add(pVol->GetVolumeName(), pSnap))
        {
            delete pSnap;
            delete pSet;
            ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
        }
    }

    // Add the snapshot set info to the global list
    if (!m_pSnapshotSetCollection.Add(SnapshotSetId, pSet))
    {
        delete pSet;
        ft.Err( VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allocation error");
    }

    wprintf (L"\n---------- BACKUP snapshot created -----------------\n");

    // Wait for user input
    wprintf(L"\nPress <Enter> to continue...\n");
    getwchar();

    // Complete the backup
    BackupComplete();
}


void CVssMultilayerTest::BackupComplete()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::BackupComplete");

	CComPtr<IVssAsync> pAsync;

    wprintf (L"\n------------ Completing backup phase ---------------\n");

	// Send the BackupComplete event
    wprintf(L"\nStarting asynchronous BackupComplete. Please wait...\n");	
    ft.hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->BackupComplete(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	HRESULT hrReturned = S_OK;
	CHECK_SUCCESS(pAsync->QueryStatus(&hrReturned, NULL));
	CHECK_NOFAIL(hrReturned);
    wprintf(L"Asynchronous BackupComplete finished.\n");	
}


// Gather writera metadata and select components for backup, if needed
void CVssMultilayerTest::GatherWriterMetadata()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::GatherWriterMetadata");

	unsigned cWriters;
	CComPtr<IVssAsync> pAsync;
	
    wprintf (L"\n---------- Gathering writer metadata ---------------\n");
	
    wprintf(L"Starting asynchronous GatherWriterMetadata. Please wait...\n");	
    ft.hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->GatherWriterMetadata(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	HRESULT hrReturned = S_OK;
	CHECK_SUCCESS(pAsync->QueryStatus(&hrReturned, NULL));
	CHECK_NOFAIL(hrReturned);
    wprintf(L"Asynchronous GatherWriterMetadata finished.\n");	
	
	CHECK_NOFAIL  (m_pBackupComponents->GetWriterMetadataCount (&cWriters));
    wprintf(L"Number of writers that responded: %u\n", cWriters);	
	
	CHECK_SUCCESS (m_pBackupComponents->FreeWriterMetadata());
}


void CVssMultilayerTest::GatherWriterStatus(
    IN  LPCWSTR wszWhen
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::GatherWriterMetadata");

    unsigned cWriters;
	CComPtr<IVssAsync> pAsync;

    wprintf (L"\nGathering writer status %s... ", wszWhen);
    ft.hr = S_OK;
    CHECK_SUCCESS(m_pBackupComponents->GatherWriterStatus(&pAsync));
	CHECK_SUCCESS(pAsync->Wait());
	HRESULT hrReturned = S_OK;
	CHECK_SUCCESS(pAsync->QueryStatus(&hrReturned, NULL));
	CHECK_NOFAIL(hrReturned);
	CHECK_NOFAIL(m_pBackupComponents->GetWriterStatusCount(&cWriters));
    m_pBackupComponents->FreeWriterStatus();
    wprintf (L"%d writers responded\n", cWriters);
}


CVssMultilayerTest::CVssMultilayerTest(
        IN  INT nArgsCount,
        IN  WCHAR ** ppwszArgsArray
        )
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::CVssMultilayerTest");

    // Initialize data members
    m_bCoInitializeSucceeded = false;
    m_bAttachYourDebuggerNow = false;

    // Command line options
    m_eTest = VSS_TEST_UNKNOWN;
    m_uSeed = VSS_SEED;
    m_lContext = VSS_CTX_BACKUP;
    m_pwszVolume = NULL;
    m_pwszDiffAreaVolume = NULL;
    m_ProviderId = VSS_SWPRV_ProviderId;
    m_llMaxDiffArea = VSS_ASSOC_NO_MAX_SPACE;
    m_SnapshotId = GUID_NULL;
    m_SnapshotSetId = GUID_NULL;

    // Command line arguments
    m_nCurrentArgsCount = nArgsCount;
    m_ppwszCurrentArgsArray = ppwszArgsArray;

    // Print display header
    wprintf(L"\nVSS Multilayer Test application, version 1.0\n");
}


CVssMultilayerTest::~CVssMultilayerTest()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::~CVssMultilayerTest");

    VssFreeString(m_pwszVolume);
    VssFreeString(m_pwszDiffAreaVolume);

    m_pTimewarpCoord = NULL;
    m_pAllCoord = NULL;
    m_pBackupComponents = NULL;

    // Unloading the COM library
    if (m_bCoInitializeSucceeded)
        CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\hwprv\vsnap\main.cpp ===
#include "stdafx.hxx"
#include "vs_idl.hxx"
#include "vswriter.h"
#include "vsbackup.h"
#include "vs_inc.hxx"
#include "vs_debug.hxx"
#include "vs_trace.hxx"
#include <debug.h>
#include <time.h>

void FreeSnapshotProperty (VSS_SNAPSHOT_PROP &prop)
    {
    if (prop.m_pwszSnapshotDeviceObject)
        VssFreeString(prop.m_pwszSnapshotDeviceObject);

    if (prop.m_pwszOriginalVolumeName)
        VssFreeString(prop.m_pwszOriginalVolumeName);

    if (prop.m_pwszOriginatingMachine)
        VssFreeString(prop.m_pwszOriginatingMachine);

    if (prop.m_pwszExposedName)
        VssFreeString(prop.m_pwszExposedName);

    if (prop.m_pwszExposedPath)
        VssFreeString(prop.m_pwszExposedPath);
    }


BOOL AssertPrivilege( LPCWSTR privName )
    {
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if ( OpenProcessToken (GetCurrentProcess(),
               TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,
               &tokenHandle))
        {
        LUID value;

        if ( LookupPrivilegeValue( NULL, privName, &value ) )
            {
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED;

            /*
            * We will always call GetLastError below, so clear
            * any prior error values on this thread.
            */
            SetLastError( ERROR_SUCCESS );

            stat = AdjustTokenPrivileges
                        (
                        tokenHandle,
                        FALSE,
                        &newState,
                        (DWORD)0,
                        NULL,
                        NULL
                        );

            /*
            * Supposedly, AdjustTokenPriveleges always returns TRUE
            * (even when it fails). So, call GetLastError to be
            * extra sure everything's cool.
            */
            if ( (error = GetLastError()) != ERROR_SUCCESS )
                stat = FALSE;

            if ( !stat )
                {
                wprintf
                    (
                    L"AdjustTokenPrivileges for %s failed with %d",
                    privName,
                    error
                    );
                }
            }

        }


    return stat;
    }


void ProcessArguments
    (
    int argc,
    WCHAR **argv,
    LONG &lContext,
    LPWSTR wszVolumes,
    bool &bDeleteSet,
    bool &bDeleteSnapshot,
    VSS_ID &idDelete
    )
    {
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"ProcessArguments");
    LPWSTR wszCopy = wszVolumes;

    lContext = VSS_CTX_FILE_SHARE_BACKUP;
    bDeleteSet = false;
    bDeleteSnapshot = false;
    for(int iarg = 1; iarg < argc; iarg++)
        {
        LPCWSTR wszArg = argv[iarg];
        if (wszArg[0] == L'-' || wszArg[0] == L'/')
            {
            if (wszArg[1] == L't')
                lContext |= VSS_VOLSNAP_ATTR_TRANSPORTABLE;
            else if (wszArg[1] == L'p')
                lContext |= VSS_VOLSNAP_ATTR_PERSISTENT|VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE;
            else if (wszArg[1] == L'r')
                lContext |= VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE;
            else if (wszArg[1] == L'd')
                {
                if (wszArg[2] == L'x')
                    bDeleteSet = true;
                else
                    bDeleteSnapshot = true;

                if (wszArg[3] != L'=' &&
                    wszArg[4] != L'{')
                    {
                    wprintf(L"bad option: %s/n", wszArg);
                    throw E_INVALIDARG;
                    }

                CVssID id;
                try
                    {
                    id.Initialize(ft, wszArg+4, E_INVALIDARG);
                    idDelete = id;
                    }
                catch(...)
                    {
                    wprintf(L"bad option: %s/n", wszArg);
                    throw E_INVALIDARG;
                    }

                break;
                }
            else
                {
                wprintf(L"bad option: %s/n", wszArg);
                throw E_INVALIDARG;
                }
            }
        else
            {
            WCHAR wsz[64];
            WCHAR wszVolume[256];
            wcscpy(wszVolume, wszArg);
            if (wszVolume[wcslen(wszVolume) - 1] != L'\\')
                {
                wszVolume[wcslen(wszVolume) + 1] = L'\0';
                wszVolume[wcslen(wszVolume)] = L'\\';
                }

            if (!GetVolumeNameForVolumeMountPoint(wszVolume, wsz, 64))
                {
                wprintf(L"Invalid volume name: %s", wszArg);
                throw E_INVALIDARG;
                }

            wcscpy(wszCopy, wsz);
            wszCopy += wcslen(wszCopy) + 1;
            }
        }

    *wszCopy = L'\0';
    }


extern "C" __cdecl wmain(int argc, WCHAR **argv)
    {
    WCHAR wszVolumes[2048];
    LONG lContext;
    HRESULT hr;

    bool bCoInitializeSucceeded = false;


    try
        {
        bool bDeleteSnapshot, bDeleteSnapshotSet;
        VSS_ID idDelete;

        ProcessArguments
            (
            argc,
            argv,
            lContext,
            wszVolumes,
            bDeleteSnapshotSet,
            bDeleteSnapshot,
            idDelete
            );

        CHECK_SUCCESS(CoInitializeEx(NULL, COINIT_MULTITHREADED));
        bCoInitializeSucceeded = true;


        if ( !AssertPrivilege( SE_BACKUP_NAME ) )
            {
            wprintf( L"AssertPrivilege returned error, rc:%d\n", GetLastError() );
            return 2;
            }

        CComPtr<IVssCoordinator> pCoord;
        CHECK_SUCCESS(pCoord.CoCreateInstance(CLSID_VSSCoordinator));
        if (bDeleteSnapshotSet || bDeleteSnapshot)
            {
            LONG lSnapshots;
            VSS_ID idNonDeleted;
            CHECK_SUCCESS(pCoord->DeleteSnapshots
                            (
                            idDelete,
                            bDeleteSnapshot ? VSS_OBJECT_SNAPSHOT : VSS_OBJECT_SNAPSHOT_SET,
                            FALSE,
                            &lSnapshots,
                            &idNonDeleted
                            ))

            if (bDeleteSnapshot)
                wprintf(L"Successfully deleted snapshot " WSTR_GUID_FMT L".\n",
                        GUID_PRINTF_ARG(idDelete));
            else
                wprintf(L"Successfully deleted snapshot set " WSTR_GUID_FMT L".\n",
                        GUID_PRINTF_ARG(idDelete));

            throw S_OK;
            }


        CHECK_SUCCESS(pCoord->SetContext(lContext));
        VSS_ID SnapshotSetId;
        CHECK_SUCCESS(pCoord->StartSnapshotSet(&SnapshotSetId));
        wprintf(L"Creating snapshot set " WSTR_GUID_FMT L"\n", GUID_PRINTF_ARG(SnapshotSetId));
        VSS_ID rgSnapshotId[64];
        UINT cSnapshots = 0;
        LPWSTR wsz = wszVolumes;
        while(*wsz != L'\0')
            {
            CHECK_SUCCESS(pCoord->AddToSnapshotSet
                            (
                            wsz,
                            GUID_NULL,
                            &rgSnapshotId[cSnapshots]
                            ));


            wprintf(L"Added volume %s to snapshot set" WSTR_GUID_FMT L"\n", wsz, GUID_PRINTF_ARG(SnapshotSetId));
            wsz += wcslen(wszVolumes) + 1;
            cSnapshots++;
            }

        CComPtr<IVssAsync> pAsync;
        CHECK_SUCCESS(pCoord->DoSnapshotSet(NULL, &pAsync));
        CHECK_SUCCESS(pAsync->Wait());
        HRESULT hrResult;
        CHECK_SUCCESS(pAsync->QueryStatus(&hrResult, NULL));
        CHECK_NOFAIL(hrResult);
        wprintf(L"Snapshot set " WSTR_GUID_FMT L" successfully created.\n", GUID_PRINTF_ARG(SnapshotSetId));
        for(UINT iSnapshot = 0; iSnapshot < cSnapshots; iSnapshot++)
            {
            VSS_ID SnapshotId = rgSnapshotId[iSnapshot];
            VSS_SNAPSHOT_PROP prop;
            CHECK_SUCCESS(pCoord->GetSnapshotProperties(SnapshotId, &prop));
            wprintf
                (
                L"Snapshot " WSTR_GUID_FMT L"\nOriginalVolume: %s\nSnapshotVolume: %s\n",
                GUID_PRINTF_ARG(SnapshotId),
                prop.m_pwszOriginalVolumeName,
                prop.m_pwszSnapshotDeviceObject
                );

            FreeSnapshotProperty(prop);
            }

        }
    catch(HRESULT hr)
        {
        }
    catch(...)
        {
        BS_ASSERT(FALSE);
        hr = E_UNEXPECTED;
        }

    if (FAILED(hr))
        wprintf(L"Failed with %08x.\n", hr);

    if (bCoInitializeSucceeded)
        CoUninitialize();

    return(0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\multilayer\main.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	main.cpp
**
**
** Abstract:
**
**	Test program to create a backup/multilayer snapshot set
**
** Author:
**
**	Adi Oltean      [aoltean]       02/22/2001
**
** Revision History:
**
**--
*/


///////////////////////////////////////////////////////////////////////////////
// Includes

#include "ml.h"


///////////////////////////////////////////////////////////////////////////////
// Main functions


extern "C" __cdecl wmain(int argc, WCHAR **argv)
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"wmain");

    try
	{
        CVssMultilayerTest test(argc-1, argv+1);

        // Parsing the command line
        // Eliminate the first argument (program name)
        if (test.ParseCommandLine())
        {
            // Initialize internal objects
            test.Initialize();

            // Run the tests
            test.Run();
        }
	}
    VSS_STANDARD_CATCH(ft)

    if (ft.HrFailed())
        wprintf(L"\nError catched at program termination: 0x%08lx\n", ft.hr);
    
    return ft.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\multilayer\ml.h ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	    ml.h
**
**
** Abstract:
**
**	    Test program to exercise backup and multilayer snapshots
**
** Author:
**
**	    Adi Oltean      [aoltean]       02/22/2001
**
** Revision History:
**
**--
*/

#ifndef __ML_HEADER_H__
#define __ML_HEADER_H__

#if _MSC_VER > 1000
#pragma once
#endif


/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/

// Disable warning: 'identifier' : identifier was truncated to 'number' characters in the debug information
//#pragma warning(disable:4786)

//
// C4290: C++ Exception Specification ignored
//
#pragma warning(disable:4290)

//
// C4511: copy constructor could not be generated
//
#pragma warning(disable:4511)

//
//  Warning: ATL debugging turned off (BUG 250939)
//
//  #ifdef _DEBUG
//  #define _ATL_DEBUG_INTERFACES
//  #define _ATL_DEBUG_QI
//  #define _ATL_DEBUG_REFCOUNT
//  #endif // _DEBUG

#include <windows.h>
#include <wtypes.h>
#pragma warning( disable: 4201 )    // C4201: nonstandard extension used : nameless struct/union
#include <winioctl.h>
#pragma warning( default: 4201 )	// C4201: nonstandard extension used : nameless struct/union
#include <winbase.h>
#include <wchar.h>
#include <string.h>
#include <iostream.h>
#include <fstream.h>
#include <stdio.h>
#include <process.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdlib.h>
#include <errno.h>
#include <time.h>
#include <string.h>

// Enabling asserts in ATL and VSS
#include "vs_assert.hxx"


#include <oleauto.h>
#include <stddef.h>
#pragma warning( disable: 4127 )    // warning C4127: conditional expression is constant
#include <atlconv.h>
#include <atlbase.h>


// VSS standard headers 
#include <vss.h>
#include <vscoordint.h>
#include <vsswprv.h>
#include <vsmgmt.h>

#include <vswriter.h>
#include <vsbackup.h>

#include <vs_inc.hxx>

#include "objects.h"

extern CComModule _Module;
#include <atlcom.h>

///////////////////////////////////////////////////////////////////////////////
// Useful macros 

#define VSS_ERROR_CASE(wszBuffer, dwBufferLen, X) 	\
    case X:  ::wcsncpy(wszBuffer, VSS_MAKE_W(VSS_EVAL(#X)), dwBufferLen); break;

#define WSTR_GUID_FMT  L"{%.8x-%.4x-%.4x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}"

#define GUID_PRINTF_ARG( X )                                \
    (X).Data1,                                              \
    (X).Data2,                                              \
    (X).Data3,                                              \
    (X).Data4[0], (X).Data4[1], (X).Data4[2], (X).Data4[3], \
    (X).Data4[4], (X).Data4[5], (X).Data4[6], (X).Data4[7]


// Execute the given call and check that the return code must be S_OK
#define CHECK_SUCCESS( Call )                                                                           \
    {                                                                                                   \
        ft.hr = Call;                                                                                   \
        if (ft.hr != S_OK)                                                                              \
            ft.Err(VSSDBG_VSSTEST, ft.hr, L"\nError: \n\t- Call %S not succeeded. \n"                   \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                #Call, ft.hr, GetStringFromFailureType(ft.hr));                                         \
    }

#define CHECK_NOFAIL( Call )                                                                            \
    {                                                                                                   \
        ft.hr = Call;                                                                                   \
        if (ft.HrFailed())                                                                              \
            ft.Err(VSSDBG_VSSTEST, ft.hr, L"\nError: \n\t- Call %S not succeeded. \n"                   \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                #Call, ft.hr, GetStringFromFailureType(ft.hr));                                         \
    }


///////////////////////////////////////////////////////////////////////////////
// Constants

const MAX_TEXT_BUFFER   = 512;
const MAX_VOL_ITERATIONS = 10;
const VSS_SEED = 1234;


typedef enum _EVssTestType
{
    VSS_TEST_UNKNOWN = 0,
    VSS_TEST_QUERY_SNAPSHOTS,
    VSS_TEST_QUERY_SNAPSHOTS_ON_VOLUME,
    VSS_TEST_QUERY_VOLUMES,
    VSS_TEST_VOLSNAP_QUERY,
    VSS_TEST_DELETE_BY_SNAPSHOT_ID,
    VSS_TEST_DELETE_BY_SNAPSHOT_SET_ID,
    VSS_TEST_CREATE,
    VSS_TEST_ADD_DIFF_AREA,
    VSS_TEST_REMOVE_DIFF_AREA,
    VSS_TEST_CHANGE_DIFF_AREA_MAX_SIZE,
    VSS_TEST_QUERY_SUPPORTED_VOLUMES_FOR_DIFF_AREA,
    VSS_TEST_QUERY_DIFF_AREAS_FOR_VOLUME,
    VSS_TEST_QUERY_DIFF_AREAS_ON_VOLUME,
    VSS_TEST_IS_VOLUME_SNAPSHOTTED_C,
} EVssTestType;


///////////////////////////////////////////////////////////////////////////////
// Main class


class CVssMultilayerTest
{
    
// Constructors& destructors
private:
    CVssMultilayerTest();
    CVssMultilayerTest(const CVssMultilayerTest&);
    
public:
    CVssMultilayerTest(
        IN  INT nArgsCount,
        IN  WCHAR ** ppwszArgsArray
        );

    ~CVssMultilayerTest();

// Main routines
public:

    // Initialize internal members
    void Initialize();

    // Run the test
    void Run();

// Internal tests
public:

    // Queries the snapshots
    void QuerySnapshots();

    // Queries the snapshots on volume
    void QuerySnapshotsByVolume();

    // Creates a backup snapshot set
    void QuerySupportedVolumes();

    // Query using hte IOCTL
    void QueryVolsnap();

    // Delete by snapshot Id
    void DeleteBySnapshotId();

    // Delete by snapshot set Id
    void DeleteBySnapshotSetId();

    // Creates a backup snapshot set
    void PreloadExistingSnapshots();

    // Creates a timewarp snapshot set
    void CreateTimewarpSnapshotSet();

    // Creates a backup snapshot set
    void CreateBackupSnapshotSet();

    // Completes the backup
    void BackupComplete();

    void GatherWriterMetadata();

    void GatherWriterStatus(
        IN  LPCWSTR wszWhen
        );

    // Adds a diff area
    void AddDiffArea();

    // Removes a diff area
    void RemoveDiffArea();

    // Change diff area maximum size
    void ChangeDiffAreaMaximumSize();

    // Query volumes for diff area
    void QueryVolumesSupportedForDiffAreas();

    // Query volumes for diff area
    void QueryDiffAreasForVolume();

    // Query volumes on diff area
    void QueryDiffAreasOnVolume();

    // Test if the volume is snapshotted using the "C" API
    void IsVolumeSnapshotted_C();

// Command line processing
public:

    // Parse command line arguments 
    bool ParseCommandLine();

    // Print the usage
    bool PrintUsage(bool bThrow = true);

    // Returns true if there are tokens left
    bool TokensLeft();
        
    // Returns the current token
    VSS_PWSZ GetCurrentToken();

    // Go to next token
    void Shift();
        
    // Check if the current token matches the given argument
	bool Peek(
		IN	VSS_PWSZ pwszPattern
		) throw(HRESULT);
    
    // Match a pattern. If succeeds, shift to the next token.
	bool Match(
		IN	VSS_PWSZ pwszPattern
		) throw(HRESULT);
    
    // Extract a GUID. If succeeds, shift to the next token.
	bool Extract(
		IN OUT VSS_ID& Guid
		) throw(HRESULT);
    
    // Extract a string. If succeeds, shift to the next token.
	bool Extract(
		IN OUT VSS_PWSZ& pwsz
		) throw(HRESULT);
    
    // Extract an UINT. If succeeds, shift to the next token.
	bool Extract(
		IN OUT UINT& uint
		) throw(HRESULT);
    
    // Extract an UINT. If succeeds, shift to the next token.
	bool Extract(
		IN OUT LONGLONG& llValue
		) throw(HRESULT);
    
// Private methods:
private:

    LPCWSTR GetStringFromFailureType (HRESULT hrStatus);

    bool IsVolume( IN VSS_PWSZ pwszVolume );

    bool AddVolume( IN VSS_PWSZ pwszVolume, OUT bool & bAdded );

    INT RndDecision(IN INT nVariants = 2);

// Implementation
private:

    // Global state
    bool                        m_bCoInitializeSucceeded;
    bool                        m_bAttachYourDebuggerNow;

    // Command line options
    unsigned int                m_uSeed;
    LONG                        m_lContext;
    EVssTestType                m_eTest;
    VSS_PWSZ                    m_pwszVolume;
    VSS_PWSZ                    m_pwszDiffAreaVolume;
    VSS_ID                      m_ProviderId;
    LONGLONG                    m_llMaxDiffArea;
    VSS_ID                      m_SnapshotId;
    VSS_ID                      m_SnapshotSetId;

    // test-related members
    CVssSnapshotSetCollection   m_pSnapshotSetCollection;
    CVssVolumeMap               m_mapVolumes;
    CComPtr<IVssCoordinator>    m_pTimewarpCoord;
    CComPtr<IVssCoordinator>    m_pAllCoord;
    CComPtr<IVssBackupComponents>    m_pBackupComponents;

    // Command line
    INT                         m_nCurrentArgsCount;
    WCHAR **                    m_ppwszCurrentArgsArray;
};


#endif // __ML_HEADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\jettest\main.cpp ===
#include <stdafx.h>

#include <vss.h>
#include <vswriter.h>

#include <jetwriter.h>
#include <esent98.h>

#define	DATABASE_ROOT		L"%SystemDrive%\\JetTestDatabases"
#define	DATABASE_ROOT_A		 "%SystemDrive%\\JetTestDatabases"
#define INCLUDED_DATABASES	L"\\IncludedDatabases"
#define INCLUDED_DATABASES_A	 "\\IncludedDatabases"
#define	EXCLUDED_DATABASES	L"\\ExcludedDatabases"
#define	EXCLUDED_DATABASES_A	 "\\ExcludedDatabases"



#if 1
#define FilesToInclude	L"X:\\Element-00\\/s;"						\
			L"x:\\Element-01\\/s;"						\
			L"x:\\Element-02\\*      /S     ;"				\
			L" x:\\Element-03\\a very long path\\with a long dir\\a.bat"

#define FilesToExclude	DATABASE_ROOT EXCLUDED_DATABASES L"\\" L" /s"

#else

/*
** These are the paths used by RSS at one point.
*/
#define	FilesToExclude	L"%SystemRoot%\\System32\\RemoteStorage\\FsaDb\\*;"	\
			L"%SystemRoot%\\System32\\RemoteStorage\\Trace\\*"

#define	FilesToInclude	L""

#endif




#define	GET_STATUS_FROM_BOOL(_bSucceeded)	((_bSucceeded)       ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_HANDLE(_handle)		((NULL != (_handle)) ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_POINTER(_ptr)		((NULL != (_ptr))    ? NOERROR : E_OUTOFMEMORY)


static const PCHAR achDatabaseNames [] =
    {
    DATABASE_ROOT_A INCLUDED_DATABASES_A "\\jettest_db0.jdb",
    DATABASE_ROOT_A EXCLUDED_DATABASES_A "\\jettest_db1.jdb",
    DATABASE_ROOT_A INCLUDED_DATABASES_A "\\jettest_db2.jdb",
    DATABASE_ROOT_A EXCLUDED_DATABASES_A "\\jettest_db3.jdb",
    DATABASE_ROOT_A INCLUDED_DATABASES_A "\\jettest_db4.jdb",
    DATABASE_ROOT_A EXCLUDED_DATABASES_A "\\jettest_db5.jdb",
    DATABASE_ROOT_A INCLUDED_DATABASES_A "\\jettest_db6.jdb",
    DATABASE_ROOT_A EXCLUDED_DATABASES_A "\\jettest_db7.jdb"
    };


#define MAX_DATABASE_COUNT		(sizeof (achDatabaseNames) / sizeof (PWCHAR))

static CHAR achExpandedDatabaseNames [MAX_DATABASE_COUNT] [MAX_PATH + 1];



static const char szUser []		= "admin";
static const char szPassword []		= "\0";

static const char szTable1 []		= "table1";
static const char szTable2 []		= "table2";

static const char szF1Name []		= "F1PAD";
static const char szF2Name []		= "F2";
static const char szF3Name []		= "F3";
static const char szV1Name []		= "V1";
static const char szT1Name []		= "T1";
static const char szT2Name []		= "T2";
					
static const char szXF1Name []		= "XF1";
static const char szXF3F2Name []	= "XF3F2";
static const char szXV1Name []		= "XV1";
static const char szXT1Name []		= "XT1";
static const char szXT2Name []		= "XT2";


HANDLE *g_phEventHandles = NULL;

typedef enum
    {
    eHandleControlC = 0,
    eHandleStepToNextConfig,
    eHandleMaxHandleCount
    } EHANDLEOFFSETS;



typedef struct
    {
	PCHAR		pszDatabaseName;
	JET_DBID	idDatabase;
} CONTEXTDB, *PCONTEXTDB, **PPCONTEXTDB;

typedef struct
    {
	JET_INSTANCE	idInstance;
	JET_SESID	idSession;

	CONTEXTDB	aDatabase [MAX_DATABASE_COUNT];
} CONTEXTJET, *PCONTEXTJET, **PPCONTEXTJET;





class CVssJetWriterLocal : public CVssJetWriter
    {
public:

	virtual bool STDMETHODCALLTYPE OnThawEnd (bool fJetThawSucceeded);

	virtual void STDMETHODCALLTYPE OnAbortEnd ();

	virtual bool STDMETHODCALLTYPE OnPostRestoreEnd(IVssWriterComponents *pComponents, bool bSucceeded);
};


bool STDMETHODCALLTYPE CVssJetWriterLocal::OnThawEnd (bool fJetThawSucceeded)
    {
	UNREFERENCED_PARAMETER(fJetThawSucceeded);
	wprintf(L"OnThawEnd\n");
    SetEvent (g_phEventHandles [eHandleStepToNextConfig]);

    return (true);
    }

void STDMETHODCALLTYPE CVssJetWriterLocal::OnAbortEnd ()
    {
	wprintf(L"OnAbortEnd\n");
    SetEvent (g_phEventHandles [eHandleStepToNextConfig]);
    }

// This function displays the formatted message at the console and throws
void Error(
    IN  INT nReturnCode,
    IN  const WCHAR* pwszMsgFormat,
    IN  ...
    )
	{
    va_list marker;
    va_start( marker, pwszMsgFormat );
    vwprintf( pwszMsgFormat, marker );
    va_end( marker );

	BS_ASSERT(FALSE);
    // throw that return code.
    throw(nReturnCode);
	}

// Convert a component type into a string
LPCWSTR GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType)
{
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eComponentType)
	{
	case VSS_CT_DATABASE:  pwszRetString = L"Database";  break;
	case VSS_CT_FILEGROUP: pwszRetString = L"FileGroup"; break;

	default:
	    break;
	}


    return (pwszRetString);
}


// Convert a failure type into a string
LPCWSTR GetStringFromFailureType(HRESULT hrStatus)
{
    LPCWSTR pwszFailureType = L"";

    switch (hrStatus)
	{
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:        pwszFailureType = L"VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT";    break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:              pwszFailureType = L"VSS_E_WRITERERROR_OUTOFRESOURCES";          break;
	case VSS_E_WRITERERROR_TIMEOUT:                     pwszFailureType = L"VSS_E_WRITERERROR_TIMEOUT";                 break;
	case VSS_E_WRITERERROR_NONRETRYABLE:                pwszFailureType = L"VSS_E_WRITERERROR_NONRETRYABLE";            break;
	case VSS_E_WRITERERROR_RETRYABLE:                   pwszFailureType = L"VSS_E_WRITERERROR_RETRYABLE";               break;
	case VSS_E_BAD_STATE:                               pwszFailureType = L"VSS_E_BAD_STATE";                           break;
	case VSS_E_PROVIDER_ALREADY_REGISTERED:             pwszFailureType = L"VSS_E_PROVIDER_ALREADY_REGISTERED";         break;
	case VSS_E_PROVIDER_NOT_REGISTERED:                 pwszFailureType = L"VSS_E_PROVIDER_NOT_REGISTERED";             break;
	case VSS_E_PROVIDER_VETO:                           pwszFailureType = L"VSS_E_PROVIDER_VETO";                       break;
	case VSS_E_PROVIDER_IN_USE:				            pwszFailureType = L"VSS_E_PROVIDER_IN_USE";                     break;
	case VSS_E_OBJECT_NOT_FOUND:						pwszFailureType = L"VSS_E_OBJECT_NOT_FOUND";                    break;						
	case VSS_S_ASYNC_PENDING:							pwszFailureType = L"VSS_S_ASYNC_PENDING";                       break;
	case VSS_S_ASYNC_FINISHED:						    pwszFailureType = L"VSS_S_ASYNC_FINISHED";                      break;
	case VSS_S_ASYNC_CANCELLED:						    pwszFailureType = L"VSS_S_ASYNC_CANCELLED";                     break;
	case VSS_E_VOLUME_NOT_SUPPORTED:					pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED";                break;
	case VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER:		pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER";    break;
	case VSS_E_OBJECT_ALREADY_EXISTS:					pwszFailureType = L"VSS_E_OBJECT_ALREADY_EXISTS";               break;
	case VSS_E_UNEXPECTED_PROVIDER_ERROR:				pwszFailureType = L"VSS_E_UNEXPECTED_PROVIDER_ERROR";           break;
	case VSS_E_CORRUPT_XML_DOCUMENT:				    pwszFailureType = L"VSS_E_CORRUPT_XML_DOCUMENT";                break;
	case VSS_E_INVALID_XML_DOCUMENT:					pwszFailureType = L"VSS_E_INVALID_XML_DOCUMENT";                break;
	case VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED:       pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED";   break;
	case VSS_E_FLUSH_WRITES_TIMEOUT:                    pwszFailureType = L"VSS_E_FLUSH_WRITES_TIMEOUT";                break;
	case VSS_E_HOLD_WRITES_TIMEOUT:                     pwszFailureType = L"VSS_E_HOLD_WRITES_TIMEOUT";                 break;
	case VSS_E_UNEXPECTED_WRITER_ERROR:                 pwszFailureType = L"VSS_E_UNEXPECTED_WRITER_ERROR";             break;
	case VSS_E_SNAPSHOT_SET_IN_PROGRESS:                pwszFailureType = L"VSS_E_SNAPSHOT_SET_IN_PROGRESS";            break;
	case VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED:     pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED"; break;
	case VSS_E_WRITER_INFRASTRUCTURE:	 		        pwszFailureType = L"VSS_E_WRITER_INFRASTRUCTURE";               break;
	case VSS_E_WRITER_NOT_RESPONDING:			        pwszFailureType = L"VSS_E_WRITER_NOT_RESPONDING";               break;
    case VSS_E_WRITER_ALREADY_SUBSCRIBED:		        pwszFailureType = L"VSS_E_WRITER_ALREADY_SUBSCRIBED";           break;
	
	case NOERROR:
	default:
	    break;
	}

    return (pwszFailureType);
}



// Execute the given call and check that the return code must be S_OK
#define CHECK_SUCCESS( Call )                                                                           \
    {                                                                                                   \
        hr = Call;                                                                                    \
		if (hr != S_OK)                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }


#define CHECK_NOFAIL( Call )                                                                            \
    {                                                                                                   \
        hr = Call;                                                                                    \
        if (FAILED(hr))                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }


bool STDMETHODCALLTYPE CVssJetWriterLocal::OnPostRestoreEnd(IVssWriterComponents *pWriter, bool bRestoreSucceeded)
	{
	wprintf(L"Restore invoked.\n");
	if (bRestoreSucceeded)
		wprintf(L"Restore succeeded.\n");
	else
		wprintf(L"Restore failed.");

	try
		{
		HRESULT hr;

		unsigned cComponents;
		CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
		VSS_ID idWriter, idInstance;
		CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstance, &idWriter));
		for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
			{
			CComPtr<IVssComponent> pComponent;
			CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
				
			VSS_COMPONENT_TYPE ct;
			CComBSTR bstrLogicalPath;
			CComBSTR bstrComponentName;

			CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
			CHECK_SUCCESS(pComponent->GetComponentType(&ct));
			CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
			wprintf(L"COMPONENT path = %s, type=%s, name=%s\n", bstrLogicalPath, GetStringFromComponentType(ct), bstrComponentName);
			}
		}
	catch(...)
		{
		wprintf(L"***Unexpected exception thrown.***\n");
		}

	return true;
	}


#define DO_CALL(xCall) \
    { \
	JET_ERR jetStatus = xCall; \
    if (jetStatus < JET_errSuccess) \
		Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n" \
			  L"\t  Error code = 0x%08lx.\n", \
			  __FILE__, __LINE__, #xCall, jetStatus); \
	 }


BOOL WINAPI Ctrl_C_Handler_Routine(IN DWORD type)
    {
    UNREFERENCED_PARAMETER(type);

    if (g_phEventHandles [eHandleControlC])
	{
	SetEvent (g_phEventHandles [eHandleControlC]);
	}

    return TRUE;
    }







JET_ERR CreateAndPopulateDatabase (JET_SESID	idSession,
				   const char	*szDatabase,
				   JET_DBID *pidDatabase)
    {
    JET_DBID		idDatabase;
    JET_TABLEID		idTable;
    JET_COLUMNDEF	columndef;
    JET_COLUMNID	idColumnF1;
    JET_COLUMNID	idColumnF2;
    JET_COLUMNID	idColumnF3;
    JET_COLUMNID	idColumnV1;
    JET_COLUMNID	idColumnT1;
    JET_COLUMNID	idColumnT2;

    const unsigned short	usCodePage = 1252;
    const unsigned short	usLanguage = 0x409;
    const long			lOne       = 1;


    DO_CALL (JetCreateDatabase (idSession, szDatabase, NULL, &idDatabase, 0));
    DO_CALL (JetCloseDatabase  (idSession, idDatabase, 0));

    /*
    **	check multiple opens of same database
    */
    DO_CALL (JetOpenDatabase (idSession, szDatabase, NULL, &idDatabase, 0));


    DO_CALL (JetBeginTransaction (idSession));

    DO_CALL (JetCreateTable      (idSession, idDatabase, szTable1, 0, 100, &idTable));
    DO_CALL (JetCloseTable       (idSession, idTable));


    DO_CALL (JetOpenTable        (idSession, idDatabase, szTable1, NULL, 0, JET_bitTableDenyRead, &idTable));


    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypLong;
    columndef.cbMax    = 0;
    columndef.grbit    = 0;

    DO_CALL (JetAddColumn (idSession, idTable, szF1Name, &columndef, &lOne, sizeof(lOne), &idColumnF1));



    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypUnsignedByte;
    columndef.cbMax    = 0;
    columndef.grbit    = 0;

    DO_CALL (JetAddColumn (idSession, idTable, szF2Name, &columndef, NULL, 0, &idColumnF2));



    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypLong;
    columndef.cbMax    = 0;
    columndef.grbit    = 0;

    DO_CALL (JetAddColumn (idSession, idTable, szF3Name, &columndef, NULL, 0, &idColumnF3));



    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypText;
    columndef.cbMax    = 0;
    columndef.grbit    = 0;

    DO_CALL (JetAddColumn (idSession, idTable, szV1Name, &columndef, NULL, 0, &idColumnV1));



    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypLongText;
    columndef.cbMax    = 0;
    columndef.grbit    = JET_bitColumnTagged | JET_bitColumnMultiValued;

    DO_CALL (JetAddColumn (idSession, idTable, szT1Name, &columndef, NULL, 0, &idColumnT1));



    columndef.cbStruct = sizeof (columndef);
    columndef.cp       = usCodePage;
    columndef.langid   = usLanguage;
    columndef.wCountry = 1;
    columndef.columnid = 0;
    columndef.coltyp   = JET_coltypBinary;
    columndef.cbMax    = 0;
    columndef.grbit    = JET_bitColumnTagged | JET_bitColumnMultiValued;

    DO_CALL (JetAddColumn (idSession, idTable, szT2Name, &columndef, NULL, 0, &idColumnT2));


    {
    char		rgbCols[50];
    sprintf( rgbCols, "+%s", szF1Name);

    rgbCols[ 1 + strlen(szF1Name) + 1] = '\0';
    *(unsigned short *)(&rgbCols[ 1 + strlen(szF1Name) + 1 + 1]) = usLanguage;
    rgbCols[ 1 + strlen(szF1Name) + 1 + 1 + sizeof(usLanguage) ]    = '\0';
    rgbCols[ 1 + strlen(szF1Name) + 1 + 1 + sizeof(usLanguage) + 1] = '\0';

    DO_CALL (JetCreateIndex (idSession,
			  idTable,
			  szXF1Name,
			  JET_bitIndexPrimary | JET_bitIndexUnique,
			  rgbCols,
			  1 + strlen( szF1Name) + 1 + 1 + sizeof(usLanguage) + 1 + 1,
			  100));
    }

    DO_CALL (JetCloseTable (idSession, idTable));
    DO_CALL (JetCommitTransaction (idSession, 0));

	*pidDatabase = idDatabase;


    return (JET_errSuccess);
    }


void DatabaseSetup (PCONTEXTJET pctxJet, ULONG ulDatabaseCount)
    {
    JET_ERR		jetStatus;


    DO_CALL (JetBeginSession (pctxJet->idInstance, &pctxJet->idSession, szUser, szPassword));


    while (ulDatabaseCount-- > 0)
	{
	jetStatus = JetAttachDatabase (pctxJet->idSession,
				       pctxJet->aDatabase [ulDatabaseCount].pszDatabaseName,
				       0);


	if (jetStatus >= JET_errSuccess)
	    {
	    DO_CALL (JetOpenDatabase (pctxJet->idSession,
				   pctxJet->aDatabase [ulDatabaseCount].pszDatabaseName,
				   NULL,
				   &pctxJet->aDatabase [ulDatabaseCount].idDatabase,
				   0));
	    }
	else
	    {
	    DO_CALL (CreateAndPopulateDatabase (pctxJet->idSession,
					     pctxJet->aDatabase [ulDatabaseCount].pszDatabaseName,
						 &pctxJet->aDatabase [ulDatabaseCount].idDatabase));
	    }

	}
    }


void DatabaseCleanup (PCONTEXTJET pctxJet, ULONG ulDatabaseCount)
    {
    while (ulDatabaseCount-- > 0)
	{
	DO_CALL (JetCloseDatabase (pctxJet->idSession,
				pctxJet->aDatabase [ulDatabaseCount].idDatabase,
				0));


	DO_CALL (JetDetachDatabase (pctxJet->idSession,
				 pctxJet->aDatabase [ulDatabaseCount].pszDatabaseName));
	}


    DO_CALL (JetEndSession (pctxJet->idSession, 0));
    }




extern "C" int _cdecl wmain(int argc, WCHAR **argv)
    {
	UNREFERENCED_PARAMETER(argc);
	UNREFERENCED_PARAMETER(argv);

    HRESULT		hrStatus        = NOERROR;
    DWORD		dwStatus        = 0;
    GUID		idWriter        = GUID_NULL;
    CVssJetWriter	*pWriter        = NULL;
    bool		bContinue       = true;
    BOOL		bSucceeded      = FALSE;
    ULONG		ulDatabaseCount = 3;
    ULONG		ulIndex;
    HANDLE		hEventHandles [eHandleMaxHandleCount];
    CONTEXTJET		ctxJet;
	WCHAR		wszBufferName [MAX_PATH + 1];
    DWORD		dwCharCount;



    dwCharCount = ExpandEnvironmentStringsW (DATABASE_ROOT, wszBufferName, sizeof (wszBufferName));

    hrStatus = GET_STATUS_FROM_BOOL (0 != dwCharCount);

    if (FAILED (hrStatus))
	{
	wprintf (L"ExpandEnvironmentStringsW (%s) FAILED with error code %08x\n",
		 DATABASE_ROOT,
		 hrStatus);
	}


    bSucceeded = CreateDirectoryW (wszBufferName, NULL);

    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

    if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_ALREADY_EXISTS) != hrStatus))
	{
	wprintf (L"CreateDirectoryW (%s) FAILED with error code %08x\n",
		 wszBufferName,
		 hrStatus);
	}




    dwCharCount = ExpandEnvironmentStringsW (DATABASE_ROOT INCLUDED_DATABASES, wszBufferName, sizeof (wszBufferName));

    hrStatus = GET_STATUS_FROM_BOOL (0 != dwCharCount);

    if (FAILED (hrStatus))
	{
	wprintf (L"ExpandEnvironmentStringsW (%s) FAILED with error code %08x\n",
		 DATABASE_ROOT INCLUDED_DATABASES,
		 hrStatus);
	}


    bSucceeded = CreateDirectoryW (wszBufferName, NULL);

    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

    if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_ALREADY_EXISTS) != hrStatus))
	{
	wprintf (L"CreateDirectoryW (%s) FAILED with error code %08x\n",
		 wszBufferName,
		 hrStatus);
	}




    dwCharCount = ExpandEnvironmentStringsW (DATABASE_ROOT EXCLUDED_DATABASES, wszBufferName, sizeof (wszBufferName));

    hrStatus = GET_STATUS_FROM_BOOL (0 != dwCharCount);

    if (FAILED (hrStatus))
	{
	wprintf (L"ExpandEnvironmentStringsW (%s) FAILED with error code %08x\n",
		 DATABASE_ROOT EXCLUDED_DATABASES,
		 hrStatus);
	}


    bSucceeded = CreateDirectoryW (wszBufferName, NULL);

    hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);

    if (FAILED (hrStatus) && (HRESULT_FROM_WIN32 (ERROR_ALREADY_EXISTS) != hrStatus))
	{
	wprintf (L"CreateDirectoryW (%s) FAILED with error code %08x\n",
		 wszBufferName,
		 hrStatus);
	}




    hrStatus = NOERROR;



    /*
    ** Initialise the database contexts
    */
    ctxJet.idInstance = 0;
    ctxJet.idSession  = 0;

    for (ulIndex = 0; ulIndex < MAX_DATABASE_COUNT; ulIndex++)
	{
	dwCharCount = ExpandEnvironmentStringsA (achDatabaseNames [ulIndex],
						 achExpandedDatabaseNames [ulIndex],
						 sizeof (achExpandedDatabaseNames [ulIndex]));

	ctxJet.aDatabase [ulIndex].idDatabase      = 0;
	ctxJet.aDatabase [ulIndex].pszDatabaseName = achExpandedDatabaseNames [ulIndex];
	}



    /*
    ** Initialise the event handles array
    */
    for (ulIndex = 0; ulIndex < eHandleMaxHandleCount; ulIndex++)
	{
	if (SUCCEEDED (hrStatus))
	    {
	    hEventHandles [ulIndex] = CreateEvent (NULL, FALSE, FALSE, NULL);

	    hrStatus = GET_STATUS_FROM_HANDLE (hEventHandles [ulIndex] );

	    if (NULL == hEventHandles [ulIndex])
		{
		wprintf (L"CreateEvent %u failed with error code %08X\n", ulIndex, hrStatus);
		}
	    }
	}



    /*
    ** Hook up the console GetOutOfJail device
    */
    if (SUCCEEDED (hrStatus))
	{
	g_phEventHandles = hEventHandles;

	::SetConsoleCtrlHandler (Ctrl_C_Handler_Routine, TRUE);
	}



    /*
    ** Tally-ho chaps!
    */
    try
	{
	DO_CALL (JetInit(&ctxJet.idInstance));

	hrStatus = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	if (FAILED (hrStatus))
	    {
	    wprintf (L"CoInitializeEx failed with error code %08x\n", hrStatus);
	    }


    hrStatus = CoInitializeSecurity
			(
			NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
			-1,                                  //  IN LONG                         cAuthSvc,
			NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
			NULL,                                //  IN void                        *pReserved1,
			RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
			RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
			NULL,                                //  IN void                        *pAuthList,
			EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
			NULL                                 //  IN void                        *pReserved3
			);


	if (FAILED (hrStatus))
	    {
	    wprintf (L"CoInitializeSecurity failed with error code %08x\n", hrStatus);
	    }

	if (SUCCEEDED (hrStatus))
	    {
	    pWriter = new CVssJetWriterLocal;

	    if (NULL == pWriter)
		{
		wprintf (L"new CVssJetWriter failed");

		hrStatus = HRESULT_FROM_WIN32 (ERROR_NOT_ENOUGH_MEMORY);
		}
	    }



	if (SUCCEEDED (hrStatus))
	    {
	    hrStatus = pWriter->Initialize (idWriter,		// id of writer
					    L"JetTest Writer",	// name of writer
					    true,		// system service
					    false,		// bootable state
					    FilesToInclude,	// files to include
					    FilesToExclude);	// files to exclude

	    if (FAILED (hrStatus))
		{
		wprintf (L"CVssJetWriter::Initialize failed with error code %08x\n", hrStatus);
		}
	    }




	while (SUCCEEDED (hrStatus) && bContinue)
	    {
	    DatabaseSetup (&ctxJet, ulDatabaseCount);


	    dwStatus = WaitForMultipleObjects (eHandleMaxHandleCount, hEventHandles, FALSE, INFINITE);


	    DatabaseCleanup (&ctxJet, ulDatabaseCount);

	    switch (dwStatus - WAIT_OBJECT_0)
		{
		case (eHandleControlC):
		    bContinue = FALSE;
		    break;


		case (eHandleStepToNextConfig):
		    ulDatabaseCount = (ulDatabaseCount + 1) % (MAX_DATABASE_COUNT + 1);
		    break;


		default:
		    BS_ASSERT (0);
		    break;
		}
	    }
	}



    catch(...)
	{
	wprintf(L"unexpected exception\n");
	exit(-1);
	}



    for (ulIndex = 0; ulIndex < eHandleMaxHandleCount; ulIndex++)
	{
	if (NULL != hEventHandles [ulIndex])
	    {
	    CloseHandle (hEventHandles [ulIndex]);

	    hEventHandles [ulIndex] = NULL;
	    }
	}



    if (NULL != pWriter)
	{
	pWriter->Uninitialize();
	delete pWriter;
	pWriter = NULL;
	}


    DO_CALL (JetTerm (ctxJet.idInstance));


    return (hrStatus);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\multilayer\mlutil.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	mlutil.cpp
**
**
** Abstract:
**
**	Utility functions for the VSML test.
**
** Author:
**
**	Adi Oltean      [aoltean]      03/05/2001
**
**  The sample is based on the Metasnap test program  written by Michael C. Johnson.
**
**
** Revision History:
**
**--
*/

///////////////////////////////////////////////////////////////////////////////
// Includes

#include "ml.h"


///////////////////////////////////////////////////////////////////////////////
// Command line parsing


bool CVssMultilayerTest::PrintUsage(bool bThrow /* = true */)
{
    wprintf(
        L"\nUsage:\n"
        L"     1) For snapshot creation:\n"
        L"           vsml [-xt|-xa] [-s <seed_number>] <volumes>\n"
        L"     2) For query:\n"
        L"           vsml [-xt|-xa] -qs [-P <ProviderID>]\n"
        L"           vsml [-xt|-xa] -qsv <volume> [-P <ProviderID>]\n"
        L"           vsml [-xt|-xa] -qv [-P <ProviderID>]\n"
        L"           vsml -qi <volume>\n"
        L"           vsml -is <volume>\n"
        L"     3) For diff area:\n"
        L"           vsml -da <vol> <diff vol> <max size> [-P <ProviderID>]\n"
        L"           vsml -dr <vol> <diff vol>  [-P <ProviderID>]\n"
        L"           vsml -ds <vol> <diff vol> <max size>  [-P <ProviderID>]\n"
        L"           vsml -dqv [-P <ProviderID>]\n"
        L"           vsml -dqf <volume> [-P <ProviderID>]\n"
        L"           vsml -dqo <volume> [-P <ProviderID>]\n"
        L"     4) For deleting snapshots:\n"
        L"           vsml [-xt|-xa] -r {snapshot id}\n"
        L"           vsml [-xt|-xa] -rs {snapshot set id}\n"
        L"\nOptions:\n"
        L"      -s              Specifies a seed for the random number generator\n"
        L"      -xt             Operates in the Timewarp context\n"
        L"      -xa             Operates  in the 'ALL' context\n"
        L"      -qs             Queries the existing snapshots\n"
        L"      -qi             Queries the VOLSNAP snapshots (through ioctl)\n"
        L"      -is             Checks if the volume is snapshotted (through C API)\n"
        L"      -qsv            Queries the snapshots on the given volume\n"
        L"      -qv             Queries the supported volumes.\n"
        L"      -P              Specifies a provider Id\n"
        L"      -da             Adds a diff area association.\n"
        L"      -dr             Removes a diff area association.\n"
        L"      -ds             Change diff area max size.\n"
        L"      -dqv            Query the volumes supported for diff area.\n"
        L"      -dqf            Query the diff area associations for volume.\n"
        L"      -dqo            Query the diff area associations on volume.\n"
        L"      -r              Remove the snapshot with that ID.\n"
        L"      -rs             Remove the snapshots from the set with that ID.\n"
        L"      -?              Displays this help.\n"
        L"      -D              Pops up an assert for attaching a debugger.\n"
        L"\n"
        L"\nExample:\n"
        L"      The following command will create a backup snapshot set\n"
        L"      on the volumes mounted under c:\\ and d:\\\n"
        L"\n"
        L"              vsml c:\\ d:\\ \n"
        L"\n"
        );

    if (bThrow)
        throw(E_INVALIDARG);

    return false;
}


bool CVssMultilayerTest::ParseCommandLine()
{
    if (!TokensLeft() || Match(L"-?"))
        return PrintUsage(false);

    // Check for context options
    if (Match(L"-D"))
        m_bAttachYourDebuggerNow = true;

    // Query using the IOCTL
    if (Match(L"-qi")) {
        m_eTest = VSS_TEST_VOLSNAP_QUERY;

        // Get the original volume
        if (!Extract(m_pwszVolume) || !IsVolume(m_pwszVolume))
            return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Query using the IOCTL
    if (Match(L"-is")) {
        m_eTest = VSS_TEST_IS_VOLUME_SNAPSHOTTED_C;

        // Get the original volume
        if (!Extract(m_pwszVolume) || !IsVolume(m_pwszVolume))
            return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Check for context options
    if (Match(L"-xt"))
        m_lContext = VSS_CTX_CLIENT_ACCESSIBLE;

    if (Match(L"-xa"))
        m_lContext = VSS_CTX_ALL;

    // Add the Diff Area
    if (Match(L"-da")) {
        m_eTest = VSS_TEST_ADD_DIFF_AREA;

        // Get the original volume
        if (!Extract(m_pwszVolume) || !IsVolume(m_pwszVolume))
            return PrintUsage();

        // Get the diff area volume
        if (!Extract(m_pwszDiffAreaVolume) || !IsVolume(m_pwszDiffAreaVolume))
            return PrintUsage();

        // Check to see if we specified a max diff area (i.e. -P is not present)
        if (!Peek(L"-P"))
            Extract(m_llMaxDiffArea);

        // Check to see if we specified a provider ID
        if (Match(L"-P")) {
            if (!Extract(m_ProviderId))
                return PrintUsage();
            Extract(m_llMaxDiffArea);
        }

        return TokensLeft()? PrintUsage(): true;
    }

    // Remove the Diff Area
    if (Match(L"-dr")) {
        m_eTest = VSS_TEST_REMOVE_DIFF_AREA;

        // Get the original volume
        if (!Extract(m_pwszVolume) || !IsVolume(m_pwszVolume))
            return PrintUsage();

        // Get the diff area volume
        if (!Extract(m_pwszDiffAreaVolume) || !IsVolume(m_pwszDiffAreaVolume))
            return PrintUsage();

        // Check to see if we specified a provider ID
        if (Match(L"-P"))
            if (!Extract(m_ProviderId))
                return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Change Diff Area max size
    if (Match(L"-ds")) {
        m_eTest = VSS_TEST_CHANGE_DIFF_AREA_MAX_SIZE;

        // Get the original volume
        if (!Extract(m_pwszVolume) || !IsVolume(m_pwszVolume))
            return PrintUsage();

        // Get the diff area volume
        if (!Extract(m_pwszDiffAreaVolume) || !IsVolume(m_pwszDiffAreaVolume))
            return PrintUsage();

        // Check to see if we specified a max diff area (i.e. -P is not present)
        if (!Peek(L"-P"))
            Extract(m_llMaxDiffArea);

        // Check to see if we specified a provider ID
        if (Match(L"-P")) {
            if (!Extract(m_ProviderId))
                return PrintUsage();
            Extract(m_llMaxDiffArea);
        }

        return TokensLeft()? PrintUsage(): true;
    }

    // Query the volumes supported for Diff Area
    if (Match(L"-dqv")) {
        m_eTest = VSS_TEST_QUERY_SUPPORTED_VOLUMES_FOR_DIFF_AREA;

        // Check to see if we specified a provider ID
        if (Match(L"-P"))
            if (!Extract(m_ProviderId))
                return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Query the volumes supported for Diff Area
    if (Match(L"-dqf")) {
        m_eTest = VSS_TEST_QUERY_DIFF_AREAS_FOR_VOLUME;

        // Get the original volume
        if (!Extract(m_pwszVolume) || !IsVolume(m_pwszVolume))
            return PrintUsage();

        // Check to see if we specified a provider ID
        if (Match(L"-P"))
            if (!Extract(m_ProviderId))
                return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Query the volumes supported for Diff Area
    if (Match(L"-dqo")) {
        m_eTest = VSS_TEST_QUERY_DIFF_AREAS_ON_VOLUME;

        // Get the original volume
        if (!Extract(m_pwszDiffAreaVolume) || !IsVolume(m_pwszDiffAreaVolume))
            return PrintUsage();

        // Check to see if we specified a provider ID
        if (Match(L"-P"))
            if (!Extract(m_ProviderId))
                return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Check for Query
    if (Match(L"-qs")) {
        m_eTest = VSS_TEST_QUERY_SNAPSHOTS;

        // Check to see if we specified a provider ID
        if (Match(L"-P"))
            if (!Extract(m_ProviderId))
                return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Check for Query
    if (Match(L"-qsv")) {
        m_eTest = VSS_TEST_QUERY_SNAPSHOTS_ON_VOLUME;

        // Extract the volume volume
        if (!Extract(m_pwszVolume) || !IsVolume(m_pwszVolume))
            return PrintUsage();

        // Check to see if we specified a provider ID
        if (Match(L"-P"))
            if (!Extract(m_ProviderId))
                return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Check for Query Supported Volumes
    if (Match(L"-qv")) {
        m_eTest = VSS_TEST_QUERY_VOLUMES;

        // Check to see if we specified a provider ID
        if (Match(L"-P"))
            if (!Extract(m_ProviderId))
                return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Check for Delete by snapshot Id
    if (Match(L"-r")) {
        m_eTest = VSS_TEST_DELETE_BY_SNAPSHOT_ID;

        // Extract the snapshot id
        if (!Extract(m_SnapshotId))
            return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Check for Delete by snapshot set Id
    if (Match(L"-rs")) {
        m_eTest = VSS_TEST_DELETE_BY_SNAPSHOT_SET_ID;

        // Extract the snapshot id
        if (!Extract(m_SnapshotSetId))
            return PrintUsage();

        return TokensLeft()? PrintUsage(): true;
    }

    // Check for Seed option
    if (Match(L"-s"))
        if (!Extract(m_uSeed))
            return PrintUsage();

    // We are in snapshot creation mode
    if (!TokensLeft())
        return PrintUsage();

    bool bVolumeAdded = false;
    VSS_PWSZ pwszVolumeName = NULL;
    while (TokensLeft()) {
        Extract(pwszVolumeName);
        if (!AddVolume(pwszVolumeName, bVolumeAdded)) {
            wprintf(L"\nError while parsing the command line:\n"
                L"\t%s is not a valid option or a mount point [0x%08lx]\n\n",
                GetCurrentToken(), GetLastError() );
            return PrintUsage();
        }

        // Check if the same volume is added twice
        if (!bVolumeAdded) {
            wprintf(L"\nError while parsing the command line:\n"
                L"\tThe volume %s is specified twice\n\n", GetCurrentToken() );
            return PrintUsage();
        }

        ::VssFreeString(pwszVolumeName);
    }

    m_eTest = VSS_TEST_CREATE;

    return true;
}


// Check if there are tokens left
bool CVssMultilayerTest::TokensLeft()
{
    return (m_nCurrentArgsCount != 0);
}


// Returns the current token
VSS_PWSZ CVssMultilayerTest::GetCurrentToken()
{
    return (*m_ppwszCurrentArgsArray);
}


// Go to next token
void CVssMultilayerTest::Shift()
{
    BS_ASSERT(m_nCurrentArgsCount);
    m_nCurrentArgsCount--;
    m_ppwszCurrentArgsArray++;
}


// Check if the current command line token matches with the given pattern
// Do not shift to the next token
bool CVssMultilayerTest::Peek(
	IN	VSS_PWSZ pwszPattern
	) throw(HRESULT)
{
    if (!TokensLeft())
        return false;

    // Try to find a match
    if (wcscmp(GetCurrentToken(), pwszPattern))
        return false;

    // Go to the next token
    return true;
}


// Match the current command line token with the given pattern
// If succeeds, then switch to the next token
bool CVssMultilayerTest::Match(
	IN	VSS_PWSZ pwszPattern
	) throw(HRESULT)
{
    if (!Peek(pwszPattern))
        return false;

    // Go to the next token
    Shift();
    return true;
}


// Converts the current token to a guid
// If succeeds, then switch to the next token
bool CVssMultilayerTest::Extract(
	IN OUT VSS_ID& Guid
	) throw(HRESULT)
{
    if (!TokensLeft())
        return false;

    // Try to extract the guid
    if (!SUCCEEDED(::CLSIDFromString(W2OLE(const_cast<WCHAR*>(GetCurrentToken())), &Guid)))
        return false;

    // Go to the next token
    Shift();
    return true;
}


// Converts the current token to a string
// If succeeds, then switch to the next token
bool CVssMultilayerTest::Extract(
	IN OUT VSS_PWSZ& pwsz
	) throw(HRESULT)
{
    if (!TokensLeft())
        return false;

    // Extract the string
    ::VssDuplicateStr(pwsz, GetCurrentToken());
    if (!pwsz)
        throw(E_OUTOFMEMORY);

    // Go to the next token
    Shift();
    return true;
}


// Converts the current token to an UINT
// If succeeds, then switch to the next token
bool CVssMultilayerTest::Extract(
	IN OUT UINT& uint
	) throw(HRESULT)
{
    if (!TokensLeft())
        return false;

    // Extract the unsigned value
    uint = ::_wtoi(GetCurrentToken());

    // Go to the next token
    Shift();
    return true;
}


// Converts the current token to an UINT
// If succeeds, then switch to the next token
bool CVssMultilayerTest::Extract(
	IN OUT LONGLONG& llValue
	) throw(HRESULT)
{
    if (!TokensLeft())
        return false;

    // Extract the unsigned value
    llValue = ::_wtoi64(GetCurrentToken());

    // Go to the next token
    Shift();
    return true;
}


// Returns true if the given string is a volume
bool CVssMultilayerTest::IsVolume(
    IN WCHAR* pwszVolumeDisplayName
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::IsVolume");

    // Check if the volume represents a real mount point
    WCHAR wszVolumeName[MAX_TEXT_BUFFER];
    if (!GetVolumeNameForVolumeMountPoint(pwszVolumeDisplayName, wszVolumeName, MAX_TEXT_BUFFER))
        return false; // Invalid volume

    return true;
}


// Add the given volume in the list of potential candidates for snapshots
// - Returns "false" if the volume does not correspond to a real mount point
//   (and GetLastError() will contain the correct Win32 error code)
// - Sets "true" in the bAdded parameter if the volume is actually added
bool CVssMultilayerTest::AddVolume(
    IN WCHAR* pwszVolumeDisplayName,
    OUT bool & bAdded
    )
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::AddVolume");

    // Initialize [out] parameters
    bAdded = false;

    // Check if the volume represents a real mount point
    WCHAR wszVolumeName[MAX_TEXT_BUFFER];
    if (!GetVolumeNameForVolumeMountPoint(pwszVolumeDisplayName, wszVolumeName, MAX_TEXT_BUFFER))
        return false; // Invalid volume

    // Check if the volume is already added.
    WCHAR* pwszVolumeNameToBeSearched = wszVolumeName;
    if (m_mapVolumes.FindKey(pwszVolumeNameToBeSearched) != -1)
        return true; // Volume already added. Stop here.

    // Create the volume info object
    CVssVolumeInfo* pVolInfo = new CVssVolumeInfo(wszVolumeName, pwszVolumeDisplayName);
    if (pVolInfo == NULL)
        ft.Err(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allcation error");

    // Add the volume in our internal list of snapshotted volumes
    if (!m_mapVolumes.Add(pVolInfo->GetVolumeDisplayName(), pVolInfo)) {
        delete pVolInfo;
        ft.Err(VSSDBG_VSSTEST, E_OUTOFMEMORY, L"Memory allcation error");
    }

    bAdded = true;

    return true;
}


///////////////////////////////////////////////////////////////////////////////
// Utility functions


// Convert a failure type into a string
LPCWSTR CVssMultilayerTest::GetStringFromFailureType( IN  HRESULT hrStatus )
{
    static WCHAR wszBuffer[MAX_TEXT_BUFFER];

    switch (hrStatus)
	{
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_WRITERERROR_OUTOFRESOURCES)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_WRITERERROR_TIMEOUT)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_WRITERERROR_NONRETRYABLE)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_WRITERERROR_RETRYABLE)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_BAD_STATE)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_PROVIDER_ALREADY_REGISTERED)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_PROVIDER_NOT_REGISTERED)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_PROVIDER_VETO)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_PROVIDER_IN_USE)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_OBJECT_NOT_FOUND)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_S_ASYNC_PENDING)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_S_ASYNC_FINISHED)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_S_ASYNC_CANCELLED)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_VOLUME_NOT_SUPPORTED)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_OBJECT_ALREADY_EXISTS)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_UNEXPECTED_PROVIDER_ERROR)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_CORRUPT_XML_DOCUMENT)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_INVALID_XML_DOCUMENT)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_FLUSH_WRITES_TIMEOUT)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_HOLD_WRITES_TIMEOUT)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_UNEXPECTED_WRITER_ERROR)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_SNAPSHOT_SET_IN_PROGRESS)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_WRITER_INFRASTRUCTURE)
	VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_WRITER_NOT_RESPONDING)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_WRITER_ALREADY_SUBSCRIBED)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_UNSUPPORTED_CONTEXT)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_VOLUME_IN_USE)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_MAXIMUM_DIFFAREA_ASSOCIATIONS_REACHED)
    VSS_ERROR_CASE(wszBuffer, MAX_TEXT_BUFFER, VSS_E_INSUFFICIENT_STORAGE)
	
	case NOERROR:
	    break;
	
	default:
        ::FormatMessageW( FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, hrStatus, 0, (LPWSTR)&wszBuffer, MAX_TEXT_BUFFER - 1, NULL);
	    break;
	}

    return (wszBuffer);
}


INT CVssMultilayerTest::RndDecision(
    IN INT nVariants /* = 2 */
    )
{
    return (rand() % nVariants);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\multilayer\mldiff.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	    ml.cpp
**
**
** Abstract:
**
**	    Test program to exercise backup and multilayer snapshots
**
** Author:
**
**	    Adi Oltean      [aoltean]       02/22/2001
**
**
** Revision History:
**
**--
*/


///////////////////////////////////////////////////////////////////////////////
// Includes

#include "ml.h"


///////////////////////////////////////////////////////////////////////////////
// Processing functions

// Adding a diff area association
void CVssMultilayerTest::AddDiffArea()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::AddDiffArea");

    wprintf (L"\n---------- Adding a diff area ----------------------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_NOFAIL(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pSnapMgmt;
	CHECK_SUCCESS( pMgmt->GetProviderMgmtInterface( m_ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pSnapMgmt ) );
    
    CHECK_SUCCESS( pSnapMgmt->AddDiffArea( m_pwszVolume, m_pwszDiffAreaVolume, m_llMaxDiffArea ));
}


// Removing a diff area association
void CVssMultilayerTest::RemoveDiffArea()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::RemoveDiffArea");

    wprintf (L"\n---------- Removing a diff area ----------------------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_NOFAIL(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pSnapMgmt;
	CHECK_SUCCESS( pMgmt->GetProviderMgmtInterface( m_ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pSnapMgmt ));

    // Remove the diff area
    CHECK_SUCCESS( pSnapMgmt->ChangeDiffAreaMaximumSize( m_pwszVolume, m_pwszDiffAreaVolume, VSS_ASSOC_REMOVE ));
}


// Changing the diff area max size
void CVssMultilayerTest::ChangeDiffAreaMaximumSize()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::ChangeDiffAreaMaximumSize");

    wprintf (L"\n---------- Changing diff area max size ----------------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_NOFAIL(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pSnapMgmt;
	CHECK_SUCCESS(pMgmt->GetProviderMgmtInterface( m_ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pSnapMgmt ));
    
    CHECK_SUCCESS(pSnapMgmt->ChangeDiffAreaMaximumSize( m_pwszVolume, m_pwszDiffAreaVolume, m_llMaxDiffArea ));
}


// Querying volumes for diff area
void CVssMultilayerTest::QueryVolumesSupportedForDiffAreas()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::QueryVolumesSupportedForDiffAreas");

    wprintf (L"\n---------- Querying volumes supported for diff area ----------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_NOFAIL(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pSnapMgmt;
	CHECK_SUCCESS(pMgmt->GetProviderMgmtInterface( m_ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pSnapMgmt ));
    
	// Get list all supported volumes for diff area
	CComPtr<IVssEnumMgmtObject> pIEnum;
	CHECK_NOFAIL(pSnapMgmt->QueryVolumesSupportedForDiffAreas( &pIEnum ));
	if (ft.hr == S_FALSE) {
        wprintf(L"Query: Empty result...\n");
        return;
	}

    wprintf(L"\n%-50s %-15s %-10s %-10s\n", L"Volume Name", L"Display name", L"Free space", L"Total space");
    wprintf(L"------------------------------------------------------------------------------------------\n");

	// For all volumes do...
	VSS_MGMT_OBJECT_PROP Prop;
	VSS_DIFF_VOLUME_PROP& DiffVol = Prop.Obj.DiffVol;
	for(;;) {
		// Get next element
		ULONG ulFetched;
		CHECK_NOFAIL(pIEnum->Next( 1, &Prop, &ulFetched ));
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        wprintf(L"%-50s %-15s %I64d %I64d\n", 
            DiffVol.m_pwszVolumeName, 
            DiffVol.m_pwszVolumeDisplayName,
            DiffVol.m_llVolumeFreeSpace,
            DiffVol.m_llVolumeTotalSpace
            );

        ::CoTaskMemFree(DiffVol.m_pwszVolumeName);
        ::CoTaskMemFree(DiffVol.m_pwszVolumeDisplayName);
	}

    wprintf(L"------------------------------------------------------------------------------------------\n");

}


// Querying volumes for diff area
void CVssMultilayerTest::QueryDiffAreasForVolume()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::QueryDiffAreasForVolume");

    wprintf (L"\n---------- Querying diff areas for volume ----------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_NOFAIL(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pSnapMgmt;
	CHECK_SUCCESS(pMgmt->GetProviderMgmtInterface( m_ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pSnapMgmt ));
    
	// Get list all supported volumes for diff area
	CComPtr<IVssEnumMgmtObject> pIEnum;
	CHECK_NOFAIL(pSnapMgmt->QueryDiffAreasForVolume( m_pwszVolume, &pIEnum ));
	if (ft.hr == S_FALSE) {
        wprintf(L"Query: Empty result...\n");
        return;
	}

    wprintf(L"\n%- 50s %- 50s %-10s %-10s %-10s\n", L"Volume", L"Diff area", L"Used", L"Allocated", L"Maximum");
    wprintf(L"-------------------------------------------------------------------------------------------------------------------------------\n");

	// For all volumes do...
	VSS_MGMT_OBJECT_PROP Prop;
	VSS_DIFF_AREA_PROP& DiffArea = Prop.Obj.DiffArea; 
	for(;;) {
		// Get next element
		ULONG ulFetched;
		CHECK_NOFAIL(pIEnum->Next( 1, &Prop, &ulFetched ));
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        wprintf(L"%- 50s %- 50s %-10I64d %-10I64d %-10I64d\n", 
            DiffArea.m_pwszVolumeName, 
            DiffArea.m_pwszDiffAreaVolumeName,
            DiffArea.m_llUsedDiffSpace,
            DiffArea.m_llAllocatedDiffSpace,
            DiffArea.m_llMaximumDiffSpace
            );

        ::CoTaskMemFree(DiffArea.m_pwszVolumeName);
        ::CoTaskMemFree(DiffArea.m_pwszDiffAreaVolumeName);
	}

    wprintf(L"-------------------------------------------------------------------------------------------------------------------------------\n");

}


// Querying volumes on diff area
void CVssMultilayerTest::QueryDiffAreasOnVolume()
{
    CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssMultilayerTest::QueryDiffAreasOnVolume");

    wprintf (L"\n---------- Querying diff areas On volume ----------------\n");

    // Create a Coordinator interface
    CComPtr<IVssSnapshotMgmt> pMgmt;
    CHECK_NOFAIL(pMgmt.CoCreateInstance( CLSID_VssSnapshotMgmt ));
    wprintf (L"Management object created.\n");

	// Get the management object
	CComPtr<IVssDifferentialSoftwareSnapshotMgmt> pSnapMgmt;
	CHECK_SUCCESS(pMgmt->GetProviderMgmtInterface( m_ProviderId, IID_IVssDifferentialSoftwareSnapshotMgmt, (IUnknown**)&pSnapMgmt ));
    
	// Get list all supported volumes for diff area
	CComPtr<IVssEnumMgmtObject> pIEnum;
	CHECK_NOFAIL(pSnapMgmt->QueryDiffAreasOnVolume( m_pwszDiffAreaVolume, &pIEnum ));
	if (ft.hr == S_FALSE) {
        wprintf(L"Query: Empty result...\n");
        return;
	}

    wprintf(L"\n%- 50s %- 50s %-10s %-10s %-10s\n", L"Volume", L"Diff area", L"Used", L"Allocated", L"Maximum");
    wprintf(L"-------------------------------------------------------------------------------------------------------------------------------\n");

	// For all volumes do...
	VSS_MGMT_OBJECT_PROP Prop;
	VSS_DIFF_AREA_PROP& DiffArea = Prop.Obj.DiffArea; 
	for(;;) {
		// Get next element
		ULONG ulFetched;
		CHECK_NOFAIL(pIEnum->Next( 1, &Prop, &ulFetched ));
		
		// Test if the cycle is finished
		if (ft.hr == S_FALSE) {
			BS_ASSERT( ulFetched == 0);
			break;
		}

        wprintf(L"%- 50s %- 50s %-10I64d %-10I64d %-10I64d\n", 
            DiffArea.m_pwszVolumeName, 
            DiffArea.m_pwszDiffAreaVolumeName,
            DiffArea.m_llUsedDiffSpace,
            DiffArea.m_llAllocatedDiffSpace,
            DiffArea.m_llMaximumDiffSpace
            );

        ::CoTaskMemFree(DiffArea.m_pwszVolumeName);
        ::CoTaskMemFree(DiffArea.m_pwszDiffAreaVolumeName);
	}

    wprintf(L"-------------------------------------------------------------------------------------------------------------------------------\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\multilayer\objects.h ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	    objects.h
**
**
** Abstract:
**
**	    Test program to exercise backup and multilayer snapshots
**
** Author:
**
**	    Adi Oltean      [aoltean]       02/22/2001
**
** Revision History:
**
**--
*/

#ifndef __ML_OBJECTS_H__
#define __ML_OBJECTS_H__

#if _MSC_VER > 1000
#pragma once
#endif


///////////////////////////////////////////////////////////////////////////////
// Snapshot-related classes


class CVssVolumeInfo;


// Keeps the information that describes one snapshot
class CVssSnapshotInfo
{
// Constructors& destructors
private:
    CVssSnapshotInfo& operator = (const CVssSnapshotInfo&);
    CVssSnapshotInfo();
    CVssSnapshotInfo(const CVssSnapshotInfo&);

public:

    CVssSnapshotInfo( 
        IN bool bActive,
        IN LONG lContext, 
        IN VSS_ID SnapshotSetId, 
        IN VSS_PWSZ pwszDeviceName,                     
        IN VSS_PWSZ pwszVolumeName,                     
        IN CVssVolumeInfo* pVol
        ): m_pwszDeviceName(NULL), m_pwszVolumeName(NULL)
    {
        CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssSnapshotInfo::CVssSnapshotInfo");

        try
        {
            m_bActive = bActive;
            m_lContext = lContext;
            m_SnapshotSetId = SnapshotSetId;
            m_pVol = pVol;
            
            ::VssSafeDuplicateStr(ft, m_pwszDeviceName, pwszDeviceName); 
            ::VssSafeDuplicateStr(ft, m_pwszVolumeName, pwszVolumeName); 
        }
        VSS_STANDARD_CATCH(ft)

        if (ft.HrFailed()) {
            ::VssFreeString(m_pwszDeviceName); 
            ::VssFreeString(m_pwszVolumeName); 
        }
    };

    ~CVssSnapshotInfo() 
    {
        ::VssFreeString(m_pwszDeviceName);
        ::VssFreeString(m_pwszVolumeName);
    };

    BOOL m_bActive;
    LONG m_lContext;
    VSS_ID m_SnapshotSetId;
    VSS_PWSZ m_pwszDeviceName;  
    VSS_PWSZ m_pwszVolumeName;  
    CVssVolumeInfo* m_pVol;
};


// Keeps an internal map of snapshots from a snapshot set. 
// The key is the original volume name
class CVssSnapshotSetInfo:
    public CVssSimpleMap< LPCWSTR, CVssSnapshotInfo* >
{
// Constructors& destructors
private:
    CVssSnapshotSetInfo& operator = (const CVssSnapshotSetInfo&);
    CVssSnapshotSetInfo(const CVssSnapshotSetInfo&);
    CVssSnapshotSetInfo();
    
public:
    CVssSnapshotSetInfo(
        IN VSS_ID SnapshotSetId
        ): m_SnapshotSetId(SnapshotSetId) {}; 

   ~CVssSnapshotSetInfo() {
        // Remove all elements
        for (int i = 0; i < GetSize(); i++) {
            CVssSnapshotInfo* pSnapInfo = GetValueAt(i);
            delete pSnapInfo;
        }
        // Remove all items        
        RemoveAll();
    };

// Attributes
public:
    VSS_ID GetSnapshotSetID() const { return m_SnapshotSetId; };

// Implementation 
private: 
    VSS_ID m_SnapshotSetId;
};


// Keeps an internal map of snapshots from a snapshot set. 
// The key is the original volume name
class CVssSnapshotSetCollection:
    public CVssSimpleMap< VSS_ID, CVssSnapshotSetInfo* >
{
// Constructors& destructors
private:
    CVssSnapshotSetCollection& operator = (const CVssSnapshotSetCollection&);
    
public:

   ~CVssSnapshotSetCollection() {
        // Remove all elements
        for (int i = 0; i < GetSize(); i++) {
            CVssSnapshotSetInfo* pSnapSetInfo = GetValueAt(i);
            delete pSnapSetInfo;
        }
        // Remove all items        
        RemoveAll();
    }
};


///////////////////////////////////////////////////////////////////////////////
// Volume-related classes

// Keeps the information that describes one volume
class CVssVolumeInfo
{
    
// Constructors/ destructors
private:
    CVssVolumeInfo();
    CVssVolumeInfo(const CVssVolumeInfo&);
    
public:
    CVssVolumeInfo(
        IN VSS_PWSZ pwszVolumeName,  
        IN VSS_PWSZ pwszVolumeDisplayName
        ): m_pwszVolumeName(NULL), m_pwszVolumeDisplayName(NULL)
    {
        CVssFunctionTracer ft(VSSDBG_VSSTEST, L"CVssVolumeInfo::CVssVolumeInfo");

        try
        {
            ::VssSafeDuplicateStr(ft, m_pwszVolumeName, pwszVolumeName); 
            ::VssSafeDuplicateStr(ft, m_pwszVolumeDisplayName, pwszVolumeDisplayName); 
        }
        VSS_STANDARD_CATCH(ft)

        if (ft.HrFailed()) {
            ::VssFreeString(m_pwszVolumeName);
            ::VssFreeString(m_pwszVolumeDisplayName);
        }
    };

    ~CVssVolumeInfo() 
    {
        ::VssFreeString(m_pwszVolumeName);
        ::VssFreeString(m_pwszVolumeDisplayName);
    };

// Attributes
public:
    VSS_PWSZ GetVolumeName() const { return m_pwszVolumeName; };
    VSS_PWSZ GetVolumeDisplayName() const { return m_pwszVolumeDisplayName; };

// Implementation
private:
    VSS_PWSZ    m_pwszVolumeName;
    VSS_PWSZ    m_pwszVolumeDisplayName;
};


// Keeps an internal array of volume names
// that does NOT remove the volume structures in the destructor
class CVssVolumeMapNoRemove: public CVssSimpleMap<VSS_PWSZ, CVssVolumeInfo*>
{
};


// Keeps an internal array of volume names
// that REMOVES the volume structures in the destructor
class CVssVolumeMap: public CVssSimpleMap<VSS_PWSZ, CVssVolumeInfo*>
{
public:
    ~CVssVolumeMap() {
        // Remove all volumes
        for (int i = 0; i < GetSize(); i++) {
            CVssVolumeInfo* pVolumeInfo = GetValueAt(i);
            delete pVolumeInfo;
        }
        
        // Remove all items        
        RemoveAll();
    }
};

#endif // __ML_OBJECTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\sqltest\main.cpp ===
// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes

#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>
#include <stdio.h>


#include "vss.h"
#include "vswriter.h"
#include "sqlsnap.h"
#include "sqlwriter.h"

DWORD g_dwMainThreadId;

/////////////////////////////////////////////////////////////////////////////
//  Control-C handler routine


BOOL WINAPI CtrlC_HandlerRoutine(
	IN DWORD /* dwType */
	)
	{
	// End the message loop
	if (g_dwMainThreadId != 0)
		PostThreadMessage(g_dwMainThreadId, WM_QUIT, 0, 0);

	// Mark that the break was handled.
	return TRUE;
	}

CVssSqlWriterWrapper g_Wrapper;

extern "C" int __cdecl wmain(HINSTANCE /*hInstance*/,
    HINSTANCE /*hPrevInstance*/, LPTSTR /*lpCmdLine*/, int /*nShowCmd*/)
	{
	int nRet = 0;

    try
		{
    	// Preparing the CTRL-C handling routine - only for testing...
		g_dwMainThreadId = GetCurrentThreadId();
		::SetConsoleCtrlHandler(CtrlC_HandlerRoutine, TRUE);

        // Initialize COM library
        HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if (FAILED(hr))
			throw hr;

		// Declare a CVssTSubWriter instance
		hr = g_Wrapper.CreateSqlWriter();
		if (FAILED(hr))
			throw hr;

        // message loop - need for STA server
        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);

		// Subscribe the object.
		g_Wrapper.DestroySqlWriter();

        // Uninitialize COM library
        CoUninitialize();
		}
	catch(...)
		{
		}

    return nRet;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\shimtest\shimtest.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    client.cpp

Abstract:

    Test program to drive the VSS Writer Shim contained in VssAPI.DLL

Author:

    Stefan R. Steiner   [ssteiner]        01-30-2000

Revision History:

--*/

/////////////////////////////////////////////////////////////////////////////
//  Defines

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes

#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdio.h>
#include <objbase.h>

#include <vss.h>

typedef HRESULT ( APIENTRY *PFUNC_RegisterSnapshotSubscriptions )( void );
typedef HRESULT ( APIENTRY *PFUNC_UnregisterSnapshotSubscriptions )( void );
typedef HRESULT ( APIENTRY *PFUNC_SimulateSnapshotFreeze )( PWCHAR pwszSnapshotSetId, PWCHAR pwszVolumeNamesList );
typedef HRESULT ( APIENTRY *PFUNC_SimulateSnapshotThaw )( PWCHAR pwszSnapshotSetId );



static BOOL AssertPrivilege( LPCWSTR privName );

/////////////////////////////////////////////////////////////////////////////
//  WinMain

extern "C" int __cdecl wmain( int argc, WCHAR *argv[] )
{
    HINSTANCE hInstLib;
    PFUNC_RegisterSnapshotSubscriptions pFnRegisterSS;
    PFUNC_UnregisterSnapshotSubscriptions pFnUnregisterSS;
    HRESULT hr;

    if ( !AssertPrivilege( SE_BACKUP_NAME ) )
    {
        wprintf( L"AssertPrivilege returned error, rc:%d\n", GetLastError() );
        return 2;
    }

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( FAILED( hr ) )
    {
        wprintf( L"CoInitialize() returned rc:%d\n", GetLastError() );
        return 1;
    }

    //  Get a handle to the DLL module
    hInstLib = LoadLibrary( L"VssAPI.dll" );

    if ( hInstLib != NULL )
    {
        pFnRegisterSS = ( PFUNC_RegisterSnapshotSubscriptions )GetProcAddress( hInstLib, "RegisterSnapshotSubscriptions" );
        if ( pFnRegisterSS != NULL )
            wprintf( L"pFnRegisterSS returned: 0x%08x\n", ( pFnRegisterSS )() );
        else
            wprintf( L"Couldn't import RegisterSnapshotSubscriptions function, rc:%d\n", GetLastError() );

        wprintf( L"\nPress return to continue...\n" );
        getchar();
        wprintf( L"continuing...\n" );

        pFnUnregisterSS = ( PFUNC_UnregisterSnapshotSubscriptions )GetProcAddress( hInstLib, "UnregisterSnapshotSubscriptions" );
        if ( pFnUnregisterSS != NULL )
            wprintf( L"pFnUnregisterSS returned: 0x%08x\n", ( pFnUnregisterSS )() );
        else
            wprintf( L"Couldn't import UnregisterSnapshotSubscriptions function, rc:%d\n", GetLastError() );

        FreeLibrary( hInstLib );
    }
    else
        printf( "LoadLibrary error, rc:%d\n", GetLastError() );


    // Uninitialize COM library
    CoUninitialize();

    return 0;

    UNREFERENCED_PARAMETER( argv );
    UNREFERENCED_PARAMETER( argc );
}


static BOOL AssertPrivilege( LPCWSTR privName )
{
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if ( OpenProcessToken( GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &tokenHandle ) )
    {
        LUID value;

        if ( LookupPrivilegeValue( NULL, privName, &value ) )
        {
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            /*
            * We will always call GetLastError below, so clear
            * any prior error values on this thread.
            */
            SetLastError( ERROR_SUCCESS );

            stat =  AdjustTokenPrivileges(
                tokenHandle,
                FALSE,
                &newState,
                (DWORD)0,
                NULL,
                NULL );
            /*
            * Supposedly, AdjustTokenPriveleges always returns TRUE
            * (even when it fails). So, call GetLastError to be
            * extra sure everything's cool.
            */
            if ( (error = GetLastError()) != ERROR_SUCCESS )
            {
                stat = FALSE;
            }

            if ( !stat )
            {
                wprintf( L"AdjustTokenPrivileges for %s failed with %d",
                    privName,
                    error );
            }
        }
        CloseHandle( tokenHandle );
    }
    return stat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\hosting.cpp ===
// Hosting.cpp : implementation file
//

#include "stdafx.h"
#include "utils.h"
#include "Hosting.h"
#include "uihelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHosting dialog


CHosting::CHosting(CWnd* pParent /*=NULL*/)
	: CDialog(CHosting::IDD, pParent)
{
	//{{AFX_DATA_INIT(CHosting)
	m_strVolume = _T("");
	//}}AFX_DATA_INIT
    m_strComputer = _T("");
}

CHosting::CHosting(LPCTSTR pszComputer, LPCTSTR pszVolume, CWnd* pParent /*=NULL*/)
	: CDialog(CHosting::IDD, pParent)
{
    m_strComputer = pszComputer + (TWO_WHACKS(pszComputer) ? 2 : 0);
    m_strVolume = pszVolume;
}

void CHosting::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHosting)
	DDX_Control(pDX, IDC_HOSTING_FREE_DISKSPACE, m_ctrlFreeSpace);
	DDX_Control(pDX, IDC_HOSTING_TOTAL_DISKSPACE, m_ctrlTotalSpace);
	DDX_Control(pDX, IDC_HOSTING_VOLUMELIST, m_ctrlVolumeList);
	DDX_Text(pDX, IDC_HOSTING_VOLUME, m_strVolume);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHosting, CDialog)
	//{{AFX_MSG_MAP(CHosting)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHosting message handlers

BOOL CHosting::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    // init listview control
    HWND hwnd = m_ctrlVolumeList.m_hWnd;
    AddLVColumns(
            hwnd, 
            IDS_HOSTINGLIST_COLUMN_VOLUME,
            IDS_HOSTINGLIST_COLUMN_DIFFCONSUMPTION - IDS_HOSTINGLIST_COLUMN_VOLUME + 1);
    ListView_SetExtendedListViewStyle(hwnd, LVS_EX_FULLROWSELECT);
	
    TCHAR   szDiskSpace[MAX_PATH];
    DWORD   dwSize = 0;
    int     nIndex = 0;
    LVITEM  lvItem = {0};
    for (VSSUI_DIFFAREA_LIST::iterator i = m_DiffAreaList.begin(); i != m_DiffAreaList.end(); i++)
    {
        ZeroMemory(&lvItem, sizeof(LVITEM));
        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = (*i)->pszVolumeDisplayName;
        lvItem.iSubItem = 0;
        nIndex = m_ctrlVolumeList.InsertItem(&lvItem);

        lvItem.iItem = nIndex;

        dwSize = sizeof(szDiskSpace)/sizeof(TCHAR);
        DiskSpaceToString((*i)->llMaximumDiffSpace, szDiskSpace, &dwSize);
        lvItem.pszText = szDiskSpace;
        lvItem.iSubItem = IDS_HOSTINGLIST_COLUMN_DIFFLIMITS - IDS_HOSTINGLIST_COLUMN_VOLUME;
        m_ctrlVolumeList.SetItem(&lvItem);

        dwSize = sizeof(szDiskSpace)/sizeof(TCHAR);
        DiskSpaceToString((*i)->llUsedDiffSpace, szDiskSpace, &dwSize);
        lvItem.pszText = szDiskSpace;
        lvItem.iSubItem = IDS_HOSTINGLIST_COLUMN_DIFFCONSUMPTION - IDS_HOSTINGLIST_COLUMN_VOLUME;
        m_ctrlVolumeList.SetItem(&lvItem);
    }
    
    dwSize = sizeof(szDiskSpace)/sizeof(TCHAR);
    DiskSpaceToString(m_llDiffVolumeTotalSpace, szDiskSpace, &dwSize);
    m_ctrlTotalSpace.SetWindowText(szDiskSpace);

    dwSize = sizeof(szDiskSpace)/sizeof(TCHAR);
    DiskSpaceToString(m_llDiffVolumeFreeSpace, szDiskSpace, &dwSize);
    m_ctrlFreeSpace.SetWindowText(szDiskSpace);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

HRESULT CHosting::Init(
    IVssDifferentialSoftwareSnapshotMgmt* i_piDiffSnapMgmt,
    VSSUI_VOLUME_LIST*  i_pVolumeList,
    IN LPCTSTR          i_pszVolumeDisplayName,
    IN LONGLONG         i_llDiffVolumeTotalSpace,
    IN LONGLONG         i_llDiffVolumeFreeSpace
    )
{
    if (!i_piDiffSnapMgmt ||
        !i_pVolumeList ||
        !i_pszVolumeDisplayName || !*i_pszVolumeDisplayName)
        return E_INVALIDARG;

    m_strVolume = i_pszVolumeDisplayName;
    m_llDiffVolumeTotalSpace = i_llDiffVolumeTotalSpace;
    m_llDiffVolumeFreeSpace = i_llDiffVolumeFreeSpace;

    FreeDiffAreaList(&m_DiffAreaList);

    CComPtr<IVssEnumMgmtObject> spiEnum;
    HRESULT hr = i_piDiffSnapMgmt->QueryDiffAreasOnVolume((PTSTR)i_pszVolumeDisplayName, &spiEnum);
    if (FAILED(hr))
        return hr;

    VSS_MGMT_OBJECT_PROP Prop;
    VSS_DIFF_AREA_PROP* pDiffAreaProp = &(Prop.Obj.DiffArea);
    ULONG ulFetched = 0;
    while (SUCCEEDED(spiEnum->Next(1, &Prop, &ulFetched)) && ulFetched > 0)
    {
        if (VSS_MGMT_OBJECT_DIFF_AREA != Prop.Type)
            return E_FAIL;

        VSSUI_DIFFAREA *pDiffAreaInfo = (VSSUI_DIFFAREA *)calloc(1, sizeof(VSSUI_DIFFAREA));
        if (pDiffAreaInfo)
        {
            PTSTR pszVolumeDisplayName = GetDisplayName(i_pVolumeList, pDiffAreaProp->m_pwszVolumeName);
            PTSTR pszDiffVolumeDisplayName = GetDisplayName(i_pVolumeList, pDiffAreaProp->m_pwszDiffAreaVolumeName);
            ASSERT(pszVolumeDisplayName);
            ASSERT(pszDiffVolumeDisplayName);

            _tcscpy(pDiffAreaInfo->pszVolumeDisplayName, pszVolumeDisplayName);
            _tcscpy(pDiffAreaInfo->pszDiffVolumeDisplayName, pszDiffVolumeDisplayName);
            pDiffAreaInfo->llMaximumDiffSpace = pDiffAreaProp->m_llMaximumDiffSpace;
            pDiffAreaInfo->llUsedDiffSpace = pDiffAreaProp->m_llUsedDiffSpace;

            m_DiffAreaList.push_back(pDiffAreaInfo);
        } else
        {
            FreeDiffAreaList(&m_DiffAreaList);
            hr = E_OUTOFMEMORY;
        }

        ::CoTaskMemFree(pDiffAreaProp->m_pwszVolumeName);
        ::CoTaskMemFree(pDiffAreaProp->m_pwszDiffAreaVolumeName);
    }

    return hr;
}


BOOL CHosting::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (!pHelpInfo || 
        pHelpInfo->iContextType != HELPINFO_WINDOW || 
        pHelpInfo->iCtrlId < 0)
        return FALSE;

    ::WinHelp((HWND)pHelpInfo->hItemHandle,
                VSSUI_CTX_HELP_FILE,
                HELP_WM_HELP,
                (DWORD_PTR)(PVOID)aMenuHelpIDsForViewFiles); 

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\tests\simsnap\simsnap.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	simsnap.cpp
**
**
** Abstract:
**
**	Test program to drive the VSS Writer Shim contained in VssAPI.DLL
**
**
** Author:
**
**	Michael C. Johnson   [mikejohn]        24-May-2000
**
**
** Revision History:
**
**	X-5	MCJ		Michael C. Johnson		15-Sep-2000
**		Add test for invalid volume array pointer, interleaved calls
**		and so on.
**
**	X-4	MCJ		Michael C. Johnson		15-Sep-2000
**		Add test for invalid bits in options parameter of call to
**		SimulateSnapshotFreeze()
**
**	X-3	MCJ		Michael C. Johnson		30-Jun-2000
**		Remove calls to RegisterSnapshotSubscriptions() and
**		UnregisterSnapshotSubscriptions() as these are no longer
**		required.
**
**	X-2	MCJ		Michael C. Johnson		26-May-2000
**		Add some extra tests to validate shim is properly sensitive
**		to volume name array contents.
**--
*/

/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/
#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdio.h>
#include <objbase.h>
#include <guiddef.h>

#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>


static BOOL AssertPrivilege (LPCWSTR privName);

static HRESULT DoTest01 (VOID);
static HRESULT DoTest02 (VOID);
static HRESULT DoTest03 (VOID);
static HRESULT DoTest05 (VOID);
static HRESULT DoTest06 (VOID);
static HRESULT DoTest07 (VOID);
static HRESULT DoTest08 (VOID);
static HRESULT DoTest09 (VOID);
static HRESULT DoTest10 (VOID);
static HRESULT DoTest11 (VOID);
static HRESULT DoTest12 (VOID);
static HRESULT DoTest13 (VOID);
static HRESULT DoTest14 (VOID);




extern "C" int __cdecl wmain (int argc, char *argv[])
    {
    HRESULT	hrStatus;


    UNREFERENCED_PARAMETER (argv);
    UNREFERENCED_PARAMETER (argc);


    wprintf (L"Test for SimulateSnapshotXxxx calls (ProcessId 0x%04x)\nChecking privileges\n",
	     GetCurrentProcessId ());


    if (!AssertPrivilege (SE_BACKUP_NAME))
	{
        wprintf (L"AssertPrivilege returned error 0x%08X\n", GetLastError ());
        return 2;
	}



    wprintf (L"Initializing COM\n");

    hrStatus = CoInitializeEx (NULL, COINIT_MULTITHREADED);

    if (FAILED (hrStatus))
	{
        wprintf (L"CoInitialize() returned 0x%08X\n", GetLastError ());
        return 1;
	}



    if ( argc == 1 )
    {
        hrStatus = DoTest01 ();

        hrStatus = DoTest02 ();

        hrStatus = DoTest05 ();

        hrStatus = DoTest06 ();

        hrStatus = DoTest02 ();

        hrStatus = DoTest07 ();

        hrStatus = DoTest08 ();

        hrStatus = DoTest09 ();

        hrStatus = DoTest10 ();

        hrStatus = DoTest11 ();

        hrStatus = DoTest12 ();

        hrStatus = DoTest13 ();

        hrStatus = DoTest14 ();
    }
    else
    {
        hrStatus = DoTest03();
    }


    CoUninitialize();

    return 0;
    }




static BOOL AssertPrivilege (LPCWSTR privName)
    {
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if (OpenProcessToken (GetCurrentProcess (), TOKEN_ADJUST_PRIVILEGES, &tokenHandle))
	{
        LUID value;

        if (LookupPrivilegeValue (NULL, privName, &value))
	    {
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            /*
            ** We will always call GetLastError below, so clear
            ** any prior error values on this thread.
            */
            SetLastError (ERROR_SUCCESS);

            stat = AdjustTokenPrivileges (tokenHandle,
					  FALSE,
					  &newState,
					  (DWORD)0,
					  NULL,
					  NULL);

            /*
            ** Supposedly, AdjustTokenPriveleges always returns TRUE
            ** (even when it fails). So, call GetLastError to be
            ** extra sure everything's cool.
            */
            if ((error = GetLastError()) != ERROR_SUCCESS)
		{
                stat = FALSE;
		}

            if (!stat)
		{
                wprintf (L"AdjustTokenPrivileges for %s failed with 0x%08X",
			 privName,
			 error);
		}
	    }


        CloseHandle (tokenHandle);
	}

    return stat;
    }



static HRESULT DoTest01 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = VSS_SW_BOOTABLE_STATE;
    GUID	guidSnapshotSetId;

    ::CoCreateGuid( &guidSnapshotSetId );

    IVssAsync *pIAsync = NULL;

    wprintf (L"\n\nTest  1 - Bootable State, Synchronous\n\n");
    wprintf (L"Simulating snapshot freeze - should work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }

    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}


    return (hrStatus);
    }



static HRESULT DoTest02 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = 0;
    GUID	guidSnapshotSetId;

    ::CoCreateGuid( &guidSnapshotSetId );

    IVssAsync *pIAsync = NULL;

    wprintf (L"\n\nTest  2 - Service State, Synchronous\n\n");
    wprintf (L"Simulating snapshot freeze - should work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }


static HRESULT DoTest03()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = VSS_SW_BOOTABLE_STATE;
    GUID	guidSnapshotSetId;

    ::CoCreateGuid( &guidSnapshotSetId );

    IVssAsync *pIAsync = NULL;

    wprintf (L"\n\nTest  3 - Bootable State, Asynchronous\n\n");
    wprintf (L"Simulating snapshot freeze with Cancel - should work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        wprintf (L"Waiting 5 seconds and then calling Cancel\n" );
        Sleep( 5000 );
        wprintf (L"Cancelling\n" );
        pIAsync->Cancel();

        do {
                Sleep( 1000 );
                hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
                wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);
        } while ( !FAILED( hrStatus ) && hrStatusAsync == VSS_S_ASYNC_PENDING );

        pIAsync->Release();
        }
#if 0
    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}
#endif
    return (hrStatus);
    }



static HRESULT DoTest05 ()
    {
    HRESULT	hrStatus;
    ULONG	ulOptionFlags       = VSS_SW_BOOTABLE_STATE;
    GUID	guidSnapshotSetId;

    ::CoCreateGuid( &guidSnapshotSetId );

    IVssAsync *pIAsync = NULL;

    wprintf (L"\n\nTest  5 - Bootable State, Synchronous, no volumes\n\n");
    wprintf (L"Simulating snapshot freeze - should work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					0,
					NULL,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }



static HRESULT DoTest06 ()
    {
    HRESULT	hrStatus;
    ULONG	ulOptionFlags       = 0;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest  6 - Service State, Synchronous, no volumes\n\n");
    wprintf (L"Simulating snapshot freeze - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					0,
					NULL,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }




static HRESULT DoTest07 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = 0x40 | VSS_SW_BOOTABLE_STATE;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest  7 - Bootable State, Synchronous, Extra Options set\n\n");
    wprintf (L"Simulating snapshot freeze - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }



    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }



static HRESULT DoTest08 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = 0x40;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest  8 - Service State, Synchronous, Extra Options set\n\n");
    wprintf (L"Simulating snapshot freeze - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }


static HRESULT DoTest09 ()
    {
    HRESULT	hrStatus;
    ULONG	ulOptionFlags       = 0x0 | VSS_SW_BOOTABLE_STATE;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest  9 - Bootable State, Synchronous, No volume list\n\n");
    wprintf (L"Simulating snapshot freeze - should work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					0,
					NULL,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }


static HRESULT DoTest10 ()
    {
    HRESULT	hrStatus;
    ULONG	ulOptionFlags       = 0x0;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest 10 - Service State, Synchronous, No volume list\n\n");
    wprintf (L"Simulating snapshot freeze - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					0,
					NULL,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }


static HRESULT DoTest11 ()
    {
    HRESULT	hrStatus;
    ULONG	ulOptionFlags       = 0x0;
    GUID	guidSnapshotSetId;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId );

    wprintf (L"\n\nTest 11 - Service State, Synchronous, One volume with bad volume list pointer\n\n");
    wprintf (L"Simulating snapshot freeze - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId,
					ulOptionFlags,
					01,
					NULL,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze() returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    wprintf (L"Simulating snapshot thaw\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw() returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }


static HRESULT DoTest12 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = 0x0;
    GUID	guidSnapshotSetId1;
    GUID	guidSnapshotSetId2;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId1 );
    ::CoCreateGuid( &guidSnapshotSetId2 );

    wprintf (L"\n\nTest 12 - Service State, Synchronous, nested call\n\n");
    wprintf (L"Simulating snapshot freeze (GUID1)\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId1,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze(GUID1) returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    IVssAsync *pIAsync2 = NULL;

    wprintf (L"Simulating snapshot freeze (GUID2) - should NOT work\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId2,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync2);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze(GUID2) returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync2 != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync2->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync2->Wait();

        hrStatus = pIAsync2->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync2->Release();
        }

    wprintf (L"Simulating snapshot thaw (GUID2)\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId2);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw(GUID2) returned 0x%08X\n", hrStatus);
	}


    wprintf (L"Simulating snapshot thaw (GUID1)\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId1);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw(GUID1) returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }



static HRESULT DoTest13 ()
    {
    HRESULT	hrStatus;
    LPWSTR	pwszVolumeArray [3] = {L"C:\\", L"V:\\", L"E:\\"};
    ULONG	ulOptionFlags       = 0x0;
    GUID	guidSnapshotSetId1;
    GUID	guidSnapshotSetId2;
    IVssAsync *pIAsync = NULL;

    ::CoCreateGuid( &guidSnapshotSetId1 );
    ::CoCreateGuid( &guidSnapshotSetId2 );

    wprintf (L"\n\nTest 13 - Service State, Synchronous, nested call (reverse thaw)\n\n");
    wprintf (L"Simulating snapshot freeze (GUID1)\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId1,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze(GUID1) returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    IVssAsync *pIAsync2 = NULL;


    wprintf (L"Simulating snapshot freeze (GUID2)\n");

    hrStatus = SimulateSnapshotFreeze  (guidSnapshotSetId2,
					ulOptionFlags,
					sizeof (pwszVolumeArray) / sizeof (pwszVolumeArray [0]),
					pwszVolumeArray,
					&pIAsync2);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze(GUID2) returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync2 != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync2->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync2->Wait();

        hrStatus = pIAsync2->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync2->Release();
        }


    wprintf (L"Simulating snapshot thaw (GUID1)\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId1);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw(GUID1) returned 0x%08X\n", hrStatus);
	}


    wprintf (L"Simulating snapshot thaw (GUID2)\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId2);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw(GUID2) returned 0x%08X\n", hrStatus);
	}



    return (hrStatus);
    }




static HRESULT DoTest14 ()
    {
    HRESULT			 hrStatus              = NOERROR;
    HRESULT			 hrStatusAsync         = NOERROR;
    IVssBackupComponents	*pIVssBackupComponents = NULL;
    VSS_ID		     SnapshotId             = GUID_NULL;
    IVssAsync			*pIVssAsync            = NULL;
    GUID			 guidSnapshotSetId     = GUID_NULL;
    GUID			 guidSnapshotSetId2;

    ::CoCreateGuid( &guidSnapshotSetId2 );

    wprintf (L"\n\nTest 14 - Bootable State, Synchronous, during DoSnapshot\n\n");

    wprintf (L"Calling CreateVssBackupComponents ()\n");

    hrStatus = CreateVssBackupComponents (&pIVssBackupComponents);

    if (FAILED (hrStatus))
	{
	wprintf (L"CreateVssBackupComponents () returned 0x%08X\n", hrStatus);
	}



    wprintf (L"Calling InitializeForBackup ()\n");

    hrStatus = pIVssBackupComponents->InitializeForBackup ();

    if (FAILED (hrStatus))
	{
	wprintf (L"InitializeForBackup () returned 0x%08X\n", hrStatus);
	}





    wprintf (L"Calling SetBackupState ()\n");

    hrStatus = pIVssBackupComponents->SetBackupState (true, true, VSS_BT_FULL, false);

    if (FAILED (hrStatus))
	{
	wprintf (L"SetBackupState () returned 0x%08X\n", hrStatus);
	}



    wprintf (L"Calling GatherWriterMetadata ()\n");

    hrStatus = pIVssBackupComponents->GatherWriterMetadata (&pIVssAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"GatherWriterMetadata () returned 0x%08X\n", hrStatus);
	}


    wprintf (L"Calling Wait () (for GatherWriterMetadata() to complete)\n");

    hrStatus = pIVssAsync->Wait ();

    if (FAILED (hrStatus))
	{
	wprintf (L"Wait () returned 0x%08X\n", hrStatus);
	}




    wprintf (L"Calling StartSnapshotSet ()\n");

    hrStatus = pIVssBackupComponents->StartSnapshotSet (&guidSnapshotSetId);

    if (FAILED (hrStatus))
	{
	wprintf (L"StartSnapshotSet () returned 0x%08X\n", hrStatus);
	}




    wprintf (L"Calling AddToSnapshotSet ()\n");

    hrStatus = pIVssBackupComponents->AddToSnapshotSet (L"E:\\",
							GUID_NULL,
							&SnapshotId);

    if (FAILED (hrStatus))
	{
	wprintf (L"AddToSnapshotSet () returned 0x%08X\n", hrStatus);
	}




    wprintf (L"Calling PrepareForBackup ()\n");

    hrStatus = pIVssBackupComponents->PrepareForBackup (&pIVssAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"PrepareForBackup () returned 0x%08X\n", hrStatus);
	}




    wprintf (L"Calling Wait () (for PrepareForBackup() to complete)\n");

    hrStatus = pIVssAsync->Wait ();

    if (FAILED (hrStatus))
	{
	wprintf (L"Wait () returned 0x%08X\n", hrStatus);
	}




    wprintf (L"Calling QueryStatus ()\n");

    hrStatus = pIVssAsync->QueryStatus (&hrStatusAsync, 0);

    if (FAILED (hrStatus))
	{
	wprintf (L"QueryStatus () returned 0x%08X\n", hrStatus);
	}




    wprintf (L"Calling DoSnapshotSet ()\n");

    hrStatus = pIVssBackupComponents->DoSnapshotSet (&pIVssAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"DoSnapshotSet () returned 0x%08X\n", hrStatus);
	}



    wprintf (L"Calling SimulateSnapshotFreeze () - should NOT work\n");

    IVssAsync *pIAsync = NULL;

    hrStatus = SimulateSnapshotFreeze (guidSnapshotSetId2,
				       VSS_SW_BOOTABLE_STATE,
				       0,
				       NULL,
  				       &pIAsync);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotFreeze () returned 0x%08X\n", hrStatus);
	}

    if ( pIAsync != NULL )
        {
        HRESULT hrStatusAsync;
        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Wait();

        hrStatus = pIAsync->QueryStatus( &hrStatusAsync, 0 );
        wprintf (L"QueryStatus () returned: 0x%08X, hrStatusAsync: 0x%08x\n", hrStatus, hrStatusAsync);

        pIAsync->Release();
        }


    wprintf (L"Calling SimulateSnapshotThaw ()\n");

    hrStatus = SimulateSnapshotThaw (guidSnapshotSetId2);

    if (FAILED (hrStatus))
	{
	wprintf (L"SimulateSnapshotThaw () returned 0x%08X\n", hrStatus);
	}


    wprintf (L"Calling Wait () (for DoSnapshotSet () to complete) ()\n");

    hrStatus = pIVssAsync->Wait();

    if (FAILED (hrStatus))
	{
	wprintf (L"Wait () returned 0x%08X\n", hrStatus);
	}

    pIVssAsync->Release();
    pIVssBackupComponents->Release();

    return (hrStatus);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\hosting.h ===
#if !defined(AFX_HOSTING_H__0B0CBFCC_5235_439E_9482_385B52D23C6E__INCLUDED_)
#define AFX_HOSTING_H__0B0CBFCC_5235_439E_9482_385B52D23C6E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Hosting.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CHosting dialog

class CHosting : public CDialog
{
// Construction
public:
	CHosting(CWnd* pParent = NULL);   // standard constructor
	CHosting(LPCTSTR pszComputer, LPCTSTR pszVolume, CWnd* pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CHosting)
	enum { IDD = IDD_HOSTING };
	CEdit	m_ctrlFreeSpace;
	CEdit	m_ctrlTotalSpace;
	CListCtrl	m_ctrlVolumeList;
	CString	m_strVolume;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHosting)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
    HRESULT Init(
        IVssDifferentialSoftwareSnapshotMgmt* i_piDiffSnapMgmt,
        VSSUI_VOLUME_LIST*  i_pVolumeList,
        IN LPCTSTR          i_pszVolumeDisplayName,
        IN LONGLONG         i_llDiffVolumeTotalSpace,
        IN LONGLONG         i_llDiffVolumeFreeSpace
        );

protected:
	CString	    m_strComputer;
    LONGLONG    m_llDiffVolumeTotalSpace;
    LONGLONG    m_llDiffVolumeFreeSpace;
    VSSUI_DIFFAREA_LIST m_DiffAreaList;

	// Generated message map functions
	//{{AFX_MSG(CHosting)
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HOSTING_H__0B0CBFCC_5235_439E_9482_385B52D23C6E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\remdlg.cpp ===
// RemDlg.cpp : implementation file
//

#include "stdafx.h"
#include "RemDlg.h"
#include "uihelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CReminderDlg dialog


CReminderDlg::CReminderDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CReminderDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CReminderDlg)
	m_strMessage = _T("");
	m_bMsgOnOff = FALSE;
	//}}AFX_DATA_INIT
    m_hKey = NULL;
    m_strRegValueName = _T("");
}

CReminderDlg::CReminderDlg(LPCTSTR pszMessage, HKEY hKey, LPCTSTR pszRegValueName, CWnd* pParent /*=NULL*/)
	: CDialog(CReminderDlg::IDD, pParent)
{
	m_strMessage = pszMessage;
	m_bMsgOnOff = FALSE;
    m_hKey = hKey;
    m_strRegValueName = pszRegValueName;
}

void CReminderDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CReminderDlg)
	DDX_Text(pDX, IDC_MESSAGE, m_strMessage);
	DDX_Check(pDX, IDC_MSG_ONOFF, m_bMsgOnOff);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CReminderDlg, CDialog)
	//{{AFX_MSG_MAP(CReminderDlg)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CReminderDlg message handlers

void CReminderDlg::OnOK() 
{
	// TODO: Add extra validation here
	UpdateData(TRUE);

    if (m_bMsgOnOff && m_hKey && !m_strRegValueName.IsEmpty())
    {
        DWORD dwData = 1;
        (void)RegSetValueEx(m_hKey, m_strRegValueName, 0, REG_DWORD, (const BYTE *)&dwData, sizeof(DWORD));
    }

	CDialog::OnOK();
}

BOOL CReminderDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (!pHelpInfo || 
        pHelpInfo->iContextType != HELPINFO_WINDOW || 
        pHelpInfo->iCtrlId < 0)
        return FALSE;

    ::WinHelp((HWND)pHelpInfo->hItemHandle,
                VSSUI_CTX_HELP_FILE,
                HELP_WM_HELP,
                (DWORD_PTR)(PVOID)aMenuHelpIDsForReminder); 

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\remdlg.h ===
#if !defined(AFX_REMDLG_H__3FB35059_815F_45FC_B12D_E6B2F31204C1__INCLUDED_)
#define AFX_REMDLG_H__3FB35059_815F_45FC_B12D_E6B2F31204C1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RemDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CReminderDlg dialog

class CReminderDlg : public CDialog
{
// Construction
public:
	CReminderDlg(CWnd* pParent = NULL);   // standard constructor
	CReminderDlg(LPCTSTR pszMessage, HKEY hKey, LPCTSTR pszRegValueName, CWnd* pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CReminderDlg)
	enum { IDD = IDD_REMINDER };
	CString	m_strMessage;
	BOOL	m_bMsgOnOff;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CReminderDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    HKEY    m_hKey;
    CString m_strRegValueName;

	// Generated message map functions
	//{{AFX_MSG(CReminderDlg)
	virtual void OnOK();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REMDLG_H__3FB35059_815F_45FC_B12D_E6B2F31204C1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vssui.rc
//
#define IDS_PROJNAME                    100
#define IDS_MENU_NAME                   101
#define IDS_MENU_STATUSBARTEXT          102
#define IDR_VSSUI                       104
#define IDR_VSSSHELLEXT                 105
#define IDS_VOLUMELIST_COLUMN_VOLUME    121
#define IDS_VOLUMELIST_COLUMN_STATUS    122
#define IDS_VOLUMELIST_COLUMN_NUMOFSHARES 123
#define IDS_VOLUMELIST_COLUMN_USED      124
#define IDS_VOLUMELIST_COLUMN_NEXTRUNTIME 125
#define IDS_SNAPSHOTLIST_COLUMN_TIMESTAMP 130
#define IDS_HOSTINGLIST_COLUMN_VOLUME   135
#define IDS_HOSTINGLIST_COLUMN_DIFFLIMITS 136
#define IDS_HOSTINGLIST_COLUMN_DIFFCONSUMPTION 137
#define IDS_DATE_TIME                   140
#define IDS_USED_ON_VOLUME              141
#define IDS_VOLUME_LABEL                142
#define IDS_SPACE_LABEL_B               143
#define IDS_SPACE_LABEL_KB              144
#define IDS_SPACE_LABEL_MB              145
#define IDS_SPACE_LABEL_GB              146
#define IDS_ENABLE_REMINDER             147
#define IDS_DISABLE_REMINDER            148
#define IDS_ERROR                       150
#define IDS_ERROR_HR                    151
#define IDS_VSSPROP_INIT_ERROR          152
#define IDS_VSSPROP_GETVOLUMES_ERROR    153
#define IDS_VSSPROP_EMPTY_VOLUMELIST    154
#define IDS_VSSPROP_VOLUME_ILEGIBLE     155
#define IDS_TAKESNAPSHOT_ERROR          156
#define IDS_DELETESNAPSHOTS_ERROR       157
#define IDS_FINDSCHEDULE_ERROR          158
#define IDS_CREATESCHEDULE_ERROR        159
#define IDS_DELETEDIFFAREA_ERROR        160
#define IDS_SETTINGS_ERROR              161
#define IDS_CHANGEDIFFAREAMAX_ERROR     162
#define IDS_ADDDIFFAREA_ERROR           163
#define IDS_VIEWFILES_ERROR             164
#define IDS_SCHEDULEPAGE_ERROR          165

#define IDD_VSSPROP                     1000
#define IDC_EXPLANATION                 1001
#define IDC_VOLUME_LIST_LABLE           1002
#define IDC_VOLUME_LIST                 1003
#define IDC_ENABLE_TEXT                 1004
#define IDC_ENABLE                      1005
#define IDC_DISABLE_TEXT                1006
#define IDC_DISABLE                     1007
#define IDC_SETTINGS_TEXT               1008
#define IDC_SETTINGS                    1009
#define IDC_SNAPSHOT_LIST_LABLE         1010 
#define IDC_SNAPSHOT_LIST               1011
#define IDC_CREATE                      1012
#define IDC_DELETE                      1013
#define IDC_VSSPROP_ERROR               1014

#define IDD_SETTINGS                    1020
#define IDC_SETTINGS_VOLUME             1021
#define IDC_SETTINGS_STORAGE_VOLUME     1022
#define IDC_SETTINGS_DIFFLIMITS_SLIDER  1023
#define IDC_SETTINGS_DIFFLIMITS_EDIT    1024
#define IDC_SETTINGS_DIFFLIMITS_SPIN    1025
#define IDC_SETTINGS_HOSTING_LABEL      1026
#define IDC_SETTINGS_HOSTING            1027
#define IDD_HOSTING                     1040
#define IDC_HOSTING_VOLUME              1041
#define IDC_HOSTING_TOTAL_DISKSPACE     1042
#define IDC_HOSTING_FREE_DISKSPACE      1043
#define IDC_HOSTING_VOLUMELIST          1044
#define IDC_HOSTING_TOTAL_DIFFLIMITS    1045
#define IDC_HOSTING_TOTAL_DIFFUSE       1046
#define IDD_REMINDER                    1050
#define IDC_MSG_ONOFF                   1051
#define IDC_MESSAGE                     1052
#define IDC_SCHEDULE                    1053
#define ID_CONFIG_SNAPSHOT              32768

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32769
#define _APS_NEXT_CONTROL_VALUE         1060
#define _APS_NEXT_SYMED_VALUE           156
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\settings.h ===
#if !defined(AFX_HOSTED_H__46C0FDC0_6E97_40CF_807A_91051E61BB1F__INCLUDED_)
#define AFX_HOSTED_H__46C0FDC0_6E97_40CF_807A_91051E61BB1F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Settings.h : header file
//

#include "vssprop.h" // VSSUI_VOLUME_LIST

/////////////////////////////////////////////////////////////////////////////
// CSettings dialog

class CSettings : public CDialog
{
// Construction
public:
	CSettings(CWnd* pParent = NULL);   // standard constructor
	CSettings(LPCTSTR pszComputer, LPCTSTR pszVolume, CWnd* pParent = NULL);
    ~CSettings();

// Dialog Data
	//{{AFX_DATA(CSettings)
	enum { IDD = IDD_SETTINGS };
	CEdit	m_ctrlDiffLimits;
	CSpinButtonCtrl	m_ctrlSpin;
	CComboBox	m_ctrlStorageVolume;
	CString	m_strVolume;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSettings)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
    void _ResetInterfacePointers();
    HRESULT Init(
        IVssDifferentialSoftwareSnapshotMgmt *piDiffSnapMgmt,
        IN ITaskScheduler*      piTS,
        IN VSSUI_VOLUME_LIST*   pVolumeList,
        IN BOOL                 bReadOnlyDiffVolume
    );

protected:
    CString             m_strComputer;
    CComPtr<IVssDifferentialSoftwareSnapshotMgmt> m_spiDiffSnapMgmt;
    CComPtr<ITaskScheduler> m_spiTS;

    VSSUI_VOLUME_LIST*  m_pVolumeList;
    CString             m_strDiffVolumeDisplayName;
    LONGLONG            m_llMaximumDiffSpace;
	LONGLONG	        m_llDiffLimitsInMB;
    BOOL                m_bHasDiffAreaAssociation;
    BOOL                m_bReadOnlyDiffVolume;
    LONGLONG            m_llDiffVolumeTotalSpace;
    LONGLONG            m_llDiffVolumeFreeSpace;
    PTSTR               m_pszTaskName;

	// Generated message map functions
	//{{AFX_MSG(CSettings)
	virtual void OnOK();
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	afx_msg void OnViewFiles();
	afx_msg void OnSchedule();
	afx_msg void OnSelchangeDiffVolume();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HOSTED_H__46C0FDC0_6E97_40CF_807A_91051E61BB1F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\shlext.h ===
// ShlExt.h : Declaration of the CVSSShellExt

#ifndef __VSSSHELLEXT_H_
#define __VSSSHELLEXT_H_

#include "resource.h"       // main symbols
#include <shlobj.h>

/////////////////////////////////////////////////////////////////////////////
// CVSSShellExt
class ATL_NO_VTABLE CVSSShellExt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CVSSShellExt, &CLSID_VSSShellExt>,
	public IShellExtInit,
    public IShellPropSheetExt
{
public:
	CVSSShellExt();

	~CVSSShellExt();

DECLARE_REGISTRY_RESOURCEID(IDR_VSSSHELLEXT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CVSSShellExt)
	COM_INTERFACE_ENTRY(IShellExtInit)
	COM_INTERFACE_ENTRY(IShellPropSheetExt)
END_COM_MAP()

// IVSSShellExt

public:
    // IShellExtInit Methods
    STDMETHOD(Initialize)
    (
            IN LPCITEMIDLIST        pidlFolder,
            IN LPDATAOBJECT         lpdobj,
            IN HKEY                 hkeyProgID
    );

    //IShellPropSheetExt methods
    STDMETHOD(AddPages)
        (
                IN LPFNADDPROPSHEETPAGE lpfnAddPage,
                IN LPARAM lParam
        );
    
    STDMETHOD(ReplacePage)
    (
            IN UINT uPageID,
            IN LPFNADDPROPSHEETPAGE lpfnReplaceWith,
            IN LPARAM lParam
    );

private:
    TCHAR                   m_szFileName[MAX_PATH];
    CComPtr<IDataObject>    m_spiDataObject;
};

#endif //__VSSSHELLEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\shlext.cpp ===
// ShlExt.cpp : Implementation of CVSSShellExt
#include "stdafx.h"
#include "Vssui.h"
#include "ShlExt.h"
#include "vssprop.h"

#include <shellapi.h>

/////////////////////////////////////////////////////////////////////////////
// CVSSShellExt

CVSSShellExt::CVSSShellExt()
{
#ifdef DEBUG
    OutputDebugString(_T("CVSSShellExt::CVSSShellExt\n"));
#endif
}

CVSSShellExt::~CVSSShellExt()
{
#ifdef DEBUG
    OutputDebugString(_T("CVSSShellExt::~CVSSShellExt\n"));
#endif
}

STDMETHODIMP CVSSShellExt::Initialize(
    IN LPCITEMIDLIST        pidlFolder, // For property sheet extensions, this parameter is NULL
    IN LPDATAOBJECT         lpdobj,
    IN HKEY                 hkeyProgID  // not used in property sheet extensions
)
{
    HRESULT hr = S_OK;

    if ((IDataObject *)m_spiDataObject)
        m_spiDataObject.Release();

    if (lpdobj)
    {
        m_spiDataObject = lpdobj;

        STGMEDIUM   medium;
        FORMATETC   fe = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        UINT        uCount = 0;

        hr = m_spiDataObject->GetData(&fe, &medium);
        if (FAILED(hr))
        {
            fe.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_MOUNTEDVOLUME);
            hr = m_spiDataObject->GetData(&fe, &medium);
        }

        if (SUCCEEDED(hr))
        {
            uCount = DragQueryFile((HDROP)medium.hGlobal, (UINT)-1, NULL, 0);
            if (uCount)
                DragQueryFile((HDROP)medium.hGlobal, 0, m_szFileName, sizeof(m_szFileName));

            ReleaseStgMedium(&medium);
        }
    }

    return hr;
}

LPFNPSPCALLBACK _OldPropertyPageCallback;

UINT CALLBACK _NewPropertyPageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    ASSERT(_OldPropertyPageCallback);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // First, let the old callback function handles the msg.
    //
    UINT i = _OldPropertyPageCallback(hwnd, uMsg, ppsp);

    //
    // Then, we release our page here
    //
    if (uMsg == PSPCB_RELEASE)
    {
        ASSERT(ppsp);
        CVSSProp* pPage = (CVSSProp*)(ppsp->lParam);
        ASSERT(pPage);
        delete pPage;
    }

    return i;
}


void ReplacePropertyPageCallback(void* vpsp)
{
    ASSERT(vpsp);
    LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE)vpsp;
    _OldPropertyPageCallback = ppsp->pfnCallback; // save the old callback function
    ppsp->pfnCallback = _NewPropertyPageCallback; // replace with our own callback
}

//
// From RaymondC:
// If you didn't add a page, you still return S_OK -- you successfully added zero pages.
// If you add some pages and then you want one of those added pages to be the default, 
// you return ResultFromShort(pagenumber+1).  S_FALSE = ResultFromShort(1).
//
STDMETHODIMP CVSSShellExt::AddPages(
    IN LPFNADDPROPSHEETPAGE lpfnAddPage,
    IN LPARAM lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // we only add our page if local machine is postW2K server
    //
    if (!IsPostW2KServer(NULL))
        return S_OK;

    //
    // we only add our page for local fixed non-FAT drive
    //
    if (DRIVE_FIXED != GetDriveType(m_szFileName))
        return S_OK;

    TCHAR  szFileSystemName[MAX_PATH + 1] = _T("");
    DWORD  dwMaxCompLength = 0, dwFileSystemFlags = 0;
    GetVolumeInformation(m_szFileName, NULL, 0, NULL, &dwMaxCompLength,
                         &dwFileSystemFlags, szFileSystemName, MAX_PATH);
    if (lstrcmpi(_T("NTFS"), szFileSystemName))
      return S_OK;

    CVSSProp *pPage = new CVSSProp(_T(""), m_szFileName);
    if (!pPage)
        return E_OUTOFMEMORY;

    if (pPage->m_psp.dwFlags & PSP_USECALLBACK)
    {
        //
        // Replace with our own callback function such that we can delete pPage
        // when the property sheet is closed.
        //
        // Note: don't change m_psp.lParam, which has to point to CVSSProp object;
        // otherwise, MFC won't hook up message handler correctly.
        //
        ReplacePropertyPageCallback(&(pPage->m_psp));

        //
        // Fusion MFC-based property page
        //
        PROPSHEETPAGE_V3 sp_v3 = {0};
        CopyMemory (&sp_v3, &(pPage->m_psp), (pPage->m_psp).dwSize);
        sp_v3.dwSize = sizeof(sp_v3);

        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&sp_v3);
        if (hPage)
        {
            if (lpfnAddPage(hPage, lParam))
            {
                // Store this pointer in pPage in order to keep our dll loaded,
                // it will be released when pPage gets deleted.
                pPage->StoreShellExtPointer((IShellPropSheetExt *)this);
                return S_OK;
            }

            DestroyPropertySheetPage(hPage);
            hPage = NULL;
        }
    }

    delete pPage;

    return S_OK;
}

//
// The shell doesn't call ReplacePage
//
STDMETHODIMP CVSSShellExt::ReplacePage(
    IN UINT uPageID,
    IN LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    IN LPARAM lParam
)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\snapext.cpp ===
#include "stdafx.h"
#include "Vssui.h"
#include "snapext.h"
#include "VSSProp.h"

/////////////////////////////////////////////////////////////////////////////
// CVSSUIComponentData

static const GUID CVSSUIExtGUID1_NODETYPE = 
{ 0x4e410f0e, 0xabc1, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
const GUID*  CVSSUIExtData1::m_NODETYPE = &CVSSUIExtGUID1_NODETYPE;
const OLECHAR* CVSSUIExtData1::m_SZNODETYPE = OLESTR("4e410f0e-abc1-11d0-b944-00c04fd8d5b0");
const OLECHAR* CVSSUIExtData1::m_SZDISPLAY_NAME = OLESTR("");
const CLSID* CVSSUIExtData1::m_SNAPIN_CLASSID = &CLSID_VSSUI;

static const GUID CVSSUIExtGUID2_NODETYPE = 
{ 0x312B59C1, 0x4002, 0x11d0, { 0x96, 0xF8, 0x0, 0xA0, 0xC9, 0x19, 0x16, 0x01 } };
const GUID*  CVSSUIExtData2::m_NODETYPE = &CVSSUIExtGUID2_NODETYPE;
const OLECHAR* CVSSUIExtData2::m_SZNODETYPE = OLESTR("312B59C1-4002-11d0-96F8-00A0C9191601");
const OLECHAR* CVSSUIExtData2::m_SZDISPLAY_NAME = OLESTR("");
const CLSID* CVSSUIExtData2::m_SNAPIN_CLASSID = &CLSID_VSSUI;

CVSSUI::CVSSUI()
{
#ifdef DEBUG
    OutputDebugString(_T("CVSSUI::CVSSUI\n"));
#endif
    m_pComponentData = this;
    m_pPage = NULL;
}

CVSSUI::~CVSSUI()
{
#ifdef DEBUG
    OutputDebugString(_T("CVSSUI::~CVSSUI\n"));
#endif
    if (m_pPage)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        delete m_pPage;
        m_pPage = NULL;
    }
}
///////////////////////////////
// Interface IExtendContextMenu
///////////////////////////////

CLIPFORMAT g_cfMachineName = (CLIPFORMAT)RegisterClipboardFormat(_T("MMC_SNAPIN_MACHINE_NAME"));

HRESULT CVSSUI::AddMenuItems(
    LPDATAOBJECT piDataObject,
    LPCONTEXTMENUCALLBACK piCallback,
    long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // we add the context menu item only when targeted machine belongs to postW2K server SKUs
    //
    TCHAR szMachineName[MAX_PATH] = {0};
    HRESULT hr = ExtractData(piDataObject, g_cfMachineName, (PBYTE)szMachineName, MAX_PATH);
    if (FAILED(hr))
        return hr;

    if (IsPostW2KServer(szMachineName))
    {
        CString strMenuName;
        strMenuName.LoadString(IDS_MENU_NAME);
        CString strStatusBarText;
        strStatusBarText.LoadString(IDS_MENU_STATUSBARTEXT);

        CONTEXTMENUITEM    ContextMenuItem;
        ZeroMemory(&ContextMenuItem, sizeof(CONTEXTMENUITEM));
        ContextMenuItem.strName = (LPTSTR)(LPCTSTR)strMenuName;
        ContextMenuItem.strStatusBarText = (LPTSTR)(LPCTSTR)strStatusBarText;
        ContextMenuItem.lCommandID = ID_CONFIG_SNAPSHOT;
        ContextMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;

        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
            hr = piCallback->AddItem(&ContextMenuItem);
    }

    return hr;
}

HRESULT CVSSUI::Command(
    IN long lCommandID,
    IN LPDATAOBJECT piDataObject)
{
    switch (lCommandID)
    {
    case ID_CONFIG_SNAPSHOT:
        {
            InvokePropSheet(piDataObject);
        }
        break;
    }

    return S_OK;
}

HRESULT ExtractData(
    IDataObject* piDataObject,
    CLIPFORMAT   cfClipFormat,
    BYTE*        pbData,
    DWORD        cbData )
{
    HRESULT hr = S_OK;
    
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL, NULL};
    
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            break;
        }
        
        BYTE* pbNewData = reinterpret_cast<BYTE*>(stgmedium.hGlobal);
        if (NULL == pbNewData)
        {
            hr = E_UNEXPECTED;
            break;
        }

        ::memcpy( pbData, pbNewData, cbData );

    } while (FALSE); // false loop
    
    if (stgmedium.hGlobal)
        ::GlobalFree(stgmedium.hGlobal);

    return hr;
}

//
// This function invokes a modal property sheet.
//
void ReplacePropertyPageCallback(void* vpsp);  // implemented in shlext.cpp
HRESULT CVSSUI::InvokePropSheet(LPDATAOBJECT piDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWaitCursor wait;

    TCHAR szMachineName[MAX_PATH] = {0};
    HRESULT hr = ExtractData(piDataObject, g_cfMachineName, (PBYTE)szMachineName, MAX_PATH);
    if (FAILED(hr))
        return hr;

    CString strTitle;
    strTitle.LoadString(IDS_PROJNAME);

    CVSSProp *pPage = new CVSSProp(szMachineName, NULL);
    if (!pPage)
        return E_OUTOFMEMORY;

    if (pPage->m_psp.dwFlags & PSP_USECALLBACK)
    {
        //
        // Replace with our own callback function such that we can delete pPage
        // when the property sheet is closed.
        //
        // Note: don't change m_psp.lParam, which has to point to CVSSProp object;
        // otherwise, MFC won't hook up message handler correctly.
        //
        ReplacePropertyPageCallback(&(pPage->m_psp));
    }

    PROPSHEETHEADER psh;
    ZeroMemory(&psh, sizeof(psh));
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW ;
    psh.hwndParent = ::GetActiveWindow();
    psh.hInstance = _Module.GetResourceInstance();
    psh.pszCaption = strTitle;
    psh.nPages = 1;
    psh.nStartPage = 0;
    psh.ppsp = (LPCPROPSHEETPAGE)&(pPage->m_psp);
    psh.pfnCallback = NULL;

    PropertySheet(&psh); // this will do a modal proerty sheet

    return S_OK;
}

/*
//
// This function invokes a modaless property sheet.
//
HRESULT CVSSUI::InvokePropSheet(LPDATAOBJECT piDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWaitCursor wait;

    //
    // CoCreate an instance of the MMC Node Manager to obtain
    // an IPropertySheetProvider interface pointer
    //
    
    CComPtr<IPropertySheetProvider> spiPropertySheetProvider;
    HRESULT hr = CoCreateInstance(CLSID_NodeManager, NULL, 
                                CLSCTX_INPROC_SERVER, 
                                IID_IPropertySheetProvider, 
                                (void **)&spiPropertySheetProvider);
    if (FAILED(hr))
        return hr;
    
    //
    // Create the property sheet
    //
    CString strTitle;
    strTitle.LoadString(IDS_PROJNAME);
    hr = spiPropertySheetProvider->CreatePropertySheet(
                    strTitle, // pointer to the property page title
                    TRUE,           // property sheet
                    NULL,           // cookie of current object - can be NULL for extension snap-ins
                    piDataObject,   // data object of selected node
                    NULL            // specifies flags set by the method call
                    );
 
    if (FAILED(hr))
        return hr;
     
    //
    // Call AddPrimaryPages. MMC will then call the
    // IExtendPropertySheet methods of our property sheet extension object
    //
    hr = spiPropertySheetProvider->AddPrimaryPages(
                    reinterpret_cast<IUnknown *>(this), // pointer to our object's IUnknown
                    FALSE, // specifies whether to create a notification handle
                    NULL,  // must be NULL
                    TRUE   // scope pane; FALSE for result pane
                    );
 
    if (FAILED(hr))
        return hr;
 
    //
    // Allow property page extensions to add
    // their own pages to the property sheet
    //
    hr = spiPropertySheetProvider->AddExtensionPages();
    
    if (FAILED(hr))
        return hr;
 
    //
    //Display property sheet
    //
    hr = spiPropertySheetProvider->Show((LONG_PTR)::GetActiveWindow(),0);
//    hr = spiPropertySheetProvider->Show(NULL,0); //NULL is allowed for modeless prop sheet
    
    return hr;
}

HRESULT CVSSUI::CreatePropertyPages( 
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle,
    LPDATAOBJECT piDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TCHAR szMachineName[MAX_PATH] = {0};
    HRESULT hr = ExtractData(piDataObject, g_cfMachineName, (PBYTE)szMachineName, MAX_PATH);
    if (FAILED(hr))
        return hr;

    m_pPage = new CVSSProp(szMachineName, NULL);
    if (m_pPage)
    {
        CPropertyPage* pBasePage = m_pPage;
        MMCPropPageCallback(&(pBasePage->m_psp));
        HPROPSHEETPAGE hPage = CreatePropertySheetPage(&(pBasePage->m_psp));

        if (hPage)
        {
            hr = lpProvider->AddPage(hPage);
            if (FAILED(hr))
                DestroyPropertySheetPage(hPage);
        } else
            hr = E_FAIL;

        if (FAILED(hr))
        {
            delete m_pPage;
            m_pPage = NULL;
        }
    } else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\settings.cpp ===
// Settings.cpp : implementation file
//

#include "stdafx.h"
#include "utils.h"
#include "Settings.h"
#include "Hosting.h"
#include "uihelp.h"
#include <mstask.h>
#include <vsmgmt.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSettings dialog


CSettings::CSettings(CWnd* pParent /*=NULL*/)
	: CDialog(CSettings::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSettings)
	m_strVolume = _T("");
	m_llDiffLimitsInMB = 0;
	//}}AFX_DATA_INIT
    m_strComputer = _T("");
    m_pszTaskName = NULL;
}

CSettings::CSettings(LPCTSTR pszComputer, LPCTSTR pszVolume, CWnd* pParent /*=NULL*/)
	: CDialog(CSettings::IDD, pParent)
{
	m_llDiffLimitsInMB = 0;
    m_strComputer = pszComputer + (TWO_WHACKS(pszComputer) ? 2 : 0);
    m_strVolume = pszVolume;
    m_pszTaskName = NULL;
}

CSettings::~CSettings()
{
    if (m_pszTaskName)
        free(m_pszTaskName);
}

void CSettings::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSettings)
	DDX_Control(pDX, IDC_SETTINGS_DIFFLIMITS_EDIT, m_ctrlDiffLimits);
	DDX_Control(pDX, IDC_SETTINGS_DIFFLIMITS_SPIN, m_ctrlSpin);
	DDX_Control(pDX, IDC_SETTINGS_STORAGE_VOLUME, m_ctrlStorageVolume);
	DDX_Text(pDX, IDC_SETTINGS_VOLUME, m_strVolume);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSettings, CDialog)
	//{{AFX_MSG_MAP(CSettings)
	ON_BN_CLICKED(IDC_SETTINGS_HOSTING, OnViewFiles)
	ON_BN_CLICKED(IDC_SCHEDULE, OnSchedule)
	ON_CBN_SELCHANGE(IDC_SETTINGS_STORAGE_VOLUME, OnSelchangeDiffVolume)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSettings message handlers

void CSettings::OnOK() 
{
    CWaitCursor wait;

    UpdateData(TRUE);

    PTSTR pszVolumeName = GetVolumeName(m_pVolumeList, m_strVolume);
    ASSERT(pszVolumeName);
    PTSTR pszDiffAreaVolumeName = GetVolumeName(m_pVolumeList, m_strDiffVolumeDisplayName);
    ASSERT(pszDiffAreaVolumeName);

    CString strDiffVolumeDisplayName;
    m_ctrlStorageVolume.GetWindowText(strDiffVolumeDisplayName);

    PTSTR pszNewDiffAreaVolumeName = GetVolumeName(m_pVolumeList, strDiffVolumeDisplayName);
    ASSERT(pszNewDiffAreaVolumeName);

    CString strDiffLimits;
    m_ctrlDiffLimits.GetWindowText(strDiffLimits);
    LONGLONG llDiffLimitsInMB = (LONGLONG)_ttoi64(strDiffLimits);
    LONGLONG llMaximumDiffSpace = llDiffLimitsInMB * g_llMB;

    HRESULT hr = S_OK;
    if (m_bReadOnlyDiffVolume ||
        m_bHasDiffAreaAssociation && !strDiffVolumeDisplayName.CompareNoCase(m_strDiffVolumeDisplayName))
    {
        if (llDiffLimitsInMB != m_llDiffLimitsInMB)
        {
            hr = m_spiDiffSnapMgmt->ChangeDiffAreaMaximumSize(
                                        pszVolumeName, 
                                        pszDiffAreaVolumeName, 
                                        llMaximumDiffSpace);
            if (SUCCEEDED(hr))
            {
                m_llDiffLimitsInMB = llDiffLimitsInMB;
                m_llMaximumDiffSpace = llMaximumDiffSpace;
            } else
            {
                DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_CHANGEDIFFAREAMAX_ERROR);
                return;
            }
        }
    } else
    {
        if (m_bHasDiffAreaAssociation)
        {
            //
            // Diff Volume has been changed to a different value, we need to
            // remove the old association and create a new one
            //
            hr = m_spiDiffSnapMgmt->ChangeDiffAreaMaximumSize(
                                            pszVolumeName, 
                                            pszDiffAreaVolumeName, 
                                            VSS_ASSOC_REMOVE);
        }

        if (SUCCEEDED(hr))
            hr = m_spiDiffSnapMgmt->AddDiffArea(
                                        pszVolumeName, 
                                        pszNewDiffAreaVolumeName, 
                                        llMaximumDiffSpace);
        if (SUCCEEDED(hr))
        {
            m_llDiffLimitsInMB = llDiffLimitsInMB;
            m_llMaximumDiffSpace = llMaximumDiffSpace;
            m_strDiffVolumeDisplayName = strDiffVolumeDisplayName;
        } else
        {
            DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_ADDDIFFAREA_ERROR);
            return;
        }
    }

	CDialog::OnOK();
}

void CSettings::OnCancel() 
{
    CWaitCursor wait;

    //
    // before exit, we want to delete the schedule we have created
    //
    if (m_pszTaskName)
    {
        m_spiTS->Delete(m_pszTaskName);
    }
	
	CDialog::OnCancel();
}

void CSettings::_ResetInterfacePointers()
{
    if ((IVssDifferentialSoftwareSnapshotMgmt *)m_spiDiffSnapMgmt)
        m_spiDiffSnapMgmt.Release();

    if ((ITaskScheduler *)m_spiTS)
        m_spiTS.Release();
}

HRESULT CSettings::Init(
    IVssDifferentialSoftwareSnapshotMgmt *piDiffSnapMgmt,
    ITaskScheduler*         piTS,
    IN VSSUI_VOLUME_LIST*   pVolumeList,
    IN BOOL                 bReadOnlyDiffVolume
    )
{
    if (!piDiffSnapMgmt || !piTS ||
        !pVolumeList || pVolumeList->empty())
        return E_INVALIDARG;

    _ResetInterfacePointers();

    m_pVolumeList = pVolumeList;
    m_bReadOnlyDiffVolume = bReadOnlyDiffVolume;
    m_spiDiffSnapMgmt = piDiffSnapMgmt;
    m_spiTS = piTS;

    HRESULT hr = S_OK;
    do
    {
        VSSUI_DIFFAREA diffArea;
        hr = GetDiffAreaInfo(m_spiDiffSnapMgmt, m_pVolumeList, m_strVolume, &diffArea);
        if (FAILED(hr))
            break;

        m_bHasDiffAreaAssociation = (S_OK == hr);

        if (S_FALSE == hr)
        {
            hr = GetVolumeSpace(
                                m_spiDiffSnapMgmt,
                                m_strVolume,
                                &m_llDiffVolumeTotalSpace,
                                &m_llDiffVolumeFreeSpace);
            if (FAILED(hr))
                break;

            m_strDiffVolumeDisplayName = m_strVolume;
            m_llMaximumDiffSpace = m_llDiffVolumeTotalSpace * 0.1; // 10%
        } else
        {
            m_strDiffVolumeDisplayName = diffArea.pszDiffVolumeDisplayName;
            m_llMaximumDiffSpace = diffArea.llMaximumDiffSpace;

            hr = GetVolumeSpace(
                                m_spiDiffSnapMgmt,
                                m_strDiffVolumeDisplayName,
                                &m_llDiffVolumeTotalSpace,
                                &m_llDiffVolumeFreeSpace);
            if (FAILED(hr))
                break;
        }

        m_llDiffLimitsInMB = m_llMaximumDiffSpace / g_llMB;
    } while(0);

    if (FAILED(hr))
        _ResetInterfacePointers();

    return hr;
}

#define LONGLONG_TEXTLIMIT          20  // 20 decimal digits for the biggest LONGLONG

BOOL CSettings::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    // init diff volume combo box
    int nIndex = CB_ERR;
    for (VSSUI_VOLUME_LIST::iterator i = m_pVolumeList->begin(); i != m_pVolumeList->end(); i++)
    {
        nIndex = m_ctrlStorageVolume.AddString((*i)->pszDisplayName);
        if (CB_ERR != nIndex && !m_strDiffVolumeDisplayName.CompareNoCase((*i)->pszDisplayName))
        {
            m_ctrlStorageVolume.SetCurSel(nIndex);
        }
    }

    m_ctrlStorageVolume.EnableWindow(!m_bReadOnlyDiffVolume);

    m_ctrlDiffLimits.SetLimitText(LONGLONG_TEXTLIMIT);

    CString strDiffLimitsInMB;
    strDiffLimitsInMB.Format(_T("%I64d"), m_llDiffLimitsInMB);
    m_ctrlDiffLimits.SetWindowText(strDiffLimitsInMB);

    m_ctrlSpin.SendMessage(UDM_SETRANGE32, 0, min(0x7FFFFFFF, m_llDiffVolumeTotalSpace / g_llMB));

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSettings::OnViewFiles() 
{
    CWaitCursor wait;

    CString strStorageVolume;
    m_ctrlStorageVolume.GetWindowText(strStorageVolume);

    CHosting dlg(m_strComputer, strStorageVolume);
    HRESULT hr = dlg.Init(m_spiDiffSnapMgmt,
                        m_pVolumeList,
                        m_strDiffVolumeDisplayName,
                        m_llDiffVolumeTotalSpace,
                        m_llDiffVolumeFreeSpace);
    if (FAILED(hr))
    {
        DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_VIEWFILES_ERROR, m_strDiffVolumeDisplayName);
        return;
    }

    dlg.DoModal();
}

void CSettings::OnSchedule() 
{
    CWaitCursor wait;
    HRESULT hr = S_OK;

    CComPtr<ITask> spiTask;
    PTSTR pszTaskName = NULL;
    hr = FindScheduledTimewarpTask((ITaskScheduler *)m_spiTS, m_strVolume, &spiTask, &pszTaskName);
    if (FAILED(hr))
    {
        DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_FINDSCHEDULE_ERROR, m_strVolume);
        return;
    }

    BOOL bScheduleFound = (S_OK == hr);

    if (!bScheduleFound)
    {
        //
        // schedule not found, we need to create the default schedule
        //
        if (m_pszTaskName)
        {
            free(m_pszTaskName);
            m_pszTaskName = NULL;
        }

        PTSTR pszVolumeName = GetVolumeName(m_pVolumeList, m_strVolume);
        ASSERT(pszVolumeName);
        hr = CreateDefaultEnableSchedule(
                                        (ITaskScheduler *)m_spiTS,
                                        m_strComputer,
                                        m_strVolume,
                                        pszVolumeName,
                                        &spiTask,
                                        &m_pszTaskName); // remember the taskname, we need to delete it if dlg is cancelled.
        if (FAILED(hr))
        {
            DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_CREATESCHEDULE_ERROR, m_strVolume);

            if (pszTaskName)
                free(pszTaskName);

            return;
        }
    }

    ASSERT((ITask *)spiTask);

    //
    // bring up the property sheet as modal with only the schedule tab
    //
    CComPtr<IProvideTaskPage> spiProvTaskPage;
    hr = spiTask->QueryInterface(IID_IProvideTaskPage, (void **)&spiProvTaskPage);
    if (SUCCEEDED(hr))
    {
        HPROPSHEETPAGE phPage = NULL;
        hr = spiProvTaskPage->GetPage(TASKPAGE_SCHEDULE, TRUE, &phPage);
  
        if (SUCCEEDED(hr))
        {
            PROPSHEETHEADER psh;
            ZeroMemory(&psh, sizeof(PROPSHEETHEADER));
            psh.dwSize = sizeof(PROPSHEETHEADER);
            psh.dwFlags = PSH_DEFAULT | PSH_NOAPPLYNOW;
            psh.hwndParent = m_hWnd;
            psh.hInstance = _Module.GetResourceInstance();
            psh.pszCaption = (bScheduleFound ? pszTaskName : m_pszTaskName);
            psh.phpage = &phPage;
            psh.nPages = 1;

            PropertySheet(&psh);
        }
    }

    if (FAILED(hr))
        DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_SCHEDULEPAGE_ERROR, (bScheduleFound ? pszTaskName : m_pszTaskName));

    if (pszTaskName)
        free(pszTaskName);

    return;
}

void CSettings::OnSelchangeDiffVolume() 
{
    CWaitCursor wait;

	int nIndex = m_ctrlStorageVolume.GetCurSel();
    ASSERT(CB_ERR != nIndex);

    m_ctrlStorageVolume.GetLBText(nIndex, m_strDiffVolumeDisplayName);
    HRESULT hr = GetVolumeSpace(
                        m_spiDiffSnapMgmt,
                        m_strDiffVolumeDisplayName,
                        &m_llDiffVolumeTotalSpace,
                        &m_llDiffVolumeFreeSpace);

    if (SUCCEEDED(hr))
        m_ctrlSpin.SendMessage(UDM_SETRANGE32, 0, min(0x7FFFFFFF, m_llDiffVolumeTotalSpace / g_llMB));
}


BOOL CSettings::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (!pHelpInfo || 
        pHelpInfo->iContextType != HELPINFO_WINDOW || 
        pHelpInfo->iCtrlId < 0)
        return FALSE;

    ::WinHelp((HWND)pHelpInfo->hItemHandle,
                VSSUI_CTX_HELP_FILE,
                HELP_WM_HELP,
                (DWORD_PTR)(PVOID)aMenuHelpIDsForSettings); 

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\snapext.h ===
#ifndef __SNAPEXT_H_
#define __SNAPEXT_H_
#include "resource.h"
#include <atlsnap.h>
#include "vssprop.h"

class CVSSUIExtData1 : public CSnapInItemImpl<CVSSUIExtData1, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	BEGIN_SNAPINCOMMAND_MAP(CVSSUIExtData1, FALSE)
	END_SNAPINCOMMAND_MAP()

//	SNAPINMENUID(IDR_VSSUI_MENU)

	CVSSUIExtData1()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CVSSUIExtData1()
	{
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}
};

class CVSSUIExtData2 : public CSnapInItemImpl<CVSSUIExtData2, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	BEGIN_SNAPINCOMMAND_MAP(CVSSUIExtData2, FALSE)
	END_SNAPINCOMMAND_MAP()

//	SNAPINMENUID(IDR_VSSUI_MENU)  // use the same context menu

	CVSSUIExtData2()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CVSSUIExtData2()
	{
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}
};

class CVSSUI :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CSnapInObjectRoot<0, CVSSUI>,
	public IExtendContextMenuImpl<CVSSUI>,
//    public IExtendPropertySheetImpl<CVSSUI>,
	public CComCoClass<CVSSUI, &CLSID_VSSUI>
{
public:
	CVSSUI();
	~CVSSUI();

EXTENSION_SNAPIN_DATACLASS(CVSSUIExtData1)
EXTENSION_SNAPIN_DATACLASS(CVSSUIExtData2)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CVSSUI)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CVSSUIExtData1)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CVSSUIExtData2)
END_EXTENSION_SNAPIN_NODEINFO_MAP()

BEGIN_COM_MAP(CVSSUI)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
//    COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_VSSUI)

DECLARE_NOT_AGGREGATABLE(CVSSUI)


	static void WINAPI ObjectMain(bool bStarting)
	{
		if (bStarting)
			CSnapInItem::Init();
	}

    ///////////////////////////////
    // Interface IExtendContextMenu
    ///////////////////////////////

    //
    // overwrite AddMenuItems() such that we only add the menu item
    // when targeted machine belongs to postW2K server SKUs.
    //
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems(
    /* [in] */ LPDATAOBJECT piDataObject,
    /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
    /* [out][in] */ long *pInsertionAllowed);

    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command(
    /* [in] */ long lCommandID,
    /* [in] */ LPDATAOBJECT piDataObject);

    ///////////////////////////////
    // Interface IExtendPropertySheet
    ///////////////////////////////
//    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
//        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
//        /* [in] */ LONG_PTR handle,
//        /* [in] */ LPDATAOBJECT lpIDataObject);
    
//    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
//    /* [in] */ LPDATAOBJECT lpDataObject) { return S_OK; }

    HRESULT InvokePropSheet(LPDATAOBJECT piDataObject);
    
private:
    CVSSProp* m_pPage;
};

HRESULT ExtractData(
    IDataObject* piDataObject,
    CLIPFORMAT   cfClipFormat,
    BYTE*        pbData,
    DWORD        cbData 
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__371FD9E3_CB47_4FA1_BF6D_986FF1B98013__INCLUDED_)
#define AFX_STDAFX_H__371FD9E3_CB47_4FA1_BF6D_986FF1B98013__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxcmn.h>         // MFC common controls
#include <afxext.h>         // MFC extensions
//#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

#include "resource.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__371FD9E3_CB47_4FA1_BF6D_986FF1B98013__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\vssprop.cpp ===
// CVSSProp.cpp : implementation file
//

#include "stdafx.h"
#include "utils.h"
#include "VSSProp.h"
#include "RemDlg.h"
#include "Settings.h"
#include "Hosting.h"
#include "uihelp.h"

#include <vss.h> // _VSS_SNAPSHOT_CONTEXT
#include <vsmgmt.h>
#include <vsswprv.h> // VSS_SWPRV_ProviderId
#include <vswriter.h>// VssFreeSnapshotProperties
#include <vsbackup.h> // VssFreeSnapshotProperties

#include <lm.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVSSProp property page

IMPLEMENT_DYNCREATE(CVSSProp, CPropertyPage)

CVSSProp::CVSSProp() : CPropertyPage(CVSSProp::IDD)
{
	//{{AFX_DATA_INIT(CVSSProp)
	//}}AFX_DATA_INIT
	m_strComputer = _T("");
    m_strSelectedVolume = _T("");
}

CVSSProp::CVSSProp(LPCTSTR pszComputer, LPCTSTR pszVolume) : CPropertyPage(CVSSProp::IDD)
{
#ifdef DEBUG
    OutputDebugString(_T("CVSSProp::CVSSPRop\n"));
#endif
    if (!pszComputer)
        m_strComputer = _T("");
    else
        m_strComputer = pszComputer + (TWO_WHACKS(pszComputer) ? 2 : 0);

    m_strSelectedVolume = (pszVolume ? pszVolume : _T(""));
}

CVSSProp::~CVSSProp()
{
#ifdef DEBUG
    OutputDebugString(_T("CVSSProp::~CVSSPRop\n"));
#endif
}

HRESULT CVSSProp::StoreShellExtPointer(IShellPropSheetExt* piShellExt)
{
    if (!piShellExt)
        return E_INVALIDARG;

    // This assignment will call AddRef().
    // Release() will later be called by ~CVSSProp().
    m_spiShellExt = piShellExt;

    return S_OK;
}

void CVSSProp::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CVSSProp)
	DDX_Control(pDX, IDC_VOLUME_LIST, m_ctrlVolumeList);
	DDX_Control(pDX, IDC_ENABLE, m_ctrlEnable);
	DDX_Control(pDX, IDC_DISABLE, m_ctrlDisable);
	DDX_Control(pDX, IDC_SETTINGS, m_ctrlSettings);
	DDX_Control(pDX, IDC_SNAPSHOT_LIST, m_ctrlSnapshotList);
	DDX_Control(pDX, IDC_CREATE, m_ctrlCreate);
	DDX_Control(pDX, IDC_DELETE, m_ctrlDelete);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CVSSProp, CPropertyPage)
	//{{AFX_MSG_MAP(CVSSProp)
	ON_BN_CLICKED(IDC_CREATE, OnCreateNow)
	ON_BN_CLICKED(IDC_DELETE, OnDeleteNow)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_SNAPSHOT_LIST, OnItemchangedSnapshotList)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_VOLUME_LIST, OnItemchangedVolumeList)
	ON_WM_HELPINFO()
	ON_BN_CLICKED(IDC_ENABLE, OnEnable)
	ON_BN_CLICKED(IDC_DISABLE, OnDisable)
	ON_BN_CLICKED(IDC_SETTINGS, OnSettings)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVSSProp message handlers

//
// If we have successfully taken one snapshot of the specified volume, we will
// return VSS_S_ASYNC_FINISHED.
//
HRESULT CVSSProp::TakeOneSnapshotNow(IN LPCTSTR pszVolumeName) 
{
    if (!pszVolumeName || !*pszVolumeName)
        return E_INVALIDARG;

    VSS_ID SnapshotSetId = GUID_NULL;
    HRESULT hr = m_spiCoord->StartSnapshotSet(&SnapshotSetId);

    if (SUCCEEDED(hr))
    {
        VSS_ID SnapshotId = GUID_NULL;
        hr = m_spiCoord->AddToSnapshotSet(
                            (PTSTR)pszVolumeName,
                            VSS_SWPRV_ProviderId,
                            &SnapshotId);
        if (SUCCEEDED(hr))
        {
            CComPtr<IVssAsync> spiAsync;
            hr = m_spiCoord->DoSnapshotSet(NULL, &spiAsync);
            if (SUCCEEDED(hr))
            {
                hr = spiAsync->Wait();
                if (SUCCEEDED(hr))
                {
                    HRESULT hrStatus = S_OK;
                    hr = spiAsync->QueryStatus(&hrStatus, NULL);
                    if (SUCCEEDED(hr))
                    {
                        return hrStatus;
                    }
                }
            }
        }
    }

    return hr;
}

//
// OnCreateNow works when only one volume is currently selected.
//
void CVSSProp::OnCreateNow() 
{
    CWaitCursor wait;

    if (m_strSelectedVolume.IsEmpty())
        return;

    PTSTR pszVolumeName = GetVolumeName(&m_VolumeList, m_strSelectedVolume);
    ASSERT(pszVolumeName);

    HRESULT hr = TakeOneSnapshotNow(pszVolumeName);
    if (VSS_S_ASYNC_FINISHED == hr)
    {
        UpdateSnapshotList();
        UpdateDiffArea();
    } else if (FAILED(hr))
    {
        DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_TAKESNAPSHOT_ERROR, m_strSelectedVolume);
    }
}

//
// OnDeleteNow works on multi-selected snapshots when only one volume is currently selected.
//
void CVSSProp::OnDeleteNow() 
{
    CWaitCursor wait;

    if (m_strSelectedVolume.IsEmpty())
        return;

    BOOL    bAtLeastOneDeleted = FALSE;
    HRESULT hr = S_OK;

    int nIndex = -1;
    while (-1 != (nIndex = m_ctrlSnapshotList.GetNextItem(nIndex, LVNI_SELECTED)))
    {
        VSSUI_SNAPSHOT *pSnapshot = (VSSUI_SNAPSHOT *)GetListViewItemData(m_ctrlSnapshotList.m_hWnd, nIndex);
        ASSERT(pSnapshot);

        LONG lDeletedSnapshots = 0;
        VSS_ID ProblemSnapshotId = GUID_NULL;
        hr = m_spiCoord->DeleteSnapshots(pSnapshot->idSnapshot,
                                        VSS_OBJECT_SNAPSHOT,
                                        TRUE,
                                        &lDeletedSnapshots,
                                        &ProblemSnapshotId
                                        );
        if (SUCCEEDED(hr))
            bAtLeastOneDeleted = TRUE;

        if (FAILED(hr))
            break;
    }

    if (FAILED(hr))
        DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_DELETESNAPSHOTS_ERROR, m_strSelectedVolume);

    if (bAtLeastOneDeleted)
    {
        UpdateSnapshotList();
        UpdateDiffArea();
    }
}

#define HKCU_VSSUI_KEY          _T("Software\\Microsoft\\VSSUI")
#define REGVALUENAME_ENABLE     _T("EnableReminderOff")
#define REGVALUENAME_DISABLE    _T("DisableReminderOff")

void CVSSProp::OnEnable() 
{
    BOOL bShowReminder = TRUE;

    HKEY hKey = NULL;
    LONG lErr = RegCreateKeyEx(HKEY_CURRENT_USER,
                                HKCU_VSSUI_KEY,
                                0,                              // reserved
                                _T(""),                         // lpClass
                                REG_OPTION_NON_VOLATILE,
                                KEY_QUERY_VALUE | KEY_SET_VALUE,
                                NULL,                           // lpSecurityAttributes
                                &hKey,
                                NULL                            // lpdwDisposition
                                );
    if (ERROR_SUCCESS == lErr)
    {
        DWORD dwType = 0;
        DWORD dwData = 0;
        DWORD cbData = sizeof(DWORD);

        lErr = RegQueryValueEx(hKey, REGVALUENAME_ENABLE, 0, &dwType, (LPBYTE)&dwData, &cbData);

        if (ERROR_SUCCESS == lErr && REG_DWORD == dwType && 0 != dwData)
            bShowReminder = FALSE;
    }

    int nRet = IDOK;
    if (bShowReminder)
    {
        CString strMsg;
        strMsg.LoadString(IDS_ENABLE_REMINDER);
        CReminderDlg dlg(strMsg, hKey, REGVALUENAME_ENABLE);
        nRet = dlg.DoModal();
    }

    if (hKey)
        RegCloseKey(hKey);

    if (IDOK == nRet)
        DoEnable();
}

HRESULT CVSSProp::DoEnable()
{
    CWaitCursor wait;

    HRESULT hr = S_OK;
    LVITEM lvItem = {0};
    int nSelectedCount = m_ctrlVolumeList.GetSelectedCount();
    if (nSelectedCount > 0)
    {
        POSITION pos = m_ctrlVolumeList.GetFirstSelectedItemPosition();
        while (pos)
        {
            int nIndex = m_ctrlVolumeList.GetNextSelectedItem(pos);
            VSSUI_VOLUME *pVolume = (VSSUI_VOLUME *)GetListViewItemData(m_ctrlVolumeList.m_hWnd, nIndex);
            ASSERT(pVolume);

            //
            // if none, create default schedule for that volume
            //
            CComPtr<ITask> spiTask;
            hr = FindScheduledTimewarpTask(
                                        (ITaskScheduler *)m_spiTS,
                                        pVolume->pszDisplayName,
                                        &spiTask);
            if (FAILED(hr))
            {
                DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_FINDSCHEDULE_ERROR, pVolume->pszDisplayName);
            } else if (S_FALSE == hr)  // task not found
            {
                (void)DeleteAllScheduledTimewarpTasks((ITaskScheduler *)m_spiTS,
                                                    pVolume->pszDisplayName,
                                                    TRUE // i_bDeleteDisabledOnesOnly
                                                    );
                hr = CreateDefaultEnableSchedule(
                                        (ITaskScheduler *)m_spiTS,
                                        m_strComputer,
                                        pVolume->pszDisplayName,
                                        pVolume->pszVolumeName,
                                        &spiTask);
                if (FAILED(hr))
                    DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_CREATESCHEDULE_ERROR, pVolume->pszDisplayName);
            }

            if (SUCCEEDED(hr))
                UpdateSchedule((ITask *)spiTask, nIndex);
            else
                break;

            //
            // take one snapshot now, it will create default diff area association if none
            //
            hr = TakeOneSnapshotNow(pVolume->pszVolumeName);
            if (VSS_S_ASYNC_FINISHED == hr)
            {
                if (1 == nSelectedCount)
                    UpdateSnapshotList();

                UpdateDiffArea(nIndex, pVolume->pszVolumeName);
            } else if (FAILED(hr))
            {
                DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_TAKESNAPSHOT_ERROR, pVolume->pszDisplayName);
                break;
            }
        }
    }

    return hr;
}

void CVSSProp::OnDisable() 
{
    BOOL bShowReminder = TRUE;

    HKEY hKey = NULL;
    LONG lErr = RegCreateKeyEx(HKEY_CURRENT_USER,
                                HKCU_VSSUI_KEY,
                                0,                              // reserved
                                _T(""),                         // lpClass
                                REG_OPTION_NON_VOLATILE,
                                KEY_QUERY_VALUE | KEY_SET_VALUE,
                                NULL,                           // lpSecurityAttributes
                                &hKey,
                                NULL                            // lpdwDisposition
                                );
    if (ERROR_SUCCESS == lErr)
    {
        DWORD dwType = 0;
        DWORD dwData = 0;
        DWORD cbData = sizeof(DWORD);

        lErr = RegQueryValueEx(hKey, REGVALUENAME_DISABLE, 0, &dwType, (LPBYTE)&dwData, &cbData);

        if (ERROR_SUCCESS == lErr && REG_DWORD == dwType && 0 != dwData)
            bShowReminder = FALSE;
    }

    int nRet = IDOK;
    if (bShowReminder)
    {
        CString strMsg;
        strMsg.LoadString(IDS_DISABLE_REMINDER);
        CReminderDlg dlg(strMsg, hKey, REGVALUENAME_DISABLE);
        nRet = dlg.DoModal();
    }

    if (hKey)
        RegCloseKey(hKey);

    if (IDOK == nRet)
        DoDisable();
}

HRESULT CVSSProp::DoDisable()
{
    CWaitCursor wait;

    HRESULT hr = S_OK;
    LVITEM lvItem = {0};
    int nSelectedCount = m_ctrlVolumeList.GetSelectedCount();
    if (nSelectedCount > 0)
    {
        POSITION pos = m_ctrlVolumeList.GetFirstSelectedItemPosition();
        while (pos)
        {
            int nIndex = m_ctrlVolumeList.GetNextSelectedItem(pos);
            VSSUI_VOLUME *pVolume = (VSSUI_VOLUME *)GetListViewItemData(m_ctrlVolumeList.m_hWnd, nIndex);
            ASSERT(pVolume);

            //
            // delete all snapshots on that volume
            //
            hr = DeleteAllSnapshotsOnVolume(pVolume->pszVolumeName);
            UpdateSnapshotList();
            if (FAILED(hr))
            {
                DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_DELETESNAPSHOTS_ERROR, pVolume->pszDisplayName);
                break;
            }

            //
            // delete all scheduled tasks for that volume
            //
            hr = DeleteAllScheduledTimewarpTasks((ITaskScheduler *)m_spiTS,
                                                pVolume->pszDisplayName,
                                                FALSE // i_bDeleteDisabledOnesOnly
                                                );

            if (SUCCEEDED(hr))
                UpdateSchedule(NULL, nIndex);
            else
            {
                DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_FINDSCHEDULE_ERROR, pVolume->pszDisplayName);
                break;
            }

            //
            // remove diff area associate for that volume
            //
            VSSUI_DIFFAREA diffArea;
            hr = GetDiffAreaInfo(m_spiDiffSnapMgmt, &m_VolumeList, pVolume->pszVolumeName, &diffArea);
            if (S_OK == hr)
            {
                PTSTR pszDiffAreaVolumeName = GetVolumeName(&m_VolumeList, diffArea.pszDiffVolumeDisplayName);
                ASSERT(pszDiffAreaVolumeName);
                hr = m_spiDiffSnapMgmt->ChangeDiffAreaMaximumSize(
                                                pVolume->pszVolumeName, 
                                                pszDiffAreaVolumeName, 
                                                VSS_ASSOC_REMOVE);
            }
            if (SUCCEEDED(hr))
                UpdateDiffArea(nIndex, pVolume->pszVolumeName);
            else
            {
                DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_DELETEDIFFAREA_ERROR, pVolume->pszDisplayName);
                break;
            }
        }
    }

    return hr;
}

HRESULT CVSSProp::DeleteAllSnapshotsOnVolume(
    IN LPCTSTR pszVolumeName
    )
{
    if (!pszVolumeName || !*pszVolumeName)
        return E_INVALIDARG;

    CComPtr<IVssEnumObject> spiEnumSnapshots;
    HRESULT hr = m_spiMgmt->QuerySnapshotsByVolume(
                                            (PTSTR)pszVolumeName,
                                            VSS_SWPRV_ProviderId,
                                            &spiEnumSnapshots
                                            );
    if (S_OK == hr)
    {
        VSS_OBJECT_PROP     Prop;
        VSS_SNAPSHOT_PROP*  pSnapProp = &(Prop.Obj.Snap);
        ULONG               ulFetched = 0;
        while (SUCCEEDED(spiEnumSnapshots->Next(1, &Prop, &ulFetched)) && ulFetched > 0)
        {
            if (VSS_OBJECT_SNAPSHOT != Prop.Type)
                return E_FAIL;

            if (pSnapProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE)
            {
                LONG lDeletedSnapshots = 0;
                VSS_ID ProblemSnapshotId = GUID_NULL;
                hr = m_spiCoord->DeleteSnapshots(pSnapProp->m_SnapshotId,
                                                VSS_OBJECT_SNAPSHOT,
                                                TRUE,
                                                &lDeletedSnapshots,
                                                &ProblemSnapshotId
                                                );
                VssFreeSnapshotProperties(pSnapProp);

                if (FAILED(hr))
                    break;
            }
        }
    }

    return hr;
}

void CVSSProp::OnSettings() 
{
    CWaitCursor wait;

    CSettings dlg(m_strComputer, m_strSelectedVolume);
    HRESULT hr = dlg.Init(m_spiDiffSnapMgmt,
                        m_spiTS,
                        &m_VolumeList,
                        !m_SnapshotList.empty());

    if (FAILED(hr))
    {
        DoErrMsgBox(m_hWnd, MB_OK, hr, IDS_SETTINGS_ERROR, m_strSelectedVolume);
        return;
    }

    if (IDOK == dlg.DoModal())
    {
        UpdateDiffArea();
        UpdateSchedule();
    }
}

void CVSSProp::OnItemchangedSnapshotList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    m_ctrlDelete.EnableWindow(0 < m_ctrlSnapshotList.GetSelectedCount());
	
	*pResult = 0;
}

void CVSSProp::OnItemchangedVolumeList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    BOOL bMultiSelected = (1 < m_ctrlVolumeList.GetSelectedCount());
    m_ctrlSettings.EnableWindow(!bMultiSelected);
    m_ctrlCreate.EnableWindow(!bMultiSelected);

    if (bMultiSelected)
    {
        m_strSelectedVolume = _T("");
    } else
    {
        int nIndex = m_ctrlVolumeList.GetNextItem(-1, LVNI_SELECTED);
        if (-1 != nIndex)
        {
            m_strSelectedVolume = m_ctrlVolumeList.GetItemText(nIndex, 0);
        } else
        {
            m_strSelectedVolume = _T("");
        }
    }

    CWaitCursor wait;
    UpdateSnapshotList();

    *pResult = 0;
}

BOOL CVSSProp::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (!pHelpInfo || 
        pHelpInfo->iContextType != HELPINFO_WINDOW || 
        pHelpInfo->iCtrlId < 0)
        return FALSE;

    ::WinHelp((HWND)pHelpInfo->hItemHandle,
                VSSUI_CTX_HELP_FILE,
                HELP_WM_HELP,
                (DWORD_PTR)(PVOID)aMenuHelpIDsForVSSProp); 

	return TRUE;
}

BOOL CVSSProp::OnInitDialog() 
{
    CWaitCursor wait;

	CPropertyPage::OnInitDialog();
	
    BOOL bHideAllControls = FALSE;
    CString strMsg;

    HRESULT hr = S_OK;
    
    do {
        hr = InitInterfacePointers();
        if (FAILED(hr))
        {
            GetMsg(strMsg, hr, IDS_VSSPROP_INIT_ERROR);
            bHideAllControls = TRUE;
            break;
        }

        hr = GetVolumes(); // get a list of volumes that are suitable for taking snapshots

        if (FAILED(hr))
        {
            GetMsg(strMsg, hr, IDS_VSSPROP_GETVOLUMES_ERROR);
            bHideAllControls = TRUE;
            break;
        }

        if (m_VolumeList.empty())
        {
            GetMsg(strMsg, 0, IDS_VSSPROP_EMPTY_VOLUMELIST);
            bHideAllControls = TRUE;
            break;
        }

        if (!m_strSelectedVolume.IsEmpty())
        {
            BOOL bFound = FALSE;
            for (VSSUI_VOLUME_LIST::iterator i = m_VolumeList.begin(); i != m_VolumeList.end(); i++)
            {
                if (!m_strSelectedVolume.CompareNoCase((*i)->pszDisplayName))
                {
                    bFound = TRUE;
                    break;
                }
            }

            if (!bFound)
            {
                GetMsg(strMsg, 0, IDS_VSSPROP_VOLUME_ILEGIBLE, m_strSelectedVolume);
                bHideAllControls = TRUE;
                break;
            }
        }
    } while (0);

    if (bHideAllControls)
    {
        GetDlgItem(IDC_VSSPROP_ERROR)->SetWindowText(strMsg);
        GetDlgItem(IDC_VSSPROP_ERROR)->EnableWindow(TRUE);

        for (int i = IDC_EXPLANATION; i < IDC_VSSPROP_ERROR; i++)
        {
            GetDlgItem(i)->EnableWindow(FALSE);
            GetDlgItem(i)->ShowWindow(SW_HIDE);
        }
    } else
    {
        GetDlgItem(IDC_VSSPROP_ERROR)->EnableWindow(FALSE);
        GetDlgItem(IDC_VSSPROP_ERROR)->ShowWindow(SW_HIDE);
        //
        // insert column header of the Volume listbox
        //
        HWND hwnd = m_ctrlVolumeList.m_hWnd;
        AddLVColumns(
                hwnd, 
                IDS_VOLUMELIST_COLUMN_VOLUME,
                IDS_VOLUMELIST_COLUMN_NEXTRUNTIME - IDS_VOLUMELIST_COLUMN_VOLUME + 1);
        ListView_SetExtendedListViewStyle(hwnd, LVS_EX_FULLROWSELECT);
	    
        InsertVolumeInfo(hwnd);
        InsertDiffAreaInfo(hwnd);
        InsertShareInfo(hwnd);
        InsertScheduleInfo(hwnd);

        SelectVolume(hwnd);

        //
        // insert column headers for the snapshot listbox
        //
        hwnd = m_ctrlSnapshotList.m_hWnd;
        AddLVColumns(
                hwnd,
                IDS_SNAPSHOTLIST_COLUMN_TIMESTAMP,
                IDS_SNAPSHOTLIST_COLUMN_TIMESTAMP - IDS_SNAPSHOTLIST_COLUMN_TIMESTAMP + 1);
        ListView_SetExtendedListViewStyle(hwnd, LVS_EX_FULLROWSELECT);

        UpdateSnapshotList();
    }

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CVSSProp::_ResetInterfacePointers()
{
    if ((IVssSnapshotMgmt *)m_spiMgmt)
        m_spiMgmt.Release();

    if ((IVssCoordinator *)m_spiCoord)
        m_spiCoord.Release();

    if ((IVssDifferentialSoftwareSnapshotMgmt *)m_spiDiffSnapMgmt)
        m_spiDiffSnapMgmt.Release();

    if ((ITaskScheduler *)m_spiTS)
        m_spiTS.Release();
}

HRESULT CVSSProp::InitInterfacePointers()
{
    _ResetInterfacePointers();

    HRESULT hr = S_OK;
    if (m_strComputer.IsEmpty())
    {
        hr = CoCreateInstance(CLSID_VssSnapshotMgmt, 
                                NULL,
                                CLSCTX_LOCAL_SERVER,
                                IID_IVssSnapshotMgmt,
                                (void **)&m_spiMgmt);
        if (SUCCEEDED(hr))
            hr = CoCreateInstance(CLSID_VSSCoordinator, 
                        NULL,
                        CLSCTX_LOCAL_SERVER,
                        IID_IVssCoordinator,
                        (void **)&m_spiCoord);

    } else
    {
        COSERVERINFO serverInfo = {0};
        serverInfo.pwszName = (LPTSTR)(LPCTSTR)m_strComputer;

        IID         iid = IID_IVssSnapshotMgmt;
        MULTI_QI    MQI = {0};
        MQI.pIID = &iid;
        hr = CoCreateInstanceEx(CLSID_VssSnapshotMgmt, 
                                NULL,
                                CLSCTX_REMOTE_SERVER,
                                &serverInfo,
                                1,
                                &MQI);
        if (SUCCEEDED(hr))
        {
            m_spiMgmt = (IVssSnapshotMgmt *)MQI.pItf;

            ZeroMemory(&MQI, sizeof(MQI));
            iid = IID_IVssCoordinator;
            MQI.pIID = &iid;
            hr = CoCreateInstanceEx(CLSID_VSSCoordinator, 
                                    NULL,
                                    CLSCTX_REMOTE_SERVER,
                                    &serverInfo,
                                    1,
                                    &MQI);
            if (SUCCEEDED(hr))
                m_spiCoord = (IVssCoordinator *)MQI.pItf;
        }
    }

    if (SUCCEEDED(hr))
    	hr = m_spiCoord->SetContext(VSS_CTX_CLIENT_ACCESSIBLE);

    if (SUCCEEDED(hr))
        hr = m_spiMgmt->GetProviderMgmtInterface(
                                    VSS_SWPRV_ProviderId,
                                    IID_IVssDifferentialSoftwareSnapshotMgmt,
                                    (IUnknown**)&m_spiDiffSnapMgmt);

    if (SUCCEEDED(hr))
        hr = CoCreateInstance(CLSID_CTaskScheduler,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_ITaskScheduler,
                                (void **)&m_spiTS);
  
    if (SUCCEEDED(hr))
    {
        // SetTargetComputer requires server name to start with whackwhack
        if (m_strComputer.IsEmpty())
            hr = m_spiTS->SetTargetComputer(NULL);
        else
        {
            CString strTargetComputer = _T("\\\\");
            strTargetComputer += m_strComputer;
            hr = m_spiTS->SetTargetComputer((LPCTSTR)strTargetComputer);
        }
    }

    if (FAILED(hr))
        _ResetInterfacePointers();

    return hr;
}

HRESULT CVSSProp::GetVolumes()
{
    if (!m_spiMgmt)
        return E_INVALIDARG;

    FreeVolumeList(&m_VolumeList);

    CComPtr<IVssEnumMgmtObject> spiEnumMgmt;
    HRESULT hr = m_spiMgmt->QueryVolumesSupportedForSnapshots(
                    VSS_SWPRV_ProviderId,
                    VSS_CTX_CLIENT_ACCESSIBLE,
                    &spiEnumMgmt);
    if (FAILED(hr))
        return hr;

    VSS_MGMT_OBJECT_PROP Prop;
    VSS_VOLUME_PROP *pVolProp = &(Prop.Obj.Vol);
    ULONG ulFetched = 0;
    while (SUCCEEDED(hr = spiEnumMgmt->Next(1, &Prop, &ulFetched)) && ulFetched > 0)
    {
        if (VSS_MGMT_OBJECT_VOLUME != Prop.Type)
            return E_FAIL;

        VSSUI_VOLUME *pVolInfo = (VSSUI_VOLUME *)calloc(1, sizeof(VSSUI_VOLUME));
        if (pVolInfo)
        {
            _tcscpy(pVolInfo->pszVolumeName, pVolProp->m_pwszVolumeName);
            _tcscpy(pVolInfo->pszDisplayName, pVolProp->m_pwszVolumeDisplayName);
            m_VolumeList.push_back(pVolInfo);
        } else
        {
            FreeVolumeList(&m_VolumeList);
            hr = E_OUTOFMEMORY;
        }
        CoTaskMemFree(pVolProp->m_pwszVolumeName);
        CoTaskMemFree(pVolProp->m_pwszVolumeDisplayName);

        if (FAILED(hr))
            break;
    }

    return hr;
}

HRESULT CVSSProp::InsertVolumeInfo(HWND hwnd)
{
    ListView_DeleteAllItems(hwnd);

    for (VSSUI_VOLUME_LIST::iterator i = m_VolumeList.begin(); i != m_VolumeList.end(); i++)
    {
        LVITEM lvItem = {0};
        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.lParam = (LPARAM)(*i);
        lvItem.pszText = (*i)->pszDisplayName;
        lvItem.iSubItem = 0;
        ListView_InsertItem(hwnd, &lvItem);
    }

    return S_OK;
}

//
// Update diff area column of the currently selected volume
//
HRESULT CVSSProp::UpdateDiffArea()
{
    if (m_strSelectedVolume.IsEmpty())
        return E_INVALIDARG;

    int nIndex = m_ctrlVolumeList.GetNextItem(-1, LVNI_SELECTED);
    ASSERT(-1 != nIndex);

    PTSTR pszVolumeName = GetVolumeName(&m_VolumeList, m_strSelectedVolume);
    ASSERT(pszVolumeName);

    return UpdateDiffArea(nIndex, pszVolumeName);
}

//
// Update diff area column of the specified volume
//
HRESULT CVSSProp::UpdateDiffArea(int nIndex, LPCTSTR pszVolumeName)
{
    CString strMsg = _T("");
    VSSUI_DIFFAREA diffArea;
    HRESULT hr = GetDiffAreaInfo(m_spiDiffSnapMgmt, &m_VolumeList, pszVolumeName, &diffArea);

    if (S_OK == hr)
    {
        //
        // "Used on DiffVolume"
        //
        TCHAR szUsed[MAX_PATH];
        DWORD dwSize = sizeof(szUsed)/sizeof(TCHAR);
        DiskSpaceToString(diffArea.llUsedDiffSpace, szUsed, &dwSize);

        strMsg.FormatMessage(IDS_USED_ON_VOLUME, szUsed, diffArea.pszDiffVolumeDisplayName);
    }

    LVITEM lvItem = {0};
    lvItem.iItem = nIndex;
    lvItem.mask = LVIF_TEXT;
    lvItem.pszText = (PTSTR)(LPCTSTR)strMsg;
    lvItem.iSubItem = IDS_VOLUMELIST_COLUMN_USED - IDS_VOLUMELIST_COLUMN_VOLUME;
    m_ctrlVolumeList.SetItem(&lvItem);

    return hr;
}

HRESULT CVSSProp::InsertDiffAreaInfo(HWND hwnd)
{
    if (m_VolumeList.empty())
        return S_OK;

    int nIndex = -1;
    while (-1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL)))
    {
        VSSUI_VOLUME *pVolume = (VSSUI_VOLUME *)GetListViewItemData(hwnd, nIndex);
        ASSERT(pVolume);

        UpdateDiffArea(nIndex, pVolume->pszVolumeName);
    }

    return S_OK;
}

HRESULT CVSSProp::InsertShareInfo(HWND hwnd)
{
    if (m_VolumeList.empty())
        return S_OK;

    SHARE_INFO_2 *pInfo = NULL;
    DWORD dwEntriesRead = 0;
    DWORD dwEntriesTotal = 0;
    DWORD dwRet = NetShareEnum((PTSTR)(LPCTSTR)m_strComputer, 
                                2, 
                                (LPBYTE *)&pInfo,
                                -1, //max
                                &dwEntriesRead,
                                &dwEntriesTotal,
                                NULL // resume handle
                                );

    if (NERR_Success != dwRet)
        return HRESULT_FROM_WIN32(dwRet);

    TCHAR szNumOfShares[256];
    int nIndex = -1;
    while (-1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL)))
    {
        VSSUI_VOLUME *pVolume = (VSSUI_VOLUME *)GetListViewItemData(hwnd, nIndex);
        ASSERT(pVolume);
        UINT count = 0;

        for (DWORD i = 0; i < dwEntriesRead; i++)
        {
            if (pInfo[i].shi2_type == STYPE_DISKTREE)
            {
                if (!mylstrncmpi(pInfo[i].shi2_path, pVolume->pszDisplayName, lstrlen(pVolume->pszDisplayName)))
                    count++;
            }
        }

        _stprintf(szNumOfShares, _T("%d"), count); // no need to localize the format
        LVITEM lvItem = {0};
        lvItem.iItem = nIndex;
        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = szNumOfShares;
        lvItem.iSubItem = IDS_VOLUMELIST_COLUMN_NUMOFSHARES - IDS_VOLUMELIST_COLUMN_VOLUME;
        ListView_SetItem(hwnd, &lvItem);
    }

    NetApiBufferFree(pInfo);
    
    return S_OK;
}

//
// Update schedule column of the currently selected volume
//
HRESULT CVSSProp::UpdateSchedule()
{
    if (m_strSelectedVolume.IsEmpty())
        return E_INVALIDARG;

    int nIndex = m_ctrlVolumeList.GetNextItem(-1, LVNI_SELECTED);
    ASSERT(-1 != nIndex);

    return UpdateSchedule(nIndex, m_strSelectedVolume);
}

//
// Update schedule column of the specified volume
//
HRESULT CVSSProp::UpdateSchedule(int nIndex, LPCTSTR pszVolumeDisplayName)
{
    if (!pszVolumeDisplayName || !*pszVolumeDisplayName)
        return E_INVALIDARG;

    CComPtr<ITask> spiTask;
    (void)FindScheduledTimewarpTask((ITaskScheduler *)m_spiTS, pszVolumeDisplayName, &spiTask);

    UpdateSchedule((ITask *)spiTask, nIndex);

    return S_OK;
}

void CVSSProp::UpdateSchedule(ITask * i_piTask, int nIndex)
{
    BOOL bEnabled = FALSE;
    SYSTEMTIME stNextRun = {0};
    if (i_piTask)
        (void)GetScheduledTimewarpTaskStatus(i_piTask, &bEnabled, &stNextRun);

    LVITEM lvItem = {0};
    lvItem.iItem = nIndex;
    lvItem.mask = LVIF_TEXT;
    lvItem.pszText = bEnabled ? _T("Enabled") : _T("Disabled");
    lvItem.iSubItem = IDS_VOLUMELIST_COLUMN_STATUS - IDS_VOLUMELIST_COLUMN_VOLUME;
    m_ctrlVolumeList.SetItem(&lvItem);

    TCHAR szNextRun[MAX_PATH] = _T("");
    DWORD dwSize = sizeof(szNextRun)/sizeof(TCHAR);

    if (bEnabled)
        SystemTimeToString(&stNextRun, szNextRun, &dwSize);

    lvItem.pszText = szNextRun;
    lvItem.iSubItem = IDS_VOLUMELIST_COLUMN_NEXTRUNTIME - IDS_VOLUMELIST_COLUMN_VOLUME;
    m_ctrlVolumeList.SetItem(&lvItem);
}

HRESULT CVSSProp::InsertScheduleInfo(HWND hwnd)
{
    if (m_VolumeList.empty())
        return S_OK;

    int nIndex = -1;
    while (-1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL)))
    {
        VSSUI_VOLUME *pVolume = (VSSUI_VOLUME *)GetListViewItemData(hwnd, nIndex);
        ASSERT(pVolume);

        UpdateSchedule(nIndex, pVolume->pszDisplayName);
    }

    return S_OK;
}

void CVSSProp::SelectVolume(HWND hwnd)
{
    if (m_VolumeList.empty())
        return;

    int nIndex = -1;
    if (!m_strSelectedVolume.IsEmpty())
    {
        while (-1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL)))
        {
            VSSUI_VOLUME *pVolume = (VSSUI_VOLUME *)GetListViewItemData(hwnd, nIndex);
            ASSERT(pVolume);
            if (!m_strSelectedVolume.CompareNoCase(pVolume->pszDisplayName))
                break;
        }
    }

    if (-1 == nIndex)
        nIndex = 0;

    ListView_SetItemState(hwnd, nIndex, LVIS_SELECTED | LVIS_FOCUSED, 0xffffffff);
}

HRESULT CVSSProp::GetSnapshots(LPCTSTR pszVolume)
{
    if (!pszVolume || !*pszVolume)
        return E_INVALIDARG;

    FreeSnapshotList(&m_SnapshotList);

    CComPtr<IVssEnumObject> spiEnumSnapshots;
    HRESULT hr = m_spiMgmt->QuerySnapshotsByVolume((PTSTR)pszVolume, VSS_SWPRV_ProviderId, &spiEnumSnapshots);
    if (S_OK == hr)
    {
        VSS_OBJECT_PROP     Prop;
        VSS_SNAPSHOT_PROP*  pSnapProp = &(Prop.Obj.Snap);
        ULONG               ulFetched = 0;
        while (SUCCEEDED(spiEnumSnapshots->Next(1, &Prop, &ulFetched)) && ulFetched > 0)
        {
            if (VSS_OBJECT_SNAPSHOT != Prop.Type)
                return E_FAIL;

            if (pSnapProp->m_lSnapshotAttributes & VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE)
            {
                VSSUI_SNAPSHOT *pSnapInfo = (VSSUI_SNAPSHOT *)calloc(1, sizeof(VSSUI_SNAPSHOT));
                if (pSnapInfo)
                {
                    pSnapInfo->idSnapshot = pSnapProp->m_SnapshotId;
                    pSnapInfo->vssTimeStamp = pSnapProp->m_tsCreationTimestamp;
                    m_SnapshotList.push_back(pSnapInfo);
                } else
                {
                    FreeSnapshotList(&m_SnapshotList);
                    hr = E_OUTOFMEMORY;
                }

                VssFreeSnapshotProperties(pSnapProp);

                if (FAILED(hr))
                    break;
            }
        }
    }

    return hr;
}

HRESULT CVSSProp::UpdateSnapshotList()
{
    if (m_strSelectedVolume.IsEmpty())
    {
        m_ctrlSnapshotList.DeleteAllItems();
        m_ctrlDelete.EnableWindow(FALSE);

        return S_OK;
    }

    HRESULT hr = GetSnapshots(m_strSelectedVolume);

    m_ctrlSnapshotList.DeleteAllItems();
    m_ctrlDelete.EnableWindow(FALSE);

    if (SUCCEEDED(hr))
    {
        TCHAR   szTimeStamp[256];
        DWORD   dwSize = 0;
        LVITEM  lvItem = {0};

        for (VSSUI_SNAPSHOT_LIST::iterator i = m_SnapshotList.begin(); i != m_SnapshotList.end(); i++)
        {
            SYSTEMTIME st = {0};
            VssTimeToSystemTime(&((*i)->vssTimeStamp), &st);

            dwSize = sizeof(szTimeStamp)/sizeof(TCHAR);
            SystemTimeToString(&st, szTimeStamp, &dwSize);

            ZeroMemory(&lvItem, sizeof(lvItem));
            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.lParam = (LPARAM)(*i);
            lvItem.pszText = szTimeStamp;
            m_ctrlSnapshotList.InsertItem(&lvItem);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\uihelp.h ===
#ifndef _VSSHELP_H_
#define _VSSHELP_H_

#define VSSUI_CTX_HELP_FILE             _T("timewrpS.hlp")

#define IDH_SETTINGS_VOLUME             1021
#define IDH_SETTINGS_STORAGE_VOLUME     1022
#define IDH_SETTINGS_DIFFLIMITS_EDIT    1023
#define IDH_SETTINGS_DIFFLIMITS_SPIN    1024
#define IDH_SCHEDULE                    1053
#define IDH_SETTINGS_HOSTING            1027
#define IDH_HOSTING_VOLUME              1041
#define IDH_HOSTING_VOLUMELIST          1044
#define IDH_MSG_ONOFF                   1051

#define IDH_VOLUME_LIST                 1003
#define IDH_ENABLE                      1005
#define IDH_DISABLE                     1007
#define IDH_SETTINGS                    1009
#define IDH_SNAPSHOT_LIST               1010
#define IDH_CREATE                      1012
#define IDH_DELETE                      1013

static const DWORD aMenuHelpIDsForVSSProp[] =
{
    IDC_EXPLANATION,                -1,
    IDC_VOLUME_LIST_LABLE,          -1,
    IDC_VOLUME_LIST,                IDH_VOLUME_LIST,
    IDC_ENABLE_TEXT,                -1,
    IDC_ENABLE,                     IDH_ENABLE,
    IDC_DISABLE_TEXT,               -1,
    IDC_DISABLE,                    IDH_DISABLE,
    IDC_SETTINGS_TEXT,              -1,
    IDC_SETTINGS,                   IDH_SETTINGS,
    IDC_SNAPSHOT_LIST_LABLE,        -1,
    IDC_SNAPSHOT_LIST,              IDH_SNAPSHOT_LIST,
    IDC_CREATE,                     IDH_CREATE,
    IDC_DELETE,                     IDH_DELETE,
    IDC_VSSPROP_ERROR,              -1,
    0,                              0
};

static const DWORD aMenuHelpIDsForSettings[] =
{
    IDC_SETTINGS_VOLUME,            IDH_SETTINGS_VOLUME,
    IDC_SETTINGS_STORAGE_VOLUME,    IDH_SETTINGS_STORAGE_VOLUME,
    IDC_SETTINGS_DIFFLIMITS_EDIT,   IDH_SETTINGS_DIFFLIMITS_EDIT,
    IDC_SETTINGS_DIFFLIMITS_SPIN,   IDH_SETTINGS_DIFFLIMITS_SPIN,
    IDC_SCHEDULE,                   IDH_SCHEDULE,
    IDC_SETTINGS_HOSTING,           IDH_SETTINGS_HOSTING,
    0,                              0
};
 
static const DWORD aMenuHelpIDsForViewFiles[] =
{
    IDC_HOSTING_VOLUME,             IDH_HOSTING_VOLUME,
    IDC_HOSTING_VOLUMELIST,         IDH_HOSTING_VOLUMELIST,
    IDC_HOSTING_TOTAL_DISKSPACE,    -1,
    IDC_HOSTING_FREE_DISKSPACE,     -1,
    0,                              0
};

static const DWORD aMenuHelpIDsForReminder[] =
{
    IDC_MESSAGE,                    -1,
    IDC_MSG_ONOFF,                  IDH_MSG_ONOFF,
    0,                              0
};

#endif // _VSSHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\vsspage.h ===
// vsspage.h : main header file for the VSSUI DLL
//

#ifndef __VSSPAGE_H_
#define __VSSPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// CVssPageApp
// See vssui.cpp for the implementation of this class
//

class CVssPageApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
protected:
    BOOL m_bRun;
};

#endif // _VSSPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\utils.h ===
#ifndef _UTILS_H_
#define _UTILS_H_

#include <vss.h>    // VSS_TIMESTAMP
#include <vsmgmt.h>
#include <mstask.h>

#include <list>
using namespace std;

typedef struct _VSSUI_VOLUME
{
    TCHAR pszVolumeName[MAX_PATH];
    TCHAR pszDisplayName[MAX_PATH];
} VSSUI_VOLUME;

typedef list<VSSUI_VOLUME *> VSSUI_VOLUME_LIST;

typedef struct _VSSUI_SNAPSHOT
{
    GUID            idSnapshot;
    VSS_TIMESTAMP   vssTimeStamp;
} VSSUI_SNAPSHOT;

typedef list<VSSUI_SNAPSHOT *> VSSUI_SNAPSHOT_LIST;

typedef struct _VSSUI_DIFFAREA
{
    TCHAR       pszVolumeDisplayName[MAX_PATH];
    TCHAR       pszDiffVolumeDisplayName[MAX_PATH];
    LONGLONG    llMaximumDiffSpace;
    LONGLONG    llUsedDiffSpace;
} VSSUI_DIFFAREA;

typedef list<VSSUI_DIFFAREA *> VSSUI_DIFFAREA_LIST;

// MACROS
#define TWO_WHACKS(p)   ((p) && lstrlen(p) > 1 && *(p) == _T('\\') && *((p)+1) == _T('\\'))

// globals
extern LONGLONG g_llKB;
extern LONGLONG g_llMB;
extern LONGLONG g_llGB;

HRESULT
AddLVColumns(
	IN const HWND     hwndListBox,
	IN const INT      iStartingResourceID,
	IN const UINT     uiColumns
);

LPARAM GetListViewItemData(
    IN HWND hwndList,
    IN int  index
);

int mylstrncmpi(
    IN LPCTSTR lpString1,
    IN LPCTSTR lpString2,
    IN UINT    cchCount
);

HRESULT FindScheduledTimewarpTask(
    IN  ITaskScheduler* i_piTS,
    IN  LPCTSTR         i_pszVolumeDisplayName,
    OUT ITask**         o_ppiTask,
    OUT PTSTR*          o_ppszTaskName = NULL
    );

HRESULT GetScheduledTimewarpTaskStatus(
    IN  ITask*          i_piTask,
    OUT BOOL*           o_pbEnabled,
    OUT SYSTEMTIME*     o_pstNextRunTime
    );

HRESULT CreateDefaultEnableSchedule(
    IN  ITaskScheduler* i_piTS,
    IN  LPCTSTR         i_pszComputer,
    IN  LPCTSTR         i_pszVolumeDisplayName,
    IN  LPCTSTR         i_pszVolumeName,
    OUT ITask**         o_ppiTask,      
    OUT PTSTR*          o_pszTaskName = NULL
    );

HRESULT DeleteAllScheduledTimewarpTasks(
    IN ITaskScheduler* i_piTS,
    IN LPCTSTR         i_pszVolumeDisplayName,
    IN BOOL            i_bDeleteDisabledOnesOnly
    );

HRESULT VssTimeToSystemTime(
    IN  VSS_TIMESTAMP*  i_pVssTime,
    OUT SYSTEMTIME*     o_pSystemTime
    );

HRESULT SystemTimeToString(
    IN      SYSTEMTIME* i_pSystemTime,
    OUT     PTSTR       o_pszText,
    IN OUT  DWORD*      io_pdwSize   
    );

HRESULT DiskSpaceToString(
    IN      LONGLONG    i_llDiskSpace,
    OUT     PTSTR       o_pszText,
    IN OUT  DWORD*      io_pdwSize   
    );

HRESULT GetVolumeSpace(
    IN  IVssDifferentialSoftwareSnapshotMgmt* piDiffSnapMgmt,
    IN  LPCTSTR     i_pszVolumeDisplayName,
    OUT LONGLONG*   o_pllVolumeTotalSpace = NULL,
    OUT LONGLONG*   o_pllVolumeFreeSpace = NULL
    );

HRESULT GetDiffAreaInfo(
    IN  IVssDifferentialSoftwareSnapshotMgmt* piDiffSnapMgmt,
    IN  VSSUI_VOLUME_LIST*  pVolumeList,
    IN  LPCTSTR             pszVolumeName,
    OUT VSSUI_DIFFAREA*     pDiffArea
    );

PTSTR GetDisplayName(VSSUI_VOLUME_LIST *pVolumeList, LPCTSTR pszVolumeName);
PTSTR GetVolumeName(VSSUI_VOLUME_LIST *pVolumeList, LPCTSTR pszDisplayName);

void FreeVolumeList(VSSUI_VOLUME_LIST* pList);
void FreeSnapshotList(VSSUI_SNAPSHOT_LIST *pList);
void FreeDiffAreaList(VSSUI_DIFFAREA_LIST* pList);

HRESULT GetSystem32Directory(
    IN     LPCTSTR  i_pszComputer,
    OUT    PTSTR    o_pszSystem32Directory,
    IN OUT DWORD*   o_pdwSize
    );

void GetMsg(
    OUT CString& strMsg,// OUT: the message
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String resource Id
    ...);               // IN: Optional arguments

INT DoErrMsgBox(
    HWND hwndParent,    // IN: Parent of the dialog box
    UINT uType,         // IN: style of message box
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String resource Id
    ...);               // IN: Optional arguments

BOOL IsPostW2KServer(LPCTSTR pszComputer);

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\utils.cpp ===
// Utils.cpp : helper functions
//

#include "stdafx.h"
#include "utils.h"
#include <lm.h>

LONGLONG g_llKB = 1024;
LONGLONG g_llMB = 1024 * 1024;
LONGLONG g_llGB = 1024 * 1024 * 1024;

HRESULT
AddLVColumns(
  IN const HWND     hwndListBox,
  IN const INT      iStartingResourceID,
  IN const UINT     uiColumns
  )
{
  //
  // calculate the listview column width
  //
  RECT      rect;
  ZeroMemory(&rect, sizeof(rect));
  ::GetWindowRect(hwndListBox, &rect);
  int nControlWidth = rect.right - rect.left;
  int nVScrollbarWidth = GetSystemMetrics(SM_CXVSCROLL);
  int nBorderWidth = GetSystemMetrics(SM_CXBORDER);
  int nControlNetWidth = nControlWidth - 4 * nBorderWidth;
  int nWidth = nControlNetWidth / uiColumns;

  LVCOLUMN  lvColumn;
  ZeroMemory(&lvColumn, sizeof(lvColumn));
  lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

  lvColumn.fmt = LVCFMT_LEFT;
  lvColumn.cx = nWidth;

  for (UINT i = 0; i < uiColumns; i++)
  {
    CString  strColumnText;
    strColumnText.LoadString(iStartingResourceID + i);

    lvColumn.pszText = (LPTSTR)(LPCTSTR)strColumnText;
    lvColumn.iSubItem = i;

    ListView_InsertColumn(hwndListBox, i, &lvColumn);
  }

  return S_OK;
}

LPARAM GetListViewItemData(
    IN HWND hwndList,
    IN int  index
)
{
    if (-1 == index)
        return NULL;

    LVITEM lvItem;
    ZeroMemory(&lvItem, sizeof(lvItem));

    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = index;
    if (ListView_GetItem(hwndList, &lvItem))
        return lvItem.lParam;

    return NULL;
}

int MyCompareStringN(
    IN LPCTSTR  lpString1,
    IN LPCTSTR  lpString2,
    IN UINT     cchCount,
    IN DWORD    dwCmpFlags
)
{
  UINT  nLen1 = (lpString1 ? lstrlen(lpString1) : 0);
  UINT  nLen2 = (lpString2 ? lstrlen(lpString2) : 0);
  int   nRet = CompareString(
                LOCALE_USER_DEFAULT,
                dwCmpFlags,
                lpString1,
                min(cchCount, nLen1),
                lpString2,
                min(cchCount, nLen2)
              );

  return (nRet - CSTR_EQUAL);
}

int mylstrncmpi(
    IN LPCTSTR lpString1,
    IN LPCTSTR lpString2,
    IN UINT    cchCount
)
{
  return MyCompareStringN(lpString1, lpString2, cchCount, NORM_IGNORECASE);
}

HRESULT GetArgV(
    IN  LPCTSTR i_pszParameters,
    OUT UINT    *o_pargc,
    OUT void    ***o_pargv
    )
{
    if (!o_pargc || !o_pargv)
        return E_INVALIDARG;

    *o_pargc = 0;
    *o_pargv = NULL;
    
    TCHAR *p = (TCHAR *)i_pszParameters;
    while (*p && _istspace(*p))  // skip leading spaces
        p++;
    if (!*p)
        return S_FALSE; // i_pszParameters contains no parameters

    UINT nChars = lstrlen(p) + 1;
    BYTE *pbData = (BYTE *)calloc((nChars / 2) * sizeof(PTSTR *) + nChars * sizeof(TCHAR), sizeof(BYTE));
    if (!pbData)
        return E_OUTOFMEMORY;

    PTSTR *pargv = (PTSTR *)pbData;
    PTSTR t = (PTSTR)(pbData + (nChars / 2) * sizeof(PTSTR *));
    _tcscpy(t, p);

    UINT argc = 0;
    do {
        *pargv++ = t;
        argc++;

        while (*t && !_istspace(*t))    // move to the end of the token
            t++;
        if (!*t)
            break;

        *t++ = _T('\0');                // end the token with '\0'

        while (*t && _istspace(*t))     // skip leading spaces of the next token
            t++;

    } while (*t);

    *o_pargv = (void **)pbData;
    *o_pargc = argc;

    return S_OK;
}

#define TIMEWARP_CMD_APPNAME        _T("vssadmin")
#define TIMEWARP_CMD_APPEXENAME     _T("vssadmin.exe")
#define TIMEWARP_TASK_ACTION_MAJOR  _T("Create")
#define TIMEWARP_TASK_ACTION_MINOR  _T("Snapshot")
#define TIMEWARP_TASK_TYPE          _T("/Type=ClientAccessible")
#define TIMEWARP_TASK_VOLUME        _T("/For=")
#define TIMEWARP_TASK_PARAMETERS    _T("Create Snapshot /Type=ClientAccessible /AutoRetry=5 /For=")

BOOL IsTimewarpTask(
    IN LPCTSTR i_pszAppName,
    IN LPCTSTR i_pszParameters,
    IN LPCTSTR i_pszVolume
    )
{
    if (!i_pszAppName || !*i_pszAppName ||
        !i_pszParameters || !*i_pszParameters ||
        !i_pszVolume || !*i_pszVolume)
        return FALSE;

    //
    // check the application name
    //
    TCHAR *p = (PTSTR)(i_pszAppName + lstrlen(i_pszAppName) - 1);
    while (p > i_pszAppName && *p != _T('\\'))
        p--;

    if (*p == _T('\\'))
        p++;

    if (lstrcmpi(p, TIMEWARP_CMD_APPEXENAME) && lstrcmpi(p, TIMEWARP_CMD_APPNAME))
        return FALSE; // application name doesn't match

    //
    // check the parameters
    //
    BOOL bType = FALSE;
    BOOL bVolume = FALSE;

    UINT argc = 0;
    void **argv = NULL;
    if (SUCCEEDED(GetArgV(i_pszParameters, &argc, &argv)))
    {
        if (argc >= 4 &&
            !lstrcmpi((PTSTR)(argv[0]), TIMEWARP_TASK_ACTION_MAJOR) &&
            !lstrcmpi((PTSTR)(argv[1]), TIMEWARP_TASK_ACTION_MINOR))
        {
            UINT nVolume = lstrlen(TIMEWARP_TASK_VOLUME);
            for (UINT i = 2; i < argc; i++)
            {
                if (bType && bVolume)
                    break;

                if (!bType &&
                    !lstrcmpi((PTSTR)(argv[i]), TIMEWARP_TASK_TYPE))
                {
                    bType = TRUE;
                    continue;
                }

                if (!bVolume &&
                    !mylstrncmpi((PTSTR)(argv[i]), TIMEWARP_TASK_VOLUME, nVolume) &&
                    !lstrcmpi((PTSTR)(argv[i]) + nVolume, i_pszVolume))
                {
                    bVolume = TRUE;
                    continue;
                }
            }
        }
        
        if (argv)
            free(argv);
    }
    
    return (bType && bVolume);
}

#define NUM_OF_TASKS            5

//
// Find the first enabled Timewarp task, skip all disabled tasks.
//
HRESULT FindScheduledTimewarpTask(
    IN  ITaskScheduler* i_piTS,
    IN  LPCTSTR         i_pszVolumeDisplayName,
    OUT ITask**         o_ppiTask,
    OUT PTSTR*          o_ppszTaskName /* = NULL */
    ) 
{
    if (!i_piTS ||
        !i_pszVolumeDisplayName || !*i_pszVolumeDisplayName ||
        !o_ppiTask)
        return E_INVALIDARG;

    *o_ppiTask = NULL;
    if (o_ppszTaskName)
        *o_ppszTaskName = NULL;

    /////////////////////////////////////////////////////////////////
    // Call ITaskScheduler::Enum to get an enumeration object.
    /////////////////////////////////////////////////////////////////
    CComPtr<IEnumWorkItems> spiEnum;
    HRESULT hr = i_piTS->Enum(&spiEnum);
    if (FAILED(hr))
        return hr;  
  
    /////////////////////////////////////////////////////////////////
    // Call IEnumWorkItems::Next to retrieve tasks. Note that 
    // this example tries to retrieve five tasks for each call.
    /////////////////////////////////////////////////////////////////
    BOOL    bTimewarpTask = FALSE;
    BOOL    bEnabled = FALSE;
    SYSTEMTIME stNextRun = {0};
    LPTSTR *ppszNames = NULL;
    DWORD   dwFetchedTasks = 0;
    while (!bTimewarpTask && SUCCEEDED(spiEnum->Next(NUM_OF_TASKS, &ppszNames, &dwFetchedTasks)) && (dwFetchedTasks != 0))
    {
        ///////////////////////////////////////////////////////////////
        // Process each task.
        //////////////////////////////////////////////////////////////
        while (!bTimewarpTask && dwFetchedTasks)
        {
            LPTSTR pszTaskName = ppszNames[--dwFetchedTasks];

            ///////////////////////////////////////////////////////////////////
            // Call ITaskScheduler::Activate to get the Task object.
            ///////////////////////////////////////////////////////////////////
            CComPtr<ITask> spiTask;
            hr = i_piTS->Activate(pszTaskName,
                                IID_ITask,
                                (IUnknown**) &spiTask);
            if (SUCCEEDED(hr))
            {
                LPTSTR pszApplicationName = NULL;
                hr = spiTask->GetApplicationName(&pszApplicationName);
                if (SUCCEEDED(hr))
                {
                    LPTSTR pszParameters = NULL;
                    hr = spiTask->GetParameters(&pszParameters);
                    if (SUCCEEDED(hr))
                    {
                        if (IsTimewarpTask(pszApplicationName, pszParameters, i_pszVolumeDisplayName))
                        {
                            bEnabled = FALSE;
                            GetScheduledTimewarpTaskStatus(spiTask, &bEnabled, &stNextRun);
                            if (bEnabled)
                                bTimewarpTask = TRUE;
                        }
                        CoTaskMemFree(pszParameters);
                    }

                    CoTaskMemFree(pszApplicationName);
                }

                if (bTimewarpTask)
                {
                    if (o_ppszTaskName)
                    {
                        // omit the ending .job
                        int nLen = lstrlen(pszTaskName);
                        BOOL bEndingFound = (nLen > 4 && !lstrcmpi(pszTaskName + nLen - 4, _T(".job")));
                        if (bEndingFound)
                            *(pszTaskName + nLen - 4) = _T('\0');

                        *o_ppszTaskName = _tcsdup(pszTaskName);
                        if (bEndingFound)
                            *(pszTaskName + nLen - 4) = _T('.');

                        if (!*o_ppszTaskName)
                            hr = E_OUTOFMEMORY;
                    }

                    if (SUCCEEDED(hr))
                    {
                        *o_ppiTask = (ITask *)spiTask;
                        spiTask.Detach();
                    }
                }
            }

            CoTaskMemFree(ppszNames[dwFetchedTasks]);
        }
        CoTaskMemFree(ppszNames);
    }
  
    if (FAILED(hr))
        return hr;

    return (bTimewarpTask ? S_OK : S_FALSE);
}

HRESULT GetScheduledTimewarpTaskStatus(
    IN  ITask*          i_piTask,
    OUT BOOL*           o_pbEnabled,
    OUT SYSTEMTIME*     o_pstNextRunTime
    ) 
{
    if (!i_piTask ||
        !o_pbEnabled || !o_pstNextRunTime)
        return E_INVALIDARG;

    *o_pbEnabled = FALSE;
    ZeroMemory(o_pstNextRunTime, sizeof(SYSTEMTIME));

    HRESULT hrStatus = S_OK;
    HRESULT hr = i_piTask->GetStatus(&hrStatus);
    if (SUCCEEDED(hr))
    {
        switch (hrStatus)
        {
        case SCHED_S_TASK_HAS_NOT_RUN:
        case SCHED_S_TASK_READY:
        case SCHED_S_TASK_RUNNING:
            {
                hr = i_piTask->GetNextRunTime(o_pstNextRunTime);
                if (S_OK == hr)
                    *o_pbEnabled = TRUE;
            }
            break;
        default:
            break;
        }
    }
  
    return hr;
}

HRESULT CreateDefaultEnableSchedule(
    IN  ITaskScheduler* i_piTS,
    IN  LPCTSTR         i_pszComputer,
    IN  LPCTSTR         i_pszVolumeDisplayName,
    IN  LPCTSTR         i_pszVolumeName,
    OUT ITask**         o_ppiTask,      
    OUT PTSTR*          o_ppszTaskName /* = NULL */
    )
{
    if (!i_piTS ||
        !i_pszVolumeDisplayName || !*i_pszVolumeDisplayName ||
        !i_pszVolumeName || !*i_pszVolumeName ||
        !o_ppiTask)
        return E_INVALIDARG;

    *o_ppiTask = NULL;
    if (o_ppszTaskName)
        *o_ppszTaskName = NULL;

    HRESULT hr = S_OK;
    do
    {
        //
        // i_pszVolumeName is in the form of \\?\Volume{xxx.....xxx}\
        // The task name will be EnableVSSOn concatenating with Volume{xxx.....xxx}
        //
        TCHAR szTaskName[MAX_PATH] = _T("EnableVSSOn");
        _tcscat(szTaskName, i_pszVolumeName + 4); // skip the beginning "\\?\"
        TCHAR *p = szTaskName + lstrlen(szTaskName) - 1;
        if (*p == _T('\\'))
            *p = _T('\0'); // remove the ending whack

        if (o_ppszTaskName)
        {
            *o_ppszTaskName = _tcsdup(szTaskName);
            if (!*o_ppszTaskName)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }

        //
        // delete any task that has the same name
        //
        (void)i_piTS->Delete(szTaskName);

        CComPtr<ITask> spiTask;
        hr = i_piTS->NewWorkItem(szTaskName,      // Name of task
                         CLSID_CTask,            // Class identifier 
                         IID_ITask,              // Interface identifier
                         (IUnknown**)&spiTask);  // Address of task interface
        if (FAILED(hr))
            break;

        TCHAR szSystem32Directory[MAX_PATH];
        DWORD dwSize = sizeof(szSystem32Directory) / sizeof(TCHAR);
        hr = GetSystem32Directory(i_pszComputer, szSystem32Directory, &dwSize);
        if (FAILED(hr))
            break;

        hr = spiTask->SetWorkingDirectory(szSystem32Directory);
        if (FAILED(hr))
            break;

        TCHAR szApplicationName[MAX_PATH];
        _tcscpy(szApplicationName, szSystem32Directory);
        _tcscat(szApplicationName, _T("\\vssadmin.exe"));
        hr = spiTask->SetApplicationName(szApplicationName);
        if (FAILED(hr))
            break;

        TCHAR szParameters[MAX_PATH] = TIMEWARP_TASK_PARAMETERS;
        _tcscat(szParameters, i_pszVolumeDisplayName);
        hr = spiTask->SetParameters(szParameters);
        if (FAILED(hr))
            break;

        // run as local system account
        hr = spiTask->SetAccountInformation(_T(""), NULL);
        if (FAILED(hr))
            break;

        SYSTEMTIME st = {0};
        GetSystemTime(&st);

        WORD wStartHours[] = {7, 12};
        for (DWORD i = 0; i < sizeof(wStartHours)/sizeof(wStartHours[0]); i++)
        {
            ///////////////////////////////////////////////////////////////////
            // Call ITask::CreateTrigger to create new trigger.
            ///////////////////////////////////////////////////////////////////
            CComPtr<ITaskTrigger> spiTaskTrigger;
            WORD piNewTrigger;
            hr = spiTask->CreateTrigger(&piNewTrigger, &spiTaskTrigger);
            if (FAILED(hr))
                break;

            //////////////////////////////////////////////////////
            // Define TASK_TRIGGER structure. Note that wBeginDay,
            // wBeginMonth, and wBeginYear must be set to a valid 
            // day, month, and year respectively.
            //////////////////////////////////////////////////////
            TASK_TRIGGER Trigger;
            ZeroMemory(&Trigger, sizeof(TASK_TRIGGER));
            Trigger.wBeginDay =st.wDay;
            Trigger.wBeginMonth =st.wMonth;
            Trigger.wBeginYear =st.wYear;
            Trigger.cbTriggerSize = sizeof(TASK_TRIGGER); 
            Trigger.wStartHour = wStartHours[i];
            Trigger.TriggerType = TASK_TIME_TRIGGER_WEEKLY;
            Trigger.Type.Weekly.WeeksInterval = 1;
            Trigger.Type.Weekly.rgfDaysOfTheWeek = TASK_MONDAY | TASK_TUESDAY | TASK_WEDNESDAY | TASK_THURSDAY | TASK_FRIDAY;

            ///////////////////////////////////////////////////////////////////
            // Call ITaskTrigger::SetTrigger to set trigger criteria.
            ///////////////////////////////////////////////////////////////////
            hr = spiTaskTrigger->SetTrigger(&Trigger);
            if (FAILED(hr))
                break;
        }
        if (FAILED(hr))
            break;

        ///////////////////////////////////////////////////////////////////
        // Call IPersistFile::Save to save trigger to disk.
        ///////////////////////////////////////////////////////////////////
        CComPtr<IPersistFile> spiPersistFile;
        hr = spiTask->QueryInterface(IID_IPersistFile, (void **)&spiPersistFile);
        if (FAILED(hr))
            break;

        hr = spiPersistFile->Save(NULL, TRUE);

        if (SUCCEEDED(hr))
        {
            *o_ppiTask = (ITask *)spiTask;
            spiTask.Detach();
        }

    } while(0);


    if (FAILED(hr))
    {
        if (o_ppszTaskName && *o_ppszTaskName)
        {
            free(*o_ppszTaskName);
            *o_ppszTaskName = NULL;
        }
    }

    return hr;
}

HRESULT DeleteAllScheduledTimewarpTasks(
    IN ITaskScheduler* i_piTS,
    IN LPCTSTR         i_pszVolumeDisplayName,
    IN BOOL            i_bDeleteDisabledOnesOnly
    ) 
{
    if (!i_piTS ||
        !i_pszVolumeDisplayName || !*i_pszVolumeDisplayName)
        return E_INVALIDARG;

    /////////////////////////////////////////////////////////////////
    // Call ITaskScheduler::Enum to get an enumeration object.
    /////////////////////////////////////////////////////////////////
    CComPtr<IEnumWorkItems> spiEnum;
    HRESULT hr = i_piTS->Enum(&spiEnum);
  
    /////////////////////////////////////////////////////////////////
    // Call IEnumWorkItems::Next to retrieve tasks. Note that 
    // this example tries to retrieve five tasks for each call.
    /////////////////////////////////////////////////////////////////
    BOOL        bEnabled = FALSE;
    SYSTEMTIME  stNextRun = {0};
    LPTSTR *ppszNames = NULL;
    DWORD   dwFetchedTasks = 0;
    while (SUCCEEDED(hr) && SUCCEEDED(spiEnum->Next(NUM_OF_TASKS, &ppszNames, &dwFetchedTasks)) && (dwFetchedTasks != 0))
    {
        ///////////////////////////////////////////////////////////////
        // Process each task.
        //////////////////////////////////////////////////////////////
        while (SUCCEEDED(hr) && dwFetchedTasks)
        {
            LPTSTR pszTaskName = ppszNames[--dwFetchedTasks];

            ///////////////////////////////////////////////////////////////////
            // Call ITaskScheduler::Activate to get the Task object.
            ///////////////////////////////////////////////////////////////////
            CComPtr<ITask> spiTask;
            hr = i_piTS->Activate(pszTaskName,
                                IID_ITask,
                                (IUnknown**) &spiTask);
            if (SUCCEEDED(hr))
            {
                LPTSTR pszApplicationName = NULL;
                hr = spiTask->GetApplicationName(&pszApplicationName);
                if (SUCCEEDED(hr))
                {
                    LPTSTR pszParameters = NULL;
                    hr = spiTask->GetParameters(&pszParameters);
                    if (SUCCEEDED(hr))
                    {
                        if (IsTimewarpTask(pszApplicationName, pszParameters, i_pszVolumeDisplayName))
                        {
                            if (i_bDeleteDisabledOnesOnly)
                            {
                                bEnabled = FALSE;
                                GetScheduledTimewarpTaskStatus(spiTask, &bEnabled, &stNextRun);
                                if (!bEnabled)
                                    hr = i_piTS->Delete(pszTaskName);
                            } else
                            {
                                hr = i_piTS->Delete(pszTaskName);
                            }
                        }

                        CoTaskMemFree(pszParameters);
                    }

                    CoTaskMemFree(pszApplicationName);
                }
            }

            CoTaskMemFree(ppszNames[dwFetchedTasks]);
        }
        CoTaskMemFree(ppszNames);
    }
  
    return hr;
}

HRESULT VssTimeToSystemTime(
    IN  VSS_TIMESTAMP*  i_pVssTime,
    OUT SYSTEMTIME*     o_pSystemTime
    )
{
    if (!o_pSystemTime)
        return E_INVALIDARG;

    SYSTEMTIME stLocal = {0};
    FILETIME ftLocal = {0};

    if (!i_pVssTime)
    {
        SYSTEMTIME sysTime = {0};
        FILETIME fileTime = {0};
        
        //  Get current time
        ::GetSystemTime(&sysTime);

        //  Convert system time to file time
        ::SystemTimeToFileTime(&sysTime, &fileTime);
        
        //  Compensate for local TZ
        ::FileTimeToLocalFileTime(&fileTime, &ftLocal);
    } else
    {        
        //  Compensate for local TZ
        ::FileTimeToLocalFileTime((FILETIME *)i_pVssTime, &ftLocal);
    }

    //  Finally convert it to system time
    ::FileTimeToSystemTime(&ftLocal, o_pSystemTime);

    return S_OK;
}

HRESULT SystemTimeToString(
    IN      SYSTEMTIME* i_pSystemTime,
    OUT     PTSTR       o_pszText,
    IN OUT  DWORD*      io_pdwSize   
    )
{
    if (!i_pSystemTime || !o_pszText || !io_pdwSize)
        return E_INVALIDARG;

    //  Convert to a date string
    TCHAR pszDate[64];
    ::GetDateFormat(GetThreadLocale( ),
                    DATE_SHORTDATE,
                    i_pSystemTime,
                    NULL,
                    pszDate,
                    sizeof(pszDate) / sizeof(TCHAR));

    //  Convert to a time string
    TCHAR pszTime[64];
    ::GetTimeFormat(GetThreadLocale( ),
                    TIME_NOSECONDS,
                    i_pSystemTime,
                    NULL,
                    pszTime,
                    sizeof( pszTime ) / sizeof(TCHAR));

    CString strMsg;
    strMsg.Format(IDS_DATE_TIME, pszDate, pszTime);
    DWORD dwRequiredSize = strMsg.GetLength() + 1;
    if (*io_pdwSize < dwRequiredSize)
    {
        *io_pdwSize = dwRequiredSize;
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    *io_pdwSize = dwRequiredSize;
    _stprintf(o_pszText, strMsg);

    return S_OK;    
}

HRESULT DiskSpaceToString(
    IN      LONGLONG    i_llDiskSpace,
    OUT     PTSTR       o_pszText,
    IN OUT  DWORD*      io_pdwSize   
    )
{
    if (!o_pszText || !io_pdwSize)
        return E_INVALIDARG;

    CString strMsg;
    if (i_llDiskSpace < g_llKB)
        strMsg.Format(IDS_SPACE_LABEL_B, i_llDiskSpace);
    else if (i_llDiskSpace < g_llMB)
        strMsg.Format(IDS_SPACE_LABEL_KB, i_llDiskSpace / g_llKB);
    else if (i_llDiskSpace < g_llGB)
        strMsg.Format(IDS_SPACE_LABEL_MB, i_llDiskSpace / g_llMB);
    else
        strMsg.Format(IDS_SPACE_LABEL_GB, i_llDiskSpace / g_llGB);

    DWORD dwRequiredSize = strMsg.GetLength() + 1;
    if (*io_pdwSize < dwRequiredSize)
    {
        *io_pdwSize = dwRequiredSize;
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    *io_pdwSize = dwRequiredSize;
    _tcscpy(o_pszText, strMsg);

    return S_OK;
}

HRESULT GetVolumeSpace(
    IN  IVssDifferentialSoftwareSnapshotMgmt* piDiffSnapMgmt,
    IN  LPCTSTR     i_pszVolumeDisplayName,
    OUT LONGLONG*   o_pllVolumeTotalSpace,  // = NULL
    OUT LONGLONG*   o_pllVolumeFreeSpace    // = NULL
    )
{
    if (!piDiffSnapMgmt ||
        !i_pszVolumeDisplayName || !*i_pszVolumeDisplayName ||
        !o_pllVolumeTotalSpace && !o_pllVolumeFreeSpace)
        return E_INVALIDARG;

    CComPtr<IVssEnumMgmtObject> spiEnum;
    HRESULT hr = piDiffSnapMgmt->QueryVolumesSupportedForDiffAreas(&spiEnum);
    if (FAILED(hr))
        return hr;

    BOOL bFound = FALSE;
    VSS_MGMT_OBJECT_PROP Prop;
    VSS_DIFF_VOLUME_PROP *pDiffVolProp = &(Prop.Obj.DiffVol);
    ULONG ulFetched = 0;
    while (!bFound && SUCCEEDED(spiEnum->Next(1, &Prop, &ulFetched)) && ulFetched > 0)
    {
        if (VSS_MGMT_OBJECT_DIFF_VOLUME != Prop.Type)
            return E_FAIL;

        if (!lstrcmpi(i_pszVolumeDisplayName, pDiffVolProp->m_pwszVolumeDisplayName))
        {
            bFound = TRUE;
            if (o_pllVolumeTotalSpace)
                *o_pllVolumeTotalSpace = pDiffVolProp->m_llVolumeTotalSpace;

            if (o_pllVolumeFreeSpace)
                *o_pllVolumeFreeSpace = pDiffVolProp->m_llVolumeFreeSpace;
        }

        CoTaskMemFree(pDiffVolProp->m_pwszVolumeName);
        CoTaskMemFree(pDiffVolProp->m_pwszVolumeDisplayName);
    }

    return (bFound ? S_OK : S_FALSE);
}

HRESULT GetDiffAreaInfo(
    IN  IVssDifferentialSoftwareSnapshotMgmt* piDiffSnapMgmt,
    IN  VSSUI_VOLUME_LIST*  pVolumeList,
    IN  LPCTSTR             pszVolumeName,
    OUT VSSUI_DIFFAREA*     pDiffArea
    )
{
    if (!piDiffSnapMgmt ||
        !pVolumeList ||
        !pszVolumeName || !*pszVolumeName ||
        !pDiffArea)
        return E_INVALIDARG;

    ZeroMemory(pDiffArea, sizeof(VSSUI_DIFFAREA));

    CComPtr<IVssEnumMgmtObject> spiEnumMgmtDiffArea;
    HRESULT hr = piDiffSnapMgmt->QueryDiffAreasForVolume(
                            (PTSTR)pszVolumeName,
                            &spiEnumMgmtDiffArea);
    if (S_OK == hr)
    {
        VSS_MGMT_OBJECT_PROP Prop;
        VSS_DIFF_AREA_PROP *pDiffAreaProp = &(Prop.Obj.DiffArea);
        ULONG ulDiffFetched = 0;
        hr = spiEnumMgmtDiffArea->Next(1, &Prop, &ulDiffFetched);
        if (SUCCEEDED(hr) && ulDiffFetched > 0)
        {
            if (VSS_MGMT_OBJECT_DIFF_AREA != Prop.Type || 1 != ulDiffFetched)
                return E_FAIL;

            PTSTR pszVolumeDisplayName = GetDisplayName(pVolumeList, pDiffAreaProp->m_pwszVolumeName);
            PTSTR pszDiffVolumeDisplayName = GetDisplayName(pVolumeList, pDiffAreaProp->m_pwszDiffAreaVolumeName);
            ASSERT(pszVolumeDisplayName);
            ASSERT(pszDiffVolumeDisplayName);

            _tcscpy(pDiffArea->pszVolumeDisplayName, pszVolumeDisplayName);
            _tcscpy(pDiffArea->pszDiffVolumeDisplayName, pszDiffVolumeDisplayName);
            pDiffArea->llMaximumDiffSpace = pDiffAreaProp->m_llMaximumDiffSpace;
            pDiffArea->llUsedDiffSpace = pDiffAreaProp->m_llUsedDiffSpace;

            CoTaskMemFree(pDiffAreaProp->m_pwszVolumeName);
            CoTaskMemFree(pDiffAreaProp->m_pwszDiffAreaVolumeName);
        }
    }

    return hr;
}

PTSTR GetDisplayName(VSSUI_VOLUME_LIST *pVolumeList, LPCTSTR pszVolumeName)
{
    if (!pVolumeList || !pszVolumeName || !*pszVolumeName)
        return NULL;

    for (VSSUI_VOLUME_LIST::iterator i = pVolumeList->begin(); i != pVolumeList->end(); i++)
    {
        if (!lstrcmpi(pszVolumeName, (*i)->pszVolumeName))
            return (*i)->pszDisplayName;
    }

    return NULL;
}

PTSTR GetVolumeName(VSSUI_VOLUME_LIST *pVolumeList, LPCTSTR pszDisplayName)
{
    if (!pVolumeList || !pszDisplayName || !*pszDisplayName)
        return NULL;

    for (VSSUI_VOLUME_LIST::iterator i = pVolumeList->begin(); i != pVolumeList->end(); i++)
    {
        if (!lstrcmpi(pszDisplayName, (*i)->pszDisplayName))
            return (*i)->pszVolumeName;
    }

    return NULL;
}

void FreeVolumeList(VSSUI_VOLUME_LIST *pList)
{
    if (!pList || pList->empty())
        return;

    for (VSSUI_VOLUME_LIST::iterator i = pList->begin(); i != pList->end(); i++)
        free(*i);

    pList->clear();
}

void FreeSnapshotList(VSSUI_SNAPSHOT_LIST *pList)
{
    if (!pList || pList->empty())
        return;

    for (VSSUI_SNAPSHOT_LIST::iterator i = pList->begin(); i != pList->end(); i++)
        free(*i);

    pList->clear();
}

void FreeDiffAreaList(VSSUI_DIFFAREA_LIST *pList)
{
    if (!pList || pList->empty())
        return;

    for (VSSUI_DIFFAREA_LIST::iterator i = pList->begin(); i != pList->end(); i++)
        free(*i);

    pList->clear();
}

HRESULT GetSystem32Directory(
    IN     LPCTSTR  i_pszComputer,
    OUT    PTSTR    o_pszSystem32Directory,
    IN OUT DWORD*   o_pdwSize
    )
{
    if (!o_pszSystem32Directory)
        return E_INVALIDARG;

    SHARE_INFO_2 *pInfo = NULL;
    DWORD dwRet = NetShareGetInfo((PTSTR)i_pszComputer, _T("ADMIN$"), 2, (LPBYTE *)&pInfo);
    if (NERR_Success == dwRet)
    {
        TCHAR szDir[MAX_PATH];
        _tcscpy(szDir, pInfo->shi2_path);
        if (_T('\\') != szDir[lstrlen(szDir) - 1])
            _tcscat(szDir, _T("\\system32"));
        else
            _tcscat(szDir, _T("system32"));

        DWORD dwRequiredLength = lstrlen(szDir) + 1;
        if (*o_pdwSize < dwRequiredLength)
            dwRet = ERROR_INSUFFICIENT_BUFFER;
        else
            _tcscpy(o_pszSystem32Directory, szDir);

        *o_pdwSize = dwRequiredLength;
    }

    if (pInfo)
        NetApiBufferFree(pInfo);

    return HRESULT_FROM_WIN32(dwRet);
}

HRESULT GetErrorMessageFromModule(
    IN  DWORD       dwError,
    IN  LPCTSTR     lpszDll,
    OUT LPTSTR      *ppBuffer
)
{
    if (0 == dwError || !lpszDll || !*lpszDll || !ppBuffer)
        return E_INVALIDARG;

    HRESULT      hr = S_OK;

    HINSTANCE  hMsgLib = LoadLibrary(lpszDll);
    if (!hMsgLib)
        hr = HRESULT_FROM_WIN32(GetLastError());
    else
    {
        DWORD dwRet = ::FormatMessage(
                            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                            hMsgLib, dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (LPTSTR)ppBuffer, 0, NULL);

        if (0 == dwRet)
            hr = HRESULT_FROM_WIN32(GetLastError());

        FreeLibrary(hMsgLib);
    }

    return hr;
}

HRESULT GetErrorMessage(
    IN  DWORD        i_dwError,
    OUT CString&     cstrErrorMsg
)
{
    if (0 == i_dwError)
        return E_INVALIDARG;

    HRESULT      hr = S_OK;
    LPTSTR       lpBuffer = NULL;

    DWORD dwRet = ::FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL, i_dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                        (LPTSTR)&lpBuffer, 0, NULL);
    if (0 == dwRet)
    {
        // if no message is found, GetLastError will return ERROR_MR_MID_NOT_FOUND
        hr = HRESULT_FROM_WIN32(GetLastError());

        if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hr ||
            0x80070000 == (i_dwError & 0xffff0000) ||
            0 == (i_dwError & 0xffff0000) )
        {
            hr = GetErrorMessageFromModule((i_dwError & 0x0000ffff), _T("netmsg.dll"), &lpBuffer);
        }
    }

    if (SUCCEEDED(hr))
    {
        cstrErrorMsg = lpBuffer;
        LocalFree(lpBuffer);
    }
    else
    {
        // we failed to retrieve the error message from system/netmsg.dll/sfmmsg.dll,
        // report the error code directly to user
        hr = S_OK;
        cstrErrorMsg.Format(_T("0x%x"), i_dwError);
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////
//    GetMsgHelper()
//
//    This function will retrieve the error msg if dwErr is specified,
//    load resource string if specified, and format the string with
//    the error msg and other optional arguments.
//
//
HRESULT GetMsgHelper(
    OUT CString& strMsg,// OUT: the message
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String ID
    va_list* parglist   // IN: OPTIONAL arguments
    )
{
    if (!dwErr && !wIdString) 
        return E_INVALIDARG;

    //
    // retrieve error msg
    //
    CString strErrorMessage;
    if (dwErr != 0)
        GetErrorMessage(dwErr, strErrorMessage);

    //
    // load string resource, and format it with the error msg and 
    // other optional arguments
    //
    if (wIdString == 0)
    {
        strMsg = strErrorMessage;
    } else
    {
        CString strFormat;
        strFormat.LoadString(wIdString);

	    CString strFormatedMsg;
        strFormatedMsg.FormatV(strFormat, *parglist); 

        if (dwErr == 0)
            strMsg = strFormatedMsg;
        else 
            strMsg.FormatMessage((((HRESULT)dwErr < 0) ? IDS_ERROR_HR : IDS_ERROR),
            strFormatedMsg,
            dwErr,
            strErrorMessage);
    }

    return S_OK;
} // GetMsgHelper()

/////////////////////////////////////////////////////////////////////
//    GetMsg()
//
//    This function will call GetMsgHelp to retrieve the error msg
//    if dwErr is specified, load resource string if specified, and
//    format the string with the error msg and other optional arguments.
//
//
void GetMsg(
    OUT CString& strMsg,// OUT: the message
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String resource Id
    ...)                // IN: Optional arguments
{
    va_list arglist;
    va_start(arglist, wIdString);

    HRESULT hr = GetMsgHelper(strMsg, dwErr, wIdString, &arglist);
    if (FAILED(hr))
        strMsg.Format(_T("0x%x"), hr);

    va_end(arglist);

} // GetMsg()

/////////////////////////////////////////////////////////////////////
//    DoErrMsgBox()
//
//    Display a message box for the error code.  This function will
//    load the error message from the system resource and append
//    the optional string (if any)
//
//    EXAMPLE
//        DoErrMsgBox(GetActiveWindow(), MB_OK, GetLastError(), IDS_s_FILE_READ_ERROR, L"foo.txt");
//
INT DoErrMsgBox(
    HWND hwndParent,    // IN: Parent of the dialog box
    UINT uType,         // IN: style of message box
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String resource Id
    ...)                // IN: Optional arguments
{
    //
    // get string and the error msg
    //
    va_list arglist;
    va_start(arglist, wIdString);

    CString strMsg;
    HRESULT hr = GetMsgHelper(strMsg, dwErr, wIdString, &arglist);
    if (FAILED(hr))
        strMsg.Format(_T("0x%x"), hr);

    va_end(arglist);

    //
    // Load the caption
    //
    CString strCaption;
    strCaption.LoadString(IDS_PROJNAME);

    //
    // Display the message.
    //
    return ::MessageBox(hwndParent, strMsg, strCaption, uType);

}

BOOL IsPostW2KServer(LPCTSTR pszComputer)
{
    BOOL bPostW2KServer = FALSE;
    SERVER_INFO_101* pServerInfo = NULL;
    DWORD dwRet = NetServerGetInfo((LPTSTR)pszComputer, 101, (LPBYTE*)&pServerInfo);
    if (NERR_Success == dwRet)
    {
        bPostW2KServer = (pServerInfo->sv101_type & SV_TYPE_NT) &&          // NT/W2K/XP or after
            (pServerInfo->sv101_version_major & MAJOR_VERSION_MASK) >= 5 &&
            pServerInfo->sv101_version_minor > 0 &&                         // XP or after
            ((pServerInfo->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
             (pServerInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) ||
             (pServerInfo->sv101_type & SV_TYPE_SERVER_NT));                // server

        NetApiBufferFree(pServerInfo);
    }

    return bPostW2KServer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\vssui.cpp ===
// vssui.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f vssps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "vssui.h"

#include "vssui_i.c"
#include "vsspage.h"
#include "snapext.h"
#include "ShlExt.h"

#include <shfusion.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_VSSUI, CVSSUI)
OBJECT_ENTRY(CLSID_VSSShellExt, CVSSShellExt)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
CVssPageApp theApp;

BOOL CVssPageApp::InitInstance()
{
//    _Module.Init(ObjectMap, m_hInstance, &LIBID_VSSUILib);
    _Module.Init(ObjectMap, m_hInstance);
    SHFusionInitializeFromModuleID (m_hInstance, 2);
    DisableThreadLibraryCalls(m_hInstance);
    return CWinApp::InitInstance();
}

int CVssPageApp::ExitInstance()
{
    // MFC's class factories registration is
    // automatically revoked by MFC itself.
    if (m_bRun)
        _Module.RevokeClassObjects();

    SHFusionUninitialize();

    _Module.Term();
	return 0;
}

/*
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_VSSUILib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}
*/

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\server\vssui\vssprop.h ===
#if !defined(AFX_VSSPROP_H__CB712178_310D_4459_9927_E0CAF69C7FA1__INCLUDED_)
#define AFX_VSSPROP_H__CB712178_310D_4459_9927_E0CAF69C7FA1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CVSSProp.h : header file
//

#include "utils.h"

#include <shlobj.h>

#include <vsmgmt.h>
#include <vscoordint.h>

/////////////////////////////////////////////////////////////////////////////
// CVSSProp dialog

class CVSSProp : public CPropertyPage
{
	DECLARE_DYNCREATE(CVSSProp)

// Construction
public:
	CVSSProp();
	CVSSProp(LPCTSTR pszComputer, LPCTSTR pszVolume);
	~CVSSProp();

// Dialog Data
	//{{AFX_DATA(CVSSProp)
	enum { IDD = IDD_VSSPROP };
	CButton	m_ctrlSettings;
	CButton	m_ctrlDisable;
	CButton	m_ctrlEnable;
	CListCtrl	m_ctrlVolumeList;
	CListCtrl	m_ctrlSnapshotList;
	CButton	m_ctrlDelete;
	CButton	m_ctrlCreate;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CVSSProp)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
    void _ResetInterfacePointers();
    HRESULT InitInterfacePointers();
    HRESULT GetVolumes();
    HRESULT StoreShellExtPointer(IShellPropSheetExt* piShellExt);
    HRESULT InsertVolumeInfo(HWND hwnd);

    HRESULT UpdateDiffArea();
    HRESULT UpdateDiffArea(int nIndex, LPCTSTR pszVolumeName);
    HRESULT InsertDiffAreaInfo(HWND hwnd);

    HRESULT InsertShareInfo(HWND hwnd);

    HRESULT UpdateSchedule();
    HRESULT UpdateSchedule(int nIndex, LPCTSTR pszVolumeDisplayName);
    void UpdateSchedule(ITask * i_piTask, int nIndex);
    HRESULT InsertScheduleInfo(HWND hwnd);

    void SelectVolume(HWND hwnd);

    HRESULT GetSnapshots(LPCTSTR pszVolume);
    HRESULT UpdateSnapshotList();

    HRESULT TakeOneSnapshotNow(IN LPCTSTR pszVolumeName);
    HRESULT DoEnable();
    HRESULT DoDisable();
    HRESULT DeleteAllSnapshotsOnVolume(IN LPCTSTR pszVolumeName);

protected:
    CString m_strComputer;
    CString m_strSelectedVolume;

    CComPtr<IShellPropSheetExt> m_spiShellExt;

    CComPtr<IVssSnapshotMgmt>   m_spiMgmt;
    CComPtr<IVssCoordinator>    m_spiCoord;
    CComPtr<IVssDifferentialSoftwareSnapshotMgmt> m_spiDiffSnapMgmt;
    CComPtr<ITaskScheduler>     m_spiTS;

    VSSUI_VOLUME_LIST           m_VolumeList;
    VSSUI_SNAPSHOT_LIST         m_SnapshotList;

	// Generated message map functions
	//{{AFX_MSG(CVSSProp)
	afx_msg void OnCreateNow();
	afx_msg void OnDeleteNow();
	afx_msg void OnItemchangedSnapshotList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedVolumeList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	virtual BOOL OnInitDialog();
	afx_msg void OnEnable();
	afx_msg void OnDisable();
	afx_msg void OnSettings();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VSSPROP_H__CB712178_310D_4459_9927_E0CAF69C7FA1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\tests\betest\cwriter.cpp ===
#include "stdafx.hxx"
#include "vss.h"
#include "vswriter.h"
#include "cwriter.h"
#include "debug.h"
#include "time.h"
#include "msxml.h"

#define IID_PPV_ARG( Type, Expr ) IID_##Type, reinterpret_cast< void** >( static_cast< Type** >( Expr ) )
#define SafeQI( Type, Expr ) QueryInterface( IID_PPV_ARG( Type, Expr ) )

static BYTE x_rgbIcon[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
static unsigned x_cbIcon = 10;


static VSS_ID s_WRITERID =
	{
	0xc0577ae6, 0xd741, 0x452a,
	0x8c, 0xba, 0x99, 0xd7, 0x44, 0x00, 0x8c, 0x04
	};

static LPCWSTR s_WRITERNAME = L"BeTest Writer";

void CTestVssWriter::Initialize()
	{
	HRESULT hr;

	CHECK_SUCCESS(CVssWriter::Initialize
					(
					s_WRITERID,
					s_WRITERNAME,
					VSS_UT_USERDATA,
					VSS_ST_OTHER
					));
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnIdentify(IN IVssCreateWriterMetadata *pMetadata)
	{
	HRESULT hr;

	if (m_lWait & x_maskWaitGatherWriterMetadata)
		{
		wprintf(L"OnIdentify sleeping 20 seconds.\n");
		Sleep(20000);
		}

	CHECK_SUCCESS(pMetadata->AddIncludeFiles
					(
					L"%systemroot%\\config",
					L"mytestfiles.*",
					false,
					NULL
					));

    CHECK_SUCCESS(pMetadata->AddExcludeFiles
						(
						L"%systemroot%\\config",
						L"*.tmp",
						true
						));

    CHECK_SUCCESS(pMetadata->AddComponent
						(
						VSS_CT_DATABASE,
						L"\\mydatabases",
						L"db1",
						L"this is my main database",
						x_rgbIcon,
						x_cbIcon,
						true,
						true,
						true
						));

    CHECK_SUCCESS(pMetadata->AddDatabaseFiles
					(
					L"\\mydatabases",
					L"db1",
					L"e:\\databases",
					L"foo.db"
					));

    CHECK_SUCCESS(pMetadata->AddDatabaseLogFiles
					(
					L"\\mydatabases",
					L"db1",
					L"e:\\logs",
					L"foo.log"
					));

    CHECK_SUCCESS(pMetadata->SetRestoreMethod
					(
					VSS_RME_RESTORE_IF_NOT_THERE,
					NULL,
					NULL,
					VSS_WRE_ALWAYS,
					true
					));

    CHECK_SUCCESS(pMetadata->AddAlternateLocationMapping
					(
					L"c:\\databases",
					L"*.db",
					false,
					L"e:\\databases\\restore"
					));

    CHECK_SUCCESS(pMetadata->AddAlternateLocationMapping
					(
					L"d:\\logs",
					L"*.log",
					false,
					L"e:\\databases\\restore"
					));


	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnPrepareBackup(IN IVssWriterComponents *pWriterComponents)
	{
	unsigned cComponents;
	LPCWSTR wszBackupType;

	if (m_lWait & x_maskWaitPrepareBackup)
		{
		wprintf(L"OnPrepareBackup sleeping 10 seconds.\n");
		Sleep(10000);
		}

	switch(GetBackupType())
		{
		default:
			wszBackupType = L"undefined";
			break;

		case VSS_BT_FULL:
			wszBackupType = L"full";
			break;

        case VSS_BT_INCREMENTAL:
			wszBackupType = L"incremental";
			break;

        case VSS_BT_DIFFERENTIAL:
			wszBackupType = L"differential";
			break;

        case VSS_BT_OTHER:
			wszBackupType = L"other";
			break;
		}

	wprintf(L"\n\n****WRITER*****\nBackup Type = %s\n", wszBackupType);

	wprintf
		(
		L"AreComponentsSelected = %s\n",
		AreComponentsSelected() ? L"yes" : L"no"
		);

	wprintf
		(
		L"BootableSystemStateBackup = %s\n\n",
		IsBootableSystemStateBackedUp() ? L"yes" : L"no"
		);

	pWriterComponents->GetComponentCount(&cComponents);
	for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
		HRESULT hr;

		CComPtr<IVssComponent> pComponent;
		VSS_COMPONENT_TYPE ct;
		CComBSTR bstrLogicalPath;
		CComBSTR bstrComponentName;


		CHECK_SUCCESS(pWriterComponents->GetComponent(iComponent, &pComponent));
		CHECK_SUCCESS(pComponent->GetLogicalPath(&bstrLogicalPath));
		CHECK_SUCCESS(pComponent->GetComponentType(&ct));
		CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
		if (ct != VSS_CT_DATABASE)
			{
			wprintf(L"component type is incorrect\n");
			DebugBreak();
			}

		wprintf
			(
			L"Backing up database %s\\%s.\n",
			bstrLogicalPath,
			bstrComponentName
			);

		WCHAR buf[100];
		wsprintf (buf, L"backupTime = %d", (INT) time(NULL));

		CHECK_SUCCESS(pComponent->SetBackupMetadata(buf));
		wprintf(L"\nBACKUPMETADATA=%s\n", buf);
		}

	wprintf(L"\n******END WRITER******\n\n");
	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnPrepareSnapshot()
	{
	IsPathAffected(L"e:\\foobar");
	return true;
	}


bool STDMETHODCALLTYPE CTestVssWriter::OnFreeze()
	{
	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnThaw()
	{
	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnBackupComplete(IN IVssWriterComponents *pWriterComponents)
	{
	if (m_lWait & x_maskWaitBackupComplete)
		{
		wprintf(L"OnBackupComplete sleeping 10 seconds.\n");
		Sleep(20000);
		}

	unsigned cComponents;
	pWriterComponents->GetComponentCount(&cComponents);
	for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
		HRESULT hr;

		CComPtr<IVssComponent> pComponent;
		VSS_COMPONENT_TYPE ct;
		CComBSTR bstrLogicalPath;
		CComBSTR bstrComponentName;
		bool bBackupSucceeded;

		CHECK_SUCCESS(pWriterComponents->GetComponent(iComponent, &pComponent));
		CHECK_SUCCESS(pComponent->GetLogicalPath(&bstrLogicalPath));
		CHECK_SUCCESS(pComponent->GetComponentType(&ct));
		CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
		CHECK_SUCCESS(pComponent->GetBackupSucceeded(&bBackupSucceeded));
		if (ct != VSS_CT_DATABASE)
			{
			wprintf(L"component type is incorrect\n");
			DebugBreak();
			}

		wprintf
			(
			L"Database %s\\%s backup %s.\n",
			bstrLogicalPath,
			bstrComponentName,
			bBackupSucceeded ? L"succeeded" : L"failed"
			);

		CComBSTR bstrMetadata;
		CHECK_SUCCESS(pComponent->GetBackupMetadata(&bstrMetadata));
		wprintf(L"BACKUPMETADATA=%s\n", bstrMetadata);
		}

	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnPreRestore(IN IVssWriterComponents *pComponent)
	{
	UNREFERENCED_PARAMETER(pComponent);

	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnPostRestore(IN IVssWriterComponents *pComponent)
	{
	UNREFERENCED_PARAMETER(pComponent);

	if (m_lWait & x_maskWaitPostRestore)
		{
		wprintf(L"OnPostRestore sleeping 10 seconds.\n");
		Sleep(10000);
		}

	return true;
	}

bool STDMETHODCALLTYPE CTestVssWriter::OnAbort()
	{
	return true;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\tests\betest\debug.cpp ===
#include "stdafx.hxx"
#include "vss.h"
#include "vswriter.h"
#include "vsbackup.h"
#include <debug.h>
#include <cwriter.h>
#include <lmshare.h>
#include <lmaccess.h>


LPCWSTR GetStringFromFailureType(HRESULT hrStatus)
{
    LPCWSTR pwszFailureType = L"";

    switch (hrStatus)
	{
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT:        pwszFailureType = L"VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT";    break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:              pwszFailureType = L"VSS_E_WRITERERROR_OUTOFRESOURCES";          break;
	case VSS_E_WRITERERROR_TIMEOUT:                     pwszFailureType = L"VSS_E_WRITERERROR_TIMEOUT";                 break;
	case VSS_E_WRITERERROR_NONRETRYABLE:                pwszFailureType = L"VSS_E_WRITERERROR_NONRETRYABLE";            break;
	case VSS_E_WRITERERROR_RETRYABLE:                   pwszFailureType = L"VSS_E_WRITERERROR_RETRYABLE";               break;
	case VSS_E_BAD_STATE:                               pwszFailureType = L"VSS_E_BAD_STATE";                           break;
	case VSS_E_PROVIDER_ALREADY_REGISTERED:             pwszFailureType = L"VSS_E_PROVIDER_ALREADY_REGISTERED";         break;
	case VSS_E_PROVIDER_NOT_REGISTERED:                 pwszFailureType = L"VSS_E_PROVIDER_NOT_REGISTERED";             break;
	case VSS_E_PROVIDER_VETO:                           pwszFailureType = L"VSS_E_PROVIDER_VETO";                       break;
	case VSS_E_PROVIDER_IN_USE:				            pwszFailureType = L"VSS_E_PROVIDER_IN_USE";                     break;
	case VSS_E_OBJECT_NOT_FOUND:						pwszFailureType = L"VSS_E_OBJECT_NOT_FOUND";                    break;						
	case VSS_S_ASYNC_PENDING:							pwszFailureType = L"VSS_S_ASYNC_PENDING";                       break;
	case VSS_S_ASYNC_FINISHED:						    pwszFailureType = L"VSS_S_ASYNC_FINISHED";                      break;
	case VSS_S_ASYNC_CANCELLED:						    pwszFailureType = L"VSS_S_ASYNC_CANCELLED";                     break;
	case VSS_E_VOLUME_NOT_SUPPORTED:					pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED";                break;
	case VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER:		pwszFailureType = L"VSS_E_VOLUME_NOT_SUPPORTED_BY_PROVIDER";    break;
	case VSS_E_OBJECT_ALREADY_EXISTS:					pwszFailureType = L"VSS_E_OBJECT_ALREADY_EXISTS";               break;
	case VSS_E_UNEXPECTED_PROVIDER_ERROR:				pwszFailureType = L"VSS_E_UNEXPECTED_PROVIDER_ERROR";           break;
	case VSS_E_CORRUPT_XML_DOCUMENT:				    pwszFailureType = L"VSS_E_CORRUPT_XML_DOCUMENT";                break;
	case VSS_E_INVALID_XML_DOCUMENT:					pwszFailureType = L"VSS_E_INVALID_XML_DOCUMENT";                break;
	case VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED:       pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_VOLUMES_REACHED";   break;
	case VSS_E_FLUSH_WRITES_TIMEOUT:                    pwszFailureType = L"VSS_E_FLUSH_WRITES_TIMEOUT";                break;
	case VSS_E_HOLD_WRITES_TIMEOUT:                     pwszFailureType = L"VSS_E_HOLD_WRITES_TIMEOUT";                 break;
	case VSS_E_UNEXPECTED_WRITER_ERROR:                 pwszFailureType = L"VSS_E_UNEXPECTED_WRITER_ERROR";             break;
	case VSS_E_SNAPSHOT_SET_IN_PROGRESS:                pwszFailureType = L"VSS_E_SNAPSHOT_SET_IN_PROGRESS";            break;
	case VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED:     pwszFailureType = L"VSS_E_MAXIMUM_NUMBER_OF_SNAPSHOTS_REACHED"; break;
	case VSS_E_WRITER_INFRASTRUCTURE:	 		        pwszFailureType = L"VSS_E_WRITER_INFRASTRUCTURE";               break;
	case VSS_E_WRITER_NOT_RESPONDING:			        pwszFailureType = L"VSS_E_WRITER_NOT_RESPONDING";               break;
    case VSS_E_WRITER_ALREADY_SUBSCRIBED:		        pwszFailureType = L"VSS_E_WRITER_ALREADY_SUBSCRIBED";           break;
	
	case NOERROR:
	default:
	    break;
	}

    return (pwszFailureType);
}


// This function displays the formatted message at the console and throws
// The passed return code will be returned by vsreq.exe
void Error(
    IN  INT nReturnCode,
    IN  const WCHAR* pwszMsgFormat,
    IN  ...
    )
{
    va_list marker;
    va_start( marker, pwszMsgFormat );
    vwprintf( pwszMsgFormat, marker );
    va_end( marker );

	BS_ASSERT(FALSE);
    // throw that return code.
    throw(nReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\tests\betest\cwriter.h ===
//
//  ATL debugging support turned on at debug version
//  BUGBUG: the ATL thunking support is not enable yet in IA64
//  When this will be enabled then enable it here also!
//
#ifdef _DEBUG
#ifdef _M_IX86
#define _ATL_DEBUG_INTERFACES
#define _ATL_DEBUG_QI
#define _ATL_DEBUG_REFCOUNT
#endif
#endif // _DEBUG

class CTestVssWriter : public CVssWriter
	{
public:
	CTestVssWriter(LONG lWait) : m_lWait(lWait)
		{
		}

	void Initialize();

	virtual bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);

	virtual bool STDMETHODCALLTYPE OnPrepareBackup(IN IVssWriterComponents *pComponent);

	virtual bool STDMETHODCALLTYPE OnPrepareSnapshot();

	virtual bool STDMETHODCALLTYPE OnFreeze();

	virtual bool STDMETHODCALLTYPE OnThaw();

	virtual bool STDMETHODCALLTYPE OnAbort();

	virtual bool STDMETHODCALLTYPE OnBackupComplete(IN IVssWriterComponents *pComponent);

	virtual bool STDMETHODCALLTYPE OnPreRestore(IN IVssWriterComponents *pComponent);
	
	virtual bool STDMETHODCALLTYPE OnPostRestore(IN IVssWriterComponents *pComponent);
private:
	enum
		{
		x_maskWaitGatherWriterMetadata = 1,
		x_maskWaitPrepareBackup = 2,
		x_maskWaitBackupComplete=4,
		x_maskWaitPostRestore=8
		};

	LONG m_lWait;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\tests\betest\debug.h ===
// Execute the given call and check that the return code must be S_OK
#define CHECK_SUCCESS( Call )                                                                           \
    {                                                                                                   \
        hr = Call;                                                                                    \
        if (hr != S_OK)                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }

#define CHECK_NOFAIL( Call )                                                                            \
    {                                                                                                   \
        hr = Call;                                                                                    \
        if (FAILED(hr))                                                                               \
            Error(1, L"\nError in %S(%d): \n\t- Call %S not succeeded. \n"                              \
                L"\t  Error code = 0x%08lx. Error description = %s\n",                                  \
                __FILE__, __LINE__, #Call, hr, GetStringFromFailureType(hr));                       \
    }



void Error(INT nReturnCode, const WCHAR* pwszMsgFormat, ...);
LPCWSTR GetStringFromFailureType(HRESULT hrStatus);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\tests\dep_demo\dep_demo.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module dep_demo.cpp | Implementation of the Volume Snapshots demo
    @end

Author:

    Adi Oltean  [aoltean]  09/17/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/17/1999  Created

--*/


/////////////////////////////////////////////////////////////////////////////
//  Includes

#include "dep_demo.h"


/////////////////////////////////////////////////////////////////////////////
//  Implementation

HRESULT DemoMain()
{
    CVssFunctionTracer ft( VSSDBG_VSSDEMO, L"DemoMain" );

    try
    {
		// Get the Snapshot Service object.
		CComPtr<IVssDependencies> pIDepGraph;
        ft.hr = pIDepGraph.CoCreateInstance( CLSID_VSSDependencies );
        if ( ft.HrFailed() )
            ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"Connection failed with hr = 0x%08lx", ft.hr);

        ft.Msg( L"Creating Dependency Graph instance... OK");

		CComBSTR strResName = L"Resource1";
		CComBSTR strAppInstance = L"APP1";
		CComBSTR strVolumeList = L"C:\\;D:\\";
		CComBSTR strDetails = L"...Description...";
		CComBSTR strResourceId;
		ft.hr = pIDepGraph->AddResource(
			strResName,
			strAppInstance,
			VS_LOCAL_RESOURCE,
			strVolumeList,
			strDetails,
			&strResourceId
			);
		if (ft.HrFailed())
            ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"AddResource failed with hr = 0x%08lx", ft.hr);

		strResName = L"Resource2";
		strAppInstance = L"APP2";
		strVolumeList = L"C:\\;D:\\";
		strDetails = L"...Description...";
		strResourceId;
		ft.hr = pIDepGraph->AddResource(
			strResName,
			strAppInstance,
			VS_LOCAL_RESOURCE,
			strVolumeList,
			strDetails,
			&strResourceId
			);
		if (ft.HrFailed())
            ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"AddResource failed with hr = 0x%08lx", ft.hr);

		strResName = L"Resource1";
		strAppInstance = L"APP1";
		strVolumeList = L"C:\\;D:\\";
		strDetails = L"...Description...";
		strResourceId;
		ft.hr = pIDepGraph->AddResource(
			strResName,
			strAppInstance,
			VS_LOCAL_RESOURCE,
			strVolumeList,
			strDetails,
			&strResourceId
			);
		if (ft.HrFailed())
            ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"AddResource failed with hr = 0x%08lx", ft.hr);

		strResName = L"Resource1";
		strAppInstance = L"APP2";
		strVolumeList = L"C:\\;D:\\";
		strDetails = L"...Description...";
		strResourceId;
		ft.hr = pIDepGraph->AddResource(
			strResName,
			strAppInstance,
			VS_LOCAL_RESOURCE,
			strVolumeList,
			strDetails,
			&strResourceId
			);
		if (ft.HrFailed())
            ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"AddResource failed with hr = 0x%08lx", ft.hr);

		CComBSTR strContext = L"Context1";
		CComBSTR strProcessID;
		HRESULT hrErrorCode;
		CComBSTR strCancelReason;
		INT nMaxDuration = 1000;
		INT nMaxIterations = 1000;
		ft.hr = pIDepGraph->StartDiscoveryProcess(
			strContext,
			&strProcessID,
			&hrErrorCode,
			&strCancelReason,
			nMaxDuration,
			nMaxIterations
			);
		if (ft.HrFailed())
            ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"StartDiscoveryProcess failed with hr = 0x%08lx", ft.hr);
    }
    VSS_STANDARD_CATCH(ft)

    return ft.hr;
}

extern "C" int WINAPI _tWinMain(HINSTANCE /*hInstance*/, 
    HINSTANCE /*hPrevInstance*/, LPTSTR /*lpCmdLine*/, int /*nShowCmd*/)
{
    CVssFunctionTracer ft( VSSDBG_VSSDEMO, L"_tWinMain" );

    try
    {
		// Initialize COM library
		ft.hr = CoInitialize(NULL);
		if (ft.HrFailed())
			ft.Err( VSSDBG_VSSDEMO, E_UNEXPECTED, L"Failure in initializing the COM library 0x%08lx", ft.hr);

		// Run the demo
		ft.hr = DemoMain();

		// Uninitialize COM library
		CoUninitialize();
	}
    VSS_STANDARD_CATCH(ft)

    return ft.HrSucceeded();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\tests\dep_demo\dep_demo.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Abstract:

    @doc
    @module dep_demo.cpp | header of Dependency demo
    @end

Author:

    Adi Oltean  [aoltean]  09/17/1999

TBD:
	
	Add comments.

Revision History:

    Name        Date        Comments
    aoltean     09/17/1999  Created

--*/


#ifndef __DEP_DEMO_H_	
#define __DEP_DEMO_H_


/////////////////////////////////////////////////////////////////////////////
//  Defines and pragmas

// C4290: C++ Exception Specification ignored
#pragma warning(disable:4290)
// warning C4511: copy constructor could not be generated
#pragma warning(disable:4511)
// warning C4127: conditional expression is constant
#pragma warning(disable:4127)


/////////////////////////////////////////////////////////////////////////////
//  Includes


#include <wtypes.h>
#include <stddef.h>
#include <oleauto.h>
#include <comadmin.h>

#include "vs_assert.hxx"

// ATL
#include <atlconv.h>
#include <atlbase.h>

// Application specific
#include "vs_inc.hxx"

// Generated MIDL headers
#include "vss.h"
#include "vscoordint.h"


#endif //__DEP_DEMO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\tests\dep_demo\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dep_demo.rc
//
#define IDS_PROJNAME                    100
#define IDR_Writer_1                    100
#define IDR_DSSSNAPSHOTWRITER           101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\tests\failsnap\failsnap.cpp ===
/*
**++
**
** Copyright (c) 2000-2001  Microsoft Corporation
**
**
** Module Name:
**
**	simsnap.cpp
**
**
** Abstract:
**
**	Test program to drive the VSS Writer Shim contained in VssAPI.DLL
**
**
** Author:
**
**	Michael C. Johnson   [mikejohn]        24-May-2000
**
**
** Revision History:
**
**	X-5	MCJ		Michael C. Johnson		18-Sep-2000
**		176860: Add the missing calling convention specifiers
**
**	X-4	MCJ		Michael C. Johnson		23-Jun-2000
**		Set the writer failure status.
**
**	X-3	MCJ		Michael C. Johnson		15-Jun-2000
**		Add some additional event routines and the ability to act
**		as various types of writer.
**
**	X-2	MCJ		Michael C. Johnson		26-May-2000
**		Add some extra tests to validate shim is properly sensitive
**		to volume name array contents.
**--
*/

/*
** Defines
**
**
**	   C4290: C++ Exception Specification ignored
** warning C4511: 'CVssCOMApplication' : copy constructor could not be generated
** warning C4127: conditional expression is constant
*/
#pragma warning(disable:4290)
#pragma warning(disable:4511)
#pragma warning(disable:4127)


/*
** Includes
*/
#include <windows.h>
#include <wtypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <assert.h>

#include <vss.h>
#include <vswriter.h>



#define	GET_STATUS_FROM_BOOL(_bSucceeded)	((_bSucceeded)       ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_HANDLE(_handle)		((NULL != (_handle)) ? NOERROR : HRESULT_FROM_WIN32 (GetLastError()))
#define GET_STATUS_FROM_POINTER(_ptr)		((NULL != (_ptr))    ? NOERROR : E_OUTOFMEMORY)

#define SIZEOF_ARRAY(_aBase)			(sizeof (_aBase) / sizeof ((_aBase)[0]))



typedef enum FAIL_PHASE
    {
    PHASE_UNDEFINED = 0,
    PHASE_IDENTIFY,
    PHASE_PREPARE_FOR_BACKUP,
    PHASE_PREPARE_FOR_SNAPSHOT,
    PHASE_FREEZE,
    PHASE_THAW,
    PHASE_ABORT,
    PHASE_BACKUP_COMPLETE,
    PHASE_RESTORE
    } FAIL_PHASE;


HRESULT SelectFailureStatus (VOID)
    {
    HRESULT	hrStatus;

    switch (rand () / (RAND_MAX / 5))
	{
	case 0: hrStatus = VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT; break;
	case 1: hrStatus = VSS_E_WRITERERROR_OUTOFRESOURCES;       break;
	case 2: hrStatus = VSS_E_WRITERERROR_TIMEOUT;              break;
	case 3: hrStatus = VSS_E_WRITERERROR_NONRETRYABLE;         break;
	case 4: hrStatus = VSS_E_WRITERERROR_RETRYABLE;            break;

	default:
	    assert (FALSE);
	    break;
	}

    return (hrStatus);
    }



LPCWSTR GetStringFromFailureType (HRESULT hrStatus)
    {
    LPCWSTR pwszFailureType;

    switch (hrStatus)
	{
	case NOERROR:                                pwszFailureType = L"";                     break;
	case VSS_E_WRITERERROR_INCONSISTENTSNAPSHOT: pwszFailureType = L"InconsistentSnapshot"; break;
	case VSS_E_WRITERERROR_OUTOFRESOURCES:       pwszFailureType = L"OutOfResources";       break;
	case VSS_E_WRITERERROR_TIMEOUT:              pwszFailureType = L"Timeout";              break;
	case VSS_E_WRITERERROR_NONRETRYABLE:         pwszFailureType = L"Non-Retryable";        break;
	case VSS_E_WRITERERROR_RETRYABLE:            pwszFailureType = L"Retryable";            break;
	default:                                     pwszFailureType = L"UNDEFINED";            break;
	}

    return (pwszFailureType);
    }



LPCWSTR GetStringFromWriterType (VSS_USAGE_TYPE wtWriterType)
    {
    LPCWSTR pwszWriterType;

    switch (wtWriterType)
	{
	case VSS_UT_BOOTABLESYSTEMSTATE: pwszWriterType = L"BootableSystemState"; break;
	case VSS_UT_SYSTEMSERVICE:       pwszWriterType = L"SystemServiceState";  break;
	case VSS_UT_USERDATA:            pwszWriterType = L"UserData";            break;
	case VSS_UT_OTHER:               pwszWriterType = L"Other";               break;
	default:                         pwszWriterType = L"UNDEFINED";           break;
	}

    return (pwszWriterType);
    }



LPCWSTR GetStringFromFailPhase (FAIL_PHASE fpFailPhase)
    {
    LPCWSTR pwszFailPhase;


    switch (fpFailPhase)
	{
	case PHASE_IDENTIFY:             pwszFailPhase = L"Identify";           break;
	case PHASE_PREPARE_FOR_BACKUP:   pwszFailPhase = L"PrepareForBackup";   break;
	case PHASE_PREPARE_FOR_SNAPSHOT: pwszFailPhase = L"PrepareForSnapshot"; break;
	case PHASE_FREEZE:               pwszFailPhase = L"Freeze";             break;
	case PHASE_THAW:                 pwszFailPhase = L"Thaw";               break;
	case PHASE_ABORT:                pwszFailPhase = L"Abort";              break;
	case PHASE_BACKUP_COMPLETE:      pwszFailPhase = L"BackupComplete";     break;
	case PHASE_RESTORE:              pwszFailPhase = L"Restore";            break;
	default:                         pwszFailPhase = L"UNDEFINED";          break;
	}
    
    return (pwszFailPhase);
    }





static volatile BOOL       bContinue   = TRUE;
static volatile FAIL_PHASE fpFailPhase = PHASE_FREEZE;


class CVssWriterFailSnap : public CVssWriter
	{
public:
	    bool STDMETHODCALLTYPE OnIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata);
	    bool STDMETHODCALLTYPE OnPrepareBackup (IVssWriterComponents *pIVssWriterComponents);
	    bool STDMETHODCALLTYPE OnPrepareSnapshot ();
	    bool STDMETHODCALLTYPE OnFreeze ();
	    bool STDMETHODCALLTYPE OnThaw ();
	    bool STDMETHODCALLTYPE OnAbort ();
	    bool STDMETHODCALLTYPE OnBackupComplete (IVssWriterComponents *pIVssWriterComponents);
	    bool STDMETHODCALLTYPE OnPostRestore (IVssWriterComponents *pIVssWriterComponents);
};



bool STDMETHODCALLTYPE CVssWriterFailSnap::OnIdentify (IVssCreateWriterMetadata *pIVssCreateWriterMetadata)
    {
    bool	bPhaseSucceeded = (PHASE_IDENTIFY != fpFailPhase);
    HRESULT	hrStatus        = SelectFailureStatus ();

    if (bPhaseSucceeded)
	{
	hrStatus = pIVssCreateWriterMetadata->AddComponent (VSS_CT_FILEGROUP,
							    NULL,
							    L"Failsnap Writer Component",
							    L"Failsnap Writer Caption",
							    NULL, // icon
							    0,
							    true,
							    false,
							    false);

	bPhaseSucceeded = SUCCEEDED (hrStatus);
	}


    wprintf (L"\nThreadId 0x%04x - Received event - OnIdentify ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnPrepareBackup (IVssWriterComponents *pIVssWriterComponents)
    {
    bool	bPhaseSucceeded = (PHASE_PREPARE_FOR_BACKUP != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnPrepareBackup ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnPrepareSnapshot ()
    {
    bool	bPhaseSucceeded = (PHASE_PREPARE_FOR_SNAPSHOT != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnPrepareSnapshot ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnFreeze ()
    {
    bool	bPhaseSucceeded = (PHASE_FREEZE != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnFreeze ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnThaw ()
    {
    bool	bPhaseSucceeded = (PHASE_THAW != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnThaw ()%s%s", 
	     GetCurrentThreadId (),
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnAbort ()
    {
    bool	bPhaseSucceeded = (PHASE_ABORT != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnAbort ()%s%s",
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnBackupComplete (IVssWriterComponents *pIVssWriterComponents)
    {
    bool	bPhaseSucceeded = (PHASE_BACKUP_COMPLETE != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnBackupComplete ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }


bool STDMETHODCALLTYPE CVssWriterFailSnap::OnPostRestore (IVssWriterComponents *pIVssWriterComponents)
    {
    bool	bPhaseSucceeded = (PHASE_RESTORE != fpFailPhase);
    HRESULT	hrStatus        = bPhaseSucceeded ? NOERROR : SelectFailureStatus ();


    wprintf (L"\nThreadId 0x%04x - Received event - OnPostRestore ()%s%s", 
	     GetCurrentThreadId (), 
	     bPhaseSucceeded ? L"" : L" - FAILED ",
	     GetStringFromFailureType (hrStatus));


    if (!bPhaseSucceeded)
	{
	SetWriterFailure (hrStatus);
	}

    return (bPhaseSucceeded);
    }






static BOOL AssertPrivilege (LPCWSTR privName)
    {
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if (OpenProcessToken (GetCurrentProcess (), TOKEN_ADJUST_PRIVILEGES, &tokenHandle))
	{
        LUID value;

        if (LookupPrivilegeValue (NULL, privName, &value))
	    {
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            /*
            ** We will always call GetLastError below, so clear
            ** any prior error values on this thread.
            */
            SetLastError (ERROR_SUCCESS);

            stat = AdjustTokenPrivileges (tokenHandle,
					  FALSE,
					  &newState,
					  (DWORD)0,
					  NULL,
					  NULL);

            /*
            ** Supposedly, AdjustTokenPriveleges always returns TRUE
            ** (even when it fails). So, call GetLastError to be
            ** extra sure everything's cool.
            */
            if ((error = GetLastError()) != ERROR_SUCCESS)
		{
                stat = FALSE;
		}

            if (!stat)
		{
                wprintf (L"AdjustTokenPrivileges for %s failed with 0x%08X",
			 privName,
			 error);
		}
	    }


        CloseHandle (tokenHandle);
	}

    return stat;
    }



BOOL WINAPI CtrlC_HandlerRoutine (IN DWORD /* dwType */)
	{
	bContinue = FALSE;

	// Mark that the break was handled.
	return TRUE;
	}



extern "C" int __cdecl wmain (int argc, WCHAR *argv[])
    {
    HRESULT		 hrStatus            = NOERROR;
    CVssWriterFailSnap	*pCVssWriterFailSnap = NULL;
    BOOL		 bSucceeded          = FALSE;
    BOOL		 bComInitialized     = FALSE;
    BOOL		 bSubscribed         = FALSE;
    VSS_USAGE_TYPE	 wtWriterType        = VSS_UT_USERDATA;
    const GUID		 guidIdWriter        = {0xd335a99e,
						0x57fb,
						0x4b80,
						    {0x85, 0xb1, 0x15, 0xda, 0xa7, 0xc7, 0x4e, 0x14}};


    srand ((unsigned)time (NULL));

    SetConsoleCtrlHandler(CtrlC_HandlerRoutine, TRUE);


    if ((argc >= 2) && (wcslen (argv[1]) > 0))
	{
	switch (*argv[1])
	    {
	    case L'I': case L'i': fpFailPhase = PHASE_IDENTIFY;             break;
	    case L'B': case L'b': fpFailPhase = PHASE_PREPARE_FOR_BACKUP;   break;
	    case L'S': case L's': fpFailPhase = PHASE_PREPARE_FOR_SNAPSHOT; break;
	    case L'F': case L'f': fpFailPhase = PHASE_FREEZE;               break;
	    case L'T': case L't': fpFailPhase = PHASE_THAW;                 break;
	    case L'A': case L'a': fpFailPhase = PHASE_ABORT;                break;
	    case L'C': case L'c': fpFailPhase = PHASE_BACKUP_COMPLETE;      break;
	    case L'R': case L'r': fpFailPhase = PHASE_RESTORE;              break;

	    default:
		wprintf (L"\nFAILSNAP [phase] [writer type]"
			 L"\n\n\tFailPhases"
			 L"\n\t\ti - Identify"
			 L"\n\t\tb - PrepareForBackup"
			 L"\n\t\ts - PrepareForSnapshot"
			 L"\n\t\tf - Freeze                (default)"
			 L"\n\t\tt - Thaw"
			 L"\n\t\ta - Abort"
			 L"\n\t\tc - BackupComplete"
			 L"\n\t\tr - PostRestore"

			 L"\n\n\tWriterTypes"
			 L"\n\t\tb - BootableState writer"
			 L"\n\t\ts - ServiceState writer"
			 L"\n\t\tu - UserData writer       (default)"
			 L"\n\t\to - Other writer"
			 L"\n");



		bContinue = FALSE;
		break;
	    }
	}



    if ((argc >= 3) && (wcslen (argv[2]) > 0))
	{
	switch (*argv[2])
	    {
	    case L'B': case L'b': wtWriterType = VSS_UT_BOOTABLESYSTEMSTATE; break;
	    case L'S': case L's': wtWriterType = VSS_UT_SYSTEMSERVICE;       break;
	    case L'U': case L'u': wtWriterType = VSS_UT_USERDATA;            break;
	    case L'O': case L'o': wtWriterType = VSS_UT_OTHER;               break;

	    default:
		bContinue = FALSE;
		break;
	    }
	}





    if (bContinue)
	{
	wprintf (L"\nSetting up %s writer to fail %s requests (ProcessId 0x%04x)",
		 GetStringFromWriterType (wtWriterType),
		 GetStringFromFailPhase  (fpFailPhase),
		 GetCurrentProcessId ());


	wprintf (L"\nChecking privileges");

	bSubscribed = AssertPrivilege (SE_BACKUP_NAME);

	hrStatus = GET_STATUS_FROM_BOOL (bSucceeded);


	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nAssertPrivilege returned error 0x%08X", hrStatus);
	    }

	}


    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nInitializing COM");

	hrStatus = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nCoInitialize() returned error 0x%08X", hrStatus);
	    }

	else
	    {
	    bComInitialized = TRUE;
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nConstructing Writer");

	pCVssWriterFailSnap = new CVssWriterFailSnap;

	if (NULL == pCVssWriterFailSnap)
	    {
	    hrStatus = HRESULT_FROM_WIN32 (ERROR_NOT_ENOUGH_MEMORY);

	    wprintf (L"\nFailed to allocate CVssWriterFailSnap : 0x%08X", hrStatus);
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	WCHAR	awchWriterName [256];


	wprintf (L"\nInitialising the writer");

	_snwprintf (awchWriterName, 
		    SIZEOF_ARRAY (awchWriterName), 
		    L"Microsoft Test Writer - FailSnap (%s/%s/0x%04x)",
		    GetStringFromWriterType (wtWriterType),
		    GetStringFromFailPhase  (fpFailPhase),
		    GetCurrentProcessId ());


	hrStatus = pCVssWriterFailSnap->Initialize (guidIdWriter,
						    awchWriterName,
						    wtWriterType,
						    VSS_ST_OTHER);

	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nFailed to initialize the writer : 0x%08X", hrStatus);
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nSubscribing to snapshot events");

	hrStatus = pCVssWriterFailSnap->Subscribe ();

	if (FAILED (hrStatus))
	    {
	    wprintf (L"\nFailed to subscribe to snapshot events : 0x%08X", hrStatus);
	    }

	else
	    {
	    bSubscribed = TRUE;
	    }
	}



    if (bContinue && SUCCEEDED (hrStatus))
	{
	wprintf (L"\nWaiting for snapshot events (or Ctrl-C)");
	
	while (bContinue)
	    {
	    Sleep (100);
	    }
	}



    if (bSubscribed)
	{
	wprintf (L"\nUn-Subscribing from snapshot events");

	pCVssWriterFailSnap->Unsubscribe ();
	}


    if (NULL != pCVssWriterFailSnap)
	{
	wprintf (L"\nDeconstructing Writer");

	delete pCVssWriterFailSnap;
	}


    if (bComInitialized)
	{
	wprintf (L"\nUnInitialising COM");

	CoUninitialize();
	}

    return (hrStatus);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\tests\betest\main.cpp ===
#include "stdafx.hxx"
#include "vs_idl.hxx"
#include "vswriter.h"
#include "vsbackup.h"
#include <debug.h>
#include <cwriter.h>
#include <lmshare.h>
#include <lmaccess.h>
#include <time.h>

BOOL AssertPrivilege( LPCWSTR privName )
    {
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if ( OpenProcessToken (GetCurrentProcess(),
			   TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,
			   &tokenHandle))
	{
	LUID value;

	if ( LookupPrivilegeValue( NULL, privName, &value ) )
	    {
	    TOKEN_PRIVILEGES newState;
	    DWORD            error;

	    newState.PrivilegeCount           = 1;
	    newState.Privileges[0].Luid       = value;
	    newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED;

	    /*
	     * We will always call GetLastError below, so clear
	     * any prior error values on this thread.
	     */
	    SetLastError( ERROR_SUCCESS );

	    stat = AdjustTokenPrivileges (tokenHandle,
					  FALSE,
					  &newState,
					  (DWORD)0,
					  NULL,
					  NULL );

	    /*
	     * Supposedly, AdjustTokenPriveleges always returns TRUE
	     * (even when it fails). So, call GetLastError to be
	     * extra sure everything's cool.
	     */
	    if ( (error = GetLastError()) != ERROR_SUCCESS )
		{
		stat = FALSE;
		}

	    if ( !stat )
		{
		wprintf( L"AdjustTokenPrivileges for %s failed with %d",
			 privName,
			 error );
		}
	    }

	DWORD cbTokens;
	GetTokenInformation (tokenHandle,
			     TokenPrivileges,
			     NULL,
			     0,
			     &cbTokens);

	TOKEN_PRIVILEGES *pTokens = (TOKEN_PRIVILEGES *) new BYTE[cbTokens];
	GetTokenInformation (tokenHandle,
			     TokenPrivileges,
			     pTokens,
			     cbTokens,
			     &cbTokens);

	delete pTokens;
	CloseHandle( tokenHandle );
	}


    return stat;
    }


LPCWSTR GetStringFromUsageType (VSS_USAGE_TYPE eUsageType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eUsageType)
	{
	case VSS_UT_BOOTABLESYSTEMSTATE: pwszRetString = L"BootableSystemState"; break;
	case VSS_UT_SYSTEMSERVICE:       pwszRetString = L"SystemService";       break;
	case VSS_UT_USERDATA:            pwszRetString = L"UserData";            break;
	case VSS_UT_OTHER:               pwszRetString = L"Other";               break;
					
	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromSourceType (VSS_SOURCE_TYPE eSourceType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eSourceType)
	{
	case VSS_ST_TRANSACTEDDB:    pwszRetString = L"TransactionDb";    break;
	case VSS_ST_NONTRANSACTEDDB: pwszRetString = L"NonTransactionDb"; break;
	case VSS_ST_OTHER:           pwszRetString = L"Other";            break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromRestoreMethod (VSS_RESTOREMETHOD_ENUM eRestoreMethod)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eRestoreMethod)
	{
	case VSS_RME_RESTORE_IF_NOT_THERE:          pwszRetString = L"RestoreIfNotThere";          break;
	case VSS_RME_RESTORE_IF_CAN_REPLACE:        pwszRetString = L"RestoreIfCanReplace";        break;
	case VSS_RME_STOP_RESTORE_START:            pwszRetString = L"StopRestoreStart";           break;
	case VSS_RME_RESTORE_TO_ALTERNATE_LOCATION: pwszRetString = L"RestoreToAlternateLocation"; break;
	case VSS_RME_RESTORE_AT_REBOOT:             pwszRetString = L"RestoreAtReboot";            break;
	case VSS_RME_CUSTOM:                        pwszRetString = L"Custom";                     break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromWriterRestoreMethod (VSS_WRITERRESTORE_ENUM eWriterRestoreMethod)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eWriterRestoreMethod)
	{
	case VSS_WRE_NEVER:            pwszRetString = L"RestoreNever";           break;
	case VSS_WRE_IF_REPLACE_FAILS: pwszRetString = L"RestoreIfReplaceFailsI"; break;
	case VSS_WRE_ALWAYS:           pwszRetString = L"RestoreAlways";          break;

	default:
	    break;
	}


    return (pwszRetString);
    }


LPCWSTR GetStringFromComponentType (VSS_COMPONENT_TYPE eComponentType)
    {
    LPCWSTR pwszRetString = L"UNDEFINED";

    switch (eComponentType)
	{
	case VSS_CT_DATABASE:  pwszRetString = L"Database";  break;
	case VSS_CT_FILEGROUP: pwszRetString = L"FileGroup"; break;

	default:
	    break;
	}


    return (pwszRetString);
    }




void PrintFiledesc(IVssWMFiledesc *pFiledesc, LPCWSTR wszDescription)
    {
    CComBSTR bstrPath;
    CComBSTR bstrFilespec;
    CComBSTR bstrAlternate;
    CComBSTR bstrDestination;
    bool bRecursive;
	HRESULT hr;

    CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
    CHECK_SUCCESS(pFiledesc->GetFilespec(&bstrFilespec));
    CHECK_NOFAIL(pFiledesc->GetRecursive(&bRecursive));
    CHECK_NOFAIL(pFiledesc->GetAlternateLocation(&bstrAlternate));
    CHECK_NOFAIL(pFiledesc->GetAlternateLocation(&bstrDestination));

    wprintf (L"%s\n            Path = %s, Filespec = %s, Recursive = %s\n",
	     wszDescription,
	     bstrPath,
	     bstrFilespec,
	     bRecursive ? L"yes" : L"no");

    if (bstrAlternate && wcslen(bstrAlternate) > 0)
	wprintf(L"            Alternate Location = %s\n", bstrAlternate);

    if (bstrDestination && wcslen(bstrDestination) > 0)
	wprintf(L"            Destination Location = %s\n", bstrDestination);
    }


/*
void AddShares(IVssSnapshot **rgpSnapshot, UINT cSnapshot)
	{
	VSS_PWSZ wszDeviceName = NULL;

	try
		{
		for(UINT iSnapshot = 0; iSnapshot < cSnapshot; iSnapshot++)
			{
			SHARE_INFO_502 info;
			CHECK_SUCCESS(rgpSnapshot[iSnapshot]->GetDevice(&wszDeviceName));
			WCHAR *wszPath = new WCHAR[wcslen(wszDeviceName) + 2];
			if (wszPath != NULL)
				{
				wcscpy(wszPath, wszDeviceName);
				wcscat(wszPath, L"\\");
				memset(&info, 0, sizeof(info));
				WCHAR wszName[20];
				swprintf(wszName, L"Snapshot%d", iSnapshot);

				info.shi502_netname = wszName;
				info.shi502_type = STYPE_DISKTREE;
				info.shi502_permissions = ACCESS_READ;
				info.shi502_max_uses = 10;
				info.shi502_path = wszDeviceName;

				NET_API_STATUS status;
				DWORD parm_err;

				status = NetShareAdd(NULL, 502, (LPBYTE) &info, &parm_err);
				}

			CoTaskMemFree(wszDeviceName);
			wszDeviceName = NULL;
			}
		}
	catch(...)
		{
		}

	if (wszDeviceName)
		CoTaskMemFree(wszDeviceName);

	}

*/




void DoAddToSnapshotSet
    (
    IN IVssBackupComponents *pvbc,
    IN BSTR bstrPath,
    IN LPWSTR wszVolumes,
	OUT VSS_ID * rgpSnapshotId,
	UINT *pcSnapshot
    )
    {
    PWCHAR	pwszPath           = NULL;
    PWCHAR	pwszMountPointName = NULL;
    WCHAR	wszVolumeName [50];
    ULONG	ulPathLength;
    ULONG	ulMountpointBufferLength;
	HRESULT hr;


    ulPathLength = ExpandEnvironmentStringsW (bstrPath, NULL, 0);

    pwszPath = (PWCHAR) malloc (ulPathLength * sizeof (WCHAR));

    ulPathLength = ExpandEnvironmentStringsW (bstrPath, pwszPath, ulPathLength);


    ulMountpointBufferLength = GetFullPathName (pwszPath, 0, NULL, NULL);

    pwszMountPointName = (PWCHAR) malloc (ulMountpointBufferLength * sizeof (WCHAR));

	bool fSuccess = false;
	if (wcslen(pwszPath) >= 3 && pwszPath[1] == L':' && pwszPath[2] == L'\\')
		{
		wcsncpy(pwszMountPointName, pwszPath, 3);
		pwszMountPointName[3] = L'\0';
		fSuccess = true;
		}
	else
		{
		if (GetVolumePathNameW (pwszPath, pwszMountPointName, ulMountpointBufferLength))
			fSuccess = true;
		else
			printf("GetVolumeMountPointW failed with error %d", GetLastError());
		}

	if (fSuccess)
		{
		if (!GetVolumeNameForVolumeMountPointW (pwszMountPointName, wszVolumeName, sizeof (wszVolumeName) / sizeof (WCHAR)))
				printf("GetVolumeNameForVolumeMountPointW failed with error %d", GetLastError());
		else
            {
			if (NULL == wcsstr (wszVolumes, wszVolumeName))
				{
				if (L'\0' != wszVolumes [0])
					wcscat (wszVolumes, L";");

				wcscat (wszVolumes, wszVolumeName);

				CHECK_SUCCESS
					(
					pvbc->AddToSnapshotSet
						(
						wszVolumeName,
						GUID_NULL,
						&rgpSnapshotId[*pcSnapshot]
						)
					);

				*pcSnapshot += 1;
				}
			}
		}

    if (NULL != pwszPath)           free (pwszPath);
    if (NULL != pwszMountPointName) free (pwszMountPointName);
    }

static LPCWSTR s_rgwszStates[] =
	{
	NULL,
	L"STABLE",
	L"WAIT_FOR_FREEZE",
	L"WAIT_FOR_THAW",
	L"WAIT_FOR_POST_SNAPSHOT",
	L"WAIT_FOR_BACKUP_COMPLETE",
	L"FAILED_AT_IDENTIFY",
	L"FAILED_AT_PREPARE_BACKUP",
	L"FAILED_AT_PREPARE_SNAPSHOT",
	L"FAILED_AT_FREEZE",
	L"FAILED_AT_THAW",
	L"FAILED_AT_BACKUP_COMPLETE",
	L"FAILED_AT_PRE_RESTORE",
	L"FAILED_AT_POST_RESTORE"
	};

void CheckStatus(IVssBackupComponents *pvbc, LPCWSTR wszWhen)
    {
    unsigned cWriters;
	CComPtr<IVssAsync> pAsync;
	HRESULT hr;
	HRESULT hrResult;


    CHECK_NOFAIL(pvbc->GatherWriterStatus(&pAsync));
	CHECK_NOFAIL(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hrResult, NULL));
	CHECK_NOFAIL(hrResult);

	CHECK_NOFAIL(pvbc->GetWriterStatusCount(&cWriters));


    wprintf(L"\n\nstatus %s (%d writers)\n\n", wszWhen, cWriters);

    for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
	{
	VSS_ID idInstance;
	VSS_ID idWriter;
	VSS_WRITER_STATE status;
	CComBSTR bstrWriter;
	HRESULT hrWriterFailure;

	CHECK_SUCCESS(pvbc->GetWriterStatus (iWriter,
					     &idInstance,
					     &idWriter,
					     &bstrWriter,
					     &status,
					     &hrWriterFailure));

	wprintf (L"Status for writer %s: %s(0x%08lx%s%s)\n",
		 bstrWriter,
		 s_rgwszStates[status],
		 hrWriterFailure,
		 SUCCEEDED (hrWriterFailure) ? L"" : L" - ",
		 GetStringFromFailureType (hrWriterFailure));
        }

    pvbc->FreeWriterStatus();
    }

// wait a maximum number of seconds before cancelling the operation
void LoopWait
	(
	IVssAsync *pAsync,
	LONG seconds,
	LPCWSTR wszOperation
	)
	{
    clock_t start = clock();
	HRESULT hr, hrStatus;
	while(TRUE)
		{
		Sleep(1000);
		CHECK_SUCCESS(pAsync->QueryStatus(&hrStatus, NULL));
		if (hrStatus != VSS_S_ASYNC_PENDING)
			break;

		if (((clock() - start)/CLOCKS_PER_SEC) >= seconds)
			break;
		}

	if (hrStatus == VSS_S_ASYNC_PENDING)
		{
		CHECK_NOFAIL(pAsync->Cancel());
		wprintf(L"Called cancelled for %s.\n", wszOperation);
		}

	CHECK_SUCCESS(pAsync->QueryStatus(&hrStatus, NULL));
	CHECK_NOFAIL(hrStatus);
	}


extern "C" __cdecl wmain(int argc, WCHAR **argv)
    {
    WCHAR wszVolumes[2048];
    wszVolumes[0] = L'\0';

	UINT cSnapshot = 0;
	VSS_ID rgpSnapshotId[64];

    CTestVssWriter *pInstance = NULL;
    bool bCreated = false;
    bool bSubscribed = false;
    HRESULT hr = S_OK;
    bool bCoInitializeSucceeded = false;


    try
	{
	HRESULT hr;
	CComBSTR bstrXML;
	CComBSTR bstrXMLOut;
	LONG lWait = 0;

	if (argc == 2 &&
		wcslen(argv[1]) == 3 &&
		argv[1][0] == L'-' &&
		argv[1][1] == L'w' &&
		(argv[1][2] >= L'0' && argv[1][2] <= L'9'||
         argv[1][2] >= L'a' && argv[1][2] <= L'f'))
		 {
		 if (argv[1][2] >= L'0' && argv[1][2] <= L'9')
			 lWait = argv[1][2] - L'0';
		 else
			 lWait = argv[1][2] - L'a' + 10;

		 wprintf(L"wait parameter=%d.\n", lWait);
		 }
		


	CHECK_SUCCESS(CoInitializeEx(NULL, COINIT_MULTITHREADED));

    // Initialize COM security
    CHECK_SUCCESS
		(
		CoInitializeSecurity
			(
			NULL,                                //  IN PSECURITY_DESCRIPTOR         pSecDesc,
			-1,                                  //  IN LONG                         cAuthSvc,
			NULL,                                //  IN SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
			NULL,                                //  IN void                        *pReserved1,
			RPC_C_AUTHN_LEVEL_CONNECT,           //  IN DWORD                        dwAuthnLevel,
			RPC_C_IMP_LEVEL_IMPERSONATE,         //  IN DWORD                        dwImpLevel,
			NULL,                                //  IN void                        *pAuthList,
			EOAC_NONE,                           //  IN DWORD                        dwCapabilities,
			NULL                                 //  IN void                        *pReserved3
			)
		);

	bCoInitializeSucceeded = true;

	if ( !AssertPrivilege( SE_BACKUP_NAME ) )
	    {
	    wprintf( L"AssertPrivilege returned error, rc:%d\n", GetLastError() );
	    return 2;
	    }

	pInstance = new CTestVssWriter(lWait);
	if (pInstance == NULL)
	    {
	    wprintf(L"allocation failure\n");
	    DebugBreak();
	    }

	bCreated = true;
	pInstance->Initialize();
	CHECK_SUCCESS(pInstance->Subscribe());
	bSubscribed = true;

	CComBSTR strSnapshotSetId = "12345678-1234-1234-1234-1234567890ab";

	CComPtr<IVssBackupComponents> pvbc;

	CHECK_SUCCESS(CreateVssBackupComponents(&pvbc));


	CHECK_SUCCESS(pvbc->InitializeForBackup());
	CHECK_SUCCESS(pvbc->SetBackupState (true,
					    false,
					    VSS_BT_FULL));

	unsigned cWriters;
	CComPtr<IVssAsync> pAsync;
	CHECK_NOFAIL(pvbc->GatherWriterMetadata(&pAsync));

	LoopWait(pAsync, 15, L"GatherWriterMetadata");

	CHECK_NOFAIL(pvbc->GetWriterMetadataCount(&cWriters));

	VSS_ID id;

	while(TRUE)
		{
		hr = pvbc->StartSnapshotSet(&id);
		if (hr == S_OK)
			break;

		if (hr == VSS_E_SNAPSHOT_SET_IN_PROGRESS)
			Sleep(1000);
		else
			CHECK_SUCCESS(hr);
		}

	for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
	    {
	    CComPtr<IVssExamineWriterMetadata> pMetadata;
	    VSS_ID idInstance;

	    CHECK_SUCCESS(pvbc->GetWriterMetadata(iWriter, &idInstance, &pMetadata));
	    VSS_ID idInstanceT;
	    VSS_ID idWriter;
	    CComBSTR bstrWriterName;
	    VSS_USAGE_TYPE usage;
	    VSS_SOURCE_TYPE source;

	    CHECK_SUCCESS(pMetadata->GetIdentity (&idInstanceT,
						  &idWriter,
						  &bstrWriterName,
						  &usage,
						  &source));

	    wprintf (L"\n\n");

            if (memcmp(&idInstance, &idInstanceT, sizeof(VSS_ID)) != 0)
		{
		wprintf(L"Instance id mismatch\n");
		DebugBreak();
		}

	    WCHAR *pwszInstanceId;
	    WCHAR *pwszWriterId;
	    UuidToString(&idInstance, &pwszInstanceId);
	    UuidToString(&idWriter, &pwszWriterId);
	    wprintf (L"WriterName = %s\n\n"
		     L"    WriterId   = %s\n"
		     L"    InstanceId = %s\n"
		     L"    UsageType  = %d (%s)\n"
		     L"    SourceType = %d (%s)\n",
		     bstrWriterName,
		     pwszWriterId,
		     pwszInstanceId,
		     usage,
		     GetStringFromUsageType (usage),
		     source,
		     GetStringFromSourceType (source));

	    RpcStringFree(&pwszInstanceId);
	    RpcStringFree(&pwszWriterId);

	    unsigned cIncludeFiles, cExcludeFiles, cComponents;
	    CHECK_SUCCESS(pMetadata->GetFileCounts (&cIncludeFiles,
						    &cExcludeFiles,
						    &cComponents));

	    CComBSTR bstrPath;
	    CComBSTR bstrFilespec;
	    CComBSTR bstrAlternate;
	    CComBSTR bstrDestination;

	    for(unsigned i = 0; i < cIncludeFiles; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;
		CHECK_SUCCESS(pMetadata->GetIncludeFile(i, &pFiledesc));

		PrintFiledesc(pFiledesc, L"\n    Include File");
		}

	    for(i = 0; i < cExcludeFiles; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;
		CHECK_SUCCESS(pMetadata->GetExcludeFile(i, &pFiledesc));
		PrintFiledesc(pFiledesc, L"\n    Exclude File");
		}

	    for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
		CComPtr<IVssWMComponent> pComponent;
		PVSSCOMPONENTINFO pInfo;
		CHECK_SUCCESS(pMetadata->GetComponent(iComponent, &pComponent));
		CHECK_SUCCESS(pComponent->GetComponentInfo(&pInfo));
		wprintf (L"\n"
			 L"    Component %d, type = %d (%s)\n"
			 L"        LogicalPath = %s\n"
			 L"        Name        = %s\n"
			 L"        Caption     = %s\n"
			 L"        Icon size   = %u\n",
			 iComponent,
			 pInfo->type,
			 GetStringFromComponentType (pInfo->type),
			 pInfo->bstrLogicalPath,
			 pInfo->bstrComponentName,
			 pInfo->bstrCaption,
			 pInfo->cbIcon );

		wprintf (L"        RestoreMetadata        = %s\n"
			 L"        NotifyOnBackupComplete = %s\n"
			 L"        Selectable             = %s\n",
			 pInfo->bRestoreMetadata        ? L"yes" : L"no",
			 pInfo->bNotifyOnBackupComplete ? L"yes" : L"no",
			 pInfo->bSelectable             ? L"yes" : L"no");



		CHECK_SUCCESS(pvbc->AddComponent (idInstance,
						  idWriter,
						  pInfo->type,
						  pInfo->bstrLogicalPath,
						  pInfo->bstrComponentName));


		if (pInfo->cFileCount > 0)
		    {
		    for(i = 0; i < pInfo->cFileCount; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;
			CHECK_SUCCESS(pComponent->GetFile(i, &pFiledesc));

			CComBSTR bstrPath;
			CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
			DoAddToSnapshotSet(pvbc, bstrPath, wszVolumes, rgpSnapshotId, &cSnapshot);

			PrintFiledesc(pFiledesc, L"        FileGroupFile");
			}
		    }

		if (pInfo->cDatabases > 0)
		    {
		    for(i = 0; i < pInfo->cDatabases; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;
			CHECK_SUCCESS(pComponent->GetDatabaseFile(i, &pFiledesc));

			CComBSTR bstrPath;
			CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
			DoAddToSnapshotSet(pvbc, bstrPath, wszVolumes, rgpSnapshotId, &cSnapshot);
			PrintFiledesc(pFiledesc, L"        DatabaseFile");
			}
		    }

		if (pInfo->cLogFiles > 0)
		    {
		    for(i = 0; i < pInfo->cLogFiles; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;
			CHECK_SUCCESS(pComponent->GetDatabaseLogFile(i, &pFiledesc));

			CComBSTR bstrPath;
			CHECK_SUCCESS(pFiledesc->GetPath(&bstrPath));
			DoAddToSnapshotSet(pvbc, bstrPath, wszVolumes, rgpSnapshotId, &cSnapshot);
			PrintFiledesc(pFiledesc, L"        DatabaseLogFile");
			}
		    }

		pComponent->FreeComponentInfo(pInfo);
		}

	    VSS_RESTOREMETHOD_ENUM method;
	    CComBSTR bstrUserProcedure;
	    CComBSTR bstrService;
	    VSS_WRITERRESTORE_ENUM writerRestore;
	    unsigned cMappings;
	    bool bRebootRequired;

	    CHECK_NOFAIL(pMetadata->GetRestoreMethod (&method,
						      &bstrService,
						      &bstrUserProcedure,
						      &writerRestore,
						      &bRebootRequired,
						      &cMappings));


	    wprintf (L"\n"
		     L"    Restore method = %d (%s)\n"
		     L"    Service        = %s\n"
		     L"    User Procedure = %s\n"
		     L"    WriterRestore  = %d (%s)\n"
		     L"    RebootRequired = %s\n",
		     method,
		     GetStringFromRestoreMethod (method),
		     bstrService,
		     bstrUserProcedure,
		     writerRestore,
		     GetStringFromWriterRestoreMethod (writerRestore),
		     bRebootRequired ? L"yes" : L"no");

	    for(i = 0; i < cMappings; i++)
		{
		CComPtr<IVssWMFiledesc> pFiledesc;

		CHECK_SUCCESS(pMetadata->GetAlternateLocationMapping(i, &pFiledesc));

		PrintFiledesc(pFiledesc, L"AlternateMapping");
		}
	
		CComBSTR bstrMetadata;
		CHECK_SUCCESS(pMetadata->SaveAsXML(&bstrMetadata));
		CComPtr<IVssExamineWriterMetadata> pMetadataNew;
		CHECK_SUCCESS(CreateVssExamineWriterMetadata(bstrMetadata, &pMetadataNew));
	    CHECK_SUCCESS(pMetadataNew->GetIdentity (&idInstanceT,
						  &idWriter,
						  &bstrWriterName,
						  &usage,
						  &source));

	    wprintf (L"\n\n");

		if (memcmp(&idInstance, &idInstanceT, sizeof(VSS_ID)) != 0)
			{
			wprintf(L"Instance id mismatch\n");
			DebugBreak();
			}

	    UuidToString(&idInstance, &pwszInstanceId);
	    UuidToString(&idWriter, &pwszWriterId);
	    wprintf (L"WriterName = %s\n\n"
		     L"    WriterId   = %s\n"
		     L"    InstanceId = %s\n"
		     L"    UsageType  = %d (%s)\n"
		     L"    SourceType = %d (%s)\n",
		     bstrWriterName,
		     pwszWriterId,
		     pwszInstanceId,
		     usage,
		     GetStringFromUsageType (usage),
		     source,
		     GetStringFromSourceType (source));

	    RpcStringFree(&pwszInstanceId);
	    RpcStringFree(&pwszWriterId);
		}
		

	CHECK_SUCCESS(pvbc->FreeWriterMetadata());

	{
	CComPtr<IVssAsync> pAsync;
	HRESULT hr;

	CHECK_SUCCESS(pvbc->PrepareForBackup(&pAsync));
	LoopWait(pAsync, 5, L"PrepareForBackup");
	}


	CheckStatus(pvbc, L"After Prepare Backup");

	unsigned cWriterComponents;
	CHECK_SUCCESS(pvbc->GetWriterComponentsCount(&cWriterComponents));

	for(iWriter = 0; iWriter < cWriterComponents; iWriter++)
	    {
	    CComPtr<IVssWriterComponentsExt> pWriter;
	    CHECK_SUCCESS(pvbc->GetWriterComponents(iWriter, &pWriter));

	    unsigned cComponents;
	    CHECK_SUCCESS(pWriter->GetComponentCount(&cComponents));
	    VSS_ID idWriter, idInstance;
	    CHECK_SUCCESS(pWriter->GetWriterInfo(&idInstance, &idWriter));
	    for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
		{
		CComPtr<IVssComponent> pComponent;
		CHECK_SUCCESS(pWriter->GetComponent(iComponent, &pComponent));
				
		VSS_COMPONENT_TYPE ct;
		CComBSTR bstrLogicalPath;
		CComBSTR bstrComponentName;

		CHECK_NOFAIL(pComponent->GetLogicalPath(&bstrLogicalPath));
		CHECK_SUCCESS(pComponent->GetComponentType(&ct));
		CHECK_SUCCESS(pComponent->GetComponentName(&bstrComponentName));
		CHECK_SUCCESS(pvbc->SetBackupSucceeded (idInstance,
							idWriter,
							ct,
							bstrLogicalPath,
							bstrComponentName,
							true));
		}
	    }


	{
	CComPtr<IVssAsync> pAsync;
	INT nPercentDone;
	CHECK_SUCCESS(pvbc->DoSnapshotSet (&pAsync));


	CHECK_SUCCESS(pAsync->Wait());
	CHECK_SUCCESS(pAsync->QueryStatus(&hr, &nPercentDone));
	}
							

        if (FAILED(hr))
	    {
            wprintf(L"Creating the snapshot failed.  hr = 0x%08lx\n", hr);
	    CheckStatus(pvbc, L"After Do Snapshot");
	    }
	else
	    {
	    CheckStatus(pvbc, L"After Do Snapshot");
		CComBSTR bstrXML;
		CComPtr<IVssBackupComponents> pvbcRestore;

		CHECK_SUCCESS(pvbc->SaveAsXML(&bstrXML));
		CHECK_SUCCESS(CreateVssBackupComponents(&pvbcRestore));
		CHECK_SUCCESS(pvbcRestore->InitializeForRestore(bstrXML));
		wprintf(L"InitializeForRestore succeeded.\n");

	    LONG lSnapshotsNotDeleted;
	    VSS_ID rgSnapshotsNotDeleted[10];
	    {
	    CComPtr<IVssAsync> pAsync;
	    HRESULT hr;

	    CHECK_SUCCESS(pvbc->BackupComplete(&pAsync));
		LoopWait(pAsync, 5, L"BackupComplete");
	    }

	    CheckStatus(pvbc, L"After Backup Complete");
	    hr  = pvbc->DeleteSnapshots (id,
					 VSS_OBJECT_SNAPSHOT_SET,
					 false,
					 &lSnapshotsNotDeleted,
					 rgSnapshotsNotDeleted);

	    if (FAILED(hr))
			wprintf(L"Deletion of Snapshots failed.  hr = 0x%08lx\n", hr);
		{
		CComPtr<IVssAsync> pAsync;
		HRESULT hr;

		pvbcRestore->GatherWriterMetadata(&pAsync);
		CHECK_SUCCESS(pAsync->Wait());
	    CHECK_SUCCESS(pAsync->QueryStatus(&hr, NULL));

	    CHECK_NOFAIL(hr);

		CHECK_SUCCESS(pvbcRestore->GetWriterMetadataCount(&cWriters));
		for(iWriter = 0; iWriter < cWriters; iWriter++)
			{
			CComPtr<IVssExamineWriterMetadata> pMetadata;
			VSS_ID idInstance;
			CHECK_SUCCESS(pvbcRestore->GetWriterMetadata(iWriter, &idInstance, &pMetadata));
			}

		pAsync = NULL;

		pvbcRestore->PostRestore(&pAsync);
		LoopWait(pAsync, 5, L"PostRetore");
	    CHECK_NOFAIL(hr);
	    }
	    }
	}
    catch(...)
	{
	BS_ASSERT(FALSE);
	hr = E_UNEXPECTED;
	}

    if (bSubscribed)
		pInstance->Unsubscribe();

    if (bCreated)
		delete pInstance;

    if (FAILED(hr))
	wprintf(L"Failed with %08x.\n", hr);

    if (bCoInitializeSucceeded)
	CoUninitialize();

    return(0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\tests\harness\common\assrt.cxx ===
/*++

Copyright (c) 200  Microsoft Corporation

Module Name:

    assrt.cxx

Abstract:
	assertion code used by VSTST_ASSERT

Author:


Revision History:
	Name		Date		Comments
	brianb		05/23/2000	created

--*/


#include "stdafx.h"


VOID
AssertFail
	(
    IN LPCSTR FileName,
    IN UINT LineNumber,
    IN LPCSTR Condition
    )
	{
    int i;
    CHAR Msg[4096];

    //
    // Use dll name as caption
    //
    sprintf(
        Msg,
        "Assertion failure at line %u in file %s in process %d thread %d: %s\n\nHit Cancel to break into the debugger.",
        LineNumber,
        FileName,
		GetCurrentProcessId(),
		GetCurrentThreadId(),
        Condition
        );

    i = MessageBoxA
			(
            NULL,
            Msg,
			"Volume Snapshots",
			MB_SYSTEMMODAL | MB_ICONSTOP | MB_OKCANCEL | MB_SERVICE_NOTIFICATION
            );

    if(i == IDCANCEL)
        DebugBreak();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\tests\harness\backup\stdafx.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <atlbase.h>
#include <vststtools.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\tests\harness\backup\backup.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    backup.cpp

Abstract:

    main module of backup test exe


    Brian Berkowitz  [brianb]  05/23/2000

TBD:
	

Revision History:

    Name        Date        Comments
    brianb      05/23/2000  Created
	brianb		06/16/2000  Added comments

--*/

#include <stdafx.h>
#include <vststmsgclient.hxx>
#include <tstiniconfig.hxx>
#include <vststprocess.hxx>
#include <vss.h>
#include <vswriter.h>
#include <vsbackup.h>
#include <vststparser.hxx>
#include <vststutil.hxx>
#include <vststvolinfo.hxx>
#include <backup.h>

void LogUnexpectedFailure(LPCWSTR wsz, ...);


// selection of volumes
static LPCWSTR x_wszVolumeBackup = L"VolumeBackup";
static LPCWSTR x_wszSome = L"Some";
static LPCWSTR x_wszOne = L"One";
static LPCWSTR x_wszAll = L"All";

// selection of file system type
static LPCWSTR x_wszFileSystemBackup = L"FileSystemBackup";
static LPCWSTR x_wszNTFS = L"NTFS";
static LPCWSTR x_wszFAT32 = L"FAT32";
static LPCWSTR x_wszFAT16 = L"FAT16";
static LPCWSTR x_wszRAW = L"RAW";

// what to backup
static LPCWSTR x_wszBackingUp = L"BackingUp";
static LPCWSTR x_wszSerialVolumes = L"Serial";
static LPCWSTR x_wszVolumes = L"Volumes";
static LPCWSTR x_wszComponents = L"Components";

// cancelling async operations
static LPCWSTR x_wszCancelPrepareBackup = L"CancelPrepareBackup";
static LPCWSTR x_wszCancelDoSnapshotSet = L"CancelDoSnapshotSet";
static LPCWSTR x_wszCancelBackupComplete = L"CancelBackupComplete";

// wait time interval
static LPCWSTR x_wszWaitInterval = L"WaitInterval";


// volumes to exclude
static LPCWSTR x_wszExcludeVolumes = L"ExcludeVolumes";

// volumes to include
static LPCWSTR x_wszVolumeList = L"VolumeList";

// volumes to fill with data
static LPCWSTR x_wszFillVolumes = L"FillVolumes";
static LPCWSTR x_wszFillVolumesOptRandom = L"Random";
static LPCWSTR x_wszFillVolumesOptSelected = L"Selected";
static LPCWSTR x_wszFillVolumesOptNone = L"None";

// whether volumes filled with data should be fragmented
static LPCWSTR x_wszFillVolumesOptFragment = L"Fragment";

// which volumes to fill
static LPCWSTR x_wszFillVolumesList = L"FillVolumesList";

// constructor
CVsBackupTest::CVsBackupTest() :
		m_bTerminateTest(false),
		m_bBackupNTFS(false),
		m_bBackupFAT32(false),
		m_bBackupFAT16(false),
		m_bBackupRAW(false),
		m_bSerialBackup(false),
		m_bVolumeBackup(false),
		m_bComponentBackup(false),
		m_cyclesCancelPrepareBackup(0),
		m_cyclesCancelDoSnapshotSet(0),
		m_cyclesCancelBackupComplete(0),
		m_cVolumes(0),
		m_cVolumesLeft(0),
		m_cSnapshotSets(0),
		m_cExcludedVolumes(0),
		m_rgwszExcludedVolumes(NULL),
		m_cIncludedVolumes(0),
		m_rgwszIncludedVolumes(NULL),
		m_bRandomFills(false),
		m_bFragmentWhenFilling(false),
		m_rgwszFillVolumes(NULL),
		m_cFillVolumes(0)
		{
		}

// delete an array of strings
void CVsBackupTest::DeleteVolumeList(LPWSTR *rgwsz, UINT cwsz)
	{
	if (rgwsz)
		{
		for(UINT iwsz = 0; iwsz < cwsz; iwsz++)
			delete rgwsz[iwsz];
		}

	delete rgwsz;
	}


// destructor
CVsBackupTest::~CVsBackupTest()
	{
	// delete any snapshot sets that are cached
	if (m_cSnapshotSets)
		DeleteCachedSnapshotSets();

	delete m_wszVolumesSnapshot;

	// delete various lists of volumes (string arrays)
	DeleteVolumeList(m_rgwszExcludedVolumes, m_cExcludedVolumes);
	DeleteVolumeList(m_rgwszIncludedVolumes, m_cIncludedVolumes);
	DeleteVolumeList(m_rgwszFillVolumes, m_cFillVolumes);
	}

// enable a privilege
BOOL CVsBackupTest::AssertPrivilege(LPCWSTR privName)
	{
    HANDLE  tokenHandle;
    BOOL    stat = FALSE;

    if (OpenProcessToken
			(
			GetCurrentProcess(),
			TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,
			&tokenHandle
			))
		{
        LUID value;

		// obtain privilige value
        if (LookupPrivilegeValue( NULL, privName, &value ))
			{
            TOKEN_PRIVILEGES newState;
            DWORD            error;

            newState.PrivilegeCount           = 1;
            newState.Privileges[0].Luid       = value;
            newState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED_BY_DEFAULT|SE_PRIVILEGE_ENABLED;

            /*
            * We will always call GetLastError below, so clear
            * any prior error values on this thread.
            */
            SetLastError( ERROR_SUCCESS );

            stat =  AdjustTokenPrivileges
				(
                tokenHandle,
                FALSE,
                &newState,
                (DWORD)0,
                NULL,
                NULL
				);
            /*
            * Supposedly, AdjustTokenPriveleges always returns TRUE
            * (even when it fails). So, call GetLastError to be
            * extra sure everything's cool.
            */
            if ((error = GetLastError()) != ERROR_SUCCESS)
                stat = FALSE;

            if (!stat)
				{
				char buf[128];
				sprintf
					(
					buf,
					"AdjustTokenPrivileges for %s failed with %d",
                    privName,
                    error
					);

                LogFailure(buf);
				}
			}
		
		CloseHandle(tokenHandle);
		}

    return stat;
	}

// build a list of volumes
void CVsBackupTest::BuildVolumeList
	(
	LPCWSTR wszOption,
	UINT *pcVolumes,
	LPWSTR **prgwszVolumes
	)
	{
	// delete existing volume list
	DeleteVolumeList(*prgwszVolumes, *pcVolumes);
	*prgwszVolumes = NULL;
	*pcVolumes = 0;

	// get option value
	CBsString bssVolumes;
	m_pConfig->GetOptionValue(wszOption, &bssVolumes);

	// split into seperate strings for each volume
	LPCWSTR wszEnd = CVsTstParser::SplitOptions(bssVolumes);
	LPCWSTR wszStart = bssVolumes;
	UINT cVolumes = 0;

	// count number of volumes in exclude list
	while(wszStart < wszEnd)
		{
		cVolumes++;
		wszStart += wcslen(wszStart) + 1;
		}

	// allocate array for strings
	*prgwszVolumes = new LPWSTR[cVolumes];
	if (*prgwszVolumes == NULL)
		{
		LogUnexpectedFailure(L"Out of Memory");
		throw E_OUTOFMEMORY;
		}
	
	wszStart = bssVolumes;
	for (UINT iVolume = 0; iVolume < cVolumes; iVolume++)
		{
		// extract a string value
		LPWSTR wszNew = new WCHAR[wcslen(wszStart) + 2];
		if (wszNew == NULL)
			{
			LogUnexpectedFailure(L"Out of Memory");
			throw E_OUTOFMEMORY;
			}

		UINT cwc = (UINT) wcslen(wszStart);

		memcpy(wszNew, wszStart, cwc * sizeof(WCHAR));
		wszStart += cwc + 1;

		// add trailing backslash if not there in order to convert
		// into a path to the root directory on the voloume
		if (wszNew[cwc-1] != L'\\')
			wszNew[cwc++] = L'\\';

		wszNew[cwc] = L'\0';
		
		WCHAR wsz[MAX_PATH];
		// get unique volume name
		if (!GetVolumeNameForVolumeMountPoint(wszNew, wsz, MAX_PATH))
			{
			delete wszNew;
			LogUnexpectedFailure
				(
				L"Cannot find unique volume name for volume volume %s due to error %d.",
				wszStart,
				GetLastError()
				);
			}
		else
			{
			delete wszNew;

			// allocate new string for unique volume name
			(*prgwszVolumes)[*pcVolumes] = new WCHAR[wcslen(wsz) + 1];
			if ((*prgwszVolumes)[*pcVolumes] == NULL)
				{
				LogUnexpectedFailure(L"Out of Memory");
				throw E_OUTOFMEMORY;
				}

			wcscpy((*prgwszVolumes)[*pcVolumes], wsz);

		    // incrmement count of volumes
			*pcVolumes += 1;
			}
		}
	}


// callback to run the test
HRESULT CVsBackupTest::RunTest
	(
	CVsTstINIConfig *pConfig,		// configuration file (selected section)
	CVsTstClientMsg *pClient,		// message pipe
	CVsTstParams *pParams			// command line parameters
	)
	{
	// save supplied parameters
	m_pConfig = pConfig;
	m_pParams = pParams;
	SetClientMsg(pClient);

	try
		{
		// make sure that backup privileges are enabled
		if (!AssertPrivilege(SE_BACKUP_NAME))
			{
			LogFailure("Unable to assert backup privilege");
			throw E_UNEXPECTED;
			}

		// determine what we are backing up
		CBsString bssBackingUp;
		m_pConfig->GetOptionValue(x_wszBackingUp, &bssBackingUp);

		// determe the type of volume backup being performed
		CBsString bssVolumeBackup;
		m_pConfig->GetOptionValue(x_wszVolumeBackup, &bssVolumeBackup);

		// determine which volumes are being backed up
		CBsString bssFilesystemBackup;
		m_pConfig->GetOptionValue(x_wszFileSystemBackup, &bssFilesystemBackup);

		// get value of FillVolumes option
		CBsString bssFillVolumes;
		m_pConfig->GetOptionValue(x_wszFillVolumes, &bssFillVolumes);


		// get cancel test options
		m_pConfig->GetOptionValue(x_wszCancelPrepareBackup, &m_llCancelPrepareBackupLow, &m_llCancelPrepareBackupHigh);
		m_pConfig->GetOptionValue(x_wszCancelDoSnapshotSet, &m_llCancelDoSnapshotSetLow, &m_llCancelDoSnapshotSetHigh);
		m_pConfig->GetOptionValue(x_wszCancelBackupComplete, &m_llCancelBackupCompleteLow, &m_llCancelBackupCompleteHigh);


		// get wait time interval
		LONGLONG llWaitTimeLow, llWaitTimeHigh;
		m_pConfig->GetOptionValue(x_wszWaitInterval, &llWaitTimeLow, &llWaitTimeHigh);
		m_waitTime = (UINT) llWaitTimeLow;

		// determine type of backup
		if (_wcsicmp(bssBackingUp, x_wszComponents) == 0)
			m_bComponentBackup = true;
		else if (_wcsicmp(bssBackingUp, x_wszVolumes) == 0)
			m_bVolumeBackup = true;
		else if (_wcsicmp(bssBackingUp, x_wszSerialVolumes) == 0)
			m_bSerialBackup = true;

		// determine how many volumes are snapshot
		if (_wcsicmp(bssVolumeBackup, x_wszAll) == 0)
			m_backupVolumes = VSTST_BV_ALL;
		else if (_wcsicmp(bssVolumeBackup, x_wszSome) == 0)
			m_backupVolumes = VSTST_BV_SOME;
		else if (_wcsicmp(bssVolumeBackup, x_wszOne) == 0)
			m_backupVolumes = VSTST_BV_ONE;

		// determine which file systems are backed up
		LPCWSTR wszEnd = CVsTstParser::SplitOptions(bssFilesystemBackup);
		LPCWSTR wszStart = bssFilesystemBackup;
		while(wszStart < wszEnd)
			{
			if (_wcsicmp(wszStart, x_wszAll) == 0)
				{
				m_bBackupNTFS = true;
				m_bBackupFAT16 = true;
				m_bBackupFAT32 = true;
				m_bBackupRAW = true;
				break;
				}

			else if (_wcsicmp(wszStart, x_wszNTFS) == 0)
				m_bBackupNTFS = true;
			else if (_wcsicmp(wszStart, x_wszFAT32) == 0)
				m_bBackupFAT32 = true;
			else if (_wcsicmp(wszStart, x_wszFAT16) == 0)
				m_bBackupFAT16 = true;
			else if (_wcsicmp(wszStart, x_wszRAW) == 0)
				m_bBackupRAW = true;

			wszStart += wcslen(wszStart) + 1;
			}

		// build list of excluded volumes
		BuildVolumeList
			(
			x_wszExcludeVolumes,
			&m_cExcludedVolumes,
			&m_rgwszExcludedVolumes
			);

		// build list of included volumes
        BuildVolumeList
			(
			x_wszVolumeList,
			&m_cIncludedVolumes,
			&m_rgwszIncludedVolumes
			);

        // build list of volumes to fill
        BuildVolumeList
			(
			x_wszFillVolumesList,
			&m_cFillVolumes,
			&m_rgwszFillVolumes
			);

        // log information about the test
		LogMessage("Starting Backup test.\n");
		if (m_bVolumeBackup || m_bSerialBackup)
			{
			LogMessage("Performing volume backup\n");

			if (m_bSerialBackup)
				LogMessage("Serially backing up volumes\n");

			if (m_bBackupNTFS && m_bBackupFAT32 &&
				m_bBackupRAW && m_bBackupFAT16)
				LogMessage("Backing up all file systems\n");
			else
				{
				if (m_bBackupNTFS)
					LogMessage("Backing up NTFS volumes.\n");
				if (m_bBackupFAT32)
					LogMessage("Backing up FAT32 volumes.\n");
				if (m_bBackupFAT16)
					LogMessage("Backing up FAT16 volumes.\n");
				if (m_bBackupRAW)
					LogMessage("Backing up RAW volumes.\n");
				}

			if (m_backupVolumes == VSTST_BV_ONE)
				LogMessage("Backing up one volume at a time");
			else if (m_backupVolumes == VSTST_BV_SOME)
				LogMessage("Backing up multiple volumes at a time");
			else if (m_backupVolumes == VSTST_BV_ALL)
				LogMessage("Backing up all volumes at once");
			}
		else
			LogMessage("Performing component backup.\n");

		if (m_llCancelPrepareBackupHigh > 0i64)
			LogMessage("Cancel during PrepareBackup.\n");

		if (m_llCancelDoSnapshotSetHigh > 0i64)
			LogMessage("Cancel during DoSnapshotSet.\n");

		if (m_llCancelBackupCompleteHigh > 0i64)
			LogMessage("Cancel during BackupComplete.\n");

		// run the test until told to terminate the test
		while(!m_bTerminateTest)
			RunBackupTest();

		LogMessage("Ending backup test.\n");
		}
	catch(...)
		{
		return E_FAIL;
		}

	return S_OK;
	}

// routine to handle waiting for an asynchronous operation to compelte
HRESULT CVsBackupTest::WaitLoop
	(
	IVssBackupComponents *pvbc,
	IVssAsync *pAsync,
	UINT cycles,
	VSS_WRITER_STATE state1,
	VSS_WRITER_STATE state2,
	VSS_WRITER_STATE state3,
	VSS_WRITER_STATE state4,
	VSS_WRITER_STATE state5,
	VSS_WRITER_STATE state6,
	VSS_WRITER_STATE state7
	)
	{
	HRESULT hr;
	INT nPercentDone;
	HRESULT hrResult;

	while(TRUE)
		{
		if (cycles == 0)
			{
			hr = pAsync->Cancel();
			ValidateResult(hr, "IVssAsync::Cancel");

			GetAndValidateWriterState
				(
				pvbc,
				state1,
				state2,
				state3,
				state4,
				state5,
				state6,
				state7
				);

			while(TRUE)
				{
				hr = pAsync->QueryStatus(&hrResult, &nPercentDone);
				ValidateResult(hr, "IVssAsync::QueryStatus");
				if (hrResult != STG_S_ASYNC_PENDING)
					return hrResult;

				Sleep(m_waitTime);
				}
			}

		cycles--;
		hr = pAsync->QueryStatus(&hrResult, &nPercentDone);
		ValidateResult(hr, "IVssAsync::QueryStatus");
		if (hrResult == STG_S_ASYNC_FINISHED)
			break;
		else if (hrResult != STG_S_ASYNC_PENDING)
			return hrResult;

		Sleep(m_waitTime);
		}

	return S_OK;
	}


void CVsBackupTest::RunBackupTest()
	{
	if (m_wszVolumesSnapshot == NULL)
		{
		m_wszVolumesSnapshot = new WCHAR[1024];
		if (m_wszVolumesSnapshot == NULL)
			{
			LogFailure("Out of memory");
			throw E_OUTOFMEMORY;
			}

		m_cwcVolumesSnapshot = 1024;
		}

	m_wszVolumesSnapshot[0] = L'\0';
	CComPtr<IVssBackupComponents> pvbc;
	HRESULT hr;
	bool bAbortNeeded = false;
	bool bDeleteNeeded = false;


	VSS_ID id = GUID_NULL;
	try
		{
		hr = CreateVssBackupComponents(&pvbc);
		ValidateResult(hr, "CreateVssBackupComponents");


		hr = pvbc->InitializeForBackup();
		ValidateResult(hr, "IVssBackupComponents::InitializeForBackup");
		hr = pvbc->SetBackupState(true, false, VSS_BT_FULL);
		ValidateResult(hr, "IVssBackupComponents::SetBackupState");
		hr = pvbc->StartSnapshotSet(&id);
		bAbortNeeded = true;
		ValidateResult(hr, "IVssBackupComponents::StartSnapshotSet");
		GetMetadataAndSetupComponents(pvbc);
		if(m_bVolumeBackup || m_bSerialBackup)
			{
			if (m_cVolumes == 0)
				{
				m_volumeList.RefreshVolumeList();
				m_cVolumes = m_volumeList.GetVolumeCount();
				if (m_cVolumes > MAX_VOLUME_COUNT)
					m_cVolumes = MAX_VOLUME_COUNT;

				m_cVolumesLeft = m_cVolumes;
				memset(m_rgbAssignedVolumes, 0, m_cVolumes * sizeof(bool));
				RemoveNonCandidateVolumes();
				if (m_cVolumesLeft == 0)
					LogFailure("No Volumes to snapshot.");
				}

			if (m_backupVolumes == VSTST_BV_ONE)
				ChooseVolumeToBackup(pvbc);
			else if (m_backupVolumes == VSTST_BV_ALL)
				{
				// backup all volumes
				while(m_cVolumesLeft > 0)
					ChooseVolumeToBackup(pvbc);
				}
			else
				{
				// choose some subset of volumes to backup
				UINT cVolumesToBackup = CVsTstRandom::RandomChoice(1, m_cVolumes);
				while(cVolumesToBackup-- > 0)
					ChooseVolumeToBackup(pvbc);
				}
			}


			{
			CComPtr<IVssAsync> pAsync;
			hr = pvbc->PrepareForBackup(&pAsync);
			ValidateResult(hr, "IVssBackupComponents::PrepareForBackup");
			if (m_llCancelPrepareBackupHigh > 0i64)
				{
				if (m_cyclesCancelPrepareBackup < (UINT) m_llCancelPrepareBackupLow)
					m_cyclesCancelPrepareBackup = (UINT) m_llCancelPrepareBackupLow;
				}
			else
				m_cyclesCancelPrepareBackup = 0xffffffff;


			hr = WaitLoop
					(
					pvbc,
					pAsync,
					m_cyclesCancelPrepareBackup,
					VSS_WS_FAILED_AT_PREPARE_BACKUP,
					VSS_WS_STABLE
					);

			if (m_cyclesCancelPrepareBackup != 0xffffffff)
				m_cyclesCancelPrepareBackup++;

            if (m_cyclesCancelPrepareBackup > (UINT) m_llCancelPrepareBackupHigh)
				m_cyclesCancelPrepareBackup = 0xffffffff;
			}

		if (FAILED(hr))
			{
			char buf[128];
			sprintf(buf, "PrepareForBackup failed.  hr = 0x%08lx", hr);
			LogFailure(buf);
			throw hr;
			}

		if (hr == STG_S_ASYNC_CANCELLED)
			throw S_OK;

		LogMessage("PrepareForBackup Succeeded.\n");
		if (!GetAndValidateWriterState(pvbc, VSS_WS_STABLE))
			throw E_FAIL;

		LogMessage("Starting snapshot");

			{
			CComPtr<IVssAsync> pAsync;
			hr = pvbc->DoSnapshotSet(0, &pAsync);

			if (m_llCancelDoSnapshotSetHigh > 0i64)
				{
				if (m_cyclesCancelDoSnapshotSet < (UINT) m_llCancelDoSnapshotSetLow)
					m_cyclesCancelDoSnapshotSet = (UINT) m_llCancelDoSnapshotSetLow;
				}
			else
				m_cyclesCancelDoSnapshotSet = 0xffffffff;

			hr = WaitLoop
					(	
					pvbc,
					pAsync,
					m_cyclesCancelDoSnapshotSet,
					VSS_WS_FAILED_AT_PREPARE_SYNC,
					VSS_WS_FAILED_AT_FREEZE,
					VSS_WS_FAILED_AT_THAW,
					VSS_WS_WAITING_FOR_COMPLETION,
					VSS_WS_WAITING_FOR_FREEZE,
					VSS_WS_WAITING_FOR_THAW,
					VSS_WS_STABLE
					);

            if (m_cyclesCancelDoSnapshotSet != 0xffffffff)
				m_cyclesCancelDoSnapshotSet++;

            if (m_cyclesCancelDoSnapshotSet > (UINT) m_llCancelDoSnapshotSetHigh)
				m_cyclesCancelDoSnapshotSet = 0xffffffff;
			}

		if (FAILED(hr))
			{
			char buf[128];
			sprintf(buf, "DoSnapshotSet failed.  hr = 0x%08lx", hr);
			LogFailure(buf);
			throw hr;
			}

		if (hr == STG_S_ASYNC_CANCELLED)
			throw S_OK;

		bDeleteNeeded = true;
		LogMessage("DoSnapshotSet Succeeded.\n");
		bAbortNeeded = false;
		if (!GetAndValidateWriterState(pvbc, VSS_WS_WAITING_FOR_COMPLETION, VSS_WS_STABLE))
			throw E_FAIL;

		SetComponentsSuccessfullyBackedUp(pvbc);

			{
			CComPtr<IVssAsync> pAsync;
			hr = pvbc->BackupComplete(&pAsync);
			ValidateResult(hr, "IVssBackupComponents::BackupComplete");

			if (m_llCancelBackupCompleteHigh > 0i64)
				{
				if (m_cyclesCancelBackupComplete < (UINT) m_llCancelBackupCompleteLow)
					m_cyclesCancelBackupComplete = (UINT) m_llCancelBackupCompleteLow;
				}
			else
				m_cyclesCancelBackupComplete = 0xffffffff;

			hr = WaitLoop
					(
					pvbc,
					pAsync,
					m_cyclesCancelBackupComplete,
					VSS_WS_WAITING_FOR_COMPLETION,
					VSS_WS_STABLE
					);

            if (m_cyclesCancelBackupComplete != 0xffffffff)
				m_cyclesCancelBackupComplete++;

            if (m_cyclesCancelBackupComplete > (UINT) m_llCancelDoSnapshotSetHigh)
				m_cyclesCancelBackupComplete = 0xffffffff;
			}

		if (FAILED(hr))
			{
			char buf[128];
			sprintf(buf, "BackupComplete failed.  hr = 0x%08lx", hr);
			LogFailure(buf);
			throw hr;
			}

		if (hr == STG_S_ASYNC_CANCELLED)
			throw S_OK;

		LogMessage("BackupComplete Succeeded.\n");
		if (!GetAndValidateWriterState(pvbc, VSS_WS_STABLE, VSS_WS_WAITING_FOR_COMPLETION))
			throw E_FAIL;

		m_cyclesCancelPrepareBackup = 0;
		m_cyclesCancelDoSnapshotSet = 0;
		m_cyclesCancelBackupComplete = 0;
		}
	catch(...)
		{
		}

	char buf[128];

	if (bAbortNeeded)
		{
		hr = pvbc->AbortBackup();
		if (FAILED(hr))
			{
			sprintf(buf, "IVssBackupComponents::AbortBackup failed.  hr = 0x%08lx", hr);
			LogFailure(buf);
			}
		}

	if (bDeleteNeeded)
		{
		if (m_bSerialBackup)
			{
			m_rgSnapshotSetIds[m_cSnapshotSets] = id;
			m_rgvbc[m_cSnapshotSets] = pvbc.Detach();
			m_cSnapshotSets++;
			}
		else
			DoDeleteSnapshotSet(pvbc, id);
		}

	if (!m_bSerialBackup)
		{
		// reset for a new snapshot by causing volume list to be refreshed
		m_cVolumes = 0;
		m_cVolumesLeft = 0;
		}
	else if (m_cVolumesLeft == 0 ||
			 m_cSnapshotSets == MAX_SNAPSHOT_SET_COUNT ||
			 !bDeleteNeeded)
		{
		// delete existing snapshot sets if there was a failure or
		// if there are no more volumes to add or
		// if we can't create a new snapshot set.
		DeleteCachedSnapshotSets();
		m_cVolumes = 0;
		m_cVolumesLeft = 0;
		m_cSnapshotSets = 0;
		}
	}

// delete all snapshot sets that are cached
void CVsBackupTest::DeleteCachedSnapshotSets()
	{
	for(UINT iSnapshotSet = 0; iSnapshotSet < m_cSnapshotSets; iSnapshotSet++)
		{
		CComPtr<IVssBackupComponents> pvbc;
		pvbc.Attach(m_rgvbc[iSnapshotSet]);
		DoDeleteSnapshotSet(pvbc, m_rgSnapshotSetIds[iSnapshotSet]);
		}
	}


void CVsBackupTest::DoDeleteSnapshotSet(IVssBackupComponents *pvbc, VSS_ID id)
	{
	try
		{
		LONG lSnapshotsNotDeleted;
		VSS_ID rgSnapshotsNotDeleted[10];
		HRESULT hr  = pvbc->DeleteSnapshots
						(
						id,
						VSS_OBJECT_SNAPSHOT_SET,
						false,
						&lSnapshotsNotDeleted,
						rgSnapshotsNotDeleted
						);

		ValidateResult(hr, "IVssBackupComponents::DeleteSnapshots");
		}
	catch(HRESULT)
		{
		}
	catch(...)
		{
		LogUnexpectedException("CVsBackupTest::DoDeleteSnapshotSet");
		}
		
	}


bool CVsBackupTest::GetAndValidateWriterState
	(
	IVssBackupComponents *pvbc,
	VSS_WRITER_STATE ws1,
	VSS_WRITER_STATE ws2,
	VSS_WRITER_STATE ws3,
    VSS_WRITER_STATE ws4,
	VSS_WRITER_STATE ws5,
	VSS_WRITER_STATE ws6,
	VSS_WRITER_STATE ws7
	)
	{
	unsigned cWriters;

	HRESULT hr = pvbc->GatherWriterStatus(&cWriters);
	ValidateResult(hr, "IVssBackupComponents::GatherWriterStatus");

	for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
		{
		VSS_ID idInstance;
		VSS_ID idWriter;
		VSS_WRITER_STATE status;
		CComBSTR bstrWriter;
		HRESULT hrWriterFailure;

		hr = pvbc->GetWriterStatus
					(
					iWriter,
					&idInstance,
					&idWriter,
					&bstrWriter,
					&status,
					&hrWriterFailure
					);

        ValidateResult(hr, "IVssBackupComponents::GetWriterStatus");
		if (status == VSS_WS_UNKNOWN ||
			(status != ws1 &&
			 status != ws2 &&
			 status != ws3 &&
             status != ws4 &&
			 status != ws5 &&
			 status != ws6 &&
			 status != ws7))
            {
			char buf[128];

			sprintf(buf, "Writer is in inappropriate state %d.", status);
			LogFailure(buf);
			return false;
			}
		}

	hr = pvbc->FreeWriterStatus();
	ValidateResult(hr, "IVssBackupComponents::FreeWriterStatus");
	return true;
	}

void CVsBackupTest::SetComponentsSuccessfullyBackedUp
	(
	IVssBackupComponents *pvbc
	)
	{
	unsigned cWriterComponents;
	HRESULT hr = pvbc->GetWriterComponentsCount(&cWriterComponents);
	ValidateResult(hr, "IVssBackupComponents::GetWriterComponentsCount");
	for(UINT iWriter = 0; iWriter < cWriterComponents; iWriter++)
		{
		CComPtr<IVssWriterComponentsExt> pWriter;
		hr = pvbc->GetWriterComponents(iWriter, &pWriter);
		ValidateResult(hr, "IVssBackupComponents::GetWriterComponents");

		unsigned cComponents;
		hr = pWriter->GetComponentCount(&cComponents);
		ValidateResult(hr, "IVssWriterComponents::GetComponentCount");

		VSS_ID idWriter, idInstance;
		hr = pWriter->GetWriterInfo(&idInstance, &idWriter);
		ValidateResult(hr, "IVssWriterComponents::GetWriterInfo");
		for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
			{
			CComPtr<IVssComponent> pComponent;
			hr = pWriter->GetComponent(iComponent, &pComponent);
			ValidateResult(hr, "IVssWriterComponents::GetComponent");
				
			VSS_COMPONENT_TYPE ct;
			CComBSTR bstrLogicalPath;
			CComBSTR bstrComponentName;

			hr = pComponent->GetLogicalPath(&bstrLogicalPath);
			ValidateResult(hr, "IVssComponent::GetLogicalPath");
			hr = pComponent->GetComponentType(&ct);
			ValidateResult(hr, "IVssComponent::GetComponentType");
			hr = pComponent->GetComponentName(&bstrComponentName);
			ValidateResult(hr, "IVssComponent::GetComponentName");
			hr = pvbc->SetBackupSucceeded
								(
								idInstance,
								idWriter,
								ct,
								bstrLogicalPath,
								bstrComponentName,
								true
								);

			ValidateResult(hr, "IVssComponent::SetBackupSucceeded");
			}
		}
	}

void CVsBackupTest::GetMetadataAndSetupComponents
	(
	IVssBackupComponents *pvbc
	)
	{
	unsigned cWriters;
	HRESULT hr = pvbc->GatherWriterMetadata(&cWriters);
	ValidateResult(hr, "IVssBackupComponents::GatherWriterMetadata");

	for(unsigned iWriter = 0; iWriter < cWriters; iWriter++)
		{
		CComPtr<IVssExamineWriterMetadata> pMetadata;
		VSS_ID idInstance;

		hr = pvbc->GetWriterMetadata(iWriter, &idInstance, &pMetadata);
		ValidateResult(hr, "IVssBackupComponents::GetWriterMetadata");

		VSS_ID idInstanceT;
		VSS_ID idWriter;
		CComBSTR bstrWriterName;
		VSS_USAGE_TYPE usage;
		VSS_SOURCE_TYPE source;
		
		hr = pMetadata->GetIdentity
							(
							&idInstanceT,
							&idWriter,
							&bstrWriterName,
							&usage,
							&source
							);

        ValidateResult(hr, "IVssExamineWriterMetadata::GetIdentity");

		if (memcmp(&idInstance, &idInstanceT, sizeof(VSS_ID)) != 0)
			LogFailure("Id Instance mismatch");

		unsigned cIncludeFiles, cExcludeFiles, cComponents;
		hr = pMetadata->GetFileCounts(&cIncludeFiles, &cExcludeFiles, &cComponents);
		ValidateResult(hr, "IVssExamineWriterMetadata::GetFileCounts");

		CComBSTR bstrPath;
		CComBSTR bstrFilespec;
		CComBSTR bstrAlternate;
		CComBSTR bstrDestination;

		for(unsigned i = 0; i < cIncludeFiles; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;
			hr = pMetadata->GetIncludeFile(i, &pFiledesc);
			ValidateResult(hr, "IVssExamineWriterMetadata::GetIncludeFile");
			ValidateFiledesc(pFiledesc);
			}

		for(i = 0; i < cExcludeFiles; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;
			hr = pMetadata->GetExcludeFile(i, &pFiledesc);
			ValidateResult(hr, "IVssExamineWriterMetadata::GetExcludeFile");
			ValidateFiledesc(pFiledesc);
			}

		for(unsigned iComponent = 0; iComponent < cComponents; iComponent++)
			{
			CComPtr<IVssWMComponent> pComponent;
			PVSSCOMPONENTINFO pInfo;
			hr = pMetadata->GetComponent(iComponent, &pComponent);
			ValidateResult(hr, "IVssExamineWriterMetadata::GetComponent");
			hr = pComponent->GetComponentInfo(&pInfo);
			ValidateResult(hr, "IVssWMComponent::GetComponentInfo");
			if (m_bComponentBackup)
				{
				hr = pvbc->AddComponent
						(
						idInstance,
						idWriter,
						pInfo->type,
						pInfo->bstrLogicalPath,
						pInfo->bstrComponentName
						);

				ValidateResult(hr, "IVssBackupComponents::AddComponent");
				}
			if (pInfo->cFileCount > 0)
				{
				for(i = 0; i < pInfo->cFileCount; i++)
					{
					CComPtr<IVssWMFiledesc> pFiledesc;
					hr = pComponent->GetFile(i, &pFiledesc);
					ValidateResult(hr, "IVssWMComponent::GetFile");

					CComBSTR bstrPath;
					hr = pFiledesc->GetPath(&bstrPath);
					ValidateResult(hr, "IVssWMFiledesc::GetPath");
					if (m_bComponentBackup)
						DoAddToSnapshotSet(pvbc, bstrPath);

					ValidateFiledesc(pFiledesc);
					}
				}

			if (pInfo->cDatabases > 0)
				{
				for(i = 0; i < pInfo->cDatabases; i++)
					{
					CComPtr<IVssWMFiledesc> pFiledesc;
					hr = pComponent->GetDatabaseFile(i, &pFiledesc);
					ValidateResult(hr, "IVssWMComponent::GetDatabaseFile");
					
					
					CComBSTR bstrPath;
					hr = pFiledesc->GetPath(&bstrPath);
					ValidateResult(hr, "IVssWMFiledesc::GetPath");

					if (m_bComponentBackup)
						DoAddToSnapshotSet(pvbc, bstrPath);

					ValidateFiledesc(pFiledesc);
					}
				}

			if (pInfo->cLogFiles > 0)
				{
				for(i = 0; i < pInfo->cLogFiles; i++)
					{
					CComPtr<IVssWMFiledesc> pFiledesc;
					hr = pComponent->GetDatabaseLogFile(i, &pFiledesc);
					ValidateResult(hr, "IVssWMComponent::GetDatabaseLogFile");

					
					CComBSTR bstrPath;
					hr = pFiledesc->GetPath(&bstrPath);
					ValidateResult(hr, "IVssWMFiledesc::GetPath");
					if (m_bComponentBackup)
						DoAddToSnapshotSet(pvbc, bstrPath);

					ValidateFiledesc(pFiledesc);
					}
				}

			hr = pComponent->FreeComponentInfo(pInfo);
			ValidateResult(hr, "IVssWMComponent::FreeComponentInfo");
			}

		VSS_RESTOREMETHOD_ENUM method;
		CComBSTR bstrUserProcedure;
		CComBSTR bstrService;
		VSS_WRITERRESTORE_ENUM writerRestore;
		unsigned cMappings;
		bool bRebootRequired;

		hr = pMetadata->GetRestoreMethod
							(
							&method,
							&bstrService,
							&bstrUserProcedure,
							&writerRestore,
							&bRebootRequired,
							&cMappings
							);

        ValidateResult(hr, "IVssExamineWriterMetadata::GetRestoreMethod");

		for(i = 0; i < cMappings; i++)
			{
			CComPtr<IVssWMFiledesc> pFiledesc;

			hr = pMetadata->GetAlternateLocationMapping(i, &pFiledesc);
			ValidateResult(hr, "IVssExamineWriterMetadata::GetAlternateLocationMapping");
			ValidateFiledesc(pFiledesc);
			}
		}

	hr = pvbc->FreeWriterMetadata();
	ValidateResult(hr, "IVssBackupComponents::FreeWriterMetadata");
	}

void CVsBackupTest::ValidateFiledesc(IVssWMFiledesc *pFiledesc)
	{
	CComBSTR bstrPath;
	CComBSTR bstrFilespec;
	CComBSTR bstrAlternate;
	CComBSTR bstrDestination;
	bool bRecursive;

	HRESULT hr = pFiledesc->GetPath(&bstrPath);
	ValidateResult(hr, "IVssWMFiledesc::GetPath");
	hr = pFiledesc->GetFilespec(&bstrFilespec);
	ValidateResult(hr, "IVssWMFiledesc::GetFilespec");
	hr = pFiledesc->GetRecursive(&bRecursive);
	ValidateResult(hr, "IVssWMFiledesc::GetRecursive");
	hr = pFiledesc->GetAlternateLocation(&bstrAlternate);
	ValidateResult(hr, "IVssWMFiledesc::GetAlternateLocation");
	}


// add a component file to the snapshot set by determining which volume
// contains the file and then adding the file to the snapshot set if it
// is not already included.
void CVsBackupTest::DoAddToSnapshotSet
	(
	IN IVssBackupComponents *pvbc,
	IN LPCWSTR wszPath
	)
	{
	WCHAR wszVolume[MAX_PATH];
	UINT cwc = (UINT) wcslen(wszPath) + 1;
	WCHAR *wszVolumeMountPoint = new WCHAR[cwc];
	if (wszVolumeMountPoint == NULL)
		{
		LogFailure("Out of memory");
		throw E_OUTOFMEMORY;
		}

	if (!GetVolumePathName(wszPath, wszVolumeMountPoint, cwc))
		ValidateResult(HRESULT_FROM_WIN32(GetLastError()), "GetVolumePathName");

	if (!GetVolumeNameForVolumeMountPointW
			(
			wszVolumeMountPoint,
			wszVolume,
			MAX_PATH
			))
		ValidateResult(HRESULT_FROM_WIN32(GetLastError()), "GetVolumeNameForVolumeMountPointW");



	WCHAR *pwc = m_wszVolumesSnapshot;
	while(*pwc != '\0')
		{
		if (wcsncmp(pwc, wszVolume, wcslen(wszVolume)) == 0)
			return;

		pwc = wcschr(pwc, L';');
		if (pwc == NULL)
			break;

		pwc++;
		}
	

	HRESULT hr = pvbc->AddToSnapshotSet
						(
						wszVolume,
						GUID_NULL,
						L"",
						0,
						0,
						NULL,
						NULL
						);

    ValidateResult(hr, "IVssBackupComponents::AddToSnaphsotSet");
	if (pwc - m_wszVolumesSnapshot + wcslen(wszVolume) + 1 > m_cwcVolumesSnapshot)
		{
		WCHAR *wszVolumesNew = new WCHAR[m_cwcVolumesSnapshot + 1024];
		if(wszVolumesNew == NULL)
			{
			LogFailure("Out of memory");
			throw E_OUTOFMEMORY;
			}

		wcscpy(wszVolumesNew, m_wszVolumesSnapshot);
		delete m_wszVolumesSnapshot;
		m_wszVolumesSnapshot = wszVolumesNew;
		m_cwcVolumesSnapshot += 1024;
		pwc = m_wszVolumesSnapshot + wcslen(m_wszVolumesSnapshot);
		}

	*pwc++ = L';';
	wcscpy(pwc, wszVolume);
    }

// remove volumes for possible set of volume we can choose to backup based
// on configuration information
void CVsBackupTest::RemoveNonCandidateVolumes()
	{
	for(UINT iVolume = 0; iVolume < m_cVolumes; iVolume++)
		{
		// get volume information
		const CVsTstVolumeInfo *pVolume = m_volumeList.GetVolumeInfo(iVolume);
		bool bCandidate = false;

		// validate that file system is one we will backup
		if (pVolume->IsNtfs())
			bCandidate = m_bBackupNTFS;
		else if (pVolume->IsFat32())
			bCandidate = m_bBackupFAT32;
		else if (pVolume->IsFat())
			bCandidate = m_bBackupFAT16;
		else if (pVolume->IsRaw())
			bCandidate = m_bBackupRAW;

		// candidates must be in the included volumes list
		if (m_cIncludedVolumes > 0)
			{
			LPCWSTR wszVolumeName = pVolume->GetVolumeName();

			bool fFound = false;
			for(UINT iIncluded = 0; iIncluded < m_cIncludedVolumes; iIncluded++)
				{
				if (wcscmp(wszVolumeName, m_rgwszIncludedVolumes[iIncluded]) == 0)
					fFound = true;
				}

			if (!fFound)
				bCandidate = false;
			}

		// candidates must not be in the excluded volumes list
		if (m_cExcludedVolumes > 0)
			{
			LPCWSTR wszVolumeName = pVolume->GetVolumeName();

			for(UINT iExcluded = 0; iExcluded < m_cExcludedVolumes; iExcluded++)
				{
				if (wcscmp(wszVolumeName, m_rgwszExcludedVolumes[iExcluded]) == 0)
					bCandidate = false;
				}
			}

		// if it is not a candidate, mark it is if it is already in use.  This
		// will prevent us from choosing the volume as part of a snapshot set
		if (!bCandidate)
			{
			m_rgbAssignedVolumes[iVolume] = true;
			m_cVolumesLeft--;
			}
		}
	}

// pick a random volume to backup
void CVsBackupTest::ChooseVolumeToBackup(IVssBackupComponents *pvbc)
	{
	VSTST_ASSERT(m_cVolumesLeft > 0);

	UINT iVolume;
	while(TRUE)
		{
		// select a volume number
		iVolume = CVsTstRandom::RandomChoice(0, m_cVolumes-1);

		// check to see if volume is already assigned.  If not, then
		// break out of loop
		if (!m_rgbAssignedVolumes[iVolume])
			break;
		}

	// get volume information about volume
	const CVsTstVolumeInfo *pVolume = m_volumeList.GetVolumeInfo(iVolume);

	// add the volume to the snapshot set using the default provider
	HRESULT hr = pvbc->AddToSnapshotSet
							(
							(VSS_PWSZ) pVolume->GetVolumeName(),
							GUID_NULL,
							L"",
							0,
							0,
							NULL,
							NULL
							);

    ValidateResult(hr, "IVssBackupComponents::AddToSnapshotSet");

	// indicate that volume is assigned
	m_rgbAssignedVolumes[iVolume] = true;
	m_cVolumesLeft--;
	}



// main driver routine
extern "C" __cdecl wmain(int argc, WCHAR **argv)
	{
	CVsBackupTest *pTest = NULL;

	bool bCoInitializeSucceeded = false;
	try
		{
		// setup to use OLE
		HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		if (FAILED(hr))
			{
			LogUnexpectedFailure(L"CoInitialize Failed hr = 0x%08lx", hr);
			throw hr;
			}

		bCoInitializeSucceeded = true;

		// create test object
        pTest = new CVsBackupTest;
		if (pTest == NULL)
			{
			LogUnexpectedFailure(L"Cannot create test object.");
			throw(E_OUTOFMEMORY);
			}


		// run test using the test object
        hr = CVsTstRunner::RunVsTest(argv, argc, pTest, true);
		if (FAILED(hr))
			LogUnexpectedFailure(L"CVsTstRunner::RunTest failed.  hr = 0x%08lx", hr);
		}
	catch(HRESULT)
		{
		}
	catch(...)
		{
		LogUnexpectedFailure(L"Unexpected exception in wmain");
		}

	// delete test object
	delete pTest;

	// uninitialize OLE
	if (bCoInitializeSucceeded)
		CoUninitialize();

	return 0;
	}


// log an unexpected failure from the test.
void LogUnexpectedFailure(LPCWSTR wsz, ...)
	{
	va_list args;

	va_start(args, wsz);

	VSTST_ASSERT(FALSE);
	vwprintf(wsz, args);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\tests\harness\backup\backup.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    backup.h

Abstract:

    definitions for backup test exe


    Brian Berkowitz  [brianb]  06/02/2000

TBD:
	

Revision History:

    Name        Date        Comments
    brianb      06/02/2000  Created
	brianb		06/12/2000  Added comments

--*/

// options for snapshotting volumes
typedef enum VSTST_BACKUP_VOLUMES
	{
	VSTST_BV_UNDEFINE = 0,
	VSTST_BV_ONE,				// snapshot a single volume during a pass
	VSTST_BV_SOME,				// snasphot several volumes during a pass
	VSTST_BV_ALL				// snapshot all volumes during a pass
	};

// actual implementation of the test
class CVsBackupTest :
	public IVsTstRunningTest,
	public CVsTstClientLogger
	{
public:

	// constructor
	CVsBackupTest();

	// destructor
	~CVsBackupTest();

	// callback to run the test
	HRESULT RunTest
		(
		CVsTstINIConfig *pConfig,		// configuration file
		CVsTstClientMsg *pMsg,			// message pipe
		CVsTstParams *pParams			// command line parameters
		);


	// callback to shutdown the test
	HRESULT ShutdownTest(VSTST_SHUTDOWN_REASON reason)
		{
		UNREFERENCED_PARAMETER(reason);

		m_bTerminateTest = true;
		return S_OK;
		}

private:
	enum
		{
		// max number of volumes this test will deal with
		MAX_VOLUME_COUNT = 2048,

		// maximum number of simultaneous snapshots that this test will deal with
		MAX_SNAPSHOT_SET_COUNT = 128
		};


    // do a single run of the backup test
	void RunBackupTest();

	// obtain state of the writers and validate the state
	bool GetAndValidateWriterState
		(
		IVssBackupComponents *pvbc,
		VSS_WRITER_STATE ws1,
		VSS_WRITER_STATE ws2 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws3 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws4 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws5 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws6 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws7 = VSS_WS_UNKNOWN
		);

	// wait for a response from an asynchronous call.   Cycles controls
	// when a cancel of the asynchronous call is issued.  The writer states
	// are valid states for writers during the asynchronous call
    HRESULT WaitLoop
		(
		IVssBackupComponents *pvbc,
		IVssAsync *pAsync,
		UINT cycles,
		VSS_WRITER_STATE ws1,
		VSS_WRITER_STATE ws2 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws3 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws4 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws5 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws6 = VSS_WS_UNKNOWN,
		VSS_WRITER_STATE ws7 = VSS_WS_UNKNOWN
		);

    // if components are being backed up, indicate that components were
	// successfully backed up
	void SetComponentsSuccessfullyBackedUp(IVssBackupComponents *pvbc);

	// validate metadata obtained by writers and add components to backup
	// components document, if component backup is used
	void GetMetadataAndSetupComponents(IVssBackupComponents *pvbc);

	// add a volume to the snapshot set based on the path
	void DoAddToSnapshotSet
		(
		IN IVssBackupComponents *pvbc,
		IN LPCWSTR bstrPath
		);

    // validate a IVssWMFiledesc object
	void ValidateFiledesc(IVssWMFiledesc *pFiledesc);

	// assert a privilege, either backup or restore
    BOOL AssertPrivilege(LPCWSTR privName);

	// remove volumes that are not candidates for the snapshot
	// based on test configuration
	void RemoveNonCandidateVolumes();

	// choose a volume to backup from non-snapshotted volumes
	void ChooseVolumeToBackup(IVssBackupComponents *pvbc);

	// delete a snapshot set
	void DoDeleteSnapshotSet(IVssBackupComponents *pvbc, VSS_ID id);

	// delete a list of strings
	void DeleteVolumeList(LPWSTR *rgwsz, UINT cwsz);

	// build a volume list
	void BuildVolumeList(LPCWSTR wszOption, UINT *pcVolumes, LPWSTR **prgwsz);

	// delete snapshot sets that are cached by the serial test
	void DeleteCachedSnapshotSets();

	// configuration file
	CVsTstINIConfig *m_pConfig;

	// command line parameters
	CVsTstParams *m_pParams;

	// flag indicating that test should be terminated after the current
	// run is complete
	bool m_bTerminateTest;


	// range for cancelling PrepareBackup
	LONGLONG m_llCancelPrepareBackupLow;
	LONGLONG m_llCancelPrepareBackupHigh;

	// range for cancelling DoSnapshotSet
	LONGLONG m_llCancelDoSnapshotSetLow;
	LONGLONG m_llCancelDoSnapshotSetHigh;

	// range for cancelling BackupComplete
	LONGLONG m_llCancelBackupCompleteLow;
	LONGLONG m_llCancelBackupCompleteHigh;

	// number of cycles to loop until calling cancel during PrepareBackup
	UINT m_cyclesCancelPrepareBackup;

   	// number of cycles to loop until calling cancel during DoSnapshotSet
	UINT m_cyclesCancelDoSnapshotSet;

	// number of cycles to loop until calling cancel during BackupComplete
	UINT m_cyclesCancelBackupComplete;

	// is this a component backup
	bool m_bComponentBackup;

	// is this a volume backup
	bool m_bVolumeBackup;

	// is this a serial volume (i.e., multiple backups on different volumes) backup
	bool m_bSerialBackup;

	// should ntfs volumes be backed up
	bool m_bBackupNTFS;

	// should fat32 volumes be backed up
	bool m_bBackupFAT32;

	// should fat16 volumes be backed up
	bool m_bBackupFAT16;

	// should raw volumes be backed up
	bool m_bBackupRAW;

	// how many volumes should be backed up at a time
	VSTST_BACKUP_VOLUMES m_backupVolumes;

	// volume list
	CVsTstVolumeList m_volumeList;

	// number of volumes in the volume list
	UINT m_cVolumes;

	// number of volumes left in the volume list
	UINT m_cVolumesLeft;

	// array of snapshot sets created
	VSS_ID m_rgSnapshotSetIds[MAX_SNAPSHOT_SET_COUNT];

	// array of backup components objects created
	IVssBackupComponents *m_rgvbc[MAX_SNAPSHOT_SET_COUNT];

	// # of snapshot sets
	UINT m_cSnapshotSets;

	// array of assigned volumes
	bool m_rgbAssignedVolumes[MAX_VOLUME_COUNT];

	// array of excluded volumes
	LPWSTR *m_rgwszExcludedVolumes;

	// count of excluded volumes
	UINT m_cExcludedVolumes;

	// array of volumes to include in the snapshot
	LPWSTR *m_rgwszIncludedVolumes;

	// number of volumes in included array
	UINT m_cIncludedVolumes;

	// perform random fills of volumes to check diff allocation code
	bool m_bRandomFills;

	// perform selected fills of volumes
	bool m_bSelectedFills;

	// try to fragment volumes when filling them
	bool m_bFragmentWhenFilling;

	// array of volumes that should be filled
	LPWSTR *m_rgwszFillVolumes;

	// number of volumes that should be filled
	UINT m_cFillVolumes;

	// array of volumes
	LPWSTR m_wszVolumesSnapshot;

	// size of volume array
	UINT m_cwcVolumesSnapshot;

	// time for wait interval
	UINT m_waitTime;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\tests\harness\common\stdafx.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <atlbase.h>
#include <vststtools.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\tests\harness\common\bsfixalloc.cxx ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    bsfixalloc.cpp

Abstract:

    Adapted from MFC 6 SR 1 release of fixalloc.cpp.  Removed all MFC stuff.

Author:

    Stefan R. Steiner   [ssteiner]        4-10-2000

Revision History:

--*/

// fixalloc.cpp - implementation of fixed block allocator

//#include "stdafx.h"
#include <windows.h>
#include <assert.h>
#include "bsfixalloc.hxx"

#define ASSERT assert
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;

// #define new DEBUG_NEW
#endif


/////////////////////////////////////////////////////////////////////////////
// CBsFixedAlloc

CBsFixedAlloc::CBsFixedAlloc(UINT nAllocSize, UINT nBlockSize)
{
	ASSERT(nAllocSize >= sizeof(CNode));
	ASSERT(nBlockSize > 1);
    //wprintf( L"CBsFixedAlloc called, nAllocSize: %d, nBlockSize: %d\n", nAllocSize, nBlockSize );
	m_nAllocSize = nAllocSize;
	m_nBlockSize = nBlockSize;
	m_pNodeFree = NULL;
	m_pBlocks = NULL;
	InitializeCriticalSection(&m_protect);
}

CBsFixedAlloc::~CBsFixedAlloc()
{
	FreeAll();
	DeleteCriticalSection(&m_protect);
}

void CBsFixedAlloc::FreeAll()
{
	EnterCriticalSection(&m_protect);
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
	m_pNodeFree = NULL;
	LeaveCriticalSection(&m_protect);
}

void* CBsFixedAlloc::Alloc()
{
	EnterCriticalSection(&m_protect);
	if (m_pNodeFree == NULL)
	{
		CBsPlex* pNewBlock = NULL;
		try
		{
			// add another block
			pNewBlock = CBsPlex::Create(m_pBlocks, m_nBlockSize, m_nAllocSize);
            //wprintf( L"Alloc getting more core, nAllocSize: %d\n", m_nAllocSize );
		}
		catch( ... )
		{
			LeaveCriticalSection(&m_protect);
			throw;
		}

		// chain them into free list
		CNode* pNode = (CNode*)pNewBlock->data();
		// free in reverse order to make it easier to debug
		(BYTE*&)pNode += (m_nAllocSize * m_nBlockSize) - m_nAllocSize;
		for (int i = m_nBlockSize-1; i >= 0; i--, (BYTE*&)pNode -= m_nAllocSize)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	// remove the first available node from the free list
	void* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;

	LeaveCriticalSection(&m_protect);
	return pNode;
}

void CBsFixedAlloc::Free(void* p)
{
	if (p != NULL)
	{
		EnterCriticalSection(&m_protect);

		// simply return the node to the free list
		CNode* pNode = (CNode*)p;
		pNode->pNext = m_pNodeFree;
		m_pNodeFree = pNode;
		LeaveCriticalSection(&m_protect);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBsPlex

CBsPlex* PASCAL CBsPlex::Create(CBsPlex*& pHead, UINT nMax, UINT cbElement)
{
	ASSERT(nMax > 0 && cbElement > 0);
	CBsPlex* p = (CBsPlex*) new BYTE[sizeof(CBsPlex) + nMax * cbElement];
			// may throw exception
    if ( p == NULL )
        throw( E_OUTOFMEMORY );

	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

void CBsPlex::FreeDataChain()     // free this one and links
{
	CBsPlex* p = this;
	while (p != NULL)
	{
		BYTE* bytes = (BYTE*) p;
		CBsPlex* pNext = p->pNext;
		delete[] bytes;
		p = pNext;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\volsnap\vss\tests\harness\common\bsstring.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    bsstring.cpp

Abstract:

    This module implements the CBsString class.  This class manages character
    arrays in a similar manner as the CString class in VC++.  In fact, this
    class is a copy of the CString class with the MFC specific stuff ripped
    out since LTS doesn't use MTF.

Author:

    Stefan R. Steiner   [SSteiner]      1-Mar-1998

Revision History:

    Stefan R. Steiner   [SSteiner]      10-Apr-2000
        Added fixed allocator code and resynced with MFC 6 SR-1 code
        
--*/

//#include "stdafx.h"
#include <windows.h>
#include "bsstring.hxx"
#include <malloc.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

struct _BSAFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };
struct _BSAFX_FLOAT   { BYTE floatBits[sizeof(float)]; };

// #define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

TCHAR bsafxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int _bsafxInitData[] = { -1, 0, 0, 0 };
static CBsStringData* _bsafxDataNil = (CBsStringData*)&_bsafxInitData;
static LPCTSTR _bsafxPchNil = (LPCTSTR)(((BYTE*)&_bsafxInitData)+sizeof(CBsStringData));
// special function to make bsafxEmptyString work even during initialization
const CBsString& BSAFXAPI BsAfxGetEmptyString()
	{ return *(CBsString*)&_bsafxPchNil; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CBsString::CBsString()
{
	Init();
}

CBsString::CBsString(const CBsString& stringSrc)
{
	ASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ASSERT(stringSrc.GetData() != _bsafxDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

CBsString::CBsString(GUID guid)
{
	Init();
	AllocBuffer(38);
    _stprintf( m_pchData, _T("{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
               guid.Data1, guid.Data2, guid.Data3, guid.Data4[0], guid.Data4[1], 
               guid.Data4[2], guid.Data4[3], guid.Data4[4], guid.Data4[5], 
               guid.Data4[6], guid.Data4[7] );
}

#ifndef _DEBUG

#pragma warning(disable: 4074)
#pragma init_seg(compiler)

#define ROUND(x,y) (((x)+(y-1))&~(y-1))
#define ROUND4(x) ROUND(x, 4)
static CBsFixedAlloc _bsafxAlloc8(ROUND4(9*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc16(ROUND4(17*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc32(ROUND4(33*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc64(ROUND4(65*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc128(ROUND4(129*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc256(ROUND4(257*sizeof(TCHAR)+sizeof(CBsStringData)));
static CBsFixedAlloc _bsafxAlloc512(ROUND4(513*sizeof(TCHAR)+sizeof(CBsStringData)));

#endif //!_DEBUG

void CBsString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
	ASSERT(nLen >= 0);
	ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CBsStringData* pData;	    
#ifndef _DEBUG
		if (nLen <= 8)
		{
			pData = (CBsStringData*)_bsafxAlloc8.Alloc();
			pData->nAllocLength = 8;
		} 
		else if (nLen <= 16)
		{
			pData = (CBsStringData*)_bsafxAlloc16.Alloc();
			pData->nAllocLength = 16;
		} 
		else if (nLen <= 32)
		{
			pData = (CBsStringData*)_bsafxAlloc32.Alloc();
			pData->nAllocLength = 32;
		} 
		else if (nLen <= 64)
		{
			pData = (CBsStringData*)_bsafxAlloc64.Alloc();
			pData->nAllocLength = 64;
		}
		else if (nLen <= 128)
		{
			pData = (CBsStringData*)_bsafxAlloc128.Alloc();
			pData->nAllocLength = 128;
		}
		else if (nLen <= 256)
		{
			pData = (CBsStringData*)_bsafxAlloc256.Alloc();
			pData->nAllocLength = 256;
		}
		else if (nLen <= 512)
		{
			pData = (CBsStringData*)_bsafxAlloc512.Alloc();
			pData->nAllocLength = 512;
		}
		else
#endif
		{
			pData = (CBsStringData*)
				new BYTE[sizeof(CBsStringData) + (nLen+1)*sizeof(TCHAR)];
            if ( pData == NULL )
                throw E_OUTOFMEMORY;

			pData->nAllocLength = nLen;
		}
		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		m_pchData = pData->data();
	}
}

void FASTCALL CBsString::FreeData(CBsStringData* pData)
{
#ifndef _DEBUG
	int nLen = pData->nAllocLength;
	if (nLen == 8)
		_bsafxAlloc8.Free(pData);
	else if (nLen == 16)
		_bsafxAlloc16.Free(pData);
	else if (nLen == 32)
		_bsafxAlloc32.Free(pData);
	else if (nLen == 64)
		_bsafxAlloc64.Free(pData);
	else if (nLen == 128)
		_bsafxAlloc128.Free(pData);
	else if (nLen == 256)
		_bsafxAlloc256.Free(pData);
	else  if (nLen == 512)
		_bsafxAlloc512.Free(pData);
	else
	{
		ASSERT(nLen > 512);
		delete[] (BYTE*)pData;
	}
#else
	delete[] (BYTE*)pData;
#endif
}

void CBsString::Release()
{
	if (GetData() != _bsafxDataNil)
	{
		ASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			FreeData(GetData());
		Init();
	}
}

void PASCAL CBsString::Release(CBsStringData* pData)
{
	if (pData != _bsafxDataNil)
	{
		ASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			FreeData(pData);
	}
}

void CBsString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = &bsafxChNil;
	ASSERT(GetData()->nDataLength == 0);
	ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

void CBsString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CBsStringData* pData = GetData();
		Release();
		AllocBuffer(pData->nDataLength);
		memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ASSERT(GetData()->nRefs <= 1);
}

void CBsString::AllocBeforeWrite(int nLen)
{
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		AllocBuffer(nLen);
	}
	ASSERT(GetData()->nRefs <= 1);
}

CBsString::~CBsString()
//  free any attached data
{
	if (GetData() != _bsafxDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			FreeData(GetData());
	}
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CBsString::AllocCopy(CBsString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		dest.AllocBuffer(nNewLen);
		memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CBsString::CBsString(LPCTSTR lpsz)
{
	Init();
	int nLen = SafeStrlen(lpsz);
	if (nLen != 0)
	{
		AllocBuffer(nLen);
		memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CBsString::CBsString(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen);
		_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
}
#else //_UNICODE
CBsString::CBsString(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen != 0)
	{
		AllocBuffer(nSrcLen*2);
		_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CBsString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CBsString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	AllocBeforeWrite(nSrcLen);
	memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
	GetData()->nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
}

const CBsString& CBsString::operator=(const CBsString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != _bsafxDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ASSERT(stringSrc.GetData() != _bsafxDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

const CBsString& CBsString::operator=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CBsString& CBsString::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	AllocBeforeWrite(nSrcLen);
	_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
	ReleaseBuffer();
	return *this;
}
#else //!_UNICODE
const CBsString& CBsString::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	AllocBeforeWrite(nSrcLen*2);
	_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
	ReleaseBuffer();
	return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CBsString + CBsString
// and for ? = TCHAR, LPCTSTR
//          CBsString + ?
//          ? + CBsString

void CBsString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CBsString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		AllocBuffer(nNewLen);
		memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
		memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
	}
}

CBsString BSAFXAPI operator+(const CBsString& string1, const CBsString& string2)
{
	CBsString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

CBsString BSAFXAPI operator+(const CBsString& string, LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	CBsString s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
		CBsString::SafeStrlen(lpsz), lpsz);
	return s;
}

CBsString BSAFXAPI operator+(LPCTSTR lpsz, const CBsString& string)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	CBsString s;
	s.ConcatCopy(CBsString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
		string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CBsString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CBsStringData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ASSERT(pOldData != NULL);
		CBsString::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

const CBsString& CBsString::operator+=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || BsAfxIsValidString(lpsz));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CBsString& CBsString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

const CBsString& CBsString::operator+=(const CBsString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CBsString::GetBuffer(int nMinBufLength)
{
	ASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CBsStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		AllocBuffer(nMinBufLength);
		memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
		GetData()->nDataLength = nOldLen;
		CBsString::Release(pOldData);
	}
	ASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

void CBsString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

LPTSTR CBsString::GetBufferSetLength(int nNewLength)
{
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

void CBsString::FreeExtra()
{
	ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CBsStringData* pOldData = GetData();
		AllocBuffer(GetData()->nDataLength);
		memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
		ASSERT(m_pchData[GetData()->nDataLength] == '\0');
		CBsString::Release(pOldData);
	}
	ASSERT(GetData() != NULL);
}

LPTSTR CBsString::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

void CBsString::UnlockBuffer()
{
	ASSERT(GetData()->nRefs == -1);
	if (GetData() != _bsafxDataNil)
		GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CBsString::Find(TCHAR ch) const
{
	return Find(ch, 0);
}

int CBsString::Find(TCHAR ch, int nStart) const
{
	int nLength = GetData()->nDataLength;
	if (nStart >= nLength)
		return -1;

	// find first single character
	LPTSTR lpsz = _tcschr(m_pchData + nStart, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CBsString::FindOneOf(LPCTSTR lpszCharSet) const
{
	ASSERT(BsAfxIsValidString(lpszCharSet));
	LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

void CBsString::MakeUpper()
{
	CopyBeforeWrite();
	_tcsupr(m_pchData);
}

void CBsString::MakeLower()
{
	CopyBeforeWrite();
	_tcslwr(m_pchData);
}

void CBsString::MakeReverse()
{
	CopyBeforeWrite();
	_tcsrev(m_pchData);
}

void CBsString::SetAt(int nIndex, TCHAR ch)
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CBsString::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
void CBsString::OemToAnsi()
{
	CopyBeforeWrite();
	::OemToAnsi(m_pchData, m_pchData);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CBsString conversion helpers (these use the current system locale)

int BSAFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, (INT)count, NULL, NULL);
	ASSERT(mbstr == NULL || result <= (int)count);
	if (result > 0)
		mbstr[result-1] = 0;
	return result;
}

int BSAFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
		wcstr, (INT)count);
	ASSERT(wcstr == NULL || result <= (int)count);
	if (result > 0)
		wcstr[result-1] = 0;
	return result;
}

LPWSTR BSAFXAPI BsAfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	if (lpa == NULL)
		return NULL;
	ASSERT(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
	return lpw;
    UNREFERENCED_PARAMETER( nChars );
}

LPSTR BSAFXAPI BsAfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	if (lpw == NULL)
		return NULL;
	ASSERT(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
    UNREFERENCED_PARAMETER( nChars );
}


//
//  the following is from strex.cpp
//

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CBsString::CBsString(TCHAR ch, int nLength)
{
	Init();
	if (nLength >= 1)
	{
		AllocBuffer(nLength);
#ifdef _UNICODE
		for (int i = 0; i < nLength; i++)
			m_pchData[i] = ch;
#else
		memset(m_pchData, ch, nLength);
#endif
	}
}

CBsString::CBsString(LPCTSTR lpch, int nLength)
{
	Init();
	if (nLength != 0)
	{
		ASSERT(BsAfxIsValidAddress(lpch, nLength, FALSE));
		AllocBuffer(nLength);
		memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CBsString::CBsString(LPCSTR lpsz, int nLength)
{
	Init();
	if (nLength != 0)
	{
		AllocBuffer(nLength);
		int n = ::MultiByteToWideChar(CP_ACP, 0, lpsz, nLength, m_pchData, nLength+1);
		ReleaseBuffer(n >= 0 ? n : -1);
	}
}
#else //_UNICODE
CBsString::CBsString(LPCWSTR lpsz, int nLength)
{
	Init();
	if (nLength != 0)
	{
		AllocBuffer(nLength*2);
		int n = ::WideCharToMultiByte(CP_ACP, 0, lpsz, nLength, m_pchData,
			(nLength*2)+1, NULL, NULL);
		ReleaseBuffer(n >= 0 ? n : -1);
	}
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CBsString& CBsString::operator=(TCHAR ch)
{
	AssignCopy(1, &ch);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CBsString BSAFXAPI operator+(const CBsString& string1, TCHAR ch)
{
	CBsString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

CBsString BSAFXAPI operator+(TCHAR ch, const CBsString& string)
{
	CBsString s;
	s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// Advanced manipulation

int CBsString::Delete(int nIndex, int nCount /* = 1 */)
{
	if (nIndex < 0)
		nIndex = 0;
	int nNewLength = GetData()->nDataLength;
	if (nCount > 0 && nIndex < nNewLength)
	{
		CopyBeforeWrite();
		int nBytesToCopy = nNewLength - (nIndex + nCount) + 1;

		memcpy(m_pchData + nIndex,
			m_pchData + nIndex + nCount, nBytesToCopy * sizeof(TCHAR));
		GetData()->nDataLength = nNewLength - nCount;
	}

	return nNewLength;
}

int CBsString::Insert(int nIndex, TCHAR ch)
{
	CopyBeforeWrite();

	if (nIndex < 0)
		nIndex = 0;

	int nNewLength = GetData()->nDataLength;
	if (nIndex > nNewLength)
		nIndex = nNewLength;
	nNewLength++;

	if (GetData()->nAllocLength < nNewLength)
	{
		CBsStringData* pOldData = GetData();
		LPTSTR pstr = m_pchData;
		AllocBuffer(nNewLength);
		memcpy(m_pchData, pstr, (pOldData->nDataLength+1)*sizeof(TCHAR));
		CBsString::Release(pOldData);
	}

	// move existing bytes down
	memcpy(m_pchData + nIndex + 1,
		m_pchData + nIndex, (nNewLength-nIndex)*sizeof(TCHAR));
	m_pchData[nIndex] = ch;
	GetData()->nDataLength = nNewLength;

	return nNewLength;
}

int CBsString::Insert(int nIndex, LPCTSTR pstr)
{
	if (nIndex < 0)
		nIndex = 0;

	int nInsertLength = SafeStrlen(pstr);
	int nNewLength = GetData()->nDataLength;
	if (nInsertLength > 0)
	{
		CopyBeforeWrite();
		if (nIndex > nNewLength)
			nIndex = nNewLength;
		nNewLength += nInsertLength;

		if (GetData()->nAllocLength < nNewLength)
		{
			CBsStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			AllocBuffer(nNewLength);
			memcpy(m_pchData, pstr, (pOldData->nDataLength+1)*sizeof(TCHAR));
			CBsString::Release(pOldData);
		}

		// move existing bytes down
		memcpy(m_pchData + nIndex + nInsertLength,
			m_pchData + nIndex,
			(nNewLength-nIndex-nInsertLength+1)*sizeof(TCHAR));
		memcpy(m_pchData + nIndex,
			pstr, nInsertLength*sizeof(TCHAR));
		GetData()->nDataLength = nNewLength;
	}

	return nNewLength;
}

int CBsString::Replace(TCHAR chOld, TCHAR chNew)
{
	int nCount = 0;

	// short-circuit the nop case
	if (chOld != chNew)
	{
		// otherwise modify each character that matches in the string
		CopyBeforeWrite();
		LPTSTR psz = m_pchData;
		LPTSTR pszEnd = psz + GetData()->nDataLength;
		while (psz < pszEnd)
		{
			// replace instances of the specified character only
			if (*psz == chOld)
			{
				*psz = chNew;
				nCount++;
			}
			psz = _tcsinc(psz);
		}
	}
	return nCount;
}

int CBsString::Replace(LPCTSTR lpszOld, LPCTSTR lpszNew)
{
	// can't have empty or NULL lpszOld

	int nSourceLen = SafeStrlen(lpszOld);
	if (nSourceLen == 0)
		return 0;
	int nReplacementLen = SafeStrlen(lpszNew);

	// loop once to figure out the size of the result string
	int nCount = 0;
	LPTSTR lpszStart = m_pchData;
	LPTSTR lpszEnd = m_pchData + GetData()->nDataLength;
	LPTSTR lpszTarget;
	while (lpszStart < lpszEnd)
	{
		while ((lpszTarget = _tcsstr(lpszStart, lpszOld)) != NULL)
		{
			nCount++;
			lpszStart = lpszTarget + nSourceLen;
		}
		lpszStart += lstrlen(lpszStart) + 1;
	}

	// if any changes were made, make them
	if (nCount > 0)
	{
		CopyBeforeWrite();

		// if the buffer is too small, just
		//   allocate a new buffer (slow but sure)
		int nOldLength = GetData()->nDataLength;
		int nNewLength =  nOldLength + (nReplacementLen-nSourceLen)*nCount;
		if (GetData()->nAllocLength < nNewLength || GetData()->nRefs > 1)
		{
			CBsStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			AllocBuffer(nNewLength);
			memcpy(m_pchData, pstr, pOldData->nDataLength*sizeof(TCHAR));
			CBsString::Release(pOldData);
		}
		// else, we just do it in-place
		lpszStart = m_pchData;
		lpszEnd = m_pchData + GetData()->nDataLength;

		// loop again to actually do the work
		while (lpszStart < lpszEnd)
		{
			while ( (lpszTarget = _tcsstr(lpszStart, lpszOld)) != NULL)
			{
				int nBalance = nOldLength - (int)(lpszTarget - m_pchData + nSourceLen);
				memmove(lpszTarget + nReplacementLen, lpszTarget + nSourceLen,
					nBalance * sizeof(TCHAR));
				memcpy(lpszTarget, lpszNew, nReplacementLen*sizeof(TCHAR));
				lpszStart = lpszTarget + nReplacementLen;
				lpszStart[nBalance] = '\0';
				nOldLength += (nReplacementLen - nSourceLen);
			}
			lpszStart += lstrlen(lpszStart) + 1;
		}
		ASSERT(m_pchData[nNewLength] == '\0');
		GetData()->nDataLength = nNewLength;
	}

	return nCount;
}

int CBsString::Remove(TCHAR chRemove)
{
	CopyBeforeWrite();

	LPTSTR pstrSource = m_pchData;
	LPTSTR pstrDest = m_pchData;
	LPTSTR pstrEnd = m_pchData + GetData()->nDataLength;

	while (pstrSource < pstrEnd)
	{
		if (*pstrSource != chRemove)
		{
			*pstrDest = *pstrSource;
			pstrDest = _tcsinc(pstrDest);
		}
		pstrSource = _tcsinc(pstrSource);
	}
	*pstrDest = '\0';
	int nCount = ( int )( pstrSource - pstrDest );
	GetData()->nDataLength -= nCount;

	return nCount;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CBsString CBsString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CBsString CBsString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	ASSERT(nFirst >= 0);
	ASSERT(nFirst + nCount <= GetData()->nDataLength);

	// optimize case of returning entire string
	if (nFirst == 0 && nFirst + nCount == GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

CBsString CBsString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	if (nCount >= GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

CBsString CBsString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	if (nCount >= GetData()->nDataLength)
		return *this;

	CBsString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalen