seRecordOnly);

            // Get web friends
            ro.Debug("Getting friends list for user B...");

            // Get user B friends list, make sure he sees web friends
            PGetFriendsListReplyMsgData replyData = requestor.GetFriendsList(b);
            ValueCheck.Test("Friend count", (ushort)(replyData.cdwFriends), (ushort)1);
        }

        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_GetFriendsList_Target_NotInMemory_Friend_NotInMemory()
        {
            // TODO: what does not in memory mean for the new presence system?

            PNUser requestor = CreateXenonUser(true);

            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);
            _fc.MakeFriend(a, b);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            ro.Debug("Removing A and B from memory...");
            //PNServers.SetCacheState(a, CacheState.NotInMemory);
            //PNServers.SetCacheState(b, CacheState.NotInMemory);

            // Get web friends
            ro.Debug("Getting friends list for user B...");

            //BugID: 101234
            requestor.GetPresenceInfo(b);

            // Get user B friends list, make sure he sees web friends
            PGetFriendsListReplyMsgData replyData = requestor.GetFriendsList(b);
            ValueCheck.Test("Friend count", (ushort)(replyData.cdwFriends), (ushort)1);
        }


        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_GetFriendsList_Target_NoFriends()
        {
            PNUser requestor = CreateXenonUser(true);

            PNUser b;

            // Create some clean users who are friends
            b = CreateXenonUser(true);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            b.ProcessNotifications();
            _fc.LogoffUser(b);

            // Get web friends
            ro.Debug("Getting friends list for user B...");

            // Get user B friends list, make sure he sees web friends
            PGetFriendsListReplyMsgData replyData = requestor.GetFriendsList(b);
            ValueCheck.Test("Friend count", (ushort)(replyData.cdwFriends), (ushort)0);
        }


        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_GetFriendsList_Target_FriendPending()
        {
            PNUser requestor = CreateXenonUser(true);

            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);
            b.AddBuddy(a);
            a.WaitForBuddyStatusRequested(b);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            // Get web friends
            ro.Debug("Getting friends list for user B...");

            // Get user B friends list, make sure he sees web friends
            PGetFriendsListReplyMsgData replyData = requestor.GetFriendsList(b);
            ValueCheck.Test("Friend count", (ushort)(replyData.cdwFriends), (ushort)1);
        }

        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_GetFriendsList_Target_FriendRequested()
        {
            PNUser requestor = CreateXenonUser(true);

            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);
            a.AddBuddy(b);
            b.WaitForBuddyStatusRequested(a);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            // Get web friends
            ro.Debug("Getting friends list for user B...");

            // Get user B friends list, make sure he sees web friends
            PGetFriendsListReplyMsgData replyData = requestor.GetFriendsList(b);
            ValueCheck.Test("Friend count", (ushort)(replyData.cdwFriends), (ushort)1);
        }

        /// <summary>
        /// 
        /// </summary>
		[TestCase]
		public void P_GetFriendsList_Max_OfflineFriends_MixStatus()
		{
            PNUser requestor = CreateXenonUser(true);

			uint friendCount = 100;
			PNUser u = CreateXenonUser(true);
			PNUser []friends = new PNUser[friendCount];
            QValPacket qval = null;

			ProgressInfo progress = new ProgressInfo("Setting up mixed friends", friendCount, 1);
			for(int i = 0; i < friendCount; ++i)
			{
                Global.RO.Debug("Friend:" + i);
				friends[i] = CreateXenonUser(true);
				switch(i % 3)
				{
				case 0:
					_fc.MakeFriend(u, friends[i]);
					break;

				case 1:
					u.AddBuddy(friends[i]);
                    qval = friends[i].WaitForQFlags(XonPresNoti.QFLAG_MASK_BUDDY_REQ);
                    friends[i].HandleQValPacket(qval);
                    qval = u.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
                    u.HandleQValPacket(qval);
					break;

				case 2:
					friends[i].AddBuddy(u);
                    qval = u.WaitForQFlags(XonPresNoti.QFLAG_MASK_BUDDY_REQ);
                    u.HandleQValPacket(qval);
                    qval = friends[i].WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
                    friends[i].HandleQValPacket(qval);
					break;

				}
				progress.Step();
			}
			progress.Finish();

            Thread.Sleep(5000);

			PGetFriendsListReplyMsgData data = null;

			foreach(PNUser f in friends)
			{
				_fc.LogoffUser(f);
                Thread.Sleep(2000);
				// Dequeue any pending qval data for full friends
                u.ProcessQVals();
			}
			
			data = requestor.GetFriendsList(u);
			ValueCheck.TestHR("Reply.HR", HResult.S_OK, data.HR);
			ValueCheck.Test("Reply.UserID", requestor.UserId, data.UserID);
			ValueCheck.Test("Reply.cdwFriends", (uint)data.rgFriends.Length, data.cdwFriends);
			ValueCheck.Test("Reply.cdwFriends == friendCount", (uint)friendCount, (uint)data.rgFriends.Length);

			// Validate user friends
		
			ro.Info("Starting forward validation pass");

			uint pass = 0;
			uint fail = 0;
			
			for(int i = 0; i < friends.Length; ++i)
			{
				PNUser f = friends[i];
                GetFriendsListData wf = data.rgFriends[i];

				try
				{
					// Compare buddy status
					PNUser.BuddyInfo bi = u.GetBuddyInfo(wf.BuddyID);
					ValueCheck.Test("WebFriend.Status", bi.Status, wf.Status);

					/*
					 * This won't work since the user is being loaded clean
					 *
					if(bi.Status == XonPresNoti.P_BUDDY_STATUS_OK)
					{
						ValueCheck.TestNotNull("BuddyInfo.RichPresence", bi.RichPresence);
						ValueCheck.Test("WebFriend.State", bi.RichPresence.State, wf.OnlineState);
						ValueCheck.Test("WebFriend.TitleID", bi.RichPresence.TitleID, wf.TitleID);
					}
					*/

                    System.Threading.Thread.Sleep(250);
					pass++;
				} 
				catch(ExpectedValueCheckException ex)
				{
					ro.Error("Value check exception: " + ex.Message);
					fail++;
				}
			}

			ro.Info("Finished forward validation passed: {0}, failed: {1}", pass, fail);


			ro.Info("Starting reverse validation pass");

			// Validate reverse associations
			foreach(PNUser f in friends)
			{
				
				data = requestor.GetFriendsList(f);

				// Validate 
				ValueCheck.TestHR("ReverseReply.HR", HResult.S_OK, data.HR);
				ValueCheck.Test("ReverseReply.UserID", requestor.UserId, data.UserID);
				ValueCheck.Test("ReverseReply.cdwFriends == 1", (uint)1, (uint)data.rgFriends.Length);


				// Logon friend, populating their pnuser state
				_fc.LogonUser(f);
                Thread.Sleep(5000);

				// Compare online vs. web presence
				ValueCheck.Test("ReverseWebFriend.BuddyID", u.UserId, data.rgFriends[0].BuddyID);
				ValueCheck.TestNotNull("ReverseWebFriend.rgFriends[0]", data.rgFriends[0]);
				ValueCheck.TestNotNull("ReverseWebFriend.GetBuddyInfo()", f.GetBuddyInfo(u.UserId));
				ValueCheck.Test("ReverseWebFriend.Status", f.GetBuddyInfo(u.UserId).Status, data.rgFriends[0].Status);
				ValueCheck.Test("ReverseWebFriend.OnlineState", u.State, data.rgFriends[0].OnlineState);
				ValueCheck.Test("ReverseWebFriend.TitleID", u.Xbox.TitleId, data.rgFriends[0].TitleID);
			}
		}


        
        [TestCase]
        public void P_GetFriendsList_OnlineFriends_MixedState()
        {
            UserNotification noti;
            PNUser requestor = CreateXenonUser(true);

            // Create our test users
            PNUser u = CreateXenonUser(false);
            PNUser online = CreateXenonUser(true);
            PNUser offline = CreateXenonUser(true);
            PNUser cloaked = CreateXenonUser(true);
            PNUser online_playing = CreateXenonUser(true);
            PNUser online_playing_voice = CreateXenonUser(true);
            PNUser online_playing_joinable = CreateXenonUser(true);
            PNUser online_playing_voice_joinable = CreateXenonUser(true);
            PNUser online_voice = CreateXenonUser(true);
            PNUser online_guests = CreateXenonUser(true);
            PNUser online_voice_guests = CreateXenonUser(true);
            PNUser online_joinable_guests = CreateXenonUser(true);
            PNUser online_playing_guests = CreateXenonUser(true);
            PNUser online_playing_voice_guests = CreateXenonUser(true);
            PNUser online_playing_voice_joinable_guests = CreateXenonUser(true);
            PNUser online_playing_joinable_guests = CreateXenonUser(true);

            u.Xbox.ChangeTitle(u.Xbox.TitleId + 1, 0, 0);
            _fc.LogonUser(u);

            // Link the friends
            _fc.MakeFriend(u, online);
            _fc.MakeFriend(u, offline);
            _fc.MakeFriend(u, cloaked);
            _fc.MakeFriend(u, online_playing);
            _fc.MakeFriend(u, online_playing_voice);
            _fc.MakeFriend(u, online_playing_joinable);
            _fc.MakeFriend(u, online_playing_voice_joinable);
            _fc.MakeFriend(u, online_voice);
            _fc.MakeFriend(u, online_guests);
            _fc.MakeFriend(u, online_voice_guests);
            _fc.MakeFriend(u, online_joinable_guests);
            _fc.MakeFriend(u, online_playing_guests);
            _fc.MakeFriend(u, online_playing_voice_guests);
            _fc.MakeFriend(u, online_playing_voice_joinable_guests);
            _fc.MakeFriend(u, online_playing_joinable_guests);

            //
            // Setup proper states 
            //

            _fc.LogoffUser(offline);
            Thread.Sleep(2000);

            u.ProcessNotifications();
            //noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            //u.HandleTCPNotification(noti);

            cloaked.State |= XonPresNoti.P_STATE_MASK_CLOAKED;
            cloaked.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);

            online_playing.State |= XonPresNoti.P_STATE_MASK_PLAYING;
            online_playing.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);

            online_playing_voice.State |= XonPresNoti.P_STATE_MASK_PLAYING | XonPresNoti.P_STATE_MASK_VOICE;
            online_playing_voice.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);

            online_playing_joinable.State |= XonPresNoti.P_STATE_MASK_PLAYING | XonPresNoti.P_STATE_MASK_JOINABLE;
            online_playing_joinable.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);

            online_playing_voice_joinable.State |= XonPresNoti.P_STATE_MASK_PLAYING | XonPresNoti.P_STATE_MASK_VOICE | XonPresNoti.P_STATE_MASK_JOINABLE;
            online_playing_voice_joinable.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);

            online_voice.State |= XonPresNoti.P_STATE_MASK_VOICE;
            online_voice.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);

            online_guests.State |= XonPresNoti.P_STATE_MASK_GUESTS;
            online_guests.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);

            online_voice_guests.State |= XonPresNoti.P_STATE_MASK_VOICE | XonPresNoti.P_STATE_MASK_GUESTS;
            online_voice_guests.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);

            online_joinable_guests.State |= XonPresNoti.P_STATE_MASK_JOINABLE | XonPresNoti.P_STATE_MASK_GUESTS;
            online_joinable_guests.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);

            online_playing_guests.State |= XonPresNoti.P_STATE_MASK_PLAYING;
            online_playing_guests.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);

            online_playing_voice_guests.State |= XonPresNoti.P_STATE_MASK_PLAYING | XonPresNoti.P_STATE_MASK_VOICE | XonPresNoti.P_STATE_MASK_GUESTS;
            online_playing_voice_guests.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);

            online_playing_voice_joinable_guests.State |= XonPresNoti.P_STATE_MASK_PLAYING | XonPresNoti.P_STATE_MASK_VOICE | XonPresNoti.P_STATE_MASK_JOINABLE | XonPresNoti.P_STATE_MASK_GUESTS;
            online_playing_voice_joinable_guests.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);

            online_playing_joinable_guests.State |= XonPresNoti.P_STATE_MASK_PLAYING | XonPresNoti.P_STATE_MASK_JOINABLE | XonPresNoti.P_STATE_MASK_GUESTS;
            online_playing_joinable_guests.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);

            Thread.Sleep(5000);

            new SleepInfo("Waiting for state updates to complete", 5000);
            u.ProcessNotifications();

            // Validate
            PGetFriendsListReplyMsgData wfd = requestor.GetFriendsList(u);
            ValidateBuddyWebData(u.GetBuddyInfo(online.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(offline.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(cloaked.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_playing.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_playing_voice.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_playing_joinable.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_playing_voice_joinable.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_voice.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_guests.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_voice_guests.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_joinable_guests.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_playing_guests.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_playing_voice_guests.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_playing_voice_joinable_guests.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_playing_joinable_guests.UserId), wfd);
        }

        void ValidateBuddyWebData(PNUser.BuddyInfo info, PGetFriendsListReplyMsgData wfd)
        {
            ValueCheck.TestNotNull("BuddyInfo", info);
            ValueCheck.TestNotNull("BuddyInfo.RichPresence", info.RichPresenceData);

            uint i;
            for (i = 0; i < wfd.cdwFriends; ++i)
            {
                GetFriendsListData wf = wfd.rgFriends[i];
                if (wf.BuddyID == info.User.UserId)
                {
                    PNUser user = info.User;
                    ValueCheck.Test("User(" + user.UserId.ToString("x") + ").GamerTag", info.Name, wf.szGamerTag);
                    if (0 == (wf.OnlineState & XonPresNoti.P_STATE_MASK_CLOAKED))
                    {
                        ValueCheck.Test("User(" + user.UserId.ToString("x") + ").OnlineState", info.BasicPresenceData.State, wf.OnlineState);
                    }
                    else
                    {
                        ValueCheck.Test("User(" + user.UserId.ToString("x") + ").RichPresence.State", 0, info.BasicPresenceData.State);
                        ValueCheck.Test("User(" + user.UserId.ToString("x") + ").OnlineState", user.State, wf.OnlineState);
                    }

                    ValueCheck.Test("User(" + user.UserId.ToString("x") + ").TitleId", info.BasicPresenceData.TitleId, wf.TitleID);
                    // TODO-jacobr: validate rich presence string data
                    break;
                }
            }

            if (i == wfd.cdwFriends)
            {
                throw new UnexpectedTestResultException("User: " + info.User.UserId.ToString("x") + " not found in web friends data");
            }
        }



        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_GetFriendsList_Target_Not_Sharing_Friends()
        {
            PNUser requestor = CreateXenonUser(true);

            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);

            // set privileges
            SetPrivilege(b, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST, false);
            SetPrivilege(b, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY, false);

            _fc.MakeFriend(a, b);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            // Logon
            ro.Debug("Logging in with user A...");
            _fc.LogonUser(a);

            // Get web friends
            ro.Debug("Getting friends list for user B...");

            bool caught = false;
            try
            {
                // Get user B friends list, make sure he sees web friends
                PGetFriendsListReplyMsgData replyData = requestor.GetFriendsList(b);
            }
            catch (HResultException ex)
            {
                caught = true;
                if (ex.HR != HResult.XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES)
                    throw ex;
            }
            if (!caught)
            {
                Assert.IsTrue(false, "Get Friends List Request should have thrown insufficient privileges.");
            }
        }


        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_GetFriendsList_Target_Sharing_Friends_To_Friends_Not_Friend()
        {
            PNUser requestor = CreateXenonUser(true);

            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);

            // set privileges
            SetPrivilege(b, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST, false);
            SetPrivilege(b, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY, true);

            _fc.MakeFriend(a, b);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            // Logon
            ro.Debug("Logging in with user A...");
            _fc.LogonUser(a);

            // Get web friends
            ro.Debug("Getting friends list for user B...");
            bool caught = false;
            try
            {
                // Get user B friends list, make sure he sees web friends
                PGetFriendsListReplyMsgData replyData = requestor.GetFriendsList(b);

            }
            catch (HResultException ex)
            {
                caught = true;
                if (ex.HR != HResult.XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES)
                    throw ex;
            }
            if (!caught)
            {
                Assert.IsTrue(false, "Get Friends List Request should have thrown insufficient privileges.");
            }
        }


        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_GetFriendsList_Target_Sharing_Friends_To_Friends_Pending_Friend()
        {
            PNUser requestor = CreateXenonUser(true);

            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);

            // set privileges
            SetPrivilege(b, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST, false);
            SetPrivilege(b, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY, true);

            _fc.MakeFriend(a, b);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            // Logon
            ro.Debug("Logging in with user A...");
            _fc.LogonUser(a);

            // Get web friends
            ro.Debug("Getting friends list for user B...");
            bool caught = false;
            try
            {
                requestor.AddBuddy(b);
                // Get user B friends list, make sure he sees web friends
                PGetFriendsListReplyMsgData replyData = requestor.GetFriendsList(b);

            }
            catch (HResultException ex)
            {
                caught = true;
                if (ex.HR != HResult.XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES)
                    throw ex;
            }
            if (!caught)
            {
                Assert.IsTrue(false, "Get Friends List Request should have thrown insufficient privileges.");
            }
        }

        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_GetFriendsList_Target_Sharing_Friends_To_Friends_Friend()
        {
            PNUser requestor = CreateXenonUser(true);

            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(false);

            // set privileges
            SetPrivilege(b, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST, false);
            SetPrivilege(b, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY, true);

            _fc.LogonUser(b);

            _fc.MakeFriend(a, b);
            _fc.MakeFriend(b, requestor);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            // Logon
            ro.Debug("Logging in with user A...");
            _fc.LogonUser(a);

            // Get web friends
            ro.Debug("Getting friends list for user B...");

            // Get user B friends list, make sure he sees web friends
            PGetFriendsListReplyMsgData replyData = requestor.GetFriendsList(b);

            // TODO: what should the results look like?
            ValueCheck.Test("Friend count", (ushort)(replyData.cdwFriends), (ushort)2);
        }


        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_GetFriendsList_Target_Self_Blocked()
        {
            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(false);

            // set privileges
            SetPrivilege(b, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST, false);
            SetPrivilege(b, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY, false);

            _fc.LogonUser(b);

            _fc.MakeFriend(a, b);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            // Logon
            ro.Debug("Logging in with user A...");
            _fc.LogonUser(a);

            // Get web friends
            ro.Debug("Getting friends list for user B...");

            // Get user B friends list, make sure he sees web friends
            PGetFriendsListReplyMsgData replyData = b.GetFriendsList(b);

            // TODO: what should the results look like?
            ValueCheck.Test("Friend count", (ushort)(replyData.cdwFriends), (ushort)1);
        }


        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_GetFriendsList_Target_Friend_Sharing_Presence_To_Friends_Friend()
        {

            PNUser requestor = CreateXenonUser(true);

            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);

            _fc.MakeFriend(a, b);
            _fc.MakeFriend(a, requestor);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            // set privileges
            SetPrivilege(a, XOn.XPRIVILEGE_PRESENCE, false);
            SetPrivilege(a, XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, true);

            // Logon
            ro.Debug("Logging in with user A...");
            _fc.LogonUser(a);

            // Get web friends
            ro.Debug("Getting friends list for user B...");

            // Get user B friends list, make sure he sees web friends
            PGetFriendsListReplyMsgData replyData = requestor.GetFriendsList(b);

            ValueCheck.Test("Friend count", (ushort)(replyData.cdwFriends), (ushort)1);
            ValidateBuddyWebData(requestor.GetBuddyInfo(a.UserId), replyData);
        }

        void ValidateBlockedPresence(PNUser user, PGetFriendsListReplyMsgData wfd)
        {
            ValueCheck.TestNotNull("User", user);

            uint i;
            for (i = 0; i < wfd.cdwFriends; ++i)
            {
                GetFriendsListData wf = wfd.rgFriends[i];
                if (wf.BuddyID == user.UserId)
                {
                    ValueCheck.Test("User(" + user.UserId.ToString("x") + ").GamerTag", user.Name, wf.szGamerTag);
                    ValueCheck.Test("User(" + user.UserId.ToString("x") + ").OnlineState", 0, wf.OnlineState);
                    break;
                }
            }

            if (i == wfd.cdwFriends)
            {
                throw new UnexpectedTestResultException("User: " + user.UserId.ToString("x") + " not found in web friends data");
            }
        }

        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_GetFriendsList_Target_Friend_Sharing_Presence_To_Friends_Not_Friend()
        {

            PNUser requestor = CreateXenonUser(true);

            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);

            // set privileges
            SetPrivilege(a, XOn.XPRIVILEGE_PRESENCE, false);
            SetPrivilege(a, XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, true);

            _fc.MakeFriend(a, b);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            // Logon
            ro.Debug("Logging in with user A...");
            _fc.LogonUser(a);

            // Get web friends
            ro.Debug("Getting friends list for user B...");

            // Get user B friends list, make sure he sees web friends
            PGetFriendsListReplyMsgData replyData = requestor.GetFriendsList(b);

            ValueCheck.Test("Friend count", (ushort)(replyData.cdwFriends), (ushort)1);
            ValidateBlockedPresence(a, replyData);
        }

        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_GetFriendsList_Target_Friend_Not_Sharing_Presence()
        {

            PNUser requestor = CreateXenonUser(true);

            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);

            _fc.MakeFriend(a, b);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            // set privileges
            SetPrivilege(a, XOn.XPRIVILEGE_PRESENCE, false);
            SetPrivilege(a, XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, false);

            // Logon
            ro.Debug("Logging in with user A...");
            _fc.LogonUser(a);

            // Get web friends
            ro.Debug("Getting friends list for user B...");

            // Get user B friends list, make sure he sees web friends
            PGetFriendsListReplyMsgData replyData = requestor.GetFriendsList(b);

            ValueCheck.Test("Friend count", (ushort)(replyData.cdwFriends), (ushort)1);
            ValidateBlockedPresence(a, replyData);
        }

        // invalid target
        // target online
        // target offline
        // target friend not in memory
        // target not in memory
        // target not in memory, one of friends not in memory

        // target has no friends
        // target has pending friend
        // target has requested friend
        // target has max friends
        // target friends have mixed status

        // target not sharing friends list
        // target sharing friends list to friends, user not friend
        // target sharing friends list to friends, user is friend
        
        // targets friends blocked presence
        // targets friends presence friends only, user friend
        // targets friends presence friends only, user not friend
    


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncPurgeUser.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.presence.client;

namespace PresenceTest
{
	/// <summary>
	/// Functional Tests for PurgeUser
	/// </summary>
    [TestGroup, AsyncGroup(1, 0)]
    class FuncPurgeUser : PresenceTestBaseGroup
	{
        static Report _Report = new Report(typeof(FuncPurgeUser).Name);

        public override void Setup()
        {
            System.Net.IPEndPoint endPoint = Global.XEnv.GetVirtualInterface("xcache");
            VirtualInterfaceInfo viInfo = (VirtualInterfaceInfo)Config.GetVirtualInterface("xcache");
            viInfo.IPAddress = endPoint.Address;

            base.Setup();
            PNUser user = CreateXenonUser(true);
        }

        public class PurgeCase : TestBase
        {
            PNUser User = null;
            PNUser Shadow = null;
            PresenceTestBaseGroup _ptbg = null;
            FriendsCommon _fc = null;

            uint m_FullFriends; // fully accepted friends
            uint m_PendingFriends; // people who have requested my friendship
            uint m_RequestedFriends; // people I have requested friendship of
            bool m_Alive = false; //is this a negative test

            public PurgeCase(uint FullFriends, // fully accepted friends
                            uint PendingFriends, // people who have requested my friendship
                            uint RequestedFriends // people I have requested friendship of
                           )
            {
                m_FullFriends = FullFriends; 
                m_PendingFriends = PendingFriends;
                m_RequestedFriends = RequestedFriends;
            }

            public PurgeCase(uint FullFriends, // fully accepted friends
                           uint PendingFriends, // people who have requested my friendship
                           uint RequestedFriends, // people I have requested friendship of
                           bool isAlive
                          )
            {
                m_FullFriends = FullFriends;
                m_PendingFriends = PendingFriends;
                m_RequestedFriends = RequestedFriends;
                m_Alive = isAlive;
            }


            public PurgeCase(string Name,
                            uint FullFriends, // fully accepted friends
                            uint PendingFriends, // people who have requested my friendship
                            uint RequestedFriends) // people I have requested friendship of
                : base(Name)
            {
                            m_FullFriends = FullFriends; 
                            m_PendingFriends = PendingFriends;
                            m_RequestedFriends = RequestedFriends;
            }

            private void WaitForXCache()
            {
                int wait = Config.GetIntSetting(Setting.xcache_db_pollingInterval);
                _Report.Debug("Sleeping " + wait.ToString() + "s (for Xcache)");
                Thread.Sleep(wait * 1000);
            }

            private void DeleteUser()
            {
                _Report.Debug("Deleting user {0}", User.UserId);
                if (!m_Alive)
                {
                    _fc.LogoffUser(User);
                    PresClient.DeleteUser(User.UserId);
                    PresClient.DeleteGamertagFromUODB(User.UserId, User.Xbox.XboxId, DateTime.UtcNow);
                    WaitForXCache();
                    VerifyNotExists();
                }
                else
                {
                    _fc.LogonUser(User);
                    try
                    {
                        xonline.common.service.HResult hr = PresClient.DeleteUser(User.UserId);
                        ValueCheck.IsTrue(true, "Delete online user should throw.");
                    }
                    catch 
                    {
                    }
                    VerifyExists(true);
                }
            }

            private void CreateTestUser(bool Alive)
            {
                User = _ptbg.CreateXenonUser(Alive);
                Shadow = _ptbg.CreateXenonUser(Alive);
                _Report.Debug("Created user {0}", User.UserId);
                _Report.Debug("Created shadow {0}", Shadow.UserId);
                WaitForXCache();
                VerifyExists(Alive);
            }

            private xonline.common.community.PresenceRecord GetUserRecord()
            {
                xonline.common.community.PresenceRecord record = null;
                uint cTrys = 0;
                do
                {
                    try
                    {
                        record = xonline.common.community.PresenceUtil.GetPresenceRecord(User.UserId);
                        if (record != null)
                        {
                            break;
                        }
                    }
                    catch { }
                    cTrys++;
                    System.Threading.Thread.Sleep(2000);
                }
                while (cTrys < 3);

                return record;
            }

            private void VerifyExists(bool HasPresence)
            {
                _Report.Debug("Verifying user {0} exists.", User.UserId);

                xonline.common.community.PresenceRecord sShowRecord = GetUserRecord();
                if (HasPresence)
                {
                    ValueCheck.IsTrue(sShowRecord.IsOnline(), "User Should be online.");
                }
                else
                {
                    ValueCheck.IsFalse(sShowRecord.IsOnline(), "User Should not be online.");
                }

                string gtfound = XCache.LookupGamerTag(User.UserId);
                ulong puidfound = XCache.LookupPUID(User.Name);
                ValueCheck.Test("Gamertag should be found", User.Name, gtfound);
                ValueCheck.Test("Puid should be found", User.UserId, puidfound);
            }

            private void VerifyNotExists()
            {
                _Report.Debug("Verifying user {0} no longer exists.", User.UserId);
                xonline.common.community.PresenceRecord sShowRecord = GetUserRecord();
                ValueCheck.IsTrue(sShowRecord == null, "User record should not exist.");

                string gtfound = XCache.LookupGamerTag(User.UserId);
                ulong puidfound = XCache.LookupPUID(User.Name);
                ValueCheck.Test("Gamertag should not be found", XCache.InvalidGamertag, gtfound);
                ValueCheck.Test("Puid should not be found", 0, puidfound);
            }

            private void VerifyFriends()
            {
                if (m_FullFriends + m_PendingFriends + m_RequestedFriends > 0)
                {
                    // expect a list change operation
                    QValPacket qval = Shadow.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
                    Shadow.HandleQValPacket(qval);
                }
                _fc.LogoffUser(Shadow);
                _fc.LogoffUser(Shadow);
            }

            private void DoPositiveCase(uint FullFriends, // fully accepted friends
                            uint PendingFriends, // people who have requested my friendship
                            uint RequestedFriends) // people I have requested friendship of
            {
                _ptbg = (PresenceTestBaseGroup)Parent;
                _fc = _ptbg._fc;
                CreateTestUser(true);

                // set up the users full friends
                for (int iFullFriend = 0; iFullFriend < FullFriends; iFullFriend++)
                {
                    
                    PNUser friend;
                    if (iFullFriend == 0)
                    {
                        friend = Shadow;
                    }
                    else
                    {
                        friend = _ptbg.CreateXenonUser(true);
                    }
                    _fc.MakeFriend(User, friend);
                }

                // set up the users pending friends
                for (int iPendingFriend = 0; iPendingFriend < PendingFriends; iPendingFriend++)
                {
                    PNUser friend;
                    if (iPendingFriend == 0 && FullFriends == 0)
                    {
                        friend = Shadow;
                    }
                    else
                    {
                        friend = _ptbg.CreateXenonUser(true);
                    } 
                    friend.AddBuddy(User);
                }

                // set up the users requested friends
                for (int iRequestedFriend = 0; iRequestedFriend < RequestedFriends; iRequestedFriend++)
                {
                    PNUser friend;
                    if (iRequestedFriend == 0 && FullFriends == 0 && PendingFriends == 0)
                    {
                        friend = Shadow;
                    }
                    else
                    {
                        friend = _ptbg.CreateXenonUser(true);
                    } 
                    User.AddBuddy(friend);
                }

                if (User.LoggedOn)
                {
                    _fc.LogoffUser(User);
                }
                if (Shadow.LoggedOn)
                {
                    _fc.LogoffUser(Shadow);
                }
           
                // shadow watches the delete happen
                _fc.LogonUser(Shadow);

                DeleteUser();

                if (m_Alive)
                    VerifyExists(true);

                VerifyFriends();
            }


            protected override void Execute()
            {
                DoPositiveCase(m_FullFriends, // fully accepted friends
                             m_PendingFriends, // people who have requested my friendship
                             m_RequestedFriends); // people I have requested friendship of
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
      

        [TestCase]
        class P_NoFriends_NoFriendsPending_NoFriendsRequested : PurgeCase
        {
            public P_NoFriends_NoFriendsPending_NoFriendsRequested()
                : base(0, 0, 0)
            {
            }
        }
      
        [TestCase]
        class P_NoFriends_NoFriendsPending_OneFriendRequested : PurgeCase
        {
            public P_NoFriends_NoFriendsPending_OneFriendRequested()
                : base(0, 0, 1)
            {
            }
        }
        
        [TestCase]
        class P_NoFriends_OneFriendPending_NoFriendsRequested : PurgeCase
        {
            public P_NoFriends_OneFriendPending_NoFriendsRequested()
                : base(0, 1, 0)
            {
            }
        }
    
        [TestCase]
        class P_OneFriend_NoFriendsPending_NoFriendsRequested: PurgeCase
        {
            public P_OneFriend_NoFriendsPending_NoFriendsRequested()
                : base(1, 0, 0)
            {
            }
        }

        [TestCase]
        class P_OneFriend_OneFriendPending_OneFriendRequested : PurgeCase
        {
            public P_OneFriend_OneFriendPending_OneFriendRequested()
                : base(1, 1, 1)
            {
            }
        }

        [TestCase]
        class P_SomeFriend_SomeFriendPending_SomeFriendRequested : PurgeCase
        {
            public P_SomeFriend_SomeFriendPending_SomeFriendRequested()
                : base(18, 3, 3)
            {
            }
        }

        [TestCase]
        class N_PurgeOnlineUser : PurgeCase
        {
            public N_PurgeOnlineUser()
                : base(0,0,0, true)
            {
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncReject.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;

namespace PresenceTest
{
	public class RejectTestBaseGroup : PresenceTestBaseGroup
	{

        /// Create two unique logged on users
        /// </summary>
        /// <param name="user1">First user</param>
        /// <param name="user2">Second user</param>
        protected void CreateXenonUsers(out PNUser user1, out PNUser user2)
        {
            user1 = CreateXenonUser(true);
            user2 = CreateXenonUser(true);
        }

		/// <summary>
		/// Send add buddy message and wait for confirmation notifications
		/// </summary>
		/// <param name="user">Sender</param>
		/// <param name="buddy">Target</param>
		protected void DoAdd(PNUser user, PNUser buddy)
		{
			user.AddBuddy(buddy);
			user.WaitForBuddyStatusPending(buddy);
			buddy.WaitForBuddyStatusRequested(user);
            //buddy.WaitForNewMessageType(XonPresNoti.MSG_TYPE_FRIEND_REQUEST);
		}

		/// <summary>
		/// Send delete buddy message and wait for confirmation notifications
		/// </summary>
		/// <param name="user">Sender</param>
		/// <param name="buddy">Target</param>
		protected void DoDelete(PNUser user, PNUser buddy)
		{
			user.DeleteBuddy(buddy);
			user.WaitForBuddyStatusDeleted(buddy);
			buddy.WaitForBuddyStatusDeleted(user);
		}

        		/// <summary>
		/// Send reject buddy message and wait for confirmation notifications
		/// </summary>
		/// <param name="user">Sender</param>
		/// <param name="buddy">Target</param>
        protected void DoValidReject(PNUser user, PNUser buddy)
        {
            DoValidReject(user, buddy, false);
        }

		/// <summary>
		/// Send reject buddy message and wait for confirmation notifications
		/// </summary>
		/// <param name="user">Sender</param>
		/// <param name="buddy">Target</param>
        /// <param name="never">Add Sender to Never List</param>
		protected void DoValidReject(PNUser user, PNUser buddy, bool never)
		{
            
            // Go get the friend message ID
            UserMsgFolder folder = new UserMsgFolder(user);
            folder.LoadEx();
            UserMessage [] msgs = folder.FindBySender(XonPresNoti.MSG_TYPE_FRIEND_REQUEST, buddy.UserId);
            ValueCheck.Test("Friend requests from user: " + buddy.UserId, 1, msgs.Length);

			user.RejectBuddy(buddy, never);

            // Make sure we get the deleted message QVAL
            user.WaitForDeletedMessage(msgs[0].ID); 

			user.WaitForBuddyStatusDeleted(buddy);
			buddy.WaitForBuddyStatusDeleted(user);
		}

		/// <summary>
		/// Send invalid reject message and wait for notification containing expected error
		/// </summary>
		/// <param name="user">Sender</param>
		/// <param name="buddy">Target</param>
		/// <param name="expectedHR">HR expected in List Change Item</param>
		/// <param name="ignoreBadListVer">True to ignore differences in the buddy list version</param>
		protected void DoInvalidReject(PNUser user, PNUser buddy, uint expectedHR, bool ignoreBadListVer)
		{
            user.RejectBuddy(buddy);
            try
            {
                user.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eFriendsList);
                throw new Exception("Should not reach here.");
            }
            catch (TimeOutException)
            {
                Global.RO.Info("Timed out waiting for FriendsListNotificaton as expected.");
            }
		}
	}

	/// <summary>
	/// Functional Tests for Reject
	/// </summary>
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3), AsyncGroup(1, 0)]
    public class FuncReject_PositiveCases : RejectTestBaseGroup
	{
		
		/// <summary>
		/// 	Reject a valid buddy request
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
		public void P_Reject_Mainline()
		{
			PNUser requestor;
			PNUser requestee;
			CreateXenonUsers(out requestor, out requestee);

			DoAdd(requestor, requestee);

			DoValidReject(requestee, requestor);
		}
		
		/// <summary>
		/// 	Reject a valid buddy request twice
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_Reject_Twice()
		{
			PNUser requestor;
			PNUser requestee;
            CreateXenonUsers(out requestor, out requestee);

			DoAdd(requestor, requestee);

			DoValidReject(requestee, requestor);

			DoInvalidReject(requestee, requestor, HResult.S_OK, false );
		}
		
		/// <summary>
		/// 	Reject when there was no request, requestee id is vaild
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void  P_Reject_NoAdd_Other()
		{
			PNUser requestor;
			PNUser requestee;
            CreateXenonUsers(out requestor, out requestee);

			DoInvalidReject(requestee, requestor, HResult.S_OK, false);
		}
	
			
		
		/// <summary>
		/// 	Reject a valid request, requestee has been muted
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_Reject_BlockedRequestee()
		{
			PNUser requestor;
			PNUser requestee;
            CreateXenonUsers(out requestor, out requestee);

			requestor.Mute(requestee);

			DoAdd(requestor, requestee);

			DoValidReject(requestee, requestor);
		}
	
        /// <summary>
        /// 	Reject a valid request, requestor has been muted
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_Reject_Never()
        {
            PNUser requestor;
            PNUser requestee;
            CreateXenonUsers(out requestor, out requestee);

            DoAdd(requestor, requestee);

            DoValidReject(requestee, requestor, true);
        }
		
		/// <summary>
		/// 	Reject a request that was valid but has been deleded by requestor
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_Reject_DeletedRequest()
		{
			PNUser requestor;
			PNUser requestee;
            CreateXenonUsers(out requestor, out requestee);

			DoAdd(requestor, requestee);

			DoDelete(requestor, requestee);

			DoInvalidReject(requestee, requestor, HResult.S_OK, false);
		}
		
		/// <summary>
		/// 	Reject a request that was valid but has been already deleded by requestee
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_Reject_DeletedPending()
		{
			PNUser requestor;
			PNUser requestee;
            CreateXenonUsers(out requestor, out requestee);

			DoAdd(requestor, requestee);

			DoDelete(requestee, requestor);

			DoInvalidReject(requestee, requestor, HResult.S_OK, false);
		}
		
		/// <summary>
		/// 	Reject and re-add twice at the max friend boundary
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_Reject_BoundaryCondition_Twice()
		{
			PNUser user1 = CreateXenonUser(true);
			PNUser user2 = null;
			for(int i = 0; i < 99; ++i)
			{
                user2 = CreateXenonUser(true);
				_fc.MakeFriend(user1, user2);
			}

            user2 = CreateXenonUser(true);
            DoAdd(user2, user1);
			// reject the last user
			DoValidReject(user1, user2);

			// readd a new user
            user2 = CreateXenonUser(true);
            DoAdd(user2, user1);
			// reject the new user
			DoValidReject(user1, user2);

			// readd a new user one more time
            user2 = CreateXenonUser(true);
			_fc.MakeFriend(user1, user2);
		}
    }

    [TestGroup,TestFrequency("Daily"), TestCasePriority(2), AsyncGroup(1, 0)]
    public class FuncReject_NegativeCases : RejectTestBaseGroup
	{
		/// <summary>
		/// 	Reject when there was no request, requestor id is requestee
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_Reject_NotAdded_Self()
		{
            PNUser requestee = CreateXenonUser(true);
			DoInvalidReject(requestee, requestee, HResult.E_INVALIDARG, false);
		}
	
		/// <summary>
		/// 	Reject when there was no request, requestor id deosn't exist
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_Reject_InvalidBuddy()
		{
			PNUser invalidBuddy = new PNUser("StfInvalid", 0xfefe000000000000);
			invalidBuddy.Xbox = new PNXbox();

            PNUser user = CreateXenonUser(true);
			DoInvalidReject(user, invalidBuddy, HResult.E_NO_SUCH_USER, false);
		}

		/// <summary>
		/// 	Reject when there was no request, requestee id is invalid
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_Reject_InvalidUser()
		{
            PNUser buddy = CreateXenonUser(true);


			PNUser invalid = new PNUser("InvalidID", 0);
			PNXbox xbox = new PNXbox();
			invalid.Connect(xbox);


			PMsgRejectBuddy rejectMsg = new PMsgRejectBuddy(invalid, buddy, false);
			bool caught = false;
			try
			{
                rejectMsg.TransactFD();
			}
			catch(XErrException e)
			{
				if(e.XErr != HResult.E_INVALIDARG)
					throw;
				caught = true;
			}

			if(!caught)
			{
				throw new UnexpectedTestResultException("Reject did not return XONLINE_E_NOTIFICATION_INVALID_PUID");
			}
		}
		
		/// <summary>
		/// 	Reject a valid buddy request that has already been accepted
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_Reject_Accepted()
		{
            PNUser requestee = CreateXenonUser(true);
            PNUser requestor = CreateXenonUser(true);

			_fc.MakeFriend(requestor, requestee);

			DoInvalidReject(requestee, requestor, HResult.E_USER_EXISTS, true);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncRichPresence.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.config;
using xonline.common.community;

namespace PresenceTest
{
    /// <summary>
    /// Functional Tests for Rich Presence/GI/String Formatting/config
    /// </summary>
    /// <remarks>
    /// <Description>
    /// 	<p>
    /// 	Xenon introduces the concept of rich presence that provides more information on what
    /// 	a user is doing and in a way that is easy for a game to provide rich descriptions of the user state
    /// 	across titles.
    /// 	</p>
    /// 	<p>
    /// 	To populate this data a new type of schematized structure is supported for games under the name Game Instrumetation (GI).
    /// 	The format of the data in the client to SG pulse and SG to presence FD is represented internally in these tests as a GI Blob
    /// 	that allows properties and contexts to be read, written, serialized and deserialized.
    /// 	</p>
    /// 	<p>
    /// 	The format of the properties in the blob, the specs for these context and property types are below.
    /// 	</p>
    ///
    /// 	<div class="test_data_label">
    /// 		GI_CONTEXT Format:
    /// 	</div>
    /// 	<table class="test_data">
    ///			<tr><td>DWORD id                      </td><td>Context name</td></tr>
    ///			<tr><td>DWORD value                   </td><td>Context value</td></tr>
    /// 	</table>
    ///
    /// 	<div class="test_data_label">
    /// 		GI_PROPERTY Format:
    /// 	</div>
    /// 	<table class="test_data">
    ///			<tr><td>DWORD id                      </td><td>Property name and type encoding</td></tr>
    ///			<tr><td>BYTE rgbValue[]               </td><td>Property value, type specific</td></tr>
    /// 	</table>
    ///
    ///		<div class="test_data_label">
    ///			GI Property Type Formats (high byte):
    ///		</div>
    /// 	<table class="test_data">
    ///			<tr><th>Symbolic Name                  </th><th>Hex code  </th><th>Encoding</th></tr>
    ///			<tr><td>XONLINE_STAT_NULL              </td><td>0x00000000</td><td>no encoding, not a valid property</td></tr>
    ///			<tr><td>XONLINE_STAT_LONG              </td><td>0x10000000</td><td>32 bit integral</td></tr>
    ///			<tr><td>XONLINE_STAT_LONGLONG          </td><td>0x20000000</td><td>64 bit integral</td></tr>
    ///			<tr><td>XONLINE_STAT_DOUBLE            </td><td>0x30000000</td><td>64 bit IEEE double</td></tr>
    ///			<tr><td>XONLINE_STAT_LPCWSTR           </td><td>0x40000000</td><td>16 bit count followed by (count) UTF 8 encoded bytes</td></tr>
    ///			<tr><td>XONLINE_STAT_FLOAT             </td><td>0x50000000</td><td>32 bit IEEE float</td></tr>
    ///			<tr><td>XONLINE_STAT_DATETIME          </td><td>0x70000000</td><td>64 bit datetime</td></tr>
    ///		</table>
    ///
    ///		<p>
    ///		Rich presence when dequeued is sent through a string formatter on the front door that is configured
    ///		by a title specific formatting config. This config can have a number of formatting strings that are selected
    ///		with the title presence DWORD. Each formatting string is configured to pick up on contexts and properties
    ///		and insert language specific strings with the values requested user's GI blob placed into the string in
    ///		intelligent places.
    ///		</p>
    ///
    ///		<p>
    ///		Some tests use the GetState internal XRL to query GI blobs directly from the FD skipping the string transformation.
    ///		Other tests use the dequeue method to pull the formatted string from the FD.
    ///		</p>
    ///
    /// </Description>
    /// </remarks>
    [TestGroup, TestFrequency("Daily"), TestCasePriority(2)]
    public class FuncRichPresence : TestNode
    {
        static Report report = new Report("FuncRichPresence");

        class RichPresenceBase : TestBase
        {
            protected FriendsCommon fc;
            protected PNUser  user1;
            protected PNUser  user2;
            protected PNXbox  xbox1;
            protected PNXbox  xbox2;
            private   XConfig xconfig = new XConfig();
            int iSettingRefreshTime;
            protected RichPresenceNotificationData pi1;
            protected RichPresenceNotificationData pi2;

            protected virtual void DoPreInit()
            {
            }
            
            protected virtual void DoInit()
            {
                DoInit(Pong.TitleId);
            }

            protected virtual void DoInit(uint titleID)
            {
                iSettingRefreshTime = xconfig.GetIntSetting(Setting.config_cacheRefreshInterval) + 5000; // Wait 5 extra seconds just in case.
                fc = new FriendsCommon();
                user1 = fc.CreateXenonUser(false);
                user2 = fc.CreateXenonUser(false);
                xbox1 = user1.Xbox;
                xbox2 = user2.Xbox;
                user1.Xbox.ChangeTitle(titleID, 0, 0);
                user2.Xbox.ChangeTitle(titleID, 0, 0);

                fc.LogonUser(user1);
                fc.LogonUser(user2);

                // Make friends and peer subscribe so they get presence data for each other
                fc.MakeFriend( user1, user2 );

                // Make sure that presence is initially not set.
                pi1 = pi2 = null;
                DateTime abortTime = DateTime.Now.AddSeconds(60);
                while(null == pi1 || null == pi2)
                {
                    if(DateTime.Now > abortTime)
                    {
                        throw new UnexpectedTestResultException("Timed out waiting for rich presence on user1: " +
                                user1.UserId.ToString("x") + " and user2: " + user2.UserId.ToString("x"));
                    }
                    Thread.Sleep(1000);
                    user1.ProcessNotifications();
                    user2.ProcessNotifications();
                    pi1 = user1.GetBuddyInfo(user2.UserId).RichPresenceData;
                    pi2 = user2.GetBuddyInfo(user1.UserId).RichPresenceData;
                }
            }
            protected virtual void DoTest()
            {
                report.Warn("DoTest() not implemented in template subclass");
            }
            protected virtual void DoCleanup()
            {
                fc.LogoffUser( user1 );
                fc.LogoffUser( user2 );
            }

            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED; // Assume a passing value unless otherwise specified
                DoPreInit();
                DoInit();
                DoTest();
                DoCleanup();
            }

            // Helpers
            //
            protected bool IsState2Equal(PNUser user, GIBlob gi, PresenceRecord replyData)
            {
                if (user.State != replyData.dwState)
                    return false;
                if (user.MatchSessionId != replyData.qwSessionID)
                    return false;
                if (user.Xbox.TitleId != replyData.dwTitleID)
                    return false;
                if (replyData.rgbRPData == null)
                    return false;
                xonline.common.protocol.RichPresence rp = new xonline.common.protocol.RichPresence();
                rp.ReadBytes(replyData.rgbRPData);
                if (gi.TitlePresence != rp.titlePresence)
                    return false;
                if (gi.PropertiesLen != rp.cProperties)
                    return false;
                if (gi.ContextsLen != rp.cContexts)
                    return false;

                // Do memberwise compare of property and context arrays
                for(int i = 0; i < gi.Properties.Length; i++)
                {
                    GIProperty reqProp = gi.Properties[i];
                    xonline.common.protocol.GIProperty replyProp = rp.rgProps[i];

                    if (reqProp.Id != replyProp.Id)
                        return false;

                    switch(reqProp.Id & GITypes.XONLINE_STAT_DATATYPE_MASK)
                    {
                        case GITypes.XONLINE_STAT_FLOAT:
                            if (reqProp.fValue != replyProp.fValue)
                                return false;
                            break;

                        case GITypes.XONLINE_STAT_DATETIME:
                            if (reqProp.dtValue != replyProp.dtValue)
                                return false;
                            break;

                        case GITypes.XONLINE_STAT_DOUBLE:
                            if (reqProp.dValue != replyProp.dValue)
                                return false;
                            break;

                        case GITypes.XONLINE_STAT_LONG:
                            if (reqProp.nValue != replyProp.nValue)
                                return false;
                            break;

                        case GITypes.XONLINE_STAT_LONGLONG:
                            if (reqProp.lValue != replyProp.lValue)
                                return false;
                            break;

                        case GITypes.XONLINE_STAT_LPCWSTR:
                            if (reqProp.strValue!= replyProp.strValue)
                                return false;
                            break;
                    }
                }

                // Do memberwise compare of property and context arrays
                for(int i = 0; i < gi.Contexts.Length; i++)
                {
                    GIContext reqCtx = gi.Contexts[i];
                    xonline.common.protocol.GIContext replyCtx = rp.rgContexts[i];

                    if (reqCtx.Id != replyCtx.Id)
                        return false;
                    if (reqCtx.Value != replyCtx.Value)
                        return false;
                }

                return true;
            }

            protected void SendContextInfo(GIBlob gi)
            {
                // Flush the QVal queue
                user1.ProcessNotifications();
                user2.ProcessNotifications();

                // Set the title data
                user2.SetTitleData(gi.GetBytes());

                // Wait for the next Presence2 QVal and handle it.
                UserNotification noti = user1.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
                user1.HandleTCPNotification(noti);
                user1.ProcessNotifications();
                pi1 = user1.GetBuddyInfo(user2.UserId).RichPresenceData;
            }

            protected void SendUserContext0(uint GameMode, uint GameSize, uint GameSpeed)
            {
                GIBlob gi = new GIBlob();
                gi.TitlePresence = 0;
                gi.AddContext((uint)Pong.Context.GameMode, GameMode);
                gi.AddContext((uint)Pong.Context.GameSize, GameSize);
                gi.AddContext((uint)Pong.Context.GameSpeed, GameSpeed);

                SendContextInfo(gi);

            }

            protected void SendUserContext1(int Points, int Losses, int Wins, uint GameMode, uint WinScore)
            {

                GIBlob gi = new GIBlob();
                gi.TitlePresence = 1;

                gi.AddProperty(new GIProperty((uint)Pong.PropertyPoints, Points));
                gi.AddProperty(new GIProperty((uint)Pong.PropertyLosses, Losses));
                gi.AddProperty(new GIProperty((uint)Pong.PropertyWins, Wins));

                gi.AddContext((uint)Pong.Context.GameMode, GameMode);
                gi.AddContext((uint)Pong.Context.WinScore, WinScore);

                SendContextInfo(gi);
            }

            protected void SendUserContext2()
            {
                GIBlob gi = new GIBlob();
                gi.TitlePresence = 2;

                SendContextInfo(gi);
            }

            protected void SendUserContext3(string StringProperty)
            {
                GIBlob gi = new GIBlob();
                gi.TitlePresence = 3;                    // Use RP_CONTEXT_3
                gi.AddProperty(new GIProperty((uint)Pong.PropertyUnicode100, StringProperty));  //Temporary while I figure out how to submit a rich presence string

                SendContextInfo(gi);
            }

            protected void SendUserContext4(string StringProperty)
            {
                GIBlob gi = new GIBlob();
                gi.TitlePresence = 4;                    // Use RP_CONTEXT_4
                gi.AddProperty(new GIProperty((uint)Pong.PropertyUnicode126, StringProperty));  //Temporary while I figure out how to submit a rich presence string

                SendContextInfo(gi);
            }

            protected void SendUserContext5(string StringProperty)
            {
                GIBlob gi = new GIBlob();
                gi.TitlePresence = 5;                    // Use RP_CONTEXT_5
                gi.AddProperty(new GIProperty((uint)Pong.PropertyUnicode126, StringProperty));  //Temporary while I figure out how to submit a rich presence string

                SendContextInfo(gi);
            }

            protected void SendUserContext6(string StringProperty, int Points, int Losses, int Wins, uint Multiplayer, uint WinScore)
            {
                GIBlob gi = new GIBlob();
                gi.TitlePresence = 6;                    // Use RP_CONTEXT_6
                gi.AddProperty(new GIProperty((uint)Pong.PropertyUnicode126, StringProperty));
                gi.AddProperty(new GIProperty((uint)Pong.PropertyPoints, Points));
                gi.AddProperty(new GIProperty((uint)Pong.PropertyLosses, Losses));
                gi.AddProperty(new GIProperty((uint)Pong.PropertyWins, Wins));
                gi.AddContext((uint)Pong.Context.GameMode, Multiplayer);
                gi.AddContext((uint)Pong.Context.WinScore, WinScore);

                SendContextInfo(gi);
            }

            protected void BlacklistTitle(String TitleID)
            {
                xconfig.MultiSettingAdd("xblob", "ALL", "-1", "ALL", MultiSetting.presenceFD_StringPresence_BlackList, TitleID);
                report.Debug("Blackisting Title " +  TitleID);
                Thread.Sleep(iSettingRefreshTime); // Wait for 5 minutes, 5 seconds to make sure the setting propogates
            }

            protected void UnBlacklistTitle(String TitleID)
            {
                xconfig.MultiSettingDeleteValue("xblob", "ALL", "-1", "ALL", MultiSetting.presenceFD_StringPresence_BlackList, TitleID);
                report.Debug("Un-blackisting Title " + TitleID);
                Thread.Sleep(iSettingRefreshTime); // Wait for 5 minutes, 5 seconds to make sure the setting propogates
            }

            protected void CheckNullPresence()
            {
                ValueCheck.IsTrue(null == pi1, "Presence ListItem for user 2 is not null.  The presence item was: " + pi1.RichPresenceString);
            }

            protected void CheckPresence(string sPresence)
            {
                ValueCheck.IsTrue(null != pi1, "Presence ListItem for user 2 is null");
                ValueCheck.IsTrue(pi1.RichPresenceString.Length != 0, "RichPresence for user 2 is 0 length, string should have data.");
                ValueCheck.IsTrue(pi1.RichPresenceString.Equals(sPresence), "Rich Presence Strings do not match!\n\tExpected: '" + pi1.RichPresenceString + "'\n\tActual:  '" + sPresence + "'");
            }

            protected void CheckNullPresenceString()
            {
                ValueCheck.IsTrue(null != pi1, "Presence ListItem for user 2 is null");
                ValueCheck.IsTrue(pi1.RichPresenceString == null, "The user's rich presence string is NOT null.  The string is: '" + pi1.RichPresenceString + "'");
            }

            protected void ReportError(Exception e)
            {
                report.Error(e.Message + "\n\n" + e.StackTrace);
                ResultCode = TEST_RESULTS.FAILED;
            }
        }

        /// <summary>
        /// 	Exercise all GI property types
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 		<p>
        /// 		Create a GI blob with every supported property type. Populate the properties
        /// 		with various reasonable values. Dequeue that data on another client.
        /// 		</p>
        ///
        /// 		<p>
        /// 		Create individual GI blob with each single property type. Populate the properties
        /// 		with reasonable values. Set state and dequeue on the invidual property types.
        /// 		</p>
        /// 	</Description>
        /// 	<Verify>
        /// 		<ul>
        /// 		<li>S_OK from GetState</li>
        /// 		<li>GetState BLOB matches locally created GI BLOB</li>
        /// 		</ul>
        /// 	</Verify>
        /// </remarks>
        [TestCase, AsyncGroup(1)]
        class P_StatePropertyTypes : RichPresenceBase
        {
            protected override void DoTest()
            {
                // Fill in the properties and contexts. We want one of each type of property and
                //  one context. This will test serialization and deserialization of both the STF
                //  and server implementation of the GIProperty objects.
                GIBlob gi = new GIBlob();
                gi.AddProperty(new GIProperty(GITypes.XONLINE_STAT_LONG, (int)5));
                gi.AddProperty(new GIProperty(GITypes.XONLINE_STAT_LONGLONG, (long)55));
                gi.AddProperty(new GIProperty(GITypes.XONLINE_STAT_DOUBLE, (double)55.55));
                gi.AddProperty(new GIProperty(GITypes.XONLINE_STAT_LPCWSTR, "this is a property"));
                gi.AddProperty(new GIProperty(GITypes.XONLINE_STAT_FLOAT, (float )5.5));
                gi.AddProperty(new GIProperty(GITypes.XONLINE_STAT_DATETIME, DateTime.UtcNow));

                gi.AddContext(new GIContext(1, 1));
                gi.AddContext(new GIContext(2, 2));


                user2.SetTitleData(gi.GetBytes());

                UserNotification noti = user1.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
                user1.HandleTCPNotification(noti);

                // Load the presence record from the presence cache. This will return the raw data
                // used to formulate the rich presence string for user 2
                PresenceRecord record = PresenceUtil.GetPresenceRecord(user2.UserId);
                ValueCheck.IsTrue( record != null, "Could not load presence for user" );


                // Now that we have the reply, reqData should == replyData
                if( !IsState2Equal(user2, gi, record) )
                {
                    throw new UnexpectedTestResultException( "Cache returned different data than was set via State2");
                }

                report.Debug("user 2 state written to the server via State2 message and then retrieved via GetState. Result=Identical \n");
            }
        }

        /// <summary>
        /// 	Exercise the rich presence state size limit
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	Overload the ammount of the rich presence title data (128 bytes).
        /// 	</Description>
        /// 	<Verify>
        ///			<ul>
        ///			<li>GetState for rich presence data returns XONLINE_E_NOTIFICATION_NO_DATA.</li>
        ///			<li>0 properties returned.</li>
        ///			<li>0 contexts returned.</li>
        ///			</ul>
        /// 	</Verify>
        /// </remarks>
        [TestCase, AsyncGroup(1), Ignore, Description("This test is defunct since we don't impose the 128 byte restriction anymore on the service.")]
        class P_StateSizeLimit : RichPresenceBase
        {
            protected override void DoTest()
            {
                // Fill in the properties and contexts. We want one of each type of property and
                //  one context. This will test serialization and deserialization of both the STF
                //  and server implementation of the GIProperty objects.
                GIBlob gi = new GIBlob();
                gi.AddProperty(new GIProperty(GITypes.XONLINE_STAT_LONG, (int)5));
                gi.AddProperty(new GIProperty(GITypes.XONLINE_STAT_LONGLONG, (long)55));
                gi.AddProperty(new GIProperty(GITypes.XONLINE_STAT_DOUBLE, (double)55.55));
                gi.AddProperty(new GIProperty(GITypes.XONLINE_STAT_LPCWSTR, "this is a property that makes the overall submission greater than 128 bytes"));
                gi.AddProperty(new GIProperty(GITypes.XONLINE_STAT_FLOAT, (float )5.5));
                gi.AddProperty(new GIProperty(GITypes.XONLINE_STAT_DATETIME, DateTime.UtcNow));


                gi.AddContext(new GIContext(1, 1));
                gi.AddContext(new GIContext(2, 2));


                user2.SetTitleData(gi.GetBytes());

                // QFlags are not going ot be set, because the previous SetState call failed.
                // user1.WaitForQFlags( XonPresNoti.QFLAG_MASK_PRESENCE );
                Thread.Sleep(3000);


                // Send a GetState message to the presence service. This will return the raw data
                // used to formulate the rich presence string for user 2
                PresenceRecord record = PresenceUtil.GetPresenceRecord(user2.UserId);
                
                xonline.common.protocol.RichPresence rp = new xonline.common.protocol.RichPresence();
                rp.ReadBytes(record.rgbRPData);
                ValueCheck.Test( "ReplyData NumProps", 0, rp.rgProps.Length);
                ValueCheck.Test( "ReplyData NumContexts", 0, rp.rgContexts.Length);
                ValueCheck.Test( "ReplyData NumProps", (ushort)0, rp.cProperties);
                ValueCheck.Test( "ReplyData NumContexts", (ushort)0, rp.cContexts);
            }
        }

        /// <summary>
        /// 	Basic rich presence request, read formatted string
        /// </summary>
        /// <remarks>
        /// 	<Description>
        ///			Populate some GI data in a state update for the Pong title ID (0x123545abc).
        ///			Request that data in a dequeue.
        /// 	</Description>
        /// 	<Verify>
        /// 		<ul>
        /// 		<li>QFlag delivered from state update.</li>
        /// 		<li>Notification delievered on PRESENCE_2 queue.</li>
        /// 		<li>Presence contains rich-formatted string.</li>
        /// 		</ul>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1), AsyncGroup(1)]
        class P_BasicRichPresence : RichPresenceBase
        {
            protected override void DoTest()
            {
                string rp;
                //
                // Set state and fetch the Rich Presence data from the other user
                //
                report.Debug("setting rich presence title data for user 2.");

                // Fill in the properties and contexts for presence context 0
                SendUserContext0((uint)Pong.GameMode.SinglePlayer, (uint)Pong.GameSize.Medium, (uint)Pong.GameSpeed.Fast);

                ValueCheck.IsTrue( null != pi1, "Presence ListItem for user 2 is null" );
                ValueCheck.IsTrue(pi1.RichPresenceString.Length != 0, "Presence rgbTitleStuff for user 2 is 0 length, even though it has been set. ");

                rp = pi1.RichPresenceString;
                report.Debug("user 1 received rich presence string for user 2: " + rp);

                //
                // Set state and fetch the Rich Presence data from the other user
                //

                SendUserContext1(17, 3, 11, (uint)Pong.GameMode.MultiPlayer, (uint)Pong.WinScore.Points21);

                ValueCheck.IsTrue( null != pi1, "Presence ListItem for user 2 is null" );
                ValueCheck.IsTrue(pi1.RichPresenceString.Length != 0, "Presence rgbTitleStuff for user 2 is 0 length, even though it has been set. ");

                report.Debug("user 1 received rich presence string for user 2: " + pi1.RichPresenceString);
            }
        }

        /// <summary>
        /// 	Test default properties set by game config
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 		Populate the GI blob with points and wins but not losses. This value should
        /// 		default to blank as defaults are no longer applied to formatting.
        /// 	</Description>
        /// 	<Verify>
        /// 	<ul>
        /// 	<li>QFLAGS delivered for rich presence.</li>
        /// 	<li>S_OK for presence item delievery.</li>
        /// 	<li>Presence item non-zero length.</li>
        /// 	<li>Rich presence string containing losses = 0.</li>
        /// 	</ul>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1), AsyncGroup(1)]
        class P_DefaultProperties : RichPresenceBase
        {
            protected override void DoTest()
            {
                GIBlob gi = new GIBlob();

                // Use custom code to handle not setting a default for a GIBlob
                gi.TitlePresence = 1;
                gi.AddProperty(new GIProperty((int)Pong.PropertyPoints, (int)17));
                // Don't include losses
                // gi.AddProperty(new GIProperty((uint)Pong.PropertyLosses, (int)3));
                gi.AddProperty(new GIProperty((int)Pong.PropertyWins, (int)11));

                gi.AddContext((uint)Pong.Context.GameMode, (uint)Pong.GameMode.MultiPlayer);
                gi.AddContext((uint)Pong.Context.WinScore, (uint)Pong.WinScore.Points21);

                user2.SetTitleData(gi.GetBytes());

                UserNotification noti = user1.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
                user1.HandleTCPNotification(noti);

                pi1 = user1.GetBuddyInfo(user2.UserId).RichPresenceData;

                ValueCheck.IsTrue(string.IsNullOrEmpty(pi1.RichPresenceString), "Presence ListItem for user 2 is null");
                ValueCheck.IsTrue(pi1.RichPresenceString.Length == 0, "RichPresence for user 2 is not 0 length, default was not supplied, string should not have any data. ");
                report.Debug("user 1 received rich presence string for user 2: " + pi1.RichPresenceString);
            }
        }

        /// <summary>
        /// 	Test the golden path of an arbitrary rich presence string
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 		Send a rich presence string that contains an ARP string and verifies that it comes across correctly.
        /// 	</Description>
        /// 	<Verify>
        /// 	<ul>
        /// 	<li>Presence string arrives correctly</li>
        /// 	</ul>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1), AsyncGroup(1)]
        class P_ArbitraryRichPresenceGoldenPath : RichPresenceBase
        {
            protected override void DoTest()
            {
                SendUserContext3("Test string");

                try
                {
                    CheckPresence("English Arbitrary String: Test string");
                }
                catch (ServerTestFramework.ExpectedValueCheckException e)
                {
                    ReportError(e);
                }
            }
        }

        /// <summary>
        /// 	Test the ARP strings with a 0-length string being sent up
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 		Send a rich presence string that contains a 0-length ARP string and verifies that it comes across correctly.
        /// 	</Description>
        /// 	<Verify>
        /// 	<ul>
        /// 	<li>Presence string arrives correctly</li>
        /// 	</ul>
        /// 	</Verify>
        /// </remarks>
        [TestCase, AsyncGroup(1)]
        class P_ArbitraryRichPresenceZeroString : RichPresenceBase
        {
            protected override void DoTest()
            {

                SendUserContext3("");

                try
                {
                    CheckPresence("English Arbitrary String: ");
                }
                catch (ServerTestFramework.ExpectedValueCheckException e)
                {
                    ReportError(e);
                }
            }
        }



        /// <summary>
        /// 	Test the ARP strings with a max string being sent up
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 		Send a rich presence string that contains an ARP string that is
        /// 		exactly long enough to hit the character boundary.  The pre-defined string is
        /// 		"English Arbitrary String: ", which is 26 characters long.  Our
        /// 		maximum number of characters is 63, so this leaves us 37 characters
        /// 		to do with as we please.
        /// 	</Description>
        /// 	<Verify>
        /// 	<ul>
        /// 	<li>Presence string arrives correctly</li>
        /// 	</ul>
        /// 	</Verify>
        /// </remarks>
        [TestCase, AsyncGroup(1)]
        class P_ArbitraryRichPresenceMaxLength : RichPresenceBase
        {
            protected override void DoTest()
            {
                SendUserContext3("1234567890123456789012345678901234567");

                try
                {
                    CheckPresence("English Arbitrary String: 1234567890123456789012345678901234567");
                }
                catch (ServerTestFramework.ExpectedValueCheckException e)
                {
                    ReportError(e);
                }
            }
        }


        /// <summary>
        /// 	Test the ARP strings with a string that increases the presence string beyond the boundary.
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 		Send a rich presence string that contains an ARP string that is
        /// 		just too long and will hit the character boundary.  The pre-defined string is
        /// 		"English Arbitrary String: ", which is 26 characters long.  The client's max
        /// 		character limit is 64 (including the null char), but our limit on the server is much higher.
        /// 		that limit is currently under investigation.
        /// 	</Description>
        /// 	<Verify>
        /// 	<ul>
        /// 	<li>Presence string does not arrive, because it is too long</li>
        /// 	</ul>
        /// 	</Verify>
        /// </remarks>
        [TestCase, Ignore, AsyncGroup(1)]
        class P_ArbitraryRichPresenceTooLong : RichPresenceBase
        {
            protected override void DoTest()
            {
                SendUserContext3("This is a test of the Tolt Dam Warni");

                try
                {
                    CheckNullPresence();
                }
                catch (ServerTestFramework.ExpectedValueCheckException e)
                {
                    ReportError(e);
                }
            }
        }

        /// <summary>
        /// 	Test an ARP string that is the entire context (no other text).
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 		Send a rich presence string that consists ONLY of an ARP string that is
        /// 		exactly long enough to hit the character boundary.
        /// 	</Description>
        /// 	<Verify>
        /// 	<ul>
        /// 	<li>Presence string arrives correctly</li>
        /// 	</ul>
        /// 	</Verify>
        /// </remarks>
        [TestCase, AsyncGroup(1)]
        class P_ArbitraryRichPresenceWholeString : RichPresenceBase
        {
            protected override void DoTest()
            {

                SendUserContext4("This is a test of the Tolt Dam Warning System.12345678901");

                try
                {
                    CheckPresence("This is a test of the Tolt Dam Warning System.12345678901");
                }
                catch (ServerTestFramework.ExpectedValueCheckException e)
                {
                    ReportError(e);
                }
            }
        }

        /// <summary>
        /// 	Test an ARP string surrounded by text on both sides.
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 		Send a rich presence string that is surrounded by text on either side, hitting the character boundary.
        /// 	</Description>
        /// 	<Verify>
        /// 	<ul>
        /// 	<li>Presence string arrives correctly</li>
        /// 	</ul>
        /// 	</Verify>
        /// </remarks>
        [TestCase, AsyncGroup(1)]
        class P_ArbitraryRichPresenceMiddleString : RichPresenceBase
        {
            protected override void DoTest()
            {

                SendUserContext5("This is in the middle");

                try
                {
                    CheckPresence("This is on the left:This is in the middle:This is on the right.");
                }
                catch (ServerTestFramework.ExpectedValueCheckException e)
                {
                    ReportError(e);
                }
            }
        }


        /// <summary>
        /// 	Test an ARP string amongst a presence string that contains other properties and contexts as well
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 		Send a rich presence string that is surrounded by text on either side, hitting the character boundary.
        /// 	</Description>
        /// 	<Verify>
        /// 	<ul>
        /// 	<li>Presence string arrives correctly</li>
        /// 	</ul>
        /// 	</Verify>
        /// </remarks>
        [TestCase, AsyncGroup(1)]
        class P_ArbitraryRichPresenceComplexString : RichPresenceBase
        {
            protected override void DoTest()
            {
                SendUserContext6("ARBITRARY TEXT", 17, 3, 11, (uint)Pong.GameMode.MultiPlayer, (uint)Pong.WinScore.Points21);

                try
                {
                    CheckPresence("Multi Player:17/21,[ARBITRARY TEXT] 11 wins, 3 losses ");
                }
                catch (ServerTestFramework.ExpectedValueCheckException e)
                {
                    ReportError(e);
                }
            }
        }


        /// <summary>
        /// 	Test that the blacklist prevents a title from broadcasting arbitrary rich presence strings
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 		Load the players into Pong and update an arbitrary rich presence string
        /// 	</Description>
        /// 	<Verify>
        /// 	<ul>
        /// 	<li>ARP strings are not set.</li>
        /// 	</ul>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1), AsyncGroup(1), Ignore("Running this test case blocks the title which is used for other tests. results in massive failure.")]
        class P_BlackListedNoARP : RichPresenceBase
        {
            //This is the real test - It will time out waiting to find the user's presence when it signs them in using ARP
            protected override void DoInit()
            {
                DoInit(0xFFFF400C); // Automatically Blacklisted TitleID
            }

            protected override void DoTest()
            {
                try
                {
                    SendUserContext3("Blacklisted!");
                    report.Error("Presence request did NOT tiem out for the blacklisted title.  Are you sure it's been blacklisted?  Player2's presence was " + user1.GetBuddyInfo(user2.UserId).RichPresenceData.RichPresenceString);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (TimeOutException) // This is the one we expect.  If we time out trying to get a new presence string, no new rich presence info came through, which is expected.
                {
                }
                catch (Exception e) // All other exceptions
                {
                    ReportError(e);
                }

            }
        }

        /// <summary>
        /// 	Test that the blacklist prevents a title from broadcasting any rich presence strings
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 		Load the players into Pong and update a non-arbitrary rich presence string
        /// 	</Description>
        /// 	<Verify>
        /// 	<ul>
        /// 	<li>SRP strings are not set.</li>
        /// 	</ul>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1), AsyncGroup(1), Ignore("Running this test case blocks the title which is used for other tests. results in massive failure.")]
        class P_BlackListedNoSRP : RichPresenceBase
        {
            protected override void DoInit()
            {
                DoInit(0xFFFF400C); // Automatically Blacklisted TitleID
            }

            protected override void DoTest()
            {
                try
                {
                    SendUserContext2();
                    report.Error("Presence request did NOT time out for the garbage blacklist setting.  Player2's presence was " + user1.GetBuddyInfo(user2.UserId).RichPresenceData.RichPresenceString);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (TimeOutException) // This is the one we expect.  If we time out trying to get a new presence string, no new rich presence info came through, which is expected.
                {
                }
                catch (Exception e) // All other exceptions
                {
                    ReportError(e);
                }
            }
        }

    } // TestGroup
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncQueryAffiliates.cs ===
using System; 
using System.Collections; 
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;

using xonline.common.config;

namespace PresenceTest
{
	/// <summary>
	/// 	Positive Functional Tests for QueryAffiliates
	/// </summary>
	/// <remarks>
	/// 	<Description>
	/// 		<p>
	/// 		The QueryAffiliates call will be used both from the client and internally within
	/// 		the service to serve a variety of purposes. Affiliate data items are read from
	/// 		either actual affiliate lists: encountered, completed game, positive and negative 
	/// 		feedback or from implicit lists such friend, block and mute lists. Affiliate data
	/// 		is always returned in the same format. 
	/// 		</p>
	///
	///			<div class="test_data_label">
	/// 		The parameters to the query are:
	/// 		</div>
	/// 		<table class="test_data">
	/// 			<tr><td>Sender user ID           </td><td>(64 bit unique ID)</td></tr>
	/// 			<tr><td>Affiliate List Flags     </td><td>(32 bit affiliate flags defined in xonline.x)</td></tr>
	/// 			<tr><td>Query result limit       </td><td>(32 bit unsigned count limit)</td></tr>
	/// 			<tr><td>Live title ID            </td><td>(32 bit LiveTitleID)</td></tr>
	/// 		</table>
	///
	/// 		<div class="test_data_label">
	/// 		P_QUERY_AFFILIATES_REPLY message structure:
	/// 		</div>
	/// 		<table class="test_data">
	/// 			<tr><td>HRESULT hr                                    </td><td>Result code of query</td></tr>
	/// 			<tr><td>DWORD cdwResults                              </td><td>Number of items in rgResults</td></tr>
	///				<tr><td>P_QUERY_AFFILIATES_REPLY_DATA_MSG [] rgResults</td><td>Result item payload</td></tr>
	///			</table>
	/// 		<div class="test_data_label">
	/// 		P_QUERY_AFFILIATES_REPLY_DATA_MSG message structure:
	/// 		</div>
	///			<table>
	///				<tr><td>ULONGLONG qwAffiliateID               </td><td>XUID of affiliate</td></tr>
	///				<tr><td>DWORD dwListFlags                     </td><td>Flags of lists user is attached to</td></tr>
	///				<tr><td>DWORD dwTitleID                       </td><td>Title ID from user record, set from login and title change</td></tr>
	///				<tr><td>ULONGLONG qwSessionID                 </td><td>Session ID from user record, set from client</td></tr>
	///				<tr><td>MSGTIME mtDateUpdated                 </td><td>32 bit message timer</td></tr>
	///				<tr><td>char szGamerTag[XONLINE_GAMERTAG_SIZE]</td><td>Puid mapped gamertag from xcache on front door</td></tr>
	///			</table>
	///
	///			<div class="test_data_label">
	///				Query Affiliates HRESULT Codes:
	///			</div>
	///			<table class="test_data">
	///				<tr><td>S_OK</td><td>Operation succeeded</td></tr>
	///				<tr><td>E_NOSUCHUSER</td><td>Operation succeeded</td></tr>
	///				<tr><td>E_OUTOFMEMORY</td><td>Operation succeeded</td></tr>
	///				<tr><td>S_OK</td><td>Operation succeeded</td></tr>
	///				<tr><td>S_OK</td><td>Operation succeeded</td></tr>
	///				<tr><td>S_OK</td><td>Operation succeeded</td></tr>
	///			</table>
	///
	///			<p>
	/// 		Affiliate list flags can be any number from 0 to 0xffffffff but flags that actually
	/// 		correspond to internal lists are defined in xonline.x (0x0007001f). 
	/// 		</p>
	///
	///			<div class="test_data_label">
	/// 			Valid affiliate list flags:
	/// 		</div>
	/// 		<table class="test_data">
	/// 			<tr><th>Friendly Name      </th><th>Bit Flags    </th><th>Notation</th></tr>
	/// 			<tr><td>Encountered        </td><td>0x00000001   </td><td>E</td></tr>
	/// 			<tr><td>Completed Game     </td><td>0x00000002   </td><td>C</td></tr>
	/// 			<tr><td>Positive Feedback  </td><td>0x00000004   </td><td>P</td></tr>
	/// 			<tr><td>Negative Feedback  </td><td>0x00000008   </td><td>N</td></tr>
	/// 			<tr><td>Avoiding Me        </td><td>0x00000010   </td><td>A</td></tr>
	/// 			<tr><td>Friends            </td><td>0x00010000   </td><td>F</td></tr>
	/// 			<tr><td>Blocks             </td><td>0x00020000   </td><td>B</td></tr>
	/// 			<tr><td>Mutes              </td><td>0x00040000   </td><td>M</td></tr>
	/// 		</table>
	///
	///			<p>
	/// 		Query result limit can be passed as 0 which indicates that all results should return. 
	/// 		Otherwise, a limit will be imposed on the number of total results returned. If this limit
	/// 		is returned the results will also be sorted by the last time they were modified with the 
	/// 		most recent items at the top of the list.
	/// 		</p>
	///
	///			<p>
	/// 		Tests will use a matrix approach for the flags but will seperate out the values used for
	/// 		title ID and limit to provide different forms of validation.
	/// 		</p>
	///
	///			<p>
	/// 		In order to provide the data sets required for querying all combination of affiliate list
	/// 		flags the test will pre-populate a user for each combination of flags. The number of required
	/// 		users for each matrix is ~2^8. The exception is the completed flag which will always enable
	/// 		an affiliate with the encountered flag. These users are created and validated 
	/// 		automatically by methods that take a string format user name (using notation above), parse it for the
	/// 		notation flags and setup or test queries for those flags. This is the query initiator control group.
	/// 		</p>
	/// 		
	/// 		<p>
	/// 		Additionally, a negative control set of users is created that can be placed outside of the query
	/// 		conditions to provide further validation against the query parameters.
	/// 		</p>
	///
	///			<p>
	/// 		The final set of users are the query result control set. These are the users that are required
	/// 		to satisfy the conditions on each of the initiator control set users. These users will not have
	/// 		any direct affiliations but will be used for validating the recipricol affiliations (avoiding me).
	/// 		</p>
	///
	/// 		<div class="test_data_label">
	/// 			User control sets:
	/// 		</div>
	/// 		<table class="test_data">
	/// 			<tr><td>Initiator control set  </td><td>Named with above notation and will contain affiliations indicated by their name (UserPNCE=Positive,Negative,Completed,Encountered)</td></tr>
	/// 			<tr><td>Negative control set   </td><td>Users who are placed outside the parameters of the query.</td></tr>
	/// 			<tr><td>Result control set     </td><td> Users who are the target of the affiliations. Used for testing recipricol affiliation conditions.</td></tr>
	/// 		</table>
	///
	/// 	</Description>
	/// </remarks>
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3)]
	public class FuncQueryAffiliates_PositiveCases : PresenceTestBaseGroup
	{
		private static Report _Report = new Report(typeof(FuncQueryAffiliates_PositiveCases).Name);
		private class FlagInfo
		{
			public string Name;
			public uint Bits;
			public string Notation;

			public FlagInfo(string name, uint bits, string notation)
			{
				Name = name;
				Bits = bits;
				Notation = notation;
			}
		}
		
		private static FlagInfo[] _Flags = new FlagInfo[]
		{
			new FlagInfo("Encountered",       0x00000001, "E"),
			new FlagInfo("Completed Game",    0x00000002, "C"),
			new FlagInfo("Positive Feedback", 0x00000004, "P"),
			new FlagInfo("Negative Feedback", 0x00000008, "N"),
			new FlagInfo("Avoiding Me",       0x00000010, "A"),
			new FlagInfo("Friends",           0x00010000, "F"),
			new FlagInfo("Blocks",            0x00020000, "B"),
			new FlagInfo("Mutes",             0x00040000, "M"),
		};

		private class Initiator
		{
			public PNUser    Owner;
			public PNUser    Reverse;   // For when the owner should be queried on the reverse list
			public bool      QueryBoth; // Query both the reverse and owner for the relationship
			public Hashtable ResultSet;
			public Hashtable NegativeSet;
			public uint      Flags;
			
			public Initiator(PNUser owner)
			{
				Owner = owner;
				ResultSet = new Hashtable();
				NegativeSet = new Hashtable();
			}
		};

		bool _DatasetCreated = false;

		ArrayList _ICS; // initiator control set
		ArrayList _AllUsers; // Used for building negative sets

		ArrayList GetFlagSet(uint flags)
		{
			ArrayList results = new ArrayList();

			foreach(FlagInfo flag in _Flags)
			{
				if((flag.Bits & flags) != 0)
				{
					results.Add(flag);
				}
			}

			return results;
		}

		// Build a subset of the initiator set for a given set of flags
		ArrayList GetInitiatorSet(uint flags)
		{
			ArrayList results = new ArrayList();

			foreach(Initiator i in _ICS)
			{
				if((i.Flags & flags) != 0)
				{
					results.Add(i);
				}
			}

			return results;
		}

		void AddAffiliate(PNUser u, PNUser affiliate, uint titleId, uint flags)
		{
			AddAffiliate(u, new PNUser[]{affiliate}, titleId, flags);
		}

		void AddAffiliate(PNUser u, PNUser []list, uint titleId, uint flags)
		{
			PMsgAddAffiliates req = new PMsgAddAffiliates(
					u, 
					flags,
					titleId, 
					list);
            req.TransactFD();
		}

		PNUser CreateUser()
		{
			PNUser u = CreateXenonUser(true);
			_AllUsers.Add(u);
			return u;
		}

		PNUser CreateUser(uint titleId)
		{
			PNUser u = CreateXenonUser(false);
			u.Xbox.ChangeTitle(titleId, 0, 0);
			_fc.LogonUser(u);
			return u;
		}


		// Populate an initiator provided a given set of flags
		void PopulateInitiator(Initiator i, uint titleId, uint flags)
		{
			PNUser u = i.Owner;

			// Encountered
			if((flags & 0x1) != 0)  
			{
				PNUser result = CreateUser();
				AddAffiliate(u, result, titleId, (uint)AffiliateFlags.Encountered);
				i.ResultSet[result.UserId] = result;
				i.Flags |= (uint)AffiliateFlags.Encountered;
			}

			// CompletedGame
			if((flags & 0x2) != 0) 
			{
				PNUser result = CreateUser();
				AddAffiliate(u, result, titleId, (uint)AffiliateFlags.CompletedGame);
				i.ResultSet[result.UserId] = result;
				i.Flags |= (uint)AffiliateFlags.CompletedGame;
			}
			// PositiveFeedback
			if((flags & 0x4) != 0) 
			{
				PNUser result = CreateUser();
				AddAffiliate(u, result, titleId, (uint)AffiliateFlags.PositiveFeedback);
				i.ResultSet[result.UserId] = result;
				i.Flags |= (uint)AffiliateFlags.PositiveFeedback;
			}
			// NegativeFeedback
			if((flags & 0x8) != 0) 
			{
				PNUser result = CreateUser();
				AddAffiliate(u, result, titleId, (uint)AffiliateFlags.NegativeFeedback);
				i.ResultSet[result.UserId] = result;
				i.Flags |= (uint)AffiliateFlags.NegativeFeedback;
			}
			// AvoidingMe
			if((flags & 0x10) != 0) 
			{
				i.Reverse = CreateUser();
				i.ResultSet[u.UserId] = u;
				AddAffiliate(i.Reverse, u, titleId, (uint)AffiliateFlags.NegativeFeedback);
				i.Flags |= (uint)AffiliateFlags.AvoidingMe;
			}
			// Friend
			if((flags & 0x20) != 0) 
			{
				PNUser friend = CreateUser();
				_fc.MakeFriend(u, friend);

				// Make sure the reverse holds true
				i.ResultSet[friend.UserId] = friend;
				i.ResultSet[u.UserId] = u;
				i.Reverse = friend;
				i.QueryBoth = true;
				i.Flags |= (uint)AffiliateFlags.Friend;
			}

			// Block
			if((flags & 0x40) != 0) 
			{
				PNUser block = CreateUser();
				u.Mute(block); // TODO-jacobr: determine difference between lists
				i.ResultSet[block.UserId] = block;
				i.Flags |= (uint)AffiliateFlags.Block;
			}
			// Mute
			if((flags & 0x80) != 0) 
			{
				PNUser mute = CreateUser();
				u.Mute(mute);
				i.ResultSet[mute.UserId] = mute;
				i.Flags |= (uint)AffiliateFlags.Mute;
			}
		}

		void BuildDataset()
		{
			if(_DatasetCreated)
				return;
			
			_ICS = new ArrayList(256);
			_AllUsers = new ArrayList(1000);

			for(uint flags = 0; flags < 0xff; ++flags)
			{
				Initiator i = new Initiator(CreateXenonUser(true));
				PopulateInitiator(i, i.Owner.Xbox.TitleId, flags);
				_ICS.Add(i);
			}

			// Go through and agument initiators with negative sets from other 
			// initiators result sets
			foreach(Initiator i in _ICS)
			{
				foreach(PNUser u in _AllUsers)
				{
					if(!i.ResultSet.Contains(u))
					{
						i.NegativeSet[u.UserId] = u;
					}
				}
			}

			_DatasetCreated = true;
		}
		void ValidateAffiliateResult(QueryAffiliatesReplyData data, PNUser u, uint desiredTitleId, uint listFlags) 
		{
			ValueCheck.Test("User(" + u.UserId + ")-AffiliateId", u.UserId, data.qwAffiliateID);
			ValueCheck.TestBits("User(" + u.UserId + ")-ListFlags", listFlags, data.dwListFlags);
			ValueCheck.Test("User(" + u.UserId + ")-TitleId", desiredTitleId, data.dwTitleID);
			ValueCheck.Test("User(" + u.UserId + ")-SessionId", u.MatchSessionId, data.qwSessionID);
			ValueCheck.Test("User(" + u.UserId + ")-GamerString", u.Name, data.szGamerTag);
		}

		//------------------------------------------------------------------------------
		// 
		// Mainline QueryAffiliates cases
		//


		/// <summary>
		/// 	QueryAffiliates: No limit, title specific, flags matrix
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		<p>
		/// 		This test specifies no limit for result count and a specific title.
		/// 		</p>
		///
		/// 		<p>
		/// 		A set of xboxes is created in a specific title ID and all of the result 
		/// 		control set users are connected to this set of xboxes. The negative control 
		/// 		set of users is connected to xboxes out of the title range. The initiator control
		/// 		set are connected to a mix of in-title and out-of-title xboxes.
		/// 		</p>
		///
		/// 		<p>
		/// 		The result set has a mix of in-session and out of session using the 
		/// 		set title data calls.
		/// 		</p>
		/// 	</Description>
		/// 	<Verify>
		/// 		<ul>
		/// 		<li>For each initiator validate the result set using their user notation flags.</li>
		/// 			<ul>
		/// 			<li>Validate each affiliate result - AffiliateId</li>
		/// 			<li>Validate each affiliate result - ListFlags</li>
		/// 			<li>Validate each affiliate result - TitleId</li>
		/// 			<li>Validate each affiliate result - SessionId</li>
		/// 			<li>Validate each affiliate result - DateUpdated</li>
		/// 			<li>Validate each affiliate result - GamerTag</li>
		/// 			</ul>
		/// 		<li>No puids returned in the negative control set.</li>
		/// 		</ul>
		/// 	</Verify> 
		/// </remarks> 
		[TestCase,Ignore]
		public void P_QueryAffiliates_NoLimit_TitleSpecific_FlagsMatrix()
		{
			BuildDataset();
		}

		/// <summary>
		/// 	QueryAffiliates: Limit result count, title specific, flags matrix
		/// </summary>
		/// <remarks>
		///		<Description>
		///			<p>
		/// 		This test specifies a 20 count limit for results and a specific title.
		/// 		</p>
		///
		/// 		<p>
		/// 		A set of xboxes is created in a specific title ID and all of the result 
		/// 		control set users are connected to this set of xboxes. The negative control 
		/// 		set of users is connected to xboxes out of the title range. The initiator control
		/// 		set are connected to a mix of in-title and out-of-title xboxes.
		/// 		</p>
		///
		/// 		<p>
		/// 		The result set has a mix of in-session and out of session using the 
		/// 		set title data calls.
		/// 		</p>
		/// 	</Description>
		/// 	<Verify>
		/// 		<ul>
		/// 		<li>Results sorted by DateUpdated.</li>
		/// 		<li>For each initiator validate the result set using their user notation flags.</li>
		/// 			<ul>
		/// 			<li>Validate each affiliate result - AffiliateId</li>
		/// 			<li>Validate each affiliate result - ListFlags</li>
		/// 			<li>Validate each affiliate result - TitleId</li>
		/// 			<li>Validate each affiliate result - SessionId</li>
		/// 			<li>Validate each affiliate result - DateUpdated</li>
		/// 			<li>Validate each affiliate result - GamerTag</li>
		/// 			</ul>
		/// 		<li>No puids returned in the negative control set.</li>
		/// 		</ul>
		/// 	</Verify> 
		/// </remarks> 
		[TestCase,Ignore]
		public void P_QueryAffiliates_Limit20_TitleSpecific_FlagsMatrix()
		{
		}

		/// <summary>
		/// 	QueryAffiliates: No limit, no title, flags matrix
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		<p>
		/// 		This test specifies no limit for result count and no title limitation.
		/// 		</p>
		///
		/// 		<p>
		/// 		A set of xboxes is created in random title IDs and all of the result 
		/// 		control set users are connected to this set of xboxes. The negative control
		/// 		set is ignored in this test. The initiator control set are connected to 
		/// 		random title xboxes.
		/// 		</p>
		///
		/// 		<p>
		/// 		The result set has a mix of in-session and out of session using the 
		/// 		set title data calls.
		/// 		</p>
		/// 	</Description>
		/// 	<Verify>
		/// 		<ul>
		/// 			<li>For each initiator validate the result set using their user notation flags.</li>
		/// 			<ul>
		/// 			<li>Validate each affiliate result - AffiliateId</li>
		/// 			<li>Validate each affiliate result - ListFlags</li>
		/// 			<li>Validate each affiliate result - TitleId</li>
		/// 			<li>Validate each affiliate result - SessionId</li>
		/// 			<li>Validate each affiliate result - DateUpdated</li>
		/// 			<li>Validate each affiliate result - GamerTag</li>
		/// 			</ul>
		/// 		</ul>
		/// 	</Verify> 
		/// </remarks> 
		[TestCase,Ignore]
		public void P_QueryAffiliates_NoLimit_NoTitle_FlagsMatrix()
		{
		}

		/// <summary>
		/// 	QueryAffiliates: Limt result count, no title, flags matrix
		/// </summary>
		/// <remarks>
		///		<Description>
		/// 		<p>
		/// 		This test specifies a limit of 20 for result count and no title limitation.
		/// 		</p>
		///
		/// 		<p>
		/// 		A set of xboxes is created in random title IDs and all of the result 
		/// 		control set users are connected to this set of xboxes. The negative control 
		/// 		set is ignored in this test. The initiator control set are connected to
		/// 		random title xboxes.
		/// 		</p>
		///
		/// 		<p>
		/// 		The result set has a mix of in-session and out of session using the 
		/// 		set title data calls.
		/// 		</p>
		/// 	</Description>
		/// 	<Verify>
		/// 		<ul>
		/// 			<li>For each initiator validate the result set using their user notation flags.</li>
		/// 			<ul>
		/// 			<li>Validate each affiliate result - AffiliateId</li>
		/// 			<li>Validate each affiliate result - ListFlags</li>
		/// 			<li>Validate each affiliate result - TitleId</li>
		/// 			<li>Validate each affiliate result - SessionId</li>
		/// 			<li>Validate each affiliate result - DateUpdated</li>
		/// 			<li>Validate each affiliate result - GamerTag</li>
		/// 			</ul>
		/// 		</ul>
		/// 	</Verify> 
		/// </remarks> 
		[TestCase, Ignore]
		public void P_QueryAffiliates_Limit20_NoTitle_FlagsMatrix()
		{
			BuildDataset();

			uint limit = 20;
			uint titleId = 0;
			uint flags;

			// When you specify a limit you can only request one flag at a time
			for(int flagIndex = 0; flagIndex < 32; ++flagIndex)
			{
				flags = (uint)(1 << flagIndex);

				try
				{
					ArrayList IS = GetInitiatorSet(flags);

					PNMsg replyMsg = null;
					PQueryAffiliatesReplyMsgData reply = null;

					foreach(Initiator i in IS)
					{
						// Send the query
						PMsgQueryAffiliates request = new PMsgQueryAffiliates(i.Owner, limit, flags, titleId);
                        request.TransactFD(out replyMsg);
						reply = (PQueryAffiliatesReplyMsgData)replyMsg.Data;

						// Validate the results using the result and negative sets
						foreach(QueryAffiliatesReplyData result in reply.rgResults)
						{
							if(!i.ResultSet.Contains(result.qwAffiliateID))
							{
								throw new UnexpectedTestResultException("Result set does not contain the affiliate ID: " + result.qwAffiliateID.ToString("x"));
							}
							if(i.NegativeSet.Contains(result.qwAffiliateID))
							{
								throw new UnexpectedTestResultException("Result set should not contain the affiliate ID: " + result.qwAffiliateID.ToString("x"));
							}
						}
					}
				}
				catch(HResultException ex)
				{
					_Report.Warn("Failure case: Limit20NoTitleId, Flags: {0:x}HResult: {1:x} ({2}), Message: {3}",
							flags, ex.HR, Global.XErrToString(ex.HR), ex.Message);
				}
			}
		}

		/// <summary>
		/// 	Emulate a social match QueryAffiliates call on the datacenter port
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		<p>
		/// 		This test case uses the parameters of social match to perform a sanity
		/// 		check test query against presence.
		/// 		</p>
		///
		/// 		<p>
		/// 		All of the users from the result control set will be placed into sessions
		/// 		in a specific title ID.
		/// 		</p>
		/// 	</Description>
		/// 	<Verify>
		/// 		<ul>
		/// 		<li>All users returned in query are not in negative list or avoiding me list of initiator.</li>
		/// 		<li>All users returned in query have valid session IDs.</li>
		/// 		<li>All users returned in query have valid title IDs.</li>
		/// 		</ul>
		/// 	</Verify> 
		/// </remarks> 
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_Query_SocialMatch()
		{
			PNUser a = CreateXenonUser(true);
			PNUser b = CreateXenonUser(false);
			PNUser c = CreateXenonUser(false);
			PNUser d = CreateXenonUser(false);

			SleepInfo sleep = new SleepInfo("Waiting for Xcache", 15000);

			// Change titleID for user B, C and D and login
			b.Xbox.ChangeTitle(b.Xbox.TitleId+1, 0, 0);
			c.Xbox.ChangeTitle(c.Xbox.TitleId+1, 0, 0);
			d.Xbox.ChangeTitle(d.Xbox.TitleId+2, 0, 0);
			_fc.LogonUser(b);
			_fc.LogonUser(c);
			_fc.LogonUser(d);

			// Complete 1 game with B 
			AffiliateState state = new AffiliateState(a);
			state.Add(b, (uint)AffiliateFlags.Encountered, b.Xbox.TitleId);
			state.Add(b, (uint)AffiliateFlags.CompletedGame, b.Xbox.TitleId);
			 
			// Only join in session with C
			state.Add(c, (uint)AffiliateFlags.Encountered, c.Xbox.TitleId);

			// Complete game with D (D will stay in it's own title)
			state.Add(d, (uint)AffiliateFlags.Encountered, d.Xbox.TitleId);
			state.Add(d, (uint)AffiliateFlags.CompletedGame, d.Xbox.TitleId);

			Thread.Sleep(2000);

			// Log B and C off and on again with same title Id as A
			// so they can play together
			_fc.LogoffUser(b);
			_fc.LogoffUser(c);
			b.Xbox.ChangeTitle(a.Xbox.TitleId, 0, 0);
			c.Xbox.ChangeTitle(a.Xbox.TitleId, 0, 0);
			_fc.LogonUser(b);
			_fc.LogonUser(c);

			// Pulse session on B, C and D
			b.SetTitleData((ulong)10);
			c.SetTitleData((ulong)20);
			d.SetTitleData((ulong)30);

            Thread.Sleep(3000);

			// Do a social match query on the datacenter port
			PQueryAffiliatesReplyMsgData reply = state.LoadExternal(0 /* no limit */, true, (uint)AffiliateFlags.Any, true);

			// Make sure that only B and C were returned
			//
			// B should be in the list twice and C should be in the list once
			// D should not be in the results 
			ValueCheck.Test("Query result count", 3, reply.cdwResults);
            ValidateAffiliateResult(reply.rgResults[0], c, c.Xbox.TitleId + 1, (uint)AffiliateFlags.Encountered);
            ValidateAffiliateResult(reply.rgResults[1], b, b.Xbox.TitleId+1, (uint)AffiliateFlags.Encountered);
            ValidateAffiliateResult(reply.rgResults[2], b, b.Xbox.TitleId + 1, (uint)AffiliateFlags.CompletedGame);
		}


        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_Query_Dash_Recent_Players()
		{
			PNUser owner = CreateXenonUser(true);
			AffiliateState state = new AffiliateState(owner);
			PNUser u0 = CreateXenonUser(false);
			PNUser u1 = CreateXenonUser(false);

			SleepInfo sleep = new SleepInfo("Waiting for Xcache", 15000);

			u0.Xbox.ChangeTitle(u0.Xbox.TitleId+1, 0, 0);
			u1.Xbox.ChangeTitle(u1.Xbox.TitleId+2, 0, 0);

			_fc.LogonUser(u0);
			_fc.LogonUser(u1);

			// Dash queries will not fan out and get user presence, we will leave
			// the session ID 0 on the user and it will match the return data.
			// u0.SetTitleData((ulong)10);
			// u1.SetTitleData((ulong)11);

			state.Add(u0, (uint)AffiliateFlags.Encountered, owner.Xbox.TitleId);
			Thread.Sleep(2000);

			state.Add(u1, (uint)AffiliateFlags.CompletedGame, owner.Xbox.TitleId);
			Thread.Sleep(2000);


			PQueryAffiliatesReplyMsgData reply = state.LoadExternal(20, false, (uint)AffiliateFlags.Encountered);

			ValueCheck.Test("HResult", HResult.S_OK, reply.hr);
			ValueCheck.Test("Reply length", 2, reply.cdwResults);

			// u1 was added after u0
			ValueCheck.IsTrue(reply.rgResults[1].mtDateUpdated < reply.rgResults[0].mtDateUpdated, "User1.DateUpdated < User0.DateUpdated");
			
			ValidateAffiliateResult(reply.rgResults[0], u1, owner.Xbox.TitleId, (uint)(AffiliateFlags.Encountered|AffiliateFlags.CompletedGame));
			ValidateAffiliateResult(reply.rgResults[1], u0, owner.Xbox.TitleId, (uint)AffiliateFlags.Encountered);
		}

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_Query_CompletedGame_NoPresenceRecord()
		{
            // TODO: what does this mean in the new presence system?

			PNUser a = CreateXenonUser(true);
			PNUser b = CreateXenonUser(true);

			// Add b to user a's affiliate list
			AffiliateState state = new AffiliateState(a);
			state.Add(b, (uint)AffiliateFlags.CompletedGame);

			a.ProcessNotifications();
			b.ProcessNotifications();

			// Make sure that b is not in memory
			_fc.LogoffUser(b);
			//PNServers.SetCacheState(b, CacheState.NotInMemory);

			// Get the results
			PQueryAffiliatesReplyMsgData reply = state.LoadExternal(20, false, (uint)AffiliateFlags.Encountered);

			ValueCheck.Test("HResult", HResult.S_OK, reply.hr);
			ValueCheck.Test("Reply length", 1, reply.cdwResults);
			ValidateAffiliateResult(reply.rgResults[0], b, b.Xbox.TitleId, (uint)(AffiliateFlags.Encountered|AffiliateFlags.CompletedGame));
		}

		/// <summary> 
		/// 	Test querying on cloaked users (special case code path)
		/// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_Query_SocialMatch_CloakedUser()
		{
			PNUser a = CreateXenonUser(true);
			PNUser b = CreateXenonUser(true);
			PNUser c = CreateXenonUser(true);
			PNUser d = CreateXenonUser(true);

			// B sends negative feedback on A
			AffiliateState Bstate = new AffiliateState(b);
			Bstate.Add(a, (uint)AffiliateFlags.Encountered);
			Bstate.Add(a, (uint)AffiliateFlags.NegativeFeedback);

			// C sends positive feedback on A
			AffiliateState Cstate = new AffiliateState(c);
			Cstate.Add(a, (uint)AffiliateFlags.Encountered);
			Cstate.Add(a, (uint)AffiliateFlags.PositiveFeedback);

			// D completes a game and sends negative feedback on A after completing a game
			AffiliateState Dstate = new AffiliateState(d);
			Dstate.Add(a, (uint)AffiliateFlags.CompletedGame);
			Dstate.Add(a, (uint)AffiliateFlags.NegativeFeedback);

			// Cloak A
			a.State |= XonPresNoti.P_STATE_MASK_CLOAKED; 
			a.SetTitleData();

			// Create a new virtual session for A
			a.EnterSession(0xaaaabbbbccccdddd, true);

			Thread.Sleep(10000);

			// Do a social match query on the datacenter port for B, C and D
			PQueryAffiliatesReplyMsgData Breply = Bstate.LoadExternal(0 /* no limit */, true, (uint)AffiliateFlags.Any, true);
			PQueryAffiliatesReplyMsgData Creply = Cstate.LoadExternal(0 /* no limit */, true, (uint)AffiliateFlags.Any, true);
			PQueryAffiliatesReplyMsgData Dreply = Dstate.LoadExternal(0 /* no limit */, true, (uint)AffiliateFlags.Any, true);

			// -- Validate B
			// A should be in the list with negative affiliation
			ValueCheck.Test("Query result count", 1, Breply.cdwResults);
			ValidateAffiliateResult(Breply.rgResults[0], a, a.Xbox.TitleId, (uint)AffiliateFlags.NegativeFeedback);

			// -- Validate C
			// A should be excluded from the list
			ValueCheck.Test("Query result count", 0, Creply.cdwResults);

			// -- Validate D
			// A should be in the list with negative affiliation
			ValueCheck.Test("Query result count", 1, Dreply.cdwResults);
			ValidateAffiliateResult(Dreply.rgResults[0], a, a.Xbox.TitleId, (uint)AffiliateFlags.NegativeFeedback);
		}

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_QueryAffiliates_NoPeerSubscribe()
        {
        	PNUser a = CreateXenonUser(true);
			PNUser b = CreateXenonUser(true);

            try
            {
                Global.XEnv.OverrideSetting("ALL", "ALL", Setting.presence_QueryAffiliatesOkToPeerSubscribe, "0");

                new SleepInfo("Waiting for all servers to be notified of the override.", 60 * 1000 * 5); //polling interval is 5 minutes.

                // Add b to user a's affiliate list
                AffiliateState state = new AffiliateState(a);
                state.Add(b, (uint)AffiliateFlags.CompletedGame);

                PQueryAffiliatesReplyMsgData reply = state.LoadExternal(0 /* no limit */, true, (uint)AffiliateFlags.Any, true);

                ValueCheck.TestHR("Query affiliates hresult", HResult.XONLINE_S_NOTIFICATION_NO_PEER_SUBSCRIBE, reply.hr); 
            }
            finally
            {
                Global.XEnv.DeleteOverrideSetting("ALL", "ALL", Setting.presence_QueryAffiliatesOkToPeerSubscribe);
                new SleepInfo("Waiting for all servers to be notified of the removed overrride.", 60 * 1000 * 5); //polling interval is 5 minutes.
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_QueryAffiliates_Web()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(true);

            AffiliateState state = new AffiliateState(a);
            state.Add(b, (uint)AffiliateFlags.CompletedGame);

            _fc.LogoffUser(a);
            Thread.Sleep(3000);

            a.WebAlive();
            PQueryAffiliatesReplyMsgData reply = state.LoadExternal(0 /* no limit */, true, (uint)AffiliateFlags.Any, true);
            ValueCheck.TestHR("Query affiliates hresult", HResult.S_OK, reply.hr); 
        }
	}

	/// <summary>
	/// 	Negative Functional Tests for QueryAffiliates
	/// </summary>
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3)]
	public class FuncQueryAffiliates_NegativeCases : PresenceTestBaseGroup
	{
		PNUser         _Valid;
		PNUser         _Zero;

		public override void Setup()
		{
            base.Setup();

			// Create a valid user to use for invalid requests
			PNXbox zeroXbox = new PNXbox();
			_Zero = new PNUser("Invalid", 0);
			_Zero.Xbox = zeroXbox;
            _alUsers.Add(_Zero);

			_Valid = CreateXenonUser(true);
		}

		void SendInvalidQuery(uint expectedHR, PNUser u, uint cdwLimit, uint dwFlags, uint dwOnlineTitleId, bool dataCenter)
		{
			PMsgQueryAffiliates msg = new PMsgQueryAffiliates(u, 
					20/*limit*/, 
					(uint)AffiliateFlags.Encountered, 
					0/*online titleid*/);

			if(true == dataCenter)
			{
				msg.AuthMethod  = PNRequestMsg.FDAuth.HttpHdr;
				msg.PortOnFD    = PNRequestMsg.FDPort.PresNoti_DC;
			}

			uint caughtHR = HResult.S_OK;
			PNMsg rep = null;

			try
			{
                msg.TransactFD(out rep);
			}
			catch(XErrException ex)
			{
				caughtHR = ex.XErr;
			}
			
			if(HResult.S_OK == caughtHR)
			{
				PQueryAffiliatesReplyMsgData data = (PQueryAffiliatesReplyMsgData)rep.Data;
				caughtHR = data.hr;
			}

			if(caughtHR != expectedHR)
			{
				throw new HResultException(caughtHR, "Expected " + Global.XErrToString(expectedHR) + " HRESULT from query affilliates");
			}
		}

		/// <summary>
		/// 	Sender ID is not in presence user cache
		/// </summary>
		/// <remarks>
		/// <Description>
		/// 	Send affiliates query with user ID set to a user who is valid
		/// 	but is not alive in any way. This request is sent to both 
		/// 	internet and datacenter ports.
		/// </Description>
		/// <Verify>
		/// 	HRESULT equal to XONLINE_E_SERVER_ERROR.
		/// </Verify>
		/// </remarks>
		[TestCase]
		public void N_QueryAffiliates_User_Not_Online()
		{
            //TODO: what does not in memory mean in the new presence system?

			PNUser offline = CreateXenonUser(true);
			offline.ProcessNotifications();
			_fc.LogoffUser(offline);
			Thread.Sleep(3000);
			//PNServers.SetCacheState(offline, CacheState.NotInMemory);

			SendInvalidQuery(HResult.XONLINE_E_NOTIFICATION_INVALID_PUID, offline, 20, (uint)AffiliateFlags.Encountered, 0, false);
		}


		/// <summary>
		/// 	Sender ID zero
		/// </summary>
		/// <remarks>
		/// <Description>
		/// 	Send affiliates query with user ID set to zero. This request
		/// 	is sent to both internet and datacenter ports.
		/// </Description>
		/// <Verify>
        /// 	HRESULT equal to E_INVALIDARG
		/// </Verify>
		/// </remarks>
		[TestCase]
		public void N_QueryAffiliates_Sender_Id_Zero()
		{
			SendInvalidQuery(HResult.E_INVALIDARG, _Zero, 20, (uint)AffiliateFlags.Encountered, 0, false);
			SendInvalidQuery(HResult.E_INVALIDARG, _Zero, 20, (uint)AffiliateFlags.Encountered, 0, false);
		}

		/// <summary>
		/// 	Query affiliates on the mute list
		/// </summary>
		/// <remarks>
		/// <Description>
		/// 	The mute list is not accessable via a specific query. Try to access it.
		/// </Description>
		/// <Verify>
		/// 	HRESULT equals E_INVALIDARG.
		/// </Verify>
		/// </remarks>
		[TestCase,Ignore]
		public void N_QueryAffiliates_Mute_List()
		{
			SendInvalidQuery(HResult.E_INVALIDARG, _Valid, 0, (uint)AffiliateFlags.Mute, 0, false);
			SendInvalidQuery(HResult.E_INVALIDARG, _Valid, 0, (uint)AffiliateFlags.Mute, 0, true);
		}
		
		/// <summary>
		/// 	Query affiliates on the block list
		/// </summary>
		/// <remarks>
		/// <Description>
		/// 	The block list is not accessable via query.
		/// </Description>
		/// <Verify>
		/// 	HRESULT equald E_INVALIDARG.
		/// </Verify>
		/// </remarks>
		[TestCase,Ignore]
		public void N_QueryAffiliates_Block_List()
		{
			SendInvalidQuery(HResult.E_INVALIDARG, _Valid, 0, (uint)AffiliateFlags.Block, 0, false);
			SendInvalidQuery(HResult.E_INVALIDARG, _Valid, 0, (uint)AffiliateFlags.Block, 0, true);
		}

		/// <summary>
		/// 	Query for affiliates without specifying a valid SG address in ticket
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		Specify a zero SG addr on the internet port of FD.
		/// 	</Description>
		/// 	<Verify>
		/// 		HRESULT equal to XONLINE_E_SERVER_ERROR
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_QueryAffiliates_Zero_SGAddr()
		{
			PMsgQueryAffiliates req = new PMsgQueryAffiliates(_Valid, 20, (uint)AffiliateFlags.Encountered, 0);
			PNMsg rep;
			req.Msg.Hdr.Sgaddr = new SGADDR();

			try
			{
                req.TransactFD(out rep);
			}
			catch(XErrException ex)
			{
                //Now when we connect to presence, we first connect to xconnsrv, which throws this error.
                ValueCheck.TestHR("Query affilaites negative HR", xonline.common.service.HResult.XONLINE_E_SERVER_ERROR, ex.XErr);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncWebFriends.cs ===
using System; using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserAccount;

using xonline.common.protocol;

namespace PresenceTest
{
	/// <summary>
	/// Functional Tests for WebFriends
	/// </summary>
    [TestGroup, TestFrequency("Daily"), TestCasePriority(2), AsyncGroup(1, 0)]
    public class FuncWebFriends : PresenceTestBaseGroup
	{

        static Report ro = new Report("WebFriends");

		[TestCase]
		public void N_Invalid_UserId()
		{
			// Do a bunch of busy work to register this invalid stuff with the fake SG
			PNUser invalid = new PNUser("Invalid", 0x4d2);
			PNXbox xbox = new PNXbox(FriendsCommon.DefaultXenonTitleId, XboxVersion.FEB_2005_ALPHA_XEDK);
			invalid.Connect(xbox);

			PNMsg replyMsg;
            PMsgWebFriends webFriendMsg = new PMsgWebFriends(invalid);
            webFriendMsg.TransactFD(out replyMsg);
            PWebFriendReplyMsgData replyData = (PWebFriendReplyMsgData) replyMsg.Data;

            if( replyData.HR != HResult.E_NO_SUCH_USER)
			{
                throw new HResultException( replyData.HR, "Get Web Friends unexpected HR = 0x"+Global.XErrToString(replyData.HR));
			}
		}

		/// <summary>
		/// 	Request web friends data for a user who has been peer subscribed while offline
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_WebFriends_After_PeerSubscribed()
        {
            PNUser a, b, c;

            // Create some clean users who are friends
            b = CreateXenonUser(true);
            c = CreateXenonUser(true);
            _fc.MakeFriend(b, c);


            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            b.ProcessNotifications();
            c.ProcessNotifications();
            _fc.LogoffUser(b);
            _fc.LogoffUser(c);

            // Create a new user 
            a = CreateXenonUser(true);

            ro.Info("Requesting peer presence for user B...");

            // Peer subscribe to b
            a.AddPeerSubscription(b);
            
            ro.Info("Getting web friends for user B...");

            // Get user B web friends, make sure he sees web friends
            PWebFriendReplyMsgData replyData = b.GetWebFriends();
            ValueCheck.Test("Friend count", (ushort)(replyData.cdwFriends), (ushort)1);
        }

		/// <summary>
		/// 	Request web friends data for a friend who is online
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_WebFriends_After_FriendOnline()
        {
            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);
            _fc.MakeFriend(a, b);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            // Logon
            ro.Debug("Logging in with user A...");
            _fc.LogonUser(a);

            // Get web friends
            ro.Debug("Getting web friends for user B...");

            // Get user B web friends, make sure he sees web friends
            PWebFriendReplyMsgData replyData = b.GetWebFriends();
            ValueCheck.Test("Friend count", (ushort)(replyData.cdwFriends), (ushort)1);
        }

                
   		/// <summary>
		/// 	Request web friends data for a friend who is online
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        protected void SetPrivilege(PNUser user, uint priv, bool grant)
        {
            // Create a grant request
            XRLXeUpdateParentalControls request = new XRLXeUpdateParentalControls();
            request.UserPuid = user.UserId;
            request.Source = "STF-PRES-FPC";

            UserPrivileges grants = new UserPrivileges();
            UserPrivileges restrictions = new UserPrivileges();

            // Populate the new requested privilege
            if (grant)
            {
                grants[(int)priv] = true;
            }
            else
            {
                restrictions[(int)priv] = true;
            }

            request.UserGrantPrivileges = grants.ToArray();
            request.UserRestrictPrivileges = restrictions.ToArray();
            request.ExecuteSafe();

            Thread.Sleep(5000);
        }

        [TestCase]
        public void P_WebFriends_Friend_List_Blocked()
        {
            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);
            _fc.MakeFriend(a, b);

            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();

            // Logon
            ro.Debug("Logging in with user A...");
            _fc.LogonUser(a);

            // set privileges
            SetPrivilege(b, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST, false);
            SetPrivilege(b, xonline.common.service.XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY, false);

            // Get web friends
            ro.Debug("Getting web friends for user B...");

            // Get user B web friends, make sure he sees web friends
            PWebFriendReplyMsgData replyData = b.GetWebFriends();
            ValueCheck.Test("Friend count", (ushort)(replyData.cdwFriends), (ushort)1);
        }

		/// <summary>
		/// Force a load offline presence for a user who has been forced completely out of memory
		/// </summary>
		[TestCase]
		public void P_WebFriends_1_NotInMemory()
		{
			PNUser a, b;
			a = CreateXenonUser(true);
			b = CreateXenonUser(true);

			_fc.MakeFriend(a, b);
			_fc.LogoffUser(b);

            // TODO: what does not in memory mean in the new presence system?

			//PNServers.SetCacheState(b, CacheState.NotInMemory);

			PWebFriendReplyMsgData replyData = a.GetWebFriends();
			ValueCheck.Test("Friend count", (ushort)1, (ushort)(replyData.cdwFriends));
		}
		
		/// <summary>
		/// 	Request a large block of web friends
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase]
        public void P_WebFriends_4_In_Cache_4_No_Cache()
        {
            PNUser[] users = new PNUser[8];
            PMsgWebFriends request;
            PNMsg replyMsg;

            for (int i = 0; i < 8; ++i)
            {
                users[i] = CreateXenonUser(true);
            }
            for (int i = 0; i < 8; ++i)
            {
                for (int j = 0; j < 8; ++j)
                {
                    if (i != j)
                    {
                        ro.Debug("Making friends: " +
                                users[i].UserId.ToString("x") + ", " +
                                users[j].UserId.ToString("x"));
                        _fc.MakeFriend(users[i], users[j]);
                    }
                }
            }

            ro.Debug("Logging off 4 users...");
            Thread.Sleep(5000);
            for (int i = 0; i < 8; i += 2)
            {
                _fc.LogoffUser(users[i]);
                users[i].ProcessNotifications();
            }

            for (int i = 0; i < 8; ++i)
            {
                ro.Debug("Requesting web friends for: " + users[i].UserId.ToString("x"));

                request = new PMsgWebFriends(users[i]);
                request.TransactFD(out replyMsg);
                PWebFriendReplyMsgData replyData = (PWebFriendReplyMsgData)replyMsg.Data;

                // Check out message summary
                if (replyData.HR != HResult.S_OK)
                    throw new UnexpectedTestResultException(
                        "Error in web friend reply, HR: 0x" + replyData.HR.ToString("X8"));

                ValueCheck.Test("Web friends count", (ushort)replyData.cdwFriends, (ushort)users.Length - 1);
            }
        }

		/// <summary>
		/// 	Spam the webfriends call to check for memory leaks.	
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, Ignore]
        public void WebGetFriends_Spam()
        {
            PMsgWebFriends request;
            PNMsg replyMsg;
            int desiredUsers = 20;
            int friendsPerUser = 5;
            PNUser[] users = new PNUser[desiredUsers];

            for (int i = 0; i < desiredUsers; ++i)
            {
                users[i] = CreateXenonUser(true);
            }
            for (int i = 0; i < desiredUsers; ++i)
            {

                int friendCount = friendsPerUser;
                int j = i + 1;
                while (friendCount > 0)
                {
                    for (; friendCount > 0 && j < desiredUsers; ++j)
                    {
                        if (i != j)
                        {
                            ro.Debug("Making friends: " +
                                    users[i].UserId.ToString("x") + ", " +
                                    users[j].UserId.ToString("x"));
                            try
                            {
                                _fc.MakeFriend(users[i], users[j]);
                                friendCount--;
                            }
                            catch (Exception ex)
                            {
                                ro.Warn("Caught error makings friends for user: " + users[i].UserId + ": " + ex.Message);
                            }
                        }
                    }
                    j = 0;
                }
            }

            uint failureCount = 0;
            uint passCount = 0;

            while (failureCount == 0)
            {
                //ro.Debug("WebFriends Burst " + runs);
                for (int j = 0; j < users.Length; ++j)
                {
                    if (!users[j].LoggedOn)
                        users[j].Alive();

                    request = new PMsgWebFriends(users[j]);
                    request.TransactFD(out replyMsg);
                    PWebFriendReplyMsgData replyData = (PWebFriendReplyMsgData)replyMsg.Data;

                    // Check out message summary
                    if (replyData.HR != HResult.S_OK)
                    {
                        ro.Error("Error in web friend reply, HR: 0x" + replyData.HR.ToString("X8"));
                    }

                    // Check online/offline friend counts
                    if (replyData.cdwFriends == 0)
                    {
                        ro.Error("PUID: " + users[j].UserId + " cdwFriends " + replyData.cdwFriends + " != FriendsPerUser " + friendsPerUser);

                        // Recheck our web friends
                        //
                        request.TransactFD(out replyMsg);
                        replyData = (PWebFriendReplyMsgData)replyMsg.Data;
                        if (replyData.HR == HResult.S_OK && replyData.cdwFriends == 0)
                        {
                            failureCount++;
                        }
                        else
                        {
                            ro.Debug("PUID: " + users[j].UserId + " had friends on refresh");
                        }
                    }
                    else
                    {
                        passCount++;
                    }


                    replyMsg = null;
                }

                ro.Debug("PassCount: " + passCount + ", FailureCount: " + failureCount);
                ro.Debug("Sleeping for 5 minutes to give xqserver time to cleanup webuser records, check xpnconfig.ini for timeouts");

                // long inactivity to allow presence to cleanup the web friends
                Thread.Sleep(1000 * 60 * 5); // sleep for 5 minutes 
            }
        }


		// Make sure that when you request web friends your last seen is not updated
		[TestCase]
		public void P_WebFriends_LastSeen_NotUpdated()
		{
			PNUser a = CreateXenonUser(true);
			PNUser b = CreateXenonUser(true);
			_fc.MakeFriend(a, b);	

            ro.Info("Cloaking user B");
			b.SetTitleData((uint)XonPresNoti.P_STATE_MASK_ONLINE|XonPresNoti.P_STATE_MASK_CLOAKED);
			// Get the cloaked state pulse 
            UserNotification noti = a.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
			a.HandleTCPNotification(noti);;

            ro.Info("Got cloaked (offline) presence for user B");

			// Get the buddy state time for B
			uint lastSeenTime = a.GetBuddyInfo(b.UserId).BasicPresenceData.mtLastSeen;
            uint lastSeenTitle = a.GetBuddyInfo(b.UserId).BasicPresenceData.TitleId;
            uint lastSeenState = a.GetBuddyInfo(b.UserId).BasicPresenceData.State;

			// Give some lag time
			Thread.Sleep(5000);


            ro.Info("Retreiving web friends for user B");

			// Request web friends (should not update last seen title or time)
			PWebFriendReplyMsgData wfd = b.GetWebFriends();

            ro.Info("Pulsing state data");

			// Pulse state again (just title bytes)
			b.SetTitleData(new byte[]{0x1, 0x2, 0x3, 0x4});

            foreach (WebFriend wf in wfd.rgFriends)
            {
                if (wf.BuddyID == b.UserId)
                {
                    ValueCheck.Test("LastSeen(Time)",  lastSeenTime,  wf.mtLastActive);
                    ValueCheck.Test("LastSeen(Title)", lastSeenTitle, wf.TitleID);
                    ValueCheck.Test("LastSeen(State)", lastSeenState, wf.OnlineState);
                    return;
                }
            }
		}

		[TestCase]
		public void P_WebFriends_OnlineFriends()
		{
            UserNotification noti = null;
			// Create our test users
			PNUser u = CreateXenonUser(false);
			PNUser online = CreateXenonUser(true);
			PNUser offline = CreateXenonUser(true);
			PNUser cloaked = CreateXenonUser(true);
            PNUser online_playing = CreateXenonUser(true);
            PNUser online_playing_voice = CreateXenonUser(true);
            PNUser online_playing_joinable = CreateXenonUser(true);
            PNUser online_playing_voice_joinable = CreateXenonUser(true);
            PNUser online_voice = CreateXenonUser(true);
            PNUser online_guests = CreateXenonUser(true);
            PNUser online_voice_guests = CreateXenonUser(true);
            PNUser online_joinable_guests = CreateXenonUser(true);
            PNUser online_playing_guests = CreateXenonUser(true);
            PNUser online_playing_voice_guests = CreateXenonUser(true);
            PNUser online_playing_voice_joinable_guests = CreateXenonUser(true);
            PNUser online_playing_joinable_guests = CreateXenonUser(true);

			u.Xbox.ChangeTitle(u.Xbox.TitleId+1, 0, 0);
			_fc.LogonUser(u);

			// Link the friends
			_fc.MakeFriend(u, online);
			_fc.MakeFriend(u, offline);
			_fc.MakeFriend(u, cloaked);
            _fc.MakeFriend(u, online_playing);
            _fc.MakeFriend(u, online_playing_voice);
            _fc.MakeFriend(u, online_playing_joinable);
            _fc.MakeFriend(u, online_playing_voice_joinable);
            _fc.MakeFriend(u, online_voice);
            _fc.MakeFriend(u, online_guests);
            _fc.MakeFriend(u, online_voice_guests);
            _fc.MakeFriend(u, online_joinable_guests);
            _fc.MakeFriend(u, online_playing_guests);
            _fc.MakeFriend(u, online_playing_voice_guests);
            _fc.MakeFriend(u, online_playing_voice_joinable_guests);
            _fc.MakeFriend(u, online_playing_joinable_guests);

			//
			// Setup proper states 
			//

            new SleepInfo("Waiting for state updates to complete", 2000);
            u.ProcessNotifications();
			
			_fc.LogoffUser(offline);
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);;

			cloaked.State |= XonPresNoti.P_STATE_MASK_CLOAKED;
			cloaked.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);;

            online_playing.State |= XonPresNoti.P_STATE_MASK_PLAYING;
            online_playing.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);;

            online_playing_voice.State |= XonPresNoti.P_STATE_MASK_PLAYING | XonPresNoti.P_STATE_MASK_VOICE;
            online_playing_voice.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);;

            online_playing_joinable.State |= XonPresNoti.P_STATE_MASK_PLAYING | XonPresNoti.P_STATE_MASK_JOINABLE;
            online_playing_joinable.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);;

            online_playing_voice_joinable.State |= XonPresNoti.P_STATE_MASK_PLAYING | XonPresNoti.P_STATE_MASK_VOICE | XonPresNoti.P_STATE_MASK_JOINABLE;
            online_playing_voice_joinable.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);;

            online_voice.State |= XonPresNoti.P_STATE_MASK_VOICE;
            online_voice.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);;

            online_guests.State |= XonPresNoti.P_STATE_MASK_GUESTS;
            online_guests.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);;

            online_voice_guests.State |= XonPresNoti.P_STATE_MASK_VOICE | XonPresNoti.P_STATE_MASK_GUESTS;
            online_voice_guests.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);;

            online_joinable_guests.State |= XonPresNoti.P_STATE_MASK_JOINABLE | XonPresNoti.P_STATE_MASK_GUESTS;
            online_joinable_guests.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);;

            online_playing_guests.State |= XonPresNoti.P_STATE_MASK_PLAYING;
            online_playing_guests.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);;

            online_playing_voice_guests.State |= XonPresNoti.P_STATE_MASK_PLAYING | XonPresNoti.P_STATE_MASK_VOICE | XonPresNoti.P_STATE_MASK_GUESTS;
            online_playing_voice_guests.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);;

            online_playing_voice_joinable_guests.State |= XonPresNoti.P_STATE_MASK_PLAYING | XonPresNoti.P_STATE_MASK_VOICE | XonPresNoti.P_STATE_MASK_JOINABLE | XonPresNoti.P_STATE_MASK_GUESTS;
            online_playing_voice_joinable_guests.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);;

            online_playing_joinable_guests.State |= XonPresNoti.P_STATE_MASK_PLAYING | XonPresNoti.P_STATE_MASK_JOINABLE | XonPresNoti.P_STATE_MASK_GUESTS;
            online_playing_joinable_guests.SetTitleData();
            Thread.Sleep(2000);
            noti = u.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            u.HandleTCPNotification(noti);;


			new SleepInfo("Waiting for state updates to complete", 2000);
			u.ProcessNotifications();


			// Validate
			PWebFriendReplyMsgData wfd = u.GetWebFriends();
			ValidateBuddyWebData(u.GetBuddyInfo(online.UserId), wfd);
			ValidateBuddyWebData(u.GetBuddyInfo(offline.UserId), wfd);
			ValidateBuddyWebData(u.GetBuddyInfo(cloaked.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_playing.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_playing_voice.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_playing_joinable.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_playing_voice_joinable.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_voice.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_guests.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_voice_guests.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_joinable_guests.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_playing_guests.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_playing_voice_guests.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_playing_voice_joinable_guests.UserId), wfd);
            ValidateBuddyWebData(u.GetBuddyInfo(online_playing_joinable_guests.UserId), wfd);
		}

		void ValidateBuddyWebData(PNUser.BuddyInfo info, PWebFriendReplyMsgData wfd)
		{
			ValueCheck.TestNotNull("BuddyInfo", info);
			ValueCheck.TestNotNull("BuddyInfo.RichPresence", info.RichPresenceData);

			uint i;
			for(i = 0; i < wfd.cdwFriends; ++i)
			{
				WebFriend wf = wfd.rgFriends[i];
				if(wf.BuddyID == info.User.UserId)
				{
					PNUser user = info.User;
					ValueCheck.Test("User(" + user.UserId.ToString("x") + ").GamerTag", info.Name, wf.szGamerTag);
					if(0 == (wf.OnlineState & XonPresNoti.P_STATE_MASK_CLOAKED))
					{
                        ValueCheck.Test("User(" + user.UserId.ToString("x") + ").OnlineState", info.BasicPresenceData.State, wf.OnlineState);
					}
					else
					{
                        ValueCheck.Test("User(" + user.UserId.ToString("x") + ").RichPresence.State", 0, info.BasicPresenceData.State);
                        ValueCheck.Test("User(" + user.UserId.ToString("x") + ").OnlineState", user.State, wf.OnlineState);
					}

                    ValueCheck.Test("User(" + user.UserId.ToString("x") + ").TitleId", info.BasicPresenceData.TitleId, wf.TitleID);
					// TODO-jacobr: validate rich presence string data
					break;
				}
			}

			if(i == wfd.cdwFriends)
			{
				throw new UnexpectedTestResultException("User: " + info.User.UserId.ToString("x") + " not found in web friends data");
			}
		}

        [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
		public void P_WebFriends_Max_OfflineFriends_MixStatus()
		{
			uint friendCount = 100;
			PNUser u = CreateXenonUser(true);
			PNUser []friends = new PNUser[friendCount];
            QValPacket qval = null;

			ProgressInfo progress = new ProgressInfo("Setting up mixed friends", friendCount, 1);
			for(int i = 0; i < friendCount; ++i)
			{
				friends[i] = CreateXenonUser(true);
				switch(i % 3)
				{
				case 0:
					_fc.MakeFriend(u, friends[i]);
					break;

				case 1:
					u.AddBuddy(friends[i]);
                    qval = friends[i].WaitForQFlags(XonPresNoti.QFLAG_MASK_BUDDY_REQ);
                    friends[i].HandleQValPacket(qval);

                    qval = u.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
                    u.HandleQValPacket(qval);
					break;

				case 2:
					friends[i].AddBuddy(u);
                    qval = u.WaitForQFlags(XonPresNoti.QFLAG_MASK_BUDDY_REQ);
                    u.HandleQValPacket(qval);

                    qval = friends[i].WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
                    friends[i].HandleQValPacket(qval);
					break;

				}
				progress.Step();
			}
			progress.Finish();

			PWebFriendReplyMsgData data = null;

			// Log off users
			foreach(PNUser f in friends)
			{
				_fc.LogoffUser(f);
			
				// Dequeue any pending qval data for full friends
				u.ProcessQVals();
			}
			
			data = u.GetWebFriends();
			ValueCheck.TestHR("Reply.HR", HResult.S_OK, data.HR);
			ValueCheck.Test("Reply.UserID", u.UserId, data.UserID);
			ValueCheck.Test("Reply.cdwFriends", (uint)data.rgFriends.Length, data.cdwFriends);
			ValueCheck.Test("Reply.cdwFriends == friendCount", (uint)friendCount, (uint)data.rgFriends.Length);

			// Validate user friends
		
			ro.Info("Starting forward validation pass");

			uint pass = 0;
			uint fail = 0;
			
			for(int i = 0; i < friends.Length; ++i)
			{
				PNUser f = friends[i];
				WebFriend wf = data.rgFriends[i];

				try
				{
					// Compare buddy status
					PNUser.BuddyInfo bi = u.GetBuddyInfo(wf.BuddyID);
					ValueCheck.Test("WebFriend.Status", bi.Status, wf.Status);

					/*
					 * This won't work since the user is being loaded clean
					 *
					if(bi.Status == XonPresNoti.P_BUDDY_STATUS_OK)
					{
						ValueCheck.TestNotNull("BuddyInfo.RichPresence", bi.RichPresence);
						ValueCheck.Test("WebFriend.State", bi.RichPresence.State, wf.OnlineState);
						ValueCheck.Test("WebFriend.TitleID", bi.RichPresence.TitleID, wf.TitleID);
					}
					*/

					pass++;
				} 
				catch(ExpectedValueCheckException ex)
				{
					ro.Error("Value check exception: " + ex.Message);
					fail++;
				}
			}

			ro.Info("Finished forward validation passed: {0}, failed: {1}", pass, fail);


			ro.Info("Starting reverse validation pass");

			// Validate reverse associations
			foreach(PNUser f in friends)
			{
				
				data = f.GetWebFriends();

				// Validate 
				ValueCheck.TestHR("ReverseReply.HR", HResult.S_OK, data.HR);
				ValueCheck.Test("ReverseReply.UserID", f.UserId, data.UserID);
				ValueCheck.Test("ReverseReply.cdwFriends == 1", (uint)1, (uint)data.rgFriends.Length);


				// Logon friend, populating their pnuser state
				_fc.LogonUser(f);

				// Compare online vs. web presence
				ValueCheck.Test("ReverseWebFriend.BuddyID", u.UserId, data.rgFriends[0].BuddyID);
				ValueCheck.TestNotNull("ReverseWebFriend.rgFriends[0]", data.rgFriends[0]);
				ValueCheck.TestNotNull("ReverseWebFriend.GetBuddyInfo()", f.GetBuddyInfo(u.UserId));
				ValueCheck.Test("ReverseWebFriend.Status", f.GetBuddyInfo(u.UserId).Status, data.rgFriends[0].Status);
				ValueCheck.Test("ReverseWebFriend.OnlineState", u.State, data.rgFriends[0].OnlineState);
				ValueCheck.Test("ReverseWebFriend.TitleID", u.Xbox.TitleId, data.rgFriends[0].TitleID);
			}
		}

		[TestCase]
		public void P_WebFriends_BuddyStatus_Requested()
		{
			PNUser u = CreateXenonUser(true);
			PNUser f = CreateXenonUser(true);

			u.AddBuddy(f);
            QValPacket qval = f.WaitForQFlags(XonPresNoti.QFLAG_MASK_BUDDY_REQ);
            f.HandleQValPacket(qval);

			PWebFriendReplyMsgData data = f.GetWebFriends();
			ValueCheck.TestHR("Reply.HR", HResult.S_OK, data.HR);
			ValueCheck.Test("Reply.UserID", f.UserId, data.UserID);
			ValueCheck.Test("Reply.cdwFriends", 1, data.cdwFriends);
			ValueCheck.Test("Reply.WF[0].Status", XonPresNoti.P_BUDDY_STATUS_REQUEST, data.rgFriends[0].Status);
		}

		[TestCase]
		public void P_WebFriends_BuddyStatus_Pending()
		{
			PNUser u = CreateXenonUser(true);
			PNUser f = CreateXenonUser(true);

			u.AddBuddy(f);
            QValPacket qval = f.WaitForQFlags(XonPresNoti.QFLAG_MASK_BUDDY_REQ);
            f.HandleQValPacket(qval);

			PWebFriendReplyMsgData data = u.GetWebFriends();
			ValueCheck.TestHR("Reply.HR", HResult.S_OK, data.HR);
			ValueCheck.Test("Reply.UserID", u.UserId, data.UserID);
			ValueCheck.Test("Reply.cdwFriends", 1, data.cdwFriends);
			ValueCheck.Test("Reply.WF[0].Status", XonPresNoti.P_BUDDY_STATUS_PENDING, data.rgFriends[0].Status);
		}

		[TestCase]
		public void P_WebFriends_BuddyStatus_Okay()
		{
			PNUser u = CreateXenonUser(true);
			PNUser f = CreateXenonUser(true);

			_fc.MakeFriend(u, f);

			PWebFriendReplyMsgData data = f.GetWebFriends();
			ValueCheck.TestHR("Reply.HR", HResult.S_OK, data.HR);
			ValueCheck.Test("Reply.UserID", f.UserId, data.UserID);
			ValueCheck.Test("Reply.cdwFriends", 1, data.cdwFriends);
			ValueCheck.Test("Reply.WF[0].Status", XonPresNoti.P_BUDDY_STATUS_OK, data.rgFriends[0].Status);
		}

		[TestCase]
		public void P_WebFriends_StateBits()
		{
			PNUser u = CreateXenonUser(true);
			PNUser f = CreateXenonUser(true);
			PNUser f_playing = CreateXenonUser(true);
			PNUser f_voice = CreateXenonUser(true);
			PNUser f_joinable = CreateXenonUser(true);
			PNUser f_joinable_playing = CreateXenonUser(true);
			PNUser f_cloaked = CreateXenonUser(true);

			_fc.MakeFriend(u, f);
			_fc.MakeFriend(u, f_playing);
			_fc.MakeFriend(u, f_voice);
			_fc.MakeFriend(u, f_joinable);
			_fc.MakeFriend(u, f_joinable_playing);
			_fc.MakeFriend(u, f_cloaked);

			f_playing.State |= XonPresNoti.P_STATE_MASK_PLAYING;
			f_voice.State |= XonPresNoti.P_STATE_MASK_VOICE;
			f_joinable.State |= XonPresNoti.P_STATE_MASK_JOINABLE;
			f_joinable_playing.State |= XonPresNoti.P_STATE_MASK_JOINABLE|XonPresNoti.P_STATE_MASK_PLAYING;
			f_cloaked.State |= XonPresNoti.P_STATE_MASK_CLOAKED;

			f_playing.SetTitleData();
			f_voice.SetTitleData();
			f_joinable.SetTitleData();
			f_joinable_playing.SetTitleData();
			f_cloaked.SetTitleData();

            new SleepInfo("Waiting for states to be updated", 5 * 1000);

			PWebFriendReplyMsgData data = u.GetWebFriends();
			ValueCheck.TestHR("Reply.HR", HResult.S_OK, data.HR);
			ValueCheck.Test("Reply.UserID", u.UserId, data.UserID);
			ValueCheck.Test("Reply.cdwFriends", 6, data.cdwFriends);

			ValueCheck.Test("Reply.WF[0].Status", XonPresNoti.P_BUDDY_STATUS_OK, data.rgFriends[0].Status);
			ValueCheck.Test("Reply.WF[1].Status", XonPresNoti.P_BUDDY_STATUS_OK, data.rgFriends[1].Status);
			ValueCheck.Test("Reply.WF[2].Status", XonPresNoti.P_BUDDY_STATUS_OK, data.rgFriends[2].Status);
			ValueCheck.Test("Reply.WF[3].Status", XonPresNoti.P_BUDDY_STATUS_OK, data.rgFriends[3].Status);
			ValueCheck.Test("Reply.WF[4].Status", XonPresNoti.P_BUDDY_STATUS_OK, data.rgFriends[4].Status);
			ValueCheck.Test("Reply.WF[5].Status", XonPresNoti.P_BUDDY_STATUS_OK, data.rgFriends[5].Status);

            ValidateWebFriendState(data.rgFriends, f.UserId, XonPresNoti.P_STATE_MASK_ONLINE | XonPresNoti.P_STATE_ENUM_CONSOLE_XENON);
            ValidateWebFriendState(data.rgFriends, f_playing.UserId, XonPresNoti.P_STATE_MASK_ONLINE | XonPresNoti.P_STATE_MASK_PLAYING | XonPresNoti.P_STATE_ENUM_CONSOLE_XENON);
            ValidateWebFriendState(data.rgFriends, f_voice.UserId, XonPresNoti.P_STATE_MASK_ONLINE | XonPresNoti.P_STATE_MASK_VOICE | XonPresNoti.P_STATE_ENUM_CONSOLE_XENON);
            ValidateWebFriendState(data.rgFriends, f_joinable.UserId, XonPresNoti.P_STATE_MASK_ONLINE | XonPresNoti.P_STATE_MASK_JOINABLE | XonPresNoti.P_STATE_ENUM_CONSOLE_XENON);
            ValidateWebFriendState(data.rgFriends, f_joinable_playing.UserId, XonPresNoti.P_STATE_MASK_ONLINE | XonPresNoti.P_STATE_MASK_JOINABLE | XonPresNoti.P_STATE_MASK_PLAYING | XonPresNoti.P_STATE_ENUM_CONSOLE_XENON);
            ValidateWebFriendState(data.rgFriends, f_cloaked.UserId, XonPresNoti.P_STATE_MASK_ONLINE | XonPresNoti.P_STATE_MASK_CLOAKED | XonPresNoti.P_STATE_ENUM_CONSOLE_XENON);
		}

		void ValidateWebFriendState(WebFriend []rgFriends, ulong userId, uint state)
		{
			bool found = false;

			foreach(WebFriend wf in rgFriends)
			{
				if(wf.BuddyID == userId)
				{
				    if ((state & XonPresNoti.P_STATE_MASK_CLOAKED) == XonPresNoti.P_STATE_MASK_CLOAKED)
				    {
				        ValueCheck.Test("WF.OnlineState", XonPresNoti.P_STATE_MASK_NONE, wf.OnlineState);
				    }
				    else
				    {
    				    ValueCheck.Test("WF.OnlineState", state, wf.OnlineState);
    				}
					found = true;
					break;    
				}
			}

			if(!found)
			{
				throw new UnexpectedTestResultException("Could not find UserId: " + userId.ToString("x") + " in web friends list");
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncNeverList.cs ===
﻿using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.protocol;
using xonline.common.service;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.stfutil;
using xonline.common.community;

namespace PresenceTest
{
    /// <summary>
    /// Functional Tests for Block
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), TestFrequency("BVT"), TestCasePriority(1)]
    public class FuncNeverList_PositiveCases : BlockTestBaseGroup
    {
        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public void P_NeverList_AddToNeverList()
        {
            PNUser a, b;
            CreateXenonUsers(out a, out b, false);

            a.AddUsersToNeverList(1, new ulong[] { b.UserId });
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_NeverList_NegativeCase_AddWithInvalidUsers()
        {
            PNUser a;
            a = CreateXenonUser(true);

            ulong invalidUserId = ulong.MaxValue - 1;
            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();

            //setup the request object
            AddUsersToNeverListMsg req = new AddUsersToNeverListMsg();
            req.qwUserID = invalidUserId;
            req.rgqwNeverListUsers =  new ulong[] {a.UserId};
            req.cNeverListUserCount = 1;

            req.header.sgaddr = new xonline.common.protocol.SGADDR();
            req.header.sgaddr.inaSg = a.Xbox.IpSg;
            req.header.sgaddr.dwSpiSg = a.Xbox.SpiSg;
            req.header.sgaddr.qwXboxId = a.Xbox.XboxId;

            //get and send in the SG slot
            slot.userPuid0 = invalidUserId;
            slot.machinePuid = a.Xbox.XboxId;

            //setup the response object
            XRLObject2 resp = new XRLObject2();

            //call the social query XRL
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, xonline.common.service.XOService.PresNotification, false, req.Xrl, req, ref resp);
            ValueCheck.Test("result should be Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER)", hr, (uint)Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER));
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_NeverList_NegativeCase_RemoveWithInvalidUsers()
        {
            PNUser a;
            a = CreateXenonUser(true);

            ulong invalidUserId = ulong.MaxValue - 1;
            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();

            //setup the request object
            RemoveUsersFromNeverListMsg req = new RemoveUsersFromNeverListMsg();
            req.qwUserID = invalidUserId;
            req.rgqwNeverListUsers = new ulong[] { a.UserId };
            req.cNeverListUserCount = 1;

            req.header.sgaddr = new xonline.common.protocol.SGADDR();
            req.header.sgaddr.inaSg = a.Xbox.IpSg;
            req.header.sgaddr.dwSpiSg = a.Xbox.SpiSg;
            req.header.sgaddr.qwXboxId = a.Xbox.XboxId;

            //get and send in the SG slot
            slot.userPuid0 = invalidUserId;
            slot.machinePuid = a.Xbox.XboxId;

            //setup the response object
            XRLObject2 resp = new XRLObject2();

            //call the social query XRL
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, xonline.common.service.XOService.PresNotification, false, req.Xrl, req, ref resp);
            ValueCheck.Test("result should be Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER)", hr, (uint)Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER));
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_NeverList_NegativeCase_CanSendWithInvalidUsers()
        {
            PNUser a;
            a = CreateXenonUser(true);

            ulong invalidUserId = ulong.MaxValue - 1;
            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();

            //setup the request object
            CanSendMessageToUsersMsg req = new CanSendMessageToUsersMsg();
            req.qwUserID = invalidUserId;
            req.rgqwUsers = new ulong[] { a.UserId };
            req.cUserListCount = 1;

            req.header.sgaddr = new xonline.common.protocol.SGADDR();
            req.header.sgaddr.inaSg = a.Xbox.IpSg;
            req.header.sgaddr.dwSpiSg = a.Xbox.SpiSg;
            req.header.sgaddr.qwXboxId = a.Xbox.XboxId;

            //get and send in the SG slot
            slot.userPuid0 = invalidUserId;
            slot.machinePuid = a.Xbox.XboxId;

            //setup the response object
            XRLObject2 resp = new XRLObject2();

            //call the social query XRL
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, xonline.common.service.XOService.PresNotification, false, req.Xrl, req, ref resp);
            ValueCheck.Test("result should be Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER)", hr, (uint)Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER));
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public void P_NeverList_AddAndRemoveFromNeverList()
        {
            PNUser a, b;
            CreateXenonUsers(out a, out b, false);

            a.AddUsersToNeverList(1, new ulong[] { b.UserId });
            a.RemoveUsersFromNeverList(1, new ulong[] { b.UserId });
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public void P_NeverList_AddAndRemoveFromNeverListWithVerify()
        {
            PNUser a, b;
            CreateXenonUsers(out a, out b, false);

            a.AddUsersToNeverList(1, new ulong[] { b.UserId });

            var results = b.CanSendMessageToUsers(1, new ulong[] { a.UserId });
            ValueCheck.Test("result should be XONLINE_E_MESSAGE_SENDER_BLOCKED", results[0], HResult.XONLINE_E_MESSAGE_SENDER_BLOCKED);

            a.RemoveUsersFromNeverList(1, new ulong[] { b.UserId });

            results = b.CanSendMessageToUsers(1, new ulong[] { a.UserId });
            ValueCheck.Test("result should be S_OK", results[0], HResult.S_OK);
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public void P_NeverList_CanSendMessageToInvalidUser()
        {
            PNUser a;
            a = CreateXenonUser(true);

            var results = a.CanSendMessageToUsers(1, new ulong[] { ulong.MaxValue-1 });
            ValueCheck.Test("result should be Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER)", results[0], (uint)Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER));

        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1)]
        public void P_NeverList_CanSendMessageToPrivilegeUser()
        {
            PNUser a, b;
            CreateXenonUsers(out a, out b, false);

            SetPrivilege(b, XOn.XPRIVILEGE_COMMUNICATIONS, false);
            SetPrivilege(b, XOn.XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY, true);

            var results = a.CanSendMessageToUsers(1, new ulong[] { b.UserId });
            ValueCheck.Test("result should be XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES)", results[0], HResult.XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES);

        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_NeverList_NegativeCase_DeleteFromEmptyNeverList()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(true);

            // This should be a no-op, but let's do some verification anyway
            a.RemoveUsersFromNeverList(1, new ulong[] { b.UserId });

            NeverList neverList =  PresenceUtil.GetNeverList(a.UserId);

            ValueCheck.IsTrue(neverList.rgNeversLen == 0, "User's neverlist should be 0! Actual: " + neverList.rgNeversLen);
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_NeverList_NegativeCase_DeleteUserNotInNeverList()
        {
            PNUser a = CreateXenonUser(true);
            PNUser [] blockedUsers = CreateXenonUsers(5, true);
            PNUser b = CreateXenonUser(true);

            // Add a bunch of users
            foreach (PNUser user in blockedUsers)
            {
                a.AddUsersToNeverList(1, new ulong[] { user.UserId });
            }

            // Remove a user that wasn't added
            a.RemoveUsersFromNeverList(1, new ulong[] { b.UserId });

            // Confirm that there are still the appropriate number of users in a's neverlist
            NeverList neverList = PresenceUtil.GetNeverList(a.UserId);

            ValueCheck.IsTrue(neverList.rgNeversLen == blockedUsers.Length, "User's neverlist is the wrong size! Expected: " + blockedUsers.Length + " Actual: " + neverList.rgNeversLen);
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_NeverList_NegativeCase_Add2UsersRemove1()
        {
            PNUser a = CreateXenonUser(true);
            PNUser notBlockedUser = CreateXenonUser(true);
            PNUser blockedUser = CreateXenonUser(true);

            // Add two users to a's neverlist
            a.AddUsersToNeverList(1, new ulong[] { notBlockedUser.UserId });
            a.AddUsersToNeverList(1, new ulong[] { blockedUser.UserId });

            // Remove 1 user
            a.RemoveUsersFromNeverList(1, new ulong[] { notBlockedUser.UserId });

            // Confirm that notBlockedUser can message user a and that blockedUser can't
            var results = notBlockedUser.CanSendMessageToUsers(1, new ulong[] { a.UserId });
            ValueCheck.Test("result should be S_OK", results[0], HResult.S_OK);

            results = blockedUser.CanSendMessageToUsers(1, new ulong[] { a.UserId });
            ValueCheck.Test("result should be XONLINE_E_MESSAGE_SENDER_BLOCKED", results[0], HResult.XONLINE_E_MESSAGE_SENDER_BLOCKED);
        }

        //This should be common code rather then in every class.
        private static void SetPrivilege(PNUser user, uint priv, bool grant)
        {
            // Create a grant request
            XRLXeUpdateParentalControls request = new XRLXeUpdateParentalControls();
            request.UserPuid = user.UserId;
            request.Source = "STF-PRES-FPC";

            ServerTestFramework.LiveService.UserAccount.UserPrivileges grants = new ServerTestFramework.LiveService.UserAccount.UserPrivileges();
            ServerTestFramework.LiveService.UserAccount.UserPrivileges restrictions = new ServerTestFramework.LiveService.UserAccount.UserPrivileges();

            // Populate the new requested privilege
            if (grant)
            {
                grants[(int)priv] = true;
            }
            else
            {
                restrictions[(int)priv] = true;
            }

            request.UserGrantPrivileges = grants.ToArray();
            request.UserRestrictPrivileges = restrictions.ToArray();
            request.ExecuteSafe();

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncSgCliNotifyUpdate.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.config;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using xonline.common.community;

namespace PresenceTest
{
	/// <summary>
	/// Functional Tests for SgCliNotifyUpdate
	/// </summary>
	/// <remarks>
	/// <Description>
	/// This functional group tests the specific code path for batch state updates
	/// in the presence FD SgCliNotifyUpdate
	/// </Description>
	/// </remarks>
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3)]
	 class FuncSgCliNotifyUpdate : PresenceTestBaseGroup
	 {
		PNUser _uxe;
		PNUser _obxe;
        PNUser _fxe;

		public override void Setup()
		{
            base.Setup();
			// users
			_uxe = CreateXenonUser(true);
			// observers
			_obxe = CreateXenonUser(true);
            // friends
            _fxe = CreateXenonUser(true);
            // establish friendship
			_fc.MakeFriend(_uxe, _fxe);
            // set up watchers
            _obxe.PeerSubscribeEx(_uxe);
		}

		public override void TearDown()
		{
			_fc.LogoffUser(_uxe);
			_fc.LogoffUser(_obxe);
            base.TearDown();
		}

		private void ValidateSetTitleStuff(PNUser a, PNUser b, byte[] titleStuff)
		{
			// Try to give b some time to settle old qvals
			Thread.Sleep(5000);
			b.ProcessNotifications();
		
			a.SetTitleData(titleStuff);

            // make sure we get at least one
            UserNotification noti = b.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            b.HandleTCPNotification(noti);
            b.ProcessNotifications();

			PNUser.PeerInfo bi = b.GetPeerInfo(a.UserId);

			ValueCheck.TestNotNull("BuddyInfo", bi);
			ValueCheck.TestNotNull("BuddyInfo.Presence", bi.RichPresenceData); //todo: PAUL: Check and diff.

            //ValueCheck.Test("TitleStuffLen", titleStuff.Length, bi.TitleId);
            //ValueCheck.Test("TitleStuffBytes", titleStuff, bi.PeerPresence.TitleStuff);
		}

		private void ValidateSetState(PNUser u, PNUser ob, PNUser f, uint state, bool sentToFriend)
		{
            UserNotification noti;
            uint sentState;

            ob.ProcessNotifications();
            u.ProcessNotifications();
            f.ProcessNotifications();

            u.State = state;	
			u.SetTitleData();
            Thread.Sleep(2000);

            // xenon user friend pair
            noti = ob.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            ob.HandleTCPNotification(noti);
            ob.ProcessNotifications();
            PNUser.PeerInfo pi = ob.GetPeerInfo(u.UserId);
            ValueCheck.TestNotNull("PeerInfo", pi);
            ValueCheck.TestNotNull("PeerInfo.BasicPresenceData", pi.BasicPresenceData);
            sentState = pi.BasicPresenceData.State;

            // if this chage was not supposed to be filtered
            if (sentToFriend)
            {
                // xenon user friend pair
                noti = f.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
                f.HandleTCPNotification(noti);
                f.ProcessNotifications();
                PNUser.BuddyInfo bi = f.GetBuddyInfo(u.UserId);
                ValueCheck.TestNotNull("BuddyInfo", bi);
                ValueCheck.TestNotNull("BuddyInfo.BasicPresenceData", bi.BasicPresenceData);
                if (sentState != bi.BasicPresenceData.State)
                {
                    throw new UnexpectedTestResultException("State bits were not sent to both peers and friends");
                }
            }

			if(0 == (state & sentState))
			{
				throw new UnexpectedTestResultException("State bits 0x" + state.ToString("x") + " were not present in state dequeue: 0x" + sentState.ToString("x"));
			}

			// Validate get presence info
            //TODO: NYI
            //PresenceInfo info = ob.GetPresenceInfo(u);
            //ValueCheck.Test("PresenceInfo.OnlineState", sentState, info.OnlineState);
		}

		[TestCase]
		public void P_SetState_Playing()
		{
			ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE|XonPresNoti.P_STATE_MASK_PLAYING, true);
            ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE, true);
		}
		[TestCase]
		public void P_SetState_Voice()
		{
			ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE|XonPresNoti.P_STATE_MASK_VOICE, true);
            ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE, true);
		}
		[TestCase]
		public void P_SetState_Joinable()
		{
			ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE|XonPresNoti.P_STATE_MASK_JOINABLE, true);
            ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE, true);
		}
         [TestCase]
         public void P_SetState_JoinableFriendsOnly()
         {
             ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE | XonPresNoti.P_STATE_MASK_JOINABLE_FRIENDS_ONLY, true);
             ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE, true);
         }
        [TestCase]
        public void P_SetState_PartyJoinable()
        {
            ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE | XonPresNoti.P_STATE_MASK_PARTY_JOINABLE, true);
            ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE, true);
        }
         [TestCase]
         public void P_SetState_PartyJoinableFriendsOnly()
         {
             ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE | XonPresNoti.P_STATE_MASK_PARTY_JOINABLE_FRIENDS_ONLY, true);
             ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE, true);
         }
         [TestCase]
         public void P_SetState_PartyPlaying()
         {
             ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE | XonPresNoti.P_STATE_MASK_PARTY_PLAYING, true);
             ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE, true);
         }
         [TestCase]
         public void P_SetState_PartyCounter()
         {
             ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE | (XonPresNoti.P_STATE_MASK_PARTY_COUNTER & (XonPresNoti.P_STATE_MASK_PARTY_COUNTER >> 1)), false); // 01
             ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE | (XonPresNoti.P_STATE_MASK_PARTY_COUNTER & (XonPresNoti.P_STATE_MASK_PARTY_COUNTER << 1)), false); // 10
             ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE | XonPresNoti.P_STATE_MASK_PARTY_COUNTER, false); // 11
             ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE, false); // 00
         }
		[TestCase]
		public void P_SetState_Guests()
		{
			ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE|XonPresNoti.P_STATE_MASK_GUESTS, true);
            ValidateSetState(_uxe, _obxe, _fxe, XonPresNoti.P_STATE_MASK_ONLINE, true);
		}

		[TestCase]
		public void P_Xenon_Stale_Data()
		{
			byte []staledata = new byte[] {
			0xd6, 0x22, 0x07, 0x00, 0x4d, 0x49, 0x41, 0x00, 
			0x50, 0x48, 0x49, 0x00, 0x0c, 0x00, 0x04, 0x00, 
			0x30, 0x3a, 0x32, 0x39, 0x00, 0xbc, 0x03, 0xd0, 
			0x51, 0x32, 0x00, 0x39, 0x01, 0x00, 0x00, 0x00, 
			0x0b, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x02, 0x00, 0x00, 0x10, 0x70, 0x00, 0x00, 0x00, 
			0x03, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			};

			PNUser a, b;
			a = CreateXenonUser(true);
			b = CreateXenonUser(true);
			_fc.MakeFriend(a, b);

			GlobalFakeSG.FakeSG.SetUserState(a.Xbox.XboxId, a.UserId, 0, a.State, staledata, 0);
		}

		[TestCase]
		public void P_BatchUpdates_Interval10_Users10_Updates1()
		{
			BatchStateUpdateScenario(10, 10, 1);
		}

		[TestCase]
		public void P_BatchUpdates_Interval3_Users10_Updates2()
		{
			BatchStateUpdateScenario(3, 10, 2);
		}

        [TestCase]
        public void BatchStateTestSendExact100()
        {
            Random rand = new Random();
            GlobalFakeSG.FakeSG.SetEnableStateBatching(false, 0);
            PresenceRecord rec = null;
            PNUser[] users = CreateXenonUsers(50, true);
            Thread.Sleep(2000);
            //Set the batch time of 2 mins
            //uint almosthour = 1000 * 60 * 59;
            uint fivesec= 5000;
            GlobalFakeSG.FakeSG.SetEnableStateBatching(true, fivesec);

            for (int i = 0; i <= 100; i++)
            {
                //playing loop
                foreach (PNUser u in users)
                {
                    uint st = u.State | XonPresNoti.P_STATE_MASK_PLAYING;
                    u.State = st;
                    u.MatchSessionId = (ulong)rand.Next();
                    u.SetTitleData();
                    //again
                    st = u.State | XonPresNoti.P_STATE_ENUM_AWAY;
                    u.State = st;
                    u.MatchSessionId = (ulong)rand.Next();
                    u.SetTitleData();
                }

                Thread.Sleep(2000);

                //verify in cache.
                foreach (PNUser u in users)
                {
                    string key = CacheUtil.BuildCacheKey(DATA_TYPES.eInternalPresence, u.UserId);
                    rec = (PresenceRecord)CacheUtil.ReadFromCache(key);
                    Global.RO.Info("User: " + u.UserId + "pnuser info: state: " + u.State + " session: " + u.MatchSessionId);
                    Global.RO.Info("User: " + u.UserId + "presrec info state: " + rec.dwState + " session: " + rec.qwSessionID);
                    xonline.common.diagnostics.Assert.IsTrue(rec.dwState == u.State, "State");
                    xonline.common.diagnostics.Assert.IsTrue(rec.qwSessionID == u.MatchSessionId, "Match");
                }

                Global.RO.Success("passed" + i);
            }
            GlobalFakeSG.FakeSG.SetEnableStateBatching(false, 0);
        }

        [TestCase]
        public void BatchStateTestSendMoreThan100()
        {
            Random rand = new Random();

            for (int i = 0; i <= 100; i++)
            {
                GlobalFakeSG.FakeSG.SetEnableStateBatching(false, 0);
                PresenceRecord rec = null;
                PNUser[] users = CreateXenonUsers(50, true);
                Thread.Sleep(2000);
                //Set the batch time of 2 mins
                uint almosthour = 1000 * 60 * 59;
                GlobalFakeSG.FakeSG.SetEnableStateBatching(true, almosthour);
                //send it
                //GlobalFakeSG.FakeSG.SendUpdateState(true);
                Thread.Sleep(2000);
                //playing loop
                foreach (PNUser u in users)
                {
                    uint st = u.State | XonPresNoti.P_STATE_MASK_PLAYING;
                    u.State = st;
                    u.MatchSessionId = (ulong)rand.Next();
                    Global.RO.Info("User: " + u.UserId + "state: " + u.State + " session: " + u.MatchSessionId);
                    u.SetTitleData();
                }

                //away loop
                foreach (PNUser u in users)
                {
                    uint st = u.State | XonPresNoti.P_STATE_ENUM_AWAY;
                    u.State = st;
                    u.MatchSessionId = (ulong)rand.Next();
                    Global.RO.Info("User: " + u.UserId + "state: " + u.State + " session: " + u.MatchSessionId);
                    u.SetTitleData();
                }

                //fakesg should have sent a batch of 100 at this moment.
                //sending another 5
                for (int j = 0; j < 5; j++)
                {
                    PNUser u = users[j];
                    uint st = u.State | XonPresNoti.P_STATE_MASK_PARTY_JOINABLE;
                    u.State = st;
                    u.MatchSessionId = (ulong)rand.Next();
                    Global.RO.Info("User: " + u.UserId + "state: " + u.State + " session: " + u.MatchSessionId);
                    u.SetTitleData();
                }

                //send it
                //GlobalFakeSG.FakeSG.SendUpdateState(true);
                //wait
                Thread.Sleep(5000);

                //verify in cache.
                foreach (PNUser u in users)
                {
                    string key = CacheUtil.BuildCacheKey(DATA_TYPES.eInternalPresence, u.UserId);
                    rec = (PresenceRecord)CacheUtil.ReadFromCache(key);
                    Global.RO.Info("User: " + u.UserId + " PRESREC State: " + rec.dwState + " PNUser state:" + u.State + " PRESREC Session: " + rec.qwSessionID + " PNUser session:" + u.MatchSessionId);
                    xonline.common.diagnostics.Assert.IsTrue(rec.dwState == u.State, "State");
                    xonline.common.diagnostics.Assert.IsTrue(rec.qwSessionID == u.MatchSessionId, "Match");
                }

                Global.RO.Success("passed" + i);
            }
            GlobalFakeSG.FakeSG.SetEnableStateBatching(false, 0);
        }

        [TestCase]
        public void MultiUserSameConsoleEAIssue()
        {

            GlobalFakeSG.FakeSG.SetEnableStateBatching(true, 1);
            PresenceRecord rec = null;
            PNUser u = CreateXenonUser(true);
            PNUser[] friends_sameConsole = CreateXenonUsers(3, true);
            PNUser[] friends_differentConsole = CreateXenonUsers(15, true);

            

            friends_sameConsole[0].Xbox.ConnectionServerConnection = u.Xbox.ConnectionServerConnection;
            friends_sameConsole[1].Xbox.ConnectionServerConnection = u.Xbox.ConnectionServerConnection;
            friends_sameConsole[2].Xbox.ConnectionServerConnection = u.Xbox.ConnectionServerConnection;

            foreach (PNUser friend in friends_sameConsole)
            {
                _fc.LogoffUser(friend);
                _fc.LogonUser(friend);

                _fc.MakeFriend(friend, u);

                _fc.LogoffUser(friend);
                _fc.LogonUser(friend);
            }

            //foreach (PNUser friend in friends_differentConsole)
            //{
            //    _fc.LogoffUser(friend);
            //    _fc.LogonUser(friend);

            //    _fc.MakeFriend(friend, u);

            //    _fc.LogoffUser(friend);
            //    _fc.LogonUser(friend);
            //}
            
            Thread.Sleep(2000);

            //set state for u;
            u.TitleId = PongTitleId;
            uint st = u.State | XonPresNoti.P_STATE_MASK_PARTY_JOINABLE;
            u.State = st;
            u.SetTitleData();
            //wait for few seconds.

            //verify all friends.
            foreach (PNUser friend in friends_sameConsole)
            {
                    string key = CacheUtil.BuildCacheKey(DATA_TYPES.eInternalPresence, friend.UserId);
                    rec = (PresenceRecord)CacheUtil.ReadFromCache(key);
                    Global.RO.Info("User: " + friend.UserId + " PRESREC State: " + rec.dwState + " PNUser state:" + friend.State + " PRESREC Session: " + rec.dwTitleID + " PNUser title:" + friend.TitleId);
                    xonline.common.diagnostics.Assert.IsTrue(rec.dwState == friend.State, "State");
                    xonline.common.diagnostics.Assert.IsTrue(rec.dwTitleID == friend.TitleId, "Title");
            }


        }
		public void BatchStateUpdateScenario(uint interval, int userCount, int updates)
		{
			PNConditionalWaitState waitState = new PNConditionalWaitState();
			PNUser observer = CreateXenonUser(true); //TODO: PAUL: CHECK
			PNUser []users = new PNUser[userCount];

			// Create other users and create the combined wait state
			for(int i =  0; i < userCount; ++i)
			{
				users[i] = CreateXenonUser(true);
				waitState.AddRequiredQFlag(XonPresNoti.QFLAG_MASK_PEER_PRESENCE, users[i], observer);
			} 

			// Add subscribrtion
			observer.PeerSubscribe(users);

			// Process the initial watch start
			waitState.WaitOnConditions();

			GlobalFakeSG.FakeSG.SetEnableStateBatching(true, interval);
			try
			{
				DateTime intervalEnd = DateTime.Now.AddSeconds(interval); 

				for(int i = 0; i < updates; ++i)
				{
					// Batch all users in a single state message
					for(int j = 0; j < userCount; ++j)
					{
						// Encode index and bottom portion of puid into title data
						byte []titleData = new byte[8];
						titleData[0] = (byte)i;
						titleData[1] = (byte)j;
						titleData[2] = (byte)((users[j].UserId    ) & 0xff);
						titleData[3] = (byte)((users[j].UserId>>8 ) & 0xff);
						titleData[4] = (byte)((users[j].UserId>>16) & 0xff);
						titleData[5] = (byte)((users[j].UserId>>24) & 0xff);
						users[j].SetTitleData(titleData);
					}

					Global.RO.Info("Waiting for interval to end and batch state flush");
					while(intervalEnd > DateTime.Now)
					{
						Thread.Sleep(10);
					}

					waitState.WaitOnConditions();
					
				}
			}
			finally
			{
				GlobalFakeSG.FakeSG.SetEnableStateBatching(false, 0);
			}
		}
	 }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncXMgmt.cs ===
using System;
using System.Net;
using System.Collections.Generic;
using System.Net.Sockets;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.protocol.SubNoti;
using xonline.common.community;
using xonline.common.diagnostics;
using xonline.common.config;
using ServerTestFramework.LiveService;
namespace PresenceTest
{
    [TestGroup, TestFrequency("Daily"), TestCasePriority(2), AsyncGroup(1, 0), Owner("Shailesh")]
	public class FuncXmgmt : PresenceTestBaseGroup
	{
        private string ExecuteXmgmt(string command, string commandArg)
        {
            string result = string.Empty;
            ManagementConsole.Execute(Global.XEnv.GetServerListByInterface("xpnfd_presence_int")[0], "e :xpnfd " + command + " "  + commandArg, out result);
            return result;
        }

        [TestCase]
        public void FuncShowHelp()
        {
            string result = ExecuteXmgmt("help", "");
            ValueCheck.IsTrue((result.Contains("XPNFD help")) &&
                              (result.Contains("ShowCacheData <key> -- Display cache value for specified key.")) &&
                              (result.Contains("Kick <userid (decimal)> -- Kick an online user off Xbox Live.")),
                              "Help displayed.");
        }

        [TestCase]
        public void FuncShowCacheDataOnlineUser()
        {
            PNUser user = CreateXenonUser(true);
            string key = CacheUtil.BuildCacheKey(DATA_TYPES.eInternalPresence, user.UserId);
            string result = ExecuteXmgmt("ShowCacheData", key);
            ValueCheck.IsTrue(result.Contains("Item found in Cache:"), "Found Cache Record.");
        }

        [TestCase]
        public void FuncShowCacheDataOfflineUser()
        {
            PNUser user = CreateXenonUser(false);
            string key = CacheUtil.BuildCacheKey(DATA_TYPES.eInternalPresence, user.UserId);
            string result = ExecuteXmgmt("ShowCacheData", key);
            ValueCheck.IsTrue(result.Contains("Item not found in Cache."), "Did not found Cache Record.");
        }

        [TestCase, Ignore("This will always fail because Kick is sent to fakesg who doesn't report it back to presence.")]
        public void FuncKickOnlineUser()
        {
            PNUser user = CreateXenonUser(true);
            string result = ExecuteXmgmt("Kick", user.UserId.ToString());
            ValueCheck.IsTrue(result.Contains("User " + user.UserId + " was kicked."), "User kicked.");
            
            //keep polling for a second. 
            PresenceRecord rec = null;
            for (int i = 0; i < 10; i++)
            {
                rec = PresenceUtil.GetPresenceRecord(user.UserId);
                if (!rec.IsOnline())
                    break;
                Thread.Sleep(100);
            }
            rec = PresenceUtil.GetPresenceRecord(user.UserId);
            ValueCheck.IsFalse(rec.IsOnline(), "User should not be online.");
        }

        [TestCase]
        public void FuncKickOfflineUser()
        {
            PNUser user = CreateXenonUser(true);
            _fc.LogoffUser(user);
            string result = ExecuteXmgmt("Kick", user.UserId.ToString());
            ValueCheck.IsTrue(result.Contains("User " + user.UserId + " is not online"), "User Not online..");
        }

        [TestCase]
        public void FuncKickNonexistantUser()
        {
            PNUser user = CreateXenonUser(false);
            string result = ExecuteXmgmt("Kick", user.UserId.ToString());
            ValueCheck.IsTrue(result.Contains("Presence record not found for user " + user.UserId), "User Not found..");
        }
        [TestCase]
        public void FuncRemoveCacheKeyOnlineUser()
        {
            PNUser user = CreateXenonUser(true);
            PNXbox xbox = user.Xbox;
            PresenceRecord prUser =  PresenceUtil.GetPresenceRecord(user.UserId);

            string key = CacheUtil.BuildCacheKey(DATA_TYPES.eInternalPresence, user.UserId);
            string result = ExecuteXmgmt("removecachekey", key);
            ValueCheck.IsTrue(result.Contains("Removed key: " + key), "User Not found..");

            // See if it's in the cache anymore
            result = ExecuteXmgmt("ShowCacheData", key);
            ValueCheck.IsTrue(result.Contains("Item not found in Cache."), "Did not found Cache Record.");

            // Update state
            user.State |= XonPresNoti.P_STATE_MASK_JOINABLE;
            user.SetTitleData();

            Thread.Sleep(2000);

            // Get the cache data  THIS FAILS
            result = ExecuteXmgmt("ShowCacheData", key);
            ValueCheck.IsTrue(result.Contains("Item found in Cache:"), "Changed state and the cache key isn't there!  Fail!");

            // Make a friend
            PNUser friend = CreateXenonUser(true);
            FriendsCommon fc = new FriendsCommon();
            fc.MakeFriend(user, friend);
            //xonline.common.service.HResult hr = FriendsListUtil.MakeFriends(user.UserId, friend.UserId, user.Name, friend.Name);
            //ValueCheck.IsTrue(xonline.common.service.HResult.Succeeded(hr), "MakeFriends failed with " + hr);

            // This doesn't invalidate the test.  it just repops the friends list to the next check works correctly
            fc.LogoffUser(user);
            fc.LogonUser(user);

            ValueCheck.IsTrue(user.BuddyStatusOK(friend), "Tried to make friends but couldn't!");
        }

        // TODO: What should removing the cache key of an offline user do?
        [TestCase]
        public void FuncRemoveCacheKeyOfflineUser()
        {
            PNUser user = CreateXenonUser(false);
            string key = CacheUtil.BuildCacheKey(DATA_TYPES.eInternalPresence, user.UserId);
            string result = ExecuteXmgmt("removecachekey", key);
            ValueCheck.IsTrue(result.Contains("Removed key: " + key), result);
        }

        [TestCase]
        public void FuncNPDBSettings()
        {
            bool bAllMatch = true;
            Global.RO.Info("Verifying Upgrade Settings");
            Dictionary<string, string> nameValues = new Dictionary<string, string>();
            nameValues =  BuildNPDBUpgradeDictionary();
            foreach (string s in nameValues.Keys)
            {
                string val = Global.XEnv.GetSetting(s);
                Global.RO.Debug("Verifying " + s);
                Global.RO.Debug("\t" + " Expected: " + nameValues[s]);
                Global.RO.Debug("\t" + " Actual: " + val);
                if (nameValues[s] != val)
                {
                    Global.RO.Error("Unexpected value for setting " +  s);
                    bAllMatch = false;
                }
            }
            Global.RO.Info("Verifying Prodbase Settings");
            nameValues = BuildNPDBProdBaseDictionary();
            foreach (string s in nameValues.Keys)
            {
                string val = Global.XEnv.GetSetting(s);
                Global.RO.Debug("Verifying " + s);
                Global.RO.Debug("\t" + " Expected: " + nameValues[s]);
                Global.RO.Debug("\t" + " Actual: " + val);
                if (nameValues[s] != val)
                {
                    Global.RO.Error("Unexpected value for setting " + s);
                    bAllMatch = false;
                }
            }
            Assert.IsTrue(bAllMatch);
        }

        //private Dictionary<string, string> BuildNPDBProdBaseXConnSrvDictionary()
        //{
        //    Dictionary<string, string> result = new Dictionary<string, string>();
        //    result.Add("XConnSrv_BulkGetBatchMaxSize", "");
        //    result.Add("XConnSrv_BytesPerPooledBuffer", "");
        //    result.Add("XConnSrv_DataThreadpoolSize", "");
        //    result.Add("XConnSrv_MaxClientSockets", "");
        //    result.Add("XConnSrv_MaxMessageBytes", "");
        //    result.Add("XConnSrv_MaxObjectsPerMessage", "");
        //    result.Add("XConnSrv_MaxSubscriptionsPerConnection", "");
        //    result.Add("XConnSrv_MemCacheDllName", "");
        //    result.Add("XConnSrv_NumLookupTableBuckets", "");
        //    result.Add("XConnSrv_SocketBufferSize", "");
        //    result.Add("XConnSrv_TCPKeepAliveTimeout", "");
        //    result.Add("XConnSrv_UseSGAuth", "");
        //    return result;
        //}

        private Dictionary<string, string> BuildNPDBProdBaseDictionary()
        {
            Dictionary<string, string> result = new Dictionary<string, string>();
            result.Add("presence_AffiliatesAvoidingMeListSize", "50");
            result.Add("presence_AffiliatesCompletedGameListSize", "100");
            result.Add("presence_AffiliatesEncounteredListSize", "50");
            result.Add("presence_AffiliatesFavoritesListSize", "50");
            result.Add("presence_AffiliatesNegativeFeedbackListSize", "50");
            result.Add("presence_AffiliatesPositiveFeedbackListSize", "50");
            result.Add("presence_BucketReloadDelay", "600000");
            result.Add("presence_ConcurrentSQLThreads", "0");
            result.Add("presence_ContextDurationAlertLimit", "10000");
            result.Add("presence_DeadSgOnFailedQVal", "false");
            result.Add("presence_EnableRichPresence", "1");
            result.Add("presence_ExpirationCheckInterval", "true");
            result.Add("presence_HeartbeatDelay", "100");
            result.Add("presence_IdleQValsCheck", "true");
            result.Add("presence_MaxNumPoolBuffers", "12800");
            result.Add("presence_MaxPresenceUsers", "1000000");
            result.Add("presence_MaxQValsPerHeartbeat", "500");
            result.Add("presence_MaxRichPresenceBytes", "128");
            result.Add("presence_MessageTimeout", "30000");
            result.Add("presence_MessageTypeExpiration", "43200, 43200, 1440, 43200, 1440, 10080, 43200, 43200, 43200, 1440, 1440, 1440");
            result.Add("presence_MessagingDailyRecipients", "2500");
            result.Add("presence_MessagingDailySends", "250");
            result.Add("presence_NumSQLThreads", "300");
            result.Add("presence_PeerPort", "3001");
            result.Add("presence_PoolBufferSize", "8192");
            result.Add("presence_PresUserCleanupDelay", "600000");
            result.Add("presence_QueryAffiliatesOkToPeerSubscribe", "1");
            result.Add("presence_QValRetryDelays", "5000, 5000, 5000, 5000, 5000, 5000");
            result.Add("presence_RichPresenceDebug", "false");
            result.Add("presence_SGIndexSize", "16381");
            result.Add("presence_SGQValRecvPort", "3002");
            result.Add("presence_SGQValSendPort", "0xFFFF");
            result.Add("presence_StartNumPoolBuffers", "100");
            result.Add("presence_StateBitsNotifyWhitelist", "0xBFFFFFFF");
            result.Add("presence_StoreStateInVelocity", "1");
            result.Add("presence_UserIndexSize", "95219");
            result.Add("presence_ValidMessageTypes", "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12");
            result.Add("presence_WebUserTimeout", "60");
            result.Add("presence_XBoxIndexSize", "95219");
            result.Add("presence_XonWatchIPs", "65.59.233.112, 255.255.255.240; 131.107.19.36, 255.255.255.252; 131.107.19.40, 255.255.255.252; 131.107.62.222, 255.255.255.254; 131.107.62.226, 255.255.255.254; 131.107.62.240, 255.255.255.254; 131.107.215.132, 255.255.255.252; 131.107.215.136, 255.255.255.252; 131.107.215.194, 255.255.255.254; 131.107.215.250, 255.255.255.254; 71.164.5.100, 255.255.255.252; 71.164.5.104, 255.255.255.252; 71.164.5.116, 255.255.255.252; 71.164.5.120, 255.255.255.252; 8.6.176.231, 255.255.255.255; 8.6.176.232, 255.255.255.255; 131.107.206.128, 255.255.255.128");
            result.Add("presenceFD_NumPoolThreads", "40");
            result.Add("presenceWidget_friendsCacheExpirationSeconds", "120");
            return result;
        }

        private Dictionary<string, string> BuildNPDBUpgradeDictionary()
        {
            Dictionary<string, string> result = new Dictionary<string, string>();
            result.Add("presence_MaxFriends", "100");
            result.Add("presence_WebUserTimeout", "60");
            result.Add("presence_WelcomeToNewConsoleMessage", "0");
            result.Add("presence_WelcomeToXboxLiveMessage", "0");
            return result;
        }

        [TestCase]
        public void FuncPresenceRecordRecreation()
        {
            PNUser u = _fc.CreateXenonUser(true);
            Global.RO.Debug("u.Xbox.XboxId: " + u.Xbox.XboxId);
            string key = CacheUtil.BuildCacheKey(DATA_TYPES.eInternalPresence, u.UserId);
            PresenceRecord rec = (PresenceRecord)CacheUtil.ReadFromCache(key);
            //What do we have in the beginning.
            ulong nonce = rec.qwNonce ;
            uint seqQvals = rec.dwSeqQVals;
            uint seqXAdd = rec.dwSeqXMsgAddQVal;
            uint seqXdel = rec.dwSeqXMsgDeleteQVal;
            Assert.IsTrue(nonce != 0);
            Assert.IsTrue(seqQvals != 0);
            Assert.IsTrue(seqXAdd != 0);
            Assert.IsTrue(seqXdel != 0);

            _fc.LogoffUser(u);
            GlobalFakeSG.FakeSG.RemoveXbox(u.Xbox.XboxId);
            u.Xbox.ConnectToFakeSG();
            _fc.LogonUser(u);
            Global.RO.Debug("u.Xbox.XboxId: " + u.Xbox.XboxId);
            //Check he gets new one after alive.
            rec = (PresenceRecord)CacheUtil.ReadFromCache(key);
            Assert.IsTrue( rec.qwNonce != 0 && nonce!=  rec.qwNonce);
            //Not checking others, because it could be same or different..
            
            //Remove user from cache.
            while (rec != null)
            {
                Global.RO.Debug("Removing Cache key...");
                CacheUtil.RemoveFromCache(key);
                rec = (PresenceRecord)CacheUtil.ReadFromCache(key);
                Thread.Sleep(100);
            }

            //Set him as away. This should trigger reconstruct of Precense Record
            u.SetTitleData(u.State | XonPresNoti.P_STATE_ENUM_AWAY);

            //Get the presence record and check again.
            rec = null;
            while (rec == null)
            {
                Global.RO.Debug("Awaiting presence record reconstruction...");
                rec = (PresenceRecord)CacheUtil.ReadFromCache(key);
                Thread.Sleep(100);
            }

            Thread.Sleep(500);
            Assert.IsTrue(rec.qwNonce != 0 && rec.qwNonce==ulong.MaxValue, "Actual: " + rec.qwNonce);
            Assert.IsTrue(rec.dwSeqQVals != 0 && 5000 == rec.dwSeqQVals, "Actual: " + rec.dwSeqQVals);
            Assert.IsTrue(rec.dwSeqXMsgAddQVal != 0 && 5000 == rec.dwSeqXMsgAddQVal, "Actual: "  + rec.dwSeqXMsgAddQVal);
            Assert.IsTrue(rec.dwSeqXMsgDeleteQVal != 0 && 5000 == rec.dwSeqXMsgDeleteQVal, "Actual: " + rec.dwSeqXMsgDeleteQVal);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncRichPresenceFormatting.cs ===
using System;
using System.Collections;
using System.Xml;
using System.Xml.XPath;
using System.Text;
using System.Security.Principal;
using System.Web.Caching;
using System.Globalization;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.GI;

using xonline.common.config;

namespace PresenceTest
{
    /// <summary>
    /// Positive Functional Tests for the Rich Presence String Formatter
    /// </summary>
    /// <remarks>
    /// <Description>
    /// <p>
    /// These tests operate by shimming a test harness around the rich presence formatter object
    /// and making it think that it is actually talking to a database and npdb config. Once the formatter
    /// is sufficiently fooled we populate internal mock tables, load it up good and bad data and abuse it.
    /// </p>
    /// <div class="test_data_label">
    /// Inputs to the formatter are of the following:
    /// </div>
    /// <table class="test_data">
    /// 	<tr><th>Contexts</th><td>Numeric values, a context has an ordinal ID and a value. This value is used for looking up strings in config data.</td></tr>
    /// 	<tr><th>Properties</th><td>Variable format data. Properties can be of the type: Long, LongLong, Double, Prefix:LPCWSTR, Float, DateTime</td></tr>
    /// 	<tr><th>Format strings</th><td>A modification of String.Format() rules has the form of "{(p|c)id[,alignment][:formatString]}"</td></tr>
    /// </table>
    ///
    /// <p>
    /// Property and context indexes in the format string can be of a decimal of hexidecimal format. These index into the ordinal Ids of the GI property blob that are
    /// part of the input of the formatter. If a game has not yet set a property in the GI blob it must be handled by a default value of the GIProperty object. There
    /// is a special case for this in the formatter. 
    /// </p>
    ///
    /// <div class="test_data_label">
    /// Default values for properties during string formatting:
    /// </div>
    /// <table class="test_data">
    /// 	<tr><td>XONLINE_STAT_FLOAT</td><td>0.0</td></tr>
    /// 	<tr><td>XONLINE_STAT_DATETIME</td><td>0</td></tr>
    /// 	<tr><td>XONLINE_STAT_DOUBLE</td><td>0.0</td></tr>
    /// 	<tr><td>XONLINE_STAT_LONG</td><td>0</td></tr>
    /// 	<tr><td>XONLINE_STAT_LONGLONG</td><td>0</td></tr>
    /// 	<tr><td>XONLINE_STAT_LPCWSTR</td><td>""</td></tr>
    /// </table>
    ///
    /// <p>
    /// When new title config data is propped to NPDB config will notify a delegate on the presence FD which is responsible for loading all title configuration
    /// data directly from the database. These rows in the database contain the title ID, last changed date and a text blob of XML. This XML data is loaded
    /// and parsed by the string formatter class. 
    /// </p>
    ///
    /// <div class="test_data_label">
    /// The portions of the document that are meaningful to rich presence are:
    /// </div>
    /// <table class="test_data">
    /// 	<tr><th>Element                                           </th><th>Attributes               </th><th>Description</th></tr>
    /// 	<tr><td>GameConfigProject                                 </td><td>@titleId                 </td><td>Game config project aggregate, there must be one or more per xlast submission, title ID is specified here.</td></tr>
    /// 	<tr><td>GameConfigProject/LocalizedStrings                </td><td>@defaultLocale           </td><td>Localized string block, there must be one or more per GameConfigProject, default locale is specified here.</td></tr>
    /// 	<tr><td>GameConfigProject/LocalizedStrings/LocalizedString</td><td>@id (stringId), @locale  </td><td>These strings are indexed by string id and reference by PresenceModes, ContextValues and Properties per locale</td></tr>
    /// 	<tr><td>GameConfigProject/Presence/Presence               </td><td>@defaultPresenceMode     </td><td>Need definition</td></tr>
    /// 	<tr><td>GameConfigProject/Presence/PresenceMode           </td><td>@contextValue, @stringId </td><td>These modes index localed format strings and are indexed to internal cache entries with the key HEXTITLEID:Fmt:LOCALE</td></tr>
    /// 	<tr><td>GameConfigProject/Contexts/Context                </td><td>@id, @stringId           </td><td>The name of the enumerator this is stored while the context values are indexed</td></tr>
    /// 	<tr><td>GameConfigProject/Contexts/Context/ContextValue   </td><td>@value, @stringId</td><td>Each context value is cached with the key built from the context enumeration id and locale for each localized context string</td></tr>
    /// </table>
    ///
    /// <div class="test_data_label">
    /// Supported locales:
    /// </div>
    /// <table class="test_data">
    /// 	<tr><th>Locale</th></tr>
    /// 	<tr><td>de-DE</td></tr>
    /// 	<tr><td>en-US</td></tr>
    /// 	<tr><td>es-ES</td></tr>
    /// 	<tr><td>fr-FR</td></tr>
    /// 	<tr><td>it-IT</td></tr>
    /// 	<tr><td>jp-JP</td></tr>
    /// 	<tr><td>ko-KR</td></tr>
    /// 	<tr><td>pt-PT</td></tr>
    /// 	<tr><td>zh-CHT</td></tr>
    /// </table>
    ///
    ///
    /// </Description>
    /// </remarks>
    [TestGroup, TestFrequency("Daily"), TestCasePriority(2)]
    class FuncRichPresenceFormatting_PositiveCases : PresenceTestBaseGroup
    {
        uint _BogusPublisher = 0x50500000;
        uint _TitleCount = 0;
        uint _NextTitleCount
        {
            get
            {
                return ++_TitleCount;
            }
        }

        public override void Setup()
        {
            base.Setup();
            // Reset the base title ID
            _TitleCount = 0;

            // Generate our xenon presence title config that will be used by xenon users created from 
            // friends common
            PresenceTitleConfig config = new PresenceTitleConfig((int)FriendsCommon.DefaultXenonTitleId);

            // First create the default strings, this will generate new string IDs which we can use
            // to add locale translations in the next section
            //Context context0 = config.AddContext(GIContext.GAME_MODE, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextName0"));
            Context context0 = config.AddGameMode(GIContext.GAME_MODE, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextName0"));
            Context context1 = config.AddContext(1, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextName1"));
            Context context2 = config.AddContext(2, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextName2"));
            Context context3 = config.AddContext(3, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextName3"));

            ContextValue cv00 = context0.AddContextValue(0, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextValue0.0"));
            ContextValue cv01 = context0.AddContextValue(1, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextValue0.1"));
            ContextValue cv02 = context0.AddContextValue(2, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextValue0.2"));

            ContextValue cv10 = context1.AddContextValue(0, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextValue1.0"));
            ContextValue cv11 = context1.AddContextValue(1, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextValue1.1"));
            ContextValue cv12 = context1.AddContextValue(2, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextValue1.2"));

            ContextValue cv20 = context2.AddContextValue(0, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextValue2.0"));
            ContextValue cv21 = context2.AddContextValue(1, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextValue2.1"));
            ContextValue cv22 = context2.AddContextValue(2, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextValue2.2"));

            ContextValue cv30 = context3.AddContextValue(0, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextValue3.0"));
            ContextValue cv31 = context3.AddContextValue(1, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextValue3.1"));
            ContextValue cv32 = context3.AddContextValue(2, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextValue3.2"));

            string[] modeStrings = new string[] 
			{
				// Context only
				" {c0x" + GIContext.GAME_MODE.ToString("X8") + "} {c0x00000001}",
				" {c0x00000001} {c0x" + GIContext.GAME_MODE.ToString("X8") + "}",

				// Presence modes used for testing properties
				" {p0x10000000} (LONG)",
				" {p0x20000000} (LONGLONG)",
				" {p0x30000000} (DOUBLE)",
				" {p0x40000000} (LPCWSTR)",
				" {p0x50000000} (FLOAT)",
				" {p0x70000000} (DATETIME)",

				// Mixed presence modes
				" {p0x10000000} {p0x10000001} {p0x10000002} {p0x10000003} {p0x10000004} {p0x10000005} {p0x10000006}",
				" {p0x10000000} {p0x10000000}",
				" {p0x70000000} {p0x10000000}",
				" {p0x70000000} {p0x50000000}",
				" {p0x10000000} {p0x10000001}",
				" {p0x40000000} {p0x10000000}",
				" {c0x" + GIContext.GAME_MODE.ToString("X8") + "} {p0x10000000} {c0x00000001} {p0x10000001} {c0x00000002} {p0x10000002} {c0x00000003} {p0x10000003}"
			};

            PresenceMode[] modes = new PresenceMode[modeStrings.Length];

            // Create the default locale mode for all of the strings
            for (uint i = 0; i < modes.Length; ++i)
            {
                modes[i] = config.AddPresenceMode(i, config.AddDefaultLocalizedString(config.DefaultLocale + modeStrings[i]));
            }

            // Add new locale strings to the presence modes and context values
            foreach (PresenceTitleConfig.LocaleSpec spec in PresenceTitleConfig.LocaleTable)
            {
                // Don't repopulate the default locale
                if (spec.Locale == config.DefaultLocale)
                {
                    continue;
                }

                if (!spec.Supported)
                {
                    continue;
                }

                string locale = spec.Locale;

                // Presence mode translations
                for (int i = 0; i < modes.Length; ++i)
                {
                    config.AddLocalizedString(modes[i].StringId, locale, locale + modeStrings[i]);
                }

                // Context 0 translations
                config.AddLocalizedString(cv00.StringId, locale, locale + "-ContextValue0.0");
                config.AddLocalizedString(cv01.StringId, locale, locale + "-ContextValue0.1");
                config.AddLocalizedString(cv02.StringId, locale, locale + "-ContextValue0.2");

                // Context 1 translations
                config.AddLocalizedString(cv10.StringId, locale, locale + "-ContextValue1.0");
                config.AddLocalizedString(cv11.StringId, locale, locale + "-ContextValue1.1");
                config.AddLocalizedString(cv12.StringId, locale, locale + "-ContextValue1.2");

                // Context 2 translations
                config.AddLocalizedString(cv20.StringId, locale, locale + "-ContextValue2.0");
                config.AddLocalizedString(cv21.StringId, locale, locale + "-ContextValue2.1");
                config.AddLocalizedString(cv22.StringId, locale, locale + "-ContextValue2.2");

                // Context 3 translations
                config.AddLocalizedString(cv30.StringId, locale, locale + "-ContextValue3.0");
                config.AddLocalizedString(cv31.StringId, locale, locale + "-ContextValue3.1");
                config.AddLocalizedString(cv32.StringId, locale, locale + "-ContextValue3.2");
            }

            Global.RO.Debug(config.BuildXml());

            // Save the config
            config.WriteToDatabase(true);
            Global.XEnv.ExecuteXmgmtCommand(Interface.xpnfd_presence, "e :xpnfd configcacherefresh");
        }

        //------------------------------------------------------------------------------
        // Generate a single property title config 
        //------------------------------------------------------------------------------
        void GeneratePropertyTitleConfig(uint titleId, uint propertyId, string[] formatStrings)
        {
            // Convert the format strings to full format strings from basic single property formats
            string[] newFormatStrings = new string[formatStrings.Length];
            uint iFormatString = 0;
            foreach (string format in formatStrings)
            {
                newFormatStrings[iFormatString++] = "{p0x" + propertyId.ToString("X") + ":" + format + "}-0x" + propertyId.ToString("X");
            }
            GenerateTitleConfig(titleId, newFormatStrings);
        }


        //------------------------------------------------------------------------------
        // Generate a title config for the specified title using the format strings
        // for the presence modes. Variable number of contexts may be passed in as
        // array objects. cContexts will be expected to exist in args.
        //------------------------------------------------------------------------------
        void GenerateTitleConfig(uint titleId, string[] formatStrings, params object[] args)
        {
            // Generate our xenon presence title config that will be used by xenon users created from 
            // friends common
            PresenceTitleConfig config = new PresenceTitleConfig((int)titleId);
            uint modeId = 0;

            // Create the presence format strings
            foreach (string format in formatStrings)
            {
                // Create the default locale mode for format string
                PresenceMode mode = config.AddPresenceMode(
                        modeId++,
                        config.AddDefaultLocalizedString(config.DefaultLocale + "-" + format));

                // Add new locale strings to the presence mode
                foreach (PresenceTitleConfig.LocaleSpec spec in PresenceTitleConfig.LocaleTable)
                {
                    // Don't repopulate the default locale
                    if (spec.Locale == config.DefaultLocale || !spec.Supported)
                    {
                        continue;
                    }

                    config.AddLocalizedString(
                            mode.StringId,
                            spec.Locale,
                            spec.Locale + "-" + format);
                }
            }


            //
            // Create the contexts
            //
            // Each array contains a set of context values for the context id specified
            // by that array index.
            //
            uint contextId = 0;
            foreach (Array contextArray in args)
            {
                // Create the context (give it a default name)
                Context ctx = config.AddContext(contextId, config.AddDefaultLocalizedString("CtxName " + contextId));

                // Create a context value for each element in the array
                uint iContextValue = 0;
                foreach (string strContextValue in contextArray)
                {
                    ContextValue ctxValue = config.AddContextValue(ctx.Id, ctx.StringId, iContextValue, config.AddDefaultLocalizedString(config.DefaultLocale + "-" + strContextValue));

                    // Generate localized context value for each element
                    foreach (PresenceTitleConfig.LocaleSpec spec in PresenceTitleConfig.LocaleTable)
                    {
                        if (spec.Locale == config.DefaultLocale || !spec.Supported)
                        {
                            continue;
                        }

                        config.AddLocalizedString(
                                ctxValue.StringId,
                                spec.Locale,
                                spec.Locale + "-" + strContextValue);
                    }

                    iContextValue++;
                }

                contextId++;
            }

            // Save the config
            config.WriteToDatabase(true);
            Global.XEnv.ExecuteXmgmtCommand(Interface.xpnfd_presence, "e :xpnfd configcacherefresh");
        }

        //------------------------------------------------------------------------------ 
        // Run a test for each locale by formatting the valueData with format strings.
        // The formatted data will be compared against what the server returns. 
        //------------------------------------------------------------------------------ 
        void CheckPropertyFormatting(bool formatCheck, uint titleId, PNUser a, PNUser b, uint propertyId, GIBlob gi, string[] formatStrings, object valueData)
        {
            foreach (PresenceTitleConfig.LocaleSpec spec in PresenceTitleConfig.LocaleTable)
            {
                if (!spec.Supported)
                {
                    continue;
                }

                // language change now requires logoff
                _fc.LogoffUser(b);
                new SleepInfo("Waiting for logoff to settle", 2000);

                // Change locale of user B
                b.Xbox.LanguageId = spec.LanguageId;
                b.LanguageId = spec.LanguageId;
                b.CountryId = spec.CountryId;

                _fc.LogonUser(b);
                b.PeerSubscribeEx(a);
                b.ProcessNotifications();

                // clear out rich presence for a
                a.SetTitleData(new byte[8]);
                UserNotification noti = b.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
                b.HandleTCPNotification(noti);

                uint presenceMode = 0;
                uint lastBuddyStateTime = 0;
                foreach (string format in formatStrings)
                {
                    //------------------------------------------------------------------------------
                    // Stage 1, standard rich presence for online users
                    //------------------------------------------------------------------------------

                    // Create a locale specific string for comparing the presence result
                    string formatResult = String.Format(new CultureInfo(spec.Locale), "{0:" + format + "}", valueData);
                    string expected = spec.Locale + "-" + formatResult + "-0x" + propertyId.ToString("X");

                    Global.RO.Info("Testing presenceMode: {0}, format: {1}, formatResult: {2}, propertyId: {3:x} in locale: {4}",
                            presenceMode, format, formatResult, propertyId, spec.Locale);

                    // Change presence mode and pulse state on user A

                    b.ProcessNotifications(); 
                    gi.TitlePresence = presenceMode++;
                    a.SetTitleData(gi.GetBytes());

                    // Wait for delivery
                    noti = b.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
                    b.HandleTCPNotification(noti);

                    // Sanity check: Get the hashed buddy info with the rich presence string
                    PNUser.BuddyInfo info = b.GetBuddyInfo(a.UserId);
                    ValueCheck.TestNotNull("BuddyInfo", info);
                    ValueCheck.TestNotNull("BuddyInfo.RichPresence", info.RichPresenceData);
                    ValueCheck.TestNotNull("BuddyInfo.RichPresence.RichPresence(strdata)", info.RichPresenceData.RichPresenceString);
                    ValueCheck.TestNonZero("BuddyInfo.RichPresence", info.RichPresenceData.RichPresenceStringLength);
                    //ValueCheck.TestGreaterThan("BuddyInfo.RichPresence BuddyStateTime > lastBuddyStateTime", lastBuddyStateTime, info.BasicPresenceData.mtLastSeen);


                    // Create the valuecheck name with repro information and perform test
                    string testName = String.Format("FormattedPropertyCheck: UserA: {0:x} -> UserB: {1:x}, PropertyId: {2:x}, FormatResult: {3}",
                            a.UserId, b.UserId, propertyId, formatResult);

                    // TODO: I haven't rewritten
                    if (formatCheck)
                    {
                        ValueCheck.Test(testName, expected, info.RichPresenceData.RichPresenceString);
                    }
                    lastBuddyStateTime = info.BasicPresenceData.mtLastSeen;

                    //------------------------------------------------------------------------------
                    // Stage 2, one off query for get presence info
                    //------------------------------------------------------------------------------
                    PresenceInfo pi = b.GetPresenceInfo(a);
                    ValueCheck.TestNotNull("PresenceInfo", pi);
                    string piRichPresence = new UTF8Encoding().GetString(pi.szRichPresence);
                    ValueCheck.Test("PresenceInfo.RichPresence", info.RichPresenceData.RichPresenceString, piRichPresence);

                    //------------------------------------------------------------------------------
                    // Stage 3, web based enumerated rich presence 
                    //------------------------------------------------------------------------------
                    PWebFriendReplyMsgData data = b.GetWebFriends();
                    ValueCheck.TestNotNull("PWebFriendReplyMsgData", data);
                    ValueCheck.TestHR("PWebFriendsReplyMsgData.HR", HResult.S_OK, data.HR);
                    ValueCheck.Test("PWebFriendsReplyMsgData.UserID", b.UserId, data.UserID);
                    ValueCheck.Test("PWebFriendsReplyMsgData.cdwFriends", 1, data.cdwFriends);
                    ValueCheck.TestNotNull("PWebFriendsReplyMsgData.rgFriends", data.rgFriends);

                    // Test item in list
                    WebFriend wf = data.rgFriends[0];
                    ValueCheck.TestNotNull("WebFriend", wf);
                    ValueCheck.Test("WebFriend.BuddyID", a.UserId, wf.BuddyID);
                    //ValueCheck.Test("WebFriend.Status", a.Status, wf.Status);
                    ValueCheck.Test("WebFriend.OnlineState", a.State, wf.OnlineState);
                    ValueCheck.Test("WebFriend.TitleID", a.Xbox.TitleId, wf.TitleID);
                    ValueCheck.TestGreaterThan("WebFriend.mtLastActive", 0, (int)wf.mtLastActive);
                    ValueCheck.TestNonZero("WebFriend.cbRichPresence", wf.cbRichPresence);
                    ValueCheck.TestNotNull("WebFriend.szGamerTag", wf.szGamerTag);
                    ValueCheck.Test("WebFriend.szGamerTag", a.Name, wf.szGamerTag);
                    ValueCheck.Test("WebFriend.szRichPresence", expected, new UTF8Encoding().GetString(wf.szRichPresence));
                }
            }
        }

        //------------------------------------------------------------------------------
        // Ensure that user A has transmitted 0 bytes of rich presence string to user B
        //------------------------------------------------------------------------------
        void CheckEmptyRichPresence(PNUser a, PNUser b)
        {
            UserNotification noti = b.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
            b.HandleTCPNotification(noti);
            b.ProcessNotifications(); //adding this to make sure that all the notifications (basic and rich) are processed before making checks.
            ValueCheck.TestNotNull("b.BuddyInfo", b.GetBuddyInfo(a.UserId));
            ValueCheck.TestNotNull("b.BuddyInfo.RichPresence", b.GetBuddyInfo(a.UserId).RichPresenceData);
            ValueCheck.Test("b.BuddyInfo.RichPresence.RichPresence", "", b.GetBuddyInfo(a.UserId).RichPresenceData.RichPresenceString);
            ValueCheck.Test("b.BuddyInfo.RichPresence.RichPresence", 0, (int)b.GetBuddyInfo(a.UserId).RichPresenceData.RichPresenceStringLength);
        }

        //------------------------------------------------------------------------------
        // Ensure that user A has transmitted more than 0 bytes of rich presence
        // string to user B
        //------------------------------------------------------------------------------
        void CheckHasRichPresence(PNUser a, PNUser b)
        {
            UserNotification noti = b.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
            b.HandleTCPNotification(noti);

            ValueCheck.TestNotNull("b.BuddyInfo", b.GetBuddyInfo(a.UserId));
            ValueCheck.TestNotNull("b.BuddyInfo.RichPresence", b.GetBuddyInfo(a.UserId).RichPresenceData);
            ValueCheck.TestNotNull("b.BuddyInfo.RichPresence.RichPresence", b.GetBuddyInfo(a.UserId).RichPresenceData.RichPresenceString);
            ValueCheck.TestNonZero("b.BuddyInfo.RichPresence.RichPresence", b.GetBuddyInfo(a.UserId).RichPresenceData.RichPresenceStringLength);
        }

        //------------------------------------------------------------------------------
        // Run a property test for each locale by first generating a single config
        // that will exercise this property then running each format check against
        // that config.
        //------------------------------------------------------------------------------
        void RunPropertyTest(string[] formatStrings, GIProperty property)
        {
            // Create some new xenon users
            PNUser a = CreateXenonUser(false);
            PNUser b = CreateXenonUser(false);
            uint titleId = _BogusPublisher | _NextTitleCount;

            // Change to the generated title ID
            a.Xbox.ChangeTitle(titleId, 0, 0);
            b.Xbox.ChangeTitle(titleId, 0, 0);

            // Populate user properties (we really only care about one though)
            GIBlob gi = new GIBlob();
            gi.AddProperty(property);
            a.GIBlob = gi;
            b.GIBlob = gi;

            // Logon with our new title Id and make buddies
            _fc.LogonUser(a);
            _fc.LogonUser(b);
            _fc.MakeFriend(a, b);

            // Generate the presence mode strings and title config in DB
            GeneratePropertyTitleConfig(titleId, property.Id, formatStrings);

            // Check formatting per locale
            CheckPropertyFormatting(true, titleId, a, b, property.Id, gi, formatStrings, property.Value);
        }


        /// <summary>
        /// 	Rich presence formatting matrix with contexts from different locales
        /// </summary>
        /// <remarks>
        /// <Description>
        /// </Description>
        /// </remarks>
        [TestCase]
        public void P_RichPresenceFormatting_Contexts()
        {

            PNUser a = CreateXenonUser(false);
            PNUser b = CreateXenonUser(false);

            GIBlob giblobA = a.GIBlob;
            GIBlob giblobB = b.GIBlob;

            giblobA.TitlePresence = 0;
            giblobA.AddContext(GIContext.GAME_MODE, 0);
            giblobA.AddContext(1, 0);

            giblobB.TitlePresence = 0;
            giblobB.AddContext(GIContext.GAME_MODE, 0);
            giblobB.AddContext(1, 0);

            _fc.LogonUser(a);
            _fc.LogonUser(b);
            _fc.MakeFriend(a, b);

            for (int mode = 0; mode < 2; ++mode)
            {
                // The presence modes will be
                // 0: locale {cGAME_MODE} {c1}
                // 1: locale {c1} {cGAME_MODE}
                //
                // The contexts will be localized
                a.GIBlob.TitlePresence = (uint)mode;

                for (int contextValue = 0; contextValue < 3; ++contextValue)
                {
                    // Zero out the other mode change the current mode to the specified value
                    if (mode == 0)
                    {
                        a.GIBlob.SetContext((uint)1, (uint)0);
                        a.GIBlob.SetContext((uint)GIContext.GAME_MODE, (uint)contextValue);
                        _fc.LogoffUser(a);
                        _fc.LogonUser(a);
                    }
                    else
                    {
                        a.GIBlob.SetContext((uint)GIContext.GAME_MODE, (uint)0);
                        a.GIBlob.SetContext((uint)1, (uint)contextValue);
                        _fc.LogoffUser(a);
                        _fc.LogonUser(a);
                    }

                    // Perform this test for each locale
                    foreach (PresenceTitleConfig.LocaleSpec spec in PresenceTitleConfig.LocaleTable)
                    {
                        if (!spec.Supported)
                        {
                            continue;
                        }

                        Global.RO.Info(mode + ":" + contextValue + ":" + spec.Locale);

                        // language change now requires logoff
                        _fc.LogoffUser(b);
                        new SleepInfo("Waiting for logoff to settle", 4000);

                        // Change the ticket language ID
                        b.Xbox.LanguageId = spec.LanguageId;
                        b.LanguageId = spec.LanguageId;

                        // Change the ticket country ID in dwUserFlags
                        b.CountryId = spec.CountryId;

                        _fc.LogonUser(b); 
                        b.ProcessNotifications();
                        a.ProcessNotifications();

                        PNUser.BuddyInfo info = b.GetBuddyInfo(a.UserId);

                        // String validation of locale specific rich presence data
                        ValueCheck.TestNonZero("Presence2 length", info.RichPresenceData.RichPresenceStringLength);
                        string strData = info.RichPresenceData.RichPresenceString;

                        // RP string should begin with locale name
                        string match0 = spec.Locale;

                        int firstContext = mode;
                        int secondContext = 1 - mode;

                        // Next context depends on presence mode, context value part depends on current mode (see top of loop)
                        string match1 = match0 + "-ContextValue" + firstContext + "." + ((mode == firstContext) ? contextValue : 0);
                        string match2 = match0 + "-ContextValue" + secondContext + "." + ((mode == secondContext) ? contextValue : 0);

                        Global.RO.Debug(strData);
                        Global.RO.Debug(match1);
                        Global.RO.Debug(match2);
                        // Match the strings in the desired order in the rich presence string
                        int index0 = strData.IndexOf(match0);
                        if (index0 != 0 || index0 < 0) throw new UnexpectedTestResultException("Expected Match0(" + match0 + ") not found in first position");
                        int index1 = strData.IndexOf(match1, index0 + match0.Length);
                        if (index1 < 0) throw new UnexpectedTestResultException("Expected Match1(" + match1 + ") not found");
                        int index2 = strData.IndexOf(match2, index1 + match1.Length);
                        if (index2 < 0) throw new UnexpectedTestResultException("Expected Match2(" + match2 + ") not found");

                        if (index0 > index1 || index1 > index2)
                        {
                            throw new UnexpectedTestResultException("Condition index0 < index1 < index2 not met for string: " + strData);
                        }
                    }
                }
            }
        }


        /// <summary>
        /// 	Rich presence formatting matrix: LONG
        /// </summary>
        /// <remarks>
        /// <Description>
        /// 	<p>
        /// 	Each iteration will cover 1 available presence modes for each locale. See postive description
        /// 	block for senumerated locales.
        /// 	</p>
        ///
        /// 	<div class="test_data_label">
        /// 	The following format strings will be tested for the long type
        /// 	</div>
        /// 	<ul>
        /// 		<li>Currency: c</li>
        /// 		<li>Decimal: d</li>
        /// 		<li>General: g</li>
        /// 		<li>Number: n</li>
        /// 		<li>Percent: p</li>
        /// 		<li>Hexidecimal: x</li>
        /// 	</ul>
        /// </Description>
        /// </remarks>
        [TestCase]
        public void P_Format_Long()
        {
            string[] formatStrings = new string[] { "c", "d", "g", "n", "p", "x" };
            RunPropertyTest(formatStrings, new GIProperty(GITypes.XONLINE_STAT_LONG | 0x0001, 10));
        }

        /// <summary>
        /// 	Rich presence formatting matrix: LONGLONG
        /// </summary>
        /// <remarks>
        /// <Description>
        /// 	<p>
        /// 	Each iteration will cover 1 available presence modes for each locale. See postive description
        /// 	block for senumerated locales.
        /// 	</p>
        ///
        /// 	<p>
        /// 	LONGLONGs can be used in place of filetimes so we will also run date times through the date
        /// 	tests.
        /// 	</p>
        ///
        /// 	<div class="test_data_label">
        /// 	The following format strings will be tested for the float type
        /// 	</div>
        /// 	<ul>
        /// 		<li>Currency: c</li>
        /// 		<li>Decimal: d</li>
        /// 		<li>General: g</li>
        /// 		<li>Number: n</li>
        /// 		<li>Percent: p</li>
        /// 		<li>Hexidecimal: x</li>
        /// 	</ul>
        /// </Description>
        /// </remarks>
        [TestCase]
        public void P_Format_LongLong()
        {
            string[] formatStrings = new string[] { "c", "g", "n", "p", "x" };
            RunPropertyTest(formatStrings, new GIProperty(GITypes.XONLINE_STAT_LONGLONG | 0x0001, 10L));
        }

        /// <summary>
        /// 	Rich presence formatting matrix: DOUBLE
        /// </summary>
        /// <remarks>
        /// <Description>
        /// 	<p>
        /// 	Each iteration will cover 1 available presence modes for each locale. See postive description
        /// 	block for senumerated locales.
        /// 	</p>
        ///
        /// 	<div class="test_data_label">
        /// 	The following format strings will be tested for the double type
        /// 	</div>
        /// 	<ul>
        /// 		<li>Currency: c</li>
        /// 		<li>Float trunc: g</li>
        /// 		<li>Float float: f</li>
        /// 		<li>Float noprec: f</li>
        /// 		<li>Float .4prec: f</li>
        /// 		<li>Float .16prec: f</li>
        /// 		<li>Float .16prec: f</li>
        /// 		<li>Decimal: d</li>
        /// 		<li>General: g</li>
        /// 		<li>Number: n</li>
        /// 		<li>Percent: p</li>
        /// 		<li>Hexidecimal: x</li>
        /// 	</ul>
        /// </Description>
        /// </remarks>
        [TestCase]
        public void P_Format_Double()
        {
            string[] formatStrings = new string[] { "c", "g", "f", "f.0", "f.4", "f.8", "f.16", "g", "n", "p" };
            RunPropertyTest(formatStrings, new GIProperty(GITypes.XONLINE_STAT_DOUBLE | 0x0001, 10.123456789123456789));
        }

        /// <summary>
        /// 	Rich presence formatting matrix: LPCWSTR
        /// </summary>
        /// <remarks>
        /// <Description>
        /// 	<p>
        /// 	Each iteration will cover 1 available presence modes for each locale. See postive description
        /// 	block for senumerated locales.
        /// 	</p>
        ///
        /// 	<div class="test_data_label">
        /// 	The following format strings will be tested for the string type
        /// 	</div>
        /// 	<ul>
        /// 		<li>String: s</li>
        /// 	</ul>
        /// </Description>
        /// </remarks>
        [TestCase]
        public void P_Format_LPCWSTR()
        {
            string[] formatStrings = new string[] { "s" };
            RunPropertyTest(formatStrings, new GIProperty(GITypes.XONLINE_STAT_LPCWSTR, "test string"));
            RunPropertyTest(formatStrings, new GIProperty(GITypes.XONLINE_STAT_LPCWSTR, RandomEx.GlobalRandGen.GenerateUnicodeString(30)));
        }

        /// <summary>
        /// 	Rich presence formatting matrix: FLOAT
        /// </summary>
        /// <remarks>
        /// <Description>
        /// 	<p>
        /// 	Each iteration will cover 1 available presence modes for each locale. See postive description
        /// 	block for senumerated locales.
        /// 	</p>
        ///
        /// 	<div class="test_data_label">
        /// 	The following format strings will be tested for the float type
        /// 	</div>
        /// 	<ul>
        /// 		<li>Currency: c</li>
        /// 		<li>Fixed: f</li>
        /// 		<li>Fixed .4prec: f</li>
        /// 		<li>Fixed .16prec: f</li>
        /// 		<li>Fixed .16prec: f</li>
        /// 		<li>Decimal: d</li>
        /// 		<li>General: g</li>
        /// 		<li>Number: n</li>
        /// 		<li>Percent: p</li>
        /// 		<li>Hexidecimal: x</li>
        /// 	</ul>
        /// </Description>
        /// </remarks>
        [TestCase]
        public void P_Format_Float()
        {
            string[] formatStrings = new string[] { "F2" };
            uint titleId = _BogusPublisher | _NextTitleCount;
            RunPropertyTest(formatStrings, new GIProperty(GITypes.XONLINE_STAT_FLOAT | 0x0001, 123.45f));
        }

        /// <summary>
        /// 	Rich presence formatting matrix: DATETIME
        /// </summary>
        /// <remarks>
        /// <Description>
        /// 	<p>
        /// 	Each iteration will cover 1 available presence modes for each locale. See postive description
        /// 	block for senumerated locales.
        /// 	</p>
        ///
        /// 	<div class="test_data_label">
        /// 	The following format strings will be tested for the datetime type
        /// 	</div>
        /// 	<ul>
        /// 		<li>Short date: d</li>
        /// 		<li>Long date: D</li>
        /// 		<li>Short time: t</li>
        /// 		<li>Long time: T</li>
        /// 		<li>Full date/time (short): f</li>
        /// 		<li>Full date/time (long): F</li>
        /// 		<li>General date/time: g</li>
        /// 		<li>Month day: m</li>
        /// 		<li>RFC1123: r</li>
        /// 		<li>Sortable: s</li>
        /// 		<li>Universal sortable: U</li>
        /// 		<li>Year/month: Y</li>
        /// 	</ul>
        /// </Description>
        /// </remarks>
        [TestCase]
        public void P_Format_DateTime()
        {
            string[] formatStrings = new string[] { "F2" };
            uint titleId = _BogusPublisher | _NextTitleCount;
            RunPropertyTest(formatStrings, new GIProperty(GITypes.XONLINE_STAT_DATETIME | 0x0001, DateTime.Now));
        }

        /// <summary>
        /// Run a mix of format strings and GI blob configurations
        /// </summary>
        /// <remarks>
        /// <Description>
        /// </Description>
        /// </remarks>
        [TestCase]
        [Ignore]
        public void P_Format_Mixed_Properties()
        {
            GIProperty[] props = new GIProperty[6];
            props[0] = new GIProperty(GITypes.XONLINE_STAT_LONG | 0x0001, (int)0x1234abcd);
            props[1] = new GIProperty(GITypes.XONLINE_STAT_LONGLONG | 0x0001, (long)0x7aaabbbbccccdddd);
            props[2] = new GIProperty(GITypes.XONLINE_STAT_DOUBLE | 0x0001, 123.45);
            props[3] = new GIProperty(GITypes.XONLINE_STAT_LPCWSTR | 0x0001, "test string");
            props[4] = new GIProperty(GITypes.XONLINE_STAT_FLOAT | 0x0001, 123.45f);

            uint titleId = _BogusPublisher | _NextTitleCount;
            string[] formatStrings = new string[]{
                PropertySpecifier(props[0], "d") + " " +
                PropertySpecifier(props[1], "d") + " " +
                PropertySpecifier(props[2], "f") + " " +
                PropertySpecifier(props[3], "s") + " " +
                PropertySpecifier(props[4], "f")
            };

            GenerateTitleConfig(titleId, formatStrings);

            // Create some new xenon users
            PNUser a = CreateXenonUser(false);
            PNUser b = CreateXenonUser(false);

            // Change to the generated title ID
            a.Xbox.ChangeTitle(titleId, 0, 0);
            b.Xbox.ChangeTitle(titleId, 0, 0);

            // Populate user properties (we really only care about one though)
            GIBlob gi = new GIBlob();
            gi.AddProperty(props[0]);
            gi.AddProperty(props[1]);
            gi.AddProperty(props[2]);
            gi.AddProperty(props[3]);
            gi.AddProperty(props[4]);
            a.GIBlob = gi;
            b.GIBlob = gi;

            // Logon with our new title Id and make buddies
            _fc.LogonUser(a);
            _fc.LogonUser(b);
            _fc.MakeFriend(a, b);


            // Use the check property formatting routine but skip the formatting check. We will just make sure
            // we actually get some data and it matches across APIs
            CheckPropertyFormatting(false, titleId, a, b, 0xffffffff, gi, formatStrings, 0);
        }

        string PropertySpecifier(GIProperty prop, string formatSpec)
        {
            return "{p0x" + prop.Id.ToString("X") + ":" + formatSpec + "}";
        }


        /// <summary>
        /// Format a context with a large value set > 1000, use case sports game
        /// </summary>
        /// <remarks>
        /// <Description>
        /// </Description>
        /// </remarks>
        [TestCase]
        public void P_Format_LargeContextValueSet()
        {
            string[] formatStrings = new string[] { "F2" };
            uint titleId = _BogusPublisher | _NextTitleCount;
            RunPropertyTest(formatStrings, new GIProperty(GITypes.XONLINE_STAT_FLOAT | 0x0001, 123.45f));
        }


        /// <summary>
        /// Run the formatter on a GI blob with a context that has not been loaded
        /// </summary>
        [TestCase]
        public void P_Format_No_Contexts_Loaded()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(true);
            _fc.MakeFriend(a, b);

            a.GIBlob.TitlePresence = 0;
            a.SetTitleData();
            CheckEmptyRichPresence(a, b);
        }

        /// <summary>
        ///  Run the formatter on GI blob with title mode of 1 without loading presence modes for that title
        /// </summary>
        [TestCase]
        public void P_Format_No_Presence_Modes_Loaded()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(true);
            _fc.MakeFriend(a, b);

            //To clean out previuos stuff.
            a.ProcessNotifications();
            b.ProcessNotifications();

            a.SetTitleData( a.State | 0x00050000 );
            try
            {
                CheckEmptyRichPresence(a, b);
                Global.RO.Error("Should not reach here.");
            }
            catch (TimeOutException exp)
            {
                Global.RO.Debug("Did not recive Rich presence notification as expected." + exp.Message);
            }
        }

        /// <summary>
        /// Run the formatter on a GI blob with a fall through on the presence mode locale to default
        /// </summary>
        [TestCase]
        public void P_Format_PresenceMode_Fallthrough_To_Default_Locale_Unknown_Language()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(false);

            // Set user B to an unsupported user language
            // console language
            b.Xbox.LanguageId = (byte)PresenceTitleConfig.LanguageId.RU;
            // user language
            b.LanguageId = (byte)PresenceTitleConfig.LanguageId.DA;
            // user country
            b.CountryId = (byte)PresenceTitleConfig.CountryId.DK;

            _fc.LogonUser(b);
            _fc.MakeFriend(a, b);

            a.GIBlob.TitlePresence = 0;
            a.GIBlob.AddContext(GIContext.GAME_MODE, 0);
            a.GIBlob.AddContext(0x00000001, 0);
            a.SetTitleData();
            CheckHasRichPresence(a, b);

            ValueCheck.IsTrue(b.GetBuddyInfo(a.UserId).RichPresenceData.RichPresenceString.Contains("ru-RU"), "Default locale string in format");
        }

        /// <summary>
        /// Run the formatter on a GI blob with a fall through on the presence mode locale to default
        /// </summary>
        [TestCase]
        public void P_Format_PresenceMode_Fallthrough_To_Default_Locale()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(false);

            // Set user B to an unsupported country
            b.Xbox.RestrictLanguageToSupported = false;
            b.Xbox.LanguageId = (byte)PresenceTitleConfig.LanguageId.SV;
            b.LanguageId = (byte)PresenceTitleConfig.LanguageId.SV;
            b.CountryId = (byte)PresenceTitleConfig.CountryId.SE;

            _fc.LogonUser(b);
            new SleepInfo("Waiting for logon to settle", 4000);
            
            _fc.MakeFriend(a, b);
            b.ProcessNotifications();

            a.GIBlob.TitlePresence = 0;
            a.GIBlob.AddContext(GIContext.GAME_MODE, 0);
            a.GIBlob.AddContext(0x00000001, 0);
            a.SetTitleData();
            new SleepInfo("Waiting for settitledata to settle", 4000);
            
            CheckHasRichPresence(a, b);

            ValueCheck.IsTrue(b.GetBuddyInfo(a.UserId).RichPresenceData.RichPresenceString.Contains("en-US"), "Default locale string in format");
        }

        /// <summary>
        /// Run the formatter on a GI blob with a fall through on the presence mode locale to default
        /// </summary>
        [TestCase]
        public void P_Format_PresenceMode_Fallthrough_To_Default_Language_Locale()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(false);

            // Set user B to an unsupported country/language pair
            b.Xbox.LanguageId = (byte)PresenceTitleConfig.LanguageId.FR;
            b.LanguageId = (byte)PresenceTitleConfig.LanguageId.FR;
            b.CountryId = (byte)PresenceTitleConfig.CountryId.US;

            _fc.LogonUser(b);
            _fc.MakeFriend(a, b);

            a.GIBlob.TitlePresence = 0;
            a.GIBlob.AddContext(GIContext.GAME_MODE, 0);
            a.GIBlob.AddContext(0x00000001, 0);
            a.SetTitleData();
            CheckHasRichPresence(a, b);

            ValueCheck.IsTrue(b.GetBuddyInfo(a.UserId).RichPresenceData.RichPresenceString.Contains("fr-FR"), "Default locale string in format");
        }

        /// <summary>
        /// Run the formatter with a presence mode that is outside the range of valid modes
        /// </summary>
        [TestCase]
        public void P_Format_PresenceMode_Out_Of_Bounds()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(true);
            _fc.MakeFriend(a, b);

            a.GIBlob.TitlePresence = 1000;
            a.GIBlob.AddContext(GIContext.GAME_MODE, 0);
            a.GIBlob.AddContext(0x00000001, 0);
            a.SetTitleData();
            CheckEmptyRichPresence(a, b);
        }

        /// <summary>
        ///  Run the formatter with a format context {c###} outside context range bounds
        /// </summary>
        [TestCase]
        public void P_Format_Context_Out_Of_Bounds()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(true);
            _fc.MakeFriend(a, b);

            a.GIBlob.TitlePresence = 0;
            a.GIBlob.AddContext(GIContext.GAME_MODE, 100000);
            a.GIBlob.AddContext(0x00000001, 200000);
            a.SetTitleData();
            CheckEmptyRichPresence(a, b);
        }

        /// <summary>
        ///  Run the formatter with a format property {p###} outside context range bounds
        /// </summary>
        [TestCase]
        public void P_Format_Property_Out_Of_Bounds()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(true);
            _fc.MakeFriend(a, b);

            a.GIBlob.TitlePresence = 2;
            a.GIBlob.AddProperty(new GIProperty(GITypes.XONLINE_STAT_LONG | 0xffff, 0));
            a.SetTitleData();
            CheckEmptyRichPresence(a, b);
        }

        /// <summary>
        /// Load a realistic working set of titles into the cache
        /// then replace them with a set with deleted, modified, and added entries
        /// </summary>
        [TestCase]
        public void P_TitleConfig_Load_Then_Replace()
        {
            //
            // Test settings
            //
            uint nContexts = 6;
            uint nContextValuesPerContext = 10;
            uint nPresenceModes = 6;
            uint nTitles = 5;

            uint titleCount = 0;
            uint tempTitleCount = _TitleCount; // Store the current TitleCount so we can use it to replace the configs

            ProgressInfo progress = new ProgressInfo("Propping title configs", nTitles * 2, 1); // 2x #Titles (fill + replace)

            // Config Fill Step
            while (titleCount++ < nTitles)
            {
                PresenceTitleConfig config = new PresenceTitleConfig((int)(_BogusPublisher | _NextTitleCount));

                // Generate contests->context values
                Context[] contexts = new Context[nContexts];
                for (uint i = 0; i < nContexts; ++i)
                {
                    contexts[i] = config.AddContext(i, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextName" + i));

                    for (uint j = 0; j < nContextValuesPerContext; ++j)
                    {
                        ContextValue cv = contexts[i].AddContextValue(j, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextValue" + i + "." + j));
                    }
                }

                PresenceMode[] modes = new PresenceMode[nPresenceModes];

                // Generate presence modes
                for (uint i = 0; i < nPresenceModes; ++i)
                {
                    modes[i] = config.AddPresenceMode(i, config.AddDefaultLocalizedString(config.DefaultLocale + " {c0} {c1} {c2} {c3} {c4} {c5} PresenceMode" + i));
                }

                // Generate the locale strings
                foreach (PresenceTitleConfig.LocaleSpec spec in PresenceTitleConfig.LocaleTable)
                {
                    // Don't repopulate the default locale
                    if (spec.Locale == config.DefaultLocale)
                    {
                        continue;
                    }

                    // Only supported locales
                    if (!spec.Supported)
                    {
                        continue;
                    }

                    for (uint i = 0; i < nContexts; ++i)
                    {
                        config.AddLocalizedString(contexts[i].StringId, spec.Locale, spec.Locale + "-ContextName" + i);
                        for (uint j = 0; j < nContextValuesPerContext; ++j)
                        {
                            ContextValue cv = contexts[i].GetContextValue(j);
                            config.AddLocalizedString(cv.StringId, spec.Locale, spec.Locale + "-ContextValue" + i + "." + j);
                        }
                    }

                    for (uint i = 0; i < nPresenceModes; ++i)
                    {
                        config.AddLocalizedString(modes[i].StringId, spec.Locale, spec.Locale + " {c0} {c1} {c2} {c3} {c4} {c5} PresenceMode" + i);
                    }
                }

                config.WriteToDatabase(true);
                progress.Step();
            }

            // Refresh the Cache to Load from Database
            progress.SetMessage("Forcing config cache refresh");
            Global.XEnv.ExecuteXmgmtCommand(Interface.xpnfd_presence, "e :xpnfd configcacherefresh");

            // Config Replace Step
            titleCount = 0;
            _TitleCount = tempTitleCount;

            // Less Contexts, Values, and Presence Modes
            nContexts = 2;
            nContextValuesPerContext = 3;
            nPresenceModes = 2;

            while (titleCount++ < nTitles)
            {
                PresenceTitleConfig config = new PresenceTitleConfig((int)(_BogusPublisher | _NextTitleCount));

                // Generate contests->context values
                Context[] contexts = new Context[nContexts];
                for (uint i = 0; i < nContexts; ++i)
                {
                    contexts[i] = config.AddContext(i, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextName" + i));

                    for (uint j = 0; j < nContextValuesPerContext; ++j)
                    {
                        ContextValue cv = contexts[i].AddContextValue(j, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextValue" + i + "." + j));
                    }
                }

                PresenceMode[] modes = new PresenceMode[nPresenceModes];

                // Generate presence modes
                for (uint i = 0; i < nPresenceModes; ++i)
                {
                    modes[i] = config.AddPresenceMode(i, config.AddDefaultLocalizedString(config.DefaultLocale + " {c0} {c1} {c2} {c3} {c4} {c5} PresenceMode" + i));
                }

                // Generate the locale strings
                foreach (PresenceTitleConfig.LocaleSpec spec in PresenceTitleConfig.LocaleTable)
                {
                    // Don't repopulate the default locale
                    if (spec.Locale == config.DefaultLocale)
                    {
                        continue;
                    }

                    // Only supported locales
                    if (!spec.Supported)
                    {
                        continue;
                    }

                    for (uint i = 0; i < nContexts; ++i)
                    {
                        config.AddLocalizedString(contexts[i].StringId, spec.Locale, spec.Locale + "-ContextName" + i);
                        for (uint j = 0; j < nContextValuesPerContext; ++j)
                        {
                            ContextValue cv = contexts[i].GetContextValue(j);
                            config.AddLocalizedString(cv.StringId, spec.Locale, spec.Locale + "-ContextValue" + i + "." + j);
                        }
                    }

                    for (uint i = 0; i < nPresenceModes; ++i)
                    {
                        config.AddLocalizedString(modes[i].StringId, spec.Locale, spec.Locale + " {c0} {c1} {c2} {c3} {c4} {c5} PresenceMode" + i);
                    }
                }

                config.WriteToDatabase(true);
                progress.Step();
            }

            progress.SetMessage("Forcing config cache refresh");
            Global.XEnv.ExecuteXmgmtCommand(Interface.xpnfd_presence, "e :xpnfd configcacherefresh");
            progress.Finish();
        }

        /// <summary>
        /// Load a realistic working set of titles into the cache, this is based off of quake 4 xlast file stats
        /// </summary>
        [TestCase]
        public void P_Realistic_TitleConfig_WorkingSet_Load_All()
        {
            // Quake 4 has ~200 localized strings x number of locales
            // Quake 4 has ~60 context values (we'll average them out to 10 per context)
            // Quake 4 has ~6 presence modes
            //
            // Let's see how that scales up 


            //
            // Test settings
            //
            uint nContexts = 6;
            uint nContextValuesPerContext = 10;
            uint nPresenceModes = 6;
            uint nTitles = 500;

            uint titleCount = 0;

            ProgressInfo progress = new ProgressInfo("Propping title configs", 500, 1);

            while (titleCount++ < nTitles)
            {
                PresenceTitleConfig config = new PresenceTitleConfig((int)(_BogusPublisher | _NextTitleCount));

                // Generate contests->context values
                Context[] contexts = new Context[nContexts];
                for (uint i = 0; i < nContexts; ++i)
                {
                    contexts[i] = config.AddContext(i, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextName" + i));

                    for (uint j = 0; j < nContextValuesPerContext; ++j)
                    {
                        ContextValue cv = contexts[i].AddContextValue(j, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextValue" + i + "." + j));
                    }
                }

                PresenceMode[] modes = new PresenceMode[nPresenceModes];

                // Generate presence modes
                for (uint i = 0; i < nPresenceModes; ++i)
                {
                    modes[i] = config.AddPresenceMode(i, config.AddDefaultLocalizedString(config.DefaultLocale + " {c0} {c1} {c2} {c3} {c4} {c5} PresenceMode" + i));
                }

                // Generate the locale strings
                foreach (PresenceTitleConfig.LocaleSpec spec in PresenceTitleConfig.LocaleTable)
                {
                    // Don't repopulate the default locale
                    if (spec.Locale == config.DefaultLocale)
                    {
                        continue;
                    }

                    // Only supported locales
                    if (!spec.Supported)
                    {
                        continue;
                    }

                    for (uint i = 0; i < nContexts; ++i)
                    {
                        config.AddLocalizedString(contexts[i].StringId, spec.Locale, spec.Locale + "-ContextName" + i);
                        for (uint j = 0; j < nContextValuesPerContext; ++j)
                        {
                            ContextValue cv = contexts[i].GetContextValue(j);
                            config.AddLocalizedString(cv.StringId, spec.Locale, spec.Locale + "-ContextValue" + i + "." + j);
                        }
                    }

                    for (uint i = 0; i < nPresenceModes; ++i)
                    {
                        config.AddLocalizedString(modes[i].StringId, spec.Locale, spec.Locale + " {c0} {c1} {c2} {c3} {c4} {c5} PresenceMode" + i);
                    }
                }


                config.WriteToDatabase(true);
                progress.Step();
            }
            progress.SetMessage("Forcing config cache refresh");
            Global.XEnv.ExecuteXmgmtCommand(Interface.xpnfd_presence, "e :xpnfd configcacherefresh");
            progress.Finish();
        }

        /// <summary>
        /// Load a realistic working set of titles into the cache, this is based off of quake 4 xlast file stats
        /// </summary>
        [TestCase]
        public void P_Realistic_TitleConfig_Large_Context_Enums()
        {
            //
            // Test settings
            //
            uint nContexts = 6;
            uint nContextValuesPerContext = 1250;
            uint nPresenceModes = 6;
            PresenceTitleConfig config = new PresenceTitleConfig((int)(_BogusPublisher | _NextTitleCount));

            // Generate contests->context values
            Context[] contexts = new Context[nContexts];
            for (uint i = 0; i < nContexts; ++i)
            {
                contexts[i] = config.AddContext(i, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextName" + i));

                for (uint j = 0; j < nContextValuesPerContext; ++j)
                {
                    ContextValue cv = contexts[i].AddContextValue(j, config.AddDefaultLocalizedString(config.DefaultLocale + "-ContextValue" + i + "." + j));
                }
            }

            PresenceMode[] modes = new PresenceMode[nPresenceModes];

            // Generate presence modes
            for (uint i = 0; i < nPresenceModes; ++i)
            {
                modes[i] = config.AddPresenceMode(i, config.AddDefaultLocalizedString(config.DefaultLocale + " {c0} {c1} {c2} {c3} {c4} {c5} PresenceMode" + i));
            }

            // Generate the locale strings
            foreach (PresenceTitleConfig.LocaleSpec spec in PresenceTitleConfig.LocaleTable)
            {
                // Don't repopulate the default locale
                if (spec.Locale == config.DefaultLocale)
                {
                    continue;
                }

                // Only supported locales
                if (!spec.Supported)
                {
                    continue;
                }

                for (uint i = 0; i < nContexts; ++i)
                {
                    config.AddLocalizedString(contexts[i].StringId, spec.Locale, spec.Locale + "-ContextName" + i);
                    for (uint j = 0; j < nContextValuesPerContext; ++j)
                    {
                        ContextValue cv = contexts[i].GetContextValue(j);
                        config.AddLocalizedString(cv.StringId, spec.Locale, spec.Locale + "-ContextValue" + i + "." + j);
                    }
                }

                for (uint i = 0; i < nPresenceModes; ++i)
                {
                    config.AddLocalizedString(modes[i].StringId, spec.Locale, spec.Locale + " {c0} {c1} {c2} {c3} {c4} {c5} PresenceMode" + i);
                }
            }


            config.WriteToDatabase(true);
            Global.XEnv.ExecuteXmgmtCommand(Interface.xpnfd_presence, "e :xpnfd configcacherefresh");
        }
    }

    /// <summary>
    /// Negative Functional Tests for the Rich Presence String Formatter
    /// </summary>
    [TestGroup, TestFrequency("Daily"), TestCasePriority(2)]
    class FuncRichPresenceFormatting_NegativeCases : TestNode
    {
        /// <summary>
        /// Attempt to load an unsupported locale string
        /// </summary>
        [TestCase, Ignore]
        public void N_Load_Unsupported_Locale()
        {
        }

        /// <summary>
        /// Overflow the format string with 9 contexts
        /// </summary>
        [TestCase, Ignore]
        public void N_FormatString_Too_Many_Contexts()
        {
        }

        /// <summary>
        /// Overflow the format string with 9 properties
        /// </summary>
        [TestCase, Ignore]
        public void N_FormatString_Too_Many_Properties()
        {
        }

        /// <summary>
        /// Overflow the format string with 1 property
        /// </summary>
        [TestCase, Ignore]
        public void N_FormatString_8Contexts_1Property()
        {
        }

        /// <summary>
        /// Overflow the format string with 1 context
        /// </summary>
        [TestCase, Ignore]
        public void N_FormatString_8Properties_1Context()
        {
        }

    }
} // namespace PresenceTest
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\gameconfigtest.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using System.IO;
using System.Net;
using System.Web;
using System.Xml;
using System.Xml.XPath;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.Utilities;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.service;
using xonline.common.sql.sqlclient;

namespace xonline.server.presence.test.dvt.presence
{
    [TestGroup, DVT, TestFrequency("Regression"), TestCasePriority(3), Ignore("Originally created for title propping in frontdoor")]
    public class PropConfigTests : TestNode
    {
        public const uint    c_titleId = 0x00004d2;
        public const uint    c_titleId_2 = 0x0000673;
        private static Report report = new Report("PropConfigTests");
        public const string  testXDK   = "PRESTEST";

        string GetGameConfig(uint titleId)
        {
            SqlClient       cmd = new SqlClient(Interface.npdb);
            uint            hr;
            DateTime        dt_changed;
            string          xml_config = null;

            cmd.StoredProc = "p_game_get_config";
            cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);
            cmd.AddParameter("@i_title_id", titleId);

            SqlDataReader reader = cmd.Execute();
            hr = (uint)cmd.GetIntParameter("@ret");

            while(reader.Read())
            {
                Assert.IsTrue( titleId == (uint)(int)reader["i_title_id"], "GetGameConfig returned data for an un-requested title" );

                dt_changed = (DateTime)reader["dt_changed"];
                xml_config = (string)reader["xml_config"];
            }

            return xml_config;
        }

        string [] GetAllGameConfigs(DateTime lastUpdate)
        {
            SqlClient   cmd = new SqlClient(Interface.npdb);
            uint        hr;
            uint        titleId;
            DateTime    dt_changed;
            string      xml_config;
            ArrayList   configs = new ArrayList();

            cmd.StoredProc = "p_game_get_all_configs";
            cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);
            cmd.AddParameter("@dt_changed", lastUpdate);

            SqlDataReader reader = cmd.Execute();
            hr = (uint)cmd.GetIntParameter("@ret");

            while(reader.Read())
            {
                titleId = (uint)(int)reader["i_title_id"];
                dt_changed = (DateTime)reader["dt_changed"];

                Assert.IsTrue(dt_changed >= lastUpdate, "GetAllGameConfigs returned data older than requested" );

                xml_config = (string)reader["xml_config"];

                configs.Add(xml_config);
            }

            return (string [])configs.ToArray(typeof(string));
        }

        uint SetGameConfig(uint titleId, string xml_config)
        {

            SqlClient       cmd = new SqlClient(Interface.npdb);
            uint            hr;

            cmd.StoredProc = "p_game_save_config";
            cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);
            cmd.AddParameter("@i_title_id", titleId);
            cmd.AddParameter("@xml_config", xml_config);
            cmd.AddParameter("@vc_xdk_version", testXDK);

            cmd.ExecuteNonQuery();
            hr = (uint)cmd.GetIntParameter("@ret");

            return hr;

        }

        uint RemoveGameConfig(uint titleId)
        {
            SqlClient       cmd = new SqlClient(Interface.npdb);
            uint            hr;

            cmd.StoredProc = "p_game_delete_config";
            cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);
            cmd.AddParameter("@i_title_id", titleId);

            cmd.ExecuteNonQuery();
            hr = (uint)cmd.GetIntParameter("@ret");

            return hr;
        }

        [TestCase]
        public void TestGameConfigAdd()
        {
            uint hr;
            const string xml_config = "This is the game config";
            string xml_output;

            hr = SetGameConfig(c_titleId, xml_config);

            Assert.IsTrue( HResult.Succeeded(hr),       "TestGameConfigAdd failed unexpectedly." );

            xml_output = GetGameConfig(c_titleId);

            Assert.IsTrue( xml_output == xml_config,    "TestGameConfigAdd returned different config data than was set" );

            hr = RemoveGameConfig(c_titleId);

            Assert.IsTrue( HResult.Succeeded(hr),       "TestGameConfigAdd failed unexpectedly." );

        }

        [TestCase]
        public void TestGameConfigAddMultiple()
        {
            uint hr;
            const string xml_config = "This is the game config";
            const string xml_config_2 = "This is the new game config";
            string xml_output;

            hr = SetGameConfig(c_titleId, xml_config);

            Assert.IsTrue( HResult.Succeeded(hr),       "TestGameConfigAddMultiple failed unexpectedly." );

            hr = SetGameConfig(c_titleId_2, xml_config_2);

            Assert.IsTrue( HResult.Succeeded(hr),       "TestGameConfigAddMultiple failed unexpectedly." );

            // Give SQL a moment to absorb the data we just poked in
            Thread.Sleep( 100 );

            xml_output = GetGameConfig(c_titleId_2);

            Assert.IsTrue( xml_output == xml_config_2,  "TestGameConfigAddMultiple returned different config data than was set" );

            hr = RemoveGameConfig(c_titleId);

            Assert.IsTrue( HResult.Succeeded(hr),       "TestGameConfigAddMultiple failed unexpectedly." );

            hr = RemoveGameConfig(c_titleId_2);

            Assert.IsTrue( HResult.Succeeded(hr),       "TestGameConfigAddMultiple failed unexpectedly." );

        }

        [TestCase]
        public void TestGameConfigRemove()
        {
            uint hr;
            const string xml_config = "This is the game config";
            string xml_output;

            hr = SetGameConfig(c_titleId, xml_config);

            Assert.IsTrue( HResult.Succeeded(hr),       "TestGameConfigRemove failed unexpectedly." );

            // Give SQL a moment to absorb the data we just poked in
            Thread.Sleep( 100 );

            hr = RemoveGameConfig(c_titleId);

            Assert.IsTrue( HResult.Succeeded(hr),       "TestGameConfigRemove failed unexpectedly." );

            xml_output = GetGameConfig(c_titleId);

            Assert.IsTrue( xml_output == null,          "TestGameConfigRemove returned data after it was removed" );
        }

        [TestCase]
        public void TestGameConfigUpdate()
        {
            uint hr;
            const string xml_config = "This is the game config";
            const string xml_config_2 = "This is the new game config";
            string xml_output;

            hr = SetGameConfig(c_titleId, xml_config);

            Assert.IsTrue( HResult.Succeeded(hr),       "TestGameConfigUpdate failed unexpectedly." );

            xml_output = GetGameConfig(c_titleId);

            Assert.IsTrue( xml_output == xml_config,    "TestGameConfigUpdate returned data after it was removed" );

            hr = SetGameConfig(c_titleId, xml_config_2);

            Assert.IsTrue( HResult.Succeeded(hr),       "TestGameConfigUpdate failed unexpectedly." );

            // Give SQL a moment to absorb the data we just poked in
            Thread.Sleep( 100 );

            xml_output = GetGameConfig(c_titleId);

            Assert.IsTrue( xml_output == xml_config_2,  "TestGameConfigUpdate returned data after it was removed" );

            hr = RemoveGameConfig(c_titleId);

            Assert.IsTrue( HResult.Succeeded(hr),       "TestGameConfigUpdate failed unexpectedly." );
        }

        [TestCase]
        public void TestGameConfigFetch()
        {
            uint hr;
            const string xml_config = "This is the game config";
            const string xml_config_2 = "This is the new game config";
            DateTime updateTime = new DateTime( 2001, 1, 1, 0, 0, 0, 0 );;
            string [] xml_output;

            hr = SetGameConfig(c_titleId, xml_config);

            Assert.IsTrue( HResult.Succeeded(hr),   "TestGameConfigFetch failed unexpectedly." );

            hr = SetGameConfig(c_titleId_2, xml_config_2);

            Assert.IsTrue( HResult.Succeeded(hr),   "TestGameConfigFetch failed unexpectedly." );

            // Give SQL a moment to absorb the data we just poked in
            Thread.Sleep( 100 );

            xml_output = GetAllGameConfigs(updateTime);

            Assert.IsTrue( xml_output.Length >= 2,  "TestGameConfigFetch returned too little data" );

            hr = RemoveGameConfig(c_titleId);

            Assert.IsTrue( HResult.Succeeded(hr),   "TestGameConfigFetch failed unexpectedly on Remove." );

            hr = RemoveGameConfig(c_titleId_2);

            Assert.IsTrue( HResult.Succeeded(hr),   "TestGameConfigFetch failed unexpectedly on Remove." );
        }

        [TestCase]
        public void TestGameConfigFetchUpdated()
        {
            uint hr;
            const string xml_config = "This is the game config";
            const string xml_config_2 = "This is the new game config";
            DateTime updateTime = new DateTime( 2001, 1, 1, 0, 0, 0, 0 );;
            bool found = false;
            string [] xml_output;

            hr = SetGameConfig(c_titleId, xml_config);

            Assert.IsTrue( HResult.Succeeded(hr),   "TestGameConfigFetchUpdated failed unexpectedly." );

            hr = SetGameConfig(c_titleId_2, xml_config_2);

            Assert.IsTrue( HResult.Succeeded(hr),   "TestGameConfigFetchUpdated failed unexpectedly." );

            xml_output = GetAllGameConfigs(updateTime);

            Assert.IsTrue( xml_output.Length >= 2,  "TestGameConfigFetchUpdated returned too little data 1" );

            Thread.Sleep(100);

            updateTime = DateTime.UtcNow;

            Thread.Sleep(100);

            hr = SetGameConfig(c_titleId, xml_config);

            Assert.IsTrue( HResult.Succeeded(hr),   "TestGameConfigFetchUpdated failed unexpectedly." );

            xml_output = GetAllGameConfigs(updateTime);

            foreach (string xml_out in xml_output)
            {
                if (xml_out.Equals(xml_config))
                {
                    found = true;
                    break;
                }
            }

            Assert.IsTrue( found,                   "TestGameConfigFetchUpdated returned too little data 2" );

            hr = RemoveGameConfig(c_titleId);

            Assert.IsTrue( HResult.Succeeded(hr),   "TestGameConfigFetchUpdated failed unexpectedly on Remove." );

            hr = RemoveGameConfig(c_titleId_2);

            Assert.IsTrue( HResult.Succeeded(hr),   "TestGameConfigFetchUpdated failed unexpectedly on Remove." );
        }

        [TestCase]
        public void TestPongPropConfig()
        {
            XmlDocument   xmlSchema = GameConfigTests.LoadConfigSchema(false);

            report.Debug("Config schema is no longer loaded into the NPDB config cache.");
            // SetGameConfig(0, xmlSchema.DocumentElement.OuterXml);

            XmlDocument   xmlDoc = GameConfigTests.LoadPongConfig(false);
            uint          titleId = GameConfigTests.ParseConfigForTitleId(xmlDoc);

            report.Debug("Loading pong.xlast into NPDB config cache.");

            SetGameConfig(titleId, xmlDoc.DocumentElement.OuterXml);
        }

    } // class GameConfigTests


    [TestGroup, DVT, TestFrequency("Regression"), TestCasePriority(3), Ignore("Originally created for title propping in frontdoor")]
    public class GameConfigTests : TestNode
    {
        static Report report = new Report("GameConfigTests");

        public static XmlDocument LoadPongConfig(bool fConsoleOutput)
        {
            string basePath = Environment.GetEnvironmentVariable("_NT386TREE");
            if(basePath == null || basePath == "")
            {
                basePath = @"Suites\";
            }
            else
            {
                basePath += @"\private\server\presence\test\presencedvt\";
            }
            string xml_config_path = basePath + "pong.xlast";

            report.Debug("Loading pong.xlast config file from " + xml_config_path);
            XmlDocument   xmlDoc = new XmlDocument();
            xmlDoc.Load(xml_config_path);

            if (fConsoleOutput)
            {
                XmlTextWriter writer = new XmlTextWriter(Console.Out);
                writer.Formatting = Formatting.Indented;
                xmlDoc.WriteContentTo( writer );
                writer.Flush();
                Console.WriteLine();
            }

            return xmlDoc;
        }

        public static XmlDocument LoadConfigSchema(bool fConsoleOutput)
        {
            string basePath = Environment.GetEnvironmentVariable("_NT386TREE");
            if(basePath == null || basePath == "")
            {
                basePath = @"Suites\";
            }
            else
            {
                basePath += @"\private\server\presence\test\presencedvt\";
            }
            string gi_xsd_path = basePath + "gi.xsd";

            report.Debug("Loading gi.xsd xml schema from " + gi_xsd_path);
            XmlDocument   xmlDoc = new XmlDocument();
            xmlDoc.Load(gi_xsd_path);

            if (fConsoleOutput)
            {
                XmlTextWriter writer = new XmlTextWriter(Console.Out);
                writer.Formatting = Formatting.Indented;
                xmlDoc.WriteContentTo( writer );
                writer.Flush();
                Console.WriteLine();
            }

            return xmlDoc;
        }

        public static void ValidatePongConfig(XmlDocument xmlDoc)
        {
            string basePath = Environment.GetEnvironmentVariable("_NT386TREE");
            if(basePath == null || basePath == "")
            {
                basePath = @"Suites\";
            }
            else
            {
                basePath += @"\private\server\presence\test\presencedvt\";
            }

            string gi_xsd_path = basePath + "gi.xsd";

            // Load the GI XSD from file
            XmlTextReader           xsdReader = new XmlTextReader(gi_xsd_path);

            // Create the validating reader to do the dirty work
            XmlReaderSettings xmlSettings = new XmlReaderSettings();
            xmlSettings.ValidationType = ValidationType.Schema;
            xmlSettings.Schemas.Add(@"http://www.xboxlive.com/xlast", xsdReader);

            NameTable               nt = new NameTable();
            XmlNamespaceManager     nsmgr = new XmlNamespaceManager(nt);

            XmlParserContext        context = new XmlParserContext(null, nsmgr, null, XmlSpace.None);

            XmlReader               vr = XmlReader.Create(xmlDoc.OuterXml, xmlSettings, context);

            // Run through the XML to validate it
            while (vr.Read())
            {
                // Do nothing, just move on to the next node
            }
        }

        public static void ValidatePongConfig(XmlDocument xmlData, XmlDocument xmlSchema)
        {
            // Load the GI XSD from file
            XmlNodeReader           xsdReader = new XmlNodeReader(xmlSchema);

            // Create the validating reader to do the dirty work
            XmlReaderSettings xmlSettings = new XmlReaderSettings();
            xmlSettings.ValidationType = ValidationType.Schema;
            xmlSettings.Schemas.Add(@"http://www.xboxlive.com/xlast", xsdReader);

            NameTable               nt = new NameTable();

            XmlParserContext        context = new XmlParserContext(nt, null, null, XmlSpace.None);
            XmlReader               vr = XmlReader.Create(xmlData.OuterXml, xmlSettings, context);

            // Run through the XML to validate it
            while (vr.Read())
            {
                // Do nothing, just move on to the next node
            }
        }

        public static uint ParseConfigForTitleId(XmlDocument xmlDoc)
        {
            if (xmlDoc == null)
            {
                xmlDoc = LoadPongConfig(false);
            }

            XPathNavigator          nav = xmlDoc.CreateNavigator();
            XmlNamespaceManager     nsmgr = new XmlNamespaceManager(nav.NameTable);
            XPathExpression         expr;
            uint                    titleId = 0;

            report.Debug("Parsing config file for TitleId");
            report.Debug("xml namespace for config file = " + xmlDoc.DocumentElement.NamespaceURI + ". Should be http://www.xboxlive.com/xlast");

            nsmgr.AddNamespace("xlast", "http://www.xboxlive.com/xlast");
            expr = nav.Compile("//xlast:GameConfigProject");
            expr.SetContext(nsmgr);
            XPathNodeIterator titleIterator = nav.Select(expr);

            Assert.IsTrue(titleIterator.Count == 1, "There should be only 1 GameConfigProject node in config file. Found " + titleIterator.Count);

            while(titleIterator.MoveNext())
            {
                string value = titleIterator.Current.GetAttribute("titleId", "");
                titleId = (uint)SafeConvert.ToInt32("0x" + value);
            }

            Assert.IsTrue(titleId != 0, "titleId attribute of GameConfigProject element not found, or titleId specified is 0 ");
            report.Debug("TitleID found for config file: TitleID=" + titleId.ToString("x8"));

            return titleId;
        }

        public static string ParseConfigForDefaultLocale(XmlDocument    xmlDoc)
        {
            if (xmlDoc == null)
            {
                xmlDoc = LoadPongConfig(false);
            }

            XPathNavigator          nav = xmlDoc.CreateNavigator();
            XmlNamespaceManager     nsmgr = new XmlNamespaceManager(nav.NameTable);
            XPathExpression         expr;
            string                  defaultLocale = "";

            report.Debug("Parsing config file for DefaultLocale");
            report.Debug("xml namespace for config file = " + xmlDoc.DocumentElement.NamespaceURI + ". Should be http://www.xboxlive.com/xlast");

            // Find the default string locale for this title
            nsmgr.AddNamespace("xlast", "http://www.xboxlive.com/xlast");

            expr = nav.Compile("//xlast:LocalizedStrings");
            expr.SetContext(nsmgr);
            XPathNodeIterator stringIterator = nav.Select(expr);

            Assert.IsTrue(stringIterator.Count == 1, "There should be only 1 LocalizedStrings node in config file. Found " + stringIterator.Count);

            while(stringIterator.MoveNext())
            {
                string value = stringIterator.Current.GetAttribute("defaultLocale", "");
                defaultLocale = value.Substring(0,2).ToLower() + value.Substring(2).ToUpper();
            }

            Assert.IsTrue(defaultLocale != "", "Default locale in config file was not found.");
            report.Debug("DefaultLocale found in config file: defaultLocale=" + defaultLocale);

            return defaultLocale;
        }

        public static void FindStringData(XPathNavigator nav, XmlNamespaceManager nsmgr, string stringId)
        {
            XPathExpression         expr;

            expr = nav.Compile("//xlast:LocalizedStrings/xlast:LocalizedString[@id='" + stringId + "']/xlast:Translation");
            expr.SetContext(nsmgr);

            XPathNodeIterator  stringIterator = nav.Select(expr);
            Assert.IsTrue(stringIterator.Count != 0, "String Translation elements not found. Expected at least 1 LocalizedString[@id='" + stringId + "']/Translation element");

            while(stringIterator.MoveNext())
            {
                string locale = stringIterator.Current.GetAttribute("locale", "");
                string data = stringIterator.Current.Value;

                report.Debug("ID:" + stringId + ", locale=" + locale + ", Data=" + data);
            }
        }

        public static void ParseConfigForStrings(XmlDocument xmlDoc)
        {
            if (xmlDoc == null)
            {
                xmlDoc = LoadPongConfig(false);
            }

            XPathNavigator          nav = xmlDoc.CreateNavigator();
            XmlNamespaceManager     nsmgr = new XmlNamespaceManager(nav.NameTable);
            XPathExpression         expr;
            string                  defaultLocale = "en-US";

            report.Debug("Parsing config file for Rich Presence Formatting data");
            report.Debug("xml namespace for config file = " + xmlDoc.DocumentElement.NamespaceURI + ". Should be http://www.xboxlive.com/xlast");

            nsmgr.AddNamespace("xlast", "http://www.xboxlive.com/xlast");

            defaultLocale = ParseConfigForDefaultLocale(xmlDoc);

            // Find the default string locale for this title
            expr = nav.Compile("//xlast:LocalizedStrings");
            expr.SetContext(nsmgr);
            XPathNodeIterator stringIterator = nav.Select(expr);

            report.Debug("Parsing config file for //LocalizedStrings[@defaultLocale]. Found " + stringIterator.Count + " LocalizedStrings elements" );
            Assert.IsTrue(stringIterator.Count != 0, "LocalizedStrings aggregate not found for titleId. ");
            while(stringIterator.MoveNext())
            {
                defaultLocale = stringIterator.Current.GetAttribute("defaultLocale", "en-US");
            }

            expr = nav.Compile("//xlast:Presence/xlast:PresenceMode");
            expr.SetContext(nsmgr);
            XPathNodeIterator presenceIterator = nav.Select(expr);

            report.Debug("Parsing config file for Format strings. Found " + presenceIterator.Count + " PresenceMode elements" );
            Assert.IsTrue(presenceIterator.Count != 0, "PresenceMode elements not found. Expected at least 1 PresenceMode element ");
            while(presenceIterator.MoveNext())
            {
                string contextValue = presenceIterator.Current.GetAttribute("contextValue", "");
                string fstringId = presenceIterator.Current.GetAttribute("stringId", "");

                uint context = (uint)SafeConvert.ToInt32(contextValue);
                report.Debug("Found Format String: Rich Presence Context=" + contextValue + ". string ID=" + fstringId);

                FindStringData(nav, nsmgr, fstringId );
            }

            expr = nav.Compile("//xlast:Contexts/xlast:Context");
            expr.SetContext(nsmgr);
            XPathNodeIterator contextIterator = nav.Select(expr);

            report.Debug("Parsing config file for Contexts. Found " + contextIterator.Count + " Context elements" );
            Assert.IsTrue(contextIterator.Count != 0, "Context elements not found. Expected at least 1 Context element ");
            while(contextIterator.MoveNext())
            {
                string contextId = contextIterator.Current.GetAttribute("id", "");
                string cstringId = contextIterator.Current.GetAttribute("stringId", "");

                uint context = (uint)SafeConvert.ToInt32(contextId);

                report.Debug("Found Context: ID=" + contextId + ". string ID=" + cstringId );

                FindStringData(nav, nsmgr, cstringId);

                expr = nav.Compile("//xlast:Contexts/xlast:Context[@id='" + contextId + "']/xlast:ContextValue");
                expr.SetContext(nsmgr);
                XPathNodeIterator contextValueIterator = nav.Select(expr);

                report.Debug("Parsing config file for ContextValue members of context " + contextId + ". Found " + contextValueIterator.Count + " ContextValue elements" );
                Assert.IsTrue(contextIterator.Count != 0, "ContextValue elements not found for context " + contextId + ". Expected at least 1 ContextValue element ");

                while(contextValueIterator.MoveNext())
                {
                    string value = contextValueIterator.Current.GetAttribute("value", "");
                    string cvstringId = contextValueIterator.Current.GetAttribute("stringId", "");

                    report.Debug("Found ContextValue: value=" + value + ". string ID=" + cvstringId );

                    FindStringData(nav, nsmgr, cvstringId);
                }

            }
        }

        [TestCase]
        public void TestPongLoadConfig()
        {
            XmlDocument   xmlDoc;

            xmlDoc = LoadPongConfig(true);
        }

        [TestCase]
        public void TestPongValidateConfig()
        {
            XmlDocument   xmlDoc;

            xmlDoc = LoadPongConfig(false);

            // Will throw if validation fails
            ValidatePongConfig(xmlDoc);
        }

        [TestCase]
        public void TestPongValidateConfig2()
        {
            XmlDocument   xmlData;
            XmlDocument   xmlSchema;

            xmlData = LoadPongConfig(false);
            xmlSchema = LoadConfigSchema(false);

            // Will throw if validation fails
            ValidatePongConfig(xmlData, xmlSchema);
        }

        [TestCase]
        public void TestPongParseTitleId()
        {
            uint  titleId = ParseConfigForTitleId(null);
        }

        [TestCase]
        public void TestPongParseDefaultLocale()
        {
            string defaultLocale = ParseConfigForDefaultLocale(null);
        }

        [TestCase]
        public void TestParsePongConfigForStrings()
        {
            ParseConfigForStrings(null);
        }


    } // class GameConfigTests

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\AsyncSocket.cpp ===
#include "PTNCore.h"


//------------------------------------------------------------------------------
// Based on the type of operation assuming an asynchronous
// socket we will convert certain WSA errors into S_OK.
//------------------------------------------------------------------------------

HRESULT HandleWSAReturnValue(DWORD dwType, int iRet)
{
    if( SOCKET_ERROR == iRet )
    {
        int iWSAError = WSAGetLastError();
    
        //
        // WSA_IO_PENDING is not an error, it just means that the I/O operation
        // will complete later.  But the same is also true for WSAEMSGSIZE, if
        // we were calling WSARecv or WSAReceiveFrom.  Don't believe what the NT documentation
        // for WSARecv says.  The IO completion port will be signalled if we get an WSAEMSGSIZE.
        //
		switch(dwType)
		{
			case SOCKET_OPERATION_RECV:
			case SOCKET_OPERATION_RECV_FROM:
        		if((WSA_IO_PENDING != iWSAError) && (WSAEMSGSIZE != iWSAError))
        		{
            		HRESULT hr = HRESULT_FROM_WIN32(iWSAError);
            		return hr;
        		}
				break;
			case SOCKET_OPERATION_SEND:
				if(WSA_IO_PENDING != iWSAError)
				{
					HRESULT hr = HRESULT_FROM_WIN32(iWSAError);
					return hr;
				}
				break;
			case SOCKET_OPERATION_CONNECT:
				if(ERROR_IO_PENDING != iWSAError && WSAEWOULDBLOCK != iWSAError)
				{
					HRESULT hr = HRESULT_FROM_WIN32(iWSAError);
					return hr;
				}
				else
				{
					return S_FALSE; // notify callers that the IO is pending
				}
				break;

			default:
				return HRESULT_FROM_WIN32(iWSAError);
				break;
		}
        return S_OK;
    }    
    else if( 0 == iRet )
    {
        //
        // Synchronous operation, completion already scheduled by the system
        //
        return( S_OK );
    }
    else 
    {
        return( E_FAIL );
    }
}



//------------------------------------------------------------------------------
//
// Begin socket implementation. 
//
//------------------------------------------------------------------------------

AsyncSocket::AsyncSocket() : 
	m_s(INVALID_SOCKET),
	m_protocol(0)
{
	ZeroMemory(&m_laddr, sizeof(struct sockaddr_in));
	ZeroMemory(&m_raddr, sizeof(struct sockaddr_in));
}

AsyncSocket::~AsyncSocket()
{
	Close();
}

HRESULT AsyncSocket::CreateTcp()
{
	HRESULT hr = S_OK;

	m_s = WSASocket(
			AF_INET,
			SOCK_STREAM,
			0,
			NULL,
			0,
			WSA_FLAG_OVERLAPPED );

	if( INVALID_SOCKET == m_s )
	{
		hr = HRESULT_FROM_WIN32( WSAGetLastError( ) );
		goto lbDone;
	}

	m_protocol = IPPROTO_TCP;

lbDone:
	return hr;
}

HRESULT AsyncSocket::CreateUdp()
{
	HRESULT hr = S_OK;

	m_s = WSASocket(
			AF_INET,
			SOCK_DGRAM,
			0,
			NULL,
			0,
			WSA_FLAG_OVERLAPPED );

	if( INVALID_SOCKET == m_s )
	{
		hr = HRESULT_FROM_WIN32( WSAGetLastError( ) );
		goto lbDone;
	}

	if(FAILED(hr = SetReuseAddr(TRUE)))
	{
		goto lbDone;
	}
	
	m_protocol = IPPROTO_UDP;

lbDone:
	return hr;
}

SOCKET AsyncSocket::Handle() const
{
	return m_s;
}

HRESULT AsyncSocket::GetOverlappedResult(SOCKET_OVERLAPPED *pOV)
{
	DWORD dwTransferred;
	DWORD dwFlags;
	HRESULT hr = S_OK;

	if(!WSAGetOverlappedResult(m_s, pOV, &dwTransferred, FALSE, &dwFlags))
	{
		hr = HRESULT_FROM_WIN32(WSAGetLastError());
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::GetLocalAddress( sockaddr_in *pLocalAddress )
{
    if( NULL == pLocalAddress )
    {
        return( E_INVALIDARG );
    }

    if( INVALID_SOCKET == m_s )
    {
        return( E_HANDLE );
    }

	if(0 == m_laddr.sin_port)
	{
		int namelen = sizeof(struct sockaddr_in);
		if(SOCKET_ERROR == getsockname(m_s, (sockaddr*)&m_laddr, &namelen))
		{
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}

    memcpy( pLocalAddress, &m_laddr, sizeof(sockaddr_in) );

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::GetPeerAddress( sockaddr_in *pPeerAddress )
{

	if(NULL == pPeerAddress)
	{
		return E_INVALIDARG;
	}

    if( INVALID_SOCKET == m_s )
    {
        return( E_HANDLE );
    }

    if( 0 == m_raddr.sin_family )
    {
        int addrLen = sizeof(sockaddr_in);

        int rc = getpeername( m_s, (sockaddr *) &m_raddr, &addrLen );

        if( SOCKET_ERROR == rc )
        {
            return( HRESULT_FROM_WIN32( WSAGetLastError() ) );
        }
    }

    memcpy( pPeerAddress, &m_raddr, sizeof(sockaddr_in) );

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::Connect(const sockaddr_in *pAddr, SOCKET_OVERLAPPED *pOV)
{
	//static unsigned long s_ulBaseAddr = 0x0200fe0a;
	//static unsigned long s_ulAddrOffset = 0;

    int rc;
    HRESULT hr = S_OK;
	LPFN_CONNECTEX ConnectEx = NULL; 
	GUID GuidConnectEx = WSAID_CONNECTEX; 
	DWORD dwBytes = 0;

    //
    // Validate arguments
    //
    
    if(NULL == pAddr)
    {
        return E_INVALIDARG;
    }

    if( IPPROTO_TCP != m_protocol )
    {
        return( E_INVALIDARG );
    }
    
    if( INVALID_SOCKET == m_s ) 
    {
        return( E_HANDLE );
    }

	// Setup the blank connection overlapped (this has to be simulated
	// at a higher level but we still populate the correct operation)
	pOV->Clear();
	pOV->dwOperation = SOCKET_OPERATION_CONNECT;

	// Query for the function pointer to ConnectEx
	rc = WSAIoctl(m_s,
			SIO_GET_EXTENSION_FUNCTION_POINTER,
			&GuidConnectEx,
			sizeof(GuidConnectEx),
			&ConnectEx,
			sizeof(ConnectEx),
			&dwBytes,
			NULL,
			NULL); 

	if(SOCKET_ERROR == rc)
	{
		hr = WSAGetLastError();
		goto lbDone;
	}

	if(0 == ConnectEx)
	{
		hr = E_UNEXPECTED;
		goto lbDone;
	}
	
	

	//s_ulAddrOffset = s_ulAddrOffset++ % 100;
	sockaddr_in bindaddr;
	ZeroMemory(&bindaddr, sizeof(bindaddr));
	bindaddr.sin_family           = AF_INET;
	bindaddr.sin_port             = 0;
	bindaddr.sin_addr.S_un.S_addr = INADDR_ANY;
	//bindaddr.sin_addr.S_un.S_addr = s_ulBaseAddr + (s_ulAddrOffset << 24);

	rc = bind(m_s, (const sockaddr*)&bindaddr, sizeof(sockaddr_in));
	if(SOCKET_ERROR == rc)
	{
		hr = HRESULT_FROM_WIN32(WSAGetLastError());
		goto lbDone;
	}

	//
	// Set socket options
	//
	if(FAILED(hr = SetReuseAddr(TRUE)))
	{
		goto lbDone;
	}

	if(FAILED(hr = SetBlockingIO(FALSE)))
	{
		goto lbDone;
	}


    // 
	// Begin the connection
	//
    if(!ConnectEx(m_s, (const sockaddr*) pAddr, sizeof(sockaddr_in), NULL, 0, NULL, pOV))
	{
		hr = HandleWSAReturnValue(SOCKET_OPERATION_CONNECT, SOCKET_ERROR);
	}
	
lbDone:
    
    return( hr );
}

HRESULT AsyncSocket::CheckConnected(HANDLE hNotifyConnect, DWORD dwMillis)
{
	HRESULT  hr;
	int      rc;
	fd_set   wset;
	fd_set   eset;
	TIMEVAL  to = {0,};

	if(INVALID_HANDLE_VALUE != hNotifyConnect)
	{
		DWORD dwStatus = WaitForSingleObject(hNotifyConnect, dwMillis);
		if(WAIT_TIMEOUT == dwStatus)
		{
			hr = S_FALSE;
			goto lbDone;
		}
		else if(WAIT_OBJECT_0 == dwStatus)
		{
			hr = S_OK;
			// continue on with the check
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto lbDone;
		}
	}
	
	FD_ZERO(&wset);
	FD_ZERO(&eset);
	FD_SET(m_s, &wset);
	FD_SET(m_s, &eset);


	hr = S_FALSE;

	//
	// Check if the socket count was positive and the
	// connected socket is writable.
	//
	rc = select(0, NULL, &wset, &eset, &to);
	if(rc > 0 && FD_ISSET(m_s, &wset))
	{
		hr = S_OK;
	}
	else if( rc != 0)
	{
		hr = HRESULT_FROM_WIN32(WSAGetLastError());
	}

	// socket operation would block, let the caller know connection is not yet ready
	if(HRESULT_FROM_WIN32(WSAEWOULDBLOCK) == hr)
	{
		hr = S_FALSE;
	}

lbDone:

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::Send(BYTE *pbBuffer, DWORD cbToSend, SOCKET_OVERLAPPED *pOV)
{
	if( ( NULL == pbBuffer ) )
	{
		return( E_INVALIDARG );
	}

	if( INVALID_SOCKET == m_s ) 
	{
		return( E_HANDLE );
	}

	HRESULT hr;

	//
	// Send the data asynchronously
	//
	WSABUF wsa;
	wsa.len = cbToSend;
	wsa.buf = (char *) pbBuffer;
	
	pOV->Clear();
	pOV->pbBuffer    = pbBuffer;
	pOV->cbBuffer    = cbToSend;
	pOV->dwOperation = SOCKET_OPERATION_SEND;

	DWORD cbSent = 0;

	int rc = WSASend( m_s, &wsa, 1, &cbSent, 0, pOV, NULL );

	hr = HandleWSAReturnValue( SOCKET_OPERATION_SEND, rc );

	if( FAILED( hr ) )
	{
		goto lbDone;
	}

	hr = S_OK;

lbDone:

	return( hr );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::SendEx(WSABUF *rgBuffers, DWORD cBuffers, SOCKET_OVERLAPPED *pOV)
{
	if( ( NULL == rgBuffers ) || (cBuffers == 0) )
	{
		return( E_INVALIDARG );
	}

	if( INVALID_SOCKET == m_s ) 
	{
		return( E_HANDLE );
	}

	HRESULT hr;

	//
	// Send the data asynchronously
	//

	pOV->Clear();
	pOV->pbBuffer    = (BYTE*)rgBuffers;
	pOV->cbBuffer    = cBuffers;
	pOV->dwOperation = SOCKET_OPERATION_SEND_EX;

	DWORD cbSent = 0;

	int rc = WSASend( m_s, rgBuffers, cBuffers, &cbSent, 0, pOV, NULL );

	hr = HandleWSAReturnValue( SOCKET_OPERATION_SEND, rc );

	if( FAILED( hr ) )
	{
		goto lbDone; 
	}

	hr = S_OK;

lbDone:

	return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::SendTo(BYTE *pbBuffer, DWORD cbToSend, const sockaddr_in *pSendToAddr, SOCKET_OVERLAPPED *pOV)
{
	//
	// Validate arguments
	//
	if( ( NULL == pbBuffer ) )
	{
		return( E_INVALIDARG );
	}

	if( INVALID_SOCKET == m_s ) 
	{
		return( E_HANDLE );
	}

	if( IPPROTO_UDP != m_protocol && IPPROTO_IP != m_protocol )
	{
		return( E_NOTIMPL );
	}

	HRESULT hr;

	//
	// Send the data asynchronously
	//
	WSABUF wsa;

	wsa.len = cbToSend;
	wsa.buf = (char *) pbBuffer;

	pOV->Clear();
	pOV->pbBuffer = pbBuffer;
	pOV->cbBuffer = cbToSend;
	pOV->dwOperation = SOCKET_OPERATION_SEND_TO;

	DWORD cbSent = 0;

	int rc = WSASendTo(
			m_s,
			&wsa,
			1,
			&cbSent,
			0,
			(sockaddr *) pSendToAddr,
			sizeof(sockaddr_in),
			pOV,
			NULL );

	hr = HandleWSAReturnValue( SOCKET_OPERATION_SEND, rc );

	if( FAILED( hr ) )
	{
		goto lbDone;
	}

	hr = S_OK;
lbDone: 

	return( hr );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::Receive(BYTE *pbBuffer, DWORD cbBuffer, SOCKET_OVERLAPPED *pOV)
{
	//
	// Validate arguments
	//
	if( ( NULL == pbBuffer ) )
	{
		return( E_INVALIDARG );
	}

	if( INVALID_SOCKET == m_s ) 
	{
		return( E_HANDLE );
	}

	HRESULT hr;

	//
	// Receive the data asynchronously
	//
	WSABUF wsa;

	wsa.len = cbBuffer;
	wsa.buf = (char *) pbBuffer;

	pOV->Clear();
	pOV->pbBuffer = pbBuffer;
	pOV->cbBuffer = cbBuffer;
	pOV->dwOperation = SOCKET_OPERATION_RECV;

	DWORD dwFlags = 0;
	DWORD cbReceived = 0;

	int rc = WSARecv(
			m_s,
			&wsa,
			1,
			&cbReceived,
			&dwFlags,
			pOV,
			NULL );

	hr = HandleWSAReturnValue( SOCKET_OPERATION_RECV, rc );

	if( FAILED( hr ) )
	{
		goto lbDone;
	}

	hr = S_OK;

lbDone:

	return( hr );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::ReceiveFrom(BYTE *pbBuffer, DWORD cbBuffer, SOCKET_OVERLAPPED *pOV)
{
	if( ( NULL == pbBuffer ) )
	{
		return( E_INVALIDARG );
	}

	if( INVALID_SOCKET == m_s ) 
	{
		return( E_HANDLE );
	}

	HRESULT hr;

	//
	// Receive the data asynchronously
	//
	WSABUF wsa;

	wsa.len = cbBuffer;
	wsa.buf = (char *) pbBuffer;

	pOV->Clear();
	pOV->pbBuffer    = pbBuffer;
	pOV->cbBuffer    = cbBuffer;
	pOV->dwOperation = SOCKET_OPERATION_RECV_FROM;

	DWORD dwFlags = 0;
	DWORD cbReceived = 0;

	int rc = WSARecvFrom(
			m_s,
			&wsa,
			1,
			&cbReceived,
			&dwFlags,
			(sockaddr*)&pOV->cliaddr,
			(int*)&pOV->cliaddrlen,
			pOV,
			NULL );

	hr = HandleWSAReturnValue( SOCKET_OPERATION_RECV_FROM, rc );

	if( FAILED( hr ) )
	{
		goto lbDone;
	}

	hr = S_OK;

lbDone: 

	return( hr );
}

HRESULT AsyncSocket::Shutdown(int fHow)
{
	if( INVALID_SOCKET == m_s ) 
    {
        return( S_OK );
    }

    int rc = shutdown( m_s, SD_SEND );
	if(SOCKET_ERROR == rc)
	{
		return HRESULT_FROM_WIN32(WSAGetLastError());
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::Close()
{
    //
    // Check if we are already closed
    //
    if( INVALID_SOCKET == m_s ) 
    {
        return( S_OK );
    }

    //shutdown( m_s, SD_SEND );

    closesocket( m_s );

    m_s = INVALID_SOCKET;
	m_protocol = 0;
	ZeroMemory(&m_laddr, sizeof(struct sockaddr_in));
	ZeroMemory(&m_raddr, sizeof(struct sockaddr_in));

    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::SetReuseAddr(BOOL fReuseAddr)
{
	HRESULT hr = S_OK;

	int rc = setsockopt(
			m_s,
			SOL_SOCKET,
			SO_REUSEADDR,
			(const char *) &fReuseAddr,
			sizeof(fReuseAddr) );

	if( SOCKET_ERROR == rc )
	{
		hr = HRESULT_FROM_WIN32( WSAGetLastError( ) );        
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::SetBlockingIO( BOOL fBlockingIO )
{
    if( INVALID_SOCKET == m_s ) 
    {
        return( E_HANDLE );
    }
    
    u_long arg = fBlockingIO ? 0L : 1L;

    int rc = ioctlsocket( m_s, FIONBIO, &arg );

    if( SOCKET_ERROR == rc )
    {
        return( E_FAIL );
    }

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::SetDisableNagle( BOOL fDisable )
{
    if( INVALID_SOCKET == m_s ) 
    {
        return( E_HANDLE );
    }

    int rc = setsockopt(
                    m_s,
                    IPPROTO_TCP,
                    TCP_NODELAY,
                    (char *) &fDisable,
                    sizeof(BOOL) );

    if ( SOCKET_ERROR == rc )    
    {
       return( HRESULT_FROM_WIN32( WSAGetLastError() ) );
    }

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::SetReceiveBufferSize( DWORD dwBufferSize )
{
    if( INVALID_SOCKET == m_s ) 
    {
        return( E_HANDLE );
    }

    int iBufSize = (int) dwBufferSize;

    int rc = setsockopt(
                    m_s,
                    SOL_SOCKET,
                    SO_RCVBUF,
                    (char *) &iBufSize,
                    sizeof(int) );

    if ( SOCKET_ERROR == rc )    
    {
       return( HRESULT_FROM_WIN32( WSAGetLastError() ) );
    }

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::SetSendBufferSize( DWORD dwBufferSize )
{
    if( INVALID_SOCKET == m_s ) 
    {
        return( E_HANDLE );
    }

    int iBufSize = (int) dwBufferSize;

    int rc = setsockopt(
                    m_s,
                    SOL_SOCKET,
                    SO_SNDBUF,
                    (char *) &iBufSize,
                    sizeof(int) );

    if ( SOCKET_ERROR == rc )    
    {
       return( HRESULT_FROM_WIN32( WSAGetLastError() ) );
    }

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::SetReceiveBroadcast( BOOL fReceive )
{
    if( INVALID_SOCKET == m_s ) 
    {
        return( E_HANDLE );
    }

    int rc = setsockopt(
                    m_s,
                    IPPROTO_IP,
                    IP_RECEIVE_BROADCAST,
                    (char *) &fReceive,
                    sizeof(BOOL) );

    if ( SOCKET_ERROR == rc )    
    {
       return( HRESULT_FROM_WIN32( WSAGetLastError() ) );
    }

    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::SetSendTimeout( DWORD dwMillis )
{
	if( INVALID_SOCKET == m_s ) 
    {
        return( E_HANDLE );
    }

    int rc = setsockopt(
                    m_s,
                    SOL_SOCKET,
                    SO_SNDTIMEO,
                    (char *) &dwMillis,
                    sizeof(DWORD) );

    if ( SOCKET_ERROR == rc )    
    {
       return( HRESULT_FROM_WIN32( WSAGetLastError() ) );
    }

    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::SetReceiveTimeout( DWORD dwMillis )
{
	if( INVALID_SOCKET == m_s ) 
    {
        return( E_HANDLE );
    }

    int rc = setsockopt(
                    m_s,
                    SOL_SOCKET,
                    SO_RCVTIMEO,
                    (char *) &dwMillis,
                    sizeof(DWORD) );

    if ( SOCKET_ERROR == rc )    
    {
       return( HRESULT_FROM_WIN32( WSAGetLastError() ) );
    }

    return( S_OK );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT AsyncSocket::GetMaxMessageSize( DWORD *pdwMaxMessageSize )
{
    //
    // Validate arguments
    //
    if( NULL == pdwMaxMessageSize )
    {
        return( E_INVALIDARG );
    }

    *pdwMaxMessageSize = 0;

    unsigned int uiMsgSize;
    int iParamSize = sizeof(uiMsgSize);

    int rc = getsockopt(
                    m_s,
                    SOL_SOCKET,
                    SO_MAX_MSG_SIZE,
                    (char *) &uiMsgSize,
                    &iParamSize );

    if( SOCKET_ERROR == rc )
    {
        return( HRESULT_FROM_WIN32( WSAGetLastError() ) );
    }

    *pdwMaxMessageSize = uiMsgSize;

    return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\AsyncSocket.h ===
#pragma once

#define SOCKET_OPERATION_CONNECT     1
#define SOCKET_OPERATION_RECV        2
#define SOCKET_OPERATION_RECV_FROM   3
#define SOCKET_OPERATION_SEND        4
#define SOCKET_OPERATION_SEND_EX     5
#define SOCKET_OPERATION_SEND_TO     6
#define SOCKET_OPERATION_ACCEPT      7

#pragma pack(push, 1)
struct SOCKET_OVERLAPPED : OVERLAPPED
{
	HRESULT            hr;
	struct sockaddr_in cliaddr;
	int                cliaddrlen;
	BYTE*              pbBuffer;
	DWORD              cbBuffer;
	DWORD              dwOperation;

	inline void   Clear()
	{
 		Internal                       = 0;
		InternalHigh                   = 0;
		Offset                         = 0;
		OffsetHigh                     = 0;
		hEvent                         = 0;
		hr                             = 0;
		cliaddr.sin_family             = 0; 
		cliaddr.sin_port               = 0; 
		cliaddr.sin_addr.s_addr        = 0; 
		*((DWORD*)&cliaddr.sin_zero[0])= 0;
		cliaddrlen                     = 0;
		pbBuffer                       = 0;
		cbBuffer                       = 0;
		dwOperation                    = 0;
	}
};
#pragma pack(pop)

class AsyncSocket
{
protected:
	SOCKET           m_s;
	DWORD            m_protocol;
	sockaddr_in      m_laddr;
	sockaddr_in      m_raddr;

public:

	AsyncSocket();
	~AsyncSocket();

	IMPLEMENT_REFCOUNT;

	HRESULT CreateTcp();

	HRESULT CreateUdp();

	SOCKET Handle() const;

	HRESULT GetOverlappedResult(SOCKET_OVERLAPPED *pOV);

	HRESULT GetLocalAddress(sockaddr_in *pLocalAddress);

	HRESULT GetPeerAddress(sockaddr_in *pPeerAddress);

	HRESULT Connect(const sockaddr_in *pAddr, SOCKET_OVERLAPPED *pOV);

	//------------------------------------------------------------------------------
	// Check the connection status from a previous connection attempt, the handle
	// passed into connect can be used to poll or block on the connection status.
	// 
	// If the handle has already notified a higher level handler that data is ready
	// the caller may pass INVALID_HANDLE_VALUE to skip the WaitForSingleObject and 
	// jump right to the select() for writability.
	//------------------------------------------------------------------------------
	HRESULT CheckConnected(HANDLE hNotifyConnect = INVALID_HANDLE_VALUE, DWORD dwMillis = 0);

	HRESULT Send(
			BYTE *pbBuffer,
			DWORD cbToSend,
			SOCKET_OVERLAPPED *pOV);

	HRESULT SendEx(
			WSABUF *rgBuffers,
			DWORD cBuffers,
			SOCKET_OVERLAPPED *pOV);

	HRESULT SendTo(
			BYTE *pbBuffer,
			DWORD cbToSend, 
			const sockaddr_in *pSendToAddr,
			SOCKET_OVERLAPPED *pOV);

	HRESULT Receive(
			BYTE *pbBuffer,
			DWORD cbBuffer,
			SOCKET_OVERLAPPED *pOV);

	HRESULT ReceiveFrom(
			BYTE *pbBuffer,
			DWORD cbBuffer,
			SOCKET_OVERLAPPED *pOV);

	HRESULT Shutdown(int fHow = SD_SEND);

	HRESULT Close();

	HRESULT SetReuseAddr(BOOL fReuseAddr);

	HRESULT SetBlockingIO(BOOL fBlockingIO);

	HRESULT SetDisableNagle(BOOL fDisable);

	HRESULT SetReceiveBufferSize(DWORD dwBufferSize);

	HRESULT SetSendBufferSize(DWORD dwBufferSize);

	HRESULT SetReceiveBroadcast(BOOL fReceive);

	HRESULT SetSendTimeout(DWORD dwMillis);

	HRESULT SetReceiveTimeout(DWORD dwMillis);

	HRESULT GetMaxMessageSize(DWORD *pdwMaxMessageSize);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\Command.h ===
#pragma once

// structure used for communicating with slave processes
struct Command
{
	WORD wType;
	WORD wSize;
	WORD wSeq;
	WORD wFlags;
};

// Command message types
enum CommandType
{
	kCommand_None			= 0,
	kCommand_Shutdown		= 1,
	kCommand_EnqueueTask	= 2
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\CompletionPort.cpp ===
#include "PTNCore.h"

CompletionPort::CompletionPort() :
	m_hPort(INVALID_HANDLE_VALUE)
{
}

CompletionPort::~CompletionPort()
{
}

HRESULT CompletionPort::Create(DWORD dwNumThreads)
{
	HRESULT hr = S_OK;

	m_hPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, dwNumThreads);
	if(NULL == m_hPort)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	return hr;
}

HRESULT CompletionPort::Destroy()
{
	HRESULT hr = S_OK;

	if(INVALID_HANDLE_VALUE != m_hPort)
	{
		if(FALSE == CloseHandle(m_hPort))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}

	return hr;
}

HRESULT CompletionPort::Attach(HANDLE hAttach, ULONG_PTR uptrKey, DWORD dwNumThreads)
{
	HRESULT hr = S_OK;
	HANDLE hValue = CreateIoCompletionPort(hAttach, m_hPort, uptrKey, dwNumThreads);
	if(NULL == hValue)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	return hr;
}

HRESULT CompletionPort::PostCompletion(OVERLAPPED *pOverlapped, DWORD cbTransferred, ULONG_PTR upKey)
{
    HRESULT hr = S_OK;

    if(FALSE == PostQueuedCompletionStatus(m_hPort, cbTransferred, upKey, pOverlapped ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


HRESULT CompletionPort::GetQueuedCompletion(DWORD *pdwTransferred, ULONG_PTR *pCompletionKey, OVERLAPPED **ppOverlapped, DWORD dwMillis)
{
	HRESULT hr = S_OK;

	if(FALSE == GetQueuedCompletionStatus(m_hPort, pdwTransferred, pCompletionKey, ppOverlapped, dwMillis))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\PresTest.cs ===
using System;
using System.Xml;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.GI;
using xonline.common.config;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

[assembly: RootNode(typeof(PresenceTest.Suite))]

namespace PresenceTest
{
	/// <summary>
	/// <TestSuite>Presence Server Test Plan</TestSuite>
	///	<Tester>Paul Lyttle</Tester>
    ///	<Tester>Vikram Subramanian</Tester>
    ///	<Developer>Matt Childerston</Developer>
	///	<PM>Ryan Cooper</PM>
	///	<Status>Draft</Status>
	/// </summary>
	///	<remarks>
	///	<Goal>Functional positive and negative test cases covering V1, V2 and V3 presence features.</Goal>
	///	<Goal>Test code validation of Profile-UODB partitioning.</Goal>
	///	<Goal>Test code validation of Profile-UODB table data.</Goal>
	///	<NonGoal>Test of container environment (.NET, ASP.NET, IIS, Windows).</NonGoal>
	///	<NonGoal>Test of NT service startup/shutdown</NonGoal>
	///	<NonGoal>Test of internal INH only messages that are not exposed on the front-door</NonGoal>
	///	<Description>
	///		<p>
	///			Presence server previously was the one of two servers used for maintaining
	///		user state in Xbox Live. The current service has been combined into 
	///		a single server which handles presence records, messaging, notification and
	///		teams. The test suites for each portion of presence however will continue 
	///		be maintained as three seperate suites.
	///		</p>
	///
	///		<p>
	///			Presence functional tests cover all of the 'P' messages that are exposed 
	///		on the presence front door sans teams messages. These are as follows:
	///		</p>
	///
	///		<p>
	///		<table class="test_data">
    ///			<tr><td>Accept            </td><td>Accept an incoming friend request</td></tr>
    ///			<tr><td>AddAffiliates     </td><td>Add a list of affiliate associations</td></tr>
    ///			<tr><td>Add               </td><td>Add an outgoing buddy request</td></tr>
    ///			<tr><td>Alive             </td><td>XBox1 Alive Request to logon to the presence service</td></tr>
	///			<tr><td>Alive2            </td><td>Xenon Alive request to logon to the presence service</td></tr>
	///			<tr><td>Reject            </td><td>Reject an incoming friend request</td></tr>
	///			<tr><td>Block             </td><td>Add a player to your block list</td></tr>
    ///			<tr><td>CheckTitleMessages</td><td>Check for title specific required/recommended messages on title change</td></tr>
    ///			<tr><td>DeadXbox          </td><td>Notification that a XBOX went offline</td></tr>
    ///			<tr><td>DeadSg            </td><td>Notification that a SG went offline</td></tr>
    ///			<tr><td>DeleteBuddy       </td><td>Delete an existing friend.</td></tr>
    ///			<tr><td>Dequeue           </td><td>Add items to each of the users queues and confirm the data upon dequeue.</td></tr>
    ///			<tr><td>FindUser          </td><td>Find a user presence record by ID or gamertag</td></tr>
    ///			<tr><td>FindUsers         </td><td>Find an array of users presence record by ID or gamertag</td></tr>
    ///			<tr><td>GetFriendsList    </td><td>Do a polling query to load your friends list (used from web pages)</td></tr>
    ///			<tr><td>GetPresenceInfo   </td><td>Datacenter call to get the state information about a single user.</td></tr>
    ///			<tr><td>InvalidateUser    </td><td>Mark the Users Presence record as dirty.</td></tr>
    ///			<tr><td>Invite            </td><td>XBox1 Invite.</td></tr>
    ///			<tr><td>Invite2           </td><td>Xenon Invite a player to a game session</td></tr>
    ///			<tr><td>Cancel            </td><td>Cancel a pending invite</td></tr>
    ///			<tr><td>InviteAnswer      </td><td>Answer an incoming pending invite</td></tr>
    ///			<tr><td>IsAffiliate       </td><td>Check for the existance of single affiliate association</td></tr>
    ///			<tr><td>Migration         </td><td>Migrate users from one XPServer to another in real time</td></tr>
    ///			<tr><td>PeerSession       </td><td>Query for the users XNADDR and XNKID</td></tr>
    ///			<tr><td>PeerSubscribe     </td><td>Subscribe to a list of other players</td></tr>
    ///			<tr><td>PeerSubscribeEx   </td><td>Subscribe to a list of other players and receive their state information in the initial response.</td></tr>
    ///			<tr><td>PeerUnsubscribe   </td><td>Tear down your peer subscriptions</td></tr>
    ///			<tr><td>PurgeUser         </td><td>Delete user from the presence service, removing all associations.(friends, teams)</td></tr>
    ///			<tr><td>QueryAffiliates   </td><td>Query player affiliate associations</td></tr>
    ///			<tr><td>RichPresence      </td><td>Xenon Users send bytes of state that is formatted into a localized text string in the FD.</td></tr>
    ///			<tr><td>State             </td><td>SG Client Notify update state for XBox1 Users</td></tr>
    ///			<tr><td>State2            </td><td>SG Client Notify update state for Xenon Users</td></tr>
    ///			<tr><td>WebFriends        </td><td>Do a polling query to load your friends list (used from web pages)</td></tr>

    ///			<tr><td>Unblock           </td><td>Remove a player from your block list</td></tr>
	///			<tr><td>Nickname          </td><td>Change your nick name (deprecated?)</td></tr>
    ///		</table>
	///		</p>
	/// </Description>
	/// </remarks>
    /// 
    [Owner("shailesh"), TestFrequency("Daily"), TestCasePriority(3), Description("Presence tests")]
	public class Suite : TestNode
	{
        // Constants to configure the stress setup
        const uint kTitleCount = 16;
        public const uint kBaseXenonTitleId = 0x22000000;
        const uint kModeCount = 4;
        const uint kPropertyCount = 4;
        const uint kContextCount = 4;
        const uint kContextValueCount = 4;

        public override void PreRun(RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.FUNCTIONAL)
            {
                InitializeFunctional();
            }
            else if (runType == RUN_TYPE.STRESS)
            {
                InitializeStress();
            }
        }

		////////////////////////////////////////////////
		// Initialize
		//
		//	Setup for Functional Suite
		//
		public void InitializeFunctional()
		{
			// Let the fake SG know where to send state updates
			GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence_int).ToString());

			// make sure we don't have any required regional messages left over (this killed regressions once)
			SystemMsgFolder.DeleteAll( 10 /*MsgTestUtil.DefaultSystemTitleID*/, SystemMessage.RevokeAlso.Yes );

            //Install Acceleration perf counters, here we run the installer locally and this should load the acceleration dll
            Hashtable hash = new Hashtable();
            xonline.common.mgmt.XomPerformanceCounterInstall xInstall = new xonline.common.mgmt.XomPerformanceCounterInstall();
            xInstall.Context = new System.Configuration.Install.InstallContext("localinstall.log", null);
            try
            {
                xInstall.Install(hash);
                xInstall.Commit(hash);
            }
            catch (Exception e)
            {
                Global.RO.Error(e.Message);
                Global.RO.Warn("Usually restarting stfgui should fix the error if counters cannot be installed the first time...");
            }
		}

		////////////////////////////////////////////////
		// Initialize Stress
		//	Setup for Stress Suite
		//
		public void InitializeStress()
		{
            // Load bulk users and create initial queues
            //StressUserList.Initialize();

            GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence_int).ToString());
            GlobalFakeSG.FakeSG.SetEnableStateBatching(true, 40); //Prod has 40 Mili 
            // Taken from "title config" portion of old presence stress
            //InitServerTestFramework(false);
            Global.RO.Debug("Configuring {0} titles", kTitleCount);
            for (uint titleId = kBaseXenonTitleId; titleId < kBaseXenonTitleId + kTitleCount; ++titleId)
            {
                SetupTitle(titleId);
            }

            Global.RO.Debug("Flushing presence FD configuration");
            //Global.XEnv.ExecuteXmgmtCommand(Interface.xpnfd_presence, "e :xpnfd configcacherefresh");

		}


        //////////////////////////////////////////////////
        // STRESS INITIALIZATION
        //////////////////////////////////////////////////

        /// <summary>
        /// 
        /// </summary>
        /// <param name="titleId"></param>
        static void SetupTitle(uint titleId)
        {
            PresenceTitleConfig config = new PresenceTitleConfig((int)titleId);

            SetupPresenceModes(config);
            SetupContexts(config);

            //Global.RO.Debug(config.BuildXml());
            config.WriteToDatabase(true);

            Global.RO.Debug("Finished writing title: " + titleId.ToString("x") + " to database");
        }

        static void SetupPresenceModes(PresenceTitleConfig config)
        {
            string[] modeStrings = 
			{
				" 0 ["+config.TitleId.ToString("x8") + "]: {c0x" + GIContext.GAME_MODE.ToString("X8") + "} {p0x10000000}: {p0x40000001} {p0x10000002} ({c0x00000000}, {c0x00000001}, {c0x00000002}, {c0x00000003}) ({p0x50000003})", // Game mode, user index, name, touches
				" 1 ["+config.TitleId.ToString("x8") + "]: {c0x" + GIContext.GAME_MODE.ToString("X8") + "} {p0x10000000}: {p0x40000001} {p0x10000002} ({c0x00000000}, {c0x00000001}, {c0x00000002}, {c0x00000003}) ({p0x50000003})", // Game mode, user index, name, touches
				" 2 ["+config.TitleId.ToString("x8") + "]: {c0x" + GIContext.GAME_MODE.ToString("X8") + "} {p0x10000000}: {p0x40000001} {p0x10000002} ({c0x00000000}, {c0x00000001}, {c0x00000002}, {c0x00000003}) ({p0x50000003})", // Game mode, user index, name, touches
				" 3 ["+config.TitleId.ToString("x8") + "]: {c0x" + GIContext.GAME_MODE.ToString("X8") + "} {p0x10000000}: {p0x40000001} {p0x10000002} ({c0x00000000}, {c0x00000001}, {c0x00000002}, {c0x00000003}) ({p0x50000003})", // Game mode, user index, name, touches
			};


            // Create the presence format modes
            for (uint i = 0; i < kModeCount; ++i)
            {
                string strValue = modeStrings[i];
                PresenceMode mode = config.AddPresenceMode(i, config.AddDefaultLocalizedString(config.DefaultLocale + strValue));
                Localize(config, mode.StringId, strValue);

            }
        }

        static void SetupContexts(PresenceTitleConfig config)
        {
            // Create the special game type context
            Context modeContext = config.AddGameMode(GIContext.GAME_MODE, config.AddDefaultLocalizedString("-GAME_MODE_NAME-" + GIContext.GAME_MODE.ToString("X")));

            for (uint contextValueId = 0; contextValueId < kContextValueCount; ++contextValueId)
            {
                string strValue = "GAME_MODE-" + contextValueId;

                ContextValue modeContextValue = modeContext.AddContextValue(contextValueId, config.AddDefaultLocalizedString(config.DefaultLocale + strValue));
                Localize(config, modeContextValue.StringId, strValue);
            }

            // Create the context ids
            for (uint contextId = 0; contextId < kContextCount; ++contextId)
            {
                Context context = config.AddContext(contextId, config.AddDefaultLocalizedString("CONTEXT_NAME-" + contextId));

                for (uint contextValueId = 0; contextValueId < kContextValueCount; ++contextValueId)
                {
                    string strValue = "-ContextValue" + contextId + "." + contextValueId;
                    ContextValue contextValue = context.AddContextValue(contextValueId, config.AddDefaultLocalizedString(config.DefaultLocale + strValue));
                    Localize(config, contextValue.StringId, strValue);
                }
            }
        }

        static void Localize(PresenceTitleConfig config, uint stringId, string strValue)
        {
            // Add values for each locale
            foreach (PresenceTitleConfig.LocaleSpec spec in PresenceTitleConfig.LocaleTable)
            {
                if (spec.Locale == config.DefaultLocale || !spec.Supported)
                {
                    continue;
                }

                config.AddLocalizedString(stringId, spec.Locale, spec.Locale + strValue);
            }
        }
	}

    public class PresenceTestBaseGroup : TestNode
    {
        public FriendsCommon _fc;
        protected ArrayList _alUsers;
        public const uint PongTitleId = 0xFFFF400C;
        public PresenceTestBaseGroup()
            : base()
        {
        }


        [TestGroupSetup]
        public virtual void Setup()
        {
            _fc = new FriendsCommon();
            _alUsers = new ArrayList();
        }

        [TestGroupTearDown]
        public virtual void TearDown()
        {
            foreach (PNUser user in _alUsers)
            {
                try
                {
                    user.Dispose();
                }
                catch (Exception e)
                {
                    Global.RO.Warn("Exception thrown while cleanup." + e.Message);
                }
            }
            _fc = null;
            _alUsers = null;
        }

        public PNUser[] CreateXenonUsers(uint numUsers, bool alive)
        {
            PNUser[] users = new PNUser[numUsers];
            for (int iUser = 0; iUser < numUsers; iUser++)
            {
                users[iUser] = CreateXenonUser(alive);
            }
            return users;
        }

        public void ClearUsersInbox(PNUser[] users)
        {
            foreach(PNUser user in users)
            {
                ClearUserInbox(user);
            }
        }
        
        public void ClearUserInbox(PNUser user)
        {
            // As of change 491078, new users always get a "Welcome to LIVE" system message
            UserMsgFolder msgFolder = new UserMsgFolder(user);
            int welcomeMsgEnabled = int.Parse(Config.GetSetting("presence_WelcomeToXboxLiveMessage"));
            if (welcomeMsgEnabled != 0)
            {
                msgFolder.WaitForMsgBySender(XonPresNoti.MSG_TYPE_LIVE_MESSAGE, 0, 5);
                msgFolder.Load2();
                msgFolder.DeleteInbox();
            }
            msgFolder.Load2();
            ValueCheck.Test("Message Inbox Count", (ushort)0, msgFolder.Count);
        }

        public PNUser CreateXenonUser(bool alive)
        {
            PNUser user = _fc.CreateXenonUser(alive);
            _alUsers.Add(user);
            return user;
        }

        public PNUser CreateXenonUser(bool alive, uint titleId)
        {
            PNUser user = _fc.CreateXenonUser(alive, titleId);
            _alUsers.Add(user);
            return user;
        }

        public PNUser CreateCleanXenonUser(bool alive)
        {
            PNUser user = CreateXenonUser(alive);
            ClearUserInbox(user);
            _fc.LogoffUser(user);
            _fc.LogonUser(user);
            return user;
        }

        public PNUser[] CreatePanoramaUsers(uint numUsers, bool alive)
        {
            PNUser[] users = new PNUser[numUsers];
            for (int iUser = 0; iUser < numUsers; iUser++)
            {
                users[iUser] = CreatePanoramaUser(alive);
            }
            return users;
        }

        public PNUser CreatePanoramaUser(bool alive)
        {
            PNUser user = _fc.CreatePanoramaUser(alive);
            _alUsers.Add(user);
            return user;
        }

        public PNUser CreatePanoramaUser(bool alive, uint titleId)
        {
            PNUser user = _fc.CreatePanoramaUser(alive, titleId);
            _alUsers.Add(user);
            return user;
        }

        public PNUser CreateLinkedUser(bool alive)
        {
            PNUser user = _fc.CreateLinkedUser(alive);
            _alUsers.Add(user);
            return user;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\CompletionPort.h ===
#pragma once

class CompletionPort
{
protected:
	HANDLE m_hPort;
public:
	CompletionPort();
	~CompletionPort();

	IMPLEMENT_REFCOUNT;

    HANDLE  Handle() const { return m_hPort; }

	HRESULT Create(DWORD dwNumThreads);
	HRESULT Destroy();

	HRESULT Attach(HANDLE hAttach, ULONG_PTR uptrKey, DWORD dwNumThreads);
	HRESULT GetQueuedCompletion(DWORD *pdwTransferred, ULONG_PTR *pCompletionKey, OVERLAPPED **ppOverlapped, DWORD dwMillis);
	HRESULT PostCompletion(OVERLAPPED *pOverlapped, DWORD cbTransferred, ULONG_PTR upKey);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\Counter.h ===
#pragma once


struct Counter
{
#define COUNTER_NAME_MAX 32

	char    szName[COUNTER_NAME_MAX];
	float   fInstance;
	float   fTotal;
	float   fLast;
	float   fMax;
	float   fMin;
	float   fRate;

	Counter()
	{
		szName[0] = '\0';
		Clear();
	}

	Counter(const char *pszName)
	{
		SetName(pszName);
		Clear();
	}

	void SetName(const char *pszName)
	{
		_ASSERTE(pszName);
        ZeroMemory(szName, COUNTER_NAME_MAX);
		strncpy(szName, pszName, COUNTER_NAME_MAX-1);
	}

    void SetNameFormat(const char *pszNameFmt, ...)
    {
        va_list ap;
        va_start(ap, pszNameFmt);
        _vsnprintf(szName, COUNTER_NAME_MAX-1, pszNameFmt, ap);
        va_end(ap);
    }

	inline void Zero()
	{
		fInstance = 0;
	}
	inline void Clear()
	{
		fInstance = 0.0f;
		fTotal    = 0.0f;
		fLast     = 0.0f;
		fMax      = 0.0f;
		fMin      = 0.0f;
		fRate     = 0.0f;
	}
	inline float operator ++()
	{
		fInstance++;
		fTotal++;

		if(fInstance > fMax)
		{
			fMax = fInstance;
		}

		return fInstance;
	}

	inline float operator += (float fValue)
	{
		fInstance += fValue;
		fTotal += fValue;

		if(fInstance > fMax)
		{
			fMax = fInstance;
		}

		return fInstance;
	}

	inline float operator --()
	{
		fInstance--;
		fTotal--;

		if(fInstance < fMin)
		{
			fMin = fInstance;
		}

		return fInstance;
	}

	inline float operator -= (float fValue)
	{
		fInstance -= fValue;
		fTotal -= fValue;

		if(fInstance < fMin)
		{
			fMin = fInstance;
		}

		return fInstance;
	}

	inline float operator = (float fValue)
	{
		fInstance = fValue;
		fTotal    = fValue;	

		if(fInstance > fMax)
		{
			fMax = fInstance;
		}

		if(fInstance < fMin)
		{
			fMin = fInstance;
		}

		return fInstance;
	}

	inline void Poll(float fElapsedSeconds)
	{
		fLast      = fInstance;
		fRate      = fLast / (fElapsedSeconds + 0.000001f);
		fInstance  = 0;
	}
};

struct RunningAverageCounter : public Counter
{
#define DEFAULT_SAMPLES 16
	float  fAverage;
	float *prgfSamples;
	DWORD  cSamples;
	DWORD  iSample;

    RunningAverageCounter()
        : prgfSamples(0)
    {
        Allocate(DEFAULT_SAMPLES);
        szName[0] = '\0';
        Clear();
    }
	RunningAverageCounter(const char *pszName)
		: prgfSamples(0)
	{
		Allocate(DEFAULT_SAMPLES);
		SetName(pszName);
		Clear();
	}
	RunningAverageCounter(const char *pszName, DWORD cSamples)
		: prgfSamples(0)
	{
		Allocate(cSamples);
		SetName(pszName);
		Clear();
	}
	~RunningAverageCounter()
	{
		if(0 != prgfSamples)
		{
			delete[] prgfSamples;
		}
	}

	void Allocate(DWORD incSamples)
	{
		_ASSERTE(incSamples > 0);

		if(0 != prgfSamples)
		{
			delete[] prgfSamples;
		}

		cSamples = incSamples;
		prgfSamples = new float[cSamples];
		_ASSERTE(prgfSamples);
		ZeroMemory(prgfSamples, cSamples * sizeof(float));
		iSample = 0;
	}


	void SampleValue(float fValue)
	{
		float *pfSample = &prgfSamples[iSample];
		fInstance = fValue;
		fTotal -= *pfSample;
		fTotal += fValue;
		*pfSample = fValue;
		iSample = (iSample + 1) % cSamples;

		fAverage = fTotal / float(cSamples);

		if(fInstance > fMax)
		{
			fMax = fInstance;
		}
		if(fInstance < fMin)
		{
			fMin = fInstance;
		}
	}

	void Clear()
	{
		Counter::Clear();
		fAverage = 0.0f;
		iSample  = 0;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\Connection.cpp ===
///////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#include "PTNCore.h"

/////////////////////////////////////////////////////////////////////////////
// Base Connection
///////////////////////////////////////////////////////////////////////////////

MGMT_DefineLoggingCategory(Conn);
/////////////////////////////////////////////////
//  Ctor
//  
BaseConnection::BaseConnection(
							   HANDLE hShutdownEvent    /* = NULL */, 
							   UINT   uicWriteBuffers   /* = DEFAULTBUFFERS */, 
							   INT    icWriteBufferSize /* = DEFAULTBUFFERSIZE */, 
							   INT    icReadBufferSize  /* = -1 */ )
							   :
m_s( INVALID_SOCKET ),
m_hShutdownEvent( hShutdownEvent ),
m_icReadBufferSize( icReadBufferSize ),
m_uicEvents( 1 ),
m_uicWriteBuffers( uicWriteBuffers ),
m_icWriteBufferSize( icWriteBufferSize ),
m_rgWriteBuffer( NULL ),
m_rgWriteOverlapped( NULL ),
m_uiWriteIndex( 0 )
{
	
    // Create array of buffers
    m_rgWriteBuffer = new WSABUF[m_uicWriteBuffers];
	
    // Create array of overlapped objects
    m_rgWriteOverlapped = new WSAOVERLAPPEDEX[m_uicWriteBuffers];
	
    // Populate array of buffers and initialize overlapped objects
    for( UINT ui = 0; ui < m_uicWriteBuffers; ui++ )
    {
        // Populate array of buffers
        m_rgWriteBuffer[ui].buf = new CHAR[m_icWriteBufferSize];
        m_rgWriteBuffer[ui].len = 0;
		
        // Initialize array of overlapped objects
        m_rgWriteOverlapped[ui].hEvent = WSACreateEvent();
        m_rgWriteOverlapped[ui].fPending = false;
    }
	
    if( NULL != m_hShutdownEvent)
    {
        m_uicEvents = 2;
        m_rghEvents[1] = m_hShutdownEvent;
    }

    // Clear the sockaddr info struct
    ZeroMemory(&m_sin, sizeof(struct sockaddr_in));
}

/////////////////////////////////////////////////
//  Dtor
//
BaseConnection::~BaseConnection()
{
	
    // Make sure there's no pending overlapped IO that's using this stuff.
    HRESULT hr = WaitForAllPendingBuffersToFlush( WSA_INFINITE );
    
    // Cleanup array of buffers and overlapped objects
    for( UINT ui = 0; ui < m_uicWriteBuffers; ui++ )
    {
        // Cleanup array of buffers
        if( NULL != m_rgWriteBuffer[ui].buf )
        {
            delete [] m_rgWriteBuffer[ui].buf;
        }
		
        // Cleanup array of overlapped objects
        if( NULL != m_rgWriteOverlapped[ui].hEvent )
        {
            BOOL fClosed = WSACloseEvent( m_rgWriteOverlapped[ui].hEvent );
			if(!fClosed)
			{
				ERR1(Conn, "BaseConnection::~BaseConnection(): WSACloseEvent() failed HR: 0x%08x", 
						HRESULT_FROM_WIN32(WSAGetLastError()));
			}
        }
    }
	
    // Deallocate array of overlapped objects
    if( NULL != m_rgWriteOverlapped )
    {
        delete [] m_rgWriteOverlapped;
    }
	
    // Deallocate array of buffers
    if( NULL != m_rgWriteBuffer )
    {
        delete [] m_rgWriteBuffer;
    }
}

/////////////////////////////////////////////////
//  Wait For All Pending Buffers To Flush
//
HRESULT BaseConnection::WaitForAllPendingBuffersToFlush( DWORD dwTimeout )
{
	
    // Initiate buffer flush
    HRESULT hr = SendToFlush( dwTimeout );
    if FAILED( hr ) return hr;
	
    // Allocate event array
    HANDLE* rghEvents = NULL;
    rghEvents = new HANDLE[m_uicWriteBuffers];
    if( NULL == rghEvents) 
	{
		return E_OUTOFMEMORY;
	}
	
    UINT uicEvents = 0;
    bool fTimeout  = false;
	
    //Count the number of pending buffers
    for( UINT ui = 0; ui < m_uicWriteBuffers; ui++ )
    {
        if( m_rgWriteOverlapped[ui].fPending)
        {
            rghEvents[uicEvents++] = m_rgWriteOverlapped[ui].hEvent;
        }
    }
	
    // If we have pending buffers wait for all of them
    if( uicEvents > 0 )
    {
        
        if( WSA_WAIT_TIMEOUT == WSAWaitForMultipleEvents( uicEvents, rghEvents, TRUE, dwTimeout, FALSE ) ) 
        {
			fTimeout = true;
        }
    }
	
    // Deallocate event array
    if( NULL != rghEvents )
    {
        delete []rghEvents;
    }
	
    return fTimeout ? HRESULT_FROM_WIN32(WSAETIMEDOUT) : S_OK;
}

/////////////////////////////////////////////////
//  Send To
//
//  Send to buffer memory
//
HRESULT BaseConnection::SendTo(
							   const char*            rgchBuf, 
							   int                    iLen, 
							   BOOL                   fFlush    /* = TRUE */, 
							   DWORD                  dwTimeout /* = WSA_INFINITE */, 
							   const struct sockaddr* lpTo      /* = NULL */, 
							   int                    iToLen    /* = 0 */ )
{
	
    HRESULT hr = E_FAIL;
	
    // Check parameters
    if( (NULL == rgchBuf ) ||
        (iLen <= 0) ||
        (iLen > m_icWriteBufferSize) )
    {
		hr = E_INVALIDARG;
		goto lbDone;
    }
	
    // check if connection is established
    if( INVALID_SOCKET == m_s )
    {
		hr = HRESULT_FROM_WIN32(WSAENOTCONN);
		goto lbDone;
    }
	
    while( TRUE )
    {
        // Was buffer pending?
        if( m_rgWriteOverlapped[m_uiWriteIndex].fPending )
        {
            
            // Populate event array
            m_rghEvents[0] = m_rgWriteOverlapped[m_uiWriteIndex].hEvent;
			
            // Wait for buffer to unlock or for shutdown event to fire
            DWORD dwErr = WSAWaitForMultipleEvents( m_uicEvents, m_rghEvents, FALSE, dwTimeout, FALSE );
            if( (WSA_WAIT_FAILED    == dwErr) ||
                (WSA_WAIT_TIMEOUT   == dwErr) ||
                (WSA_WAIT_EVENT_0+1 == dwErr) )
            {
				hr = HRESULT_FROM_WIN32(WSAGetLastError());
				ERR1(Conn, "WSAWaitForMultipleEvents() failed with HR: 0x%08x", hr);
				goto lbDone;
            }
			
            // Reuse the buffer and set the offset back to 0; data was sent
            m_rgWriteOverlapped[ m_uiWriteIndex].fPending = false;
            m_rgWriteBuffer[     m_uiWriteIndex].len      = 0;
        }
		
        // Can we write to this buffer or do we need to flush/and or get new buffer?
        if( (INT)m_rgWriteBuffer[m_uiWriteIndex].len +iLen > m_icWriteBufferSize )
        {
            
            hr = SendToFlush( dwTimeout, lpTo, iToLen );
            if( FAILED( hr ) ) 
			{
				ERR1(Conn, "SendToFlush() failed with HR: 0x%08x", hr);
				goto lbDone;
			}
			
            // check buffer now
            continue;  
        }
		
        // Copy data to memory buffer
        memcpy( 
            m_rgWriteBuffer[m_uiWriteIndex].buf + m_rgWriteBuffer[m_uiWriteIndex].len,
            rgchBuf,
            iLen );
        
        m_rgWriteBuffer[m_uiWriteIndex].len += iLen;
		
        // Force a flush? (time critical)
        if( TRUE == fFlush )
        {
            
            hr = SendToFlush( dwTimeout, lpTo, iToLen );
            if( FAILED(hr) )
			{
				ERR1(Conn, "SendToFlush() failed with HR: 0x%08x", hr);
				goto lbDone;
			}
        }
        break; // success
    }

	// Succeeded
	hr = S_OK;

lbDone:
    return hr;
}

/////////////////////////////////////////////////
//  Receive From
//
//  Receives data on an open socket
//
HRESULT BaseConnection::ReceiveFrom(char* rgchBuf, DWORD dwLen, DWORD* pdwLen, DWORD dwTimeout/*=WSA_INFINITE*/,struct sockaddr FAR *lpFrom/*=NULL*/, int* piFromLen/*=0*/)
{
    HRESULT hr = E_FAIL;
	
    // Check parameters
    if( (NULL == rgchBuf) ||
        (NULL == pdwLen) )
    {
		hr = E_INVALIDARG;
		goto lbDone;
    }
	
    // check if connection is established
    if( INVALID_SOCKET == m_s )
    {
		hr = HRESULT_FROM_WIN32(WSAENOTCONN);
		goto lbDone;
    }
	
    // wrap w/ wsa buffer
    WSABUF Buffer;
    Buffer.buf = (char*)rgchBuf;
    Buffer.len = dwLen;
	
    // create io completion event
    WSAOVERLAPPED overlapped;
    overlapped.hEvent = WSACreateEvent();
    if( NULL == overlapped.hEvent)
    {
		hr = HRESULT_FROM_WIN32(WSAGetLastError());
		ERR1(Conn, "WSACreateEvent() failed with HR: 0x%08x", hr);
		goto lbDone;
    }
	
    // populate event array
    UINT uicEvents = 1;
    WSAEVENT rghEvents[2];
    rghEvents[0] = overlapped.hEvent;
    if( NULL != m_hShutdownEvent )
    {
        uicEvents = 2;
        rghEvents[1] = m_hShutdownEvent;
    }
	
    // receive data
    DWORD dwFlags = 0L;
    *pdwLen       = 0L;
    int iRC = WSARecvFrom(
        m_s,
        &Buffer,
        1,
        pdwLen,
        &dwFlags,
        lpFrom,
        piFromLen,
        &overlapped,
        NULL );
	
    if( 0 != iRC )
    {
        // blocks
        int iErr = WSAGetLastError();
        if( WSA_IO_PENDING==iErr ) 
        {
            
            // wait for completion event or shutdown
            DWORD dwErr = WSAWaitForMultipleEvents( uicEvents, rghEvents, FALSE, dwTimeout, FALSE );
            if( (WSA_WAIT_FAILED == dwErr) ||
                (WSA_WAIT_TIMEOUT == dwErr) ||
                (1 == dwErr) )
            {
				hr = HRESULT_FROM_WIN32(WSAGetLastError());
				ERR1(Conn, "WSAWaitForMultipleEvents failed with HR: 0x%08x", hr);
				goto lbDone;
            }
			
			// get bytes received
			if( FALSE == WSAGetOverlappedResult( m_s, &overlapped, pdwLen, FALSE, &dwFlags ) )
			{
				hr = HRESULT_FROM_WIN32(WSAGetLastError());
				ERR1(Conn, "WSAGetOverlappedResult failed with HR: 0x%08x", hr);
				goto lbDone;
            }
        }
        else
        {
			hr = HRESULT_FROM_WIN32(iErr);
			ERR1(Conn, "WSAGetLastError was not WSA_IO_PENDING: failed with HR: 0x%08x", hr);
			goto lbDone;
        }
    }
    else
    {
		// RecvFrom returned 0
	}
	
    // close event
    BOOL fClosed = WSACloseEvent( overlapped.hEvent );
    if( FALSE == fClosed )
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
		ERR1(Conn, "WSACloseEvent() failed with HR: 0x%08x", hr);
		goto lbDone;
    }

	// Succeeded
	hr = S_OK;
	
lbDone:
    return hr;
}

/////////////////////////////////////////////////
//  Reset Buffers
//
//  Reset overlapped buffers
//
HRESULT BaseConnection::ResetBuffers()
{
	HRESULT hr = S_OK;

    // Reset any existing buffers
    for( UINT ui = 0; ui < m_uicWriteBuffers; ui++ )
    {
        m_rgWriteBuffer[ui].len          = 0;
        m_rgWriteOverlapped[ui].fPending = false;
		
        BOOL fReset = WSAResetEvent( m_rgWriteOverlapped[ui].hEvent );
		if(!fReset)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			ERR1(Conn, "WSAResetEvent() failed with HR: 0x%08x", hr);
			break;	
		}
    }

    m_uiWriteIndex = 0;

    return hr;
}

/////////////////////////////////////////////////
//  Send To Flush
//
// Throw overlapped buffer to winsock
//
HRESULT BaseConnection::SendToFlush(
									DWORD                  dwTimeout /* = WSA_INFINITE */, 
									const struct sockaddr* lpTo      /* = NULL */, 
									int                    iToLen    /* = 0 */ )
{
	HRESULT hr = E_FAIL;

    // Check if connection is established
    if( INVALID_SOCKET == m_s )
    {
		hr = HRESULT_FROM_WIN32(WSAENOTCONN);
		goto lbDone;
    }
	
    // Was buffer pending?
    if( m_rgWriteOverlapped[ m_uiWriteIndex ].fPending )
    {
        
        // Populate event array
        m_rghEvents[0] = m_rgWriteOverlapped[ m_uiWriteIndex ].hEvent;
		
        // Wait for buffer to unlock or for shutdown event to fire
        DWORD dwErr = WSAWaitForMultipleEvents( m_uicEvents, m_rghEvents, FALSE, dwTimeout, FALSE );
        if( (WSA_WAIT_FAILED    == dwErr) ||
            (WSA_WAIT_TIMEOUT   == dwErr) ||
            (WSA_WAIT_EVENT_0+1 == dwErr) )
        {
			hr = HRESULT_FROM_WIN32(WSAGetLastError());
			ERR1(Conn, "WSAWaitForMultipleEvents() failed with HR: 0x%08x", hr);
			goto lbDone;
        }
		
        // Reuse the buffer and set the offset back to 0; data was sent
        m_rgWriteOverlapped[ m_uiWriteIndex].fPending = false;
        m_rgWriteBuffer[     m_uiWriteIndex].len      = 0;
		
		// Shortcircuit since we have data now
        hr = S_OK;
		goto lbDone;
    }
	
    // Initialize number of bytes sent
    DWORD dwBytesSent = 0L;
	
    // Reset overlapped object's wsa event
    WSAResetEvent( m_rgWriteOverlapped[ m_uiWriteIndex ].hEvent );
	
    // Send 
    int iRC = WSASendTo( 
        m_s, 
        &m_rgWriteBuffer[m_uiWriteIndex],
        1,
        &dwBytesSent,
        0,
        lpTo,
        iToLen,
        &m_rgWriteOverlapped[m_uiWriteIndex],
        NULL);
	
    if( 0 != iRC )
    {
        int iError = WSAGetLastError();
		
        // Pending?
        if( WSA_IO_PENDING != iError )
        {
			hr = HRESULT_FROM_WIN32( iError );    
			ERR1(Conn, "WSASendTo() failed with HR: 0x%08x", hr);
			goto lbDone;
        }
		
        
        // Mark buffer as submitted
        m_rgWriteOverlapped[m_uiWriteIndex].fPending = true;
		
        // Set new current buffer
        if( ++m_uiWriteIndex >= m_uicWriteBuffers) 
		{
            m_uiWriteIndex = 0;
        }
    }
    else
    {
        // All data sent?
        if( dwBytesSent != m_rgWriteBuffer[m_uiWriteIndex].len)
        {
            ERR0(Conn, "Should have gone to WSA_IO_PENDING!");
			hr = E_FAIL;
			goto lbDone;
        }
		
        // Data was sent; set buffer offset back to 0
        m_rgWriteBuffer[m_uiWriteIndex].len = 0;
    }

	// Succeeded
	hr = S_OK;

lbDone:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// TCP Client Connection
///////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////
//  Ctor
//
TCPClientConnection::TCPClientConnection(
										 HANDLE hShutdownEvent    /* = NULL */, 
										 UINT   uicWriteBuffers   /* = DEFAULTBUFFERS */, 
										 INT    icWriteBufferSize /* = DEFAULTBUFFERSIZE */, 
										 INT    icReadBufferSize  /* = -1 */,
										 BOOL fReuseAddress /* = false */)
										 :
BaseConnection( hShutdownEvent, uicWriteBuffers, icWriteBufferSize, icReadBufferSize )
{
    
    // create close event
    m_hCloseEvent = WSACreateEvent();
	
    if (!m_hCloseEvent)
    {
        //TRACE1(L_ERROR, "Could Not Create Event, HRESULT: 0x%08x\n", HRESULT_FROM_WIN32(WSAGetLastError()));
    }
    m_wOutGoingPort = 0;
    m_fReuseAddress = fReuseAddress;
}

/////////////////////////////////////////////////
//  Dtor
//
TCPClientConnection::~TCPClientConnection()
{
	
    // Close socket
    Close();
	
    // close event
    BOOL fClosed = WSACloseEvent( m_hCloseEvent );
	if(!fClosed)
	{
		ERR1(Conn, "TCPClientConnection::~TCPClientConnection(): WSACloseEvent() failed with HR: 0x%08x", 
				HRESULT_FROM_WIN32(WSAGetLastError()));
	}
}

/////////////////////////////////////////////////
//  Connect
//
HRESULT TCPClientConnection::Connect(
									 DWORD dwIP, 
									 WORD  wPort, 
									 DWORD dwTimeout )   // = WSA_INFINITE
{
   	HRESULT hr = E_FAIL;

    // already connected?
    if( INVALID_SOCKET != m_s )
    {
		hr = HRESULT_FROM_WIN32(WSAENOTCONN);
		goto lbDone;
    }
	
    // create socket
    m_s = WSASocket( AF_INET,SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED );
	if( INVALID_SOCKET == m_s )
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
		ERR1(Conn, "WSASocket() failed with HR: 0x%08x", hr);
		goto lbDone;
    }
	
    // Set the send buffer size to 0; forcing our local buffers to be used preventing any bad-performance copy
    int iBufferSize = 0;
    if( 0 != setsockopt( m_s, SOL_SOCKET, SO_SNDBUF, (char*)&iBufferSize, sizeof(iBufferSize) ) )
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
		ERR1(Conn, "setsockopt(SO_SNDBUF) failed with HR: 0x%08x", hr);
		goto lbDone;
    }
	
    // Set the socket option to reuse address
    if (0 != setsockopt( m_s, SOL_SOCKET, SO_REUSEADDR, (const char *)&m_fReuseAddress, sizeof(BOOL) ))
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
		ERR1(Conn, "setsockopt(SO_REUSEADDR) failed with HR: 0x%08x", hr);
		goto lbDone;
    }
	
    // If user has requested a different receive buffer size, set it
    if( -1 != m_icReadBufferSize ) 
    {
		iBufferSize = m_icReadBufferSize;
        if( 0 != setsockopt( m_s, SOL_SOCKET, SO_RCVBUF, (char*)&iBufferSize, sizeof(iBufferSize) ) )
        {
            hr = HRESULT_FROM_WIN32(WSAGetLastError());
			ERR1(Conn, "setsockopt(SO_RCVBUF) failed with HR: 0x%08x", hr);
			goto lbDone;
        }
    }
	
    // create address
    SOCKADDR_IN sin;
    sin.sin_family      = AF_INET;
    sin.sin_port        = htons(wPort);
    sin.sin_addr.s_addr = dwIP;
	
    // create event array
    WSAEVENT rghEvents[2];
    rghEvents[0] = WSACreateEvent();
    if( NULL==rghEvents[0] )
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
		ERR1(Conn, "WSACreateEvent() failed with HR: 0x%08x", hr);
		goto lbDone;
    }
	
    // populate event array
    UINT uicEvents = 1;
    if( NULL!=m_hShutdownEvent )
    {
        uicEvents    = 2;
        rghEvents[1] = m_hShutdownEvent;
    }
	
    // register for network event
    if( SOCKET_ERROR == WSAEventSelect( m_s, rghEvents[0], FD_CONNECT ) )
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
		ERR1(Conn, "WSAEventSelect() failed with HR: 0x%08x", hr);
        ::WSACloseEvent(rghEvents[0]);
		goto lbDone;
    }
	
    // connect
	hr = S_OK;
    if( SOCKET_ERROR == WSAConnect( m_s, (const SOCKADDR*) &sin, sizeof(sin), NULL, NULL, NULL, NULL ) )
    {
        // blocks
        if( WSAEWOULDBLOCK==WSAGetLastError())
        {
            // wait for network event or shutdown
            DWORD dwErr = WSAWaitForMultipleEvents( uicEvents, rghEvents, false, dwTimeout, false );
            if( (WSA_WAIT_FAILED == dwErr) ||
                (WSA_WAIT_TIMEOUT==dwErr) ||
                (1 == dwErr) )
            {
                hr = HRESULT_FROM_WIN32(WSAGetLastError());
            }
			
            // success?
            if(SUCCEEDED(hr))
            {
                // get network event
                WSANETWORKEVENTS NetworkEvents;
                if( SOCKET_ERROR == WSAEnumNetworkEvents( m_s, rghEvents[0], &NetworkEvents ) )
                {
                    hr = HRESULT_FROM_WIN32(WSAGetLastError());
                }
				
                // success?
                if(SUCCEEDED(hr))
                {
                    // check network event error code
                    if( ((NetworkEvents.lNetworkEvents & FD_CONNECT ) == FD_CONNECT) && 
                        (NetworkEvents.iErrorCode[FD_CONNECT_BIT] != 0) )
                    {
                        hr = HRESULT_FROM_WIN32(NetworkEvents.iErrorCode[FD_CONNECT_BIT]);
                    }
                }
				else
				{
					ERR1(Conn, "WSAEnumNetworkEvents() failed with HR: 0x%08x", hr);
					goto lbDone;
				}
            }
			else
			{
				ERR1(Conn, "WSAWaitForMultipleEvents() failed with HR: 0x%08x", hr);
				goto lbDone;
			}
        }
        else
        {
            // error other than blocking occurred from WSAConnect()
            hr = HRESULT_FROM_WIN32(WSAGetLastError());
			ERR1(Conn, "WSAConnect() failed with HR: 0x%08x", hr);
			goto lbDone;
        }
    }

	// WSAConnect failed after wait for events
	if(FAILED(hr))
	{
		ERR1(Conn, "WSAConnect() failed delayed connection: HR: 0x%08x", hr);
		goto lbDone;
	}

	
	// Get the Outgoing socket
    SOCKADDR_IN sddrFrom;
    int x = sizeof(sddrFrom);
    getsockname( m_s, (SOCKADDR*)&sddrFrom, &x);
    //printf("Outgoing port  %d\n", ntohs (sddrFrom.sin_port));
    m_wOutGoingPort = ntohs (sddrFrom.sin_port);
	
    // unregister for network event
    if( SOCKET_ERROR == WSAEventSelect( m_s, rghEvents[0], 0 ) )
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
		ERR1(Conn, "WSAEventSelect() failed with HR: 0x%08x", hr);
		goto lbDone;
    }
	
    // close event
    if( FALSE == WSACloseEvent(rghEvents[0] ) )
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
		ERR1(Conn, "WSACloseEvent() failed with HR: 0x%08x", hr);
		goto lbDone;
    }
	
    // register for socket close event
    WSAResetEvent( m_hCloseEvent );
    if( SOCKET_ERROR == WSAEventSelect( m_s, m_hCloseEvent, FD_CLOSE ) )
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
		ERR1(Conn, "WSAResetEvent() failed with HR: 0x%08x", hr);
		goto lbDone;
    }
	
    // Reset buffers
	if(FAILED(hr = ResetBuffers()))
	{
		ERR1(Conn, "ResetBuffers() failed with HR: 0x%08x", hr);
		goto lbDone;
	}
   

lbDone:
	
    return hr;
}

/////////////////////////////////////////////////
//  Wait For Disconnect
//
bool TCPClientConnection::WaitForDisconnect(
											int iTimeout )
{
	
    // create event array
    UINT uicEvents = 1;
    WSAEVENT l_rgEvents[2];    
    l_rgEvents[0] = m_hCloseEvent;
    if( NULL != m_hShutdownEvent)
    {
        uicEvents     = 2;
        l_rgEvents[1] = m_hShutdownEvent;
    }
	
    // wait for event or timeout
    DWORD dwErr = WSAWaitForMultipleEvents( uicEvents, l_rgEvents, false, iTimeout, false );
    if( (WSA_WAIT_TIMEOUT!=dwErr) ||
        (1==dwErr) )
    {
        Close();
    }
    
    // if connection is gone set retval to false
    if( INVALID_SOCKET == m_s )
    {
        return false;
    }
	
    return true;
}

/////////////////////////////////////////////////
//  Close 
//
HRESULT TCPClientConnection::Close(
								   bool fHard /* = false */ )
{
	
    // Socket closed?
    if( INVALID_SOCKET == m_s) 
    {   
		return S_FALSE;
    }
	
    int iWSALastErr = 0;
    if( fHard )
    {
        
        //Hard disconnect!
        LINGER linger;
        linger.l_onoff  = 1;
        linger.l_linger = 0;
        if( 0 != setsockopt( m_s, SOL_SOCKET, SO_LINGER, (const char *)&linger, sizeof(linger) ) )
        {
            return HRESULT_FROM_WIN32(WSAGetLastError());
        }
    }
    else
    {
        SendToFlush();
    }
    
    if( SOCKET_ERROR == shutdown( m_s, SD_SEND ) )
    {
        return HRESULT_FROM_WIN32(WSAGetLastError());;
    }
	
    // create event array
    UINT uicEvents = 1;
    WSAEVENT rgEvents[2];    
    rgEvents[0] = m_hCloseEvent;
    if( NULL != m_hShutdownEvent)
    {
        uicEvents   = 2;
        rgEvents[1] = m_hShutdownEvent;
    }
	
    // wait for close event or timeout
    int iTimeout = 60000;
    DWORD dwErr = WSAWaitForMultipleEvents( uicEvents, rgEvents, false, iTimeout, false );
    if( 0 != dwErr )
    {
        return HRESULT_FROM_WIN32(WSAGetLastError());;
    }
	
    // Read socket to detect remote close
	
    // wrap w/ wsa buffer
    WSABUF Buffer;
    char  acGarbage[ 128 ];  // TBD!!! Get this off stack use send buff
    Buffer.buf = acGarbage;
    Buffer.len = 128;
	
    // create io completion event
    WSAOVERLAPPED overlapped;
    overlapped.hEvent = WSACreateEvent();
    if( NULL == overlapped.hEvent)
    {
		return HRESULT_FROM_WIN32(WSAGetLastError());
    }
    rgEvents[0] = overlapped.hEvent;
	
    HRESULT hr = S_OK;
	
    bool bDoneReading = false;
    while( ! bDoneReading )
    {
        // receive data
        DWORD dwFlags = 0L;
        DWORD dwLen = 128;
        int iRC = WSARecvFrom(
            m_s,
            &Buffer,
            1,
            &dwLen,
            &dwFlags,
            NULL,
            NULL,
            &overlapped,
            NULL );
		
        if( 0 == iRC )
        {
            if( dwLen == 0 )
            {
                bDoneReading = true;
            }
        }
        else
        {
            // blocks
            int iErr = WSAGetLastError();
            if( WSA_IO_PENDING == iErr ) 
            {
                
                // wait for completion event or shutdown
                DWORD dwTimeout = 60000;
                DWORD dwErr = WSAWaitForMultipleEvents( uicEvents, rgEvents, FALSE, dwTimeout, FALSE );
                if( (WSA_WAIT_FAILED == dwErr) ||
                    (WSA_WAIT_TIMEOUT == dwErr) ||
                    (1 == dwErr) )
                {
                    hr = HRESULT_FROM_WIN32(WSAGetLastError());;
                    break;
                }
				
				// get bytes received
                if( FALSE == WSAGetOverlappedResult( m_s, &overlapped, &dwLen, FALSE, &dwFlags ) )
                {
					hr = HRESULT_FROM_WIN32(WSAGetLastError());
                    break;
                }
                else
                {
                    if( dwLen == 0 )
                    {
                        bDoneReading = true;
                    }
                }
            }
            else
            {
                if( iErr != WSAEWOULDBLOCK )
                {
					bDoneReading = true;
                }
            }
        }
    }
	
    BOOL fClosed = WSACloseEvent( overlapped.hEvent );
	
    // Close socket
    if( SOCKET_ERROR == closesocket( m_s ) )
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
    }
	
    // Set internal state
    m_s = INVALID_SOCKET;
	
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// UDP Connection
///////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////
//  Ctor 
//
UDPConnection::UDPConnection(
							 HANDLE hShutdownEvent    /* = NULL */, 
							 UINT   uicWriteBuffers   /* = DEFAULTBUFFERS */, 
							 INT    icWriteBufferSize /* = DEFAULTBUFFERSIZE */, 
							 INT    icReadBufferSize  /* = -1 */ )
							 :
BaseConnection( hShutdownEvent, uicWriteBuffers, icWriteBufferSize, icReadBufferSize )
{
    
    // Socket setup
    m_s = WSASocket(AF_INET,SOCK_DGRAM,0,NULL,0,WSA_FLAG_OVERLAPPED);
    if( INVALID_SOCKET == m_s )
    {
        return;
    }
	
    // Set the send buffer size to 0; forcing our local buffers to be used preventing any bad-performance copy
    INT iBufferSize = 0;
    if( 0!= setsockopt( m_s, SOL_SOCKET, SO_SNDBUF, (char*)&iBufferSize, sizeof(iBufferSize) ) )
    {
        return;
    }
	
    // If user has requested a different receive buffer size, set it
    if( -1 != m_icReadBufferSize )
    {
		iBufferSize = m_icReadBufferSize;
        if( 0 != setsockopt( m_s, SOL_SOCKET, SO_RCVBUF, (char*)&iBufferSize, sizeof(iBufferSize) ) )
        {
            return;
        }
    }
}

/////////////////////////////////////////////////
//  Dtor 
//
UDPConnection::~UDPConnection()
{
	
    if (m_s != INVALID_SOCKET)
    {
        shutdown( m_s, SD_SEND );
		
        closesocket( m_s );
		
        m_s = INVALID_SOCKET;
    }
}

/////////////////////////////////////////////////
//  Bind 
//
HRESULT UDPConnection::Bind( WORD wPort, DWORD inaddr)
{
	int result;
	HRESULT hr = E_FAIL;

    // Socket address
    SOCKADDR_IN sin;
    sin.sin_family      = AF_INET;
    sin.sin_port        = htons( wPort );
    sin.sin_addr.s_addr = inaddr;
	
    BOOL fVal = TRUE;
    result = setsockopt( m_s, SOL_SOCKET, SO_REUSEADDR, (const char *)&fVal, sizeof(BOOL) );
	if(SOCKET_ERROR == result)
	{
		hr = HRESULT_FROM_WIN32(WSAGetLastError());
		ERR1(Conn, "setsockopt(SO_REUSEADDR) failed HR: 0x%08x", hr);
		goto lbDone;
	}
	
    // Bind socket
	result = ::bind( m_s,(struct sockaddr *)&sin, sizeof(sin) );
    if( SOCKET_ERROR == result)
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());  //Unable to bind socket
		ERR1(Conn, "bind() failed with HR: 0x%08x", hr);
		goto lbDone;
    }
    
	hr = S_OK;
lbDone:
    return hr;
}

/////////////////////////////////////////////////
//  Close 
//
HRESULT UDPConnection::Close(
							 bool fHard /* = false */ )
{
	int iErr;
	
    // Socket closed?
    if( INVALID_SOCKET == m_s) 
    {   
		return S_FALSE;
    }
	
    if( fHard )
    {
        
        //Hard disconnect!
		LINGER linger;
		linger.l_onoff  = 1;
		linger.l_linger = 0;
		iErr = setsockopt( m_s, SOL_SOCKET, SO_LINGER, (const char *)&linger, sizeof(LINGER) );
		if(SOCKET_ERROR == iErr)
		{
			ERR1(Conn, "UDPConnection::Close() setsockopt(SO_LINGER) failed, HR: 0x%08x", 
					HRESULT_FROM_WIN32(WSAGetLastError()));
		}

        iErr = shutdown( m_s, SD_SEND );
        if(SOCKET_ERROR == iErr)
		{
			ERR1(Conn, "UDPConnection::Close() shutdown(SD_SEND) failed, HR: 0x%08x", 
					HRESULT_FROM_WIN32(WSAGetLastError()));
		}
    }
    else
    {
        BOOL fValue = true;
        iErr = setsockopt(m_s,SOL_SOCKET,SO_DONTLINGER,(const char *)&fValue,sizeof(BOOL));
		if(SOCKET_ERROR == iErr)
		{
			ERR1(Conn, "UDPConnection::Close() setsockopt(SO_DONTLINGER) failed, HR: 0x%08x", 
					HRESULT_FROM_WIN32(WSAGetLastError()));
		}
        SendToFlush();
		
        iErr = shutdown(m_s, SD_SEND);
		if(SOCKET_ERROR == iErr)
		{
			ERR1(Conn, "UDPConnection::Close() shutdown(SD_SEND) failed, HR: 0x%08x", 
					HRESULT_FROM_WIN32(WSAGetLastError()));
		}
    }
	
    // Close socket
    iErr = closesocket(m_s);
	if(SOCKET_ERROR == iErr)
	{
		ERR1(Conn, "UDPConnection::Close() closesocket() failed, HR: 0x%08x", 
				HRESULT_FROM_WIN32(WSAGetLastError()));
	}
	
    // Set internal state
    m_s = INVALID_SOCKET;
	
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// HELPER FUNCTIONS
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////
//  Get Local Address 
//
//  Helper function getting local ip as  DWORD
//
DWORD GetLocalAddress()
{
    
    DWORD dwIP = INADDR_NONE;
	
    char szHost[ 128 ];
    if( 0 == gethostname( szHost, 128 ) )
    {
        HOSTENT* pHostEnt= ::gethostbyname( szHost );
        if( NULL != pHostEnt )
        {
            DWORD dwFavorite = 0xFFFFFFFF;
            int iAddr = 0;
            while( NULL != pHostEnt->h_addr_list[ iAddr ] )
            {
                // This will prefer the lowest address in host order.  For our networks, this means Testnet addresses
                // will be preferred over corpnet addresses and front tier will be preferred over back tier.
                dwFavorite = min( dwFavorite, ntohl( *((DWORD*)pHostEnt->h_addr_list[ iAddr ] ) ) );
                iAddr++;
            }
			
            if( 0xFFFFFFFF != dwFavorite )
            {
                dwIP = htonl( dwFavorite );
            }
        }
    }
	
    return dwIP;  //Return IP address
}

/////////////////////////////////////////////////
//  Internet Address
//
//  Helper function converting names or ips to DWORD
//
DWORD InternetAddress(
					  const char* pszHost )
{
    
    DWORD dwIP = INADDR_NONE;
	
    // Get IP address
    dwIP = ::inet_addr( pszHost );
    if( dwIP == INADDR_NONE )
    {
        HOSTENT* pHostEnt = ::gethostbyname( pszHost );
        if( NULL != pHostEnt )
        {
            dwIP = *( (LPDWORD)pHostEnt->h_addr );
        }
    }
	
    return dwIP; // Return IP address
}

/////////////////////////////////////////////////
//  Winsock UP
//  Helper function to bring up winsock layer
//
//
HRESULT WinsockUP()
{
	
    // Set version requested
    WORD wVersionRequested = MAKEWORD( 2, 2 );
	
    // WSAStartup
    WSADATA wsaData; // Version of winsock the system supports
    int err = WSAStartup( wVersionRequested, &wsaData );
    if( err != 0 )
    {
        return HRESULT_FROM_WIN32(WSAGetLastError()); // Unable to start winsock
    }
	
    // Check version
    if( LOBYTE(wsaData.wVersion) != 2 ||
        HIBYTE(wsaData.wVersion) != 2 )
    {
        WSACleanup();
        return HRESULT_FROM_WIN32(WSAGetLastError()); // Wrong version of winsock 
    }
	
    // Success
    return S_OK;
}

/////////////////////////////////////////////////
//  Winsock DOWN
//
//  Helper function to bring down winsock layer
//
HRESULT WinsockDOWN()
{
    
    // WSACleanup
    int err=WSACleanup();
    if( err != 0 )
    {
        return HRESULT_FROM_WIN32(WSAGetLastError()); // Unable to bring down winsock
    }

    // Success
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\Connection.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#ifndef __CONNECTION_H_
#define __CONNECTION_H_

#ifndef _WINDOWS_
#include <windows.h>
#endif

#define DEFAULTBUFFERSIZE 1024
#define DEFAULTBUFFERS 1

/////////////////////////////////////////////////
//  WSAOVERLAPPEDEX
//
struct WSAOVERLAPPEDEX : public WSAOVERLAPPED 
{
	bool fPending;
};

/////////////////////////////////////////////////
//  Base Connection
//
class BaseConnection
{
public:

	// Constructor - This form is for establishing a new connection
	BaseConnection(
        HANDLE hShutdownEvent    = NULL, 
        UINT   uicWriteBuffers   = DEFAULTBUFFERS, 
        INT    icWriteBufferSize = DEFAULTBUFFERSIZE, 
        INT    icReadBufferSize  = -1 );

	// Destructor
	virtual ~BaseConnection();

	void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

	// Wait for all overlapped async buffers to be in non-pending state
	HRESULT WaitForAllPendingBuffersToFlush(
        DWORD dwTimeout );

	// Get socket name
	const sockaddr_in *GetSockName() const
	{
		int cbSin = sizeof(sockaddr_in);

		if (getsockname(m_s, (SOCKADDR *)&m_sin, &cbSin) == SOCKET_ERROR)
		{
			return NULL;
		}

		return &m_sin;
	}
    
    WORD GetClientPort()     
    {
        GetSockName();
        return m_sin.sin_port;
    }

	DWORD GetClientAddr()
	{
        GetSockName();
		return (DWORD)m_sin.sin_addr.S_un.S_addr;
	}

	const char *GetClientIp()
	{
        GetSockName();
		return inet_ntoa(m_sin.sin_addr);
	}

	SOCKET GetSockHandle() const { return m_s; }

protected:

	// Send data down connection
	HRESULT SendTo(
        const char*            rgchBuf, 
        int                    iLen, 
        BOOL                   fFlush    = TRUE, 
        DWORD                  dwTimeout = WSA_INFINITE, 
        const struct sockaddr* lpTo      = NULL, 
        int                    iToLen    = 0 );

	// Receive data off the connection
	HRESULT ReceiveFrom(
        char*            rgchBuf, 
        DWORD            dwLen, 
        DWORD*           pdwLen, 
        DWORD            dwTimeout = WSA_INFINITE, 
        struct sockaddr* lpFrom    = NULL, 
        int*             piFromLen = 0 );

	// Reset overlapped buffers
	HRESULT ResetBuffers();

	// Flush buffers to wire
	HRESULT SendToFlush(
        DWORD                  dwTimeout = WSA_INFINITE, 
        const struct sockaddr* lpTo      = NULL, 
        int                    iToLen    = 0 );

protected:

	SOCKET m_s;                // Overlapped socket
	HANDLE m_hShutdownEvent;   // Shutdown event
	INT    m_icReadBufferSize; // Internal buffer read size

private:

	WSAEVENT m_rghEvents[2]; // Can hold one overlapped event and a shutdown event
	UINT     m_uicEvents;    // Number of WSA wait event (depends if shutdownevent was provided)
	
    UINT             m_uicWriteBuffers;   // Number of write buffers
	INT              m_icWriteBufferSize; // Max size of a write buffer
	WSABUF*          m_rgWriteBuffer;     // Array of WSABUFs
	WSAOVERLAPPEDEX* m_rgWriteOverlapped; // Array of overlapped events
	UINT             m_uiWriteIndex;      // Current write buffer to write to
	sockaddr_in		 m_sin;		          // The current socket address information for this socket
};
    
/////////////////////////////////////////////////
//  TCP Client Connection
//
// Construct any class with the optional hShutdownEvent parameter so that you 
// can cancel ANY outstanding network operation.  These class methods will
// block until each operation is complete OR the hShutdownEvent has is thrown.
// All blocking methods perform smart sleep states until network action can
// be completed or the hShutdownEvent is thrown.
//
class TCPClientConnection : public BaseConnection
{
public:

	// Constructor - This form is for establishing a new connection
	TCPClientConnection(
        HANDLE hShutdownEvent    = NULL, 
        UINT   uicWriteBuffers   = DEFAULTBUFFERS, 
        INT    icWriteBufferSize = DEFAULTBUFFERSIZE, 
        INT    icReadBufferSize  = -1,
        BOOL fReuseAddress = false);

	// Destructor
	virtual ~TCPClientConnection();

	void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

	// Establish connection
	HRESULT Connect(
        DWORD dwIP, 
        WORD  wPortD, 
        DWORD dwTimeout = WSA_INFINITE );

	// Wait for socket disconnect or timeout
	bool WaitForDisconnect(
        int iTimeout );

	// Close connection
	HRESULT Close(
        bool fHard = false );
	
	// Send data down connection
	HRESULT Send(
        const char* rgchBuf, 
        int         iLen, 
        BOOL        fFlush    = TRUE, 
        DWORD       dwTimeout = WSA_INFINITE )
    {
		return SendTo( rgchBuf, iLen, fFlush, dwTimeout );
	}

	// Receive data off the connection
	HRESULT Receive(
        char*  rgchBuf, 
        DWORD  dwLen, 
        DWORD* pdwLen, 
        DWORD  dwTimeout = WSA_INFINITE )
    {
		return ReceiveFrom( rgchBuf, dwLen, pdwLen, dwTimeout );
	}

    WORD TCPGetOutGoingPort(VOID){ return m_wOutGoingPort;}

private:
	BOOL m_fReuseAddress;
	WORD  m_wOutGoingPort;
	WSAEVENT m_hCloseEvent; // Close event
};

/////////////////////////////////////////////////
//  UDP Connection
//
// UDP based connection wrapper class used to send or receive data.  Use 
// Bind() method only for establishing a port bind for ReceiveFrom().
//
class UDPConnection : public BaseConnection
{
public:

	// Constructor - use INADDR_ANY for receiving any source on specified port
	UDPConnection(
        HANDLE hShutdownEvent    = NULL, 
        UINT   uicWriteBuffers   = DEFAULTBUFFERS, 
        INT    icWriteBufferSize = DEFAULTBUFFERSIZE, 
        INT    icReadBufferSize  = -1 );

	// Destructor
	virtual ~UDPConnection();

	void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

	// Bind socket to port
	HRESULT Bind( WORD wPort, DWORD inaddr = INADDR_ANY );

	// Close socket
	HRESULT Close(
        bool fHard = false );
	
	// Send data down connection
	HRESULT SendTo(
        const char*            rgchBuf, 
        int                    iLen, 
        BOOL                   fFlush    = TRUE, 
        DWORD                  dwTimeout = WSA_INFINITE, 
        const struct sockaddr* lpTo      = NULL, 
        int                    iToLen    = 0 )
    {
        return BaseConnection::SendTo( rgchBuf, iLen, fFlush, dwTimeout, lpTo, iToLen );
	}

	// Receive data off the connection
	HRESULT ReceiveFrom(
        char*            rgchBuf, 
        DWORD            dwLen, 
        DWORD*           pdwLen, 
        DWORD            dwTimeout = WSA_INFINITE, 
        struct sockaddr* lpFrom    = NULL, 
        int*             piFromLen = 0 )
    {
		return BaseConnection::ReceiveFrom( rgchBuf, dwLen, pdwLen, dwTimeout, lpFrom, piFromLen );
	}
};

/////////////////////////////////////////////////////////////////////////////
// HELPER FUNCTIONS
/////////////////////////////////////////////////////////////////////////////

// GetLoccalAddress - Helper function getting local ip as  DWORD
DWORD GetLocalAddress();

// InternetAddress - Helper function converting names or ips to DWORD
DWORD InternetAddress(
    const char* pszHost );

// WinsockUP - Helper function to bring up winsock layer
HRESULT WinsockUP();

// WinsockDOWN - Helper function to bring down winsock layer
HRESULT WinsockDOWN();
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\Memory.cpp ===
#include "PTNCore.h"

MGMT_DefineLoggingCategory(Memory);

char *Duplicate(const char *psz)
{
	ASSERT_THROW(NULL != psz);
	LONG len = strlen(psz);
	char *pszCopy = (char*)XAlloc(len+1);
	CopyMemory(pszCopy, psz, len+1);
	return pszCopy;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\Management.cpp ===
#include "PTNCore.h"

MGMT_DefineLoggingCategory( mgmt );

#include "ManagementInternals.h"
	ConfigWrapper::ConfigWrapper() : 
		m_pConfig(0),
		m_bInitialized(false)
	{}
	ConfigWrapper::~ConfigWrapper()
	{
		SAFE_RELEASE(m_pConfig);
	}

	bool ConfigWrapper::IsInitialized() const
	{
		return m_bInitialized;
	}

	XblConfig::IConfig *ConfigWrapper::operator->() const
	{
		ASSERT_THROW(0 != m_pConfig);	
		return m_pConfig;
	}

	// This function was adapated from xmgmt.cpp
	HRESULT ConfigWrapper::Initialize()
	{
		HRESULT hr = E_FAIL;
		BOOL fTryAgain = TRUE;
lTryAgain:
		//
		// Create an instance of the Config class
		//
		hr = CoCreateInstance( __uuidof(XblConfig::ConfigInterop), NULL, CLSCTX_ALL, __uuidof(XblConfig::IConfig), (void**)&m_pConfig);
		if (FAILED(hr))
		{
			if ( CO_E_NOTINITIALIZED == hr && fTryAgain )
			{
				fTryAgain = FALSE;

				ERR0(mgmt, "[ConfigWrapper::Initialize] Component needs to call CoInitialize prior to calling g_xomcentral.Init.  Calling CoInitialize implicitly..." );

				hr = CoInitialize(NULL);
				if (FAILED(hr))
				{
					ERR1( mgmt, "[ConfigWrapper::Initialize] Failed to CoInitialize. hr = 0x%08x", hr );
					goto lDone;
				}

				// CoInitialize has been called... try CoCreateInstance one more time
				goto lTryAgain;
			}

			ERR1( mgmt, "[ConfigWrapper::Initialize] Failed to CoCreateInstance of ConfigInterop. hr = 0x%08x", hr );
			goto lDone;
		}

		// Leave the component name 'unknown' we do not need overrides
lDone:
		return hr;
	}

static Console *__pConsoleInstance;
ConfigWrapper __gConfigWrapper;

// Upper word is for the change signature. Lower word is for
// enable level of trace statements. The first time a trace is hit
// it will check it's logging level against config signature.
DWORD Management::g_dwLoggingConfigSignature = 0x00010000;

Console::Console()
{
	MGMT_GetLoggingCategory(mgmt).SetEnableLevel(L_NORMAL);
}

Console::~Console()
{
	RemoveAllLoggingCategories();	
	RemoveAllLoggingTargets();
	RemoveAllConfigSettings();
	

	MGMT_GetLoggingCategory(mgmt).RemoveAllLoggingTargets();
}

void Console::Initialize()
{
	// Add some default targets
	AutoRef<Target> refStdoutTarget(new Target("stdout"));
	AutoRef<_FileStreamLogStream> refStdoutLogStream(new _FileStreamLogStream(stdout));
	AutoRef<Target> refDebugTarget(new Target("debug"));
	AutoRef<_DebugLogStream> refDebugLogStream(new _DebugLogStream());

	refStdoutTarget->SetLogStream(refStdoutLogStream);
	refDebugTarget->SetLogStream(refDebugLogStream);

	// Add target to console and diagnostic logging category
	AddLoggingTarget(refStdoutTarget);
	AddLoggingTarget(refDebugTarget);
	MGMT_GetLoggingCategory(mgmt).AddLoggingTarget(refStdoutTarget);
	MGMT_GetLoggingCategory(mgmt).AddLoggingTarget(refDebugTarget);

	INF0(mgmt, "Management console logging initialized");

	// Initialize common config
	HRESULT hr;
	if(!__gConfigWrapper.IsInitialized())
	{
		if(FAILED(hr = __gConfigWrapper.Initialize()))
		{
			// Non-fatal
			ERR1(mgmt, "Config system could not be initialized: HR: 0x%08x", hr);
		}
	}
}


void Console::ParseArguments(DWORD argc, const char **rgpszArgs)
{
}

void Console::ParseCommand(const char *pszCommand)
{
}

void Console::ParseFile(const char *pszIniConfig)
{
	ErrorCode ecode = kErrorNone;
	HANDLE hFile = CreateFileA(	pszIniConfig, 
			GENERIC_READ, 
			FILE_SHARE_READ, 
			NULL, 
			OPEN_EXISTING, 
			FILE_FLAG_SEQUENTIAL_SCAN,
			NULL);

	if(hFile == INVALID_HANDLE_VALUE)
	{
		THROW_HRESULT1(HRESULT_FROM_WIN32(GetLastError()), "Could not open file: %s", pszIniConfig);
	}

	BYTE rgbGroup[256];
	BYTE rgbData[256];
	BYTE rgbBuffer[2048];
	BYTE *pWrite = rgbData;
	DWORD dwRead = 0;
	DWORD dwState = 0;
	LONG lLine = 0;
	LONG lCol = 0;
	Logging::Category *pLoggingCategory = 0;
	Logging::Target *pLoggingTarget = 0;
	Config::Setting *pConfigSetting = 0;

#define SET_PARSE_ERROR(setecode) \
				ecode = setecode; \
				ERR9(mgmt,  \
						"Parser: failed ecode: '%s' (0x%08x), config group: %s, data: '%s', parse state: 0x%08x, file: %s(line: %d, col: %d), current char: %c",  \
						#setecode, \
						setecode, \
						rgbGroup, \
						rgbData, \
						dwState, \
						pszIniConfig, \
						lLine, \
						lCol, \
						*pBuffer);

#define GROUP_NAME_LEN      127
#define SETTING_NAME_LEN    127
#define SETTING_VALUE_LEN   127
#define STATE_COMMENT       0x1
#define STATE_GROUP         0x2
#define STATE_GROUP_DECL    0x4
#define STATE_SETTING_KEY   0x8
#define STATE_SETTING_VALUE 0x10
	try
	{
		while(kErrorNone == ecode && ReadFile(hFile, rgbBuffer, sizeof(rgbBuffer), &dwRead, NULL))
		{
			if(dwRead == 0)
			{
				break;
			}
			
			BYTE *pBuffer = rgbBuffer;
			BYTE *pEndBuffer = pBuffer + dwRead;

			while(kErrorNone == ecode && pBuffer < pEndBuffer)
			{
				switch(*pBuffer)
				{
					case ';':
						switch(dwState)
						{
							// ignore in comments
							case STATE_COMMENT:
							case STATE_GROUP|STATE_COMMENT:
								break;

							// Write to values
							case STATE_GROUP|STATE_SETTING_VALUE:
								*pWrite++ = *pBuffer;
								*pWrite = '\0';
								break;
							case 0:
							case STATE_GROUP:
								dwState |= STATE_COMMENT;
								break;
							default:
								SET_PARSE_ERROR(kErrorInvalidParseState);
						}

						break;
					case '[':
						switch(dwState)
						{
							// ignore in comments
							case STATE_COMMENT:
							case STATE_GROUP|STATE_COMMENT:
								break;

							case 0:
							case STATE_GROUP:
								pWrite = rgbData;
								*pWrite = '\0';
								dwState = STATE_GROUP|STATE_GROUP_DECL;
								break;
							default:
								SET_PARSE_ERROR(kErrorInvalidParseState);
						}

						break;
					case ']':
						switch(dwState)
						{
							case STATE_COMMENT:
							case STATE_GROUP|STATE_COMMENT:
								break;

							case STATE_GROUP|STATE_GROUP_DECL:
								{
									// Copy in group name and update state
									CopyMemory(rgbGroup, rgbData, (pWrite - rgbData) + 1);
									dwState &= ~STATE_GROUP_DECL;

									// Update write pointer
									pWrite = rgbData;
									*pWrite = '\0';
								}
								break;
							default:
								SET_PARSE_ERROR(kErrorInvalidParseState);
								break;
						}

						break;
					case '=':
						switch(dwState)
						{
							// Ignore in comments
							case STATE_COMMENT:
							case STATE_GROUP|STATE_COMMENT:
								break;

							// Write to values
							case STATE_GROUP|STATE_SETTING_VALUE:
								*pWrite++ = *pBuffer;
								*pWrite = '\0';
								break;

								// Move to value state from key state
							case STATE_GROUP|STATE_SETTING_KEY:
								if(!strcmp((const char*)rgbGroup, "Mgmt.log.area"))
								{
									if(!GetLoggingCategory((const char*)rgbData, &pLoggingCategory))
									{
										ERR1(mgmt, "Could not find logging category: %s", (const char*)rgbData);
										SET_PARSE_ERROR(kErrorCannotFindNamedObject);
										break;
									}
								}
								else if(!strcmp((const char*)rgbGroup, "Mgmt.log.target"))
								{
									if(!GetLoggingTarget((const char*)rgbData, &pLoggingTarget))
									{
										AutoRef<Target> refTarget(new Target((const char*)rgbData));	
										AddLoggingTarget(refTarget);
										pLoggingTarget = refTarget;
									}
								}
								else
								{
									if(!GetUniqueSetting((const char *)rgbGroup, (const char*)rgbData, &pConfigSetting))
									{
										AutoRef<Setting> refSetting(new Setting((const char*)rgbGroup, (const char*)rgbData));
										pConfigSetting = refSetting;
									}
								}

								// Update the write pointer and state
								pWrite = rgbData;
								*pWrite = '\0';

								dwState &= ~STATE_SETTING_KEY;
								dwState |= STATE_SETTING_VALUE;

								break;
							default:
								SET_PARSE_ERROR(kErrorInvalidParseState);
								break;
						}

						break;

					case '\r': // ignore 
						break;
					case '\n':
						lCol = 0;
						lLine++;
						switch(dwState)
						{
							// End of comments
							case STATE_COMMENT:
							case STATE_GROUP|STATE_COMMENT:
								dwState &= ~STATE_COMMENT;
								break;

								// End of values
							case STATE_GROUP|STATE_SETTING_VALUE:
								// Got the setting update it's value
								if(pConfigSetting)
								{
									if(!pConfigSetting->UpdateValue((const char*)rgbData))
									{
										ERR2(mgmt, "Failed to update config setting: %s.%s with value '%s'", rgbGroup, rgbData);
									}
									pConfigSetting = NULL;
								}
								else if(pLoggingTarget)
								{
									pLoggingTarget->Configure((const char*)rgbData, pWrite - rgbData);
									pLoggingTarget = NULL;
								}
								else if(pLoggingCategory)
								{
									pLoggingCategory->Configure((const char*)rgbData, pWrite - rgbData);
									pLoggingCategory = NULL;
								}

								// Update write pointer
								pWrite = rgbData;
								*pWrite = '\0';

								// Update state
								dwState &= ~STATE_SETTING_VALUE;
								break;
							case STATE_GROUP:
							case 0:
								// Ignore
								break;
							default:
								SET_PARSE_ERROR(kErrorInvalidParseState);
								break;
						}

						break;
					case ' ':
						// Only write spaces into data buffer in particular states
						switch(dwState)
						{
							case STATE_GROUP|STATE_SETTING_VALUE:
								*pWrite++ = *pBuffer;
								*pWrite = '\0';
								break;
							case STATE_GROUP|STATE_GROUP_DECL:
								SET_PARSE_ERROR(kErrorInvalidParseState);
								break;
							default:
								// Ignore
								break;
						}
						break;

					default: 
						// All other character data
						switch(dwState)
						{
							case STATE_GROUP:
								dwState |= STATE_SETTING_KEY;
								pWrite = rgbData;
								*pWrite++ = *pBuffer;
								*pWrite = '\0';
								break;
							case STATE_GROUP|STATE_GROUP_DECL:
							case STATE_GROUP|STATE_SETTING_KEY:
							case STATE_GROUP|STATE_SETTING_VALUE:
								*pWrite++ = *pBuffer;
								*pWrite = '\0';
								break;
						}
						break;

				} // End switch on *pBuffer

				pBuffer++;
				lCol++;

				// Don't allow loop to try writing again
				if(pWrite == rgbData + sizeof(rgbData) - 1)
				{
					ERR0(mgmt, "Data buffer has filled up. Parser cannot continue.");
					SET_PARSE_ERROR(kErrorBufferOverrun);
				}

			} // End of parsing loop

			if(ecode != kErrorNone)
			{
				THROW_CODE7(ecode, "INI file parse failed for %s(%d,%d): config group: '%s', state 0x%08x, data: '%s', char: %c",
						pszIniConfig,
						lLine,
						lCol,
						rgbGroup, 
						dwState,
						rgbData, 
						*pBuffer);
			}
		} // End of ReadFile loop

		CloseHandle(hFile);
	} 
	catch(Exception &ex)
	{
		if(hFile != INVALID_HANDLE_VALUE)
		{
			CloseHandle(hFile);
			hFile = 0;
		}
		throw;
	}

}

// Commands to manage internal console state 
void Console::AddLoggingCategory(Logging::Category *pCategory)
{
	SAFE_ADDREF(pCategory);

	if(!m_aCategories.Add(pCategory, NULL))
	{
		THROW_CODE0(kErrorWriteFailed, "Could not add loggging category");
	}
	TRACE1(mgmt, L_DEBUG, "Logging category: %s added to console", pCategory->GetName());
}

void Console::AddLoggingTarget(Logging::Target *pTarget)
{
	SAFE_ADDREF(pTarget);
	if(!m_aTargets.Add(pTarget, NULL))
	{
		THROW_CODE0(kErrorWriteFailed, "Could not add logging target");
	}
	TRACE1(mgmt, L_DEBUG, "Logging target: %s added to console", pTarget->GetName());
}

bool Console::AddConfigSetting(const char *pszGroupName, Config::Setting *pSetting)
{
	bool bReturn = false;
	SettingGroup *pGroup = 0;

	if(!GetSettingGroup(pszGroupName, &pGroup))
	{
		pGroup = new SettingGroup(pszGroupName);
		if(!m_aGroups.Add(pGroup, NULL))
		{
			THROW_CODE1(kErrorWriteFailed, "Could not add config setting group: %s", pszGroupName);
		}
	}

	Config::Setting *pCurrentSetting;
	if(pGroup->GetSetting(pSetting->GetName(), &pCurrentSetting) && (pSetting->IsUnique() || pCurrentSetting->IsUnique()))
	{
		ERR3(mgmt, "Config setting: %s.%s unique(%s) was not added to console, could not enforce uniqueness", 
				pGroup->GetName(), pSetting->GetName(), pSetting->IsUnique() ? "yes" : "no");
		goto lbDone;
	}

	if(!pGroup->AddSetting(pSetting))
	{
		THROW_CODE1(kErrorWriteFailed, "Could not add config setting: %s", &Management::Config::Setting::GetName);
	}

	TRACE2(mgmt, L_DEBUG, "Config setting: %s.%s added to console", pGroup->GetName(), pSetting->GetName());
	bReturn = true;

lbDone:
	
	return bReturn;
}

void Console::RemoveAllLoggingCategories()
{
	Category *pCategory;
	for(DWORD i = 0, c = m_aCategories.GetSize(); i < c; ++i)
	{
		 if(m_aCategories.GetAt(i, &pCategory))
		 {
			 SAFE_RELEASE(pCategory);
		 }
	}
	m_aCategories.SetSize(0);
} 

void Console::RemoveAllLoggingTargets()
{
	Target *pTarget;
	for(DWORD i = 0, c = m_aTargets.GetSize(); i < c; ++i)
	{
		 if(m_aTargets.GetAt(i, &pTarget))
		 {
			 SAFE_RELEASE(pTarget);
		 }
	}
	m_aTargets.SetSize(0);
}

void Console::RemoveAllConfigSettings()
{
	SettingGroup *pGroup;
	for(DWORD i = 0, c = m_aGroups.GetSize(); i < c; ++i)
	{
		 if(m_aGroups.GetAt(i, &pGroup))
		 {
			 SAFE_RELEASE(pGroup);
		 }
	}
	m_aGroups.SetSize(0);
}


bool Console::GetLoggingCategory(const char *pszCategory, Logging::Category **ppCategory)
{
	bool found = false;

	DWORD i, c;
	for(i = 0, c = m_aCategories.GetSize(); i < c; ++i)
	{
		if(m_aCategories.GetAt(i, ppCategory))
		{
			if(!_stricmp((*ppCategory)->GetName(), pszCategory))
			{ 
				found = true;
				break;
			}
		}
	}

	if(i == c)
	{ 
		*ppCategory = NULL;
	}

	return found;
}

bool Console::GetLoggingTarget(const char *pszTargetName, Logging::Target **ppTarget)
{
	bool found = false;

	DWORD i, c;
	for(i = 0, c = m_aTargets.GetSize(); i < c; ++i)
	{
		if(m_aTargets.GetAt(i, ppTarget))
		{
			if(!_stricmp((*ppTarget)->GetName(), pszTargetName))
			{ 
				found = true;
				break;
			}
		}
	}

	if(i == c)
	{ 
		*ppTarget = NULL;
	}

	return found;
}

bool Console::GetServerSetting(CComBSTR eSetting, CComBSTR &outBSTR)
{
	__gConfigWrapper->GetSetting(eSetting, &outBSTR);
	return (outBSTR.Length() > 0);
}

bool Console::GetUniqueSetting(const char *pszFullName, Config::Setting **ppSetting)
{
	return GetSetting(pszFullName, ppSetting) && (*ppSetting)->IsUnique();
}

bool Console::GetSetting(const char *pszFullName, Config::Setting **ppSetting)
{
	char szGroup[128];
	const char *pMark = strchr(pszFullName, '.');
	
	if(!pMark)
	{
		THROW_CODE1(kErrorInvalidFormat, "Fullname must contain a group specifier: %s", pszFullName);
	}

	CopyMemory(szGroup, pszFullName, pMark - pszFullName);
	szGroup[pMark-pszFullName] = '\0';

	return GetSetting(szGroup, pMark+1, ppSetting);
}

bool Console::GetUniqueSetting(const char *pszGroup, const char *pszName, Config::Setting **ppSetting)
{
	return GetSetting(pszGroup, pszName, ppSetting) && (*ppSetting)->IsUnique();
}

bool Console::GetSetting(const char *pszGroup, const char *pszName, Config::Setting **ppSetting)
{
	SettingGroup *pGroup;

	if(0 == ppSetting)
	{
		return false;
	}

	if(GetSettingGroup(pszGroup, &pGroup))
	{
		return pGroup->GetSetting(pszName, ppSetting);
	}
	else
	{
		return false;
	}
}

bool Console::GetSettingGroup(const char *pszGroupName, SettingGroup **ppGroup)
{
	SettingGroup *pGroup;

	if(0 == ppGroup)
	{
		return false;
	}

	for(DWORD i = 0, c = m_aGroups.GetSize(); i < c; ++i)
	{
		if(m_aGroups.GetAt(i, &pGroup) && !_stricmp(pGroup->GetName(), pszGroupName))
		{
			*ppGroup = pGroup;
			goto lbDone;
		}
	}

	*ppGroup = 0;
lbDone:
	return (*ppGroup != 0);
}

bool Console::GetSettingGroup(DWORD iGroup, SettingGroup **ppGroup)
{
	return (TRUE == m_aGroups.GetAt(iGroup, ppGroup));
}

void Console::GetSettingIterator(
		SettingIterator **ppSettingIterator, 
		const char *pszMatchGroup, 
		const char *pszMatchSetting)
{
	*ppSettingIterator = new SettingIterator(&m_aGroups, pszMatchGroup, pszMatchSetting);
}

Console &Console::GetInstance()
{
	if(!__pConsoleInstance)
	{
		__pConsoleInstance = new Console;
	}

	return *__pConsoleInstance;
}

void Console::ReleaseInstance()
{
	if(__pConsoleInstance)
	{
		delete __pConsoleInstance;
		__pConsoleInstance = 0;
	}
}

//
// Config objects
// 
SettingGroup::SettingGroup(const char *pszName)
{
	strncpy(m_szName, pszName, kConfigSettingGroupNameLen);
}

SettingGroup::~SettingGroup()
{
	DWORD dwi, dwc;
	Setting *pSetting;

	for(dwi = 0, dwc = m_aSettings.GetSize(); dwi < dwc; ++dwi)
	{
		if(m_aSettings.GetAt(dwi, &pSetting))
		{
			SAFE_RELEASE(pSetting); 
		}
	}
}

const char *SettingGroup::GetName() const
{
	return m_szName;
}

bool SettingGroup::GetSetting(const char *pszName, Setting **ppSetting) const
{
	bool found = false;
	DWORD end = m_aSettings.GetSize();

	for(DWORD i = 0; i < end; ++i)
	{
		if(m_aSettings.GetAt(i, ppSetting))
		{
			if(!strcmp((*ppSetting)->GetName(), pszName))
			{ 
				found = true;
				break;
			}
		}
	}

	if(!found)
	{
		*ppSetting = NULL;
	}

	return found;
}

bool SettingGroup::GetSetting(DWORD iSetting, Setting **ppSetting) const
{
	return (TRUE == m_aSettings.GetAt(iSetting, ppSetting));
}

bool SettingGroup::AddSetting(Setting *pSetting)
{
	bool bReturn = (TRUE == m_aSettings.Add(pSetting, NULL));
	if(bReturn)
	{
		SAFE_ADDREF(pSetting);
		pSetting->SetGroup(this);
	}

	return bReturn;
}

Setting::Setting(const char *pszGroupName, const char *pszName, bool bIsUnique)
{
	m_bIsUnique = bIsUnique;
	m_pGroup = 0;
	strncpy(m_szName, pszName, kConfigSettingNameLen);
	m_szValue[0] = '\0';

	Console::GetInstance().AddConfigSetting(pszGroupName, this);
}

Setting::~Setting()
{
	SAFE_RELEASE(m_pGroup);
}

bool Setting::UpdateValue(const char *pszValue)
{
	strncpy(m_szValue, pszValue, kConfigSettingNameLen);

	// TODO: apply option constraints
	
	return true;
}

SettingGroup *Setting::GetGroup() const 
{
	return m_pGroup;
}

const char* Setting::GetGroupName() const 
{
	return m_pGroup->GetName();
}

const char *Setting::GetName() const
{
	return m_szName;
}

bool Setting::IsUnique() const
{
	return m_bIsUnique;
}

void Setting::SetGroup(SettingGroup *pGroup)
{
	// settings don't own references on groups
	m_pGroup = pGroup;
}

WORD Setting::GetWORD() const
{ 
	WORD wSetting = (WORD)strtoul(m_szValue, '\0', 10);
	return wSetting;
}

DWORD Setting::GetDWORD() const
{
	DWORD dwSetting = strtoul(m_szValue, '\0', 10);
	return dwSetting;
} 

float Setting::GetFloat() const
{
	float fSetting = (float)strtod(m_szValue, '\0');
	return fSetting;
}

const char *Setting::GetLPCSTR() const
{
	return m_szValue;
}

BOOL Setting::GetBOOL() const
{
	char c = m_szValue[0];
	return c == 't' || c == 'T' || c == 'y' || c == 'Y'; // true or yes
}

SettingIterator::SettingIterator(
		CTPtrArray<Config::SettingGroup> *pGroups, 
		const char *pszMatchGroup, 
		const char *pszMatchSetting) :
	m_pGroups(pGroups),
	m_iSearchGroups(0),
	m_iSearchSettings(0),
	m_pszMatchGroup(pszMatchGroup),
	m_pszMatchSetting(pszMatchSetting)
{
}

SettingIterator::~SettingIterator()
{
}

void SettingIterator::_MoveToNextMatch()
{
	Setting *pSetting;
	SettingGroup *pSettingGroup;

	// Iterate groups
	for(; m_iSearchGroups < m_pGroups->GetSize(); ++m_iSearchGroups)
	{ 
		if(m_pGroups->GetAt(m_iSearchGroups, &pSettingGroup))
		{
			// Iterate settings in that group
			if(0 == m_pszMatchGroup || !_stricmp(m_pszMatchGroup, pSettingGroup->GetName()))
			{
				CTPtrArray<Config::Setting> *pSettings = &pSettingGroup->m_aSettings;
				for(; m_iSearchSettings < pSettings->GetSize(); ++m_iSearchSettings)
				{ 
					if(pSettings->GetAt(m_iSearchSettings, &pSetting))
					{
						if(0 == m_pszMatchSetting || !_stricmp(m_pszMatchSetting, pSetting->GetName()))
						{
							goto lbDone;
						}
					}
				}
			}
		}
	}

lbDone:
	return;
}

Setting* SettingIterator::First()
{
	SettingGroup *pGroup;
	Setting *pSetting;

	m_iSearchGroups = 0;
	m_iSearchSettings = 0;

	_MoveToNextMatch();

	return Current();
}

Setting* SettingIterator::Next()
{
	++m_iSearchSettings;
	_MoveToNextMatch();

	return Current();
}

Setting *SettingIterator::Current()
{
	SettingGroup *pGroup;
	Setting *pSetting;

	if(	m_iSearchGroups < m_pGroups->GetSize() 
		&& m_pGroups->GetAt(m_iSearchGroups, &pGroup)
		&& pGroup->GetSetting(m_iSearchSettings, &pSetting))
	{
		return pSetting;
	}
	else
	{
		return 0;
	}
}


Target::Target(const char *pszName)
{
	strncpy(m_szName, pszName, kLoggingTargetNameLen);
	m_pStream = NULL;

	Console::GetInstance().AddLoggingTarget(this);
}

Target::~Target()
{
	SAFE_RELEASE(m_pStream);
}

const char* Target::GetName() const 
{
	return m_szName;
}


void Target::SetLogStream(LogStream *pStream)
{
	SAFE_RELEASE(m_pStream);

	pStream->AddRef();
	m_pStream = pStream;
}

void Target::Configure(const char *pszConfig, DWORD dwLen)
{
	Logging::Target *pLoggingTarget = NULL;
	const char *pCursor = pszConfig;
	char szKey[128]; 
	char szValue[128];

	while(ParseTokens((char**)&pCursor, &dwLen, szKey, sizeof(szKey), szValue, sizeof(szValue)))
	{
		if(!_stricmp(szKey, "type"))
		{
			SAFE_RELEASE(m_pStream);

			m_pStream = CreateLogStream(szValue);
		}
		else if(NULL != m_pStream)
		{
			m_pStream->SetOption(szKey, szValue);	
		}
	}
}

void Target::WriteLog(DWORD dwLogLevel, const BYTE *prgbData, DWORD cData)
{
	if(m_pStream)
	{
		m_pStream->WriteData(prgbData, cData);
	}
}


Category::Category(const char *pszName)
{
	strncpy(m_szName, pszName, kLoggingCategoryNameLen);
	Console::GetInstance().AddLoggingCategory(this);
	m_dwLevelEnable = L_NORMAL;
}

Category::~Category()
{
	RemoveAllLoggingTargets();	
}


const char *Category::GetName() const
{
	return m_szName;
}

DWORD Category::GetEnableLevel() const
{
	return m_dwLevelEnable;
}

void Category::Configure(const char *pszConfig, DWORD dwLen)
{
	Logging::Target *pLoggingTarget = NULL;
	const char *pCursor = pszConfig;
	char szKey[128]; 
	char szValue[128];

	while(ParseTokens((char**)&pCursor, &dwLen, szKey, sizeof(szKey), szValue, sizeof(szValue)))
	{
		if(!strcmp(szKey, "target"))
		{
			pLoggingTarget = NULL;
			if(!FAILED(Console::GetInstance().GetLoggingTarget(szValue, &pLoggingTarget)))
			{
				if(NULL != pLoggingTarget)	
				{ 
					AddLoggingTarget(pLoggingTarget);
				}
				else
				{
					ERR1(mgmt, "Category::Configure(): Could not find logging target: %s", (const char*)szValue);
				}
			}
		}
		else if(!strcmp(szKey, "enable"))
		{
			SetEnableLevel(ParseEnableLevel(szValue));
		}
	}
}

void Category::AddLoggingTarget(Target *pTarget)
{
	SAFE_ADDREF(pTarget);

	if(!m_aTargets.Add(pTarget, NULL))
	{
		THROW_CODE0(kErrorWriteFailed, "Could not logging target to category");
	}

	TRACE2(mgmt, L_DEBUG, "Logging target: %s added to logging category: %s", pTarget->GetName(), GetName());
}

void Category::RemoveAllLoggingTargets()
{
	Target *pTarget;
	DWORD i, c;

	for(i = 0, c = m_aTargets.GetSize(); i < c; ++i)
	{
		if(m_aTargets.GetAt(i, &pTarget))
		{
			SAFE_RELEASE(pTarget);
		}
	}

	m_aTargets.SetSize(0);
}


// Private log formatting function
void Category::_Format(DWORD dwLevel, const char *pszType, const char *pszFile, long lLine, const char *pszFormat, va_list ap)
{
	int n, n2;
#define LOGLINE_SIZE 1024
	BYTE rgbLogData[LOGLINE_SIZE];

	// Only print the name portion of the file
	const char *pszFileName = pszFile;
	const char *pszLast = pszFileName;
	while(*pszFileName) 
	{
		if(*pszFileName == '\\')
			pszLast = pszFileName+1;
		pszFileName++;
	}

	// Format the log entry save one extra char for newline and one for the nul character 
	n = _snprintf((char*)rgbLogData, LOGLINE_SIZE - 3, "[%s] %s(%d): ", pszType, *pszLast ? pszLast : pszFile, lLine);
	if(n < 0)
	{
		ERR0(mgmt, "Not enough buffer to format base log statement");
		rgbLogData[0] = '\0';
		n = 0;
	}

	// format message from user, save one extra char for newline and one for the nul character
	n2 = _vsnprintf((char*)(rgbLogData + n), LOGLINE_SIZE - n - 3, pszFormat, ap);
	if(n2 < 0)
	{
		ERR0(mgmt, "Not enough buffer to format user portion of log statement");
		rgbLogData[n] = '\0';
		n2 = 0;
	}

	rgbLogData[n + n2] = '\r';
	rgbLogData[n + n2 + 1] = '\n';
	rgbLogData[n + n2 + 2] = '\0';

	{
		DWORD c, i;
		Target *pTarget;

		i = 0; 
		c = m_aTargets.GetSize();

		while(i < c)
		{
			if(m_aTargets.GetAt(i, &pTarget))
			{
				pTarget->WriteLog(dwLevel, rgbLogData, (DWORD)(n + n2 + 2));
			}
			++i;
		}
	}
}

void Category::Trace(long lLevel, DWORD *pdwCanLog, const char *pszFile, long lLine, const char *pszFormat, ...)
{
	static const char *rgszLevelNames[] = {
		"DBG",
		"NML",
		"HGH",
		"ERR",
		"FTL",
		"OOB",
	};
	
	if(CheckLogging(lLevel, pdwCanLog, pszFile, lLine))
	{
		va_list ap;

		if(lLevel > 5)
		{
			lLevel = 5;
		}

		va_start(ap, pszFormat);
		_Format((DWORD)(1+lLevel), rgszLevelNames[lLevel], pszFile, lLine, pszFormat, ap);
		va_end(ap);
	}
}

bool Category::CheckLogging(long lLevel, DWORD *pdwCanLog, const char *pszFile, long lLine)
{
	DWORD dwNewCanLog = 0;
	bool bCanLog = false;
	
	// If the change signature store on the trace line matches this change signature we can just 
	// return the stored log enable
	if(HIWORD(*pdwCanLog) == HIWORD(g_dwLoggingConfigSignature))
	{
		bCanLog = !!LOWORD(*pdwCanLog);
	}
	else
	{
		// Else get the new log enable from this categories log enable level
		// special case false for no attached logging targets
		if(m_aTargets.GetSize() == 0)
		{
			bCanLog = false;
		}
		else
		{
			bCanLog = ((DWORD)lLevel >= m_dwLevelEnable);
		}
	}

	// Set new log enable on this trace line
	dwNewCanLog = g_dwLoggingConfigSignature | (bCanLog? 1 : 0);
	InterlockedExchange((LONG*)pdwCanLog, dwNewCanLog);
	
	return bCanLog;
}

void Category::SetEnableLevel(DWORD dwEnable)
{
	m_dwLevelEnable = dwEnable;
	DWORD dwVersion = HIWORD(g_dwLoggingConfigSignature);
	dwVersion++;
	g_dwLoggingConfigSignature = (dwVersion<<16) | LOWORD(g_dwLoggingConfigSignature);
}


// 
// Error handling
//

Exception::Exception(const char *pszFile, long lLine, ErrorCode eCode, const char *pszMessage)
{
	m_pszFile = pszFile;
	m_lLine = lLine;
	m_eCode = eCode;
	m_hrCode = 0;
	m_pCause = 0;
	m_pszMessage = pszMessage ? Duplicate(pszMessage) : NULL;
}

Exception::Exception(const char *pszFile, long lLine, ErrorCode eCode, HRESULT hrCode, const char *pszMessage) 
{
	m_pszFile = pszFile;
	m_lLine = lLine;
	m_eCode = eCode;
	m_hrCode = hrCode;
	m_pCause = 0;
	m_pszMessage = pszMessage ? Duplicate(pszMessage) : NULL;
}

Exception::Exception(const char *pszFile, long lLine, ErrorCode eCode, HRESULT hrCode, Exception *pCause, const char *pszMessage)
{
	m_pszFile = pszFile;
	m_lLine = lLine;
	m_eCode = eCode;
	m_hrCode = hrCode;
	m_pCause = pCause;
	m_pszMessage = pszMessage ? Duplicate(pszMessage) : NULL;
}

Exception::Exception(const Exception &in)
{
	*this = in;
}


Exception &Exception::operator=(const Exception &rhs) 
{
	m_pszFile = rhs.m_pszFile;
	m_lLine = rhs.m_lLine;
	m_eCode = rhs.m_eCode;
	m_hrCode = rhs.m_hrCode;
	m_pCause = rhs.m_pCause;
	m_pszMessage = rhs.m_pszMessage ? Duplicate(rhs.m_pszMessage) : NULL;

	return *this;
}

Exception::~Exception()
{
	if(NULL != m_pszMessage)
	{
		XFree(m_pszMessage);
	}
}


const char *Exception::GetText() const
{
	return m_pszMessage;	
}

ErrorCode Exception::GetCode() const
{
	return m_eCode;
}

HRESULT Exception::GetHRESULT() const
{
	return m_hrCode;
}

const char *Exception::GetFile() const
{
	return m_pszFile;
}

long Exception::GetLine() const
{
	return m_lLine;
}

Exception *Exception::GetInnerException() const
{
	return m_pCause;
}

//
// Static exception throw helpers
//
void Exception::ThrowException(const char *pszFile, long lLine, ErrorCode eCode, const char *pszMessage, ...)
{
	va_list ap;
	va_start(ap, pszMessage);
	ThrowException(pszFile, lLine, eCode, 0, 0, pszMessage, ap);
}

void Exception::ThrowException(const char *pszFile, long lLine, ErrorCode eCode, HRESULT hrCode, const char *pszMessage, ...)
{
	va_list ap;
	va_start(ap, pszMessage);
	ThrowException(pszFile, lLine, eCode, hrCode, 0, pszMessage, ap);
}

void Exception::ThrowException(const char *pszFile, long lLine, ErrorCode eCode, HRESULT hrCode, Exception *pCause, const char *pszMessage, ...)
{
	va_list ap;
	va_start(ap, pszMessage);
	ThrowException(pszFile, lLine, eCode, hrCode, pCause, pszMessage, ap);
}

void Exception::ThrowException(const char *pszFile, long lLine, ErrorCode eCode, HRESULT hrCode, Exception *pCause, const char *pszMessage, va_list ap)
{
	char szBuffer[1024] = {0,};
	_vsnprintf(szBuffer, sizeof(szBuffer), pszMessage, ap);
	va_end(ap);
	throw Exception(pszFile, lLine, eCode, hrCode, pCause, szBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\ManagementInternals.h ===
static DWORD ParseEnableLevel(const char *pszLevel)
{
	ASSERT_THROW(NULL != pszLevel);

	if(!_stricmp(pszLevel, "fatal"))
		return 4;
	else if(!_stricmp(pszLevel, "error"))
		return 3;
	else if(!_stricmp(pszLevel, "high"))
		return 2;
	else if(!_stricmp(pszLevel, "enable") || !_stricmp(pszLevel, "normal") )
		return 1;
	else 
		return 0;
}


//
// Internal logging stream classes
//

class _FileHandleLogStream  : public Logging::LogStream
{
protected: 
	HANDLE m_hFile;
	DWORD m_dwRotationTime;
	DWORD m_dwRotationSize;
	DWORD m_dwAccumSize;
	DWORD m_dwCreateTime;
	DWORD m_dwRollTime;
	char m_szPrefix[FILENAME_MAX];

	HRESULT m_hrLastErr;
	const char *m_pszLastErr;

	//
	// Buffer switch and flush file logging
	//
#define FHLS_BUFFER_SZ			8192	
	BYTE m_pbBuffer[2*FHLS_BUFFER_SZ];
	BYTE *m_pbWriteBuffer;
	BYTE *m_pbReadBuffer;
	DWORD m_cbWriteBuffer;
	DWORD m_cbReadBuffer;
	bool m_bFlushWrites;
	CRITICAL_SECTION m_WriterLock;
	CRITICAL_SECTION m_ReaderLock;

	HRESULT _FlushToDisk()
	{
		HRESULT hr = S_OK;

		// Check log rollover conditions
		if(m_dwAccumSize >= m_dwRotationSize || GetTickCount() >= m_dwRollTime)
		{
			hr = _RollLogFile();
		}

		// Write all buffer up
		DWORD dwTotalWritten = 0;
		DWORD dwWritten;
		BOOL fSucceeded;
		while(hr == S_OK && (dwTotalWritten < m_cbReadBuffer))
		{
			dwWritten = 0;
			fSucceeded = WriteFile(m_hFile, m_pbReadBuffer + dwTotalWritten, m_cbReadBuffer - dwTotalWritten, &dwWritten, NULL);
			if(fSucceeded)
			{
				if(0 == dwWritten)
				{
					break;
				}
				else
				{
					m_dwAccumSize += dwWritten;
					dwTotalWritten += dwWritten;
				}
			}
			else
			{
				hr = HRESULT_FROM_WIN32(GetLastError());
			}
		}

		m_cbReadBuffer -= dwTotalWritten;

		return hr;
	}

	HRESULT _OpenLogFile()
	{
		HRESULT hr = S_OK;
		char szFileName[FILENAME_MAX];

		m_dwCreateTime = GetTickCount();
		m_dwAccumSize = 0;	
		m_dwRollTime = m_dwCreateTime + m_dwRotationTime;

		// Create the logging filename
		SYSTEMTIME st;
		GetSystemTime(&st);
		_snprintf(szFileName, FILENAME_MAX, "%s_%02d_%02d_%02d_%02d.log", 
				m_szPrefix,
            	(st.wYear % 100), 
            	st.wMonth, 
				st.wDay, 
				st.wHour);

		m_hFile = CreateFileA(szFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_FLAG_WRITE_THROUGH, NULL);
		if(INVALID_HANDLE_VALUE == m_hFile)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}	

		return hr;
	}

	void _CloseLogFile()
	{
		if(INVALID_HANDLE_VALUE != m_hFile)
		{
			CloseHandle(m_hFile);
			m_hFile = INVALID_HANDLE_VALUE;
		}
	}

	HRESULT _RollLogFile()
	{
		HRESULT hr = S_OK;
		_CloseLogFile();
		hr = _OpenLogFile();

		return hr;
	}

public:
	_FileHandleLogStream() 
	{
		m_hFile = INVALID_HANDLE_VALUE;
		m_dwRotationTime = 1000 * 3600;
		m_dwRotationSize = 0xffffffff;
		m_dwRollTime = 0;
		m_dwAccumSize = 0;
		m_dwCreateTime = 0;
		m_dwRollTime = 0;
		m_szPrefix[0] = '\0';
	
		// Setup intial buffers
		m_pbWriteBuffer = m_pbBuffer;
		m_pbReadBuffer = m_pbBuffer + FHLS_BUFFER_SZ;
		m_cbWriteBuffer = 0;
		m_cbReadBuffer = 0;
		m_bFlushWrites = false;

		// Setup initial locks
        InitializeCriticalSectionAndSpinCount( &m_WriterLock, 4000 );
        InitializeCriticalSectionAndSpinCount( &m_ReaderLock, 4000 );
	}

	~_FileHandleLogStream()
	{
		DeleteCriticalSection(&m_WriterLock);
		DeleteCriticalSection(&m_ReaderLock);
	}

	void SetOption(const char *pszName, const char *pszValue)
	{
		if(!_stricmp("prefix", pszName))
		{
			strncpy(m_szPrefix, pszValue, FILENAME_MAX-1);
			_RollLogFile();
		}
		else if(!_stricmp("RotationTime", pszName))
		{
			// Rotation time is provided in minutes, convert to millis
			m_dwRotationTime = strtoul(pszValue, '\0', 10) * 60 * 1000;
			m_dwRollTime = m_dwCreateTime + m_dwRotationTime;
		}
		else if(!_stricmp("RotationSize", pszName))
		{
			m_dwRotationSize = strtoul(pszValue, '\0', 10);
		}
		else if(!_stricmp("FlushWrites", pszName))
		{
			m_bFlushWrites = pszValue[0] == 't' || pszValue[0] == 'T' || pszValue[0] == 'y' || pszValue[0] == 'Y';
		}
	}

	HRESULT WriteData(const BYTE *prgbData, DWORD cbData)
	{
		DWORD dwBufferLeft;
		BYTE *pbDst, *pbEnd;
		LONG lBufferedWrites = 0;
		HRESULT hr = S_OK;

		if(cbData > FHLS_BUFFER_SZ)
		{
			hr = E_FAIL;
			goto lbDone;
		}

lbRetry:
		// Lock writer buffer
		EnterCriticalSection(&m_WriterLock);

		// Not enough room, we will need to lock the reader to do a buffer
		// swap
		if(m_bFlushWrites || (cbData > FHLS_BUFFER_SZ - m_cbWriteBuffer))
		{
			// Get a lock on the buffer swap and flush to disk operation
			EnterCriticalSection(&m_ReaderLock);
			BYTE *pbTmpBuffer = m_pbWriteBuffer;
			DWORD cbTmpBuffer = m_cbWriteBuffer;

			// Swap buffers
			m_pbWriteBuffer = m_pbReadBuffer;
			m_pbReadBuffer = pbTmpBuffer;
			m_cbWriteBuffer = m_cbReadBuffer;
			m_cbReadBuffer = cbTmpBuffer;
			
			// Leave the writer section so this thread can flush to disk without
			// blocking other threads
			LeaveCriticalSection(&m_WriterLock);

			// Flush the read buffer
			hr = _FlushToDisk();	

			// Finished read buffer portion, buffer may have filled up again in
			// the time we took to flush to disk, we will let another thread flush
			// the current buffer to disk while we go back and try to write again
			LeaveCriticalSection(&m_ReaderLock);

			if(FAILED(hr))
				goto lbDone;
			else
				goto lbRetry;
		}

		// Set the initial write position
		pbDst 			= m_pbWriteBuffer + m_cbWriteBuffer;
		pbEnd 			= pbDst + cbData;
		m_cbWriteBuffer += cbData;

		// Write what we can
		while(pbDst < pbEnd)
		{
			*pbDst++ = *prgbData++;
		}

		// Finished normal write code path
		LeaveCriticalSection(&m_WriterLock);
lbDone:

		return hr;
	}
};


class _FileStreamLogStream : public Logging::LogStream
{
protected:
	FILE *m_pStream;
	CRITICAL_SECTION m_CritSec;
public:
	_FileStreamLogStream()
	{
		m_pStream = 0;
	}

	_FileStreamLogStream(FILE *pStream)
	{
		m_pStream = pStream;
        InitializeCriticalSectionAndSpinCount( &m_CritSec, 4000 );
	}


	~_FileStreamLogStream()
	{
		if(NULL != m_pStream && m_pStream != stdout && m_pStream != stderr)
		{
			fclose(m_pStream);
			m_pStream = NULL;
		}
		DeleteCriticalSection(&m_CritSec);
	}

	void SetOption(const char *pszName, const char *pszValue)
	{ 
	}

	HRESULT WriteData(const BYTE *prgbData, DWORD cbData)
	{
		ASSERT_THROW(NULL != m_pStream);
		EnterCriticalSection(&m_CritSec);
		fprintf(m_pStream, "%s", (const char*)prgbData);
		LeaveCriticalSection(&m_CritSec);
		return S_OK;
	}
};
class _RemoteLogStream  : public Logging::LogStream
{
protected:
	enum {
		kHostnameLen = 255
	};
	char m_strRemoteAddr[kHostnameLen+1];
	// Add some networking here
public:
	_RemoteLogStream() 
	{
	}
	~_RemoteLogStream()
	{
	}

	void SetOption(const char *pszName, const char *pszValue)
	{
	}

	HRESULT WriteData(const BYTE *prgbData, DWORD cbData)
	{
		//printf("REMOTE: %s\n", (const char *)prgbData);
		//
		return S_OK;
	}
};

class _DebugLogStream  : public Logging::LogStream
{
protected:
public:
	_DebugLogStream() 
	{
	}

	void SetOption(const char *pszName, const char *pszValue)
	{
	}

	HRESULT WriteData(const BYTE *prgbData, DWORD cbData)
	{
		OutputDebugStringA((LPCSTR)prgbData);
		return S_OK;
	}
};


// Add new log types here
static LogStream *CreateLogStream(const char *pszTypeName)
{
	ASSERT_THROW(NULL != pszTypeName);

	LogStream *pStream = 0;

	if(!_stricmp(pszTypeName, "remote"))
	{ 
		pStream = new _RemoteLogStream();
	}
	else if(!_stricmp(pszTypeName, "file"))
	{
		pStream = new _FileHandleLogStream();
	}
	else if(!_stricmp(pszTypeName, "debug"))
	{
		pStream = new _DebugLogStream();
	}
	else if(!_stricmp(pszTypeName, "stdout"))
	{
		pStream = new _FileStreamLogStream(stdout);
	}
	else if(!_stricmp(pszTypeName, "stderr"))
	{
		pStream = new _FileStreamLogStream(stderr);
	}

	return pStream;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\Management.h ===
//
// Copyright c 2004,2005 Microsoft.  ALL RIGHTS RESERVED
// Author: Jacob Repp (jacobr@microsoft.com)
//
// Based off of xmgmt server code, had to remove the dependency
// from dev code to enable running against different versions
// of xbox live.
//

#pragma once

// Make sure Debug is undefined
#ifdef Debug
#undef Debug
#endif

//
// This is a replacement for xmgmt since it is not appropriate for client 
// tools any more.  The root of this management system is the console. 
//
// To use this management system you need to use dstruct
//

namespace Management
{
	// Definition of internal error codes
	enum ErrorCode 
	{
		kErrorNone,

		kErrorUnknown,					// 001: Unknown error, often a fallthrough condition
		kErrorSystemCallFailed,			// 002: Look at exception HR for internal system failure code
		kErrorCannotFindNamedObject,	// 003: Could not find an object specified by name
		kErrorInvalidParseState,		// 004: Parsing encountered an invalid character 
		kErrorBufferOverrun,			// 005: A buffer has run out of room
		kErrorWriteFailed,				// 006: A write operation failed (container, buffer, etc)
		kErrorInvalidFormat,			// 007: Format of a value was incorrect
		kErrorAssertFailed,				// 008: An assertion in the code tested false

		kErrorMax
	};

	// Internal constants
	enum Constants 
	{
		kConfigSettingGroupNameLen      = 63,
		kConfigSettingNameLen           = 63,
		kConfigSettingValueLen          = 127,
		kLoggingTargetNameLen           = 63,
		kLoggingCategoryNameLen         = 63,
	};

	// foward namespace decl
	class Console;

	// Configuration objects used for dynamic setting of application parameters
	// also supports specifying logging and settings through an INI file.
	namespace Config
	{
		class Option
		{
		public:
			enum Type {
				kNone,
				kName,
				kMin,
				kMax
			};

			Type m_eType;

		protected:
			union {
				const char *m_pszValue;
				DWORD m_dwValue;
				BOOL m_fValue;
			};

		public:
		};

		class SettingGroup;
		class Setting
		{
		protected:
			bool           m_bIsUnique;
			SettingGroup*  m_pGroup;
			char           m_szName[kConfigSettingNameLen+1];
			char           m_szValue[kConfigSettingValueLen+1];
		public:
			Setting(const char *pszGroupName, const char *pszName, bool bIsUnique = false);
			~Setting();

			IMPLEMENT_REFCOUNT;

			bool           UpdateValue(const char *pszValue);
			const char*    GetGroupName() const;
			SettingGroup*  GetGroup() const;
			const char*    GetName() const;
			bool           IsUnique() const;

			void           SetGroup(SettingGroup *pGroup);
			
			WORD           GetWORD() const;
			DWORD          GetDWORD() const;
			float          GetFloat() const;
			const char*    GetLPCSTR() const;
			BOOL           GetBOOL() const;
		};

		class SettingIterator; // fwd decl
		class SettingGroup
		{
		protected:
			friend class Config::SettingIterator;

			CTPtrArray<Config::Setting>   m_aSettings;
			char m_szName[kConfigSettingGroupNameLen+1];
		public:
			SettingGroup(const char *pszName);
			~SettingGroup();

			IMPLEMENT_REFCOUNT;

			const char *GetName() const;
			bool GetSetting(const char *pszName, Setting **ppSetting) const;
			bool GetSetting(DWORD iSetting, Setting **ppSetting) const;
			bool AddSetting(Setting *pSetting);
		};

		class SettingIterator
		{
			protected:
				friend class Management::Console;
				CTPtrArray<SettingGroup>*         m_pGroups;
				DWORD                             m_iSearchGroups;
				DWORD                             m_iSearchSettings;
				const char*                       m_pszMatchGroup;
				const char*                       m_pszMatchSetting;

				void _MoveToNextMatch();

				SettingIterator(
						CTPtrArray<SettingGroup> *pGroups, 
						const char *pszMatchGroup, 
						const char *pszMatchSetting);
			public:
				~SettingIterator();

				IMPLEMENT_REFCOUNT;

				Config::Setting *First();
				Config::Setting *Next();
				Config::Setting *Current();
		};
	}; // end namespace Config
	
	//
	// Logging objects used for specifying logging categories and targets
	// for log files.
	//
	namespace Logging
	{
		class LogStream 
		{
		public:

			IMPLEMENT_REFCOUNT;

			virtual ~LogStream() {};
			virtual void SetOption(const char *pszName, const char *pszValue) {};
			virtual HRESULT WriteData(const BYTE *prgbData, DWORD cData) = 0;
		};

		class Target 
		{
		protected:
			LogStream *m_pStream;
			char m_szName[kLoggingTargetNameLen+1];

		public:
			Target(const char *pszName);
			~Target();

			IMPLEMENT_REFCOUNT;

			const char *GetName() const;
			void SetLogStream(LogStream *pStream);

			void Configure(const char *pszConfig, DWORD dwLen);
			void WriteLog(DWORD dwLogLevel, const BYTE *prgbData, DWORD cData);
		};

		class Category 
		{
		protected:
			char m_szName[kLoggingCategoryNameLen+1];
			CTPtrArray<Target> m_aTargets;
			DWORD m_dwLevelEnable;

			void _Format(DWORD dwLevel, const char *pszType, const char *pszFile, long lLine, const char *pszFormat, va_list ap);
		public:
			Category(const char *pszName);
			~Category();

			IMPLEMENT_REFCOUNT;

			const char *GetName() const;
			DWORD GetEnableLevel() const;

			bool CheckLogging(long lLevel, DWORD *pdwCanLog, const char *pszFile, long lLine);
			void SetEnableLevel(DWORD dwEnable);

			void Configure(const char *pszConfig, DWORD dwLen);
			void AddLoggingTarget(Target *pTarget);
			void RemoveAllLoggingTargets();

			bool GetLoggingTarget(const char *pszName, Target **ppTarget);

			void Trace(long lLevel, DWORD *pdwCanLog, const char *pszFile, long lLine, const char *pszFormat, ...);
		};
	}; // end namespace Logging


	//
	// Root object of the management interfaces. 
	//
	class Console 
	{
	protected:
		CTPtrArray<Logging::Category>     m_aCategories;
		CTPtrArray<Logging::Target>       m_aTargets;
		CTPtrArray<Config::SettingGroup>  m_aGroups;

	public:		
		Console();
		virtual ~Console();

		IMPLEMENT_REFCOUNT;

		void Initialize();

		void ParseCommand(const char *pszCommand);
		void ParseFile(const char *pszIniConfig);
		void ParseArguments(DWORD argc, const char **rgpszArgs);

		// Commands to manage internal console state 
		void AddLoggingCategory(Logging::Category *pTarget);
		void AddLoggingTarget(Logging::Target *pTarget);
		bool AddConfigSetting(const char *pszGroupName, Config::Setting *pSetting);

		bool GetLoggingCategory(const char *pszCategory, Logging::Category **ppCategory);
		bool GetLoggingTarget(const char *pszCategory, Logging::Target **ppTarget);

		void RemoveAllLoggingCategories();
		void RemoveAllLoggingTargets();
		void RemoveAllConfigSettings();

		bool GetServerSetting(CComBSTR eSetting, CComBSTR &outBSTR); 
		bool GetSetting(const char *pszFullName, Config::Setting **ppSetting);
		bool GetSetting(const char *pszGroupName, const char *pszName, Config::Setting **ppSetting);
		bool GetUniqueSetting(const char *pszFullName, Config::Setting **ppSetting);
		bool GetUniqueSetting(const char *pszGroupName, const char *pszName, Config::Setting **ppSetting);
		bool GetSettingGroup(const char *pszGroupName, Config::SettingGroup **ppGroup);
		bool GetSettingGroup(DWORD iGroup, Config::SettingGroup **ppGroup);

		//------------------------------------------------------------------------------
		// Get a new settings iterator. If pszMatchGroup and pszMatchSetting are
		// specified only settings matching those  strings will be iterated.
		//------------------------------------------------------------------------------	
		void GetSettingIterator(Config::SettingIterator **ppIterator, const char *pszMatchGroup, const char *pszMatchSetting);

		//------------------------------------------------------------------------------
		// Get a reference to the global management console. It will be initialized
		// if it doesn't yet exist.
		//------------------------------------------------------------------------------
		static Console &GetInstance();

		//------------------------------------------------------------------------------
		// Release any global config console object.
		//------------------------------------------------------------------------------
		static void ReleaseInstance();
	};

	
	// 
	// Exception wrapper
	//
	class Exception {
	protected:
		Exception *m_pCause;
		char *m_pszMessage;
		ErrorCode m_eCode;
		HRESULT m_hrCode;
		const char *m_pszFile;
		long m_lLine;
	public:
		Exception(const char *pszFile, long lLine, ErrorCode eCode, const char *pszMessage);
		Exception(const char *pszFile, long lLine, ErrorCode eCode, HRESULT hrCode, const char *pszMessage);
		Exception(const char *pszFile, long lLine, ErrorCode eCode, HRESULT hrCode, Exception *pCause, const char *pszMessage);
		Exception(const Exception &);
		Exception &operator=(const Exception &);
		virtual ~Exception();

		static void ThrowException(const char *pszFile, long lLine, ErrorCode eCode, const char *pszMessage, ...);
		static void ThrowException(const char *pszFile, long lLine, ErrorCode eCode, HRESULT hrCode, const char *pszMessage, ...);
		static void ThrowException(const char *pszFile, long lLine, ErrorCode eCode, HRESULT hrCode, Exception *pCause, const char *pszMessage, ...);

		// Note: this call does the va_end() for you since once the exception is thrown the va_list will be out of scope
		static void ThrowException(const char *pszFile, long lLine, ErrorCode eCode, HRESULT hrCode, Exception *pCause, const char *pszMessage, va_list ap);

		const char *GetText() const;
		ErrorCode GetCode() const;
		HRESULT GetHRESULT() const;
		const char *GetFile() const;
		long GetLine() const;
		Exception *GetInnerException() const;
	};

	extern DWORD g_dwLoggingConfigSignature;

}; // end namespace Management


#define L_DEBUG  0
#define L_NORMAL 1
#ifndef L_INFO
#define L_INFO   L_NORMAL
#endif
#define L_HIGH   2
#define L_ERROR  3
#define L_FATAL  4
#define L_OOB    5 // reserved channel for non-automated type logging


//
// Helper defines for defining settings and logging categories
// 
#define MGMT_DefineLoggingCategory(name)            Management::Logging::Category gLoggingCategory_##name(#name)
#define MGMT_ImportLoggingCategory(name)            extern Management::Logging::Category gLoggingCategory_##name
#define MGMT_GetLoggingCategory(name)               (gLoggingCategory_##name)

#define MGMT_DefineConfigSetting(group, name)       Management::Config::Setting gConfigSetting_##group_##name(#group, #name, true)
#define MGMT_ImportConfigSetting(group, name)       extern Management::Config::Setting gConfigSetting_##group_##name
#define MGMT_GetConfigSetting(group, name) 		    (gConfigSetting_##group_##name)


#define TRACE0(category, level, fmt) \
	do { \
		static DWORD dwCanLog = 0; \
		if(dwCanLog == g_dwLoggingConfigSignature) \
		{ \
			break; \
		} \
		gLoggingCategory_##category.Trace(level, &dwCanLog, __FILE__, __LINE__, fmt); \
	} while(0) 

#define TRACE1(category, level, fmt, a) \
	do { \
		static DWORD dwCanLog = 0; \
		if(dwCanLog == g_dwLoggingConfigSignature) \
		{ \
			break; \
		} \
		gLoggingCategory_##category.Trace(level, &dwCanLog, __FILE__, __LINE__, fmt, a); \
	} while(0)

#define TRACE2(category, level, fmt, a, b) \
	do { \
		static DWORD dwCanLog = 0; \
		if(dwCanLog == g_dwLoggingConfigSignature) \
		{ \
			break; \
		} \
		gLoggingCategory_##category.Trace(level, &dwCanLog, __FILE__, __LINE__, fmt, a, b); \
	} while(0) 

#define TRACE3(category, level, fmt, a, b, c) \
	do { \
		static DWORD dwCanLog = 0; \
		if(dwCanLog == g_dwLoggingConfigSignature) \
		{ \
			break; \
		} \
		gLoggingCategory_##category.Trace(level, &dwCanLog, __FILE__, __LINE__, fmt, a, b, c); \
	} while(0)

#define TRACE4(category, level, fmt, a, b, c, d) \
	do { \
		static DWORD dwCanLog = 0; \
		if(dwCanLog == g_dwLoggingConfigSignature) \
		{ \
			break; \
		} \
		gLoggingCategory_##category.Trace(level, &dwCanLog, __FILE__, __LINE__, fmt, a, b, c, d); \
	} while(0)
	
#define TRACE5(category, level, fmt, a, b, c, d, e) \
	do { \
		static DWORD dwCanLog = 0; \
		if(dwCanLog == g_dwLoggingConfigSignature) \
		{ \
			break; \
		} \
		gLoggingCategory_##category.Trace(level, &dwCanLog, __FILE__, __LINE__, fmt, a, b, c, d, e); \
	} while(0)

#define TRACE6(category, level, fmt, a, b, c, d, e, f) \
	do { \
		static DWORD dwCanLog = 0; \
		if(dwCanLog == g_dwLoggingConfigSignature) \
		{ \
			break; \
		} \
		gLoggingCategory_##category.Trace(level, &dwCanLog, __FILE__, __LINE__, fmt, a, b, c, d, e, f); \
	} while(0)

#define TRACE7(category, level, fmt, a, b, c, d, e, f, g) \
	do { \
		static DWORD dwCanLog = 0; \
		if(dwCanLog == g_dwLoggingConfigSignature) \
		{ \
			break; \
		} \
		gLoggingCategory_##category.Trace(level, &dwCanLog, __FILE__, __LINE__, fmt, a, b, c, d, e, f, g); \
	} while(0)

#define TRACE8(category, level, fmt, a, b, c, d, e, f, g, h) \
	do { \
		static DWORD dwCanLog = 0; \
		if(dwCanLog == g_dwLoggingConfigSignature) \
		{ \
			break; \
		} \
		gLoggingCategory_##category.Trace(level, &dwCanLog, __FILE__, __LINE__, fmt, a, b, c, d, e, f, g, h); \
	} while(0)

#define TRACE9(category, level, fmt, a, b, c, d, e, f, g, h, i) \
	do { \
		static DWORD dwCanLog = 0; \
		if(dwCanLog == g_dwLoggingConfigSignature) \
		{ \
			break; \
		} \
		gLoggingCategory_##category.Trace(level, &dwCanLog, __FILE__, __LINE__, fmt, a, b, c, d, e, f, g, h, i); \
	} while(0)

#define TRACE10(category, level, fmt, a, b, c, d, e, f, g, h, i, j) \
	do { \
		static DWORD dwCanLog = 0; \
		if(dwCanLog == g_dwLoggingConfigSignature) \
		{ \
			break; \
		} \
		gLoggingCategory_##category.Trace(level, &dwCanLog, __FILE__, __LINE__, fmt, a, b, c, d, e, f, g, h, i, j); \
	} while(0)


//
// Logging macros 
//
#define DBG0(category, fmt) TRACE0(categroy, L_DEBUG, fmt)
#define DBG1(category, fmt, a) TRACE1(category, L_DEBUG, fmt, a)
#define DBG2(category, fmt, a, b) TRACE2(category, L_DEBUG, fmt, a, b)
#define DBG3(category, fmt, a, b, c) TRACE3(category, L_DEBUG, fmt, a, b, c)
#define DBG4(category, fmt, a, b, c, d) TRACE4(category, L_DEBUG, fmt, a, b, c, d)
#define DBG5(category, fmt, a, b, c, d, e) TRACE5(category, L_DEBUG, fmt, a, b, c, d, e)
#define DBG6(category, fmt, a, b, c, d, e, f) TRACE6(category, L_DEBUG, fmt, a, b, c, d, e, f)
#define DBG7(category, fmt, a, b, c, d, e, f, g) TRACE7(category, L_DEBUG, fmt, a, b, c, d, e, f, g)
#define DBG8(category, fmt, a, b, c, d, e, f, g, h) TRACE8(category, L_DEBUG, fmt, a, b, c, d, e, f, g, h)
#define DBG9(category, fmt, a, b, c, d, e, f, g, h, i) TRACE9(category, L_DEBUG, fmt, a, b, c, d, e, f, g, h, i)
#define DBG10(category, fmt, a, b, c, d, e, f, g, h, i, j) TRACE10(category, L_DEBUG, fmt, a, b, c, d, e, f, g, h, i, j)

#define ERR0(category, fmt) TRACE0(category, L_ERROR, fmt)
#define ERR1(category, fmt, a) TRACE1(category, L_ERROR, fmt, a)
#define ERR2(category, fmt, a, b)  TRACE2(category, L_ERROR, fmt, a, b)
#define ERR3(category, fmt, a, b, c) TRACE3(category, L_ERROR, fmt, a, b, c)
#define ERR4(category, fmt, a, b, c, d) TRACE4(category, L_ERROR, fmt, a, b, c, d)
#define ERR5(category, fmt, a, b, c, d, e) TRACE5(category, L_ERROR, fmt, a, b, c, d, e)
#define ERR6(category, fmt, a, b, c, d, e, f) TRACE6(category, L_ERROR, fmt, a, b, c, d, e, f)
#define ERR7(category, fmt, a, b, c, d, e, f, g) TRACE7(category, L_ERROR, fmt, a, b, c, d, e, f, g)
#define ERR8(category, fmt, a, b, c, d, e, f, g, h) TRACE8(category, L_ERROR, fmt, a, b, c, d, e, f, g, h)
#define ERR9(category, fmt, a, b, c, d, e, f, g, h, i) TRACE9(category, L_ERROR, fmt, a, b, c, d, e, f, g, h, i)
#define ERR10(category, fmt, a, b, c, d, e, f, g, h, i, j) TRACE10(category, L_ERROR, fmt, a, b, c, d, e, f, g, h, i, j)

#define INF0(category, fmt) TRACE0(category, L_INFO, fmt)
#define INF1(category, fmt, a) TRACE1(category, L_INFO, fmt, a)
#define INF2(category, fmt, a, b) TRACE2(category, L_INFO,  fmt, a, b)
#define INF3(category, fmt, a, b, c) TRACE3(category, L_INFO, fmt, a, b, c)
#define INF4(category, fmt, a, b, c, d) TRACE4(category, L_INFO, fmt, a, b, c, d)
#define INF5(category, fmt, a, b, c, d, e) TRACE5(category, L_INFO, fmt, a, b, c, d, e)
#define INF6(category, fmt, a, b, c, d, e, f) TRACE6(category, L_INFO, fmt, a, b, c, d, e, f)
#define INF7(category, fmt, a, b, c, d, e, f, g) TRACE7(category, L_INFO, fmt, a, b, c, d, e, f, g)
#define INF8(category, fmt, a, b, c, d, e, f, g, h) TRACE8(category, L_INFO, fmt, a, b, c, d, e, f, g, h)
#define INF9(category, fmt, a, b, c, d, e, f, g, h, i) TRACE9(category, L_INFO, fmt, a, b, c, d, e, f, g, h, i)
#define INF10(category, fmt, a, b, c, d, e, f, g, h, i, j) TRACE10(category, L_INFO, fmt, a, b, c, d, e, f, g, h, i, j)

//
// Exception throw wrappers
//
#define THROW_CODE0(eCode, fmt) Exception::ThrowException(__FILE__, __LINE__, eCode, 0, fmt); 
#define THROW_CODE1(eCode, fmt, a) Exception::ThrowException(__FILE__, __LINE__, eCode, 0, fmt, a); 
#define THROW_CODE2(eCode, fmt, a, b) Exception::ThrowException(__FILE__, __LINE__, eCode, 0, fmt, a, b); 
#define THROW_CODE3(eCode, fmt, a, b, c) Exception::ThrowException(__FILE__, __LINE__, eCode, 0, fmt, a, b, c); 
#define THROW_CODE4(eCode, fmt, a, b, c, d) Exception::ThrowException(__FILE__, __LINE__, eCode, 0, fmt, a, b, c, d); 
#define THROW_CODE5(eCode, fmt, a, b, c, d, e) Exception::ThrowException(__FILE__, __LINE__, eCode, 0, fmt, a, b, c, d, e); 
#define THROW_CODE6(eCode, fmt, a, b, c, d, e, f) Exception::ThrowException(__FILE__, __LINE__, eCode, 0, fmt, a, b, c, d, e, f); 
#define THROW_CODE7(eCode, fmt, a, b, c, d, e, f, g) Exception::ThrowException(__FILE__, __LINE__, eCode, 0, fmt, a, b, c, d, e, f, g); 
#define THROW_CODE8(eCode, fmt, a, b, c, d, e, f, g, h) Exception::ThrowException(__FILE__, __LINE__, eCode, 0, fmt, a, b, c, d, e, f, g, h); 

#define THROW_HRESULT0(hr, fmt) Exception::ThrowException(__FILE__, __LINE__, Management::kErrorSystemCallFailed, hr, fmt); 
#define THROW_HRESULT1(hr, fmt, a) Exception::ThrowException(__FILE__, __LINE__, Management::kErrorSystemCallFailed, hr, fmt, a); 
#define THROW_HRESULT2(hr, fmt, a, b) Exception::ThrowException(__FILE__, __LINE__, Management::kErrorSystemCallFailed, hr, fmt, a, b); 
#define THROW_HRESULT3(hr, fmt, a, b, c) Exception::ThrowException(__FILE__, __LINE__, Management::kErrorSystemCallFailed, hr, fmt, a, b, c); 
#define THROW_HRESULT4(hr, fmt, a, b, c, d) Exception::ThrowException(__FILE__, __LINE__, Management::kErrorSystemCallFailed, hr, fmt, a, b, c, d); 
#define THROW_HRESULT5(hr, fmt, a, b, c, d, e) Exception::ThrowException(__FILE__, __LINE__, Management::kErrorSystemCallFailed, hr, fmt, a, b, c, d, e); 
#define THROW_HRESULT6(hr, fmt, a, b, c, d, e, f) Exception::ThrowException(__FILE__, __LINE__, Management::kErrorSystemCallFailed, hr, fmt, a, b, c, d, e, f); 
#define THROW_HRESULT7(hr, fmt, a, b, c, d, e, f, g) Exception::ThrowException(__FILE__, __LINE__, Management::kErrorSystemCallFailed, hr, fmt, a, b, c, d, e, f, g); 

#define ASSERT_THROW(cond) { if(!(cond)) { THROW_CODE0(kErrorAssertFailed, #cond); } }
#define ASSERT_BREAK(cond) { if(!(cond)) { DebugBreak(); } }
#define ASSERT_NOT_NULL(ptr) { if(0 == ptr) { THROW_CODE0(kErrorAssertFailed, "Invalid Pointer (NULL)"); } }

using namespace Management;
using namespace Management::Logging;
using namespace Management::Config;


// Internal config wrapper to manage global config library lifetime 
class ConfigWrapper
{
private:
	bool m_bInitialized;
	XblConfig::IConfig *m_pConfig;
public:
	ConfigWrapper();
	~ConfigWrapper();
	bool IsInitialized() const;
	XblConfig::IConfig *operator->() const;

	// This function was adapated from xmgmt.cpp
	HRESULT Initialize();
};

extern ConfigWrapper __gConfigWrapper;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\Memory.h ===
#pragma once


// Helper macros
//#define SAFE_DELETE(ptr) {delete ptr; (ptr) = NULL;}
//#define SAFE_DELETE_ARRAY(ptr) {delete[] ptr; (ptr) = NULL;}

#ifdef MEMORY_TRACING

#define NEW(type) new(##type, __FILE__, __LINE__) type
#define NEW_ARRAY(type, count) new(#type "[]", __FILE__, __LINE__) type[count]

MGMT_ImportLoggingCategory(Memory)

inline void *operator new(size_t size, const char *pszType, const char *pszFile, long line)
{
	TRACE5(Memory, L_DEBUG, "new '%s', size: %d (%08x), file: %s(%d)\n", 
		pszType, 
		size, 
		size, 
		pszFile, 
		line);
	return malloc(size);
}
inline void *operator new[](size_t size, const char *pszType, const char *pszFile, long line)
{
	TRACE5(Memory, L_DEBUG, "new '%s', size: %d (%08x), file: %s(%d)\n", 
		pszType, 
		size, 
		size, 
		pszFile, 
		line);
	return malloc(size);
}
inline void operator delete(void *ptr, const char *pszType, const char *pszFile, long line)
{
	TRACE4(Memory, L_DEBUG, "unwind delete '%s', file: %s(%d), ptr: 0x%08x\n", 
		pszType, 
		pszFile, 
		line,
		ptr);
	free(ptr);
}
inline void operator delete[](void *ptr, const char *pszType, const char *pszFile, long line)
{
	TRACE4(Memory, L_DEBUG, "unwind delete '%s', file: %s(%d), ptr: 0x%08x\n", 
		pszType, 
		pszFile, 
		line,
		ptr);
	free(ptr);
}
inline void operator delete(void *ptr)
{
	TRACE1(Memory, L_DEBUG, "delete ptr: 0x%08x\n", ptr);
	free(ptr);
}
inline void operator delete[](void *ptr)
{
	TRACE1(Memory, L_DEBUG, "delete ptr: 0x%08x\n", ptr);
	free(ptr);
}

#else // MEMORY_TRACING

inline void * __cdecl operator new(size_t size)
{
	return XAlloc(size);
}
inline void * __cdecl operator new[](size_t size)
{
	return XAlloc(size);
}
inline void  __cdecl operator delete(void *ptr)
{
	XFree(ptr);
}
inline void  __cdecl operator delete[](void *ptr)
{
	XFree(ptr);
}

#endif // !MEMORY_TRACING

//------------------------------------------------------------------------------
// 
// Local memory management routines
//


// 
// Duplicate a string taking into account it's length
//
char * __stdcall Duplicate(const char *psz);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\NetStruct.cpp ===
#include "PTNCore.h"

// Couldn't find actual tcpipxsum in client tree so here's a quick version
// from http://www.ietf.org/rfc/rfc1071.txt
//  I have no idea what the xsum parameter is used for in the original signature
//  everywhere this is referenced it is passed in as zero.
UINT __cdecl tcpipxsum(UINT xsum, const void *pb, UINT cb)
{
	WORD *sdata = (WORD*)pb;
	register long sum = 0;

	// Accumulate 16 bit values from data
	while(cb > 1)	
	{
		sum += *sdata++;
		cb -= 2;
	}

	// Add left-over byte if any
	if(cb > 0) 
	{
		sum += *((BYTE*)sdata);
	}

	// Fold 32-bit sum to 16 bits
	while(sum>>16)
		sum = (sum & 0xffff) + (sum >> 16);

	return ~(sum & 0xffff);
}

// ---------------------------------------------------------------------------------------
// CIpAddr
// ---------------------------------------------------------------------------------------

CIpAddr CIpAddr::DefaultMask() const
{
    if (IsClassA()) return(IPADDR_CLASSA_NETMASK);
    if (IsClassB()) return(IPADDR_CLASSB_NETMASK);
    if (IsClassC()) return(IPADDR_CLASSC_NETMASK);
    if (IsClassD()) return(IPADDR_CLASSD_NETMASK);

    return(0);
}

BOOL CIpAddr::IsValidUnicast() const
{
    return(_dw != 0 && !IsSecure() && !IsBroadcast() && !IsMulticast() && !IsLoopback());
}

BOOL CIpAddr::IsValidAddr() const
{
    return(     ((BYTE)(_ab[0] - 1)) <  254     // 1 ... 254
            &&  _ab[1]               <= 254     // 0 ... 254
            &&  _ab[2]               <= 254     // 0 ... 254
            &&  ((BYTE)(_ab[3] - 1)) <  254);   // 1 ... 254
}

char * CIpAddr::Str() const
{
    #define IPADDR_STR_BUFFS    32
    #define IPADDR_BUF_SIZE     16
    static char g_chBufIpAddr[IPADDR_STR_BUFFS * IPADDR_BUF_SIZE];
    static LONG g_lBufIndexIpAddr = 0;
    char * pch = &g_chBufIpAddr[(InterlockedIncrement(&g_lBufIndexIpAddr) % IPADDR_STR_BUFFS) * IPADDR_BUF_SIZE];
    XnInAddrToString(*(IN_ADDR *)&_dw, pch, IPADDR_BUF_SIZE);
    return(pch);
}

// ---------------------------------------------------------------------------------------
// HexStr
// ---------------------------------------------------------------------------------------

char * HexStr(const void * pv, size_t cb)
{
    #define HEXSTR_BUFFS        8
    #define HEXSTR_CBMAX        128
    #define HEXSTR_BUF_SIZE     (HEXSTR_CBMAX * 2 + 1)
    static char g_chHexBuf[HEXSTR_BUFFS * HEXSTR_BUF_SIZE];
    static LONG g_lHexBufIndex = 0;
    char * pch = &g_chHexBuf[(InterlockedIncrement(&g_lHexBufIndex) % HEXSTR_BUFFS) * HEXSTR_BUF_SIZE];
    char * pchDst = pch;
    BYTE * pb = (BYTE *)pv;
    UINT   ui;

    if (cb > HEXSTR_CBMAX)
        cb = HEXSTR_CBMAX;

    for (; cb > 0; --cb, ++pb)
    {
        ui = (*pb) >> 4;
        *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
        ui = (*pb) & 0x0F;
        *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
    }

    *pchDst = 0;

    return(pch);
}


// ---------------------------------------------------------------------------------------
// XnInAddrToString
// ---------------------------------------------------------------------------------------

void XnInAddrToString(const IN_ADDR ina, char * pchBuf, INT cchBuf)
{
    char    ach[16];
    BYTE *  pbSrc = (BYTE *)&ina;
    BYTE *  pbEnd = pbSrc + 4;
    char *  pbDst = (cchBuf < sizeof(ach)) ? ach : pchBuf;
    UINT    b;

    while (pbSrc < pbEnd)
    {
        b = *pbSrc++;

        if (b >= 10)
        {
            if (b >= 100) { *pbDst++ = '0' + (b / 100); b %= 100; }
            *pbDst++ = '0' + (b / 10); b %= 10;
        }

        *pbDst++ = '0' + b;
        *pbDst++ = '.';
    }

    pbDst[-1] = 0;

    if (cchBuf < sizeof(ach) && cchBuf > 0)
    {
        memcpy(pchBuf, ach, cchBuf);
        pchBuf[cchBuf - 1] = 0;
    }
}


// ---------------------------------------------------------------------------------------
// CEnetAddr
// ---------------------------------------------------------------------------------------


char * CEnetAddr::Str() const
{
    #define ENETADDR_STR_BUFFS    32
    #define ENETADDR_BUF_SIZE     18
    static char g_chBuf[ENETADDR_STR_BUFFS * ENETADDR_BUF_SIZE];
    static LONG g_lBufIndex = 0;
    char * pch = &g_chBuf[(InterlockedIncrement(&g_lBufIndex) % ENETADDR_STR_BUFFS) * ENETADDR_BUF_SIZE];
    _snprintf(pch, ENETADDR_BUF_SIZE, "%02X-%02X-%02X-%02X-%02X-%02X", _ab[0], _ab[1], _ab[2], _ab[3], _ab[4], _ab[5]);
    return(pch);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\NetStruct.h ===
#pragma once


// Stuff ripped from xpn.h and nettypes.h
// -- jacobr
//
#define Assert(cond)
#define INLINE inline

// Byte-order swapping macros
//  - equivalent to htons/htonl/ntohs/ntohl functions
//  - assumes we're on a little-endian machine

#define HTONL_(l) \
        ((((l) >> 24) & 0x000000FFL) | \
         (((l) >>  8) & 0x0000FF00L) | \
         (((l) <<  8) & 0x00FF0000L) | \
         (((l) << 24)              ))

#define HTONS_(s) ((WORD) \
        ((((s) >> 8) & 0x00FF) | \
         (((s) << 8) & 0xFF00)))

#define HTONL HTONL_
#define HTONS HTONS_
#define NTOHL HTONL_
#define NTOHS HTONS_

// Return the sequence numbers in a TCP segment (in host byte order)
#define SEG_SEQ(_tcphdr) NTOHL((_tcphdr)->_dwSeqNum)
#define SEG_ACK(_tcphdr) NTOHL((_tcphdr)->_dwAckNum)
#define SEG_WIN(_tcphdr) NTOHS((_tcphdr)->_wWindow)

// Return the length of a TCP segment (counting SYN and FIN)
#define SEG_LEN(_tcphdr, _datalen) \
        ((_datalen) + \
         (((_tcphdr)->_bFlags & TCP_SYN) ? 1 : 0) + \
         (((_tcphdr)->_bFlags & TCP_FIN) ? 1 : 0))

// convenience macro for checking segment flags
#define ISTCPSEG(_tcphdr, _flag) ((_tcphdr)->_bFlags & TCP_##_flag)

#define MAXTCPHDRLEN (4*15)

// TCP segment flag bits
#define TCP_FIN 0x01
#define TCP_SYN 0x02
#define TCP_RST 0x04
#define TCP_PSH 0x08
#define TCP_ACK 0x10
#define TCP_URG 0x20

// Control flags
#define TCP_CONTROLS (TCP_SYN|TCP_FIN|TCP_RST)

//
// TCP option tags
//
#define TCPOPT_EOL              0x00
#define TCPOPT_NOP              0x01
#define TCPOPT_MAX_SEGSIZE      0x02

#define MAKE_IDENTIFIER(a, b, c, d)     ((DWORD) MAKELONG(MAKEWORD(a, b), MAKEWORD(c, d)))

#define KEYEX_XBTOSG_SIZE_1       1400    // Payload size target for KeyExXbToSg
#define KEYEX_XBTOSG_SIZE_2       1332    // Payload size target for KeyExXbToSg

#define dimensionof(x)          (sizeof((x))/sizeof(*(x)))
#define BIT(n)                  (1u << (n))
#define ROUNDUP4(count)         (((count) + 3) & ~3)
#define ROUNDUP8(count)         (((count) + 7) & ~7)

// Ethernet Link Headers -----------------------------------------------------------------

#define ENET_LINK_MAXSIZE               ROUNDUP4(sizeof(CIeeeHdr))

#define ENET_DATA_MAXSIZE               1500
#define ENET_DATA_MINSIZE               42
#define ENET_DATA_MAX_PPP_PAYLOAD       (ENET_DATA_MAXSIZE - sizeof(CPppHdr))
#define ENET_DATA_MAXPAYLOAD            1364   // Some ISP's don't like transmitting 1500 bytes

#define ENET_TYPE_IP                    HTONS_(0x0800)
#define ENET_TYPE_ARP                   HTONS_(0x0806)
#define ENET_TYPE_PPPOE_DISCOVER        HTONS_(0x8863)
#define ENET_TYPE_PPPOE_SESSION         HTONS_(0x8864)
#define ENET_TYPE_PPPOE_DISCOVER_3COM   HTONS_(0x3C12)
#define ENET_TYPE_PPPOE_SESSION_3COM    HTONS_(0x3C13)

#define CBENET                          (8 + sizeof(CEnetHdr) + 4)  // Preamble, CEnetHdr, CRC

#define IPPROTOCOL_SECMSG       0
#define IPPROTOCOL_ICMP         1
#define IPPROTOCOL_TCP          6
#define IPPROTOCOL_UDP          17

//
//
// Begin IP/ENET struct decls
//

#pragma pack(push, 1)

struct CEnetAddr
{
    BYTE _ab[6];

    INLINE BOOL IsEqual(const CEnetAddr & ea) const { return(memcmp(_ab, ea._ab, sizeof(_ab)) == 0); }
    INLINE BOOL IsEqual(const BYTE * pb) const { return(memcmp(_ab, pb, sizeof(_ab)) == 0); }
    INLINE void SetBroadcast()                { *(DWORD *)&_ab[0] = 0xFFFFFFFF; *(WORD *)&_ab[4] = 0xFFFF; }
    INLINE void SetMulticast(const BYTE * pb) { _ab[0] = 0x01; _ab[1] = 0x00; _ab[2] = 0x5E; _ab[3] = pb[1] & 0x7F; _ab[4] = pb[2]; _ab[5] = pb[3]; }
    INLINE void SetZero()                     { *(DWORD *)&_ab[0] = 0x00000000; *(WORD *)&_ab[4] = 0x0000; }
    INLINE BOOL IsBroadcast() const           { return(*(DWORD *)&_ab[0] == 0xFFFFFFFF && *(WORD *)&_ab[4] == 0xFFFF); }
    INLINE BOOL IsMulticast() const           { return((_ab[0] & 1) != 0); }
    INLINE BOOL IsZero() const                { return(*(DWORD *)&_ab[0] == 0 && *(WORD *)&_ab[4] == 0); }
    char * Str() const;
};

struct CEnetHdr
{
    CEnetAddr       _eaDst;
    CEnetAddr       _eaSrc;
    WORD            _wType;
};

// IP Address in Network Byte Order ------------------------------------------------------

struct CIpAddr                      // IP Address in Network Byte Order
{
    union
    {
        BYTE        _ab[4];
        DWORD       _dw;
    };

    #define IPADDR_BROADCAST            HTONL_(0xFFFFFFFF)
    #define IPADDR_LOOPBACK             HTONL_(0x7F000001)
    #define IPADDR_ALLHOSTS             HTONL_(0xE0000001)
    #define IPADDR_ALLROUTERS           HTONL_(0xE0000002)
    #define IPADDR_CLASSA_NETMASK       HTONL_(0xFF000000)
    #define IPADDR_CLASSB_NETMASK       HTONL_(0xFFFF0000)
    #define IPADDR_CLASSC_NETMASK       HTONL_(0xFFFFFF00)
    #define IPADDR_CLASSD_NETMASK       HTONL_(0xF0000000)
    #define IPADDR_CLASSD_NETID         HTONL_(0xE0000000)
    #define IPADDR_LOOPBACK_NETID       HTONL_(0x7F000000)
    #define IPADDR_SECURE_NETID         HTONL_(0x00000000)
    #define IPADDR_SECURE_NETMASK       HTONL_(0xFF000000)
    #define IPADDR_SECURE_DEFAULT       HTONL_(0x00000001)

    INLINE operator DWORD () const { return(_dw); }
    INLINE DWORD operator = (DWORD & dw) { return(_dw = dw); }
    INLINE CIpAddr(DWORD dw) { _dw = dw; }
    INLINE CIpAddr(WORD wUniq, BYTE bSlot) { Assert(wUniq > 0); _dw = HTONL((wUniq << 8) | bSlot); Assert(IsSecure()); }
    INLINE CIpAddr() {}

    INLINE BOOL IsBroadcast() const { return(_dw == IPADDR_BROADCAST); }
    INLINE BOOL IsMulticast() const { return(IsClassD() && !IsBroadcast()); }
    INLINE BOOL IsLoopback() const { return((_dw & IPADDR_CLASSA_NETMASK) == IPADDR_LOOPBACK_NETID); }
    INLINE BOOL IsSecure() const { return(_dw && (_dw & IPADDR_SECURE_NETMASK) == IPADDR_SECURE_NETID); }
    INLINE UINT SecureSlot() const { Assert(IsSecure()); return(_dw >> 24); }
    INLINE BOOL IsClassA() const { return((_dw & HTONL_(0x80000000)) == HTONL_(0x00000000)); }
    INLINE BOOL IsClassB() const { return((_dw & HTONL_(0xC0000000)) == HTONL_(0x80000000)); }
    INLINE BOOL IsClassC() const { return((_dw & HTONL_(0xE0000000)) == HTONL_(0xC0000000)); }
    INLINE BOOL IsClassD() const { return((_dw & HTONL_(0xF0000000)) == HTONL_(0xE0000000)); }
    INLINE BOOL IsValidMask() const { DWORD dw = ~NTOHL(_dw); return((dw & (dw + 1)) == 0); }
    BOOL IsValidUnicast() const;
    BOOL IsValidAddr() const;
    CIpAddr DefaultMask() const;
    char * Str() const;
};

struct CIpPort
{
    WORD            _w;

    INLINE operator WORD () { return (_w); }
    INLINE WORD operator = (WORD & w) { return(_w = w); }
    INLINE CIpPort(WORD w) { _w = w; }
    INLINE CIpPort() {}
};

struct CIpHdr
{
    BYTE            _bVerHdr;       // Version & header length
    BYTE            _bTos;          // Type of service
    WORD            _wLen;          // Total length including IP header
    WORD            _wId;           // Identification
    WORD            _wFragOff;      // Flags and fragment offset
    BYTE            _bTtl;          // Time to live
    BYTE            _bProtocol;     // Protocol
    WORD            _wChecksum;     // Header checksum
    CIpAddr         _ipaSrc;        // Source address
    CIpAddr         _ipaDst;        // Destination address

    INLINE UINT     GetHdrLen()         { return((_bVerHdr & 0xF) << 2); }
    INLINE void     SetHdrLen(UINT cb)  { _bVerHdr = (BYTE)(0x40 | (cb >> 2)); }
    INLINE UINT     GetOptLen()         { return(GetHdrLen() - sizeof(CIpHdr)); }
    INLINE UINT     GetLen()            { return(NTOHS(_wLen)); }
    INLINE UINT     VerifyHdrLen()      { return((_bVerHdr & 0xF0) == 0x40 ? GetHdrLen() : 0); }

};

class CIcmpHdr
{

    // Definitions -----------------------------------------------------------------------

    #define ICMPTYPE_ECHO_REPLY                 0
    #define ICMPTYPE_DESTINATION_UNREACHABLE    3
    #define   ICMPCODE_NET_UNREACHABLE          0
    #define   ICMPCODE_HOST_UNREACHABLE         1
    #define   ICMPCODE_PROTOCOL_UNREACHABLE     2
    #define   ICMPCODE_PORT_UNREACHABLE         3
    #define   ICMPCODE_CANT_FRAGMENT_WITH_DF    4
    #define   ICMPCODE_SRCROUTE_FAILED          5
    #define   ICMPCODE_DEST_NET_UNKNOWN         6
    #define   ICMPCODE_DEST_HOST_UNKNOWN        7
    #define   ICMPCODE_SRC_HOST_ISOLATED        8
    #define   ICMPCODE_DEST_NET_PROHIBITED      9
    #define   ICMPCODE_DEST_HOST_PROHIBITED     10
    #define   ICMPCODE_NET_UNREACHABLE_TOS      11
    #define   ICMPCODE_HOST_UNREACHABLE_TOS     12
    #define   ICMPCODE_COMMUNICATION_PROHIBITED 13
    #define ICMPTYPE_SOURCE_QUENCH              4
    #define ICMPTYPE_REDIRECT                   5
    #define   ICMPCODE_REDIRECT_NET             0
    #define   ICMPCODE_REDIRECT_HOST            1
    #define   ICMPCODE_REDIRECT_NET_TOS         2
    #define   ICMPCODE_REDIRECT_HOST_TOS        3
    #define ICMPTYPE_ECHO_REQUEST               8
    #define ICMPTYPE_ROUTER_ADVERTISEMENT       9
    #define ICMPTYPE_ROUTER_SOLICIATION         10
    #define ICMPTYPE_TIME_EXCEEDED              11
    #define   ICMPCODE_TTL_EXCEEDED             0
    #define   ICMPCODE_REASSEMBLY_TIMEOUT       1
    #define ICMPTYPE_PARAMETER_PROBLEM          12
    #define   ICMPCODE_PTR_INDICATES_ERROR      0
    #define   ICMPCODE_MISSING_REQD_OPTION      1
    #define ICMPTYPE_TIMESTAMP_REQUEST          13
    #define ICMPTYPE_TIMESTAMP_REPLY            14
    #define ICMPTYPE_INFORMATION_REQUEST        15
    #define ICMPTYPE_INFORMATION_REPLY          16
    #define ICMPTYPE_ADDRESSMASK_REQUEST        17
    #define ICMPTYPE_ADDRESSMASK_REPLY          18

    // Trace Support ---------------------------------------------------------------------

public:

    char * Str();

    // Data ------------------------------------------------------------------------------

public:

    BYTE            _bType;         // One of ICMPTYPE_* above
    BYTE            _bCode;         // One of ICMPCODE_* above
    WORD            _wChecksum;     // Checksum
    DWORD           _dwData;        // Data (depends on _bType)

};

struct CPseudoHeader
{
    CIpAddr         _ipaSrc;
    CIpAddr         _ipaDst;
    BYTE            _bZero;
    BYTE            _bProtocol;
    WORD            _wLen;
};

struct CArpMsg
{
    WORD            _wHrd;      // hardware address space
    WORD            _wPro;      // protocol address space (ENET_TYPE_IP)
    BYTE            _bHln;      // hardware address length (6)
    BYTE            _bPln;      // protocol address length (4)
    WORD            _wOp;       // opcode
    CEnetAddr       _eaSender;  // sender's hardware address
    CIpAddr         _ipaSender; // sender's protocol address
    CEnetAddr       _eaTarget;  // target's hardware address
    CIpAddr         _ipaTarget; // target's protocol address
};

// UDP Header in Network Byte Order ------------------------------------------------------
//
struct CUdpHdr
{
    CIpPort         _ipportSrc;     // Source port
    CIpPort         _ipportDst;     // Destination port
    WORD            _wLen;          // Datagram length including UDP header
    WORD            _wChecksum;     // Datagram checksum

    INLINE UINT GetLen()            { return(NTOHS(_wLen)); }
};

struct CTcpInfo
{
    // Definitions -----------------------------------------------------------------------

    #define TCPSEQ  DWORD

    INLINE void SetHdrLen(UINT cb)  { _bHdrLen = (BYTE)(ROUNDUP4(cb) << 2); }
    INLINE UINT GetHdrLen()         { return((_bHdrLen & 0xF0) >> 2); }

    // Data ------------------------------------------------------------------------------

    TCPSEQ          _dwSeqNum;      // Sequence number
    TCPSEQ          _dwAckNum;      // Ack number
    BYTE            _bHdrLen;       // Header length (number of DWORDs)
    BYTE            _bFlags;        // Flags
    WORD            _wWindow;       // Window
};

struct CTcpHdr
{
    CIpPort         _ipportSrc;     // src port
    CIpPort         _ipportDst;     // dst port
    CTcpInfo        _info;          // TCP header information
    WORD            _wChecksum;     // Checksum
    WORD            _wUrgent;       // Urgent pointer
};

#pragma pack(pop)

// ---------------------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------------------

UINT __cdecl tcpipxsum(UINT xsum, const void * buf, UINT buflen);
void XnInAddrToString(const IN_ADDR ina, char * pchBuf, INT cchBuf);
char * HexStr(const void * pv, size_t cb);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\NetworkEndpoint.cpp ===
#include "PTNCore.h"

NetworkEndpoint::NetworkEndpoint()
{
	m_dwAddr = 0;
	m_wPort = 0;
}

NetworkEndpoint::~NetworkEndpoint()
{
}

DWORD NetworkEndpoint::GetAddr() const
{
	return m_dwAddr;
}

WORD NetworkEndpoint::GetPort() const
{
	return m_wPort;
}

//------------------------------------------------------------------------------
//
// Static helper methods

// statics for iterating host entity information
static hostent *__pHostEnt;
static DWORD    __iHostEnt;

bool NetworkEndpoint::GetFirstLocalAddr(DWORD &dwOutAddr)
{
	bool bReturn = false;
	dwOutAddr = 0;

	__pHostEnt = gethostbyname(NULL);
	__iHostEnt = 0;

	if(__pHostEnt && __pHostEnt->h_addrtype == AF_INET && __pHostEnt->h_length == 4 && __pHostEnt->h_addr_list[0])		
	{
		dwOutAddr = *(DWORD*)__pHostEnt->h_addr_list[__iHostEnt];
		bReturn = true;
		++__iHostEnt;
	}
	else
	{
		__pHostEnt = NULL;
	}

	return bReturn;
}

bool NetworkEndpoint::GetNextLocalAddr(DWORD &dwOutAddr) 
{
	bool bReturn = false;

	if(__pHostEnt && __pHostEnt->h_addr_list[__iHostEnt])
	{
		dwOutAddr = *(DWORD*)__pHostEnt->h_addr_list[__iHostEnt];
		bReturn = true;
		++__iHostEnt;
	}

	return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\NetworkEndpoint.h ===
#pragma once

class NetworkEndpoint
{
protected:
	DWORD  m_dwAddr;
	WORD   m_wPort;
public:
	NetworkEndpoint();
	~NetworkEndpoint();

	DWORD GetAddr() const;
	WORD GetPort() const;

	static bool GetFirstLocalAddr(DWORD &dwOutAddr);
	static bool GetNextLocalAddr(DWORD &dwOutAddr);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\Protocol.cpp ===
#include "PTNCore.h"
#include "xonlinep.h"
#include "Protocol.h"

void fprint_BYTE(FILE *pOutFile, BYTE *pd)
{
	fprintf(pOutFile, "%02X ", *pd);
}

void fprint_DWORD(FILE *pOutFile, DWORD *pd)
{
	fprintf(pOutFile, "%X ", *pd);
}

void fprint_ULONGLONG(FILE *pOutFile, ULONGLONG *pd)
{
	fprintf(pOutFile, "%I64d", *pd);
}
void fprint_PQ_WEB_FRIEND(FILE *pOutFile, PQ_WEB_FRIEND *pd)
{
	fprintf(pOutFile, "qwUserID: %I64d, dwState: %08X, dwTitleID: %08X, cbTitleStuff: %d",
			pd->qwUserID,
			pd->dwState,
			pd->dwTitleID,
			pd->cbTitleStuff);
}

void fprint_Q_RECIPIENT_RESULT(FILE *pOutFile, Q_RECIPIENT_RESULT *pd)
{
	fprintf(pOutFile, "qwUserID: %I64d, ID|HR: %X", pd->qwUserID, pd->dwMessageID);
}

void fprint_Q_MESSAGE_SUMMARY(FILE *pOutFile, Q_MESSAGE_SUMMARY *pd)
{
	fprintf(pOutFile, "qwSenderID: %I64d, qwSenderContext: %I64d, mtSentTime: %d, dwMessageID: %d, dwMessageFlags: %X\n"
					  " -- dwSenderTitleID: %X, wExpireMinutes: %d, cbDetails: %d, bMessageType: %2x, szSenderName: %s",
						pd->qwSenderID,
    					pd->qwSenderContext,
    					pd->mtSentTime,
    					pd->dwMessageID,
    					pd->dwMessageFlags,
    					pd->dwSenderTitleID,
    					pd->wExpireMinutes,
    					pd->cbDetails,
    					pd->bMessageType,
    					pd->szSenderName);
}

BOOL DumpMessage(BYTE *pbData, DWORD cbData, DUMP_MESSAGE_FORMAT eFormat)
{
#define MSG_CASE(type, clsname) \
    case type: { \
        clsname *pMsg = (clsname*)pbData; \
        if(eFormat == DMF_MULTI_LINE) { \
            pMsg->WriteText(stdout); \
        } else if (eFormat == DMF_SINGLE_LINE) { \
            pMsg->WriteTextLine(stdout); \
            fprintf(stdout, "\n"); \
        } \
    } \
    break;

    BOOL fParsed = TRUE;
	CBaseMsgHeader *pBaseHdr = (CBaseMsgHeader*)pbData;
	switch(pBaseHdr->dwMsgType)
	{
		//-------------------------------------------------------------------------------
		// Presence message requests
		MSG_CASE(PMSG_HELLO, CPHelloMsg);
		MSG_CASE(PMSG_ALIVE, CPAliveMsg);
		MSG_CASE(PMSG_SYNC, CPSyncMsg);
		MSG_CASE(PMSG_REFRESH, CPRefreshMsg);
		MSG_CASE(PMSG_ADD, CPAddMsg);
		MSG_CASE(PMSG_DELETE, CPDeleteMsg);
		MSG_CASE(PMSG_ACCEPT, CPAcceptMsg);
		MSG_CASE(PMSG_REJECT, CPRejectMsg);
		MSG_CASE(PMSG_BLOCK, CPBlockMsg);
		MSG_CASE(PMSG_UNBLOCK, CPUnblockMsg);
		MSG_CASE(PMSG_INVITE, CPInviteMsg);
		MSG_CASE(PMSG_CANCEL, CPCancelMsg);
		MSG_CASE(PMSG_INVITE_ANSWER, CPInviteAnswerMsg);
		MSG_CASE(PMSG_NICKNAME, CPNicknameMsg);
		MSG_CASE(PMSG_STATE, CPStateMsg);
		MSG_CASE(PMSG_ANNOUNCE, CPAnnounceMsg);
		MSG_CASE(PMSG_SUBSCRIBED, CPSubscribedMsg);
		MSG_CASE(PMSG_UNSUBSCRIBE, CPUnsubscribeMsg);
		MSG_CASE(PMSG_ADDED, CPAddedMsg);
		MSG_CASE(PMSG_ACCEPTED, CPAcceptedMsg);
		MSG_CASE(PMSG_REMOVED, CPRemovedMsg);
		MSG_CASE(PMSG_KICK, CPKickMsg);
		MSG_CASE(PMSG_ALIVE_2, CPAlive2Msg);
		MSG_CASE(PMSG_WEB_FRIENDS, CPWebFriendsMsg);
		MSG_CASE(PMSG_WEB_ALIVE, CPWebAliveMsg);
		MSG_CASE(PMSG_WEB_ANNOUNCE, CPWebAnnounceMsg);
		MSG_CASE(PMSG_WEB_SUBSCRIBED, CPWebSubscribedMsg);
		MSG_CASE(PMSG_WEB_UNSUBSCRIBE, CPWebUnsubscribeMsg);

		//-------------------------------------------------------------------------------
		// Presence message replies
		//
		MSG_CASE(PMSG_WEB_FRIENDS_REPLY, CPWebFriendsReplyMsg);
		MSG_CASE(PMSG_WEB_ALIVE_REPLY, CPWebAliveReplyMsg);

		//-------------------------------------------------------------------------------
		// Notification message requests
		MSG_CASE(QMSG_HELLO, CQHelloMsg);
		MSG_CASE(QMSG_USER_INFO, CQUserInfoMsg);
		MSG_CASE(QMSG_ADD, CQAddMsg);
		MSG_CASE(QMSG_DELETE, CQDeleteMsg);
		MSG_CASE(QMSG_DELETE_MATCHES, CQDeleteMatchesMsg);
		MSG_CASE(QMSG_LIST, CQListMsg);
		MSG_CASE(QMSG_DEQUEUE, CQDequeueMsg);
		MSG_CASE(QMSG_DEAD_USER, CQDeadUserMsg);
		MSG_CASE(QMSG_WEB_USER_INFO, CQWebUserInfoMsg);
		MSG_CASE(QMSG_WEB_PRESENCE, CQWebPresenceMsg);
		MSG_CASE(QMSG_WEB_LIST, CQWebListMsg);
		MSG_CASE(QMSG_ENUM_MESSAGES, CQEnumMessagesMsg);
		MSG_CASE(QMSG_MESSAGE_SUMMARY, CQMessageSummaryMsg);
		MSG_CASE(QMSG_MESSAGE_DETAILS, CQMessageDetailsMsg);
		MSG_CASE(QMSG_DELETE_MESSAGE, CQDeleteMessageMsg);
		MSG_CASE(QMSG_REVOKE_MESSAGE, CQRevokeMessageMsg);
		MSG_CASE(QMSG_SEND_MESSAGE, CQSendMessageMsg);
		MSG_CASE(QMSG_REVOKE_MESSAGE_EX, CQRevokeMessageExMsg);

		//-------------------------------------------------------------------------------
		// Notification message replies
		//
		MSG_CASE(QMSG_LIST_REPLY, CQListReplyMsg);
		MSG_CASE(QMSG_WEB_LIST_REPLY, CQWebListReplyMsg);
		MSG_CASE(QMSG_ENUM_MESSAGES_REPLY, CQEnumMessagesReplyMsg);

		default:
            fParsed = FALSE;
			break;
	}
#undef MSG_CASE

    return fParsed;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\SafeCounter.h ===
#pragma once

struct SafeCounter
{
	volatile LONG lValue;

	SafeCounter() :
		lValue(0)
	{}

	SafeCounter(const SafeCounter &in)
	{
		*this = in;
	}

	inline void Increment()
	{
		InterlockedIncrement(&lValue);
	}

	inline void Decrement()
	{
		InterlockedDecrement(&lValue);
	}

	inline SafeCounter& operator=(LONG lNewValue)
	{
		InterlockedCompareExchange(&lValue, lValue, lNewValue);
		return *this;
	}

	inline SafeCounter& operator=(const SafeCounter &rhs)
	{
		*this = rhs.lValue;
		return *this;
	}

	// Prefix increment and decrement
	inline SafeCounter& operator++()
	{
		Increment();
		return *this;
	}
	inline SafeCounter& operator--()
	{
		Decrement();
		return *this;
	}

	// Postfix increment and decrement
	inline SafeCounter operator++(int)
	{
		Increment();
		return *this;
	}
	inline SafeCounter operator--(int)
	{
		Decrement();
		return *this;
	}

	// Automatic conversion
	inline operator LONG  () const
	{
		return lValue;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\ScopeTimer.h ===
#pragma once

struct __declspec(align(32)) ScopeTimer
{
	LARGE_INTEGER li;
	float fCaptured;
	const char *pszTimerName;

	ScopeTimer(const char *pszName)
	{
		pszTimerName = pszName ? pszName : "<UNKNOWN>";
	}
	~ScopeTimer()
	{
	}

	inline HRESULT Enter()
	{
		fCaptured = 0.0;
		if(!QueryPerformanceCounter(&li))
		{
			return HRESULT_FROM_WIN32(GetLastError());
		}

		return S_OK;
	}

	inline HRESULT Leave()
	{
		return Capture(&fCaptured);	
	}

	inline HRESULT Capture(float *pfCaptured)
	{
		LARGE_INTEGER eli;

		if(!QueryPerformanceCounter(&eli))
		{
			return HRESULT_FROM_WIN32(GetLastError());
		}

		LARGE_INTEGER freqli;
		QueryPerformanceFrequency(&freqli);
		*pfCaptured = (float)((eli.QuadPart - li.QuadPart) / (double)freqli.QuadPart);
	
		return S_OK;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\Protocol.h ===
#pragma once

//-------------------------------------------------------------------------------
// Macro object type callouts
#define StructName_TYPE(type_id)
#define StructName_STRUCT(type_name)						type_name
#define StructName_FLD_ULONGLONG(fld_name)
#define StructName_FLD_DWORD(fld_name)
#define StructName_FLD_WORD(fld_name)
#define StructName_FLD_BYTE(fld_name)
#define StructName_ARRAY(type, fld_name, c_fld_name)
#define StructName_XARRAY(type, fld_name)
#define StructName_SARRAY(type, fld_name, array_sz)

#define DefineFields_TYPE(type_id)
#define DefineFields_STRUCT(type_name)
#define DefineFields_FLD_ULONGLONG(fld_name) 				ULONGLONG fld_name;
#define DefineFields_FLD_DWORD(fld_name)					DWORD fld_name;
#define DefineFields_FLD_WORD(fld_name) 					WORD fld_name;
#define DefineFields_FLD_BYTE(fld_name) 					BYTE fld_name;
#define DefineFields_ARRAY(type, fld_name, c_fld_name) 		\
	type *fld_name(DWORD iItem) { \
		return (type*)(((BYTE*)this) + sizeof(*this)); \
	}
#define DefineFields_XARRAY(type, fld_name) \
	type *fld_name(DWORD iItem) { \
		return (type*)(((BYTE*)this) + sizeof(*this)); \
	}
#define DefineFields_SARRAY(type, fld_name, array_sz)  		type fld_name[array_sz];


#define CalculateSize_TYPE(type_id)
#define CalculateSize_STRUCT(type_name)
#define CalculateSize_FLD_ULONGLONG(fld_name) 				dwSize += 8;
#define CalculateSize_FLD_DWORD(fld_name) 					dwSize += 4;
#define CalculateSize_FLD_WORD(fld_name) 					dwSize += 2;
#define CalculateSize_FLD_BYTE(fld_name)					dwSize += 1;
#define CalculateSize_ARRAY(type, fld_name, c_fld_name) 	dwSize += c_fld_name * sizeof(type);
#define CalculateSize_XARRAY(type, fld_name) 	
#define CalculateSize_SARRAY(type, fld_name, array_sz) 		dwSize += array_sz * sizeof(type);

#define WriteText_TYPE(type_id)							fprintf(pOutFile, "------------------------------------\nTYPE: %08x\n", type_id);
#define WriteText_STRUCT(type_name)						fprintf(pOutFile, "NAME: %s\n", #type_name);
#define WriteText_FLD_ULONGLONG(fld_name) 				fprintf(pOutFile, "%s: %I64d\n", #fld_name, fld_name);
#define WriteText_FLD_DWORD(fld_name) 					fprintf(pOutFile, "%s: %u\n", #fld_name, fld_name);	
#define WriteText_FLD_WORD(fld_name) 					fprintf(pOutFile, "%s: %d\n", #fld_name, fld_name);	
#define WriteText_FLD_BYTE(fld_name)					fprintf(pOutFile, "%s: %d\n", #fld_name, fld_name);	
#define WriteText_ARRAY(type, fld_name, c_fld_name)		fprintf(pOutFile, "[%s (%s) COUNT: %d]\n", #fld_name, #type, c_fld_name); \
	type *p##fld_name = (type*)(((BYTE*)this) + sizeof(*this)); \
	for(DWORD i = 0; i < c_fld_name; ++i) { \
		fprintf(pOutFile, "%d: ", i); \
		fprint_##type(pOutFile, p##fld_name);  \
		fprintf(pOutFile, "\n"); \
		p##fld_name++; \
	}
#define WriteText_XARRAY(type, fld_name)		\
	DWORD cItems = (dwMsgLen - (sizeof(*this) - sizeof(CBaseMsgHeader))) / sizeof(type); \
	fprintf(pOutFile, "%s (%s) COUNT: %d ----\n", #fld_name, #type, cItems); \
	type *p##fld_name = (type*)(((BYTE*)this) + sizeof(*this)); \
	for(DWORD i = 0; i < cItems; ++i) { \
		fprintf(pOutFile, "%d: ", i); \
		fprint_##type(pOutFile, p##fld_name);  \
		fprintf(pOutFile, "\n"); \
		p##fld_name++; \
	}
#define WriteText_SARRAY(type, fld_name, array_sz)	\
	fprintf(pOutFile, "%s (%s) COUNT: %d ----\n", #fld_name, #type, array_sz); \
	type *p##fld_name = (type*)&fld_name[0]; \
	for(DWORD i = 0; i < array_sz; ++i) { \
		fprintf(pOutFile, "%d: ", i); \
		fprint_##type(pOutFile, p##fld_name);  \
		fprintf(pOutFile, "\n"); \
		p##fld_name++; \
	}

#define WriteTextLine_TYPE(type_id)							fprintf(pOutFile, "TYPE(%08x) ", type_id);
#define WriteTextLine_STRUCT(type_name)						fprintf(pOutFile, "NAME(%s) ", #type_name);
#define WriteTextLine_FLD_ULONGLONG(fld_name) 				fprintf(pOutFile, "%s(%I64d) ", #fld_name, fld_name);
#define WriteTextLine_FLD_DWORD(fld_name) 					fprintf(pOutFile, "%s(%u) ", #fld_name, fld_name);	
#define WriteTextLine_FLD_WORD(fld_name) 					fprintf(pOutFile, "%s(%d) ", #fld_name, fld_name);	
#define WriteTextLine_FLD_BYTE(fld_name)					fprintf(pOutFile, "%s(%d) ", #fld_name, fld_name);	
#define WriteTextLine_ARRAY(type, fld_name, c_fld_name)		fprintf(pOutFile, "%s:%s:%d(", #fld_name, #type, c_fld_name); \
	type *p##fld_name = (type*)(((BYTE*)this) + sizeof(*this)); \
	for(DWORD i = 0; i < c_fld_name; ++i) { \
		fprintf(pOutFile, "%d:", i); \
		fprint_##type(pOutFile, p##fld_name);  \
		fprintf(pOutFile, " "); \
		p##fld_name++; \
	} \
    fprintf(pOutFile, ") ");
#define WriteTextLine_XARRAY(type, fld_name)		\
	DWORD cItems = (dwMsgLen - (sizeof(*this) - sizeof(CBaseMsgHeader))) / sizeof(type); \
	fprintf(pOutFile, "%s:%s:%d (", #fld_name, #type, cItems); \
	type *p##fld_name = (type*)(((BYTE*)this) + sizeof(*this)); \
	for(DWORD i = 0; i < cItems; ++i) { \
		fprintf(pOutFile, "%d:", i); \
		fprint_##type(pOutFile, p##fld_name);  \
		fprintf(pOutFile, " "); \
		p##fld_name++; \
	} \
    fprintf(pOutFile, ") ");
#define WriteTextLine_SARRAY(type, fld_name, array_sz)	\
	fprintf(pOutFile, "%s:%s:%d (", #fld_name, #type, array_sz); \
	type *p##fld_name = (type*)&fld_name[0]; \
	for(DWORD i = 0; i < array_sz; ++i) { \
		fprintf(pOutFile, "%d: ", i); \
		fprint_##type(pOutFile, p##fld_name);  \
		fprintf(pOutFile, " "); \
		p##fld_name++; \
	} \
    fprintf(pOutFile, ") ");

#define GetType_TYPE(type_id) type_id
#define GetType_STRUCT(type_name)
#define GetType_FLD_ULONGLONG(fld_name)
#define GetType_FLD_DWORD(fld_name)
#define GetType_FLD_WORD(fld_name)
#define GetType_FLD_BYTE(fld_name)
#define GetType_ARRAY(type, fld_name, c_fld_name) 
#define GetType_XARRAY(type, fld_name) 
#define GetType_SARRAY(type, fld_name, array_sz) 

//------------------------------------------------------------------------------
// Packet defining entry for macro objects
#define MakePacketDef(name, PACKET_DEF) \
	struct name : public CBaseMsgHeader { \
		PACKET_DEF(DefineFields) \
			\
		DWORD GetSize() const { \
			DWORD dwSize = 0; \
			PACKET_DEF(CalculateSize); \
			return dwSize; \
		} \
		DWORD GetType() const { \
			return PACKET_DEF(GetType); \
		} \
		const char *GetName() const { \
			return #name ; \
		} \
		void WriteText(FILE *pOutFile) const { \
			PACKET_DEF(WriteText); \
		} \
        void WriteTextLine(FILE *pOutFile) const { \
			PACKET_DEF(WriteTextLine); \
		} \
	}; 

#pragma pack(push, 1)
//------------------------------------------------------------------------------
// Base message header definition
struct CBaseMsgHeader {
	DWORD dwMsgType;
    DWORD dwMsgLen;
    DWORD dwSeqNum;
	SGADDR sgaddr;
	
	DWORD GetSize() const {
		return sizeof(CBaseMsgHeader);
	}
	DWORD GetType() const {
		return -1;
	}

	const char *GetName() const {
		return "CBaseMsgHeader";
	}

	DWORD ReadData(BYTE *pbSrc, DWORD cbData) 
	{
		BYTE *pbOrigSrc = pbSrc;
		dwMsgType = *(DWORD*) pbSrc; pbSrc += 4;
		dwMsgLen = *(DWORD*) pbSrc; pbSrc += 4;
		dwSeqNum = *(DWORD*) pbSrc; pbSrc += 4;
		return pbSrc - pbOrigSrc;
	}
	DWORD WriteData(BYTE *pbData, DWORD cbData)  const
	{
		return 0;
	}

	void WriteText(FILE *pOutput)
	{
	}
};

//------------------------------------------------------------------------------
// Array member printing functions
//
void fprint_BYTE(FILE *pOutFile, BYTE *pd);
void fprint_DWORD(FILE *pOutFile, DWORD *pd);
void fprint_ULONGLONG(FILE *pOutFile, ULONGLONG *pd);
void fprint_PQ_WEB_FRIEND(FILE *pOutFile, PQ_WEB_FRIEND *pd);
void fprint_Q_RECIPIENT_RESULT(FILE *pOutFile, Q_RECIPIENT_RESULT *pd);
void fprint_Q_MESSAGE_SUMMARY(FILE *pOutFile, Q_MESSAGE_SUMMARY *pd);

//
// Begin macro packet object definitions
//

//-------------------------------------------------------------------------------
// Presence message types
#define _P_HELLO_MSG(OP) \
	OP##_TYPE(PMSG_HELLO) \
	OP##_STRUCT(P_HELLO_MSG) \
	OP##_FLD_DWORD(dwProtocolVersion) 
MakePacketDef(CPHelloMsg, _P_HELLO_MSG);

#define _P_ALIVE_MSG(OP) \
	OP##_TYPE(PMSG_ALIVE) \
	OP##_STRUCT(P_ALIVE_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_DWORD(dwTitleID) \
	OP##_FLD_WORD(cbAcctName) \
	OP##_FLD_DWORD(dwBuddyListVersion) \
	OP##_FLD_DWORD(dwBlockListVersion) \
	OP##_FLD_DWORD(dwState) \
	OP##_FLD_ULONGLONG(qwMatchSessionID) \
	OP##_FLD_WORD(cbNickName) \
	OP##_FLD_WORD(cbTitleStuff) 
MakePacketDef(CPAliveMsg, _P_ALIVE_MSG);

#define _P_SYNC_MSG(OP) \
	OP##_TYPE(PMSG_SYNC) \
	OP##_STRUCT(P_SYNC_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_DWORD(dwBuddyListVersion) \
	OP##_FLD_DWORD(dwBlockListVersion) 
MakePacketDef(CPSyncMsg, _P_SYNC_MSG);

#define _P_REFRESH_MSG(OP) \
	OP##_TYPE(PMSG_REFRESH) \
	OP##_STRUCT(P_REFRESH_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) 
MakePacketDef(CPRefreshMsg, _P_REFRESH_MSG);

#define _P_ADD_MSG(OP) \
	OP##_TYPE(PMSG_ADD) \
	OP##_STRUCT(P_ADD_MSG) \
	OP##_FLD_ULONGLONG(qwSenderID) \
	OP##_FLD_ULONGLONG(qwBuddyID) \
	OP##_FLD_WORD(cbBuddyAcctName) \
	OP##_ARRAY(BYTE, szBuddyAcctName, cbBuddyAcctName) 
MakePacketDef(CPAddMsg, _P_ADD_MSG);

#define _P_DELETE_MSG(OP) \
	OP##_TYPE(PMSG_DELETE) \
	OP##_STRUCT(P_DELETE_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_ULONGLONG(qwBuddyID) 
MakePacketDef(CPDeleteMsg, _P_DELETE_MSG);

#define _P_ACCEPT_MSG(OP) \
	OP##_TYPE(PMSG_ACCEPT) \
	OP##_STRUCT(P_ACCEPT_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_ULONGLONG(qwBuddyID) 
MakePacketDef(CPAcceptMsg, _P_ACCEPT_MSG);

#define _P_REJECT_MSG(OP) \
	OP##_TYPE(PMSG_REJECT) \
	OP##_STRUCT(P_REJECT_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_ULONGLONG(qwBuddyID) \
	OP##_FLD_BYTE(fNever) 
MakePacketDef(CPRejectMsg, _P_REJECT_MSG);

#define _P_BLOCK_MSG(OP) \
	OP##_TYPE(PMSG_BLOCK) \
	OP##_STRUCT(P_BLOCK_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_ULONGLONG(qwBuddyID) 
MakePacketDef(CPBlockMsg, _P_BLOCK_MSG);

#define _P_UNBLOCK_MSG(OP) \
	OP##_TYPE(PMSG_UNBLOCK) \
	OP##_STRUCT(P_UNBLOCK_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_ULONGLONG(qwBlockID) 
MakePacketDef(CPUnblockMsg, _P_UNBLOCK_MSG);

#define _P_INVITE_MSG(OP) \
	OP##_TYPE(PMSG_INVITE) \
	OP##_STRUCT(P_INVITE_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_DWORD(dwTitleID) \
	OP##_FLD_ULONGLONG(qwMatchSessionID) \
	OP##_FLD_WORD(cInvitees) \
	OP##_ARRAY(ULONGLONG, rgqwInvitees, cInvitees) 
MakePacketDef(CPInviteMsg, _P_INVITE_MSG);

#define _P_CANCEL_MSG(OP) \
	OP##_TYPE(PMSG_CANCEL) \
	OP##_STRUCT(P_CANCEL_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_ULONGLONG(qwMatchSessionID) \
	OP##_FLD_WORD(cInvitees) \
	OP##_ARRAY(ULONGLONG, rgqwInvitees, cInvitees) 
MakePacketDef(CPCancelMsg, _P_CANCEL_MSG);

#define _P_INVITE_ANSWER_MSG(OP) \
	OP##_TYPE(PMSG_INVITE_ANSWER) \
	OP##_STRUCT(P_INVITE_ANSWER_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_ULONGLONG(qwHostID) \
	OP##_FLD_ULONGLONG(qwMatchSessionID) \
	OP##_FLD_WORD(wAnswer) 
MakePacketDef(CPInviteAnswerMsg, _P_INVITE_ANSWER_MSG);

#define _P_NICKNAME_MSG(OP) \
	OP##_TYPE(PMSG_NICKNAME) \
	OP##_STRUCT(P_NICKNAME_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_WORD(cbNickname) \
	OP##_ARRAY(BYTE, rgbNickname, cbNickname) 
MakePacketDef(CPNicknameMsg, _P_NICKNAME_MSG);

#define _P_STATE_MSG(OP) \
	OP##_TYPE(PMSG_STATE) \
	OP##_STRUCT(P_STATE_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_DWORD(dwState) \
	OP##_FLD_ULONGLONG(qwMatchSessionID) \
	OP##_FLD_WORD(cbTitleStuff) \
	OP##_ARRAY(BYTE, rgbTitleStuff, cbTitleStuff) 
MakePacketDef(CPStateMsg, _P_STATE_MSG);

#define _P_ANNOUNCE_MSG(OP) \
	OP##_TYPE(PMSG_ANNOUNCE) \
	OP##_STRUCT(P_ANNOUNCE_MSG) \
	OP##_FLD_ULONGLONG(qwDestUserID) \
	OP##_FLD_WORD(cSourceUserIDs) \
	OP##_ARRAY(ULONGLONG, qwSourceUserIDs, cSourceUserIDs) 
MakePacketDef(CPAnnounceMsg, _P_ANNOUNCE_MSG);

#define _P_SUBSCRIBED_MSG(OP) \
	OP##_TYPE(PMSG_SUBSCRIBED) \
	OP##_STRUCT(P_SUBSCRIBED_MSG) \
	OP##_FLD_ULONGLONG(qwDestUserID) \
	OP##_FLD_WORD(cSourceUserIDs) \
	OP##_ARRAY(ULONGLONG, qwSourceUserIDs, cSourceUserIDs) 
MakePacketDef(CPSubscribedMsg, _P_SUBSCRIBED_MSG);

#define _P_UNSUBSCRIBE_MSG(OP) \
	OP##_TYPE(PMSG_UNSUBSCRIBE) \
	OP##_STRUCT(P_UNSUBSCRIBE_MSG) \
	OP##_FLD_ULONGLONG(qwSourceUserID) \
	OP##_FLD_WORD(cDestUserIDs) \
	OP##_ARRAY(ULONGLONG, qwDestUserIDs, cDestUserIDs) 
MakePacketDef(CPUnsubscribeMsg, _P_UNSUBSCRIBE_MSG);

#define _P_ADDED_MSG(OP) \
	OP##_TYPE(PMSG_ADDED) \
	OP##_STRUCT(P_ADDED_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_ULONGLONG(qwBuddyID) \
	OP##_FLD_ULONGLONG(qwBuddyWebID) \
	OP##_FLD_DWORD(dwVersion) \
	OP##_FLD_WORD(cbBuddyAcctName) \
	OP##_ARRAY(BYTE, szBuddyAcctName, cbBuddyAcctName) 
MakePacketDef(CPAddedMsg, _P_ADDED_MSG);

#define _P_ACCEPTED_MSG(OP) \
	OP##_TYPE(PMSG_ACCEPTED) \
	OP##_STRUCT(P_ACCEPTED_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_ULONGLONG(qwBuddyID) \
	OP##_FLD_DWORD(dwVersion) \
	OP##_FLD_WORD(cbBuddyAcctName) \
	OP##_ARRAY(BYTE, szBuddyAcctName, cbBuddyAcctName) 
MakePacketDef(CPAcceptedMsg, _P_ACCEPTED_MSG);

#define _P_REMOVED_MSG(OP) \
	OP##_TYPE(PMSG_REMOVED) \
	OP##_STRUCT(P_REMOVED_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_ULONGLONG(qwBuddyID) \
	OP##_FLD_DWORD(dwVersion) 
MakePacketDef(CPRemovedMsg, _P_REMOVED_MSG);

#define _P_KICK_MSG(OP) \
	OP##_TYPE(PMSG_KICK) \
	OP##_STRUCT(P_KICK_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_WORD(fFlushTickets) 
MakePacketDef(CPKickMsg, _P_KICK_MSG);

#define _P_ALIVE_2_MSG(OP) \
	OP##_TYPE(PMSG_ALIVE_2) \
	OP##_STRUCT(P_ALIVE_2_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_WORD(cbAcctName) \
	OP##_FLD_DWORD(xnaddr_ina) \
	OP##_FLD_DWORD(xnaddr_inaOnline) \
	OP##_FLD_WORD(xnaddr_wPortOnline) \
	OP##_SARRAY(BYTE, xnaddr_abEnet, 6) \
	OP##_SARRAY(BYTE, xnaddr_abOnline, 20) \
	OP##_SARRAY(BYTE, xnkid_ab, 8) \
	OP##_SARRAY(BYTE, xnkey_ab, 16) \
	OP##_FLD_DWORD(dwBuddyListVersion) \
	OP##_FLD_DWORD(dwBlockListVersion) \
	OP##_FLD_WORD(cli_wMajorVersion) \
	OP##_FLD_WORD(cli_wMinorVersion) \
	OP##_FLD_WORD(cli_wBuildNumber) \
	OP##_FLD_WORD(cli_wQFENumber) \
	OP##_FLD_DWORD(dwTitleID) \
	OP##_FLD_DWORD(dwTitleVersion) \
	OP##_FLD_DWORD(dwTitleRegion) \
	OP##_FLD_WORD(ipportI) \
	OP##_FLD_DWORD(ipaI) \
	OP##_FLD_ULONGLONG(liNonce) \
	OP##_FLD_ULONGLONG(liTimeInit) \
	OP##_ARRAY(BYTE, szAcctName, cbAcctName) 
MakePacketDef(CPAlive2Msg, _P_ALIVE_2_MSG);

#define _P_WEB_FRIENDS_MSG(OP) \
	OP##_TYPE(PMSG_WEB_FRIENDS) \
	OP##_STRUCT(P_WEB_FRIENDS_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) 
MakePacketDef(CPWebFriendsMsg, _P_WEB_FRIENDS_MSG);

#define _P_WEB_ALIVE_MSG(OP) \
	OP##_TYPE(PMSG_WEB_ALIVE) \
	OP##_STRUCT(P_WEB_ALIVE_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) 
MakePacketDef(CPWebAliveMsg, _P_WEB_ALIVE_MSG);

#define _P_WEB_ANNOUNCE_MSG(OP) \
	OP##_TYPE(PMSG_WEB_ANNOUNCE) \
	OP##_STRUCT(P_WEB_ANNOUNCE_MSG) \
	OP##_FLD_ULONGLONG(qwDestUserID)  \
	OP##_FLD_WORD(cSourceUserIDs) \
	OP##_ARRAY(ULONGLONG, qwUserSourceIDs, cSourceUserIDs) 
MakePacketDef(CPWebAnnounceMsg, _P_WEB_ANNOUNCE_MSG);

#define _P_WEB_SUBSCRIBED_MSG(OP) \
	OP##_TYPE(PMSG_WEB_SUBSCRIBED) \
	OP##_STRUCT(P_WEB_SUBSCRIBED_MSG) \
	OP##_FLD_ULONGLONG(qwDestUserID) \
	OP##_FLD_WORD(cSourceUserIDs) \
	OP##_ARRAY(ULONGLONG, qwSourceUserIDs, cSourceUserIDs) 
MakePacketDef(CPWebSubscribedMsg, _P_WEB_SUBSCRIBED_MSG);

#define _P_WEB_UNSUBSCRIBE_MSG(OP) \
	OP##_TYPE(PMSG_WEB_UNSUBSCRIBE) \
	OP##_STRUCT(P_WEB_UNSUBSCRIBE_MSG) \
	OP##_FLD_ULONGLONG(qwSourceUserID)  \
	OP##_FLD_WORD(cDestUserIDs)  \
	OP##_ARRAY(ULONGLONG, qwDestUserIDs, cDestUserIDs)
MakePacketDef(CPWebUnsubscribeMsg, _P_WEB_UNSUBSCRIBE_MSG);

	/*
    PMSG_PEER_SESSION       = 1031,
    PMSG_TEAM_LIST_TEAMS    = 1032,
    PMSG_TEAM_LIST_MEMBERS  = 1033,
    PMSG_TEAM_CREATE        = 1034,
    PMSG_TEAM_DELETE        = 1035,
    PMSG_TEAM_REMOVE        = 1036,
    PMSG_TEAM_MANAGE_TEAM   = 1037,
    PMSG_TEAM_MANAGE_MEMBER = 1038,
    PMSG_TEAM_RECRUIT       = 1039,
    PMSG_TEAM_JOIN          = 1040,
    PMSG_TEAM_GET_TICKET    = 1041,
    PMSG_PEER_SUBSCRIBE     = 1042,
    PMSG_PEER_UNSUBSCRIBE   = 1043,
    PMSG_WATCH_START        = 1044,
    PMSG_WATCH_STOP         = 1045,
    PMSG_ADD_2              = 1046,
    PMSG_INVITE_2           = 1047,
    PMSG_ALIVE_INTERNAL     = 1048,
    PMSG_STATE_2            = 1049,
    PMSG_GET_STATE          = 1050,
    PMSG_TEAM_CREATE_XE     = 1051,
    PMSG_TEAM_MANAGE_TEAM_XE= 1052,
    PMSG_MAX_REQ_TYPE       = 1052,

    // Outgoing messages
    PMSG_MIN_REPLY_TYPE           = 1101,
    PMSG_ALIVE_REPLY              = 1101,
    PMSG_SYNC_REPLY               = 1102,
	*/
#define _P_WEB_FRIENDS_REPLY_MSG(OP) \
	OP##_TYPE(PMSG_WEB_FRIENDS_REPLY) \
	OP##_STRUCT(P_WEB_FRIENDS_REPLY_MSG) \
	OP##_FLD_DWORD(hr)  \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_DWORD(dwVersion) \
	OP##_FLD_WORD(wOnlineFriendsSent) \
	OP##_FLD_WORD(wOfflineFriendsSent) 
MakePacketDef(CPWebFriendsReplyMsg, _P_WEB_FRIENDS_REPLY_MSG);

#define _P_WEB_ALIVE_REPLY_MSG(OP) \
	OP##_TYPE(PMSG_WEB_ALIVE_REPLY) \
	OP##_STRUCT(P_WEB_ALIVE_REPLY_MSG) \
	OP##_FLD_DWORD(hr)  \
	OP##_FLD_ULONGLONG(qwUserID) 
MakePacketDef(CPWebAliveReplyMsg, _P_WEB_ALIVE_REPLY_MSG);

	/*
    PMSG_PEER_SESSION_REPLY       = 1105,
    PMSG_INVITE_REPLY             = 1106,
    PMSG_TEAM_LIST_TEAMS_REPLY    = 1107,
    PMSG_TEAM_LIST_MEMBERS_REPLY  = 1108,
    PMSG_TEAM_CREATE_REPLY        = 1109,
    PMSG_TEAM_DELETE_REPLY        = 1110,
    PMSG_TEAM_REMOVE_REPLY        = 1111,
    PMSG_TEAM_MANAGE_TEAM_REPLY   = 1112,
    PMSG_TEAM_MANAGE_MEMBER_REPLY = 1113,
    PMSG_TEAM_RECRUIT_REPLY       = 1114,
    PMSG_TEAM_JOIN_REPLY          = 1115,
    PMSG_TEAM_GET_TICKET_REPLY    = 1116,
    PMSG_PEER_SUBSCRIBE_REPLY     = 1117,
    PMSG_PEER_UNSUBSCRIBE_REPLY   = 1118,
    PMSG_GET_STATE_REPLY          = 1119,
    PMSG_MAX_REPLY_TYPE           = 1119
*/

#define _Q_HELLO_MSG(OP) \
	OP##_TYPE(QMSG_HELLO) \
	OP##_STRUCT(Q_HELLO_MSG) \
	OP##_FLD_DWORD(dwProtocolVersion) 
MakePacketDef(CQHelloMsg, _Q_HELLO_MSG);

#define _Q_USER_INFO_MSG(OP) \
	OP##_TYPE(QMSG_USER_INFO) \
	OP##_STRUCT(Q_USER_INFO_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
    OP##_FLD_DWORD(dwTitleID) \
    OP##_FLD_DWORD(dwAltTitleID1) \
    OP##_FLD_DWORD(dwAltTitleID2) \
    OP##_FLD_DWORD(dwAltTitleID3) \
    OP##_FLD_DWORD(dwAltTitleID4) \
    OP##_FLD_WORD(wBlockCount) \
	OP##_ARRAY(ULONGLONG, qwBlockedUsers, wBlockCount) 
MakePacketDef(CQUserInfoMsg, _Q_USER_INFO_MSG);

#define _Q_ADD_MSG(OP) \
	OP##_TYPE(QMSG_ADD) \
	OP##_STRUCT(Q_ADD_MSG) \
	OP##_FLD_WORD(wQType) \
    OP##_FLD_WORD(wUserCount) \
	OP##_ARRAY(ULONGLONG, qwUserIDs, wUserCount)
MakePacketDef(CQAddMsg, _Q_ADD_MSG);

#define _Q_DELETE_MSG(OP) \
	OP##_TYPE(QMSG_DELETE) \
	OP##_STRUCT(Q_DELETE_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
    OP##_FLD_WORD(wQType) \
    OP##_FLD_DWORD(dwFirstItemID) \
    OP##_FLD_DWORD(dwLastItemID) 
MakePacketDef(CQDeleteMsg, _Q_DELETE_MSG);

#define _Q_DELETE_MATCHES_MSG(OP) \
	OP##_TYPE(QMSG_DELETE_MATCHES) \
	OP##_STRUCT(Q_DELETE_MATCHES_MSG) \
	OP##_FLD_WORD(wQType) \
    OP##_FLD_WORD(wMatchAttrNum) \
    OP##_FLD_WORD(wUserCount) \
	OP##_ARRAY(ULONGLONG, qwUserIDs, wUserCount)
MakePacketDef(CQDeleteMatchesMsg, _Q_DELETE_MATCHES_MSG);

/*
    QMSG_DEAD_XBOX             =  5,
    QMSG_DEAD_SG               =  6,
*/

#define _Q_LIST_MSG(OP) \
	OP##_TYPE(QMSG_LIST) \
	OP##_STRUCT(Q_LIST_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_WORD(wQType) \
	OP##_FLD_DWORD(dwStartItemID) \
	OP##_FLD_WORD(wMaxItems) \
	OP##_FLD_DWORD(dwMaxTotalItemDataSize) 
MakePacketDef(CQListMsg, _Q_LIST_MSG);

#define _Q_DEQUEUE_MSG(OP) \
	OP##_TYPE(QMSG_DEQUEUE) \
	OP##_STRUCT(Q_DEQUEUE_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_WORD(wQType) \
	OP##_FLD_DWORD(dwStartItemID) \
	OP##_FLD_WORD(wMaxItems) \
	OP##_FLD_DWORD(dwMaxTotalItemDataSize) 
MakePacketDef(CQDequeueMsg, _Q_DEQUEUE_MSG);

#define _Q_DEAD_USER_MSG(OP) \
	OP##_TYPE(QMSG_DEAD_USER) \
	OP##_STRUCT(Q_DEAD_USER_MSG) \
	OP##_FLD_ULONGLONG(qwUserID)
MakePacketDef(CQDeadUserMsg, _Q_DEAD_USER_MSG);

#define _Q_WEB_USER_INFO_MSG(OP) \
	OP##_TYPE(QMSG_WEB_USER_INFO) \
	OP##_STRUCT(Q_WEB_USER_INFO_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_XARRAY(ULONGLONG, qwUserIDs)
MakePacketDef(CQWebUserInfoMsg, _Q_WEB_USER_INFO_MSG);

#define _Q_WEB_PRESENCE_MSG(OP) \
	OP##_TYPE(QMSG_WEB_PRESENCE) \
	OP##_STRUCT(Q_WEB_PRESENCE_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
    OP##_FLD_ULONGLONG(qwFriendID) \
    OP##_FLD_DWORD(dwFriendState) \
    OP##_FLD_DWORD(dwFriendTitleID) \
    OP##_FLD_WORD(cbTitleStuff) \
	OP##_ARRAY(BYTE, rgbTitleStuff, cbTitleStuff)
MakePacketDef(CQWebPresenceMsg, _Q_WEB_PRESENCE_MSG);

#define _Q_WEB_LIST_MSG(OP) \
	OP##_TYPE(QMSG_WEB_LIST) \
	OP##_STRUCT(Q_WEB_LIST_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) 
MakePacketDef(CQWebListMsg, _Q_WEB_LIST_MSG);

#define _Q_ENUM_MESSAGES(OP) \
	OP##_TYPE(QMSG_ENUM_MESSAGES) \
	OP##_STRUCT(Q_ENUM_MESSAGES_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) 
MakePacketDef(CQEnumMessagesMsg, _Q_ENUM_MESSAGES);

#define _Q_MESSAGE_SUMMARY_MSG(OP) \
	OP##_TYPE(QMSG_MESSAGE_SUMMARY) \
	OP##_STRUCT(Q_MESSAGE_SUMMARY_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_DWORD(dwMessageID) 
MakePacketDef(CQMessageSummaryMsg, _Q_MESSAGE_SUMMARY_MSG);

#define _Q_MESSAGE_DETAILS_MSG(OP) \
	OP##_TYPE(QMSG_MESSAGE_DETAILS) \
	OP##_STRUCT(Q_MESSAGE_DETAILS_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_DWORD(dwMessageID) \
	OP##_FLD_DWORD(dwSetFlags) \
	OP##_FLD_DWORD(dwUnsetFlags) 
MakePacketDef(CQMessageDetailsMsg, _Q_MESSAGE_DETAILS_MSG);

#define _Q_DELETE_MESSAGE_MSG(OP) \
	OP##_TYPE(QMSG_DELETE_MESSAGE) \
	OP##_STRUCT(Q_DELETE_MESSAGE_MSG) \
	OP##_FLD_ULONGLONG(qwUserID) \
	OP##_FLD_DWORD(dwMessageID) \
	OP##_FLD_DWORD(dwFlags) 
MakePacketDef(CQDeleteMessageMsg, _Q_DELETE_MESSAGE_MSG);

#define _Q_SEND_MESSAGE_MSG(OP) \
	OP##_TYPE(QMSG_SEND_MESSAGE) \
	OP##_STRUCT(Q_SEND_MESSAGE_MSG) \
	OP##_FLD_ULONGLONG(qwSenderID) \
	OP##_FLD_ULONGLONG(qwSenderContext) \
	OP##_FLD_DWORD(dwMessageFlags) \
	OP##_FLD_DWORD(dwSenderTitleID) \
	OP##_FLD_WORD(wExpireMinutes) \
	OP##_FLD_WORD(cbDetails) \
	OP##_FLD_WORD(cRecipients) \
	OP##_FLD_BYTE(bMessageType) \
	OP##_SARRAY(BYTE, szSenderName, XONLINE_GAMERTAG_SIZE-1) \
	OP##_ARRAY(ULONGLONG, rgRecipientIDs, cRecipients) 
MakePacketDef(CQSendMessageMsg, _Q_SEND_MESSAGE_MSG);

#define _Q_REVOKE_MESSAGE_MSG(OP) \
	OP##_TYPE(QMSG_REVOKE_MESSAGE) \
	OP##_STRUCT(Q_REVOKE_MESSAGE_MSG) \
	OP##_FLD_ULONGLONG(qwSenderID) \
	OP##_FLD_ULONGLONG(qwSenderContext) \
	OP##_FLD_WORD(cRecipients) \
	OP##_FLD_BYTE(bMessageType) \
	OP##_ARRAY(Q_RECIPIENT_RESULT, rgRecipients, cRecipients) 
MakePacketDef(CQRevokeMessageMsg, _Q_REVOKE_MESSAGE_MSG);

/*
    QMSG_DELETE_TITLE          = 19,
    QMSG_ENUM_TITLES           = 20,
    QMSG_MESSAGE_FLAGS         = 21,
    QMSG_ENUM_SYSTEM_MESSAGES  = 22,
    QMSG_SYSTEM_MESSAGE_DETAILS = 23,
    QMSG_DELETE_SYSTEM_MESSAGE = 24,
    QMSG_SEND_SYSTEM_MESSAGE   = 25,
*/

#define _Q_REVOKE_MESSAGE_EX_MSG(OP) \
	OP##_TYPE(QMSG_REVOKE_MESSAGE_EX) \
	OP##_STRUCT(Q_REVOKE_MESSAGE_EX_MSG) \
	OP##_FLD_ULONGLONG(qwSenderID)  \
	OP##_FLD_ULONGLONG(qwSenderContext)  \
	OP##_FLD_DWORD(dwFlags)  \
	OP##_FLD_WORD(wPropTag)  \
	OP##_FLD_WORD(cRecipients)  \
	OP##_FLD_WORD(cbProp) \
	OP##_FLD_BYTE(bMessageType) \
	OP##_ARRAY(Q_RECIPIENT_RESULT, rgRecipients, cRecipients)
MakePacketDef(CQRevokeMessageExMsg, _Q_REVOKE_MESSAGE_EX_MSG);

#define _Q_LIST_REPLY_MSG(OP) \
	OP##_TYPE(QMSG_LIST_REPLY) \
	OP##_STRUCT(Q_LIST_REPLY_MSG) \
	OP##_FLD_ULONGLONG(qwUserID)  \
	OP##_FLD_WORD(wQType)  \
	OP##_FLD_DWORD(hr)  \
	OP##_FLD_DWORD(dwNextItemID) \
	OP##_FLD_WORD(wQLeft) \
	OP##_FLD_WORD(wNumItems) \
	OP##_FLD_DWORD(dwTotalItemDataSize) \
	OP##_FLD_DWORD(cdwQVals) \
	OP##_ARRAY(DWORD, rgQVals, cdwQVals)
MakePacketDef(CQListReplyMsg, _Q_LIST_REPLY_MSG);

#define _Q_WEB_LIST_REPLY_MSG(OP) \
	OP##_TYPE(QMSG_WEB_LIST_REPLY) \
	OP##_STRUCT(Q_WEB_LIST_REPLY_MSG) \
	OP##_FLD_DWORD(hr)  \
	OP##_FLD_WORD(wNumItems) \
	OP##_ARRAY(PQ_WEB_FRIEND, rgFriends, wNumItems)
MakePacketDef(CQWebListReplyMsg, _Q_WEB_LIST_REPLY_MSG);

#define _Q_ENUM_MESSAGES_REPLY_MSG(OP) \
	OP##_TYPE(QMSG_WEB_LIST) \
	OP##_STRUCT(Q_ENUM_MESSAGES_REPLY_MSG) \
	OP##_FLD_DWORD(hr) \
	OP##_FLD_WORD(cMessages) \
	OP##_ARRAY(Q_MESSAGE_SUMMARY, rgMessages, cMessages) 
MakePacketDef(CQEnumMessagesReplyMsg, _Q_ENUM_MESSAGES_REPLY_MSG);

	/*
    QMSG_ENUM_MESSAGES_REPLY   = 102,
    QMSG_MESSAGE_SUMMARY_REPLY = 103,
    QMSG_MESSAGE_DETAILS_REPLY = 104,
    QMSG_DELETE_MESSAGE_REPLY  = 105,
    QMSG_SEND_MESSAGE_REPLY    = 106,
    QMSG_REVOKE_MESSAGE_REPLY  = 107,
    QMSG_DELETE_TITLE_REPLY    = 108,
    QMSG_ENUM_TITLES_REPLY     = 109,
    QMSG_MESSAGE_FLAGS_REPLY   = 110,
    QMSG_ENUM_SYSTEM_MESSAGES_REPLY = 111,
    QMSG_SYSTEM_MESSAGE_DETAILS_REPLY = 112,
    QMSG_DELETE_SYSTEM_MESSAGE_REPLY = 113,
    QMSG_SEND_SYSTEM_MESSAGE_REPLY = 114,
    QMSG_MAX_REPLY_TYPE        = 114
*/
#pragma pack(pop)

//------------------------------------------------------------------------------
// Helper functions
//

typedef enum DUMP_MESSAGE_FORMAT
{
    DMF_MULTI_LINE,
    DMF_SINGLE_LINE
} DUMP_MESSAGE_FORMAT;

// Data contains message header and message payload, cbData should indicate
// total length of message (including the header)
// 
// returns FALSE if message type is unknown
BOOL DumpMessage(BYTE *pbData, DWORD cbData, DUMP_MESSAGE_FORMAT eMessageFormat);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\ServerPool.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#include "PTNCore.h"


MGMT_DefineLoggingCategory(ServerPool);

/////////////////////////////////////////////////////////////////////////////
// CServerPool
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////
// Ctor
//
CServerPool::CServerPool
(
    DWORD  dwServers, 
    HANDLE hShutdownEvent,       // = NULL
    ULONG  ulcSendBuffers,       // = DEFAULTBUFFERS, 
    ULONG  ulcSendBufferSize,    // = DEFAULTBUFFERSIZE, 
    long   lcReceiveBufferSize ) // = -1 
: 
    m_hShutdownEvent( hShutdownEvent ), 
    m_dwServers( 0 ),
    m_apClient( NULL )
{
    // Check for valid server count
    if( 0L >= dwServers ) 
    {
        return;
    }

    // Create client connection array
    m_apClient = new TCPClientConnection*[ dwServers ];
    if( NULL == m_apClient )
    {
        return;
    }

    // Create client connections
    for( DWORD dw = 0L; dw < dwServers; dw++ )
    {
        m_apClient[ dw ] = new 
            TCPClientConnection( 
                m_hShutdownEvent,
                ulcSendBuffers,
                ulcSendBufferSize,
                lcReceiveBufferSize );
        if( NULL == m_apClient[ dw ] )
        {
            return;
        }
    }

    // Create list of ips
    m_adwIP = new DWORD[ dwServers ];
    if( NULL == m_adwIP )
    {
        return;
    }

    // Create list of ports
    m_awPort = new WORD[ dwServers ];
    if( NULL == m_awPort )
    {
        return;
    }

    m_dwServers = dwServers;

	TRACE4(ServerPool, L_DEBUG, "ServerPool created: dwServers: %d, ulcSendBuffers: %d, ulcSendBufferSize: %d, lcReceiveBufferSize: %d",
			dwServers, ulcSendBuffers, ulcSendBufferSize, lcReceiveBufferSize);
}

/////////////////////////////////////////////////
// Dtor
//
CServerPool::~CServerPool()
{
    if( NULL==m_apClient ) return;

    // Delete client connections
    for( DWORD dw = 0L; dw < m_dwServers; dw++ )
    {
        if( NULL != m_apClient[ dw ] )
        {
            delete m_apClient[ dw ];
        }
    }
    delete[] m_apClient;

    // Delete client IPs
    if( NULL != m_adwIP )
    {
        delete[] m_adwIP;
    }

    // Delete client ports
    if( NULL != m_awPort )
    {
        delete[] m_awPort;
    }
}

/////////////////////////////////////////////////
//  User To IP
//
DWORD CServerPool::UserToIP( 
    ULONGLONG qwUserId )
{
    if( NULL == m_adwIP )
    {
        return E_FAIL;
    }

    return m_adwIP[ UserToServer( qwUserId ) ];
}

/////////////////////////////////////////////////
//  Wait For All Pending Buffers To Flush
//
HRESULT CServerPool::WaitForAllPendingBuffersToFlush(
    DWORD dwTimeout )
{
    HRESULT hr = S_OK;
    
    for( DWORD dw = 0L; dw < m_dwServers; dw++ )
    {
        if( FAILED( m_apClient[ dw ]->WaitForAllPendingBuffersToFlush( dwTimeout ) ) )
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

/////////////////////////////////////////////////
//  Connect
//
HRESULT CServerPool::Connect( 
    DWORD* adwIP, 
    UINT   uiNumIPs, 
    WORD*  awPort, 
    DWORD  dwTimeout ) // = WSA_INFINITE 
{
    HRESULT hr = S_OK;
	DWORD dwConnected = 0;
    
    for( DWORD dw = 0L; hr == S_OK && dw < m_dwServers; dw++ )
    {
        m_adwIP[ dw ] = adwIP[ dw ];
        m_awPort[ dw ] = awPort[ dw ];

		TRACE3(ServerPool, L_HIGH, "Connecting to: %s:%d, Timeout: %d", inet_ntoa(*(in_addr*)&m_adwIP[dw]), m_awPort[dw], dwTimeout);
		hr = m_apClient[ dw ]->Connect( m_adwIP[ dw ], m_awPort[ dw ], dwTimeout );
     	if( FAILED( hr ) )
        {
			in_addr ina;
			ina.S_un.S_addr = m_adwIP[dw];
			ERR2(ServerPool, "Failed to connect to server: %s:%d", inet_ntoa(ina), m_awPort[dw]);
        }   
		else
		{
			++dwConnected;
		}
    }

	TRACE1(ServerPool, L_HIGH, "(%d) servers connected", dwConnected);

    return hr;
}

/////////////////////////////////////////////////
//  Close
//
HRESULT CServerPool::Close( 
    bool fHard ) // = false 
{
    HRESULT hr = S_OK;
    
    for( DWORD dw = 0L; dw < m_dwServers; dw++ )
    {
        if( FAILED( m_apClient[ dw ]->Close( fHard ) ) )
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

/////////////////////////////////////////////////
//  Send
//
HRESULT CServerPool::Send(
    ULONGLONG   qwUserId, 
    const BYTE* pBuf, 
    int         iLen, 
    BOOL        fFlush,     // = TRUE
    DWORD       dwTimeout ) // = WSA_INFINITE
{
	HRESULT hr;

	if(0 == qwUserId)
	{
		for(DWORD dwi = 0, dwc = m_dwServers; dwi < dwc; ++dwi)
		{
			hr = m_apClient[dwi]->Send((const char*)pBuf, iLen, fFlush, dwTimeout);
			if(FAILED(hr))
			{
				ERR2(ServerPool, "[CServerPool::Send]: send failed to server index: %u, HR: 0x%08x",
						dwi, hr);
				break;
			}
		}
	}
	else
	{
		DWORD iServer = UserToServer( qwUserId );
		hr = m_apClient[iServer]->Send( (const char*)pBuf, iLen, fFlush, dwTimeout );
	}

	return hr;
}

/////////////////////////////////////////////////
//  Send ALL
//
HRESULT CServerPool::SendALL(
    const BYTE* pBuf, 
    int         iLen, 
    BOOL        fFlush,     // = TRUE
    DWORD       dwTimeout ) // = WSA_INFINITE
{
    HRESULT hr = S_OK;
    
    for( DWORD dw = 0L; dw < m_dwServers; dw++ )
    {
        if( FAILED( hr = m_apClient[ dw ]->Send( (const char*)pBuf, iLen, fFlush, dwTimeout ) ) )
        {
			ERR3(ServerPool, "SendALL(): Failed to Send to client index: %d, address: %s:%d",
					dw, m_apClient[dw]->GetClientIp(), ntohs(m_apClient[dw]->GetClientPort()));
            break;
        }
    }

    return hr;
}

/////////////////////////////////////////////////
//  Receive
//
HRESULT CServerPool::Receive( 
    ULONGLONG qwUserId, 
    BYTE*     pBuf, 
    DWORD     dwLen, 
    DWORD*    pdwLen, 
    DWORD     dwTimeout ) // = WSA_INFINITE
{
    return m_apClient[ UserToServer( qwUserId ) ]->Receive( (char*)pBuf, dwLen, pdwLen, dwTimeout );
}

/////////////////////////////////////////////////
//  Wait For Disconnect
//
bool CServerPool::WaitForDisconnect( 
    ULONGLONG qwUserId, 
    int       iTimeout )
{
    return m_apClient[ UserToServer( qwUserId ) ]->WaitForDisconnect( iTimeout );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\PTNCore.h ===
//
// Presence Test Native C++ Core 
// Author: jacobr@microsoft.com
// Copyright (c) Microsoft Corporation.  All rights reserved
//
#pragma once

// TODO: support native presence unicode?
#ifdef UNICODE
#undef UNICODE
#endif

#ifdef _UNICODE
#undef _UNICODE
#endif

// warning settings
// unreference formal parameter
#pragma warning(disable: 4100)
// conditional expression is constant
#pragma warning(disable: 4127)

//
// system includes
#define INCL_WINSOCK_API_TYPEDEFS 1 
#include <winsock2.h>
#include <windows.h>
#include <mswsock.h>
#include <ws2tcpip.h>
#include <wininet.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <process.h>

#include <wmsstd.h>
#include <xalloc.h>
#include <wsockntp.h>
#include <atlsafe.h>

#include "NetStruct.h"

#include <tcpcnt.h>
#include <servsock.h>
#include <ntservice.h>

// dstruct
#include <dstructp.h>
#include <tptrarr.h>
#include <tptrlist.h>

#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers

// local includes
#include "Memory.h"
#include "Utility.h"
#include "Management.h"
#include "SafeCounter.h"
#include "TRefCountObj.h"
#include "TThreadContainer.h"
#include "TDynamicArray.h"
#include "TLockFreeFifo.h"
#include "TBuffer.h"
#include "NetworkEndpoint.h"
#include "Connection.h"
#include "Win32Event.h"
#include "Serverpool.h"
#include "ThreadPool.h"
#include "AsyncSocket.h"
#include "CompletionPort.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\ServerPool.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

// engine.h : Declaration of the Cengine

#pragma once

#include "connection.h"        // connection
#include "wmsstd.h"        // LODWORD and HIDWORD

/////////////////////////////////////////////////////////////////////////////
// CServerPool
class CServerPool
{
public: 
    explicit CServerPool( 
        DWORD  dwServers, 
        HANDLE hShutdownEvent      = NULL, 
        ULONG  ulcSendBuffers      = DEFAULTBUFFERS, 
        ULONG  ulcSendBufferSize   = DEFAULTBUFFERSIZE, 
        long   lcReceiveBufferSize = -1 );

    ~CServerPool();

    // Return number of servers
    DWORD NumServers() { return m_dwServers; }

    // Return IP address of server that user is assigned to
    DWORD CServerPool::UserToIP( 
        ULONGLONG qwUserId );

    // Wait for all overlapped async buffers to be in non-pending state
    HRESULT WaitForAllPendingBuffersToFlush( 
        DWORD dwTimeout );

    //Establish connections
    HRESULT Connect( 
        DWORD* adwIP, 
        UINT   uiNumIPs, 
        WORD*  awPort, 
        DWORD  dwTimeout = WSA_INFINITE );

    //Close connections
    HRESULT Close( 
        bool fHard = false );

    //Send data down proper connection
    HRESULT Send( 
        ULONGLONG   qwUserId, 
        const BYTE* pBuf, 
        int         iLen, 
        BOOL        fFlush    = TRUE, 
        DWORD       dwTimeout = WSA_INFINITE );

    //Send data down proper connection
    HRESULT SendALL(
        const BYTE* pBuf, 
        int         iLen, 
        BOOL        fFlush = TRUE, 
        DWORD       dwTimeout = WSA_INFINITE );

    //Receive data off the proper connection
    HRESULT Receive( 
        ULONGLONG qwUserId, 
        BYTE*     pBuf, 
        DWORD     dwLen, 
        DWORD*    pdwLen, 
        DWORD     dwTimeout = WSA_INFINITE );

    //Wait for socket disconnect or timeout
    bool WaitForDisconnect( 
        ULONGLONG qwUserId, 
        int       iTimeout );

private:

    // Hash user ID to Server index
    DWORD UserToServer( ULONGLONG qwUserID )
    {
        return ((LODWORD(qwUserID) + HIDWORD(qwUserID)) % 95219) % m_dwServers;
    }
    
    // Number of Servers in pool
    DWORD m_dwServers;

    // SHutdown Event passed to all Connection objects 
    HANDLE m_hShutdownEvent;
    
    // Server Connection array
    TCPClientConnection** m_apClient;

    // Server IP array
    DWORD* m_adwIP;

    // Server port array
    WORD* m_awPort;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\SimStruct.cpp ===
#include "PTNCore.h"

void XboxInfo::SetUser(DWORD dwUserIndex, QWORD qwUserId, DWORD dwUserFlags)
{
}

void XboxInfo::ClearUsers()
{
	
}

void XboxInfo::SetXboxDefaults(QWORD _qwXboxId, DWORD _dwTitleId, DWORD _dwSpi)
{
	
}	

void XboxInfo::SetXenonDefaults(QWORD _qwXboxId, DWORD dwTitleId, DWORD _dwSpi)
{
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\SimStruct.h ===
#pragma once

//
// SimStruct.h
//
// Structures used across the simulation
//
#pragma push(pack, 1)
struct UserInfo
{
	QWORD qwUserId;
	QWORD qwMatchId;
	DWORD dwState;
	CHAR  rgbName[XONLINE_GAMERTAG_SIZE];
	WORD  wcbTitleData;
	BYTE  *prgbTitleData;
};

struct XboxInfo
{
	QWORD                qwXboxId;
	XBOX_LIBRARY_VERSION clientVersion;
	DWORD                dwTitleId;
	DWORD                dwTitleRegion;
	DWORD                dwTitleVersion;
	QWORD                rgqwUserId[XONLINE_MAX_LOGON_USERS];
	DWORD                rgdwUserFlags[XONLINE_MAX_LOGON_USERS];
	SGADDR               sgaddr;
	WORD                 wPort;
	DWORD                dwSpi;
	DWORD                dwAuthDataFlags;

	void SetUser(DWORD dwUserIndex, QWORD qwUserId, DWORD dwUserFlags)
	{
		ASSERT_THROW(dwUserIndex < 4);

		rgqwUserId[dwUserIndex] = qwUserId;
		rgdwUserFlags[dwUserIndex] = dwUserFlags;
	}
	void ClearUsers()
	{
		rgqwUserId[0]    = 0;
		rgqwUserId[1]    = 0;
		rgqwUserId[2]    = 0;
		rgqwUserId[3]    = 0;

		rgdwUserFlags[0] = 0;
		rgdwUserFlags[1] = 0;
		rgdwUserFlags[2] = 0;
		rgdwUserFlags[3] = 0;
	}
	void SetXboxDefaults(QWORD _qwXboxId, DWORD _dwTitleId, DWORD _dwSpi)
	{
		ClearUsers();

		qwXboxId         = _qwXboxId;
		dwTitleId        = _dwTitleId;
		dwSpi            = _dwSpi;
		dwAuthDataFlags  = 0x0;
	}
	void SetXenonDefaults(QWORD _qwXboxId, DWORD _dwTitleId, DWORD _dwSpi)
	{
		ClearUsers();

		qwXboxId         = _qwXboxId;
		dwTitleId        = _dwTitleId;
		dwSpi            = _dwSpi;
		dwAuthDataFlags  = 0x1;
	}
};

struct QValInfo
{
	QWORD qwUserId;
	DWORD dwQVFlags;
	DWORD dwFlags;
	DWORD dwQVNewInvite;
	DWORD dwQVNewMsgIds;
	DWORD dwMsgId1;
	DWORD dwMsgId2;
	DWORD dwMsgId3;
	DWORD dwQVNewMsgData;
	DWORD dwMsgData1;
	DWORD dwMsgData2;
	DWORD dwMsgData3;
	DWORD dwQVDelMsgIds;
	DWORD dwDelId1;
	DWORD dwDelId2;
	DWORD dwDelId3;
};
#pragma pop(pack)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\TBuffer.h ===
#pragma once

template<class _Type>
class Buffer
{
private:
	bool m_bLocked;
	DWORD m_dwAvail;
	DWORD m_dwCount;
	_Type *m_prgData;

	void Init()
	{
		m_dwAvail = m_dwCount = 0;
		m_prgData = 0;
		m_bLocked = false;
	}

public:
	Buffer()
	{
		Init();
	}

	explicit Buffer(DWORD dwReserve) 
    {
		Init();
		Reserve(dwReserve);
	}

	~Buffer()
	{
        delete[] m_prgData;
        m_prgData = 0;
        m_dwCount = m_dwAvail = 0;
	}


	_Type *LockData()
	{
		m_bLocked = true;
		return m_prgData;
	}

	void UnlockData()
	{
		m_bLocked = false;
	}

	HRESULT Release()
	{
		_ASSERTE(false == m_bLocked);

		if(0 != m_prgData)
		{
			delete[] m_prgData;
			m_prgData = 0;
			m_dwCount = m_dwAvail = 0;
            m_bLocked = false;

            return S_OK;
		}
        else
        {
            return S_FALSE;
        }
	}

    HRESULT Compact()
    {
        if(0 == m_dwCount)
        {
            return Release();  
        }

        if(m_dwAvail > m_dwCount)
        {
            _Type *prgNewData = new _Type[m_dwCount];
            if(0 == prgNewData)
            {
                return E_OUTOFMEMORY;
            }

            CopyMemory(prgNewData, m_prgData, sizeof(_Type) * m_dwCount);
            m_dwAvail = m_dwCount;

            delete [] m_prgData;
            m_prgData = prgNewData;
        }

        return S_OK;
    }

	HRESULT Set(DWORD dwIndex, const _Type &inValue)
	{
		if(dwIndex < m_dwCount)
		{
            *(m_prgData + dwIndex) = inValue;
            return S_OK;
		}
        else
        {
            return E_INVALIDARG;
        }
	}

    HRESULT Remove(DWORD dwIndex)
    {
        if(dwIndex < m_dwCount)
        {
            m_prgData[dwIndex] = m_prgData[m_dwCount-1];
            m_dwCount--;
            return S_OK;
        }
        else
        {
            return E_INVALIDARG;
        }
    }

    HRESULT Remove(const _Type *pData)
    {
        if(pData >= m_prgData && pData < (m_prgData + m_dwCount))
        {
            DWORD dwIndex = pData - m_prgData;
            m_prgData[dwIndex] = m_prgData[m_dwCount-1];
            m_dwCount--;
            return S_OK;
        }
        else
        {
            return E_INVALIDARG;
        }
    }

	HRESULT Append(const _Type &inValue, _Type **ppOut = 0)
	{
		HRESULT hr;

		if(FAILED(hr = Reserve(m_dwCount + 1)))
		{
			return hr;
		}

		*(m_prgData + m_dwCount) = inValue;
		m_dwCount++;

        if(ppOut)
        {
            *ppOut = (m_prgData + (m_dwCount - 1));
        }

		return S_OK;
	}

	HRESULT Append(_Type *prgData, DWORD dwCount)
	{
		HRESULT hr;

		_ASSERTE(false == m_bLocked);

		// Make sure we have enough space reserved for the append
		if(FAILED(hr = Reserve(m_dwCount + dwCount)))
		{
			return hr;
		}

		_Type *pDst = m_prgData + m_dwCount;
		_Type *pSrc = prgData;
		_Type *pEnd = prgData + dwCount;
		
		while(pSrc < pEnd)
		{
			*pDst++ = *pSrc++;
			m_dwCount++;
		}

		return S_OK;
	}

	void Clear(bool bZero = false)
	{
		_ASSERTE(false == m_bLocked);

		m_dwCount = 0;
		if(bZero)
		{
			ZeroMemory(m_prgData, m_dwCount * sizeof(_Type));
		}
	}

	HRESULT Reserve(DWORD dwReserve)
	{
		if(dwReserve == 0)
		{
			return E_INVALIDARG;
		}

        _ASSERTE(false == m_bLocked);
        if(m_bLocked)
        {
            return E_FAIL;
        }

		if(dwReserve > m_dwAvail)
		{
			_Type *prgNewData = new _Type[dwReserve];

			if(!prgNewData)
			{
				return E_OUTOFMEMORY;
			}

			if(m_prgData)
			{
				if(m_dwCount > 0)
				{
					CopyMemory(prgNewData, m_prgData, m_dwCount * sizeof(_Type));
				}
				delete[] m_prgData;
			}
			m_prgData = prgNewData;
			m_dwAvail = dwReserve;
		}

		return S_OK;
	}

	DWORD GetCount() const
	{ 
		return m_dwCount;
	}

	void SetActualCount(DWORD dwActual)
	{
		m_dwCount = dwActual;
	}

	DWORD GetCountBytes() const
	{
		return m_dwCount * sizeof(_Type);
	}

	DWORD GetAvail() const
	{
		return m_dwAvail;
	}

	DWORD GetAvailBytes() const
	{
		return m_dwAvail * sizeof(_Type);
	}

	bool IsLocked() const
	{
		return m_bLocked;
	}

	HRESULT GetAt(DWORD dwIndex, _Type &outValue)
	{
		if(dwIndex >= m_dwCount)
		{
			return E_INVALIDARG;
		}

		outValue = m_prgData[dwIndex];

		return S_OK;
	}

    _Type *First() const
	{
        return m_prgData;
	}

    _Type *End() const 
    {
        return m_prgData + m_dwCount;
    }
};

typedef Buffer<BYTE> ByteBuffer;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\TDynamicArray.h ===
#pragma once

template<class _Type>
class DynamicArray
{
private:
	DWORD m_dwAvail;
	DWORD m_dwCount;
	_Type *m_prgData;

	void Init()
	{
		m_dwAvail = m_dwCount = 0;
		m_prgData = 0;
	}

public:
	DynamicArray()
	{
		Init();
	}
	explicit DynamicArray(DWORD dwReserve) {
		Init();
		Reserve(dwReserve);
	}
	~DynamicArray()
	{
		Release();	
	}
	void Release()
	{
		if(m_prgData)
		{
			delete[] m_prgData;
			m_prgData = 0;
			m_dwCount = m_dwAvail = 0;
		}
	}
	HRESULT Append(_Type *prgData, DWORD dwCount)
	{
		HRESULT hr;

		// Make sure we have enough space reserved for the append
		if(FAILED(hr = Reserve(m_dwCount + dwCount)))
		{
			return hr;
		}

		_Type *pDst = m_prgData + m_dwCount;
		_Type *pSrc = prgData;
		_Type *pEnd = prgData + dwCount;
		
		while(pSrc < pEnd)
		{
			*pDst++ = *pSrc++;
			m_dwCount++;
		}

		return S_OK;
	}
	void Clear()
	{
		m_dwCount = 0;
	}
	HRESULT Reserve(DWORD dwReserve)
	{
		if(dwReserve == 0)
		{
			return E_INVALIDARG;
		}
		
		if(dwReserve > m_dwAvail)
		{
			_Type *prgNewData = new _Type[dwReserve];

			if(!prgNewData)
			{
				return E_OUTOFMEMORY;
			}

			if(m_prgData)
			{
				if(m_dwCount > 0)
				{
					CopyMemory(prgNewData, m_prgData, m_dwCount * sizeof(_Type));
				}
				delete[] m_prgData;
			}
			m_prgData = prgNewData;
			m_dwAvail = dwReserve;
		}

		return S_OK;
	}

	//
	// Accessors
	//
	DWORD GetCount() const
	{ 
		return m_dwCount;
	}
	DWORD GetCountBytes() const
	{
		return m_dwCount * sizeof(_Type);
	}
	DWORD GetAvail() const
	{
		return m_dwAvail;
	}
	DWORD GetAvailBytes() const
	{
		return m_dwAvail * sizeof(_Type);
	}
	_Type *GetData() const
	{
		return m_prgData;
	}

	// 
	// Operators
	//
	inline _Type& operator[](DWORD i)
	{
		ASSERT_THROW(i < m_dwCount);
		return m_prgData[i];
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\TLockFreeFifo.h ===
#pragma once


//  Lock-free fifo based on "Simple, Fast, and Practical
//  Non-Blocking and Blocking Concurrent Queue Algorithms"
//  By Maged M. Michael and Michael L. Scott.
//
//  C++ template by jacobr@microsoft.com
//
template<typename _T>
class LockFreeFifo
{
protected:
	enum {
		kNull = 0xffff
	};

	// Ensure that link index and count are byte aligned
#pragma pack(push, 1)
	struct Link { 
		WORD _wIndex; 
		WORD _wCount;

		Link()
		{
			_wIndex = 0;
			_wCount = 0;
		}
		Link(WORD wIndex, WORD wCount)
		{
			_wIndex = wIndex;
			_wCount = wCount;
		}
		inline volatile Link &operator=(const volatile Link &rhs) volatile 
		{
			_wIndex = rhs._wIndex;
			_wCount = rhs._wCount;
			return *this;
		}
		inline bool Compare(const volatile Link &rhs) volatile const
		{
			return _wIndex == rhs._wIndex && _wCount == rhs._wCount;
		}
	};
#pragma pack(pop)

	struct Node {
		volatile Link _Next; 
		_T            _Value;
	};

	volatile Link  m_Head;
	volatile Link  m_Tail;
	volatile Link  m_FreeList;

	// The data is protected by the atomic free-list so is not
	// declared volatile
	Node*          m_prgNodes;
	DWORD          m_dwcNodes;
	SafeCounter    m_ActiveCount;

	
	
	WORD _NewNode() volatile
	{
		Link freeList;
		Link next;
		LONG lValue;
		WORD wNewIndex = kNull;

		while(true)
		{
			freeList = m_FreeList;

			// Check for out of free node conditions
			if(freeList._wIndex == kNull)
			{
				break;
			}

			// Get the next node link for swap
			next = _NodeAt(freeList._wIndex)._Next;

			// If the free list is still valid swap the free list link
			// with the next link, otherwise spin and try again
			next._wCount = freeList._wCount + 1;
			lValue = InterlockedCompareExchange(
					(LONG volatile *)&m_FreeList,
					*(LONG*)&next,
					*(LONG*)&freeList);

			// Operation succeeded
			if(lValue == *(LONG*)&freeList)
			{
				wNewIndex = freeList._wIndex;
				break;
			}
		}

		return wNewIndex;
	}
	
	void _FreeNode(WORD iNode) volatile
	{
		LONG lValue;
		Link freeList;
		Link next;

		while(true)
		{
			freeList = m_FreeList;

			// Update the node being released next to refer to current free list head
			_NodeAt(iNode)._Next._wIndex = freeList._wIndex;
			_NodeAt(iNode)._Next._wCount = freeList._wCount;

			
			// Swap the free list head with the node ID that is being
			// free'd
			Link newFreeList(iNode, freeList._wCount+1);
			lValue = InterlockedCompareExchange(
					(LONG volatile*)&m_FreeList,
					*(LONG*)&newFreeList,
					*(LONG*)&freeList);
			
			// Operation succeeded
			if(lValue == *(LONG*)&freeList)
			{
				break;
			}
		}
	}

	inline volatile Node &_NodeAt(WORD wIndex) volatile const
	{
		ASSERT_THROW(wIndex < m_dwcNodes && wIndex < kNull);
		return const_cast<volatile Node &>(m_prgNodes[wIndex]);
	}

public:
	LockFreeFifo() :
		m_prgNodes(0),
		m_dwcNodes(0)
	{
	}
	~LockFreeFifo()
	{
		Destroy();
	}

	HRESULT Create(DWORD dwcNodes)
	{
		HRESULT hr = S_OK;

		m_dwcNodes = dwcNodes;
		m_prgNodes = new Node[dwcNodes];
		if(0 == m_prgNodes)
		{
			hr = E_OUTOFMEMORY;
			goto lbDone;
		}

		ZeroMemory(m_prgNodes, sizeof(Node) * m_dwcNodes);

		m_FreeList._wIndex = 0;
		m_FreeList._wCount = 0;

		WORD i;
		for(i = 0; i < (m_dwcNodes - 1); ++i)
		{
			m_prgNodes[i]._Next._wIndex = i+1;
			m_prgNodes[i]._Next._wCount = 0;
		}
		m_prgNodes[i]._Next._wIndex = kNull;
		m_prgNodes[i]._Next._wCount = 0;

		// Allocate a sentinal node
		WORD wiSentinal = _NewNode();
		m_prgNodes[wiSentinal]._Next._wIndex = kNull;

		// Both head and tail point to the sential
		m_Head._wIndex = wiSentinal;
		m_Tail._wIndex = wiSentinal;
		
lbDone:
		return hr;
	}

	void Destroy()
	{
		if(0 != m_prgNodes)
		{
			delete[] m_prgNodes;
			m_prgNodes = 0;
			m_dwcNodes = 0;
			m_ActiveCount.lValue = 0;
			m_Head._wIndex = m_Head._wCount = 0;
			m_Tail._wIndex = m_Head._wCount = 0;
			m_FreeList._wIndex = m_Head._wCount = 0;
		}
	}

	bool Enqueue(const _T &inValue)
	{
		LONG lValue;

		// Get a new node
		WORD iNewNode = _NewNode();
		if(kNull == iNewNode)
		{
			// Ran out of nodes to allocate
			return false;
		}

		// Reset new node (this node is non-volatile as it has been protected
		// by the _NewNode() aquisition)
		Node &node = const_cast<Node&>(m_prgNodes[iNewNode]);
		node._Next._wIndex = kNull;
		node._Next._wCount = 0;
		node._Value = inValue;

		Link tail;
		Link next;

		while(true)
		{
			// Read tail and next (index and count)
			tail = m_Tail;	
			next = _NodeAt(m_Tail._wIndex)._Next;

			// Are tail and next consistent
			if(tail.Compare(m_Tail))
			{
				// Is tail last node in list
				if(kNull == next._wIndex) 
				{
					// Try to link new node onto tail using tails current count
					Link newLink(iNewNode, tail._wCount+1);
					lValue = InterlockedCompareExchange(
								(LONG volatile*)&(_NodeAt(tail._wIndex)._Next),
								*(LONG*)&newLink,
								*(LONG*)&next);

					if(lValue == *(LONG*)&next)
					{
						// Modification succeeded as planned exit the modification loop
						break;
					}
				}
				else
				{
					// Tail was not pointing at last node, try to move
					// tail to next node
					Link newTail(next._wIndex, tail._wCount+1);

					InterlockedCompareExchange(
							(LONG volatile*)&m_Tail,
							*(LONG*)&newTail,
							*(LONG*)&tail);
				}
			}
		}


		// Enqueue is finished swing tail to inserted node
		Link newTail(iNewNode, tail._wCount+1);
		InterlockedCompareExchange(
				(LONG volatile*)&m_Tail,
				*(LONG*)&newTail,
				*(LONG*)&tail);
				
		m_ActiveCount++;

		return true;
	}

	bool Dequeue(_T &outValue)
	{
		LONG lValue;
		Link head;
		Link tail;
		Link next;

		while(true)
		{
			// Read head, tail and head.next
			head = m_Head;
			tail = m_Tail;
			next = _NodeAt(head._wIndex)._Next;

			// Make sure that head, tail and head.next are consistent
			if(head.Compare(m_Head))
			{
				// Are head and tail the same 
				// Empty queue or tail falling behind
				if(head._wIndex == tail._wIndex)
				{
					// Is queue empty?
					if(kNull == next._wIndex)
					{
						return false;
					}

					// Tail is falling behind try to advance it
					Link newTail(next._wIndex, tail._wCount+1);
					InterlockedCompareExchange(
							(LONG volatile *)&m_Tail,
							*(LONG*)&newTail,
							*(LONG*)&tail);
				}
				else // tail does not need to be adjusted
				{
					// Read value before CAS otherwise another dequeue might free the next node	
					// (cast away volatile)
					outValue = *(_T*)&(_NodeAt(next._wIndex)._Value);

					Link newHead(next._wIndex, head._wCount+1);
					lValue = InterlockedCompareExchange(
							(LONG volatile *)&m_Head,
							*(LONG*)&newHead,
							*(LONG*)&head);

					if(lValue == *(LONG*)&head)
					{
						// End the loop
						break;
					}
				}
			}
		}

		_FreeNode(head._wIndex);
		
		m_ActiveCount--;

		return true;
	}

	inline LONG	Count() const
	{
		return (LONG)m_ActiveCount;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\TRefCountObj.h ===
#pragma once


//
// Reference counting helper template
//
template<class T>
class RefCountObj
{
protected:
	long m_lRefCount;

public:
	RefCountObj()
	{
		// Objects will have one reference when they are created
		m_lRefCount = 1;
	}
	virtual ~RefCountObj()
	{
	}
	
	long AddRef()
	{
		return InterlockedIncrement(&m_lRefCount);
	}

	long Release()
	{
		long lCount = InterlockedDecrement(&m_lRefCount);
		if(lCount == 0)
		{
			delete this;
		}

		return lCount;
	}
};


//
// Object to manage references within a scope. This object doesn't add references
// of it's own. AutoRef is a notation of the callee to hold exactly one reference to 
// a given pointer of the specified type.
// 
template<class T>
class AutoRef
{
protected:
	T *m_pType;
public:
	AutoRef()
	{
		m_pType = 0;
	} 

	AutoRef(T *pType)
	{
		m_pType = pType;
	}

	~AutoRef()
	{
		if(0 != m_pType)
		{ 
			m_pType->Release();
			m_pType = 0;
		}
	}

	// assign this reference to a new pointer
	AutoRef<T> &operator=(T *pType)
	{
		if(0 != m_pType)
		{
			// we have to let go of our current reference
			m_pType->Release();
		}
		m_pType = pType;
	}

	// conversion to type of pointer
	inline operator T*() const
	{
		return m_pType;
	}

	// proxy dereference 
	inline T* operator->() const
	{
		//ASSERT_NOT_NULL(m_pType);
		return m_pType;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\ThreadPool.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#pragma once


/////////////////////////////////////////////////////////////////////////////
// WorkerThreadPool - Generic thread pool class that can be used to
// distribute work across multiple worker threads.  Construct the object with
// the number of threads that you want and the static worker function that
// you have define. Your static worker function must conform to the
// LPTHREAD_SMART_ROUTINE function type.  Then call DoWork when ever you have
// work that needs to be processed.  As defined by the LPTHREAD_SMART_ROUTINE
// function type, the parameters you pass to your static worker function are
// of type LPVOID.  Since the parameters are of type LPVOID it is the
// responsiblity of this object to delete that data when finished.  So, make
// sure that the parameter you pass can be deleted via delete [] pData.  It
// is suggested that pData be a pointer to a class with an appriopriate
// destructor defined.  If a work function takes time be sure to check the
// hShutdownEvent or use it in combination with any WaitForObject processing.
/////////////////////////////////////////////////////////////////////////////


// Worker thread function type
typedef HRESULT (WINAPI *ThreadFuncPtr)( 
    void*,     // Thread Parameter
    HANDLE );  // hShutdownEvent


class WorkerThreadPool
{
public:
    
    // Ctor
    WorkerThreadPool(
        unsigned int  cThreads, 
        ThreadFuncPtr pWorkerFunc, 
        HANDLE        hShutdownEvent = NULL );
 
    ~WorkerThreadPool();
	
    // Perform work
	HRESULT DoWork( void* dwData );

    // Is class initialized
	bool IsInit() { return m_fInit; }

    // Obtain access to the shutdown event
	HANDLE GetShutdownEvent() { return m_hShutdown; }

private:

    enum enumEvents
    {   
        EVENTS_TRIGGER = 0,
        EVENTS_SHUTDOWN,
        EVENTS_FINISHED,
        EVENTS_ENDENUM
    };

    // Structure used to pass events and parameters to worker thread
	struct ThreadParam
    {
        ThreadFuncPtr pFunc;
        void*         pData;
        HANDLE        rgEvents[ EVENTS_ENDENUM ];
    };

private: 

    bool         m_fInit;             // Instance successfully initialized
	unsigned int m_cThreads;          // Number of worker threads
	HANDLE*      m_rghThreads;        // Array of worker threads
	ThreadParam* m_rgThreadParams;    // Array of thread parameters and events
	HANDLE*      m_rghFinishedEvents; // Duplicate finished event array for WaitForMultipleObjects
	HANDLE       m_hShutdown;         // Shutdown event
	bool         m_fOwnShutdownEvent; // Was the shutdown event passed in or do we own it?

private:

	// Internal worker thread function that wraps user's "ThreadFuncPtr" function
	static unsigned __stdcall WorkerThread( void* );
	
    // Initialization routine
	unsigned Init( 
        unsigned      cThreads, 
        ThreadFuncPtr pWorkerFunc, 
        HANDLE        hShutdownEvent );
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\TSafeQueue.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2002 Microsoft.  ALL RIGHTS RESERVED
/////////////////////////////////////////////////////////////////////////////
#pragma once

/////////////////////////////////////////////////
// Thread Safe Queue Template
//
//  Beware of contention for the single crit sec used by 
//  put and get. Also the handling of the event used to 
//  signal when the queue isn't empty is optimized for 
//  it rarely actually being empty.
//  
template< class T >
class TSafeQueue
{
public:

    ///////////////////////////////////
    // Ctor
    //
    explicit TSafeQueue( HANDLE hStopEvent )
    {
        InitializeCriticalSectionAndSpinCount( &m_CritSec, 4000 );

        m_hEvents[ Stop ] = hStopEvent;
        _ASSERTE( NULL != m_hEvents[ Stop ] );

        // Event to Wait on if Queue is empty - maunual reset, initially not set
        m_hEvents[ NotEmpty ] = CreateEvent( NULL, TRUE, FALSE, NULL ); 
        _ASSERTE( NULL != m_hEvents[ NotEmpty ] );
    }

    ///////////////////////////////////
    // Dtor
    //
    ~TSafeQueue()
    {   
        DeleteCriticalSection( &m_CritSec );
        CloseHandle( m_hEvents[ NotEmpty ] );
    }

    ///////////////////////////////////
    // Get
    //  Effectively blocks until an item can be be returned.  
    //  Return of NULL indicates operation was aborted by stop 
    //  event being set.
    //
    T* Get()
    {
        T* pFront = NULL;
        while( NULL == pFront )
        {
            // Wait for signal to stop or queue not empty
            DWORD dwRet = WaitForMultipleObjects( NumEvents, m_hEvents, FALSE, INFINITE );
            if( dwRet == WaitIndex( Stop ) )
            {
                // Stop Signal
                return( NULL );
            }

            // May have one
            _ASSERTE( dwRet == WaitIndex( NotEmpty ) );
            EnterCriticalSection( &m_CritSec );
            if( m_Queue.empty() )
            {
                // Nope, didn't beat the rush. Clear the event and wait again
                ResetEvent( m_hEvents[ NotEmpty ] );
            }
            else
            {
                pFront = m_Queue.front();
                m_Queue.pop_front();
            }
            LeaveCriticalSection( &m_CritSec );
        }
        return pFront;
    }

    ///////////////////////////////////
    // Put
    //  
    void Put( T* pT, bool bFront = false )
    {
        EnterCriticalSection( &m_CritSec );
        // Only signal not empty if it previously was
        if( m_Queue.empty() ) 
        {
            SetEvent( m_hEvents[ NotEmpty ] ); 
        }

        if( bFront )
            m_Queue.push_front( pT );
        else 
            m_Queue.push_back( pT );

        LeaveCriticalSection( &m_CritSec );
    }        

    ///////////////////////////////////
    // Remove
    //  Finds a particular item and removes it
    //
    bool Remove( T* pItem )
    {
        bool bRemoved = false;
        EnterCriticalSection( &m_CritSec );
        if( ! m_Queue.empty() )
        {
            for( Queue::iterator i = m_Queue.begin(); i != m_Queue.end(); ++i )
            {
                if( *i == pItem )
                {
                    m_Queue.erase( i );
                    bRemoved = true;
                    break;
                }
            }
        }
        LeaveCriticalSection( &m_CritSec );
        return bRemoved;
    }

    ///////////////////////////////////
    // IsEmpty & Count
    //  Non synchronized read only status checks. 
    //  Doesn't guarantee subsequent Get() won't block.
    //  
    bool IsEmpty()
    {
        EnterCriticalSection( &m_CritSec );
        bool bEmpty = m_Queue.empty();
        LeaveCriticalSection( &m_CritSec );
        return bEmpty; 
    }

    DWORD Count()
    {
        EnterCriticalSection( &m_CritSec );
        DWORD dwSize = m_Queue.size();
        LeaveCriticalSection( &m_CritSec );
        return dwSize; 
    }

    ///////////////////////////////////
    // Unsafe Get
    //  Non synchronized removal.  Should only be used
    //  when absolutely sure of exclusive access.
    //  Never blocks, returns NULL when Queue is empty.
    //  
    T* UnsafeGet()
    {
        T* pFront = NULL;
        if( ! m_Queue.empty() )
        {
            pFront = m_Queue.front();
            m_Queue.pop_front();
        }
        return pFront;
    }

private:

    typedef list<T*> Queue;
    Queue m_Queue;
    
    enum EEventIndex
    { 
        Stop = 0, 
        NotEmpty, 
        NumEvents 
    };
    HANDLE m_hEvents[ NumEvents ]; 
    DWORD  WaitIndex( EEventIndex eIndex ) { return( eIndex - WAIT_OBJECT_0 ); }

    CRITICAL_SECTION m_CritSec;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\THashTable.h ===
#pragma once

//------------------------------------------------------------------------------
// Template based hash table.
//
// Author: jacobr@microsoft.com
//------------------------------------------------------------------------------

const DWORD __HASHBINSIZES[] = {13,251,509,1021,2039,4094,9191,16381,32749,65521,131071};

template<typename _Tkey, typename _Thashfunc, typename _Tval>
class HashTable
{
protected:

	struct Item
	{
		Item *pNext;
		_Tkey key;
		_Tval value;
	};

	Item**  m_prgBins;
	DWORD   m_cBins;
	DWORD   m_cItems;

	Item *_LookupItem(DWORD &dwOutHash, const _Tkey &key) const
	{
		register Item *pItem;
		register Item *pNext;

		dwOutHash = _Thashfunc::CalculateHash(key, m_cBins);
		ASSERT_THROW(dwOutHash < m_cBins);

		for(pItem = m_prgBins[dwOutHash]; pItem; pItem = pNext)
		{
			pNext = pItem->pNext;
			if(_Thashfunc::Equal(key, pItem->key))
			{
				break;
			}
		}
		
		return pItem;	
	}

public:
	HashTable() :
		m_prgBins(0),
		m_cBins(0),
		m_cItems(0)
	{
	}
	~HashTable()
	{
		Release();	
	}

	DWORD BinCount()   const { return m_cBins; }
	DWORD ItemCount()  const { return m_cItems; }

	//------------------------------------------------------------------------------
	// Initialize the bins of the hashtable, cBins is rounded to closest prime 
	// number.
	//------------------------------------------------------------------------------
	HRESULT Create(DWORD cBins)
	{
		Release();

		int i;
		for (i = 0; i < sizeof(__HASHBINSIZES)/sizeof(DWORD); i++)
		{
			if (__HASHBINSIZES[i] >= cBins)
			{
				m_cBins = __HASHBINSIZES[i];
				break;
			}
		}

		if(sizeof(__HASHBINSIZES)/sizeof(DWORD) == i)
		{
			m_cBins = __HASHBINSIZES[i-1];
		}

		m_prgBins = new Item*[m_cBins];
		if(0 == m_prgBins)
		{
			return E_OUTOFMEMORY;
		}
		ZeroMemory(m_prgBins, sizeof(Item*) * m_cBins);

		return S_OK;
	}

	//------------------------------------------------------------------------------
	// Release any memory held by the hash table. 
	//------------------------------------------------------------------------------
	void Release()
	{
		if(m_prgBins)
		{
			delete []m_prgBins;
			m_prgBins   = 0;
			m_cBins     = 0;
			m_cItems    = 0;
		}
	}

	//------------------------------------------------------------------------------
	// Insert a new item in the hash, returns true when an item has been replaced, 
	// the old item if any is placed into outValue.
	//------------------------------------------------------------------------------
	bool Insert(const _Tkey &inKey, const _Tval &inValue, _Tval &outValue, bool bReplace = false)
	{
		DWORD dwHash;
		_Tval lastValue;

		Item *pItem = _LookupItem(dwHash, inKey);
		if(0 != pItem && bReplace)
		{
			outValue = pItem->value;
			pItem->value = inValue;
			return true;
		}
		else
		{
			pItem = new Item;

			// Add item to head of list, store key and value
			pItem->pNext = m_prgBins[dwHash];
			pItem->key   = inKey;
			pItem->value = inValue;
			m_prgBins[dwHash] = pItem;

			++m_cItems;

			return false;
		}
	}

	//------------------------------------------------------------------------------
	// Lookup returns true when the outValue has been returned for a hit on inKey
	//------------------------------------------------------------------------------
	bool Lookup(const _Tkey &inKey, _Tval &outValue) const
	{
		DWORD dwHash;
		Item *pItem = _LookupItem(dwHash, inKey);
		if(0 != pItem)
		{
			outValue = pItem->value;
			return true;
		}

		return false;
	}

	//------------------------------------------------------------------------------
	// Remove returns true when the an item matches inKey. The removed item is 
	// returned in outValue.
	//------------------------------------------------------------------------------
	bool Remove(const _Tkey &inKey, _Tval &outValue)
	{
		// We could do this directly in one pass but removes should not
		// be done that often anyways
		Item *pRemove = _LookupItem(dwHash, inKey);
		if(0 != pRemove)
		{
			outValue = pRemove->value;

			// Test the top of the bin first
			if(pRemove == m_rgBins[dwHash])
			{
				m_rgBins[dwHash] = m_rgBins[dwHash]->pNext;
			}
			else
			{
				Item *pItem;
				Item *pNext;
				for(pItem = m_rgBins[dwHash]; pItem; pItem = pNext)
				{
					pNext = pItem->pNext;
	
					if(pNext == pRemove)
					{
						pItem->pNext = pNext->pNext;
					}
				}

				delete pRemove;
			}

			--m_cItems;

			return true;
		}

		return false;
	}
};

//------------------------------------------------------------------------------
// Built-in hash functions
//------------------------------------------------------------------------------

struct DWORDHASHFUNC
{
	static bool Equal(DWORD dwKeyA, DWORD dwKeyB)
	{
		return dwKeyA == dwKeyB;
	}

	static DWORD CalculateHash(const DWORD &inKey, DWORD cBins)
	{
		return inKey % cBins;
	}
};

struct LPCSTRHASHFUNC
{
	static bool Equal(LPCSTR pszKeyA, LPCSTR pszKeyB)
	{
		register LPCSTR pA, pB;

		pA = pszKeyA;
		pB = pszKeyB;

		while(*pA && *pB && *pA++ == *pB++)
			;

		return (*pA == *pB);
	}

	// Sedgewick's effective string hash
	static DWORD CalculateHash(LPCSTR pszKey, DWORD cBins)
	{
		static const DWORD b = 27183;
		DWORD h, a = 31415;
		for (h = 0; *pszKey != '\0'; pszKey++, a = a*b % (cBins-1))
		{
			h = (a*h + *pszKey) % cBins;
		}

		return h;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\ThreadPool.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED
// Programmer: Sean Wohlgemuth (mailto:seanwo@microsoft.com)
/////////////////////////////////////////////////////////////////////////////

#include "PTNCore.h"   //Precompiled header

MGMT_DefineLoggingCategory(ThreadPool);

/////////////////////////////////////////////////////////////////////////////
// Constructor - Initializes member variables and call initialization
// procedure.
/////////////////////////////////////////////////////////////////////////////

WorkerThreadPool::WorkerThreadPool(
    unsigned      cThreads, 
    ThreadFuncPtr pWorkerFunc, 
    HANDLE        hShutdownEvent /* = NULL */ )
:
    m_fInit( false ),
    m_cThreads( 0 ),
    m_rghThreads( NULL ),
    m_rgThreadParams( NULL ),
    m_rghFinishedEvents( NULL ),
    m_hShutdown( hShutdownEvent )
{
	TRACE3(ThreadPool, L_NORMAL, "WorkerThreadPool: initializing %d threads. pWorkerFunc %x, hShutdownEvent: %x", 
			cThreads, pWorkerFunc, hShutdownEvent);
	Init( cThreads, pWorkerFunc, hShutdownEvent );
}

/////////////////////////////////////////////////////////////////////////////
// Destructor - signals shutdown event then waits on all threads finished
// events before closing all handles and freeing allocated memory for member
// variables.
/////////////////////////////////////////////////////////////////////////////

WorkerThreadPool::~WorkerThreadPool()
{
	// If we are not initialized, no need to cleanup
	if( !m_fInit )
    {
		return;
    }

	// Signal shutdown
	SetEvent( m_hShutdown );

	//Make sure that both events have been thrown, this signifies proper shutdown, not just being "finished"
	for (unsigned int i=0; i<m_cThreads; i++)
		if ((WAIT_TIMEOUT==WaitForSingleObject(m_rgThreadParams[i].rgEvents[EVENTS_FINISHED],1000))||
			(WAIT_TIMEOUT==WaitForSingleObject(m_rgThreadParams[i].rgEvents[EVENTS_TRIGGER],1000)))
			if (NULL!=m_rghThreads[i])
            {
                ERR0(ThreadPool, "Forcibly terminating a thread - This is VERY bad, is worker thread stupid?" );
                ASSERT_THROW( false );
				TerminateThread(m_rghThreads[i],-1);
            }

    // TBD - Add WFMO on thread handles

	//Close thread handles and free thread list
	if (NULL!=m_rghThreads){
		for (unsigned int i=0; i<m_cThreads; i++)
			CloseHandle(m_rghThreads[i]);
		delete [] m_rghThreads;
	}//endif

	//Close trigger and shutdown events, delete thread data and then free parameter structure list
	if (NULL!=m_rgThreadParams){
		for (unsigned int i=0; i<m_cThreads; i++){
			if (NULL!=m_rgThreadParams[i].rgEvents[EVENTS_TRIGGER])
				CloseHandle(m_rgThreadParams[i].rgEvents[EVENTS_TRIGGER]);
			if (NULL!=m_rgThreadParams[i].rgEvents[EVENTS_FINISHED])
				CloseHandle(m_rgThreadParams[i].rgEvents[EVENTS_FINISHED]);
//			if (NULL!=m_rgThreadParams[i].pData)
//				delete [] m_rgThreadParams[i].pData;
		}//endfor
		delete [] m_rgThreadParams;
	}//endif

	//Free finished events list, no need to close handles since that was done in the parameter structure list; this is a copy
	if (NULL!=m_rghFinishedEvents){
		delete [] m_rghFinishedEvents;
	}//endif

	//Close shutdown event
	if (true==m_fOwnShutdownEvent){
		CloseHandle(m_hShutdown);
	}//endif

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// Init - Store how many threads we have, create all events and event lists, 
// and start all threads.
/////////////////////////////////////////////////////////////////////////////

unsigned int WorkerThreadPool::Init(
    unsigned      cThreads, 
    ThreadFuncPtr pWorkerFunc, 
    HANDLE        hShutdownEvent )
{
	// Check parameters or whether we have been initialized before somehow
    ASSERT_THROW( !m_fInit )
    ASSERT_THROW( NULL != pWorkerFunc )
    ASSERT_THROW( 0 != cThreads )

	if( ( m_fInit ) || (NULL == pWorkerFunc) || (0 == cThreads) )
    {
		return m_cThreads; // return number of worker threads
    }

	// Create shutdown event if one is not provided.
    m_fOwnShutdownEvent = (NULL == m_hShutdown);
    if( m_fOwnShutdownEvent )
    {
		m_hShutdown = CreateEvent( NULL, TRUE, FALSE, NULL );
        ASSERT_THROW( NULL != m_hShutdown )
        if( NULL == m_hShutdown )
        {
            return m_cThreads;
        }
	}

    // Store number of threads
	m_cThreads = cThreads;

	// Allocate memory for lists
	m_rghThreads = new HANDLE[ m_cThreads ];
    ASSERT_THROW( NULL != m_rghThreads );
	
    m_rgThreadParams = new ThreadParam[ m_cThreads ];
	ASSERT_THROW( NULL != m_rgThreadParams );
    
    m_rghFinishedEvents = new HANDLE[ m_cThreads ];
    ASSERT_THROW( NULL != m_rghFinishedEvents );


	// Populate lists and start threads
	for( unsigned int i = 0; i < m_cThreads; i++ )
    {
        // Create Finished event for this thread (Auto reset, Initially signaled)
        HANDLE hFinishedEvent = CreateEvent( NULL, FALSE, TRUE, NULL );
        ASSERT_THROW( NULL != hFinishedEvent )

        // Create Trigger event for this thread (Manual reset, Initially non-sugnaled)
        HANDLE hTriggerEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        ASSERT_THROW( NULL != hTriggerEvent )

        m_rghFinishedEvents[i] = hFinishedEvent;

        m_rgThreadParams[i].rgEvents[ EVENTS_FINISHED ] = hFinishedEvent;
		m_rgThreadParams[i].rgEvents[ EVENTS_TRIGGER ]  = hTriggerEvent;
		m_rgThreadParams[i].rgEvents[ EVENTS_SHUTDOWN ] = m_hShutdown;
		m_rgThreadParams[i].pFunc                       = pWorkerFunc;
		m_rgThreadParams[i].pData                       = NULL;
    	
        unsigned uID = 0;
		m_rghThreads[i] = 
            (HANDLE)_beginthreadex( 
                NULL, 
                0, 
                &WorkerThread, 
                (void*)&m_rgThreadParams[i], 
                0, 
                &uID );
        if( 0 == m_rghThreads[i] )
        {
            // fail
        }
	}
	
	// We have successfully initialized	
	m_fInit = true;

	return m_cThreads; // Return number of threads
}

/////////////////////////////////////////////////////////////////////////////
// WorkerThread - The worker thread which wraps the user worker function.
/////////////////////////////////////////////////////////////////////////////

unsigned __stdcall WorkerThreadPool::WorkerThread(
     void* pParam )
{
	// If parameter pointer is NULL then shutdown
    ASSERT_THROW( pParam != NULL );
	if( NULL == pParam )
    {
        return( E_FAIL );
    }

	// Cast back the parameters
	HANDLE* rgEvents; 
	rgEvents = ((ThreadParam*)pParam)->rgEvents;

	DWORD dwReturn=0; //temp return value from worker function
	DWORD dwObject=0; //signaled object
	while (true){
		//Wait to be triggered or shutdown
		dwObject=WaitForMultipleObjects(2,&rgEvents[0],false,INFINITE);
		if (EVENTS_SHUTDOWN==(dwObject-WAIT_OBJECT_0))
			break;
		//Reset the trigger
		ResetEvent(rgEvents[EVENTS_TRIGGER]);
		//Do work
		dwReturn= ((ThreadParam*)pParam)->pFunc(((ThreadParam*)pParam)->pData,rgEvents[EVENTS_SHUTDOWN]);
		//Signal finished
		SetEvent(rgEvents[EVENTS_FINISHED]);
	}//endwhile

	//We are shutting down, trigger both events when done
	SetEvent(rgEvents[EVENTS_FINISHED]);
	SetEvent(rgEvents[EVENTS_TRIGGER]);

	ExitThread(S_OK);
	return S_OK;  //Success

}//endmethod

/////////////////////////////////////////////////////////////////////////////
// DoWork - Assign work to one of the available threads in the thread pool.
// This operation blocks until the task has been assigned to an available 
// thread.  If no thread is available, the task blocks until one is.
/////////////////////////////////////////////////////////////////////////////

HRESULT WorkerThreadPool::DoWork( void* pData )
{
	// Check if we have been initialized
    ASSERT_THROW( m_fInit );
	if( !m_fInit ) return E_FAIL;

	// Wait for any thread to become available
	DWORD dwRet =  WaitForMultipleObjects( m_cThreads, m_rghFinishedEvents, FALSE, INFINITE );
    if( (WAIT_OBJECT_0 < dwRet ) || (dwRet > (WAIT_OBJECT_0 + m_cThreads - 1)) )
    {
        ERR0(ThreadPool, "WorkerThreadPool::DoWork - Failed, thread looks available becuase it's dead" );
		return S_FALSE;
    }
	DWORD dwIndex = dwRet - WAIT_OBJECT_0;

	// Shutdown time
	if( WAIT_OBJECT_0 == WaitForSingleObject( m_hShutdown, 0 ) )
    {
        ERR0(ThreadPool, "WorkerThreadPool::DoWork - Failed, been signaled to shutdown" );
		return S_FALSE;
    }

	// Reset the finished event on this thread so we know when it is done
	ResetEvent(m_rghFinishedEvents[dwIndex]);

	//Delete previous data used by this thread
//	if (NULL!=m_rgThreadParams[dIndex].pData){
        // TBD: Come back and fix this.  Calling delete, let alone delete[], on a void* isn't going to cut it.  
        //      It's possible that a object with a virtual destructor might work, but what's a void* know of 
        //      vtables.  Sean is investigating, maybe RTTI makes this work but that's too expensive when there
        //      are alternatives such as the thread funcs stack, or using a base data class with a virtual
        //      destructor.
        //          
		// delete [] m_rgThreadParams[dIndex].pData;
		// m_rgThreadParams[dIndex].pData=NULL;
//	}//enidf

	//Assign new data for thread to process
	m_rgThreadParams[dwIndex].pData=pData;

	//Signal thread to start processing
	SetEvent(m_rgThreadParams[dwIndex].rgEvents[EVENTS_TRIGGER]);

	return S_OK;  //Success
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\Utility.cpp ===
#include "PtnCore.h"

ULONGLONG ParsePuid(const char *pszPuid)
{
	ULONGLONG qwPuid = 0;

	if(!pszPuid || !*pszPuid)
	{
		goto lbDone;
	}

	// Grab the user puid
	if(pszPuid[0] == '0' && tolower(pszPuid[1]) == 'x')
	{
		// Parse hex
		WORD wTmp;
		const char *pszHex = &(pszPuid[2]);
		while(*pszHex)
		{
			if(isdigit(*pszHex))
			{
				wTmp = *pszHex - '0';
			}
			else if(isalpha(*pszHex))
			{
				wTmp = 10 + (tolower(*pszHex) - 'a');
			}
			else
			{
				qwPuid = 0;
				break;
			}

			qwPuid <<= 4;
			qwPuid |= wTmp;
			pszHex++;
		}
	}
	else
	{
		// Convert decimal
		WORD wTmp;
		const char *pszDec = pszPuid;
		while(*pszDec)
		{
			if(isdigit(*pszDec))
			{
				wTmp = *pszDec - '0';
			}
			else
			{
				qwPuid = 0;
				break;
			}

			qwPuid *= 10;
			qwPuid += wTmp;
			pszDec++;
		}
	}

lbDone:
	return qwPuid;
}

DWORD ParseDWORD(const char *pszStart, DWORD dwLen)
{
	register const char *pc = pszStart;
	register const char *pe = pszStart + dwLen;
	register DWORD dwAccum = 0;
	register DWORD dwTmp;

	if(0 == pszStart || 0 == dwLen)
	{
		return 0;
	}

	// Convert decimal
	while(*pc && pc < pe)
	{
		if(isdigit(*pc))
		{
			dwTmp = *pc - '0';
		}
		else
		{
			break;
		}

		dwAccum *= 10;
		dwAccum += dwTmp;
		pc++;
	}

	return dwAccum;
}

DWORD ParseHexDWORD(const char *pszStart, DWORD dwLen)
{
	register const char *pc = pszStart;
	register const char *pe = pszStart + dwLen;
	register DWORD dwAccum = 0;
	register DWORD dwTmp;

	if(0 == pszStart || 0 == dwLen)
	{
		return 0;
	}

	while(*pc && pc < pe)
	{
		if(isdigit(*pc))
		{
			dwTmp = *pc - '0';
		}
		else if(isalpha(*pc))
		{
			dwTmp = 10 + (tolower(*pc) - 'a');
		}
		else
		{
			break;
		}

		dwAccum <<= 4;
		dwAccum |= dwTmp;
		pc++;
	}
	
	return dwAccum;
}

char *SearchString(char *pszSearch, DWORD cbSearch, const char *pszKey)
{
	register char *pszAt;
	register char *pszLast;
	register const char *pszFound;

	pszAt = pszSearch;
	pszLast = pszSearch + cbSearch;
	pszFound = pszKey;

	while(*pszAt && pszAt < pszLast && *pszFound)
	{
		if(*pszAt == *pszFound)
		{
			pszFound++;
		}
		else
		{
			pszFound = pszKey;
		}

		pszAt++;
	}

	// If we consumed all of the key then return the first character
	// in the search string that contained the key
	if('\0' == *pszFound)
	{
		return pszAt - (pszFound - pszKey);
	}
	else
	{
		return NULL;
	}
}

BOOL ParseTokens(char **ppCursor, DWORD *pnLength, char *pKeyStart, DWORD nKeySize, char *pValueStart, DWORD nValueSize)
{
	char *pCur = *ppCursor;
	const char *pEnd = pCur + *pnLength;
	char *pKeyEnd = pKeyStart + nKeySize;	
	char *pValueEnd = pValueStart + nKeySize;	

	// Allows convient loop behavior
	if(pCur == pEnd || !*pCur)
		return FALSE;

	*pKeyStart = *pValueStart = '\0';

	char *pKey = pKeyStart;
	while(pCur < pEnd && pKey < pKeyEnd)
	{
		if(*pCur == '=')
		{
			pCur++;
			break;
		}
		*pKey++ = *pCur++;
	}
	*pKey = '\0';

	char *pValue = pValueStart;
	while(pCur < pEnd && pValue < pValueEnd)
	{
		if(*pCur == ';')
		{
			pCur++;
			break;
		}
		*pValue++ = *pCur++;
	}
	*pValue = '\0';

	// Update the cursor and the length left based on 
	// what we have parsed out.
	*pnLength -= (pCur - *ppCursor);
	*ppCursor = pCur;

	return TRUE;
}

/// jacobr base64 encode, could be faster 

static CHAR rgEncodeTable[] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/' };

HRESULT Base64Encode(BYTE *pbSrc, DWORD cbSrc, BYTE *pbDst, DWORD cbDst) 
{
    HRESULT hr;
	DWORD iSrc, iDst;
	DWORD dwBits, iEncode;
	LONG lSrcShift, lDstShift;
    BYTE b;

    if(0 == pbSrc || 0 == cbSrc || 0 == pbDst || 0 == cbDst)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    lSrcShift = 16;
    dwBits = 0;

    iSrc = 0;
    iDst = 0;

    while(iSrc < cbSrc)
    {
        b = pbSrc[iSrc];

        // Accumlate 3 bytes
        dwBits |= b << lSrcShift; 
        if(iSrc == (cbSrc - 1) || lSrcShift == 0) 
        {
            // Got 3 bytes or at end of input 
            // scaled remainder offset
            lSrcShift = (lSrcShift >> 3) * 6; 

            // Encode 6 bits of dwBits at a time
            for(lDstShift = 18; lDstShift >= lSrcShift; lDstShift -= 6) 
            {
                iEncode = ((dwBits >> lDstShift) & 0x3f);

                if(cbDst == iDst)
                {
                    hr = E_FAIL;
                    goto lbDone;
                }

                pbDst[iDst++] = rgEncodeTable[iEncode];
            }

            // Add extra padding
            while(lDstShift >= 0) 
            {
                if(cbDst == iDst)
                {
                    hr = E_FAIL;
                    goto lbDone;
                }

                pbDst[iDst++] = '=';	 
                lDstShift -= 6;
            }

            dwBits = 0;
            lSrcShift = 16;
        } 
        else 
        {
            lSrcShift -= 8;
        }

        ++iSrc;
    } 

    pbDst[iDst] = '\0';

    hr = S_OK;

lbDone:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\Win32Event.h ===
#pragma once

//
// Wrapper for OS level event object handles and operations
// on that event.
//
class Win32Event
{
protected:
	HANDLE m_hEvent;
public:
	Win32Event();
	~Win32Event();

	// Create a new event object
	bool Create();
	bool Create(BOOL bManualReset, BOOL bInitialState);
	bool Create(BOOL bManualReset, BOOL bInitialState, LPCTSTR pszName);
	
	// Open an existing event object by name
	bool Create(LPCTSTR pszName);

	// Event operations
	bool Set();
	bool Reset();
	bool Destroy();

	DWORD Wait(DWORD dwMillis = 0);

	HANDLE GetHandle() const;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\Win32Event.cpp ===
#include "PTNCore.h"

Win32Event::Win32Event()
{
	m_hEvent = INVALID_HANDLE_VALUE;
}

Win32Event::~Win32Event()
{
	if(m_hEvent != INVALID_HANDLE_VALUE)
	{
		Destroy();
	}
}

// Create a new event object
bool Win32Event::Create()
{
	m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	return m_hEvent != INVALID_HANDLE_VALUE;
}

bool Win32Event::Create(BOOL bManualReset, BOOL bInitialState)
{
	m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	return m_hEvent != INVALID_HANDLE_VALUE;
}

bool Win32Event::Create(BOOL bManualReset, BOOL bInitialState, LPCTSTR pszName)
{
	m_hEvent = CreateEvent(NULL, FALSE, FALSE, pszName);
	return m_hEvent != INVALID_HANDLE_VALUE;
}

// Open an existing event object by name
bool Win32Event::Create(LPCTSTR pszName)
{
	 m_hEvent = CreateEvent(NULL, FALSE, FALSE, pszName);
	 return m_hEvent != INVALID_HANDLE_VALUE;
}


// Event operations
bool Win32Event::Set()
{
	return SetEvent(m_hEvent) == TRUE;
}

bool Win32Event::Reset()
{
	return ResetEvent(m_hEvent) == TRUE;
}

bool Win32Event::Destroy()
{
	return CloseHandle(m_hEvent) == TRUE;
}

DWORD Win32Event::Wait(DWORD dwMillis)
{
	DWORD dwResult = WaitForSingleObject(m_hEvent, dwMillis);
	return dwResult;
}


HANDLE Win32Event::GetHandle() const
{
	return m_hEvent;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\TThreadContainer.h ===
#pragma once

#define THREAD_NAME_LEN 31

// 
// Container describes all handles to a thread, it's symbolic name
// in the program and stores the class delegate that will run
// when the thread starts.
//
template <class T> 
class ThreadContainer
{
protected:
	typedef void (T::*ThreadStartMemberFn)(HANDLE);
	struct ThreadStartRec
	{
		T *pObject;
		ThreadStartMemberFn pThreadFunc;
		HANDLE hStopEvent;
	};

	DWORD m_dwStackSize;
	HANDLE m_hStopEvent;
	HANDLE m_hThread;
	DWORD m_dwThreadId;
	char m_szName[THREAD_NAME_LEN+1];
	bool m_bRunning;
	T *m_pObject;
	ThreadStartMemberFn m_pThreadFunc;

	static unsigned int __stdcall _ThreadStartProc(ThreadContainer<T> *pContainer)
	{
		T *pObject                      = pContainer->m_pObject;
		ThreadStartMemberFn pThreadFunc = pContainer->m_pThreadFunc;
		HANDLE hStopEvent               = pContainer->m_hStopEvent;

		// start the thread running
		(pObject->*pThreadFunc)(hStopEvent);

		return 0;
	}

public:
	ThreadContainer()
	{
		m_dwStackSize = 8192;
		m_hStopEvent = INVALID_HANDLE_VALUE;
		m_hThread = INVALID_HANDLE_VALUE;
		m_dwThreadId = -1;
		m_szName[0] = '\0';
		m_bRunning = false;
		m_pObject = 0;
		m_pThreadFunc = 0;
	}

	~ThreadContainer()
	{
		Stop(0);
		Destroy();
	}

	bool IsRunning() const
	{
		return m_bRunning;
	}

	HRESULT Create(const char *pszName, T *pObject, ThreadStartMemberFn pThreadFunc, DWORD dwStackSize = 8196)
	{
		HRESULT hr = S_OK;
		
		strncpy(m_szName, pszName, THREAD_NAME_LEN);
		m_dwStackSize = dwStackSize;
		m_pObject = pObject;
		m_pThreadFunc = pThreadFunc;

		// Create the thread stop event
		m_hStopEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL);
		if(INVALID_HANDLE_VALUE == m_hStopEvent)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto lbDone;
		}

		// Create the thread
		if(_beginthreadex(NULL, m_dwStackSize, (unsigned int (__stdcall*)(void *))_ThreadStartProc, this, CREATE_SUSPENDED, (unsigned int*)&m_dwThreadId) < 0)
		{
			hr = E_FAIL;
			goto lbDone;
		}

		// Open a handle to the thread
		m_hThread = ::OpenThread(THREAD_SUSPEND_RESUME, FALSE, m_dwThreadId);
		if(INVALID_HANDLE_VALUE == m_hThread)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto lbDone;
		}

lbDone:
		return hr;
	}

	HRESULT Destroy()
	{
		HRESULT hr = S_OK;

		// Signal thread stop
		if(!SetEvent(m_hStopEvent))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto lbDone;
		}

		// Unconditional wait 5 seconds for the thread to finish execution
		WaitForSingleObject(m_hThread, 5000);

		// Attempt to cleanup
		if(CloseHandle(m_hStopEvent))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto lbDone;
		}
		if(CloseHandle(m_hThread))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto lbDone;
		}
lbDone:
		return hr;
	}

	HRESULT Start()
	{
		HRESULT hr = S_OK;

		if(ResumeThread(m_hThread) < 0)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			m_bRunning = false;
		}
		else
		{
			m_bRunning = true;
		}

		return hr;
	}

	HRESULT Stop(DWORD dwWaitMillis = 5000)
	{
		HRESULT hr = S_OK;

		if(!SetEvent(m_hStopEvent))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}

		DWORD dwStatus = WaitForSingleObject(m_hThread, dwWaitMillis);
		switch(dwStatus)
		{
		case WAIT_FAILED:
			hr = HRESULT_FROM_WIN32(GetLastError());
			break;
		case WAIT_OBJECT_0:
		case WAIT_ABANDONED:
			m_bRunning = false;
			break;
		}

		return hr;
	}


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\ptncore\Utility.h ===
#pragma once

//
// Parse a PUID that is specified in 0x hex form
// or decimal.
//
ULONGLONG ParsePuid(const char *pszPuid);

//
// Parse a DWORD that is in decimal format given a finite
// ammount of parse buffer
//
DWORD ParseDWORD(const char *pszStart, DWORD dwLen);

//
// Parse a DWORD that is in hex format given a finite
// ammount of parse buffer
//
DWORD ParseHexDWORD(const char *pszStart, DWORD dwLen);

//
// Safer version of strstr
//
char *SearchString(char *pszSearch, DWORD cbSearch, const char *pszKey);

// 
// Parse tokenn from a string buffer iteratively
//
BOOL ParseTokens(char **ppCursor, DWORD *pnLength, char *pKeyStart, DWORD nKeySize, char *pValueStart, DWORD nValueSize);

//
// Base64 encode a buffer
//
HRESULT Base64Encode(BYTE *pbSrc, DWORD cbSrc, BYTE *pbDst, DWORD cbDst);

#ifndef WRAP_DWORD_CMP
#define WRAP_DWORD_CMP
__forceinline int WrapDWORDCompare(DWORD dwLeft, DWORD dwRight)
{
    DWORD dwDiffLR;
    DWORD dwDiffRL;

    if (dwLeft == dwRight)
    {
        return 0;
    }
    else
    {
        // Shorest distance will tell us which is likely later (within 20+ days)
        dwDiffLR = dwRight - dwLeft;
        dwDiffRL = dwLeft - dwRight;

        if (dwDiffLR < dwDiffRL)
        {
            // Right later
            return 1;
        }
        else
        {
            // Left later
            return -1;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\stress\StressUser.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using xonline.common.service;
using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;
using xonline.common.config;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.Notification;
//using live.protocol;

namespace PresenceTest
{
    public class StressUser : PNUser
	{
        private int fLocked = 0;
        private Random rand = new Random();
        private int blobId = 0;
        public enum UserQueueTypes
        {
            VOICE_BLOCKED,
            INCOMING_BUDDY_REQUEST,
            OUTGOING_BUDDY_REQUEST,
            FRIENDS,
            AFFILIATES
        }

        private Dictionary<ulong, StressUser> voiceBlockedUsers = new Dictionary<ulong, StressUser>();          // Users I have blocked
        private Dictionary<ulong, StressUser> incomingBuddyRequestUsers = new Dictionary<ulong, StressUser>();  // Users that have requested to be friends with me
        private Dictionary<ulong, StressUser> outgoingBuddyRequestUsers = new Dictionary<ulong, StressUser>();  // Users that I have requested to be friends with
        private Dictionary<ulong, StressUser> friends = new Dictionary<ulong, StressUser>();                    // Users I am accepted friends with
        private Dictionary<ulong, StressUser> affiliates = new Dictionary<ulong, StressUser>();                    // Users I am Affiliate with

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="puidName"></param>
		public StressUser( PuidName puidName ) : base(puidName)
		{
        }

        /// <summary>
        /// Attempts to aquire the lock
        /// </summary>
        public bool Aquire()
        {
            return Interlocked.Exchange(ref fLocked, 1) == 0;
        }

        /// <summary>
        /// Releases the lock
        /// </summary>
        public void Release()
        {
            Interlocked.Exchange(ref fLocked, 0);
        }

        /// <summary>
        /// Gets a user from the requested queue. If a user it found, it will be locked. If not user is found, null is returned.
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public StressUser GetUser(UserQueueTypes type)
        {
            Dictionary<ulong, StressUser> d = GetUserDictionary(type);

            StressUser su = null;

            if (d.Count > 0)
            {
                Dictionary<ulong, StressUser>.Enumerator e = d.GetEnumerator();

                // Loop until we find an unlocked user or we hit the end of the list
                while (e.MoveNext())
                {
                    su = e.Current.Value;
                    
                    // Attempt to get a lock on the user
                    if (su.Aquire())
                    {
                        d.Remove(su.UserId);
                        break;
                    }
                }
            }

            return su;
        }

        public bool UserExists(UserQueueTypes type, StressUser user)
        {
            Dictionary<ulong, StressUser> d = GetUserDictionary(type);

            try
            {
                StressUser u = d[user.UserId];
            }
            catch (KeyNotFoundException)
            {
                return false;
            }
            return true;
        }

        /// <summary>
        /// Gets the count for the given queue type.
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public int GetUserCount(UserQueueTypes type)
        {
            Dictionary<ulong, StressUser> d = GetUserDictionary(type);

            return d.Count;
        }

        /// <summary>
        /// Removes the user from the given queue.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="user"></param>
        public void RemoveUser(UserQueueTypes type, StressUser user)
        {
            Dictionary<ulong, StressUser> d = GetUserDictionary(type);

            d.Remove(user.UserId);
        }

        /// <summary>
        /// Adds the user to the given queue.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="user"></param>
        public void AddUser(UserQueueTypes type, StressUser user)
        {
            Dictionary<ulong, StressUser> d = GetUserDictionary(type);

            d.Add(user.UserId, user);
        }

        private Dictionary<ulong, StressUser> GetUserDictionary(UserQueueTypes type)
        {
            switch (type)
            {
                case UserQueueTypes.VOICE_BLOCKED:
                    return voiceBlockedUsers;
                case UserQueueTypes.INCOMING_BUDDY_REQUEST:
                    return incomingBuddyRequestUsers;
                case UserQueueTypes.OUTGOING_BUDDY_REQUEST:
                    return outgoingBuddyRequestUsers;
                case UserQueueTypes.FRIENDS:
                    return friends;
                default:
                    Assert.IsTrue(false, "Attempting to get user dictionary from invalid type");
                    return null;
            }
        }

        /// <summary>
        /// Sends the alive message
        /// </summary>
        public void AliveMsg()
        {
            if (this.Xbox == null)
            {
                this.Xbox = new PNXbox(FriendsCommon.DefaultXenonTitleId);
            }

            ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.AddUser(this.Xbox.XboxId, this.UserId, this.UserFlags);
            PNMsg replyMsg;
            PMsgAlive2 aliveMsg = new PMsgAlive2(this);
            aliveMsg.TransactFD(out replyMsg);

            PAliveReplyMsgData reply = (PAliveReplyMsgData)replyMsg.Data;
            if (reply.HR != HResult.S_OK && reply.HR != HResult.XONLINE_S_LOGON_USER_HAS_MESSAGE)
            {
                Global.RO.Error("Alive message return HR:" + reply.HR);
                throw new Exception("Alive failed."); 
            }
            //Default state after alive. 
            this.State = XonPresNoti.P_STATE_MASK_ONLINE;
            //CAREFUL: This will also trigger state2.
            this.SetTitleData();
        }

        public void WebAliveMsg()
        {
            HResult hr = HResult.S_OK;
            XRLObject2 xrlo = null;

            // web alive before webfriends
            xonline.common.protocol.WebAliveRequest reqWebAlive = new xonline.common.protocol.WebAliveRequest();
            reqWebAlive.puid = this.UserId;
            xonline.common.protocol.WebAliveResponse replyWebAlive = new xonline.common.protocol.WebAliveResponse();
            xrlo = replyWebAlive;
            XRLUtil.PostXrlRequest(VirtualInterface.xpnfd_presence_int, reqWebAlive.GetXRL(), null, reqWebAlive, ref xrlo);
        }
        public void DeadUserMsg()
        {
            //this.Xbox.RemoveUser(this.UserId);
            ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.RemoveUser(this.Xbox.XboxId, this.UserId);

            PNMsg replyMsg;
            PNMsgDeadUser deadUserMsg = new PNMsgDeadUser(this);
            deadUserMsg.TransactFD(out replyMsg);

            //PNDeadUserMsgData reply = (PNDeadUserMsgData)replyMsg.Data;
            //this.Disconnect();
            //this.Xbox.ConnectionServerConnection.Disconnect();
            //this.Xbox.DisconnectFromFakeSG();
            this.State = XonPresNoti.P_STATE_MASK_NONE;
        }

        public void DeadXboxMsg()
        {
            this.State = XonPresNoti.P_STATE_MASK_NONE;
            this.Xbox.DeadXbox();
            this.Xbox = null;
        }

        public void InvalidateMsg()
        {
            this.Invalidate();
        }

        public void GetPresenceInfoMsg(StressUser target)
        {
            this.GetPresenceInfo(target);

            //PNMsg replyMsg;
            //PMsgGetPresenceInfo getPresenceInfoMsg = new PMsgGetPresenceInfo(this, target);
            //getPresenceInfoMsg.TransactFD(out replyMsg);
        }

        public void LogonCheckMsg()
        {
            PNMsg replyMsg;
            PMsgLogonCheck logonCheckMsg = new PMsgLogonCheck(this, this.Xbox.XboxId); // TODO: Should I use my own? Random? Another users?
            logonCheckMsg.TransactFD(out replyMsg);

            //PLogonCheckMsgData reply = (PLogonCheckMsgData)replyMsg.Data;

            // TODO: VERIFICATION?
        }

        public void StateMsg()
        {
            uint dwState = GenerateRandomOnlineState();
            //ulong matchId = (ulong)new Random().Next();
            AssignRandomRichPresence();
            this.SetTitleData(dwState);
        }

        private void AssignRandomRichPresence()
        {
            uint titleid = Pong.TitleId;
            this.Xbox.ChangeTitle(titleid, 0, 0);

            GIBlob gi = new GIBlob();
            gi.TitlePresence = 0;
            gi.AddContext((uint)Pong.Context.GameMode, (uint)Pong.GameMode.SinglePlayer);
            gi.AddContext((uint)Pong.Context.GameSize, (uint)Pong.GameSize.Medium);
            if (blobId == 0)
            {
                gi.AddContext((uint)Pong.Context.GameSpeed, (uint)Pong.GameSpeed.Fast);
                blobId = 1;
            }
            else
            {
                gi.AddContext((uint)Pong.Context.GameSpeed, (uint)Pong.GameSpeed.Slow);
                blobId = 0;
            }
            this.GIBlob = gi;
        }

        private uint GenerateRandomOnlineState()
        {
            uint dwState = XonPresNoti.P_STATE_MASK_ONLINE;
            int i = GetRandomInt(0, 5);
            switch (i)
            {
                case 0:
                    break;
                case 1:
                    dwState |= XonPresNoti.P_STATE_MASK_PLAYING;
                    break;
                case 2:
                    dwState |= XonPresNoti.P_STATE_MASK_VOICE;
                    break;
                case 3:
                    dwState |= XonPresNoti.P_STATE_MASK_PARTY_JOINABLE;
                    break;
                case 4:
                    dwState |= XonPresNoti.P_STATE_MASK_PARTY_JOINABLE;
                        break;
            }
            return dwState;
        }
        private int GetRandomInt(int min, int max)
        {
            return rand.Next(min,max);
        }
        public void Dequeue(ushort qType)
        {
            QMsgDequeue dequeueMsg = new QMsgDequeue(this, qType);
            PNMsg replyMsg;
            dequeueMsg.TransactFD(out replyMsg);

            QDequeueReplyMsgData reply = null;
            reply = (QDequeueReplyMsgData)replyMsg.Data;
            //validate
        }

        public void FindUser(ulong userId, string gamertag)
        {
            PNMsg replyMsg;
            PMsgFindUser findUserMsg = new PMsgFindUser(this, userId, gamertag);
            findUserMsg.TransactFD(out replyMsg);

            PFindUserReplyMsgData reply = (PFindUserReplyMsgData)replyMsg.Data;

            // TODO: VERIFICATION?
        }

        public void FindUsers(ulong[] userIds, string[] gamertags)
        {
            PNMsg replyMsg;
            PMsgFindUsers findUsersMsg = new PMsgFindUsers(this, userIds, gamertags);
            findUsersMsg.TransactFD(out replyMsg);

            PFindUsersReplyMsgData reply = (PFindUsersReplyMsgData)replyMsg.Data;

            // TODO: VERIFICATION?
        }

        public void AddBuddyMsg(StressUser buddy)
        {
            this.AddBuddyMsg(buddy, false);
        }

        public void AddBuddyMsg(StressUser buddy, bool byName)
        {
            PNMsg replyMsg;
            PMsgAddBuddy addBuddyMsg = new PMsgAddBuddy(this, buddy, byName);
            addBuddyMsg.TransactFD(out replyMsg);
        }

        public void AcceptBuddyMsg(StressUser buddy)
        {
            PNMsg replyMsg;
            PMsgAcceptBuddy acceptBuddyMsg = new PMsgAcceptBuddy(this, buddy);
            acceptBuddyMsg.TransactFD(out replyMsg);

            PAcceptBuddyMsgData reply = (PAcceptBuddyMsgData)replyMsg.Data;

            // TODO: VERIFICATION?
        }

        public void RejectBuddyMsg(StressUser buddy)
        {
            RejectBuddyMsg(buddy, false);
        }

        public void RejectBuddyMsg(StressUser buddy,  bool bNever)
        {
            PNMsg replyMsg;
            PMsgRejectBuddy rejectBuddyMsg = new PMsgRejectBuddy(this, buddy, bNever); // False for never
            rejectBuddyMsg.TransactFD(out replyMsg);

            PRejectBuddyMsgData reply = (PRejectBuddyMsgData)replyMsg.Data;

            // TODO: VERIFICATION?
        }

        public void DeleteBuddyMsg(StressUser buddy)
        {
            PNMsg replyMsg;
            PMsgDeleteBuddy deleteBuddyMsg = new PMsgDeleteBuddy(this, buddy);
            deleteBuddyMsg.TransactFD(out replyMsg);

            PDeleteBuddyMsgData reply = (PDeleteBuddyMsgData)replyMsg.Data;
            
            // TODO: VERIFICATION?
        }

        public void GetFriendsListMsg(StressUser target)
        {
            PGetFriendsListReplyMsgData reply = this.GetFriendsList(target);
        }

        public void GetWebFriendsMsg()
        {
            PWebFriendReplyMsgData reply = this.GetWebFriends();
        }

        public void BlockVoiceMsg(StressUser naughty)
        {
            PNMsg replyMsg;
            PMsgBlockVoice blockVoiceMsg = new PMsgBlockVoice(this, naughty);
            blockVoiceMsg.TransactFD(out replyMsg);

            PBlockVoiceMsgData reply = (PBlockVoiceMsgData)replyMsg.Data;

            // TODO: VERIFICATION?
        }

        public void UnblockVoiceMsg(StressUser notNaughty)
        {
            PNMsg replyMsg;
            PMsgUnblockVoice unblockVoiceMsg = new PMsgUnblockVoice(this, notNaughty);
            unblockVoiceMsg.TransactFD(out replyMsg);

            PNUnblockVoiceMsgData reply = (PNUnblockVoiceMsgData)replyMsg.Data;

            // TODO: VERIFICATION?
        }
        public void UnblockAllVoiceMsg()
        {
            PNMsg replyMsg;
            PMsgUnblockVoice unblockVoiceMsg = new PMsgUnblockVoice(this);
            unblockVoiceMsg.TransactFD(out replyMsg);

            //PNUnblockVoiceMsgData reply = (PNUnblockVoiceMsgData)replyMsg.Data;
        }

        public void AddAffiliate(StressUser affiliateUser, uint affiliateFlags)
        {
            PNUser[] list = new PNUser[1] {affiliateUser};
            PMsgAddAffiliates req = new PMsgAddAffiliates(this,affiliateFlags , this.Xbox.TitleId,  list);
            PNMsg replyMsg;
            req.TransactFD(out replyMsg);
            
            //PAddAffiliatesMsgData reply = (PAddAffiliatesMsgData)replyMsg.Data;
        }

        public void IsAffiliate(PNUser affiliate)
        {
            PMsgIsAffiliate request = new PMsgIsAffiliate(this, affiliate);
			PNMsg replyMsg;
            request.TransactFD(out replyMsg);

            //PIsAffiliateReplyMsgData reply = (PIsAffiliateReplyMsgData)replyMsg.Data;
        }

        public void QueryAffliates(uint affiliateFlags)
        {
            uint limit = 20;
            //Can't send the limit
            if (affiliateFlags == (uint)AffiliateFlags.Any)
                limit = 0;
            PMsgQueryAffiliates req = new PMsgQueryAffiliates(this, limit, affiliateFlags, 0);
            PNMsg replyMsg;
            req.TransactFD(out replyMsg);
          
            //PQueryAffiliatesReplyMsgData reply = (PQueryAffiliatesReplyMsgData)replyMsg.Data;
        }

        public void CanSendMessage(PNUser[] recipients)
        {
            ulong[] xuids = new ulong[recipients.Length];
            int i = 0;
            foreach (PNUser u in recipients)
            {
                xuids[i] = u.UserId;
                i++;
            }
            this.CanSendMessageToUsers((ushort)recipients.Length, xuids);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\stress\PresenceStress.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using ServerTestFramework;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.diagnostics;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace PresenceTest
{
    // Functional test tests for testing stress tests
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3), AsyncGroup(1, 0), AsyncThreadCount(2), Ignore("We dont run this ever in automated fashion. This is just to verify stress methods.")]
    public class PresenceStressFunctionalTests : TestNode
    {
        [TestCase]
        class TEST : TestBase
        {
            override protected void Execute()
            {
                StressUserList stressUserList = new StressUserList();

                // TODO: RESET STRESSUSERLIST CONSTRUCTOR TO LOAD REAL REALS
                StressUserList.Initialize();
                for (int i = 0; i < 25; ++i)
                {
                    Alive();
                }

                State();
                State();
                State();
                //Alive();
                //Alive();
                //AddBuddy();
                //AcceptBuddyRequest();
                //RejectBuddyRequest();
                //DeleteBuddy();
                //CancelBuddyInvite();
                //DeleteReceivedBuddy();
                //GetFriendsList();
                //GetWebFriends();
                //BlockVoice();
                //UnblockVoice();

                //FindUserByGamertag();
                //FindUserById();
                //FindUsers();
            }

            // ***NOTE THESE ARE JUST COPIED FROM BELOW FOR FUNCTIONAL TESTING
            #region TEST Presence APIs
            void Alive()
            {
                StressUser user = null;
                try
                {
                    user = StressUserList.GetOfflineUser(true);

                    if (user != null)
                    {
                        user.AliveMsg();

                        StressUserList.AddOnline(user);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Warn("Not enough offline users.");
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("Alive exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        user.Release();
                    }
                }
            }

            void DeadUser()
            {
                StressUser user = null;
                try
                {
                    user = StressUserList.GetOnlineUser(true);

                    if (user != null)
                    {
                        user.DeadUserMsg();

                        StressUserList.AddOffline(user);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Warn("Not enough online users.");
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("DeadUser exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        user.Release();
                    }
                }
            }

            void DeadXbox()
            {
                StressUser user = null;
                try
                {
                    user = StressUserList.GetOnlineUser(true);

                    if (user != null)
                    {
                        user.DeadXboxMsg();

                        StressUserList.AddOffline(user);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Warn("Not enough online users.");
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("DeadXbox exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        user.Release();
                    }
                }
            }

            void InvalidateUser() // Not verified on server
            {
                StressUser user = null;
                try
                {
                    user = StressUserList.GetOnlineUser(true);

                    if (user != null)
                    {
                        user.InvalidateMsg();

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("InvalidateUser exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        StressUserList.AddOnline(user);
                        user.Release();
                    }
                }
            }

            void GetPresenceInfo()
            {
                StressUser[] users = null;
                try
                {
                    users = StressUserList.GetOnlineUser(2, true);

                    if (users != null)
                    {
                        users[0].GetPresenceInfoMsg(users[1]);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("GetPresenceInfo exception caught:\n" + e.Message);
                }
                finally
                {
                    if (users != null)
                    {
                        StressUserList.AddOnline(users[0]);
                        StressUserList.AddOnline(users[1]);
                        users[0].Release();
                        users[1].Release();
                    }
                }
            }

            void LogonCheck() // Not verified on server
            {
                StressUser user = null;
                try
                {
                    user = StressUserList.GetOnlineUser(true);

                    if (user != null)
                    {
                        user.LogonCheckMsg();

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("LogonCheck exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        StressUserList.AddOnline(user);
                        user.Release();
                    }
                }
            }

            void State()
            {
                StressUser user = null;
                try
                {
                    user = StressUserList.GetOnlineUser(true);

                    if (user != null)
                    {
                        user.StateMsg(); // TODO: Do I need to change anything or just send it with default everything????????????

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Warn("Not enough online users.");
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("State exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        StressUserList.AddOnline(user);
                        user.Release();
                    }
                }
            }

            void FindUserById()
            {
                StressUser[] users = null;
                try
                {
                    users = StressUserList.GetOnlineUser(2, true);

                    if (users != null)
                    {
                        users[0].FindUser(users[1].UserId, "");

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("FindUserById exception caught:\n" + e.Message);
                }
                finally
                {
                    if (users != null)
                    {
                        StressUserList.AddOnline(users[0]);
                        StressUserList.AddOnline(users[1]);
                        users[0].Release();
                        users[1].Release();
                    }
                }
            }
            
            void FindUserByGamertag()
            {
                StressUser[] users = null;
                try
                {
                    users = StressUserList.GetOnlineUser(2, true);

                    if (users != null)
                    {
                        users[0].FindUser(0, users[1].Name);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("FindUserByGamertag exception caught:\n" + e.Message);
                }
                finally
                {
                    if (users != null)
                    {
                        StressUserList.AddOnline(users[0]);
                        StressUserList.AddOnline(users[1]);
                        users[0].Release();
                        users[1].Release();
                    }
                }
            }
            
            void FindUsers()
            {
                StressUser[] users = null;
                try
                {
                    users = StressUserList.GetOnlineUser(21, true);

                    if (users != null)
                    {
                        ulong[] userIds = new ulong[10];
                        string[] gamertags = new string[10];

                        for (int i = 0; i < 10; ++i)
                        {
                            userIds[i] = users[i + 1].UserId;
                            gamertags[i] = users[i + 10 + 1].Name;
                        }

                        users[0].FindUsers(userIds, gamertags);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("FindUsers exception caught:\n" + e.Message);
                }
                finally
                {
                    if (users != null)
                    {
                        for (int i = 0; i < users.Length; ++i)
                        {
                            StressUserList.AddOnline(users[i]);
                            users[i].Release();
                        }
                    }
                }
            }

            void CanSendMessage()
            {
                StressUser user = null;
                StressUser[] recipients = null;
                try
                {
                    user = StressUserList.GetOnlineUser(true);
                    recipients = StressUserList.GetOnlineUser(2, false);

                    if (user != null && user.LoggedOn)
                    {
                        user.CanSendMessage(recipients);
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("CanSendMessage exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        user.Release();
                    }
                }
            }
            #endregion

            #region TEST Friends APIs
            void AddBuddy()
            {
                StressUser[] users = null;
                try
                {
                    users = StressUserList.GetOnlineUser(2, true);

                    if (users != null)
                    {
                        users[0].AddBuddyMsg(users[1]);

                        users[0].AddUser(StressUser.UserQueueTypes.OUTGOING_BUDDY_REQUEST, users[1]);
                        users[1].AddUser(StressUser.UserQueueTypes.INCOMING_BUDDY_REQUEST, users[0]);

                        StressUserList.AddBuddyRequestor(users[0]);
                        StressUserList.AddBuddyRequested(users[1]);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("AddBuddy exception caught:\n" + e.Message);
                }
                finally
                {
                    if (users != null)
                    {
                        StressUserList.AddOnline(users[0]);
                        StressUserList.AddOnline(users[1]);
                        users[0].Release();
                        users[1].Release();
                    }
                }
            }

            void AcceptBuddyRequest()
            {
                StressUser user = null;
                StressUser requestorUser = null;
                try
                {
                    user = StressUserList.GetBuddyRequestedUser(true);

                    if (user != null)
                    {
                        requestorUser = user.GetUser(StressUser.UserQueueTypes.INCOMING_BUDDY_REQUEST);

                        // This could happen if the requestor deleted the requested friend (user)
                        if (requestorUser != null)
                        {
                            user.AcceptBuddyMsg(requestorUser);

                            // Record our friends-ness locally
                            user.AddUser(StressUser.UserQueueTypes.FRIENDS, requestorUser);
                            requestorUser.AddUser(StressUser.UserQueueTypes.FRIENDS, user);

                            // Remove user from the requestor's outgoingBuddyRequest queue
                            requestorUser.RemoveUser(StressUser.UserQueueTypes.OUTGOING_BUDDY_REQUEST, user);

                            //////// NOTE: This leaves the requestor in the outgoing queue still. To change?

                            // Add one of the friends to the accepted friend list
                            //////////////// TODO: Should both be added? Currently that list is only used to remove buddies, which only needs to be done once per pair
                            StressUserList.AddBuddyAccepted(user);

                            ResultCode = TEST_RESULTS.PASSED;
                        }
                        else
                        {
                            ResultCode = TEST_RESULTS.NOT_EXECUTED;
                        }
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("AcceptBuddy exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        user.Release();
                    }
                    if (requestorUser != null)
                    {
                        requestorUser.Release();
                    }
                }
            }

            void RejectBuddyRequest()
            {
                StressUser user = null;
                StressUser requestorUser = null;
                try
                {
                    user = StressUserList.GetBuddyRequestedUser(true);

                    if (user != null)
                    {
                        requestorUser = user.GetUser(StressUser.UserQueueTypes.INCOMING_BUDDY_REQUEST);

                        // This could happen if the requestor deleted the requested friend (user)
                        if (requestorUser != null)
                        {
                            user.RejectBuddyMsg(requestorUser);

                            //////// NOTE: This leaves the requestor in the outgoing queue still. To change?

                            // Remove reference 
                            requestorUser.RemoveUser(StressUser.UserQueueTypes.OUTGOING_BUDDY_REQUEST, user);

                            ResultCode = TEST_RESULTS.PASSED;
                        }
                        else
                        {
                            ResultCode = TEST_RESULTS.NOT_EXECUTED;
                        }
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("RejectBuddy exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        user.Release();
                    }
                    if (requestorUser != null)
                    {
                        requestorUser.Release();
                    }
                }
            }

            void DeleteBuddy()
            {
                StressUser user = null;
                StressUser buddyUser = null;
                try
                {
                    user = StressUserList.GetBuddyAcceptedUser(true);

                    if (user != null)
                    {
                        buddyUser = user.GetUser(StressUser.UserQueueTypes.FRIENDS);

                        if (buddyUser != null)
                        {
                            user.DeleteBuddyMsg(buddyUser);

                            // Remove from friends list on other user
                            buddyUser.RemoveUser(StressUser.UserQueueTypes.FRIENDS, user);

                            ResultCode = TEST_RESULTS.PASSED;
                        }
                        else
                        {
                            ResultCode = TEST_RESULTS.NOT_EXECUTED;
                        }
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("DeleteBuddy exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        user.Release();
                    }
                    if (buddyUser != null)
                    {
                        buddyUser.Release();
                    }
                }
            }

            void CancelBuddyInvite()
            {
                StressUser user = null;
                StressUser pendingUser = null;
                try
                {
                    user = StressUserList.GetBuddyRequestorUser(true);

                    if (user != null)
                    {
                        pendingUser = user.GetUser(StressUser.UserQueueTypes.OUTGOING_BUDDY_REQUEST);

                        if (pendingUser != null)
                        {
                            user.DeleteBuddyMsg(pendingUser);

                            // Remove from friends list on other user
                            pendingUser.RemoveUser(StressUser.UserQueueTypes.INCOMING_BUDDY_REQUEST, user);

                            ResultCode = TEST_RESULTS.PASSED;
                        }
                        else
                        {
                            ResultCode = TEST_RESULTS.NOT_EXECUTED;
                        }
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("CancelBuddyInvite exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        user.Release();
                    }
                    if (pendingUser != null)
                    {
                        pendingUser.Release();
                    }
                }
            }

            void DeleteReceivedBuddy()
            {
                StressUser user = null;
                StressUser pendingUser = null;
                try
                {
                    user = StressUserList.GetBuddyRequestedUser(true);

                    if (user != null)
                    {
                        pendingUser = user.GetUser(StressUser.UserQueueTypes.INCOMING_BUDDY_REQUEST);

                        if (pendingUser != null)
                        {
                            user.DeleteBuddyMsg(pendingUser);

                            // Remove from friends list on other user
                            pendingUser.RemoveUser(StressUser.UserQueueTypes.OUTGOING_BUDDY_REQUEST, user);

                            ResultCode = TEST_RESULTS.PASSED;
                        }
                        else
                        {
                            ResultCode = TEST_RESULTS.NOT_EXECUTED;
                        }
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("DeleteReceivedBuddy exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        user.Release();
                    }
                    if (pendingUser != null)
                    {
                        pendingUser.Release();
                    }
                }
            }

            void GetFriendsList()
            {
                StressUser[] users = null;
                try
                {
                    users = StressUserList.GetOnlineUser(2, true);

                    if (users != null)
                    {
                        users[0].GetFriendsListMsg(users[1]);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("GetFriendsList exception caught:\n" + e.Message);
                }
                finally
                {
                    if (users != null)
                    {
                        StressUserList.AddOnline(users[0]);
                        StressUserList.AddOnline(users[1]);
                        users[0].Release();
                        users[1].Release();
                    }
                }
            }

            void GetWebFriends()
            {
                StressUser user = null;
                try
                {
                    user = StressUserList.GetOnlineUser(true);

                    if (user != null)
                    {
                        user.GetWebFriendsMsg();

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("GetWebFriends exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        StressUserList.AddOnline(user);
                        user.Release();
                    }
                }
            }

            void BlockVoice()
            {
                StressUser[] users = null;
                try
                {
                    users = StressUserList.GetOnlineUser(2, true);

                    if (users != null)
                    {
                        users[0].BlockVoiceMsg(users[1]);

                        // Add a reference of the blocked user to user[0] so they can be unblocked later
                        users[0].AddUser(StressUser.UserQueueTypes.VOICE_BLOCKED, users[1]);

                        StressUserList.AddBlocked(users[0]);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("BlockVoice exception caught:\n" + e.Message);
                }
                finally
                {
                    if (users != null)
                    {
                        StressUserList.AddOnline(users[0]);
                        StressUserList.AddOnline(users[1]);
                        users[0].Release();
                        users[1].Release();
                    }
                }
            }

            void UnblockVoice()
            {
                StressUser user = null;
                StressUser blockedUser = null;
                try
                {
                    user = StressUserList.GetBlockedUser(true);

                    if (user != null)
                    {
                        // blockedUser will be locked
                        blockedUser = user.GetUser(StressUser.UserQueueTypes.VOICE_BLOCKED);

                        if (blockedUser != null)
                        {
                            user.UnblockVoiceMsg(blockedUser);

                            // User should already be in online so no need to worry about returning him there
                            //if (user.GetUserCount(StressUser.UserQueueTypes.VOICE_BLOCKED) != 0)
                            //    StressUserList.AddBlocked(user);

                            ResultCode = TEST_RESULTS.PASSED;
                        }
                        else
                        {
                            ResultCode = TEST_RESULTS.NOT_EXECUTED;
                        }
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("UnblockVoice exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        user.Release();
                    }
                    if (blockedUser != null)
                    {
                        blockedUser.Release();
                    }
                }
            }
            void UnblockAllVoice()
            {
                StressUser user = null;
                List<StressUser> blockedUsers = null;
                try
                {
                    user = StressUserList.GetBlockedUser(true);
                  
                    if (user != null)
                    {
                        // blockedUser will be locked
                        bool bAvailable = true;
                        while (bAvailable)
                        {
                            StressUser u = user.GetUser(StressUser.UserQueueTypes.VOICE_BLOCKED);
                            if (u == null)
                            {
                                bAvailable = false;
                            }
                            else
                            {
                                blockedUsers.Add(u);
                            }
                        }

                        user.UnblockAllVoiceMsg();
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("UnblockAllVoice exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        user.Release();
                    }
                    if (blockedUsers.Count > 0)
                    {
                        foreach (StressUser u in blockedUsers)
                            u.Release();
                    }
                }
            }

            void AddAffiliatesP()
            {
                StressUser user = null;
                StressUser affiliate = null;
                try
                {
                    user = StressUserList.GetOnlineUser(true);

                    if (user != null)
                    {
                        affiliate = StressUserList.GetOnlineUser(false);

                        if (affiliate != null)
                        {
                            user.AddAffiliate(affiliate, (uint)AffiliateFlags.PositiveFeedback);
                            //TODO: Do we need this? : user.AddUser(StressUser.UserQueueTypes.AFFILIATES, affiliate);
                        }
                        else
                        {
                            ResultCode = TEST_RESULTS.NOT_EXECUTED;
                        }
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("AddAffiliatePositiveFeedback exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        StressUserList.AddOnline(user);
                        user.Release();
                    }
                }
            }

            void IsAffiliate()
            {
                StressUser user = null;
                StressUser affiliate = null;
                try
                {
                    user = StressUserList.GetOnlineUser(true);

                    if (user != null)
                    {
                        affiliate = StressUserList.GetOnlineUser(false);

                        if (affiliate != null)
                        {
                            user.AddAffiliate(affiliate, (uint)AffiliateFlags.PositiveFeedback);
                        }
                        else
                        {
                            ResultCode = TEST_RESULTS.NOT_EXECUTED;
                        }
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("AddAffiliatePositiveFeedback exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        StressUserList.AddOnline(user);
                        user.Release();
                    }
                }
            }

            void QueryAffiliateAny()
            {
                StressUser user = null;
                try
                {
                    user = StressUserList.GetOnlineUser(true);
                    if (user != null)
                    {
                        user.QueryAffliates((uint)AffiliateFlags.Encountered);
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("QueryAffiliates exception caught:\n" + e.Message);
                }
                finally
                {
                    if (user != null)
                    {
                        StressUserList.AddOnline(user);
                        user.Release();
                    }
                }
            }
            #endregion
        }
    }

    #region Presence APIs
    [StressTest, StressInstantiate]
    public class Alive : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOfflineUser(true);

                if (user != null && !user.LoggedOn)
                {
                    user.AliveMsg();

                    StressUserList.AddOnline(user);

                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("Alive exception caught:\n" + e.Message);
                Global.RO.Debug("Call Stack: " + e.StackTrace);
                StressUserList.AddOffline(user);
            }
            finally
            {
                if (user != null)
                {
                    user.Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class WebAlive : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOfflineUser(true);

                if (user != null && !user.LoggedOn)
                {
                    user.WebAliveMsg();
                    StressUserList.AddOffline(user); //Note: We are sending him back to offline queue.. because webalive doesn't do anything in general.
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("WebAlive exception caught:\n" + e.Message);
                Global.RO.Debug("Call Stack: " + e.StackTrace);
                StressUserList.AddOffline(user);
            }
            finally
            {
                if (user != null)
                {
                    user.Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class WebAlive2 : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOfflineUser(true);

                if (user != null && !user.LoggedOn)
                {
                    user.WebAlive2();
                    StressUserList.AddOffline(user); //Note: We are sending him back to offline queue.. because webalive doesn't do anything in general.
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("WebAlive2 exception caught:\n" + e.Message);
                Global.RO.Debug("Call Stack: " + e.StackTrace);
                StressUserList.AddOffline(user);
            }
            finally
            {
                if (user != null)
                {
                    user.Release();
                }
            }
        }
    }


    [StressTest, StressInstantiate]
    public class DeadUser : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);

                if (user != null && user.LoggedOn)
                {
                    user.DeadUserMsg();

                    StressUserList.AddOffline(user);

                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("DeadUser exception caught:\n" + e.Message);
                Global.RO.Debug("Userstate at the time of exception: " + user.LoggedOn);
                Global.RO.Debug("Call Stack: " + e.StackTrace);
                StressUserList.AddOnline(user);
            }
            finally
            {
                if (user != null)
                {
                    user.Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class DeadXbox : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);

                if (user != null && user.LoggedOn)
                {
                    user.DeadXboxMsg();

                    StressUserList.AddOffline(user);

                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("DeadXbox exception caught:\n" + e.Message);
                StressUserList.AddOnline(user);
            }
            finally
            {
                if (user != null)
                {
                    user.Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class InvalidateUser : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);

                if (user != null)
                {
                    user.InvalidateMsg();

                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("InvalidateUser exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    StressUserList.AddOnline(user);
                    user.Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class GetPresenceInfo : TestBase
    {
        protected override void Execute()
        {
            StressUser[] users = null;
            try
            {
                users = StressUserList.GetOnlineUser(2, true);

                if (users != null)
                {
                    users[0].GetPresenceInfoMsg(users[1]);

                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("GetPresenceInfo exception caught:\n" + e.Message);
            }
            finally
            {
                if (users != null)
                {
                    StressUserList.AddOnline(users[0]);
                    StressUserList.AddOnline(users[1]);
                    users[0].Release();
                    users[1].Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class LogonCheck : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);

                if (user != null)
                {
                    user.LogonCheckMsg();

                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("LogonCheck exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    StressUserList.AddOnline(user);
                    user.Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class State : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);

                if (user != null && user.LoggedOn)
                {
                    user.StateMsg();

                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("State exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    if (user.LoggedOn)
                        StressUserList.AddOnline(user);
                    else
                        StressUserList.AddOffline(user);
                    user.Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class DequeueFriendsList : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);

                if (user != null && user.LoggedOn)
                {
                    user.Dequeue(XonPresNoti.PQUEUE_LIST_CHANGE);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("DequeueFriendsList exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    if (user.LoggedOn)
                        StressUserList.AddOnline(user);
                    else
                        StressUserList.AddOffline(user);
                    user.Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class DequeueBuddyRequest : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);

                if (user != null && user.LoggedOn)
                {
                    user.Dequeue(XonPresNoti.PQUEUE_BUDDY_REQ);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("DequeueBuddyRequest exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    if (user.LoggedOn)
                        StressUserList.AddOnline(user);
                    else
                        StressUserList.AddOffline(user);
                    user.Release();
                }
            }
        }
    }
    [StressTest, StressInstantiate]
    public class FindUserById : TestBase
    {
        protected override void Execute()
        {
            StressUser[] users = null;
            try
            {
                users = StressUserList.GetOnlineUser(2, true);

                if (users != null)
                {
                    users[0].FindUser(users[1].UserId, "");

                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("FindUserById exception caught:\n" + e.Message);
            }
            finally
            {
                if (users != null)
                {
                    StressUserList.AddOnline(users[0]);
                    StressUserList.AddOnline(users[1]);
                    users[0].Release();
                    users[1].Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class FindUserByGamertag : TestBase
    {
        protected override void Execute()
        {
            StressUser[] users = null;
            try
            {
                users = StressUserList.GetOnlineUser(2, true);

                if (users != null)
                {
                    users[0].FindUser(0, users[1].Name);

                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("FindUserByGamertag exception caught:\n" + e.Message);
            }
            finally
            {
                if (users != null)
                {
                    StressUserList.AddOnline(users[0]);
                    StressUserList.AddOnline(users[1]);
                    users[0].Release();
                    users[1].Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class FindUsers : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            StressUser[] queryUsers = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);
                queryUsers = StressUserList.GetOnlineUser(20, false);

                if (user != null && queryUsers != null)
                {
                    ulong[] userIds = new ulong[10];
                    string[] gamertags = new string[10];

                    for (int i = 0; i < 10; ++i)
                    {
                        userIds[i] = queryUsers[i].UserId;
                        gamertags[i] = queryUsers[i + 10].Name;
                    }

                    user.FindUsers(userIds, gamertags);

                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("FindUsers exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    StressUserList.AddOnline(user);
                    user.Release();
                }
                if (queryUsers != null)
                {
                    for (int i = 0; i < queryUsers.Length; ++i)
                    {
                        StressUserList.AddOnline(queryUsers[i]);
                        // Don't need to release since they weren't locked
                    }
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class BlockVoice : TestBase
    {
        protected override void Execute()
        {
            StressUser[] users = null;
            try
            {
                users = StressUserList.GetOnlineUser(2, true);

                if (users != null)
                {
                    // We must make sure we don't try to block someone that is already blocked
                    if (users[0].UserExists(StressUser.UserQueueTypes.VOICE_BLOCKED, users[1]))
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                    else
                    {
                        users[0].BlockVoiceMsg(users[1]);

                        // Add a reference of the blocked user to user[0] so they can be unblocked later
                        users[0].AddUser(StressUser.UserQueueTypes.VOICE_BLOCKED, users[1]);

                        StressUserList.AddBlocked(users[0]);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("BlockVoice exception caught:\n" + e.Message);
            }
            finally
            {
                if (users != null)
                {
                    StressUserList.AddOnline(users[0]);
                    StressUserList.AddOnline(users[1]);
                    users[0].Release();
                    users[1].Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class UnblockVoice : TestBase // No idea if this does anything?
    {
        protected override void Execute()
        {
            StressUser user = null;
            StressUser blockedUser = null;
            try
            {
                user = StressUserList.GetBlockedUser(true);

                if (user != null && user.LoggedOn)
                {
                    // blockedUser will be locked
                    blockedUser = user.GetUser(StressUser.UserQueueTypes.VOICE_BLOCKED);

                    if (blockedUser != null)
                    {
                        user.UnblockVoiceMsg(blockedUser);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("UnblockVoice exception caught:\n" + e.Message);
                if (blockedUser != null)
                {
                    StressUserList.AddBlocked(blockedUser);
                }
            }
            finally
            {
                if (user != null)
                {
                    user.Release();
                }
                if (blockedUser != null)
                {
                    blockedUser.Release();
                }
            }
        }
    }
    [StressTest, StressInstantiate]
    public class UnblockAllVoice : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            List<StressUser> blockedUsers = new List<StressUser>();
            try
            {
                user = StressUserList.GetBlockedUser(true);
              
                if (user != null && user.LoggedOn)
                {
                    // blockedUser will be locked
                    bool bAvailable = true;
                    while (bAvailable)
                    {
                        StressUser u = user.GetUser(StressUser.UserQueueTypes.VOICE_BLOCKED);
                        if (u == null)
                        {
                            bAvailable = false;
                        }
                        else
                        {
                            blockedUsers.Add(u);
                        }
                    }

                    user.UnblockAllVoiceMsg();
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("UnblockAllVoice exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    user.Release();
                }
                if (blockedUsers.Count > 0)
                {
                    foreach (StressUser u in blockedUsers)
                        u.Release();
                }
            }
        }
    }
    [StressTest, StressInstantiate]
    public class CanSendMessage : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            StressUser[] recipients = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);
                recipients = StressUserList.GetOnlineUser(2, true);
                
                if (user != null && user.LoggedOn && recipients!= null && recipients.Length > 0)
                {
                    user.CanSendMessage(recipients);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("CanSendMessage exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    StressUserList.AddOnline(user);
                    user.Release();
                }
                if (recipients != null)
                {
                    foreach (StressUser s in recipients)
                    {
                        StressUserList.AddOnline(s);
                        s.Release();
                    }
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class AddToNeverList : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            StressUser nevered = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);
                nevered = StressUserList.GetOnlineUser(false);

                if (user != null && user.LoggedOn && nevered != null)
                {
                    user.AddUsersToNeverList(1, new ulong[]{nevered.UserId});
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("AddToNeverList exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    StressUserList.AddOnline(user);
                    user.Release();
                }
                if (nevered != null)
                {
                    StressUserList.AddOnline(nevered);
                    nevered.Release();
                }
            }
        }
    }
    #endregion

    #region Friends APIs
    [StressTest, StressInstantiate]
    public class AddBuddyById : TestBase
    {
        protected override void Execute()
        {
            StressUser[] users = null;
            try
            {
                users = StressUserList.GetOnlineUser(2, true);

                if (users != null)
                {
                    // We must make sure we don't send the message if we are already friends
                    if(users[0].UserExists(StressUser.UserQueueTypes.FRIENDS, users[1]) ||
                       users[0].UserExists(StressUser.UserQueueTypes.INCOMING_BUDDY_REQUEST, users[1]) ||
                       users[0].UserExists(StressUser.UserQueueTypes.OUTGOING_BUDDY_REQUEST, users[1]))
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                    else
                    {
                        users[0].AddBuddyMsg(users[1]);

                        users[0].AddUser(StressUser.UserQueueTypes.OUTGOING_BUDDY_REQUEST, users[1]);
                        users[1].AddUser(StressUser.UserQueueTypes.INCOMING_BUDDY_REQUEST, users[0]);

                        StressUserList.AddBuddyRequestor(users[0]);
                        StressUserList.AddBuddyRequested(users[1]);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("AddBuddyById exception caught:\n" + e.Message);
            }
            finally
            {
                if (users != null)
                {
                    StressUserList.AddOnline(users[0]);
                    StressUserList.AddOnline(users[1]);
                    users[0].Release();
                    users[1].Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class AddBuddyByName : TestBase
    {
        protected override void Execute()
        {
            StressUser[] users = null;
            try
            {
                users = StressUserList.GetOnlineUser(2, true);

                if (users != null)
                {
                    // We must make sure we don't send the message if we are already friends
                    if (users[0].UserExists(StressUser.UserQueueTypes.FRIENDS, users[1]) ||
                       users[0].UserExists(StressUser.UserQueueTypes.INCOMING_BUDDY_REQUEST, users[1]) ||
                       users[0].UserExists(StressUser.UserQueueTypes.OUTGOING_BUDDY_REQUEST, users[1]))
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                    else
                    {
                        users[0].AddBuddyMsg(users[1], true);

                        users[0].AddUser(StressUser.UserQueueTypes.OUTGOING_BUDDY_REQUEST, users[1]);
                        users[1].AddUser(StressUser.UserQueueTypes.INCOMING_BUDDY_REQUEST, users[0]);

                        StressUserList.AddBuddyRequestor(users[0]);
                        StressUserList.AddBuddyRequested(users[1]);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("AddBuddyByName exception caught:\n" + e.Message);
            }
            finally
            {
                if (users != null)
                {
                    StressUserList.AddOnline(users[0]);
                    StressUserList.AddOnline(users[1]);
                    users[0].Release();
                    users[1].Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class AcceptBuddyRequest : TestBase // NOTE: This leaves the requestor in the outgoing queue still. To change?
    {
        protected override void Execute()
        {
            StressUser user = null;
            StressUser requestorUser = null;
            try
            {
begin:
                user = StressUserList.GetBuddyRequestedUser(true);

                if (user != null)
                {
                    requestorUser = user.GetUser(StressUser.UserQueueTypes.INCOMING_BUDDY_REQUEST);

                    // This could happen if the requestor deleted the requested friend (user)
                    if (requestorUser != null)
                    {
                        user.AcceptBuddyMsg(requestorUser);

                        // Record our friends-ness locally
                        user.AddUser(StressUser.UserQueueTypes.FRIENDS, requestorUser);
                        requestorUser.AddUser(StressUser.UserQueueTypes.FRIENDS, user);

                        // Remove user from the requestor's outgoingBuddyRequest queue
                        requestorUser.RemoveUser(StressUser.UserQueueTypes.OUTGOING_BUDDY_REQUEST, user);

                        // Add one of the friends to the accepted friend list
                        StressUserList.AddBuddyAccepted(user);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        if (StressUserList.BuddyRequestedUserQueueCount > 0)
                        {
                            user.Release();
                            goto begin;
                        }

                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("AcceptBuddy exception caught:\n" + e.Message);
                StressUserList.AddBuddyRequested(user);
            }
            finally
            {
                if (user != null)
                {
                    user.Release();
                }
                if (requestorUser != null)
                {
                    requestorUser.Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class RejectBuddyRequest : TestBase // NOTE: This leaves the requestor in the outgoing queue still. To change?
    {
        protected override void Execute()
        {
            StressUser user = null;
            StressUser requestorUser = null;
            try
            {
begin:
                user = StressUserList.GetBuddyRequestedUser(true);

                if (user != null)
                {
                    requestorUser = user.GetUser(StressUser.UserQueueTypes.INCOMING_BUDDY_REQUEST);

                    // This could happen if the requestor deleted the requested friend (user)
                    if (requestorUser != null)
                    {
                        user.RejectBuddyMsg(requestorUser);

                        // Remove reference 
                        requestorUser.RemoveUser(StressUser.UserQueueTypes.OUTGOING_BUDDY_REQUEST, user);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        if (StressUserList.BuddyRequestedUserQueueCount > 0)
                        {
                            user.Release();
                            goto begin;
                        }

                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("RejectBuddy exception caught:\n" + e.Message);
                StressUserList.AddBuddyRequested(user);
            }
            finally
            {
                if (user != null)
                {
                    user.Release();
                }
                if (requestorUser != null)
                {
                    requestorUser.Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class RejectNeverBuddyRequest : TestBase // NOTE: This leaves the requestor in the outgoing queue still. To change?
    {
        protected override void Execute()
        {
            StressUser user = null;
            StressUser requestorUser = null;
            try
            {
            begin:
                user = StressUserList.GetBuddyRequestedUser(true);

                if (user != null)
                {
                    requestorUser = user.GetUser(StressUser.UserQueueTypes.INCOMING_BUDDY_REQUEST);

                    // This could happen if the requestor deleted the requested friend (user)
                    if (requestorUser != null)
                    {
                        user.RejectBuddyMsg(requestorUser, true);

                        // Remove reference 
                        requestorUser.RemoveUser(StressUser.UserQueueTypes.OUTGOING_BUDDY_REQUEST, user);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        if (StressUserList.BuddyRequestedUserQueueCount > 0)
                        {
                            user.Release();
                            goto begin;
                        }

                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("RejectNeverBuddyRequest exception caught:\n" + e.Message);
                StressUserList.AddBuddyRequested(user);
            }
            finally
            {
                if (user != null)
                {
                    user.Release();
                }
                if (requestorUser != null)
                {
                    requestorUser.Release();
                }
            }
        }
    }
    [StressTest, StressInstantiate]
    public class DeleteBuddy : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            StressUser buddyUser = null;
            try
            {
                user = StressUserList.GetBuddyAcceptedUser(true);

                if (user != null)
                {
                    buddyUser = user.GetUser(StressUser.UserQueueTypes.FRIENDS);

                    if (buddyUser != null)
                    {
                        user.DeleteBuddyMsg(buddyUser);

                        // Remove from friends list on other user
                        buddyUser.RemoveUser(StressUser.UserQueueTypes.FRIENDS, user);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("DeleteBuddy exception caught:\n" + e.Message);
                StressUserList.AddBuddyAccepted(user);
            }
            finally
            {
                if (user != null)
                {
                    user.Release();
                }
                if (buddyUser != null)
                {
                    buddyUser.Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class CancelBuddyInvite : TestBase // NOTE: This leaves the requested user in the incoming queue still. To change?
    {
        protected override void Execute()
        {
            StressUser user = null;
            StressUser pendingUser = null;
            try
            {
begin:
                user = StressUserList.GetBuddyRequestorUser(true);

                if (user != null)
                {
                    pendingUser = user.GetUser(StressUser.UserQueueTypes.OUTGOING_BUDDY_REQUEST);

                    if (pendingUser != null)
                    {
                        user.DeleteBuddyMsg(pendingUser);

                        // Remove from friends list on other user
                        pendingUser.RemoveUser(StressUser.UserQueueTypes.INCOMING_BUDDY_REQUEST, user);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        if (StressUserList.BuddyRequestorUserQueueCount > 0)
                        {
                            user.Release();
                            goto begin;
                        }

                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("CancelBuddyInvite exception caught:\n" + e.Message);
                StressUserList.AddBuddyRequestor(user);
            }
            finally
            {
                if (user != null)
                {
                    user.Release();
                }
                if (pendingUser != null)
                {
                    pendingUser.Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class DeleteReceivedBuddy : TestBase // NOTE: This leaves the requestor in the outgoing queue still. To change?
    {
        protected override void Execute()
        {
            StressUser user = null;
            StressUser pendingUser = null;
            try
            {
begin:
                user = StressUserList.GetBuddyRequestedUser(true);

                if (user != null)
                {
                    pendingUser = user.GetUser(StressUser.UserQueueTypes.INCOMING_BUDDY_REQUEST);

                    if (pendingUser != null)
                    {
                        user.DeleteBuddyMsg(pendingUser);

                        // Remove from friends list on other user
                        pendingUser.RemoveUser(StressUser.UserQueueTypes.OUTGOING_BUDDY_REQUEST, user);

                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        if (StressUserList.BuddyRequestedUserQueueCount > 0)
                        {
                            user.Release();
                            goto begin;
                        }

                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("DeleteReceivedBuddy exception caught:\n" + e.Message);
                StressUserList.AddBuddyRequested(user);
            }
            finally
            {
                if (user != null)
                {
                    user.Release();
                }
                if (pendingUser != null)
                {
                    pendingUser.Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class GetFriendsList : TestBase
    {
        protected override void Execute()
        {
            StressUser[] users = null;
            try
            {
                users = StressUserList.GetOnlineUser(2, true);

                if (users != null)
                {
                    users[0].GetFriendsListMsg(users[1]);

                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("GetFriendsList exception caught:\n" + e.Message);
            }
            finally
            {
                if (users != null)
                {
                    StressUserList.AddOnline(users[0]);
                    StressUserList.AddOnline(users[1]);
                    users[0].Release();
                    users[1].Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class GetWebFriends : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);

                if (user != null)
                {
                    user.GetWebFriendsMsg();

                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("GetWebFriends exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    StressUserList.AddOnline(user);
                    user.Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class GetFriendsListLimitedPresence : TestBase
    {
        protected override void Execute()
        {
            StressUser[] users = null;
            try
            {
                users = StressUserList.GetOnlineUser(1, true); // Get one user and get the limited presence.

                if (users != null)
                {
                    users[0].GetFriendsLimitedPresence();
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("GetFriendsListLimitedPresence exception caught:\n" + e.Message);
            }
            finally
            {
                if (users != null)
                {
                    StressUserList.AddOnline(users[0]);
                    StressUserList.AddOnline(users[1]);
                    users[0].Release();
                    users[1].Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class GetFriendsListNoPresence : TestBase
    {
        protected override void Execute()
        {
            StressUser[] users = null;
            try
            {
                users = StressUserList.GetOnlineUser(1, true); // Get one user and get the limited presence.

                if (users != null)
                {
                    users[0].GetFriendsNoPresence();
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("GetFriendsListNoPresence exception caught:\n" + e.Message);
            }
            finally
            {
                if (users != null)
                {
                    StressUserList.AddOnline(users[0]);
                    StressUserList.AddOnline(users[1]);
                    users[0].Release();
                    users[1].Release();
                }
            }
        }
    }

    #endregion

    #region Affiliate APIs
    [StressTest, StressInstantiate]
    public class AddAffiliatePositiveFeedback : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            StressUser affiliate = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);

                if (user != null)
                {
                    affiliate = StressUserList.GetOnlineUser(false);

                    if (affiliate != null && user.UserId != affiliate.UserId)
                    {
                        user.AddAffiliate(affiliate, (uint)AffiliateFlags.PositiveFeedback);
                        //TODO: Do we need this? : user.AddUser(StressUser.UserQueueTypes.AFFILIATES, affiliate);
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("AddAffiliatePositiveFeedback exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    StressUserList.AddOnline(user);
                    user.Release();
                }
                if (affiliate != null)
                    StressUserList.AddOnline(affiliate);
            }
        }
    }

    [StressTest, StressInstantiate]
    public class AddAffiliateNegativeFeedback : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            StressUser affiliate = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);

                if (user != null)
                {
                    affiliate = StressUserList.GetOnlineUser(false);

                    if (affiliate != null)
                    {
                        user.AddAffiliate(affiliate, (uint)AffiliateFlags.NegativeFeedback);
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("AddAffiliateNegativeFeedback exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    StressUserList.AddOnline(user);
                    user.Release();
                }
                if (affiliate != null)
                    StressUserList.AddOnline(affiliate);
            }
        }
    }

    [StressTest, StressInstantiate]
    public class AddAffiliateFavoritesList: TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            StressUser affiliate = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);

                if (user != null)
                {
                    affiliate = StressUserList.GetOnlineUser(false);

                    if (affiliate != null)
                    {
                        user.AddAffiliate(affiliate, (uint)AffiliateFlags.Favorites);
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("AddAffiliateFavoritesList exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    StressUserList.AddOnline(user);
                    user.Release();
                }
                if (affiliate != null)
                    StressUserList.AddOnline(affiliate);
            }
        }
    }

    [StressTest, StressInstantiate]
    public class AddAffiliateCompletedGame : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            StressUser affiliate = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);

                if (user != null)
                {
                    affiliate = StressUserList.GetOnlineUser(false);

                    if (affiliate != null)
                    {
                        user.AddAffiliate(affiliate, (uint)AffiliateFlags.CompletedGame);
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("AddAffiliateCompletedGame exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    StressUserList.AddOnline(user);
                    user.Release();
                }
                if (affiliate != null)
                    StressUserList.AddOnline(affiliate);
            }
        }
    }

    [StressTest, StressInstantiate]
    public class IsAffiliate : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            StressUser affiliate = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);

                if (user != null)
                {
                    affiliate = StressUserList.GetOnlineUser(false);

                    if (affiliate != null)
                    {
                        user.IsAffiliate(affiliate);
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        ResultCode = TEST_RESULTS.NOT_EXECUTED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("IsAffiliate exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    StressUserList.AddOnline(user);
                    user.Release();
                }
                if (affiliate != null)
                    StressUserList.AddOnline(affiliate);
            }
        }
    }

    [StressTest, StressInstantiate]
    public class QueryAffiliates : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);
                if (user != null)
                {
                    user.QueryAffliates((uint)AffiliateFlags.Encountered);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("QueryAffiliates exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    StressUserList.AddOnline(user);
                    user.Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class QueryAffiliatesRecentPlayers : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);
                if (user != null)
                {
                    user.QueryAffliates((uint)AffiliateFlags.Encountered);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("QueryAffiliatesRecentPlayers exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    StressUserList.AddOnline(user);
                    user.Release();
                }
            }
        }
    }

    [StressTest, StressInstantiate]
    public class QueryAffiliatesFavorites : TestBase
    {
        protected override void Execute()
        {
            StressUser user = null;
            try
            {
                user = StressUserList.GetOnlineUser(true);
                if (user != null)
                {
                    user.QueryAffliates((uint)AffiliateFlags.Favorites);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.NOT_EXECUTED;
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("QueryAffiliatesFavorites exception caught:\n" + e.Message);
            }
            finally
            {
                if (user != null)
                {
                    StressUserList.AddOnline(user);
                    user.Release();
                }
            }
        }
    }




    #endregion

    [StressTest, StressInstantiate]
    public class RefreshUserQueues : TestBase
    {
        protected override void Execute()
        {
            Global.RO.Warn("Rejuvenating queues");
            StressUserList.ReinitializedQueues();
            ResultCode = TEST_RESULTS.PASSED;
        }
    }
    [StressTest, StressInstantiate]
    public class StressInfoDump : TestBase
    {
        protected override void Execute()
        {
            Global.RO.Info("Online User Queue:    " + StressUserList.OnlineUserQueueCount);
            Global.RO.Info("Offline User Queue:   " + StressUserList.OfflineUserQueueCount);
            Global.RO.Info("Blocked User Queue:   " + StressUserList.BlockedUserQueueCount);
            Global.RO.Info("Requested User Queue: " + StressUserList.BuddyRequestedUserQueueCount);
            Global.RO.Info("Requestor User Queue: " + StressUserList.BuddyRequestorUserQueueCount);
            Global.RO.Info("Accepted User Queue:  " + StressUserList.BuddyAcceptedUserQueueCount);
            ResultCode = TEST_RESULTS.PASSED;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\BasePresenceConnection.h ===
#pragma once

enum PresenceConnectionType
{
	BASEPRESENCECONNECTION = 0,
	FDCONNECTION = 1,
	INHCONNECTION = 2
};

class BasePresenceConnection
{
	PresenceConnectionType m_dwType;
public:

	BasePresenceConnection(PresenceConnectionType dwType)
	{
		m_dwType = dwType;
	}

	PresenceConnectionType Type(){return m_dwType; }

    //------------------------------------------------------------------------------
    // Message transport
    //------------------------------------------------------------------------------
    
    virtual HRESULT SendAlive(
        XPQTask*      pTask, 
        XPQUser*      pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendLogoff(
        XPQTask*      pTask,
        XPQUser*      pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendDeadXbox(
        XPQTask*      pTask, 
        XPQUser*      pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendDeadUser(
        XPQTask*      pTask, 
        XPQUser*      pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendCheckTitleMessages(
        XPQTask*      pTask,
        XPQUser*      pUser,
        DWORD         dwTitleId){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendUpdateState( 
        XPQTask*      pTask,
        XPQUser*      pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendUpdateStateBatch(
        XPQTask*      pTask,
        XPQUser*      pUser,
        CSgMsgNotifyCliUpdate *prgUdpates,
        DWORD         cUpdates){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendUpdateState2( 
        XPQTask*      pTask,
        XPQUser*      pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendDequeue(
        XPQTask*      pTask,
        XPQUser*      pUser,
        P_QUEUE_TYPES eQType){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendPeerSubscribe( 
        XPQTask*        pTask,
        XPQUser*        pUser,
        const XPQUser** rgpPeers,
        WORD            wPeers){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendPeerUnsubscribe(
        XPQTask*       pTask,
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendAddBuddy(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pBuddy, 
        bool           bByName = false ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendAcceptBuddy( 
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pBuddy ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendRejectBuddy( 
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pBuddy, 
        bool           bNever = false ){_ASSERTE(0); return E_FAIL;}
    
    virtual HRESULT SendDeleteBuddy( 
        XPQTask*       pTask,
        XPQUser*       pUser,
		const XPQUser* pBuddy ){_ASSERTE(0); return E_FAIL;}
   
    virtual HRESULT SendBlock(   
        XPQTask*        pTask,
        XPQUser*        pUser,
        const XPQUser*  pBlock){_ASSERTE(0); return E_FAIL;}
    
    virtual HRESULT SendUnblock( 
        XPQTask*        pTask,
        XPQUser*        pUser,
        const XPQUser*  pUnblock,
        bool            bAll = false ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendAddAffiliates(
        XPQTask*        pTask,
        XPQUser*        pUser,
        DWORD           dwListFlag,
        DWORD           dwTitleId,
        const XPQUser** rgpAffiliates,
        WORD            cwAffiliates){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendIsAffiliate(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pAffiliate){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendQueryAffiliates(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwListFlags,
        DWORD          cdwLimit,
        DWORD          dwOnlineTitleId,
        BOOL           fUseDatacenter){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendInvite( 
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser** apBuddy, 
        WORD           wCount ){_ASSERTE(0); return E_FAIL;}
    
    virtual HRESULT SendCancelInvite( 
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser** apBuddy, 
        WORD           wCount ){_ASSERTE(0); return E_FAIL;}
    
    virtual HRESULT SendAnswerInvite( 
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pHost, 
        ULONGLONG      qwMatchSessionId,
        bool           bYes ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendSendMessage(
        XPQTask*       pTask,
        XPQUser*       pUser,
		BYTE		   bMsgType,
        ULONGLONG      qwContext,
        DWORD          dwFlags,
        ULONGLONG*     pqwRecipients,
        WORD           wRecipients,
        BYTE*          pbDetails,
        WORD           wDetails,
		WORD		   wExpire){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendEnumMessages(
        XPQTask*       pTask,
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendEnumMessages2(
        XPQTask*       pTask,
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendMessageSummary(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwMsgId){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendMessageSummary2(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwMsgId){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendMessageDetails(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwMsgId,
        DWORD          dwMsgSetFlags,
        DWORD          dwMsgUnsetFlags){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendMessageFlags(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwMsgId,
        DWORD          dwSetFlags,
        DWORD          dwClearFlags ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendMessageDelete(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwMsgId,
        bool           bBlock ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendMessageRevoke(
        XPQTask*                  pTask,
        XPQUser*                  pUser,
        const Q_RECIPIENT_RESULT *prgRecipientResults,
        WORD                      wcRecipients){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendMessageRevokeEx(
        XPQTask*                  pTask,
        XPQUser*                  pUser,
        ULONGLONG                 qwSenderId,
        ULONGLONG                 qwSenderContext,
        DWORD                     dwFlags,
        WORD                      wPropTag,
        BYTE                      bMessageType,
        const Q_RECIPIENT_RESULT* prgRecipients,  
        WORD                      cRecipients,
        const BYTE*               prbProp,
        WORD                      cbProp){_ASSERTE(0); return E_FAIL;}
    
    virtual HRESULT SendUpdateNickname(
        XPQTask*       pTask,
        XPQUser*       pUser,
        BYTE*          pbNickname, 
        WORD           wNicknameLen ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendDeleteTitle(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwTitleId){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendEnumTitles(
        XPQTask*       pTask,
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}
   
    virtual HRESULT SendCreateTeam(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const WCHAR*   wszTeamName,
        const WCHAR*   wszTeamDescription,
        const WCHAR*   wszTeamMotto,
        const WCHAR*   wszTeamURL,
        BYTE*          pbTeamData, 
        WORD           wTeamDataLen,
        BYTE*          pbCreatorData, 
        WORD           wCreatorDataLen){_ASSERTE(0); return E_FAIL;}
        
    virtual HRESULT SendManageTeam(
        XPQTask*       pTask,
        XPQUser*       pUser,
        ULONGLONG      qwTeamId,
        const WCHAR*   wszTeamName,
        const WCHAR*   wszTeamDescription,
        const WCHAR*   wszTeamMotto,
        const WCHAR*   wszTeamURL,
        BYTE*          pbTeamData, 
        WORD           wTeamDataLen ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendDeleteTeam(
        XPQTask*       pTask,
        XPQUser*       pUser,
        ULONGLONG      qwTeamId ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendListTeams(
        XPQTask*       pTask,
        XPQUser*       pUser,
        ULONGLONG*     aqwTeamIds, 
        WORD           wNumIds ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendListUserTeams(
        XPQTask*       pTask,
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendRecruitTeamMember(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pRecruit,
        ULONGLONG      qwTeamId,
        DWORD          dwMemberPriv,
        BYTE*          pbData, 
        WORD           wDataLen){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendJoinTeam(
        XPQTask*         pTask,
        XPQUser*         pUser,
        ULONGLONG        qwTeamId,
        DWORD            dwRecruitMsgId,
        P_INVITE_REPLIES eReply ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendManageTeamMember(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pMember,
        ULONGLONG      qwTeamId,
        DWORD          dwMemberPriv,
        BYTE*          pbData, 
        WORD           wDataLen ){_ASSERTE(0); return E_FAIL;}
            
    virtual HRESULT SendRemoveTeamMember(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pMember,
        ULONGLONG      qwTeamId){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendListTeamMembers(
        XPQTask*       pTask,   
        XPQUser*       pUser,   
        ULONGLONG      qwTeamId,
        bool           bShowRecruits ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendGetTeamTicket(
        XPQTask*       pTask,
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendWebFriends(
        XPQTask*       pTask, 
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendGetFriendsList(
        XPQTask*       pTask, 
        XPQUser*       pUser,
        const XPQUser* pTargetUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendGetPresenceInfo(
        XPQTask*       pTask, 
        XPQUser*       pUser,
        const XPQUser* pTargetUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendFindUser(
        XPQTask*       pTask, 
        XPQUser*       pUser,
        ULONGLONG      qwFindId,
        const char*    pszGamerTag){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendFindUsers(
        XPQTask*       pTask, 
        XPQUser*       pUser,
        const XPQUser** apFinds, 
		WORD  wCount){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendInvalidateUser(
        XPQTask*       pTask,
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}
  
	virtual HRESULT SendEcho(
        XPQTask*       pTask,
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\Command.h ===
#pragma once


class XPQTask;
class Command;

typedef Command * (*PfnCommandFactory)();

//------------------------------------------------------------------------------
//
// Command object composes the commands that a task must perform and the
// data associated with the command
//
//------------------------------------------------------------------------------
class Command
{
protected:
    static void Register(const char *pszCommandName, PfnCommandFactory pfnCommandFactory);

    Command()
    {}

private:
    Command(Command &command);
    Command &operator=(Command &command);
public:
    

    virtual ~Command() {};

    //------------------------------------------------------------------------------
    // Create a new command given a command name
    //------------------------------------------------------------------------------
    static Command * Create(const char *pszCommandName);
    
    //------------------------------------------------------------------------------
    // Execute the command from a task
    //------------------------------------------------------------------------------
    virtual HRESULT Execute(XPQTask *pTask) = 0;
    virtual const char* Name() const = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\stress\StressUserList.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Database;
//using ServerTestFramework.LiveService.PresNotiCommon;
//using ServerTestFramework.LiveService.Presence;
using xonline.common.diagnostics;



using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;



namespace PresenceTest
{
    public class StressUserList
    {
        public static ulong basePuid = 0;
        public static int puidCount;

        // only used for reference not for making requests
        public static StressUser[] UserArray = null;

        private enum QueueTypes
        {
            OFFLINE,
            ONLINE,
            BUDDYREQUESTOR,
            BUDDYREQUESTED,
            BUDDYACCEPTED,
            BLOCKED
        }

        // used for making requests
        private static Queue OfflineUsers = Queue.Synchronized(new Queue());        // Users who are offline (pre alive, post deaduser/deadxbox)
        private static Queue OnlineUsers = Queue.Synchronized(new Queue());         // Users who are online (post alive)
        private static Queue BuddyRequestorUsers = Queue.Synchronized(new Queue()); // Users who have issued a friend request (post addbuddy)
        private static Queue BuddyRequestedUsers = Queue.Synchronized(new Queue()); // Users who have received a friend request (post addbuddy)
        private static Queue BuddyAcceptedUsers = Queue.Synchronized(new Queue());  // Users who have accepted a friend request (post acceptbuddy)
        private static Queue BlockedUsers = Queue.Synchronized(new Queue());        // Users who have blocked someone (post blockvoice)

        /// <summary>
        /// Constructor
        /// </summary>
        public StressUserList()
        {
        }

        /// <summary>
        /// Static initialization to load bulk users and create initial stress users
        /// </summary>
        public static void Initialize()
        {
            uint userCount = 250;
            ulong Offer = 0xFFFE000080000008;
            BulkUserSet userSet = null;
            try
            {
                // Have these be null is the default and desired method. Only set the 
                // KEK if you really know what you are doing and installing the crypto stuff
                // is too much of a pain.
                UodbWS.ReserveName_KEK = null;
                UodbWS.ReserveName_KEKVersion = 1;

                UodbWS.CreateBulkUsersExt("BU", userCount, Offer, 103, true, out userSet, false, false);
                Global.RO.Success("Done creating Bulkusers.");
                Console.WriteLine("Done.");
            }
            catch (Exception exp)
            {
                Global.RO.Debug(exp.Message);
            }
            finally
            {
                if (userSet != null)
                {
                    Global.RO.Info("OfferId: {0:x}, BasePuid: 0x{1:x}, Count: {2}, Prefix: {3}",
                        userSet.OfferId, userSet.Base, userSet.Count, userSet.Prefix);
                }
            }

            FriendsCommon.WaitForXCache();
            puidCount = (int)userSet.Count;
            basePuid = userSet.Base;
            CPUIDList puidList = userSet.GetPuidList();
            UserArray = new StressUser[puidList.GetSize()];

            lock (OfflineUsers.SyncRoot)
            {
                for (int i = 0; i < puidList.GetSize(); ++i)
                {
                    StressUser user = new StressUser(puidList[i]);
                    UserArray[i] = user;
                    OfflineUsers.Enqueue(user);
                }
            }
        }

        #region Add to Queues
        /// <summary>
        /// Adds a user to the offline queue
        /// </summary>
        public static void AddOffline(StressUser user)
        {
            lock (OfflineUsers.SyncRoot)
            {
                OfflineUsers.Enqueue(user);
            }
        }

        /// <summary>
        /// Adds a user to the online queue
        /// </summary>
        public static void AddOnline(StressUser user)
        {
            lock (OnlineUsers.SyncRoot)
            {
                OnlineUsers.Enqueue(user);
            }
        }

        /// <summary>
        /// Adds a user to the buddyRequestor queue
        /// </summary>
        public static void AddBuddyRequestor(StressUser user)
        {
            lock (BuddyRequestorUsers.SyncRoot)
            {
                BuddyRequestorUsers.Enqueue(user);
            }
        }

        /// <summary>
        /// Adds a user to the buddyRequested queue
        /// </summary>
        public static void AddBuddyRequested(StressUser user)
        {
            lock (BuddyRequestedUsers.SyncRoot)
            {
                BuddyRequestedUsers.Enqueue(user);
            }
        }

        /// <summary>
        /// Adds a user to the buddyAccepted queue
        /// </summary>
        public static void AddBuddyAccepted(StressUser user)
        {
            lock (BuddyAcceptedUsers.SyncRoot)
            {
                BuddyAcceptedUsers.Enqueue(user);
            }
        }

        /// <summary>
        /// Adds a user to the blocked queue
        /// </summary>
        public static void AddBlocked(StressUser user)
        {
            lock (BlockedUsers.SyncRoot)
            {
                BlockedUsers.Enqueue(user);
            }
        }
        #endregion

        #region Get from Queues
        /// <summary>
        /// Gets a single user from the offline queue. If there are none, null is returned.
        /// </summary>
        public static StressUser GetOfflineUser(bool Lock)
        {
            return GetUser(QueueTypes.OFFLINE, Lock);
        }

        /// <summary>
        /// Gets the requested number of users from the offline queue. If there are not enough, null is returned.
        /// </summary>
        public static StressUser[] GetOfflineUser(ushort NumUsers, bool Lock)
        {
            return GetUser(QueueTypes.OFFLINE, NumUsers, Lock);
        }

        /// <summary>
        /// Gets a single user from the online queue. If there are none, null is returned.
        /// </summary>
        public static StressUser GetOnlineUser(bool Lock)
        {
            return GetUser(QueueTypes.ONLINE, Lock);
        }

        /// <summary>
        /// Gets the requested number of users from the online queue. If there are not enough, null is returned.
        /// </summary>
        public static StressUser[] GetOnlineUser(ushort NumUsers, bool Lock)
        {
            return GetUser(QueueTypes.ONLINE, NumUsers, Lock);
        }

        /// <summary>
        /// Gets a single user from the buddyrequestor queue. If there are none, null is returned.
        /// </summary>
        public static StressUser GetBuddyRequestorUser(bool Lock)
        {
            return GetUser(QueueTypes.BUDDYREQUESTOR, Lock);
        }

        /// <summary>
        /// Gets the requested number of users from the buddyrequestor queue. If there are not enough, null is returned.
        /// </summary>
        public static StressUser[] GetBuddyRequestorUser(ushort NumUsers, bool Lock)
        {
            return GetUser(QueueTypes.BUDDYREQUESTOR, NumUsers, Lock);
        }

        /// <summary>
        /// Gets a single user from the buddyrequested queue. If there are none, null is returned.
        /// </summary>
        public static StressUser GetBuddyRequestedUser(bool Lock)
        {
            return GetUser(QueueTypes.BUDDYREQUESTED, Lock);
        }

        /// <summary>
        /// Gets the requested number of users from the buddyrequested queue. If there are not enough, null is returned.
        /// </summary>
        public static StressUser[] GetBuddyRequestedUser(ushort NumUsers, bool Lock)
        {
            return GetUser(QueueTypes.BUDDYREQUESTED, NumUsers, Lock);
        }

        /// <summary>
        /// Gets a single user from the buddyaccepted queue. If there are none, null is returned.
        /// </summary>
        public static StressUser GetBuddyAcceptedUser(bool Lock)
        {
            return GetUser(QueueTypes.BUDDYACCEPTED, Lock);
        }

        /// <summary>
        /// Gets the requested number of users from the buddyaccepted queue. If there are not enough, null is returned.
        /// </summary>
        public static StressUser[] GetBuddyAcceptedUser(ushort NumUsers, bool Lock)
        {
            return GetUser(QueueTypes.BUDDYACCEPTED, NumUsers, Lock);
        }

        /// <summary>
        /// Gets a single user from the blocked queue. If there are none, null is returned.
        /// </summary>
        public static StressUser GetBlockedUser(bool Lock)
        {
            return GetUser(QueueTypes.BLOCKED, Lock);
        }

        /// <summary>
        /// Gets the requested number of users from the blocked queue. If there are not enough, null is returned.
        /// </summary>
        public static StressUser[] GetBlockedUser(ushort NumUsers, bool Lock)
        {
            return GetUser(QueueTypes.BLOCKED, NumUsers, Lock);
        }

        /// <summary>
        /// Gets a single user from the desired queue. If there are none, null is returned.
        /// </summary>
        private static StressUser GetUser(QueueTypes type, bool Lock)
        {
            Queue q = null;
            switch(type)
            {
                case QueueTypes.OFFLINE:
                    q = OfflineUsers;
                    break;
                case QueueTypes.ONLINE:
                    q = OnlineUsers;
                    break;
                case QueueTypes.BUDDYREQUESTOR:
                    q = BuddyRequestorUsers;
                    break;
                case QueueTypes.BUDDYREQUESTED:
                    q = BuddyRequestedUsers;
                    break;
                case QueueTypes.BUDDYACCEPTED:
                    q = BuddyAcceptedUsers;
                    break;
                case QueueTypes.BLOCKED:
                    q = BlockedUsers;
                    break;
            }

            StressUser user = null;
            lock (q.SyncRoot)
            {
                int iUser = 0;
                int iUserCount = q.Count;
                while (iUser < iUserCount)
                {
                    user = (StressUser)q.Dequeue();
                    iUser++;
                    if (!Lock || user.Aquire())
                    {
                        break;
                    }
                    else
                    {
                        q.Enqueue(user);
                        user = null;
                    }
                }
            }
            return user;
        }

        /// <summary>
        /// Gets the requested number of users from the desired queue. If there are not enough, null is returned.
        /// </summary>
        private static StressUser[] GetUser(QueueTypes type, ushort NumUsers, bool Lock)
        {
            Queue q = null;
            switch (type)
            {
                case QueueTypes.OFFLINE:
                    q = OfflineUsers;
                    break;
                case QueueTypes.ONLINE:
                    q = OnlineUsers;
                    break;
                case QueueTypes.BUDDYREQUESTOR:
                    q = BuddyRequestorUsers;
                    break;
                case QueueTypes.BUDDYREQUESTED:
                    q = BuddyRequestedUsers;
                    break;
                case QueueTypes.BUDDYACCEPTED:
                    q = BuddyAcceptedUsers;
                    break;
                case QueueTypes.BLOCKED:
                    q = BlockedUsers;
                    break;
            }

            StressUser[] users = new StressUser[NumUsers];
            int iUser = 0;
            int iFoundUser = 0;
            int startingCount = q.Count;

            if (NumUsers > startingCount)
                return null;

            while (q.Count > 0 && iFoundUser < NumUsers && iUser < startingCount)
            {
                StressUser user = GetUser(type, Lock);
                iUser++;
                if (user != null)
                {
                    users[iFoundUser] = user;
                    iFoundUser++;
                }
            }
            if (iFoundUser < NumUsers)
            {
                lock (q.SyncRoot)
                {
                    for (int i = 0; i < iFoundUser; i++)
                    {
                        StressUser user = users[i];
                        q.Enqueue(user);
                        if (Lock)
                            user.Release();
                    }
                    users = null;
                }
            }
            return users;
        }
        #endregion

        #region Queue Counts
        /// <summary>
        /// Returns the count of offline users
        /// </summary>
        public static int OfflineUserQueueCount
        {
            get
            {
                lock (OfflineUsers.SyncRoot)
                {
                    return OfflineUsers.Count;
                }
            }
        }

        /// <summary>
        /// Returns the count of online users
        /// </summary>
        public static int OnlineUserQueueCount
        {
            get
            {
                lock (OnlineUsers.SyncRoot)
                {
                    return OnlineUsers.Count;
                }
            }
        }

        /// <summary>
        /// Returns the count of blocked users
        /// </summary>
        public static int BlockedUserQueueCount
        {
            get
            {
                lock (BlockedUsers.SyncRoot)
                {
                    return BlockedUsers.Count;
                }
            }
        }

        /// <summary>
        /// Returns the count of buddyrequestor users
        /// </summary>
        public static int BuddyRequestorUserQueueCount
        {
            get
            {
                lock (BuddyRequestorUsers.SyncRoot)
                {
                    return BuddyRequestorUsers.Count;
                }
            }
        }

        /// <summary>
        /// Returns the count of buddyrequested users
        /// </summary>
        public static int BuddyRequestedUserQueueCount
        {
            get
            {
                lock (BuddyRequestedUsers.SyncRoot)
                {
                    return BuddyRequestedUsers.Count;
                }
            }
        }

        /// <summary>
        /// Returns the count of buddyaccepted users
        /// </summary>
        public static int BuddyAcceptedUserQueueCount
        {
            get
            {
                lock (BuddyAcceptedUsers.SyncRoot)
                {
                    return BuddyAcceptedUsers.Count;
                }
            }
        }
        #endregion
        public static void ReinitializedQueues()
        {
            bool allClear = false;
            int i = 1;
            while (! allClear)
            {
                Global.RO.Debug("Clearing queues, try " + i);
                lock (BuddyRequestorUsers.SyncRoot)
                {
                    BuddyRequestorUsers.Clear();
                }

                lock (BuddyRequestedUsers.SyncRoot)
                {
                    BuddyRequestedUsers.Clear();
                }

                lock (BuddyAcceptedUsers.SyncRoot)
                {
                    BuddyAcceptedUsers.Clear();
                }

                lock (BlockedUsers.SyncRoot)
                {
                    BlockedUsers.Clear();
                }

                lock (OfflineUsers.SyncRoot)
                {
                    OfflineUsers.Clear();
                }

                lock (OnlineUsers.SyncRoot)
                {
                    OnlineUsers.Clear();
                }

                if (BuddyRequestorUsers.Count != 0 || BuddyRequestedUsers.Count != 0 || BuddyAcceptedUsers.Count != 0 || BlockedUsers.Count != 0 || OfflineUsers.Count != 0 || OnlineUsers.Count != 0)
                    allClear = false;
                else
                    allClear = true;
                i++;
            }

            //Clear all xboxes.
            ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.ClearXboxes();

            Initialize();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\setupstress\main.cs ===
//
// SetupStress: utility to create the stress configuration in the testing network
//
//
using System;
using System.Globalization;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using xonline.common.config;

namespace SetupStress
{
	public class ConsoleApp
	{
		// Constants to configure the setup
		const uint kTitleCount         = 16;
		const uint kBaseXenonTitleId   = 0x22000000;
		const uint kModeCount          = 4;
		const uint kPropertyCount      = 4;
		const uint kContextCount       = 4;
		const uint kContextValueCount  = 4;

		
		[STAThread]
		public static void Main(string []args)
		{
			try
			{

				// Route all reports form the root to debug output and consoleX
				ServerTestFramework.Report.GetRoot().AddReportDestination(new DebugOutputReportDestination());
				ServerTestFramework.Report.GetRoot().AddReportDestination(new ConsoleReportDestination());

				ConsoleX.WriteLine(CC.WHITE, "Starting stress setup...");

                if(args.Length < 1)
                {
                    ConsoleX.WriteLine("First parameter must be 'titleconfig' or 'populatefriends'");
                    goto done;
                }

                if(args[0] == "titleconfig")
                {
				    InitServerTestFramework(false);
				    Global.RO.Debug("Configuring {0} titles", kTitleCount);
				    for(uint titleId = kBaseXenonTitleId; titleId < kBaseXenonTitleId + kTitleCount; ++titleId)
				    {
					    SetupTitle(titleId);
				    }
				    Global.RO.Debug("Flushing presence FD configuration");
				    Global.XEnv.ExecuteXmgmtCommand(Interface.xpnfd_presence, "e :xpnfd configcacherefresh");
                }
                else if(args[0] == "populatefriends")
                {
                    if(args.Length < 3)
                    {
                        ConsoleX.WriteLine("populatefriends requires three parameters: basepuid, count and average list size");
                        goto done;
                    }

                    ulong basePuid  =  0;
                    uint count      = 0;
                    uint listSize   = 0;


                    if(0 == args[1].IndexOf("0x"))
                    {
                        basePuid = (ulong)UInt64.Parse(args[1].Substring(2), NumberStyles.HexNumber);
                    }
                    else
                    {
                        basePuid = (ulong)UInt64.Parse(args[1]);
                    }

                    count = (uint)UInt32.Parse(args[2]);
                    listSize = (uint)UInt32.Parse(args[3]);

                    InitServerTestFramework(true);
                    PopulateFriends(basePuid, count, listSize);
                }
                else
                {
                    ConsoleX.WriteLine("unrecogonized command specified");
                }
			}
			catch(Exception ex)
			{
				Console.WriteLine("Exception during excecution: " + ex.ToString());
			}
done:
            return;
		}

		static void InitServerTestFramework(bool useUodb)
		{
            ConsoleX.WriteLine(CC.GRAY, "Initializing STF framework...");

            XmlDocument config = new XmlDataDocument();

            try
            {
                config.Load("stf.xml");
            }
            catch (System.IO.FileNotFoundException ex)
            {
                throw new Exception("Error: Unable to find config file \"stf.xml\" in the current directory.", ex);
            }

            Global.Initialize(config);
		}



		// This could be better factored out of the functional test suite FuncRichPresenceFormatting
		static void SetupTitle(uint titleId)
		{
			PresenceTitleConfig config = new PresenceTitleConfig((int)titleId);
			
			SetupPresenceModes(config);
			SetupContexts(config);

			//Global.RO.Debug(config.BuildXml());
			config.WriteToDatabase(true);

			Global.RO.Debug("Finished writing title: " + titleId.ToString("x") + " to database");
		}

		static void SetupPresenceModes(PresenceTitleConfig config)
		{
			string []modeStrings = 
			{
				" 0 ["+config.TitleId.ToString("x8") + "]: {c0x" + GIContext.GAME_MODE.ToString("X8") + "} {p0x10000000}: {p0x40000001} {p0x10000002} ({c0x00000000}, {c0x00000001}, {c0x00000002}, {c0x00000003}) ({p0x50000003})", // Game mode, user index, name, touches
				" 1 ["+config.TitleId.ToString("x8") + "]: {c0x" + GIContext.GAME_MODE.ToString("X8") + "} {p0x10000000}: {p0x40000001} {p0x10000002} ({c0x00000000}, {c0x00000001}, {c0x00000002}, {c0x00000003}) ({p0x50000003})", // Game mode, user index, name, touches
				" 2 ["+config.TitleId.ToString("x8") + "]: {c0x" + GIContext.GAME_MODE.ToString("X8") + "} {p0x10000000}: {p0x40000001} {p0x10000002} ({c0x00000000}, {c0x00000001}, {c0x00000002}, {c0x00000003}) ({p0x50000003})", // Game mode, user index, name, touches
				" 3 ["+config.TitleId.ToString("x8") + "]: {c0x" + GIContext.GAME_MODE.ToString("X8") + "} {p0x10000000}: {p0x40000001} {p0x10000002} ({c0x00000000}, {c0x00000001}, {c0x00000002}, {c0x00000003}) ({p0x50000003})", // Game mode, user index, name, touches
			};


			// Create the presence format modes
			for(uint i = 0; i < kModeCount; ++i)
			{
				string strValue = modeStrings[i];
				PresenceMode mode = config.AddPresenceMode(i, config.AddDefaultLocalizedString(config.DefaultLocale + strValue)); 
				Localize(config, mode.StringId, strValue);
				
			}
		}

		static void SetupContexts(PresenceTitleConfig config)
		{
			// Create the special game type context
			Context modeContext = config.AddGameMode(GIContext.GAME_MODE, config.AddDefaultLocalizedString("-GAME_MODE_NAME-"+GIContext.GAME_MODE.ToString("X")));

			for(uint contextValueId = 0; contextValueId < kContextValueCount; ++contextValueId)
			{
				string strValue = "GAME_MODE-" + contextValueId;

				ContextValue modeContextValue = modeContext.AddContextValue(contextValueId, config.AddDefaultLocalizedString(config.DefaultLocale + strValue)); 
				Localize(config, modeContextValue.StringId, strValue);
			}
			
			// Create the context ids
			for(uint contextId = 0; contextId < kContextCount; ++contextId)
			{
				Context context = config.AddContext(contextId, config.AddDefaultLocalizedString("CONTEXT_NAME-" + contextId));

				for(uint contextValueId = 0; contextValueId < kContextValueCount; ++contextValueId)
				{
					string strValue = "-ContextValue" + contextId + "." + contextValueId;
					ContextValue contextValue = context.AddContextValue(contextValueId, config.AddDefaultLocalizedString(config.DefaultLocale + strValue));
					Localize(config, contextValue.StringId, strValue);
				}
			}
		}

		static void Localize(PresenceTitleConfig config, uint stringId, string strValue)
		{
			// Add values for each locale
			foreach(PresenceTitleConfig.LocaleSpec spec in PresenceTitleConfig.LocaleTable)
			{
				if(spec.Locale == config.DefaultLocale || !spec.Supported)
				{
					continue;
				}

				config.AddLocalizedString(stringId, spec.Locale, spec.Locale + strValue);
			}
		}


        
        static void PopulateFriends(ulong basePuid, uint count, uint listSize)
        {
            Global.RO.Debug("Populate friends, basepuid: {0:x}, count: {1}, listsize: {2}", basePuid, count, listSize);

            for(uint i = 0; i < count; ++i)
            {
                // Exec load offline to get friend data

                ulong userPuid = basePuid + count;
                FriendRecord []friends = UodbWS.LoadFriends(userPuid);

                foreach(FriendRecord fr in friends)
                {
                    Global.RO.Debug("Skipping {0:x}:{1:x} friendship", userPuid, fr.BuddyId);
                }
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\ConnectionMgr.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2002 Microsoft.  ALL RIGHTS RESERVED
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Connection.h"
#include "ServerPool.h"
#include "MsgBuilder.h"

// Forward Declaration
class XPQTask;
class XPQUser;
class INHConnection;

//------------------------------------------------------------------------------
// SG Auth port mappings, port map maps to slot info, users aquire slots
// and hold the index to the slot in their SPI. When the user logs off
// they may release their slot back into the pool.
//------------------------------------------------------------------------------
struct XPQSlotInfo
{
    DWORD                  dwNextSPI;
    DWORD                  dwSPI;
    DWORD                  dwAquired;
    DWORD                  dwLastSentAuth;
    DWORD                  dwLastSentQVal;
    DWORD                  dwMapped;
    BOOL                   fValid;
    BOOL                   fKicked;
    WORD                   wPort;
    XBOX_LIBRARY_VERSION   clientVersion;
    QWORD                  qwXboxId;
    DWORD                  dwAuthDataFlags;
    DWORD                  dwTitleId;
    DWORD                  dwTitleVersion;
    DWORD                  dwTitleRegion;
    DWORD                  dwAltTitleIds[4];
    WORD                   wNumDwordServices;
    DWORD                  dwPrivileges[1]; // [XONLINE_NUM_PRIVILEGE_DWORDS];
    WORD                   wLanguageId;
    WORD                   wcUsers;
    QWORD                  rgqwUserIDs[4];
    DWORD                  rgdwUserFlags[4];

    inline void            SetXenonDefaults()
    {
        dwAuthDataFlags  = 1; // XENON CLIENT
        dwTitleVersion   = 1;   
        dwPrivileges[0]  = 0xff;
        wLanguageId      = 1;
    }

    inline void            SetXboxDefaults()
    {
        dwAuthDataFlags  = 0; // XBOX CLIENT
        dwTitleVersion   = 1;
        dwPrivileges[0]  = 0xff;
        wLanguageId      = 1;
    }
};

//
// Taken from SGInfo.Init()
//
// Defaults for xenon
//
struct XPQHttpAuthData
{
    // Initial header
    WORD    wBundledAuthDataVersion;
    WORD    wPortI;
    DWORD   dwAddrI;
    QWORD   qwNonce;

    WORD    wAuthDataVersion;
    WORD    wAuthDataSize;
    WORD    wMajorVersion;
    WORD    wMinorVersion;
    WORD    wBuildNumber;
    WORD    wQfeNumber;
    DWORD   dwTitleID;
    DWORD   dwTitleVersion;
    DWORD   dwTitleRegion;
    DWORD   dwConsoleRegion;
    DWORD   dwMediaID;
    WORD    wLanguageID;
    DWORD   dwAuthDataFlags;
    WORD    wNumPrivileges;
    DWORD   dwPrivileges[XONLINE_NUM_PRIVILEGE_DWORDS];
    QWORD   qwXboxID;
    XUID    rgXUIDs[XONLINE_MAX_LOGON_USERS];
    float   rgUserTrustRatings[XONLINE_MAX_LOGON_USERS];
    WORD    wNumDwordServices;
    DWORD   dwServiceIDs[XONLINE_MAX_DWORD_SERVICEIDS];
    DWORD   dwAltTitleIDs[XONLINE_MAX_ALTERNATE_TITLE_ID];
    BYTE    rgbKey[XONLINE_KEY_LENGTH];


    void Initialize(const XPQSlotInfo &slot);
    
};

//------------------------------------------------------------------------------
// Delayed SG Response
//------------------------------------------------------------------------------

typedef struct _SG_RESPONSE
{
    DWORD       dwResponseTime;
	DWORD       dwResSize;
	BYTE*       pbResBuffer; 
	sockaddr_in saReplyTo;
} SG_RESPONSE, *PSG_RESPONSE;

//------------------------------------------------------------------------------
// XPQ Connection Manager
//
//  Manages:
//      Persistent TCP connections to all presence 
//          and notificaton in house servers and msg
//          proccessing threads that allow them to be
//          shared.
//      TCP transactions with the PN Front door
//      A thread to do UDP exchanges for auth and QVALs
//------------------------------------------------------------------------------
class XPQConnectionMgr
{
public:


    static XPQConnectionMgr* GetPtr() 
    { 
        _ASSERTE(ms_pConnMgr); 
        return ms_pConnMgr; 
    }

    XPQConnectionMgr();
    ~XPQConnectionMgr();

    HRESULT Create( HANDLE hStopEvent, DWORD dwMaxSPI );
    void Destroy();
	void Heartbeat();
    bool ResumeThreads();
    void WaitForThreads();

    const XPQSgAddr& GetDefSgAddr() { return m_DefSgAddr; } 
   
    enum EService { ePresence, eNotification, eMessaging, eTeams };

    bool TransactFD(
        XPQTask* pTask,
        XPQMsg*  pMsg, 
        XPQUser* pUser,
        BYTE*    pbReplyBuf,
        DWORD    dWReplyBufSize,
        DWORD*   pdwReplyLen,
        WORD     wPort );

    // Send a synchronous message to the INH cluster. If the user 
    // is not provided it will be sent to all servers.
    HRESULT SendToInh( XPQMsg* pMsg, XPQUser* pUser = 0);
	INHConnection *GetINHConnection();
    DWORD QValTimeOut() const;

    DWORD FDIP() const { return m_dwFDIP; }

    //------------------------------------------------------------------------------
    // Slot management
    //------------------------------------------------------------------------------
    
    // Enable the slot and map the port in the request to the SPI
    HRESULT EnableAndMapSlot( DWORD dwSPI, DWORD dwSlotIndex, ULONGLONG qwUserId, sockaddr_in* pSin );
    HRESULT DisableAndUnmapSlot( WORD wPortH );
    
    HRESULT AquireSlot(XPQUser *pUser);
    HRESULT ReleaseSlot(DWORD dwSPI);
    HRESULT RemoveUserFromSlot(const XPQUser *pUser);
    HRESULT ReleaseSlotIfEmpty(DWORD dwSPI);
    HRESULT GetSlotInfo(DWORD dwSPI, XPQSlotInfo &outSlotInfo);

    //------------------------------------------------------------------------------
    // Stats
    //------------------------------------------------------------------------------
    void SetStatistics(float fQValRate, float fAuthRate, float fKickRate, float fTotalRate)
    {
        m_fQValRate  = fQValRate;
        m_fAuthRate  = fAuthRate;
        m_fKickRate  = fKickRate;
        m_fTotalRate = fTotalRate;
    }
    void LogStats() const;

    //------------------------------------------------------------------------------
    // QVal access
    //------------------------------------------------------------------------------
    LockFreeFifo<SGQVal> &GetQValPacketQueue() { return m_qvalPacketQueue; }

    //------------------------------------------------------------------------------
    // Delayed SG Responses access
    //------------------------------------------------------------------------------
    LockFreeFifo<PSG_RESPONSE> &GetSGResponseQueue() { return m_sgResponseQueue; }
	UDPConnection* GetUDPConnection() { return m_pSGConnection; }
	DWORD          GetSGSendDelay()   { return m_dwSGSendDelay; }
	void           SetSGSendDelay(DWORD dwSendDelay);

    void SetDisableQVals(bool bDisable);
        
private:
    
    // Constants
    enum { 
        kFDBufSize         = 8192,
        kConnOpTimeout     = 30000,
        kAuthPortArraySize = 65000,
    };

    // pointer to singleton instance.
    static XPQConnectionMgr* ms_pConnMgr;
    static bool ms_bDisableQVals;

    XPQConnectionMgr( const XPQConnectionMgr& );            // No implementaion
    XPQConnectionMgr& operator=( const XPQConnectionMgr& ); // No implementaion

    // Builds and sends Dead SG messages directly to all INH servers 
    HRESULT SendDeadSG();

    // Thread for FakeSG
    UDPConnection* m_pSGConnection;
    static unsigned __stdcall SGMsgReceiveThreadFunc( void* );
    static unsigned __stdcall SGMsgSendThreadFunc( void* );

    // Thread for STF control protocol
    static unsigned __stdcall STFMsgThreadFunc( void* );
    static HRESULT __stdcall SendControlRegisterMessage( UDPConnection *pConn, BYTE *pbBuffer, DWORD dwDestAddr, WORD wPort, DWORD dwMsgType, DWORD dwState );

    // Initializes Server Pools
    static CServerPool* InitServerPool(
        HANDLE hStopEvent,
        WORD   wCount,
        char*  pszBaseName );

    //------------------------------------------------------------------------------
    // Begin member variables
    //------------------------------------------------------------------------------
    
    // Global stop event handle
    HANDLE         m_hStopEvent;

    // Flag indicates if the threads have been resumed 
    bool           m_bRunning;

    WORD           m_wThreads;
    HANDLE         m_ahThreads[ 4 ];

    // Local IP address we use to pretend to be the SG
    DWORD         m_dwSGIP;

    // IP Address to use for STF control messages
    DWORD         m_dwSTFCIP;
    WORD          m_wSTFCPort;

    // Standard SGADDR
    XPQSgAddr     m_DefSgAddr; 

    // VIP IP of FD server
    DWORD         m_dwFDIP;

    // INH server pool wrapper
    CServerPool*  m_pServerPool;
	INHConnection *m_pINHConnection;

    // SG Handler stats
    DWORD         m_cSpiRequests;
    DWORD         m_cQValRequests;

    // UDP messaging stats
    float         m_fQValRate;
    float         m_fAuthRate;
    float         m_fKickRate;
    float         m_fTotalRate;
    
    DWORD            m_rgdwPortMap[kAuthPortArraySize]; 
    XPQSlotInfo*     m_rgSlotInfo;
    DWORD            m_dwNextSPI;
    DWORD            m_dwNumSPI;
    DWORD            m_dwMaxSPI;
    CRITICAL_SECTION m_csSlotInfo;

#define AUTHENTER() EnterCriticalSection(&m_csSlotInfo);
#define AUTHLEAVE() LeaveCriticalSection(&m_csSlotInfo);

#define INVALID_SPI            0x00ffffff
#define INVALID_SPI_SLOT_INDEX 0x000000ff

#define QVAL_PACKET_QUEUE_SIZE 16 * 1024
#define SG_RESPONSE_QUEUE_SIZE 5 * 1024
    // Queue to pass qvals from connmgr thread to scheduler
    LockFreeFifo<SGQVal> m_qvalPacketQueue;

	// delayed SG Responses
	LockFreeFifo<PSG_RESPONSE> m_sgResponseQueue;
	DWORD					   m_dwSGSendDelay;
};

extern XPQConnectionMgr* gpConnMgr;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\DetailsBuilder.cpp ===
#include "stdafx.h"

DetailsBuilder::DetailsBuilder()
{
    m_wcProperties = 0;
    m_wcbPropertyData = 0;
}

DetailsBuilder::~DetailsBuilder()
{
}

HRESULT DetailsBuilder::_CheckAdd(BYTE bType, WORD wcBytes)
{
    HRESULT hr = S_OK;

    if(m_wcProperties == kMaxProperties)
    {
        hr = E_FAIL;
        goto lbDone;
    }
    

    // We only append to property data when the byte count doesn't fit into 
    // the message property or it's a variable type like binary or string
    if(bType > XONLINE_MSG_PROP_TYPE_I2)
    {
        if(wcBytes + m_wcbPropertyData > kMaxPropertyData)
        {
            hr = E_FAIL;
            goto lbDone;
        }
    }
lbDone:
    return hr;
}

HRESULT DetailsBuilder::AddBYTE(BYTE bId, BYTE bData)
{
    HRESULT hr = S_OK;

    if(FAILED(hr = _CheckAdd(XONLINE_MSG_PROP_TYPE_I1, 1)))
    {
        goto lbDone;
    }

    m_rgProperties[m_wcProperties++] = MsgProperty(XONLINE_MSG_PROP_TYPE_I1, bId, (WORD)bData);

lbDone:
    return hr;
}

HRESULT DetailsBuilder::AddWORD(BYTE bId, WORD wData)
{
    HRESULT hr = S_OK;

    if(FAILED(hr = _CheckAdd(XONLINE_MSG_PROP_TYPE_I2, 2)))
    {
        goto lbDone;
    }

    m_rgProperties[m_wcProperties++] = MsgProperty(XONLINE_MSG_PROP_TYPE_I2, bId, wData);

lbDone:
    return hr;
}

HRESULT DetailsBuilder::AddDWORD(BYTE bId, DWORD dwData)
{
    HRESULT hr = S_OK;

    if(FAILED(hr = _CheckAdd(XONLINE_MSG_PROP_TYPE_I4, 4)))
    {
        goto lbDone;
    }

    m_rgProperties[m_wcProperties++] = MsgProperty(XONLINE_MSG_PROP_TYPE_I4, bId, m_wcbPropertyData);
    memcpy((void*)m_rgbPropertyData[m_wcbPropertyData], &dwData, sizeof(dwData));
    m_wcbPropertyData += sizeof(dwData);

lbDone:
    return hr;
}

HRESULT DetailsBuilder::AddULONGLONG(BYTE bId, ULONGLONG qwData)
{
    HRESULT hr = S_OK;

    if(FAILED(hr = _CheckAdd(XONLINE_MSG_PROP_TYPE_I8, 8)))
    {
        goto lbDone;
    }

    m_rgProperties[m_wcProperties++] = MsgProperty(XONLINE_MSG_PROP_TYPE_I8, bId, m_wcbPropertyData);
    memcpy((void*)m_rgbPropertyData[m_wcbPropertyData], &qwData, sizeof(ULONGLONG));
    m_wcbPropertyData += sizeof(ULONGLONG);

lbDone:
    return hr;
}

HRESULT DetailsBuilder::AddDateTime(BYTE bId, ULONGLONG qwData)
{
    HRESULT hr = S_OK;

    if(FAILED(hr = _CheckAdd(XONLINE_MSG_PROP_TYPE_FILETIME, 8)))
    {
        goto lbDone;
    }

    m_rgProperties[m_wcProperties++] = MsgProperty(XONLINE_MSG_PROP_TYPE_FILETIME, bId, (WORD)m_wcbPropertyData);
    memcpy((void*)m_rgbPropertyData[m_wcbPropertyData], &qwData, sizeof(ULONGLONG));
    m_wcbPropertyData += sizeof(ULONGLONG);

lbDone:
    return hr;
}

HRESULT DetailsBuilder::_AddVariableType(BYTE bType, BYTE bId, const BYTE *pbData, WORD wcbData)
{
    HRESULT hr = S_OK;

    if(bType < 6)
    {
        // The type is a value type should not variable
        hr = E_FAIL;
        goto lbDone;
    }

    if(FAILED(hr = _CheckAdd(bType, wcbData)))
    {
        goto lbDone;
    }

    m_rgProperties[m_wcProperties++] = MsgProperty(bType, bId, (WORD)m_wcbPropertyData);

    // Write the property data length marker
    memcpy((void*)m_rgbPropertyData[m_wcbPropertyData], &wcbData, sizeof(WORD));
    m_wcbPropertyData += sizeof(WORD);

    // Write the binary property data
    memcpy((void*)m_rgbPropertyData[m_wcbPropertyData], pbData, wcbData);
    m_wcbPropertyData += wcbData;

lbDone:
    return hr;
}

HRESULT DetailsBuilder::AddBinary(BYTE bId, const BYTE *pbData, WORD wcbData)
{
    return _AddVariableType(XONLINE_MSG_PROP_TYPE_BINARY, bId, pbData, wcbData);    
}

HRESULT DetailsBuilder::AddString(BYTE bId, const BYTE *pbData, WORD wcbData)
{
    return _AddVariableType(XONLINE_MSG_PROP_TYPE_STRING, bId, pbData, wcbData);
}

HRESULT DetailsBuilder::AddAttachment(BYTE bId, DWORD dwcbAttach, DWORD dwFlags, const BYTE *pbUrl, DWORD dwcbUrl)
{
    HRESULT hr = S_OK;

    if(pbUrl == 0 || dwcbUrl == 0)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    MsgPropertyAttachment attach;

    attach.dwcbAttach = dwcbAttach;
    attach.dwFlags    = dwFlags;
    attach.dwUrlLen   = dwcbUrl;

	// Check for overflow
	if( ((sizeof(MsgPropertyAttachment) + dwcbUrl) & 0xFFFF0000) != 0)
	{
		hr = E_INVALIDARG;
		goto lbDone;
	}

    if(FAILED(hr = _CheckAdd(XONLINE_MSG_PROP_TYPE_ATTACHMENT, (WORD)(sizeof(MsgPropertyAttachment) + dwcbUrl))))
    {
        goto lbDone;
    }

    m_rgProperties[m_wcProperties++] = MsgProperty(XONLINE_MSG_PROP_TYPE_ATTACHMENT, bId, m_wcbPropertyData);

    // Write attachment header
    memcpy((void*)m_rgbPropertyData[m_wcbPropertyData], &attach, sizeof(MsgPropertyAttachment));
    m_wcbPropertyData += sizeof(MsgPropertyAttachment);

    // Write attachment URL
    memcpy((void*)m_rgbPropertyData[m_wcbPropertyData], pbUrl, dwcbUrl);
    m_wcbPropertyData += (WORD)dwcbUrl;

lbDone:
    return hr;
}

DWORD   DetailsBuilder::CalculatePayloadSize() const
{
    DWORD cbData = 0;   

    // Details header (property count, property data bytes);
    cbData += 4; 

    // Details property bundle
    cbData += m_wcProperties * sizeof(MsgProperty);

    // Details data
    cbData += m_wcbPropertyData;


    return cbData;
}


HRESULT DetailsBuilder::Serialize(BYTE *pbDest, /*INOUT*/ DWORD *pdwcbDest)
{
    HRESULT hr = E_FAIL;

    // Check our arguments
    if(0 == pbDest || pdwcbDest == 0 || *pdwcbDest == 0)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    // Make sure we can fit our payload into the destination
    DWORD dwCalcSize = CalculatePayloadSize();
    if(dwCalcSize > *pdwcbDest)
    {
        hr = E_OUTOFMEMORY;
        goto lbDone;
    }

    DWORD dwcBytes = 0;

    // First write our details header
    memcpy((void*)pbDest, &m_wcProperties, sizeof(WORD));
    dwcBytes += sizeof(WORD);

    memcpy((void*)(pbDest + dwcBytes), &m_wcbPropertyData, sizeof(WORD));
    dwcBytes += sizeof(WORD);

    // Write the property bundle
    for(WORD wi = 0; wi < m_wcProperties; ++wi)
    {
        memcpy((void*)(pbDest + dwcBytes), (const void*)&m_rgProperties[wi], sizeof(MsgProperty));
        dwcBytes += sizeof(MsgProperty);
    }

    // Write the property data block
    memcpy((void*)pbDest, m_rgbPropertyData, m_wcbPropertyData);
    dwcBytes += m_wcbPropertyData;

    *pdwcbDest = dwcBytes;

    // Everything worked
    hr = S_OK;

lbDone:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\ConnectionMgr.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2002 Microsoft.  ALL RIGHTS RESERVED
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#define XENON_AUTH 1
#define XENON_CLIENT_VERSION 8395

#define SG_AUTH_RESP_SZ sizeof( CSgMsgSpiRep ) + sizeof( CSgMsgSpiData ) + sizeof( CSgMsgHdr ) + sizeof( CAuthData3 )

///////////////////////////////////////////////////////////
// XPQ Connection Manager
///////////////////////////////////////////////////////////

// Pointer to singleton instance
XPQConnectionMgr* XPQConnectionMgr::ms_pConnMgr = NULL;
bool XPQConnectionMgr::ms_bDisableQVals = false;
XPQConnectionMgr* gpConnMgr = NULL;
XPQSlotInfo       NotFoundSlotInfo;

// Ini File Settings
MGMT_DefineConfigSetting( ConnectionMgr, QValTimeOut );

MGMT_DefineConfigSetting( ConnectionMgr, ServerPoolSendBuffers );
MGMT_DefineConfigSetting( ConnectionMgr, ServerPoolSendBuffSize );

MGMT_DefineConfigSetting( ConnectionMgr, SGSendDelay );

MGMT_DefineConfigSetting( ConnectionMgr, FDRecvBufferSize );
MGMT_DefineConfigSetting( ConnectionMgr, FDRecvTimeOut );
MGMT_DefineConfigSetting( ConnectionMgr, FDConnectTimeOut );

MGMT_DefineConfigSetting( ConnectionMgr, NumPresInh );   
MGMT_DefineConfigSetting( ConnectionMgr, NumNotiInh );   
MGMT_DefineConfigSetting( ConnectionMgr, NotiInhPortFromPresInh );

MGMT_DefineConfigSetting( ConnectionMgr, FDVIP );   
MGMT_DefineConfigSetting( ConnectionMgr, FDPortForPresNoti );
MGMT_DefineConfigSetting( ConnectionMgr, FDPortForMessaging );
MGMT_DefineConfigSetting( ConnectionMgr, FDPortForTeams );
MGMT_DefineConfigSetting( ConnectionMgr, FDPortForDataCenter );

MGMT_DefineConfigSetting( ConnectionMgr, STFControlServerIP );
MGMT_DefineConfigSetting( ConnectionMgr, STFControlServerPort );

MGMT_DefineLoggingCategory( ConnMgr );

//------------------------------------------------------------------------------ 
// Setup a http auth data structure based on the slot info
//------------------------------------------------------------------------------ 
void XPQHttpAuthData::Initialize(const XPQSlotInfo &slot)
{
    WORD wi;
    DWORD dwi;

    wBundledAuthDataVersion = 3;
    wPortI                  = slot.wPort;
    dwAddrI                 = gpConnMgr->GetDefSgAddr().IP();
    qwNonce                 = 0;

    wAuthDataVersion        = XONLINE_XENON_AUTHDATA_VERSION;
    wAuthDataSize           = 0;

    wMajorVersion           = slot.clientVersion.wMajorVersion;
    wMinorVersion           = slot.clientVersion.wMinorVersion;
    wBuildNumber            = slot.clientVersion.wBuildNumber;
    wQfeNumber              = slot.clientVersion.wQFENumber;

    dwTitleID               = slot.dwTitleId;
    dwTitleVersion          = slot.dwTitleVersion;
    dwTitleRegion           = slot.dwTitleRegion;
    dwConsoleRegion         = slot.dwTitleRegion;
    dwMediaID               = 0;
    wLanguageID             = slot.wLanguageId;
    dwAuthDataFlags         = slot.dwAuthDataFlags;

    wNumPrivileges          = XONLINE_NUM_PRIVILEGE_DWORDS;
    dwPrivileges[0]         = slot.dwPrivileges[0];
    for(wi = 1; wi < XONLINE_NUM_PRIVILEGE_DWORDS; ++wi)
    {
        dwPrivileges[wi] = 0;
    }

    qwXboxID                = slot.qwXboxId;

    for (wi = 0; wi < XONLINE_MAX_LOGON_USERS; wi++)
    {
        rgXUIDs[wi].qwUserID      = slot.rgqwUserIDs[wi];
        rgXUIDs[wi].dwUserFlags   = slot.rgdwUserFlags[wi];
        rgUserTrustRatings[wi]    = 0.0f;
    }

    wNumDwordServices = 0;
    for (dwi = 0; dwi < XONLINE_MAX_DWORD_SERVICEIDS; dwi++)
    {
        dwServiceIDs[dwi] = 0;
    }

    for (dwi=0; dwi < XONLINE_MAX_ALTERNATE_TITLE_ID; dwi++)
    {
        dwAltTitleIDs[dwi] = slot.dwAltTitleIds[dwi]; 
    }

    for(dwi = 0; dwi < XONLINE_KEY_LENGTH; dwi++)
    {
        rgbKey[dwi] = 0;
    }
}

//------------------------------------------------------------------------------
// Begin connection manager implementation
//------------------------------------------------------------------------------
XPQConnectionMgr::XPQConnectionMgr() 
:
    m_hStopEvent( INVALID_HANDLE_VALUE ),
    m_bRunning(false),
    m_wThreads( 0 ),
    m_dwSGIP( INADDR_NONE ),
    m_DefSgAddr(),
    m_dwFDIP( INADDR_NONE ),
    m_pServerPool( NULL ),
    m_cSpiRequests(0),
    m_cQValRequests(0),
    m_dwNextSPI(INVALID_SPI),
    m_dwNumSPI(0),
    m_fQValRate(0),
    m_fAuthRate(0),
    m_fKickRate(0),
    m_fTotalRate(0),
	m_pSGConnection(NULL)
{
    memset( m_ahThreads, 0, sizeof( m_ahThreads ) );

    if(NULL == ms_pConnMgr)
    {
        ms_pConnMgr = this;
        gpConnMgr = this;
    }
}

XPQConnectionMgr::~XPQConnectionMgr()
{
    if(this == ms_pConnMgr)
    {
        ms_pConnMgr = NULL;
        gpConnMgr = 0;
    }
    Destroy();
}

// Startup all internal state and threads
HRESULT XPQConnectionMgr::Create( HANDLE hStopEvent, DWORD dwMaxSPI )
{
    HRESULT hr;
    TCPClientConnection *pFDConn = 0;

    _ASSERTE(INVALID_HANDLE_VALUE != hStopEvent);
    m_hStopEvent = hStopEvent;

    // Setup the dummy slotinfo
    ZeroMemory(&NotFoundSlotInfo, sizeof(XPQSlotInfo));
    
    // Bring winsock up
    WinsockUP();

    // Create enough buffer so that we don't backlog the queue
    if(FAILED(hr = m_qvalPacketQueue.Create(QVAL_PACKET_QUEUE_SIZE)))
    {
        ERR1(ConnMgr, "[XPQConnectionMgr::Create]: failed to create packet queue, hr: 0x%08x", hr);
        goto lbDone;
    }

	// Set up the SG Response Delay
    m_dwSGSendDelay = MGMT_GetConfigSetting(ConnectionMgr, SGSendDelay).GetDWORD();

	// Create enough buffer so that we don't backlog the queue
    if(FAILED(hr = m_sgResponseQueue.Create(SG_RESPONSE_QUEUE_SIZE)))
    {
        ERR1(ConnMgr, "[XPQConnectionMgr::Create]: failed to create sg send queue, hr: 0x%08x", hr);
        goto lbDone;
    }

    // Zero out the slot map and initialize the links
    m_dwMaxSPI   = dwMaxSPI;
    m_rgSlotInfo = new XPQSlotInfo[m_dwMaxSPI];
    if(0 == m_rgSlotInfo)
    {
        hr = E_OUTOFMEMORY;
        ERR2(ConnMgr, "[XPQConnectionMgr::Create]: failed to create slotinfo buffer, size: %u, hr: 0x%08x", 
                m_dwMaxSPI,
                hr);
        goto lbDone;
    }

    ZeroMemory(m_rgSlotInfo, sizeof(XPQSlotInfo) * m_dwMaxSPI);
    for(DWORD dwi = 0; dwi < m_dwMaxSPI-1; ++dwi)
    {
        XPQSlotInfo &slot = m_rgSlotInfo[dwi];

        slot.dwSPI = dwi;
        slot.dwNextSPI = dwi+1;
    }

    XPQSlotInfo &slot = m_rgSlotInfo[m_dwMaxSPI-1];
    slot.dwSPI = m_dwMaxSPI-1;
    slot.dwNextSPI = INVALID_SPI;

    m_dwNextSPI = 0;
    m_dwNumSPI = m_dwMaxSPI;

    // Clear out the port -> slot vector
    memset(m_rgdwPortMap, -1, sizeof(DWORD) * kAuthPortArraySize);

    // Initialize the lock
    InitializeCriticalSection(&m_csSlotInfo);

    // Create Presence server pool
    DWORD dwcServers = MGMT_GetConfigSetting(ConnectionMgr, NumPresInh).GetDWORD();
    TRACE1( ConnMgr, L_NORMAL, "[XPQConnectionMgr::Create]: initialize Presence server pool (%d servers)", dwcServers);
    m_pServerPool = InitServerPool( hStopEvent, (WORD)dwcServers, "PresInh" );
    if( NULL == m_pServerPool )
    {
        hr = E_FAIL;
        ERR0( ConnMgr, "[XPQConnectionMgr::Create] initializing Presence server pool failed" );
        goto lbDone;
    }

    //
    // Get IP of Front Door VIP
    //
    m_dwFDIP = InternetAddress( MGMT_GetConfigSetting(ConnectionMgr, FDVIP).GetLPCSTR() );
    TRACE2( ConnMgr, L_NORMAL, "[XPQConnectionMgr::Create]: setup front door VIP address - '%s' -> 0x%08x",
            MGMT_GetConfigSetting(ConnectionMgr, FDVIP).GetLPCSTR(),
            m_dwFDIP);
    if( m_dwFDIP == INADDR_NONE )
    {
        ERR0( ConnMgr, "[XPQConnectionMgr::Create]: setup front door VIP address failed" );
        hr = E_FAIL;
        goto lbDone;
    }

    // Get the local address that can connect to the front door to determine what address we 
    // should bind to for SG
    pFDConn = new TCPClientConnection();
    hr = pFDConn->Connect(m_dwFDIP, (WORD)(MGMT_GetConfigSetting(ConnectionMgr, FDPortForPresNoti).GetDWORD()), 10000);
    if(FAILED(hr))
    {
        ERR2( ConnMgr, "[XPQConnectionMgr::Create]: could not connect to front door: %s, HR: 0x%08x", 
                MGMT_GetConfigSetting(ConnectionMgr, FDVIP).GetLPCSTR(),
                hr);
        goto lbDone;
    }

    const sockaddr_in *pfdcliAddr = pFDConn->GetSockName();

    //
    // Get our IP to say we're the SG
    //
    m_dwSGIP = pfdcliAddr->sin_addr.S_un.S_addr; // GetLocalAddress();
    TRACE1( ConnMgr, L_HIGH, "[XPQConnectionMgr::Create]: setup our address for acting as SG - '%s'", inet_ntoa( *( (in_addr*)&ms_pConnMgr->m_dwSGIP ) ) );
    if( m_dwSGIP == INADDR_NONE )
    {
        ERR0( ConnMgr, "[XPQConnectionMgr::Create]: setup our address for acting as SG failed" );
        hr = E_FAIL;
        goto lbDone;
    }

    //
    // Set up Shared SGADDR
    //
    m_DefSgAddr.SetIP( ms_pConnMgr->m_dwSGIP );
    unsigned uID = 0;

    // 
    // Get our address for STF control
    //
    m_dwSTFCIP  =  InternetAddress( MGMT_GetConfigSetting(ConnectionMgr, STFControlServerIP).GetLPCSTR() );
    m_wSTFCPort = htons(MGMT_GetConfigSetting(ConnectionMgr, STFControlServerPort).GetWORD());

    // Create UDP connection 
    m_pSGConnection = new UDPConnection( ms_pConnMgr->m_hStopEvent, 1, 1024, 64*1024 ); 
    _ASSERTE( NULL != m_pSGConnection ); 

	// Bind to SG msg Port
    TRACE6(ConnMgr, L_HIGH, "[XPQConnectionMgr::Create]: binding port 0xffff, compiled with: SG_AUTH_RESP_SZ(%d), SGMSG_TYPE_SPIDATA_REQ(Type: %x), SGMSG_TYPE_SPIDATA_REP(Type: %x, Size: %d), SGMSG_TYPE_SPIDATA(Type: %x, Size: %d)", 
            SG_AUTH_RESP_SZ,
            SGMSG_TYPE_SPIDATA_REQ,
            SGMSG_TYPE_SPIDATA_REP,
            sizeof( CSgMsgSpiRep ),
            SGMSG_TYPE_SPIDATA,
            sizeof( CSgMsgSpiData ));

    if( FAILED( hr = m_pSGConnection->Bind( 0xFFFF, 0 ) ) ) //ms_pConnMgr->m_dwSGIP ) ) )
    {
        ERR1( ConnMgr, "[XPQConnectionMgr::SGMsgReceiveThreadFunc]: thread [%d] Failed to bind to port FFFF, sending stop event", 
                GetCurrentThreadId() );
        goto lbDone;
    }

    //
    // Start up Threads
    //
    TRACE0( ConnMgr, L_NORMAL, "[XPQConnectionMgr::Create]: start SG receive message thread" );
    m_ahThreads[m_wThreads] = (HANDLE) _beginthreadex( NULL, 0, &SGMsgReceiveThreadFunc, NULL, CREATE_SUSPENDED, &uID );
    if( NULL == m_ahThreads[m_wThreads] )
    {
        ERR0( ConnMgr, "[XPQConnectionMgr::Create]: start SG receive message thread failed" );
        hr = E_FAIL;
        goto lbDone; 
    }
    else
    {
        SetThreadPriority( m_ahThreads[ m_wThreads ], THREAD_PRIORITY_HIGHEST );
    }
    ++(m_wThreads);


    TRACE0( ConnMgr, L_NORMAL, "[XPQConnectionMgr::Create]: start SG send message thread" );
    m_ahThreads[m_wThreads] = (HANDLE) _beginthreadex( NULL, 0, &SGMsgSendThreadFunc, NULL, CREATE_SUSPENDED, &uID );
    if( NULL == m_ahThreads[m_wThreads] )
    {
        ERR0( ConnMgr, "[XPQConnectionMgr::Create]: start SG send message thread failed" );
        hr = E_FAIL;
        goto lbDone; 
    }
    else
    {
        SetThreadPriority( m_ahThreads[ m_wThreads ], THREAD_PRIORITY_HIGHEST );
    }
    ++(m_wThreads);

	
	if( m_dwSTFCIP != 0 )
    {
        TRACE0( ConnMgr, L_NORMAL, "[XPQConnectionMgr::Create]: start STF control message thread" );
        m_ahThreads[m_wThreads] = (HANDLE) _beginthreadex( NULL, 0, &STFMsgThreadFunc, NULL, CREATE_SUSPENDED, &uID );
        if( NULL == m_ahThreads[m_wThreads] )
        {
            ERR0( ConnMgr, "[XPQConnectionMgr::Create]: start STF message thread failed" );
            hr = E_FAIL;
            goto lbDone; 
        }
        else
        {
            SetThreadPriority( m_ahThreads[ m_wThreads ], THREAD_PRIORITY_NORMAL );
        }
        ++(m_wThreads);
    }
    else
    {
        TRACE0( ConnMgr, L_HIGH, "[XPQConnectionMgr::Create]: skipped STF control message thread init (no address specified)" );
    }

	m_pINHConnection = new INHConnection();
	if(!m_pINHConnection || FAILED(hr = m_pINHConnection->Init()))
	{
        XomNtEvent(XEVENT_PRESENCE_CONFIG_82, "Unrecoverable failure while initializing: INHConnection Init failed hr=0x%X", hr);
        goto lbDone;
	}

    //
    // Send Hello to Inh Servers (there is no reply)
    //
    TRACE0( ConnMgr, L_NORMAL, "[XPQConnectionMgr::Create]: send Presence 'hello' message" );
    {
        XPMsgHello msgPresHello( m_DefSgAddr );
        if( FAILED( hr = SendToInh(&msgPresHello)))
        {
            ERR1( ConnMgr, "[XPQConnectionMgr::Create]: send Presence 'hello' message failed: HR: 0x%08x", hr );
            goto lbDone; 
        }
    }

    TRACE0( ConnMgr, L_HIGH, "[XPQConnectionMgr::Create] send 'dead sg' message to clear users" );
    hr  = SendDeadSG();
    if(FAILED(hr))
    {
        ERR1( ConnMgr, "[XPQConnectionMgr::Create]: SendDeadSG message failed, HR: 0x%08x", hr);
        goto lbDone;
    }

    hr = S_OK;

lbDone:
    
    SAFE_DELETE(pFDConn);

    return hr;
}

// Shutdown internal state 
void XPQConnectionMgr::Destroy()
{
    HRESULT hr;

    TRACE0( ConnMgr, L_NORMAL, "[XPQConnectionMgr::Destroy]: shutting down connection manager" );

    if(m_bRunning)
    {
        WaitForThreads();
    }

    // Close all thread handles
    for( WORD wThreadI = 0; wThreadI < m_wThreads; ++wThreadI )
    {
        SAFE_CLOSEHANDLE(m_ahThreads[wThreadI]);
    } 

    SAFE_DELETE(m_pSGConnection);
	SAFE_DELETE(m_pINHConnection);

    if(m_pServerPool)
    {
        // Free Server Pool
        TRACE0( ConnMgr, L_HIGH, "[XPQConnectionMgr::Destroy]: delete presence server pool" );
        SAFE_DELETE(m_pServerPool);
    }

    SAFE_ARRAY_DELETE(m_rgSlotInfo);    

    // Bring winsock down
    WinsockDOWN();
}

void XPQConnectionMgr::WaitForThreads()
{
    TRACE1( ConnMgr, L_NORMAL, "[XPQConnectionMgr::WaitForThreads]: waiting for %d threads to exit", m_wThreads );

    DWORD dwRet = WaitForMultipleObjects( m_wThreads, m_ahThreads, TRUE, INFINITE );

    if(WAIT_FAILED == dwRet)
    {
        ERR1( ConnMgr, "XPQConnectionMgr::WaitForThreads]: WaitForMultipleObjects failed, HR: 0x%08x", 
                HRESULT_FROM_WIN32(GetLastError()));
    }
}

DWORD XPQConnectionMgr::QValTimeOut() const
{
    return MGMT_GetConfigSetting(ConnectionMgr, QValTimeOut).GetDWORD();
}


bool XPQConnectionMgr::ResumeThreads()
{
    // Wait for any running trheads to stop
    TRACE1( ConnMgr, L_NORMAL, "[XPQConnectionMgr::Run]: resuming %u threads", m_wThreads );
    for( WORD wThreadI = 0; wThreadI < m_wThreads; ++wThreadI )
    {
        DWORD dwRet = ResumeThread( m_ahThreads[wThreadI] );
        if( DWORD(-1) == dwRet )
        {   
            ERR1( ConnMgr, "XPQConnectionMgr::ResumeThreads]: resuming thread failed, HR: 0x%08x", 
                    HRESULT_FROM_WIN32(GetLastError()));
            return false;
        }
    }

    m_bRunning = true;

    return true;
}

void XPQConnectionMgr::Heartbeat()
{
	m_pINHConnection->Heartbeat();
}

bool XPQConnectionMgr::TransactFD(  
    XPQTask* pTask, 
    XPQMsg*  pMsg, 
    XPQUser* pUser,
    BYTE*    pbReplyBuf,
    DWORD    dwReplyBufSize,
    DWORD*   pdwReplyLen,
    WORD     wPort )
{

    // Init return values
    bool bReplyReceived = false;
    *pdwReplyLen = 0L;

    DWORD dwCurrentThreadId = GetCurrentThreadId();

    // Grab global singletons
    XPQStress* pStress = XPQStress::GetPtr();

    // Contols stat gathering when done
    bool bValidReplyTiming = false;
    bool bSuccess          = false;

    // Check Params
    _ASSERTE( NULL != pTask );
    _ASSERTE( NULL != pMsg );
    _ASSERTE( NULL != pUser );
    _ASSERTE( (0L == dwReplyBufSize) || (NULL != pbReplyBuf) );

    // Connect to FD
    TCPClientConnection* pFDClient = NULL;
    HRESULT hr = E_FAIL;
    while( FAILED( hr ) ) 
    {
        pFDClient = new TCPClientConnection( m_hStopEvent, 1, MGMT_GetConfigSetting(ConnectionMgr, FDRecvBufferSize).GetDWORD() );
        if (pFDClient == NULL)
        {
            ERR1( ConnMgr, "XPQConnectionMgr::TransactFD() - create TCPClientConnection failed - thread[%d]", dwCurrentThreadId);
            hr = E_OUTOFMEMORY;
            goto done;
        }

        hr = pFDClient->Connect( 
            m_dwFDIP, 
            wPort, 
            kConnOpTimeout);
    
        if( FAILED( hr ) ) 
        {
            ERR1( ConnMgr, "XPQConnectionMgr::TransactFD() - connect failed - thread[%d]", dwCurrentThreadId );
            pFDClient->Close();
            pStress->LogTcpError( "Connect", pFDClient, pUser, pTask, WSAGetLastError() );
            Sleep( 500 );

            delete pFDClient;
            pFDClient = NULL;
        }
    }
    
    // Write Request to buffer
    char *pbBuffer = new char[kFDBufSize];
    if(0 == pbBuffer)
    {
        ERR1(ConnMgr, "XPQConnectionMgr::TransactFD() - out of memory - thread[%d]", dwCurrentThreadId);
        goto done;
    }

    DWORD dwDumped = pMsg->DumpMsg((BYTE*)pbBuffer, kFDBufSize);
    if( 0L == dwDumped )
    {
        ERR1( ConnMgr, "XPQConnectionMgr::TransactFD() - build message failed - thread[%d]", dwCurrentThreadId );
        pStress->LogErrorText( "Dump Buffer too small for FD Send", pUser, pTask );
        goto done;
    }

    // Set Auth Info 
    sockaddr_in* pSin = (sockaddr_in*)pFDClient->GetSockName();
    if(FAILED(hr = EnableAndMapSlot(
            pUser->Spi(), 
            pUser->SlotIndex(),
            pMsg->Type() == PMSG_DEAD_USER ? 0  : pUser->UserId(), 
            pSin)))
	{
		goto done;
	}

    TRACE6( ConnMgr, L_DEBUG, "XPQConnectionMgr::TransactFD() - thread[%d] sending XPQMsg Type: %d, Bytes: %d, UserId: %I64x, SPI: %08x:%u", 
            dwCurrentThreadId, 
            pMsg->Type(), 
            dwDumped, 
            pUser->UserId(), 
            pUser->Spi(), 
            pUser->SlotIndex() );

    // Send Request
    hr = pFDClient->WaitForAllPendingBuffersToFlush( kConnOpTimeout );
    if(FAILED(hr))
    {
        ERR3(ConnMgr, "WaitForAllPendingBuffersToFlush() timed out (%d millis), HR: 0x%08x - thread[%d]",
                kConnOpTimeout, hr, dwCurrentThreadId);
    }

    DWORD dwStarted = GetTickCount();
    hr = pFDClient->Send( pbBuffer, dwDumped, TRUE );
    if( FAILED( hr ) )
    {
        ERR1( ConnMgr, "XPQConnectionMgr::TransactFD() - send failed - thread[%d] (sleeping 1000ms)", dwCurrentThreadId );
        pStress->LogTcpError( "Send", pFDClient, pUser, pTask, WSAGetLastError() );
        Sleep( 1000 );
        goto done;
    }

    hr = pFDClient->WaitForAllPendingBuffersToFlush( kConnOpTimeout );
    if(FAILED(hr))
    {
        ERR3(ConnMgr, "WaitForAllPendingBuffersToFlush() timed out (%d millis), HR: 0x%08x - thread[%d]",
                kConnOpTimeout, hr, dwCurrentThreadId);
    }

    // Get Response
    memset( pbBuffer, 0, kFDBufSize );
    DWORD dwRcv     = 0L;
    DWORD dwTotal   = 0L;
    char* pMsgData  = NULL;

    // Read at least the headers
    while( dwTotal != kFDBufSize )
    {
        // Do we have headers?
        pMsgData = SearchString( pbBuffer, dwTotal, "\r\n\r\n" ); 

        if( NULL != pMsgData )
        {
            pMsgData += 4;
            break;
        }

        // Read as much as we can
        dwRcv = 0L;
        hr = pFDClient->Receive( pbBuffer + dwTotal, kFDBufSize - dwTotal, &dwRcv, MGMT_GetConfigSetting(ConnectionMgr, FDRecvTimeOut).GetDWORD() * 1000 );
        if(FAILED(hr))
        {
            TRACE1( ConnMgr, L_HIGH, "XPQConnectionMgr::TransactFD() - receive failed - thread[%d]", dwCurrentThreadId );
            pStress->LogTcpError( "Receive", pFDClient, pUser, pTask, WSAGetLastError() );
            TRACE1( ConnMgr, L_HIGH, "XPQConnectionMgr::TransactFD() - temp sleeping - thread[%d]", dwCurrentThreadId );
            Sleep( 1000 );
            TRACE1( ConnMgr, L_HIGH, "XPQConnectionMgr::TransactFD() - temp jumping - thread[%d]", dwCurrentThreadId );
            goto done;
        }
        
        if(0 == dwRcv)
        {
            TRACE1(ConnMgr, L_DEBUG, "XPQConnectionMgr::TransactFD() - receive remote end closed connection - thread[%d]", dwCurrentThreadId);
            break;
        }

        dwTotal += dwRcv;
    }

    bValidReplyTiming = true;

    // Was Buffer too small
    if( (dwTotal == kFDBufSize) && (NULL == pMsgData) )
    {
        ERR1( ConnMgr, "XPQConnectionMgr::TransactFD() - receive buffer too small - thread[%d]", dwCurrentThreadId );
        pStress->LogErrorText( "Buffer too small to Recv FD header", pUser, pTask );
        goto done;
    }

    // Did post succeed
    if( NULL == SearchString( pbBuffer, dwTotal, "200 OK" ) )
    {
        // Nope, Get X-Err for user
        char* pch = NULL;
        pch = SearchString( pbBuffer, dwTotal, "X-Err:" );
        DWORD dwErr = 0L;
        if( NULL != pch )
        {
            sscanf( pch + 6, "%x", &dwErr );
        }
   
        pStress->LogHttpError( pFDClient, pUser, pTask, dwErr );
        goto done;
    }

    // Get content length
    WORD  wContentLength = 0;
    char* pch = NULL;
    pch = SearchString( pbBuffer, dwTotal, "Content-Length:" );
    _ASSERTE( NULL != pch );
    if( NULL == pch )
    {
        pStress->LogErrorText( "FD Header Missing Content-Length", pUser, pTask );
        goto done;
    }

    // Make sure there is enough buffer left to sscanf
    if(((DWORD)((pch + 15) - pbBuffer)) >= dwTotal)
    {
        pStress->LogErrorText( "Not enough buffer to extract the content length header", pUser, pTask);
        goto done;
    }
    sscanf( pch + 15, "%u", &wContentLength );
   
    // If there no contents we be done
    if( 0 == wContentLength )
    {
        bReplyReceived = true;
        bSuccess = true;
        goto done;
    }

    // Make sure reply buffer is big enough
    if( wContentLength > dwReplyBufSize )
    {
        pStress->LogErrorText( "Reply Buff too small for FD Data", pUser, pTask );
        goto done;
    }
        
    // Remove the the headers from the reply buffer, pbBuffer + dwTotal is our new insertion point
    dwTotal = (pbBuffer + dwTotal) - pMsgData;
    memmove( pbReplyBuf, pMsgData, dwTotal);
    pMsgData = (char*)pbReplyBuf;
    
    // Read anything missing into reply buf
    while( dwTotal < (DWORD)wContentLength )
    {
        dwRcv = 0L;
        hr = pFDClient->Receive( (char*)(pbReplyBuf + dwTotal), dwReplyBufSize - dwTotal,
                                        &dwRcv, MGMT_GetConfigSetting(ConnectionMgr, FDRecvTimeOut).GetDWORD() );
        if(FAILED(hr))
        {
            ERR1( ConnMgr, "XPQConnectionMgr::TransactFD() - receive missing portion failed - thread[%d]", dwCurrentThreadId );
            pStress->LogTcpError( "Receive", pFDClient, pUser, pTask, WSAGetLastError() );
            Sleep( 1000 );
            goto done;
        }

        if(0 == dwRcv)
        {
            TRACE1(ConnMgr, L_DEBUG, "XPQConnectionMgr::TransactFD() - receive remote end closed connection - thread[%d]", dwCurrentThreadId);
            break;
        }

        dwTotal += dwRcv;
    }   

    if(dwTotal == (DWORD)wContentLength)
    {
        bReplyReceived = true;
        bSuccess = true;
        *pdwReplyLen = dwTotal;
    }
    

done:        

    // Release the local buffer
    SAFE_ARRAY_DELETE(pbBuffer);

    if (pFDClient != NULL)
    {
        // Hard close the connection
        pFDClient->Close(true); 
        delete pFDClient;
    }
 
    return bReplyReceived; 
}

INHConnection *XPQConnectionMgr::GetINHConnection()
{
	return m_pINHConnection;
}


HRESULT XPQConnectionMgr::SendToInh( XPQMsg* pMsg, XPQUser* pUser )
{
    HRESULT hr;
    BYTE rgbBuffer[2048];
    DWORD dwcBytes;

    // Write Reqest to buffer
    dwcBytes = pMsg->DumpMsg( rgbBuffer, 1024 );
    if( 0L == dwcBytes )
    {
        ERR0(ConnMgr, "[XPQConnectionMgr::SendToInh]: DumpMsg only built a message of 0 bytes");
        return false; 
    }

    hr = m_pServerPool->Send(pUser ? pUser->UserId() : 0, rgbBuffer, dwcBytes);
    
    return hr;
}


void __stdcall TraceBuffer(
    BYTE* pBuff,
    DWORD dwLen,
    char* pszDesc )
{
    DWORD dwThreadId = GetCurrentThreadId();
    TRACE3( ConnMgr, L_HIGH, "%s - Dump, Length %lu : thread [%d]", pszDesc, dwLen, dwThreadId );

    while( dwLen > 8 )
    {
        TRACE8( ConnMgr, L_HIGH, "%02x %02x %02x %02x   %02x %02x %02x %02x",
            pBuff[0],  pBuff[1],  pBuff[2],  pBuff[3],
            pBuff[4],  pBuff[5],  pBuff[6],  pBuff[7] );
        dwLen -= 8;
        pBuff += 8;
    }

    switch(dwLen)
    {
        case 1:
            TRACE1( ConnMgr, L_HIGH, "%02x",
                    (BYTE)pBuff[0] );
            break;
        case 2:
            TRACE2( ConnMgr, L_HIGH, "%02x %02x",
                    (BYTE)pBuff[0], (BYTE)pBuff[1] );
            break;
        case 3:
            TRACE3( ConnMgr, L_HIGH, "%02x %02x %02x",
                    (BYTE)pBuff[0], (BYTE)pBuff[1], (BYTE)pBuff[2] );
            break;
        case 4:
            TRACE4( ConnMgr, L_HIGH, "%02x %02x %02x %02x ",
                    (BYTE*)pBuff[0], (BYTE)pBuff[1], (BYTE)pBuff[2], (BYTE)pBuff[3] );
            break;
        case 5:
            TRACE5( ConnMgr, L_HIGH, "%02x %02x %02x %02x   %02x",
                    (BYTE)pBuff[0], (BYTE)pBuff[1], (BYTE)pBuff[2], (BYTE)pBuff[3],
                    (BYTE)pBuff[4] );
            break;
        case 6:
            TRACE6( ConnMgr, L_HIGH, "%02x %02x %02x %02x   %02x %02x",
                    (BYTE)pBuff[0], (BYTE)pBuff[1], (BYTE)pBuff[2], (BYTE)pBuff[3],
                    (BYTE)pBuff[4], (BYTE)pBuff[5] );
            break;
        case 7:
            TRACE7( ConnMgr, L_HIGH, "%02x %02x %02x %02x   %02x %02x %02x",
                    (BYTE)pBuff[0], (BYTE)pBuff[1], (BYTE)pBuff[2], (BYTE)pBuff[3],
                    (BYTE)pBuff[4], (BYTE)pBuff[5], (BYTE)pBuff[6] );
            break;
        case 8:
            TRACE8( ConnMgr, L_HIGH, "%02x %02x %02x %02x   %02x %02x %02x %02x",
                    (BYTE)pBuff[0], (BYTE)pBuff[1], (BYTE)pBuff[2], (BYTE)pBuff[3],
                    (BYTE)pBuff[4], (BYTE)pBuff[5], (BYTE)pBuff[6], (BYTE)pBuff[7] );
            break;
    }
}


///////////////////////////////////////
// SG Msg Thread Func
//

unsigned __stdcall XPQConnectionMgr::SGMsgReceiveThreadFunc( void*pArg )
{
#define SG_BUFFER_SZ 8192


    // All variables declared at top to avoid stack misalignment
    HRESULT hr;
    XPQConnectionMgr *pConnMgr;
    XPQUserMgr* pUserMgr;
    XPQStress* pStress;

    CSgMsgHdr*  pHdr;

    // Get an entire Message
    DWORD dwTotal;
    DWORD dwRead;
    DWORD dwMsgSize;
    BYTE  fNotFound;
    int   iFrom;

    BYTE *pbBuffer               = 0;
    DWORD dwResSize;

    XPQUser* pUser;
    CSgMsgSpiReq* pSpiDataReq;          
    CSgMsgSpiRep* pSpiDataRep;
    CSgMsgSpiData* pSpiData;
    CSgMsgHdr* pAuthDataHdr;
    CAuthData3* pAuthData3;
    DWORD dwSPI;

    // Get with receive to use for sending Auth reply
    sockaddr_in saReplyTo;

    pConnMgr = XPQConnectionMgr::GetPtr();
    _ASSERTE( NULL != pConnMgr );

    pUserMgr = XPQUserMgr::GetPtr();
    _ASSERTE( NULL != pUserMgr );

    pStress = XPQStress::GetPtr();
    _ASSERTE( NULL != pUserMgr );

    hr = S_OK;

    TRACE1( ConnMgr, L_HIGH, "[XPQConnectionMgr::SGMsgReceiveThreadFunc]: thread [%d] started", GetCurrentThreadId() ); 

    // Create a local buffer for reading UDP messages 
    pbBuffer    = new BYTE[SG_BUFFER_SZ]; 
    ZeroMemory(pbBuffer, SG_BUFFER_SZ); 

    // Measure all UDP messages
    DWORD dwAuthMsgCount = 0;
    DWORD dwQValMsgCount = 0;
    DWORD dwKickMsgCount = 0;
    DWORD dwTotalMsgCount = 0;
    DWORD dwMsgTimestamp = GetTickCount();

    LockFreeFifo<SGQVal> &qvalQueue = pConnMgr->GetQValPacketQueue();

    UDPConnection* pSGConnection = pConnMgr->GetUDPConnection();
	LockFreeFifo<PSG_RESPONSE> &sgSendQueue = pConnMgr->GetSGResponseQueue();

    // Loop getting SG Msgs until told to stop
    while(1)//WAIT_OBJECT_0 != WaitForSingleObject( ms_pConnMgr->m_hStopEvent, 0 ) )
    {
        pHdr = (CSgMsgHdr*)pbBuffer;

        // Get an entire Message
        dwTotal   = 0;
        dwRead    = 0;
        dwMsgSize = 0xffffffff;
        
        while( dwTotal < dwMsgSize )
        {
            // Receive part or all of a QFlags
            dwRead = 0;
            iFrom = sizeof( sockaddr_in );
            hr = pSGConnection->ReceiveFrom( 
                    (char*)pbBuffer + dwTotal,
                    SG_BUFFER_SZ - dwTotal, 
                    &dwRead, 
                    WSA_INFINITE,
                    (sockaddr*)&saReplyTo, 
                    &iFrom );
            if( FAILED( hr ) )
            {
                if( (HRESULT_FACILITY( hr ) == FACILITY_WIN32) && 
                    (HRESULT_CODE( hr ) == WSAECONNRESET) )
                {
                    TRACE3( 
                        ConnMgr, L_DEBUG, 
                        "[XPQConnectionMgr::SGMsgReceiveThreadFunc] - Continuable error 0x%08x, current %u, total %u", 
                        hr, dwRead, dwTotal);

                    // Start over 
                    dwRead    = 0;
                    dwTotal   = 0;
                    dwMsgSize = 0xffffffff;        
                }
                else
                {
                    if(!XPQStress::GetPtr()->IsStopping() )
                    {
                        TRACE2( ConnMgr, L_ERROR, "[XPQConnectionMgr::SGMsgReceiveThreadFunc]: HR: 0x%08x, sending stop event - thread [%d]", 
                                hr, GetCurrentThreadId() );
                        pStress->AllStop();
                    }
                    continue;
                }
            }

            dwTotal += dwRead;

            // If there enough for a header, get the real message size
            if( dwTotal >= sizeof( CSgMsgHdr ) )
            {
                dwMsgSize = pHdr->_cbEnt;
            }
        }
        
        // Process the message depending on its type
        if( pHdr->_wType == SGMSG_TYPE_SPIDATA_REQ )
        {
            pConnMgr->m_cSpiRequests++;

            if( dwRead != sizeof(CSgMsgSpiReq) )
            {
                ERR4( 
                    ConnMgr,
                    "XPQConnectionMgr::SGMsgReceiveThreadFunc() - Proc Type %d, read %d, not %d : thread [%d]", 
                    pHdr->_wType, dwRead, sizeof(CSgMsgSpiReq), GetCurrentThreadId() );
                TraceBuffer( pbBuffer, dwRead, "XPQConnectionMgr::SGMsgReceiveThreadFunc()" );
                continue;
            }

            // Spi Data Request 
            pSpiDataReq = (CSgMsgSpiReq*)pbBuffer;
			
			PSG_RESPONSE pSGResponse = new SG_RESPONSE();
			pSGResponse->dwResponseTime = GetTickCount() + pConnMgr->GetSGSendDelay();
            pSGResponse->dwResSize = SG_AUTH_RESP_SZ;
			pSGResponse->pbResBuffer = new BYTE[SG_AUTH_RESP_SZ]; 
            memcpy(&(pSGResponse->saReplyTo), &saReplyTo, sizeof(sockaddr_in));
		    ZeroMemory(pSGResponse->pbResBuffer, SG_AUTH_RESP_SZ); 

			// Build the response message
            pSpiDataRep     = (CSgMsgSpiRep*)       pSGResponse->pbResBuffer;
            pSpiData        = (CSgMsgSpiData*)      (pSpiDataRep + 1);
            pAuthDataHdr    = (CSgMsgHdr*)          (pSpiData + 1);
            pAuthData3      = (CAuthData3*)         (pAuthDataHdr + 1);

            //
            // Map the port to the slot index
            //
            // port -> slot index -> slot data
            //
            DWORD dwPortIndex = ntohs( pSpiDataReq->_ipportZ ) - 1024;
            _ASSERTE(dwPortIndex < kAuthPortArraySize);
        
            dwSPI = gpConnMgr->m_rgdwPortMap[dwPortIndex];
            XPQSlotInfo &slot = NotFoundSlotInfo;
            
            // Make sure the slot map is not invalid (-1)
            if(dwSPI >= gpConnMgr->m_dwMaxSPI) 
            {
                fNotFound = 1;
            }
            else 
            {
                // Map slot and perform sanity check
                slot = gpConnMgr->m_rgSlotInfo[dwSPI];
                if(!slot.fValid || slot.wPort != pSpiDataReq->_ipportZ)
                {
                    fNotFound = 1;
                }
                else
                {
                    fNotFound = 0;
                }
            }
    
            // CSgMsgSpiRep
            pSpiDataRep->_wType     = SGMSG_TYPE_SPIDATA_REP;
            pSpiDataRep->_cbEnt     = sizeof( CSgMsgSpiRep );
            pSpiDataRep->_dwReqNum  = pSpiDataReq->_dwReqNum;
            pSpiDataRep->_ipaZ      = pSpiDataReq->_ipaZ;
            pSpiDataRep->_ipportZ   = pSpiDataReq->_ipportZ;
            pSpiDataRep->_fNotFound = fNotFound;


            // Just send the not-found reply
            if(1 == fNotFound)
            {
                DWORD dwNow = GetTickCount();

                ERR9(ConnMgr, "[ConnectionMgr::SGMsgReceiveThreadFunc]: invalid sgauth request num: %u from: %s, for port: %u, slot(valid: %d, mapped: %ums, lastsent: %ums, spi: %08x, port: %u, user[0]: %I64x)",
                        pSpiDataReq->_dwReqNum,
                        inet_ntoa(saReplyTo.sin_addr),
                        ntohs(pSpiDataReq->_ipportZ),
                        slot.fValid,
                        slot.dwMapped ? dwNow - slot.dwMapped : 0,
                        slot.dwLastSentAuth ? dwNow - slot.dwLastSentAuth : 0,
                        slot.dwSPI,
                        slot.wPort,
                        slot.rgqwUserIDs[0]);
            
                dwResSize = sizeof(CSgMsgSpiRep);
                goto lbSendReply;
            }

            // Mark the last sent time for slot
            slot.dwLastSentAuth = GetTickCount();

            // CSgMsgSpiData
            pSpiData->_wType               = SGMSG_TYPE_SPIDATA;
            pSpiData->_cbEnt               = sizeof( CSgMsgSpiData );
            pSpiData->_ipportI             = 0xFFFF;       
            pSpiData->_ipaI.s_addr         = ms_pConnMgr->m_dwSGIP;          
            pSpiData->_sgaddr.inaSg.s_addr = ms_pConnMgr->m_dwSGIP;
            pSpiData->_sgaddr.dwSpiSg      = slot.dwSPI;
            pSpiData->_sgaddr.qwXboxID     = slot.qwXboxId;
            *((UINT*)pSpiData->_sgaddr.abReserved) = 0;

            GetSystemTimeAsFileTime( reinterpret_cast< LPFILETIME >( &(pSpiData->_liTimeInit) ) );
            pSpiData->_fCs                 = 1;           

            // CSgMsgHdr (AuthData Header) The TYPE did not change
            pAuthDataHdr->_wType = SGMSG_TYPE_AUTHDATA;
            pAuthDataHdr->_cbEnt = sizeof( CSgMsgHdr ) + sizeof( CAuthData3 );
            
            // CAuthData
            pAuthData3->wAuthDataVersion            = 3;
            pAuthData3->dwAuthDataFlags             = slot.dwAuthDataFlags;
            pAuthData3->wAuthDataSize               = sizeof( CAuthData3 );
            pAuthData3->dwTitleID                   = slot.dwTitleId;
            pAuthData3->dwTitleVersion              = slot.dwTitleVersion;
            pAuthData3->dwTitleRegion               = slot.dwTitleRegion;
            pAuthData3->qwXboxID                    = slot.qwXboxId;
            pAuthData3->users[0].dwUserFlags        = slot.rgdwUserFlags[0];
            pAuthData3->users[0].qwUserID           = slot.rgqwUserIDs[0];
            pAuthData3->users[1].dwUserFlags        = slot.rgdwUserFlags[1];
            pAuthData3->users[1].qwUserID           = slot.rgqwUserIDs[1];
            pAuthData3->users[2].dwUserFlags        = slot.rgdwUserFlags[2];
            pAuthData3->users[2].qwUserID           = slot.rgqwUserIDs[2];
            pAuthData3->users[3].dwUserFlags        = slot.rgdwUserFlags[3];
            pAuthData3->users[3].qwUserID           = slot.rgqwUserIDs[3];
            pAuthData3->wNumDwordServices           = XONLINE_MAX_NUMBER_SERVICE_PER_TICKET;
            pAuthData3->wLanguageID                 = slot.wLanguageId;
			pAuthData3->clientVersion               = slot.clientVersion;

            // Add services
            pAuthData3->dwPrivileges[0]             = slot.dwPrivileges[0];

lbSendReply:

			// queue the auth response
			sgSendQueue.Enqueue(pSGResponse);
            TRACE8(ConnMgr, L_DEBUG, "AUTH[%08x]: User0: %I64x, fNotFound: %d, Port: %d, From: %u.%u.%u.%u",
                    dwSPI,
                    slot.rgqwUserIDs[0],
                    fNotFound,
                    pSpiDataReq->_ipportZ, 
                    ((BYTE*)&saReplyTo.sin_addr)[0],
                    ((BYTE*)&saReplyTo.sin_addr)[1],
                    ((BYTE*)&saReplyTo.sin_addr)[2],
                    ((BYTE*)&saReplyTo.sin_addr)[3]);
            ++dwAuthMsgCount;
        }
        else if( (pHdr->_wType == SGMSG_TYPE_SET_QVALS_LAZY) ||
                 (pHdr->_wType == SGMSG_TYPE_SET_QVALS_PUSH) )
        {
            if(ms_bDisableQVals)
            {
                ++dwQValMsgCount;
                goto lbDoneQValReply;
            }

            bool bGoodData = true;
            if(dwRead < sizeof(CSgMsgSetQValsReq))
            {
                TRACE4( 
                        ConnMgr, L_HIGH, 
                        "XPQConnectionMgr::SGMsgReceiveThreadFunc() - Proc Type %d, read %d, not %d : thread [%d]", 
                        pHdr->_wType, dwRead, (sizeof(CSgMsgSetQValsReq) + sizeof(SGQVal)), GetCurrentThreadId() );
                bGoodData = false;
            }
            if(bGoodData)
            {
                pConnMgr->m_cQValRequests++;

                // QVal Request 
                CSgMsgSetQValsReq* pQValReq = (CSgMsgSetQValsReq*)pbBuffer;

                // Look up User
                XPQUser* pUser = pUserMgr->UserPtrFromId( pQValReq->_qwUserId );
                fNotFound = ((pUser == NULL) || !pUser->IsOnline()) ? 1 : 0;

                // Map the SPI and record the last qval if the user is online
                if(0 == fNotFound)
                {
                    dwSPI = pQValReq->_sgaddr.dwSpiSg;
                    if(dwSPI < gpConnMgr->m_dwMaxSPI)
                    {
                        XPQSlotInfo &slot = gpConnMgr->m_rgSlotInfo[dwSPI];
                        slot.dwLastSentQVal = GetTickCount();
                    }
					else
					{
						fNotFound = 1;
					}
                }

                if(fNotFound)
                {
                    const char *pszOnlineState = (NULL == pUser) ? "<null>" : (pUser->IsOnline() ? "true" : "false");
                    TRACE3(ConnMgr, L_DEBUG, "[ConnectionMgr::SGMsgReceiveThreadFunc]: QVAL response user not found 0x%I64x (online: %s), spi: %08x",
                            pQValReq->_qwUserId,
                            pszOnlineState,
                            dwSPI);
                }

                // Build the replymessage
                CSgMsgSetQValsRep CMsg;
                CMsg._wType = SGMSG_TYPE_SET_QVALS_REP;
                CMsg._cbEnt = sizeof( CSgMsgSetQValsRep );

                CMsg._sgaddr = pQValReq->_sgaddr;

                CMsg._qwUserId    = pQValReq->_qwUserId;
                CMsg._dwContext   = pQValReq->_dwContext;
                CMsg._fNotFound   = fNotFound;
                CMsg._fNoSuchUser = fNotFound;


				PSG_RESPONSE pSGResponse = new SG_RESPONSE();
				pSGResponse->dwResponseTime = GetTickCount() + pConnMgr->GetSGSendDelay();
				pSGResponse->dwResSize = sizeof(CSgMsgSetQValsRep);
				pSGResponse->pbResBuffer = new BYTE[sizeof(CSgMsgSetQValsRep)]; 
				memcpy(pSGResponse->pbResBuffer, &CMsg, sizeof(CSgMsgSetQValsRep));
				memcpy(&(pSGResponse->saReplyTo), &saReplyTo, sizeof(sockaddr_in));

                // Send it
       			sgSendQueue.Enqueue(pSGResponse);

                if( 0 == fNotFound && (dwRead > sizeof(CSgMsgSetQValsReq)))
                {
                    SGQVal* pQVals = (SGQVal*)(pQValReq+1);
                    pQVals->m_qwUserId = pUser->UserId();
                    bGoodData = qvalQueue.Enqueue(*pQVals);
                }

                TRACE4(ConnMgr, L_DEBUG, "QVAL[%08x]: fNotFound: %d, UserId: %I64x, ContextId: %08x",
                        CMsg._sgaddr.dwSpiSg,
                        fNotFound,
                        CMsg._qwUserId, 
                        CMsg._dwContext);
            }
            else // ! bGoodData 
            {
                TraceBuffer( (BYTE*)pbBuffer, dwRead, "[XPQConnectionMgr::SGMsgReceiveThreadFunc]" );
            }


lbDoneQValReply:
            ++dwQValMsgCount;
        }
        else if( pHdr->_wType == SGMSG_TYPE_KICK_REQ )
        {
            CSgMsgKickReq* pKickReq = (CSgMsgKickReq*)pbBuffer;

            // Get the slot
            DWORD dwSPI = pKickReq->_sgaddr.dwSpiSg;
            XPQSlotInfo &slot = NotFoundSlotInfo;
            
            CSgMsgKickRep CMsg;
            CMsg._sgaddr = pKickReq->_sgaddr;

            // Make sure the slot map is not invalid (-1)
            if(dwSPI >= gpConnMgr->m_dwMaxSPI) 
            {
                fNotFound = 1;
            }
            else
            {
                slot = gpConnMgr->m_rgSlotInfo[dwSPI];
                fNotFound = slot.wcUsers == 0 ? 1 : 0;

                if(0 == fNotFound)
                {
                    slot.fKicked = TRUE;
                }
            }

            CMsg._fNotFound = fNotFound;

			PSG_RESPONSE pSGResponse = new SG_RESPONSE();
			pSGResponse->dwResponseTime = GetTickCount() + pConnMgr->GetSGSendDelay();
			pSGResponse->dwResSize = sizeof(CSgMsgKickRep);
			pSGResponse->pbResBuffer = new BYTE[sizeof(CSgMsgKickRep)]; 
			memcpy(pSGResponse->pbResBuffer, &CMsg, sizeof(CSgMsgKickRep));
			memcpy(&(pSGResponse->saReplyTo), &saReplyTo, sizeof(sockaddr_in));

            // Send it
   			sgSendQueue.Enqueue(pSGResponse);

            TRACE8(ConnMgr, L_DEBUG, "KICK[%08x]: fNotFound: %d, user[0]: %I64x, user[1]: %I64x, user[2]: %I64x, user[3]: %I64x, lastauth: %ums, lastqval: %ums",
                    dwSPI,
                    fNotFound,
                    slot.rgqwUserIDs[0],
                    slot.rgqwUserIDs[1],
                    slot.rgqwUserIDs[2],
                    slot.rgqwUserIDs[3],
                    slot.dwLastSentAuth ? GetTickCount() - slot.dwLastSentAuth : 0,
                    slot.dwLastSentQVal ? GetTickCount() - slot.dwLastSentQVal : 0);
            dwKickMsgCount++;
        }
        else
        {
            TRACE2( ConnMgr, L_HIGH, "[XPQConnectionMgr::SGMsgReceiveThreadFunc]: unexpected SGMsg Type 0x%04x, on thread [%d]", 
                    pHdr->_wType, GetCurrentThreadId() );
        }

        DWORD dwElapsed = GetTickCount() - dwMsgTimestamp + 1;
        if(dwElapsed > 10000)
        {
            dwTotalMsgCount = (dwQValMsgCount + dwAuthMsgCount + dwKickMsgCount);

            float fQValRate  = float(dwQValMsgCount)  / (0.001f * dwElapsed);
            float fAuthRate  = float(dwAuthMsgCount)  / (0.001f * dwElapsed);
            float fKickRate  = float(dwKickMsgCount)  / (0.001f * dwElapsed);
            float fTotalRate = float(dwTotalMsgCount) / (0.001f * dwElapsed);

            pConnMgr->SetStatistics(fQValRate, fAuthRate, fKickRate, fTotalRate);

            TRACE8( ConnMgr, L_DEBUG, "[XPQConnectionMgr::SGMsgReceiveThreadFunc]: [STATS] qval: %u (rate: %g), auth: %u (rate: %g), kick: %u (rate: %g), total: %u (rate: %g)",
                    dwQValMsgCount,
                    fQValRate,
                    dwAuthMsgCount,
                    fAuthRate,
                    dwKickMsgCount,
                    fKickRate,
                    dwTotalMsgCount,
                    fTotalRate);
                    

            // reset counts
            dwMsgTimestamp = GetTickCount();
            dwQValMsgCount = 0;
            dwAuthMsgCount = 0;
            dwKickMsgCount = 0;
        }
    }

    TRACE1( ConnMgr, L_HIGH, "[XPQConnectionMgr::SGMsgReceiveThreadFunc]: exiting thread [%d]", GetCurrentThreadId() );

    SAFE_ARRAY_DELETE(pbBuffer);

    return 0;
}


unsigned __stdcall XPQConnectionMgr::SGMsgSendThreadFunc( void*pArg )
{
	HRESULT hr;
    XPQConnectionMgr *pConnMgr;
    pConnMgr = XPQConnectionMgr::GetPtr();
    _ASSERTE( NULL != pConnMgr );

    UDPConnection* pSGConnection = pConnMgr->GetUDPConnection();
	LockFreeFifo<PSG_RESPONSE> &sgSendQueue = pConnMgr->GetSGResponseQueue();
	PSG_RESPONSE sgResponse = NULL;

    // Loop getting SG Msgs until told to stop
    while(1)//WAIT_OBJECT_0 != WaitForSingleObject( ms_pConnMgr->m_hStopEvent, 0 ) )
    {

		DWORD dwNow = GetTickCount();
		if(sgResponse == NULL)
		{
			if(!sgSendQueue.Dequeue(sgResponse))
			{
				Sleep(50);
			}
		}
		else if(dwNow > sgResponse->dwResponseTime)
		{

			// Send back to source
			hr = pSGConnection->SendTo( (const char*)sgResponse->pbResBuffer, sgResponse->dwResSize,
									TRUE, kConnOpTimeout, (sockaddr*)&(sgResponse->saReplyTo), sizeof(sockaddr) );
			if(FAILED(hr))
			{
				ERR3(ConnMgr, "[XPQConnectionMgr::SGMsgSendThreadFunc] SgAuth SendTo() failed, HR: 0x%08x - thread[%d]",
						kConnOpTimeout, hr, GetCurrentThreadId());
			}
			SAFE_ARRAY_DELETE(sgResponse->pbResBuffer);
			SAFE_DELETE(sgResponse);
		}
		else
		{
			Sleep(sgResponse->dwResponseTime - dwNow);
		}
    }

    TRACE1( ConnMgr, L_HIGH, "[XPQConnectionMgr::SGMsgSendThreadFunc]: exiting thread [%d]", GetCurrentThreadId() );

    return 0;
}


#define STF_CLIENT_TYPE_FUNCTIONAL      0
#define STF_CLIENT_TYPE_DVT_FUNCTIONAL  1
#define STF_CLIENT_TYPE_STRESS          2

#define STF_MSG_TYPE_REGISTER           0
#define STF_MSG_TYPE_REGISTER_RESP      1 
#define STF_MSG_TYPE_UPDATE_STATE       2
#define STF_MSG_TYPE_COMMAND            3

#define STF_CLIENT_STATE_STARTING       0
#define STF_CLIENT_STATE_INIT           1
#define STF_CLIENT_STATE_RUNNING        2
#define STF_CLIENT_STATE_TERMINATING    3
#define STF_CLIENT_STATE_STOP           4

#define STF_CONTROL_CLIENT_PORT         0xFF00
#define STF_CONTROL_RECV_TIMEOUT        5000
#define STF_CONTROL_SEND_TIMEOUT        1000
#define STF_CONTROL_HEARTBEAT_INTERVAL  30000
#define STF_CONTROL_COMPONENT_NAME      "Presence"
#define STF_CONTROL_BUFFER_SZ           128

#pragma pack(push, 1)
struct STFControlHdr
{
    DWORD dwMsgType;
    DWORD dwMsgSize;
};
struct STFControlRegisterMsg : public STFControlHdr
{
    DWORD dwType;
    DWORD dwState;
    DWORD dwListeningPort;
    BYTE  bDataLen;
    // BYTE rgbData[0..bDataLen]

    void   CalculateSize()
    {
        dwMsgSize = sizeof(STFControlRegisterMsg) + bDataLen;   
    }
};
struct STFControlCommandMsg : public STFControlHdr
{
    DWORD dwTextLen;
    // BYTE rgbUtfData[0...dwTextLen]
};
#pragma pack(pop)

HRESULT __stdcall XPQConnectionMgr::SendControlRegisterMessage(UDPConnection *pConn, BYTE *pbBuffer, DWORD dwDestAddr, WORD wDestPort, DWORD dwMsgType, DWORD dwState)
{
    HRESULT                hr;
    STFControlRegisterMsg* pMsg;
    sockaddr_in            saSendTo = {0,};
    int                    iSockLen;
    
    //
    // Create the register command message
    //
    pMsg                  = (STFControlRegisterMsg*)pbBuffer;
    pMsg->dwMsgType       = dwMsgType;
    pMsg->dwType          = STF_CLIENT_TYPE_STRESS;
    pMsg->dwState         = dwState;
    pMsg->dwListeningPort = STF_CONTROL_CLIENT_PORT;
    pMsg->bDataLen        = (BYTE)_snprintf((char*)(pMsg+1), sizeof(STF_CONTROL_COMPONENT_NAME), STF_CONTROL_COMPONENT_NAME); 

    pMsg->CalculateSize();

    // Set up the destination socket addr 
    saSendTo.sin_family      = AF_INET;
    saSendTo.sin_addr.s_addr = dwDestAddr;
    saSendTo.sin_port        = wDestPort;
    iSockLen                 = sizeof(struct sockaddr_in);

    // Ship the register command
    hr = pConn->SendTo((char*)pbBuffer, pMsg->dwMsgSize, TRUE, STF_CONTROL_SEND_TIMEOUT, (struct sockaddr*)&saSendTo, iSockLen);
    if(FAILED(hr) && HRESULT_FROM_WIN32(ERROR_IO_PENDING) != hr)
    {
        ERR1(ConnMgr, "[XPQConnectionMgr::SendControlRegisterMsg]: failed  to send register message, HR: 0x%08x", hr);
    }
    else
    {
        TRACE3(ConnMgr, L_DEBUG, "[XPQConnectionMgr::SendControlRegisterMsg]: sent %u bytes to %s:%d", 
                pMsg->dwMsgSize, 
                inet_ntoa(*(in_addr*)&saSendTo.sin_addr.s_addr), 
                ntohs(wDestPort));
    }

    return hr;
}

unsigned __stdcall XPQConnectionMgr::STFMsgThreadFunc( void*pArg )
{
    HRESULT                hr;
    BYTE*                  pbBuffer;
    UDPConnection*         pSTFConnection;
    DWORD                  dwServerAddr;
    WORD                   wServerPort;
    DWORD                  dwHeartBeatTicks;
    DWORD                  dwSent;
    DWORD                  dwRead;
    DWORD                  dwState;
    STFControlCommandMsg*  pMsg;
    sockaddr_in            saRecvFrom;
    int                    iSockLen;
    XPQStress*             pStress;

    // Create a local buffer for reading UDP messages 
    pbBuffer       = new BYTE[STF_CONTROL_BUFFER_SZ]; 
    pSTFConnection = new UDPConnection();
    dwState        = STF_CLIENT_STATE_STARTING;
    pStress        = XPQStress::GetPtr();

    _ASSERTE(0 != pbBuffer && 0 != pSTFConnection);
    _ASSERTE(0 != pStress);

    // Bind to SG msg Port
    TRACE0(ConnMgr, L_HIGH, "[XPQConnectionMgr::STFMsgThreadFunc]: startup, binding port 0xffff") ;


    if( FAILED( hr = pSTFConnection->Bind( STF_CONTROL_CLIENT_PORT, ms_pConnMgr->m_dwSGIP ) ) )
    {
        SAFE_DELETE(pSTFConnection);
        ERR1( ConnMgr, "[XPQConnectionMgr::STFMsgThreadFunc]: thread [%d] Failed to bind to port FF00, sending stop event", 
                GetCurrentThreadId() );
        goto lbDone;
    }


    // Initiate the heartbeat
    dwHeartBeatTicks = GetTickCount() + STF_CONTROL_HEARTBEAT_INTERVAL;

    //
    // Get STF control messages unless we get a server stop message
    //
    while( WAIT_OBJECT_0 != WaitForSingleObject( ms_pConnMgr->m_hStopEvent, 0 ) )
    {
        // Get any stf commands
        dwRead = 0;
        iSockLen = sizeof( sockaddr_in );

        hr = pSTFConnection->ReceiveFrom( 
                (char*)pbBuffer,
                STF_CONTROL_BUFFER_SZ, 
                &dwRead, 
                STF_CONTROL_RECV_TIMEOUT,
                (sockaddr*)&saRecvFrom, 
                &iSockLen );

        if( FAILED( hr ) )
        {
            if( (HRESULT_FACILITY( hr ) == FACILITY_WIN32) && 
                    ((HRESULT_CODE( hr ) == ERROR_IO_PENDING)   ||
                     (HRESULT_CODE( hr ) == WSAECONNRESET)      ||
                     (HRESULT_CODE( hr ) == WSAEINPROGRESS)     ||
                     (HRESULT_CODE( hr ) == WSAEALREADY)        ||
                     (HRESULT_CODE( hr ) == WSAEMSGSIZE) ))
            {
                TRACE2( 
                        ConnMgr, L_DEBUG, 
                        "[XPQConnectionMgr::STFMsgThreadFunc]: Continuable error 0x%08x, read %u", 
                        hr, dwRead);
            }
            else
            {
                ERR1(ConnMgr, "[XPQConnectionMgr::STFMsgThreadFunc]: pSTFConnection->ReceiveFrom() return error, HR: 0x%08x", hr);
                goto lbDone;
            }
        }


        // Parse the message if any
        if(dwRead > 4)
        {
            // Read the message header
            pMsg = (STFControlCommandMsg*)pbBuffer;

            switch(pMsg->dwMsgType)
            {
                default:
                    ERR3(ConnMgr, "[XPQConnectionMgr::STFMsgThreadFunc]: unknown message type received: 0x%04x, size: %u, dwTextLen: 0x%08x", 
                            pMsg->dwMsgType, pMsg->dwMsgSize, pMsg->dwTextLen);
                    break;
                case STF_MSG_TYPE_COMMAND:
                    TRACE4(ConnMgr, L_HIGH, "[XPQConnectionMgr::STFMsgThreadFunc]: Received command: type: %u, size: %u, textlen: %u, data: %s", 
                        pMsg->dwMsgType, pMsg->dwMsgSize, pMsg->dwTextLen, (char*)(pMsg+1));

                    if(0 == _strnicmp((const char*)(pMsg+1), "stop", 4))
                    {
                        pStress->AllStop();
                        continue;
                    }
                    else
                    {
                        ERR4(ConnMgr, "[XPQConnectionMgr::STFMsgThreadFunc]: Received unknown: type: %u, size: %u, textlen: %u, data: %s", 
                                pMsg->dwMsgType, pMsg->dwMsgSize, pMsg->dwTextLen, (char*)(pMsg+1));
                    }
                    
                    break;
            }
        }

        //
        // Handle registration and heartbeat state updates
        //
        if(STF_CLIENT_STATE_STARTING == dwState)
        {
            hr = SendControlRegisterMessage(pSTFConnection, pbBuffer, ms_pConnMgr->m_dwSTFCIP, ms_pConnMgr->m_wSTFCPort, STF_MSG_TYPE_REGISTER, dwState);
            if(SUCCEEDED(hr))
            {
                dwState = STF_CLIENT_STATE_RUNNING;
            }
        }
        else if (GetTickCount() >= dwHeartBeatTicks)
        {
            hr = SendControlRegisterMessage(pSTFConnection, pbBuffer, ms_pConnMgr->m_dwSTFCIP, ms_pConnMgr->m_wSTFCPort, STF_MSG_TYPE_UPDATE_STATE, dwState);
            if(FAILED(hr))
            {
                ERR1(ConnMgr, "[XPQConnectionMgr::STFMsgThreadFunc]: failed to update control state, HR: 0x%08x", hr);
            }
            dwHeartBeatTicks = GetTickCount() + STF_CONTROL_HEARTBEAT_INTERVAL;
        }

        
    } // while not stop event

    // Send the stop message
    dwState = STF_CLIENT_STATE_STOP;
    hr = SendControlRegisterMessage(pSTFConnection, pbBuffer, ms_pConnMgr->m_dwSTFCIP, ms_pConnMgr->m_wSTFCPort, STF_MSG_TYPE_UPDATE_STATE, dwState);
    if(FAILED(hr))
    {
        ERR1(ConnMgr, "XPQConnectionMgr::STFMsgThreadFunc]: failed to send stop control message, HR: 0x%08x", hr);
    }

    SAFE_ARRAY_DELETE(pbBuffer);
    SAFE_DELETE(pSTFConnection);

    hr = S_OK;

lbDone:
    TRACE1(ConnMgr, L_HIGH, "[XPQConnectionMgr::STFMsgThreadFunc]: finished, HR: 0x%08x", hr) ;

    return 0;
}


///////////////////////////////////////
// Send Dead SG
//
HRESULT XPQConnectionMgr::SendDeadSG()
{
    // Set up Shared SGADDR
    XPQSgAddr sgAddr( m_dwSGIP, 0L, 0 );

    // Presence
    XPMsgDeadSG msgPresDeadSG( sgAddr );
    HRESULT hr = SendToInh(&msgPresDeadSG);
    if(FAILED(hr))
    {
        ERR1(ConnMgr, "[XPQConnectionMgr::SendDeadSG]: failed with hr: 0x%08x", hr);
    }
    
    return hr;
}

///////////////////////////////////////
// Init Server Pool 
//
CServerPool* XPQConnectionMgr::InitServerPool(
    HANDLE hStopEvent,
    WORD   wCount,
    char*  pszBaseName )
{
    // Create the pool 
    CServerPool* pPool =
        new CServerPool( wCount, 
                         hStopEvent, 
                         MGMT_GetConfigSetting(ConnectionMgr, ServerPoolSendBuffers).GetDWORD(),
                         MGMT_GetConfigSetting(ConnectionMgr, ServerPoolSendBuffSize).GetDWORD() );
    _ASSERTE( NULL != pPool );
    if( NULL == pPool )
    {
        return NULL;
    }
    _ASSERTE( wCount == pPool->NumServers() );
    if( wCount != pPool->NumServers() )
    {
        delete pPool;
        return NULL;
    }

    // Create Array for server IPs
    DWORD* adwIP = new DWORD[wCount];
    _ASSERTE( NULL != adwIP );
    if( NULL == adwIP )
    {
        delete pPool;
        return NULL;
    }

    // Create Array for server ports
    WORD* awPort = new WORD[wCount];
    _ASSERTE( NULL != awPort );
    if( NULL == awPort )
    {
        SAFE_ARRAY_DELETE(adwIP);
        SAFE_DELETE(pPool);
        return NULL;
    }

    // Load Server IPs from ini file
    Console &console = Console::GetInstance();
    Setting* pSetting;
    const int NameSize = 64;
    char szName[NameSize];
    bool bIPsAreOK = true;
    for( int i = 0; i < wCount; ++i )
    {
        _snprintf( szName, NameSize, "ConnectionMgr.%sIP%d", pszBaseName, i+1 );
        szName[ NameSize-1 ] = 0;

        if( !console.GetSetting( szName, &pSetting ) )
        {
            ERR1( ConnMgr, "Ini file setting missing: %s", szName );
            bIPsAreOK = false;
            break;
        }

        adwIP[i] = InternetAddress( pSetting->GetLPCSTR() );
        if( adwIP[i] == INADDR_NONE )
        {
            ERR2( ConnMgr, "Ini file setting invalid: %s = %s", szName, pSetting->GetLPCSTR() );
            bIPsAreOK = false;
            break;
        }

        _snprintf( szName, NameSize, "ConnectionMgr.%sPortFromClient%d", pszBaseName, i+1 );
        szName[ NameSize-1 ] = 0;

        if( !console.GetSetting( szName, &pSetting ) )
        {
            // If we failed getting a port setting specific to this server, try to get the old-style
            // global setting to remain compatible with old INI files.
            _snprintf( szName, NameSize, "ConnectionMgr.%sPortFromClient", pszBaseName );
            szName[ NameSize-1 ] = 0;

            if( !console.GetSetting( szName, &pSetting ) )
            {
                printf( "Ini file setting missing: %s\n", szName );
                bIPsAreOK = false;
                break;
            }
        }

        awPort[i] = (WORD) pSetting->GetDWORD();
    }

    HRESULT hr = E_FAIL;
    if( bIPsAreOK )
    {
        hr = pPool->Connect( adwIP, wCount, awPort );
    }

    SAFE_ARRAY_DELETE(adwIP);
    SAFE_ARRAY_DELETE(awPort);

    if( FAILED( hr ) )
    {
        SAFE_DELETE(pPool);
    }

    return pPool;
}

//------------------------------------------------------------------------------
//
// Fake SG slot info management
//
//------------------------------------------------------------------------------
HRESULT XPQConnectionMgr::GetSlotInfo( DWORD dwSPI, XPQSlotInfo &outSlotInfo)
{
    HRESULT hr = E_FAIL;

    if(dwSPI > m_dwMaxSPI)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    AUTHENTER();
    outSlotInfo          = m_rgSlotInfo[dwSPI];
    AUTHLEAVE();

    hr = S_OK;

lbDone:
    return hr;
}

HRESULT XPQConnectionMgr::EnableAndMapSlot( DWORD dwSPI, DWORD dwSlotIndex, ULONGLONG qwUserId, sockaddr_in* pSin )
{
    HRESULT hr;
    DWORD dwiPort;
    
    _ASSERTE(INVALID_SPI != dwSPI);
    _ASSERTE(INVALID_SPI_SLOT_INDEX != dwSlotIndex);

    if(dwSPI >= m_dwMaxSPI || 0 == pSin)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    // Vector port mapping to correct SPI index
    dwiPort = ntohs( pSin->sin_port ) - 1024;

    _ASSERTE( dwiPort < kAuthPortArraySize );
    if(dwiPort >= kAuthPortArraySize)
    {
        hr = E_FAIL;
        goto lbDone;
    }

    AUTHENTER();

	if(m_rgdwPortMap[dwiPort] != -1)
	{
		AUTHLEAVE();
		return HRESULT_FROM_WIN32(WSAEADDRINUSE);
	}

    XPQSlotInfo &slot = m_rgSlotInfo[dwSPI];

    USERTRACE8(slot.rgqwUserIDs[0], "[XPQConnectionMgr::EnableAndMapSlot]: SPI: %08x:%u, port: 0x%04x, PortIndex: %u, User0: %I64x, User1: %I64x, User2: %I64x, User3: %I64x",
            dwSPI,
            dwSlotIndex,
            pSin->sin_port,
            ntohs(pSin->sin_port) - 1024,
            slot.rgqwUserIDs[0],
            slot.rgqwUserIDs[1],
            slot.rgqwUserIDs[2],
            slot.rgqwUserIDs[3]);
    
    if(slot.fKicked)
    {
        ERR6(ConnMgr, "[XPQConnectionMgr::EnableAndMapSlot]: user: %I64x slot has been kicked: %08x:%u (lastauth: %ums, lastqval: %ums, kicked: %u)",
                qwUserId,
                dwSPI,
                dwSlotIndex,
                slot.dwLastSentAuth ? GetTickCount() - slot.dwLastSentAuth : 0,
                slot.dwLastSentQVal ? GetTickCount() - slot.dwLastSentQVal : 0,
                slot.fKicked);
        hr = E_FAIL;
        AUTHLEAVE();
        goto lbDone;
    }

    _ASSERTE(qwUserId == slot.rgqwUserIDs[dwSlotIndex]);
    if(qwUserId != slot.rgqwUserIDs[dwSlotIndex])
    {
        DWORD dwNow = GetTickCount();
        ERR7(ConnMgr, "[XPQConnectionMgr::EnableAndMapSlot]: user: %I64x does not exist in expected slot location: %08x:%u (mapped: %ums, lastauth: %ums, lastqval: %ums, kicked: %u)",
                qwUserId,
                dwSPI,
                dwSlotIndex,
                slot.dwMapped ? dwNow - slot.dwLastSentAuth : 0,
                slot.dwLastSentAuth ? dwNow - slot.dwLastSentAuth : 0,
                slot.dwLastSentQVal ? dwNow - slot.dwLastSentQVal : 0,
                slot.fKicked);
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        AUTHLEAVE();
        goto lbDone;
    }

    // Set port and mark valid for the next request auth
    slot.wPort    = pSin->sin_port;
    slot.fValid   = 1;
    slot.dwMapped = GetTickCount();

    // Map port to spi
	_ASSERTE(m_rgdwPortMap[dwiPort] == -1);
    m_rgdwPortMap[dwiPort] = dwSPI;

    AUTHLEAVE();
    
    hr = S_OK;

lbDone:
    return hr;
}

HRESULT XPQConnectionMgr::DisableAndUnmapSlot( WORD wPortH )
{
    HRESULT hr;
    DWORD dwiPort;
    DWORD dwSPI;

    // Vector port mapping to correct SPI index
    dwiPort = wPortH - 1024;

    // We can get a port of 0 here if the connection was not fully setup (timeout or otherwise)
    if(dwiPort >= kAuthPortArraySize)
    {
        hr = E_FAIL;
        goto lbDone;
    }

    AUTHENTER();

    // Map the port to the spi through the port map
    dwSPI = m_rgdwPortMap[dwiPort];
    XPQSlotInfo &slot = m_rgSlotInfo[dwSPI];

    USERTRACE7(slot.rgqwUserIDs[0], "[XPQConnectionMgr::DisableAndUnmapSlot]: SPI: %08x, portH: 0x%04x, PortIndex: %u, User0: %I64x, User1: %I64x, User2: %I64x, User3: %I64x",
            dwSPI,
            wPortH,
            wPortH - 1024,
            slot.rgqwUserIDs[0],
            slot.rgqwUserIDs[1],
            slot.rgqwUserIDs[2],
            slot.rgqwUserIDs[3]);

    // Set port and mark valid for the next request auth
    slot.wPort    = 0;
    slot.fValid   = 0;

    // Clear port to spi map
    m_rgdwPortMap[dwiPort] = -1;

    AUTHLEAVE();
    
    hr = S_OK;

lbDone:
    return hr;
}

HRESULT XPQConnectionMgr::AquireSlot(XPQUser *pUser)
{
    HRESULT hr;
    DWORD dwSPI = INVALID_SPI;
    DWORD dwSlotIndex = INVALID_SPI_SLOT_INDEX;

    
    if(0 == pUser)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    _ASSERTE(INVALID_SPI == pUser->Spi());
    _ASSERTE(INVALID_SPI_SLOT_INDEX == pUser->SlotIndex());
    if(INVALID_SPI != pUser->Spi() || INVALID_SPI_SLOT_INDEX != pUser->SlotIndex())
    {
        ERR3(ConnMgr, "[XPQConnectionMgr::AquireSlot]: user: 0x%I64x already attached to SPI: %08x:%u",
                pUser->UserId(), 
                pUser->Spi(),
                pUser->SlotIndex());
        hr = E_FAIL;
        goto lbDone;
    }

    // Enter the critical section
    AUTHENTER();

    if(INVALID_SPI == m_dwNextSPI)
    {
        hr = E_OUTOFMEMORY;
        AUTHLEAVE();
        goto lbDone;
    }

    // Aquire slot data structure
    XPQSlotInfo &aquired = m_rgSlotInfo[m_dwNextSPI];

    // Find the first free slot
    _ASSERTE(aquired.wcUsers < XONLINE_MAX_LOGON_USERS);
    if(XONLINE_MAX_LOGON_USERS == aquired.wcUsers)
    {
        ERR2(ConnMgr, "[XPQConnectionMgr::AquireSlot]: user: 0x%I64x can not be added SPI: %08x is full",
                pUser->UserId(), 
                aquired.dwSPI);

        hr = E_FAIL;
    }

    // Move the next available SPI
    m_dwNextSPI = aquired.dwNextSPI;
    m_dwNumSPI--;

    dwSPI = aquired.dwSPI;

    // Get the first free slot on the SPI
    for(dwSlotIndex = 0; dwSlotIndex < XONLINE_MAX_LOGON_USERS; ++dwSlotIndex)
    {
        if(0 == aquired.rgqwUserIDs[dwSlotIndex])
        {
            aquired.rgqwUserIDs[dwSlotIndex]   = pUser->UserId();
            aquired.rgdwUserFlags[dwSlotIndex] = pUser->UserFlags();
            pUser->SetSpiInfo(dwSPI, dwSlotIndex);
            break;
        }
    }

    // Setup the title ID and console info if this is the first user
    if(0 == aquired.wcUsers)
    {
        aquired.dwTitleId      = pUser->TitleId();
        aquired.dwTitleVersion = 0;
        aquired.dwTitleRegion  = 0;
        aquired.dwTitleId      = pUser->TitleId();
        aquired.wLanguageId    = (WORD)((pUser->UserFlags() & XONLINE_USER_LANGUAGE_MASK) >> 25);

        if(pUser->IsXenonTitleId())
        {
            aquired.SetXenonDefaults();
	        aquired.qwXboxId       = pUser->XboxId();
			aquired.clientVersion.wMajorVersion  =  2;
			aquired.clientVersion.wBuildNumber = XENON_CLIENT_VERSION;
        }
        else
        {
            aquired.SetXboxDefaults();
	        aquired.qwXboxId       = pUser->XboxId();
			aquired.clientVersion.wMajorVersion  =  0;
			aquired.clientVersion.wBuildNumber = 0;
        }
    }

    // Update the slot
    aquired.wcUsers++;
    aquired.dwAquired    = GetTickCount();
    aquired.dwNextSPI    = INVALID_SPI;

    USERTRACE3(pUser->UserId(), "[XPQConnectionMgr::AquireSlot]: added user: 0x%I64x to SPI: %08x:%u",
            pUser->UserId(),
            dwSPI,
            dwSlotIndex);

    // Leave our critical section
    AUTHLEAVE();
    
    hr = S_OK;

lbDone:
    return hr;
}

HRESULT XPQConnectionMgr::ReleaseSlot(DWORD dwSPI)
{
    HRESULT hr;

    _ASSERTE(dwSPI < m_dwMaxSPI);
    if(dwSPI >= m_dwMaxSPI)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    AUTHENTER();
    
    XPQSlotInfo &released = m_rgSlotInfo[dwSPI];

    USERTRACE3(released.rgqwUserIDs[0], "[XPQConnectionMgr::ReleaseSlot]: SPI: %08x, slot active for %.2f seconds, user[0]: %I64x", 
            dwSPI,
            (GetTickCount() - released.dwAquired) * .001f,
            released.rgqwUserIDs[0]);
    
    // clear users
    released.rgqwUserIDs[0]   = 0;
    released.rgqwUserIDs[1]   = 0;
    released.rgqwUserIDs[2]   = 0;
    released.rgqwUserIDs[3]   = 0;
    released.rgdwUserFlags[0] = 0;
    released.rgdwUserFlags[1] = 0;
    released.rgdwUserFlags[2] = 0;
    released.rgdwUserFlags[3] = 0;

    released.dwMapped         = 0;
    released.dwLastSentAuth   = 0;
    released.dwLastSentQVal   = 0;
    released.dwAquired        = 0;
    released.fValid           = 0;
    released.dwNextSPI        = m_dwNextSPI;
    released.wcUsers          = 0;
    m_dwNextSPI               = released.dwSPI;
    m_dwNumSPI++;

    

    AUTHLEAVE();

    hr = S_OK;

lbDone:
    return hr;
}


HRESULT XPQConnectionMgr::RemoveUserFromSlot(const XPQUser *pUser)
{
    HRESULT hr;
    QWORD qwUserId    = pUser->UserId();
    DWORD dwSPI       = pUser->Spi();
    DWORD dwSlotIndex = pUser->SlotIndex(); 

    // Validate slot bounds
    _ASSERTE(INVALID_SPI != dwSPI);
    _ASSERTE(INVALID_SPI_SLOT_INDEX != dwSlotIndex);
    if(dwSPI >= m_dwMaxSPI)
    {
        ERR2(ConnMgr, "[XPQConnectionMgr::RemoveUserFromSlot]: user: 0x%I64x invalid SPI: %08x",
                qwUserId, 
                dwSPI);
        hr = E_INVALIDARG;
        goto lbDone;
    }

    _ASSERTE(0 != qwUserId);
    if(0 == qwUserId)
    {
        ERR1(ConnMgr, "[XPQConnectionMgr::RemoveUserFromSlot]: invalid user: 0x%I64x",
                qwUserId);
        hr = E_INVALIDARG;
        goto lbDone;
    }

    // Validate user is already bound to this slot
    if(INVALID_SPI_SLOT_INDEX == dwSlotIndex || INVALID_SPI == dwSPI)
    {
        ERR3(ConnMgr, "[XPQConnectionMgr::RemoveUserFromSlot]: user: 0x%I64x attached to wrong SPI: %08x:%u",
                qwUserId, 
                dwSPI,
                dwSlotIndex);
        hr = E_FAIL;
        goto lbDone;
    }


    USERTRACE3(qwUserId, "[XPQConnectionMgr::RemoveUserFromSlot]: removing user: 0x%I64x from SPI: %08x:%u",
            qwUserId,
            dwSPI,
            dwSlotIndex);

    AUTHENTER();
    
    XPQSlotInfo &slot = m_rgSlotInfo[dwSPI];

    // Validate that the user slot allocation is correct
    // and remove the user ID if it was found
    if(qwUserId != slot.rgqwUserIDs[dwSlotIndex])
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }
    else
    {       
        // Remove the user
        slot.rgqwUserIDs[dwSlotIndex]   = 0;
        slot.rgdwUserFlags[dwSlotIndex] = 0;
        slot.wcUsers--;
        hr = S_OK;
    }
    
    AUTHLEAVE();

lbDone:
    return hr;
}

HRESULT XPQConnectionMgr::ReleaseSlotIfEmpty(DWORD dwSPI)
{
    HRESULT hr;

    // Validate slot bounds
    _ASSERTE(dwSPI < m_dwMaxSPI);
    if(dwSPI >= m_dwMaxSPI)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    AUTHENTER();
    
    XPQSlotInfo &slot = m_rgSlotInfo[dwSPI];

    if(0 == slot.wcUsers)
    {
        ReleaseSlot(dwSPI);
    }

    AUTHLEAVE();

    hr = S_OK;

lbDone:
    return hr;
}

void XPQConnectionMgr::LogStats() const
{
    TRACE6(ConnMgr, L_OOB, "[XPQConnectionMgr::LogStats]: SPILeft: %u, PendingQvals: %u, QValRate: %.2f, AuthRate: %.2f, KickRate: %.2f, TotalRate: %.2f\n",
            m_dwNumSPI,
            m_qvalPacketQueue.Count(),
            m_fQValRate,
            m_fAuthRate,
            m_fKickRate,
            m_fTotalRate);
}

void XPQConnectionMgr::SetDisableQVals(bool bDisable) 
{
    ms_bDisableQVals = bDisable;
}


void XPQConnectionMgr::SetSGSendDelay(DWORD dwSendDelay)
{
	m_dwSGSendDelay = dwSendDelay;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\detailsbuilder.h ===
#pragma once

//
// Build up a details response metadata into a binary payload

class DetailsBuilder
{
protected:

    enum
    {
        kMaxProperties   = 16,
        kMaxPropertyData = 1024
    };

    struct MsgProperty
    {
        WORD _wTag;
        WORD _wData;
        

        MsgProperty()
        {
            _wTag = 0;
            _wData = 0;
        }

        MsgProperty(BYTE bType, BYTE bId, WORD wData)
        {
            _wTag = (bType << 8) | bId;
            _wData = wData;
        }

        ~MsgProperty()
        {
        }

        BYTE TagId()
        {
            return (BYTE)(_wTag & 0xff);
        }

        BYTE TagType()
        {
            return (BYTE)((_wTag >> 8) & 0xff);
        }
    };

#pragma pack(push, 1)
    // Extended rich message property types
    struct MsgPropertyBinary
    {
        WORD wcbData; 
        // BYTE rgbData[wcbData]
    };
    struct MsgPropertyString
    {
        WORD wcbLen;
        // BYTE rgbData[wcbLen+1]
    };
    struct MsgPropertyAttachment
    {
        DWORD dwcbAttach;
        DWORD dwFlags; 
        DWORD dwUrlLen;
        // BYTE rgbUrl[dwUrlLen] 
    };
#pragma pack(pop)

    WORD        m_wcProperties;
    WORD        m_wcbPropertyData;
    MsgProperty m_rgProperties[kMaxProperties];
    BYTE        m_rgbPropertyData[kMaxPropertyData];

    // Internal APIs
    HRESULT _CheckAdd(BYTE bType, WORD wcBytes);
    HRESULT _AddVariableType(BYTE bType, BYTE bId, const BYTE *pbData, WORD wcbData);

public:

    DetailsBuilder();
    ~DetailsBuilder();

    // Any propeties that are longer than 16bits reserved in the
    // property itself will require bytes reserved in the property data
    // blob.
    //
    // Adding a string requires that the correct encoding is already
    // added and the count of bytes includes the nul terminator.
    //
    // Adding an attachment requires that the correct encoding is already 
    // applied to the url string.
    HRESULT AddBYTE(BYTE bId, BYTE bData);
    HRESULT AddWORD(BYTE bId, WORD wData);
    HRESULT AddDWORD(BYTE bId, DWORD dwData);
    HRESULT AddULONGLONG(BYTE bId, ULONGLONG qwData);
    HRESULT AddDateTime(BYTE bId, ULONGLONG qwData);
    HRESULT AddBinary(BYTE bId, const BYTE *pbData, WORD dwcbData);
    HRESULT AddString(BYTE bId, const BYTE *pbData, WORD dwcbData);
    HRESULT AddAttachment(BYTE bId, DWORD dwcbAttach, DWORD dwFlags, const BYTE *pbUrl, DWORD dwcbUrl);

    DWORD   CalculatePayloadSize() const;
    HRESULT Serialize(BYTE *pbDest, /*INOUT*/ DWORD *pdwcDest);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\Command.cpp ===
#include "StdAfx.h"

MGMT_ImportLoggingCategory(TaskMgr);

enum CommandSetting
{
    kCommandSetting_Index,
    kCommandSetting_Name,
    kCommandSetting_Probability,
    kCommandSetting_Wait,
    kCommandSetting_Timeout,
    kCommandSetting_Flags,
    kCommandSetting_PositiveTransition,
    kCommandSetting_NegativeTransition
};

// Command name->Command object hash
typedef HashTable<LPCSTR, LPCSTRHASHFUNC, PfnCommandFactory> CommandNameHash;
static CommandNameHash g_CommandHash;

//------------------------------------------------------------------------------
// Command data randomizer
//------------------------------------------------------------------------------
void GenerateRandomBytes(BYTE *pbDst, DWORD dwCount)
{
    while(0 != dwCount--)
    {
        *pbDst++ = rand() % 0xff;
    }
}

void GenerateRandomCWString(WCHAR *pwsz, DWORD dwMin, DWORD dwMax)
{
    _ASSERTE(0 != dwMax);
    _ASSERTE(0 != dwMin);
    _ASSERTE(dwMax > dwMin);

    DWORD dwLen = (rand() % (dwMax - dwMin)) + dwMin;
    WCHAR *pwszEnd = pwsz + dwLen;

    while(pwsz < pwszEnd)
    {
        *pwsz++ = (WCHAR)('A' + (rand() % ('Z'-'A')));
    }

    // nul terminate
    *pwsz = 0;
}

DWORD GenerateRandomOnlineState(XPQUser *pUser)
{

	// % of the time do not change
	if((DWORD)(rand()/RAND_MAX*100) < gpUserMgr->GetStateBitsUnchangedPercentage())
	{
		return pUser->State();
	}


    DWORD dwState = P_STATE_MASK_ONLINE;
    
    if(rand() > RAND_MAX/4)
    {
        dwState |= P_STATE_MASK_VOICE;
    }
    if(0 != pUser->MatchId())
    {
        if(rand() < RAND_MAX/4)
        {
            dwState |= P_STATE_MASK_JOINABLE;
        }
        if(rand() < RAND_MAX/2)
        {
            dwState |= P_STATE_MASK_PLAYING;
        }
    }

    return dwState;
}

void GenerateRandomRichPresence(XPQUser *pUser)
{
#define UPDATE_GAME_COUNT_MODES      4
#define UPDATE_GAME_COUNT_PROPERTIES 16
#define UPDATE_GAME_COUNT_CONTEXTS   8
#define UPDATE_GAME_COUNT_CVALUES    4

#define UPDATE_GAME_PROP_USER_INDEX   0x10000000
#define UPDATE_GAME_PROP_USER_NAME    0x40000001
#define UPDATE_GAME_PROP_USER_TOUCHES 0x10000002
#define UPDATE_GAME_PROP_USER_MONEY   0x50000003
#define UPDATE_GAME_CONTEXT_GAME_MODE 0x0000800B

    GI_CONTEXT *pCtx;
    GI_PROPERTY *pProperty;
    DWORD i;
    WORD wcbTitleData = 0;
    BYTE *pbTitleData = pUser->TitleData();
    P_RICH_PRESENCE *pRP = (P_RICH_PRESENCE*)pbTitleData;

    // Do first time initialization of rich presence
    if(0 == pUser->TitleDataLen())
    {
        // All contexts + 1 game mode context
        pRP->cContexts = XPQUser::kCountContexts + 1;
        pRP->cProperties = XPQUser::kCountProperties;
    }

    wcbTitleData = sizeof(P_RICH_PRESENCE);

    // Randomize title mode
    pRP->titlePresence = rand() % XPQUser::kCountGameModes;

    // Create the game mode
    pCtx = (GI_CONTEXT*)(pRP+1);
    pCtx->id = UPDATE_GAME_CONTEXT_GAME_MODE;
    pCtx->value = rand() % XPQUser::kCountContextValues;
    wcbTitleData += sizeof(GI_CONTEXT);

    // Create the contexts
    pCtx = (GI_CONTEXT*)(pbTitleData + wcbTitleData);
    for(DWORD i = 0; i < XPQUser::kCountContexts; ++i)
    {
        _ASSERTE((BYTE*)pCtx < (pbTitleData + MAX_TITLE_DATA_BYTES - sizeof(GI_CONTEXT)));
        pCtx->id = i;
        pCtx->value = rand() % XPQUser::kCountContextValues;
        pCtx++;
        wcbTitleData += sizeof(GI_CONTEXT);
    }

    // Create the properties off the end of the contexts
    pProperty = (GI_PROPERTY*)(pbTitleData + wcbTitleData); 

    // User index
    pProperty->id = UPDATE_GAME_PROP_USER_INDEX;
    *(DWORD*)(pProperty+1) = pUser->UserIndex();
    wcbTitleData += sizeof(GI_PROPERTY) + sizeof(DWORD);
        
    // User name (16bit LEN + STR)
    pProperty = (GI_PROPERTY*)(pbTitleData + wcbTitleData);
    pProperty->id = UPDATE_GAME_PROP_USER_NAME;
    *(WORD*)(pProperty+1) = XONLINE_GAMERTAG_SIZE;
    wcbTitleData += sizeof(GI_PROPERTY) + sizeof(WORD);

    CopyMemory((pbTitleData + wcbTitleData), pUser->Name(), XONLINE_GAMERTAG_SIZE);
    wcbTitleData += XONLINE_GAMERTAG_SIZE;

    // User touches
    pProperty = (GI_PROPERTY*)(pbTitleData + wcbTitleData);
    pProperty->id = UPDATE_GAME_PROP_USER_TOUCHES;
    *(DWORD*)(pProperty+1) = pUser->GetTouchCount();
    wcbTitleData += sizeof(GI_PROPERTY) + sizeof(DWORD);

    // Random float 
    pProperty = (GI_PROPERTY*)(pbTitleData + wcbTitleData);
    pProperty->id = UPDATE_GAME_PROP_USER_MONEY;
    *(float*)(pProperty+1) = rand() * (1.0f/RAND_MAX);
    wcbTitleData += sizeof(GI_PROPERTY) + sizeof(float);

    // Update the user record title byte len
    pUser->SetTitleDataLen(wcbTitleData);
}


//------------------------------------------------------------------------------
// State Batching implementation
//------------------------------------------------------------------------------
HRESULT AppendNotifyCliUpdate(XPQTask *pTask, BasePresenceConnection *pConn, XPQUser *pUser, BOOL fFromAlive)
{
    HRESULT hr = S_OK;

    WorkerBatchData *pBatchData = (WorkerBatchData*)TlsGetValue(gpTaskMgr->GetWorkerBatchTLS());
    if(0 == pBatchData)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR3(TaskMgr, "[AppendNotifyCliUpdate]: failed to get batch TLS, HR: 0x%08x, Task [%u] %s",
                    hr,
                    pTask->ID(),
                    pTask->Name());
        goto lbDone;
    }

	if(WORKER_BATCH_STATE_UPDATE_COUNT-1 == pBatchData->cUpdates && fFromAlive)
	{
		// don't want to send from this connection
		return hr;
	}

    BYTE rgbTitleData[32];
    DWORD cbTitleData = 16 + (rand() % 16);

    DWORD dwState = GenerateRandomOnlineState(pUser); 
    pUser->SetState(dwState);

    if(pUser->IsXenonTitleId())
    {
        GenerateRandomRichPresence(pUser);
    }
    else
    {
        GenerateRandomBytes(rgbTitleData, cbTitleData);
        pUser->SetTitleData(rgbTitleData, (WORD)cbTitleData);
    }

    CSgMsgNotifyCliUpdate &sgupdate = pBatchData->rgUpdates[pBatchData->cUpdates++];

    sgupdate._wType           = SGMSG_TYPE_NOTIFY_CLI_UPD;
    sgupdate._cbEnt           = sizeof(CSgMsgNotifyCliUpdate);
    sgupdate._sgaddr          = gpConnMgr->GetDefSgAddr();
    sgupdate._sgaddr.dwSpiSg  = pUser->Spi();
    sgupdate._sgaddr.qwXboxID = pUser->XboxId();
    sgupdate._qwUserId        = pUser->UserId();
    sgupdate._qwXnkid         = pUser->MatchId();
    sgupdate._dwAuthFlags     = pUser->IsXenonTitleId() ? 1 : 0;
    sgupdate._dwState         = pUser->State();
    sgupdate._dwTitleId       = pUser->TitleId();
    sgupdate._cbTitleData     = pUser->TitleDataLen();
    CopyMemory(sgupdate._rgbTitleData, pUser->TitleData(), pUser->TitleDataLen());

    if(WORKER_BATCH_STATE_UPDATE_COUNT == pBatchData->cUpdates)
    {
        hr = pConn->SendUpdateStateBatch(pTask, pUser, pBatchData->rgUpdates, pBatchData->cUpdates);
        pBatchData->cUpdates = 0;
    }
    else if(!fFromAlive)
    {
        // Give it back to the scheduler if it didn't come from alive, after the scheduler has issued a run it 
        // does not own the task at the level at which it called Run(), hence this
        // slight hack
        if(FAILED(hr = gpTaskMgr->GetScheduler()->PostCompletedTask(pTask)))
        {
            ERR3(TaskMgr, "[AppendNotifyCliUpdate]: failed to post completed task: HR 0x%08x, Task [%u] %s",
                    hr,
                    pTask->ID(),
                    pTask->Name());
            // Let the scheduler handle the failure case here and try to repost the task
        }
    }

lbDone:
    return hr;
}



//------------------------------------------------------------------------------
// Common Command implementation
//------------------------------------------------------------------------------
Command *Command::Create(const char *pszCommandName)
{
    _ASSERTE(0 != pszCommandName);

    Command *pCommand = 0;
    PfnCommandFactory pfnCommandFactory = 0;

    if(g_CommandHash.Lookup(pszCommandName, pfnCommandFactory))
    {
        pCommand = pfnCommandFactory();
        if(0 == pCommand)
        {
            ERR1(TaskMgr, "[Command::Create]: command factory for command name: %s", pszCommandName);
        }
    }
    else
    {
        ERR1(TaskMgr, "[Command::Create]: invalid name: %s", pszCommandName);
    }

    return pCommand;
}

void Command::Register(const char *pszCommandName, PfnCommandFactory pfnCommandFactory)
{
    PfnCommandFactory outValue;
    if(0 == g_CommandHash.BinCount())
    {
        g_CommandHash.Create(253);
    }
    g_CommandHash.Insert(pszCommandName, pfnCommandFactory, outValue, true);
}

//------------------------------------------------------------------------------
// Begin commands
//------------------------------------------------------------------------------

#define BEG_COMMAND(name)                                 \
class Command_##name : public Command                     \
{                                                         \
public:                                                   \
    static Command *Create()                              \
    {                                                     \
        return new Command_##name;                        \
    }                                                     \
    Command_##name() {                                    \
        Command::Register(#name, Command_##name::Create); \
    }                                                     \
    ~Command_##name() {}                                  \
    const char *Name() const { return #name; }            \
    HRESULT Execute(XPQTask *pTask)                       \
    {                                                     \
        HRESULT hr = E_FAIL;                              \
        BasePresenceConnection *pConn = pTask->GetConnection(); \
        _ASSERTE(0 != pConn);                             \
        XPQTaskResourceBlock &block = pTask->GetResourceBlock(); \

#define END_COMMAND(name)                                 \
lbDone:                                                   \
        return hr;                                        \
    }                                                     \
};                                                        \
Command_##name __gCommand_##name##_Instance;              \

#define HR_OP(op) if(FAILED(hr = (op))) { ERR2(TaskMgr, "[Command_%s::Execute]: failed operation " #op " HR: 0x%08x", Name(), hr); goto lbDone; }


BEG_COMMAND(Alive)
    XPQUser *pUserA = block.GetOfflineUser(0);
    HR_OP(pConn->SendAlive(pTask, pUserA));
END_COMMAND(Alive)

BEG_COMMAND(Logoff)
    XPQUser *pUserA = block.GetOnlineUser(0);
    HR_OP(pConn->SendLogoff(pTask, pUserA));
END_COMMAND(Logoff)

BEG_COMMAND(ChangeTitle)
    // change the users title information send update state
    // TODO: select a real title ID
    XPQUser *pUser = block.GetOnlineUser(0);
    pUser->SetTitleId(pUser->TitleId() + 1);
    HR_OP(AppendNotifyCliUpdate(pTask, pConn, pUser, FALSE));
END_COMMAND(ChangeTitle)

BEG_COMMAND(UpdateState)
    BYTE rgbTitleData[32];
    DWORD cbTitleData = 16 + (rand() % 16);
    XPQUser *pUser = block.GetOnlineUser(0);

    if(GetTickCount() >= pUser->MatchExpire())
    {
        pUser->SetMatchId(0);
    }

    DWORD dwState = GenerateRandomOnlineState(pUser); 
    GenerateRandomBytes(rgbTitleData, cbTitleData);

    pUser->SetTitleData(rgbTitleData, (WORD)cbTitleData);
    pUser->SetState(dwState);

    HR_OP(pConn->SendUpdateState(pTask, pUser))
END_COMMAND(UpdateState)

BEG_COMMAND(UpdateStateBatch)
    XPQUser *pUser = block.GetOnlineUser(0);

    // Handle expiration of matchID
    if(GetTickCount() >= pUser->MatchExpire())
    {
        pUser->SetMatchId(0);
    }

	HR_OP(AppendNotifyCliUpdate(pTask, pConn, pUser, FALSE));
END_COMMAND(UpdateStateBatch)

BEG_COMMAND(Dequeue)
    XPQUser *pUser = block.GetOnlineUser(0);
    
    HR_OP(pUser->CollapseNotificationData());
    P_QUEUE_TYPES eQType = pUser->GetNextQueue();

    if(eQType < PQUEUE_NUM_TYPES)
    {
        HR_OP(pConn->SendDequeue(pTask, pUser, eQType));
    }
    else
    {
        ERR1(TaskMgr, "[Command_Dequeue::Execute]: no queue data available for user: %I64x", pUser->UserId());
        hr = E_FAIL;
    }
END_COMMAND(Dequeue)

BEG_COMMAND(PeerSubscribe)
    if(block.Count() > 0)
    {
        XPQUser *pUser = block.GetOnlineUser(0); 
        HR_OP(pConn->SendPeerSubscribe(
                    pTask, 
                    pUser, 
                    block.Users()+1, 
                    (WORD)(block.Count()-1)));
    }
    else
    {
        ERR1(TaskMgr, "[Command_PeerSubscribe::Execute]: not enough users for peer subscribe: %u",
                block.Count());
    }
END_COMMAND(PeerSubscribe)

BEG_COMMAND(PeerUnsubscribe)
{
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendPeerUnsubscribe(pTask, pUser));
}
END_COMMAND(PeerUnsubscribe)

BEG_COMMAND(AddByName)
    XPQUser *pUserA = block.GetOnlineUser(0);
    const XPQUser *pUserB = block.GetOnlineOrOfflineUser(1);
    HR_OP(pConn->SendAddBuddy(pTask, pUserA, pUserB, true));
END_COMMAND(AddByName)

BEG_COMMAND(AddById)
    XPQUser *pUserA = block.GetOnlineUser(0);
    const XPQUser *pUserB = block.GetOnlineOrOfflineUser(1);
    HR_OP(pConn->SendAddBuddy(pTask, pUserA, pUserB, false));
END_COMMAND(AddById)

BEG_COMMAND(DeleteBuddy)
    XPQUser *pUserA = block.GetOnlineUser(0);
    const XPQUser *pUserB = block.GetUser(0);
    HR_OP(pConn->SendDeleteBuddy(pTask, pUserA, pUserB));
END_COMMAND(DeleteBuddy)

BEG_COMMAND(Accept)
    XPQUser *pUserA = block.GetOnlineUser(0);
    const XPQUser *pUserB = block.GetUser(0);
    HR_OP(pConn->SendAcceptBuddy(pTask, pUserA, pUserB));
END_COMMAND(Accept)

BEG_COMMAND(Reject)
    XPQUser *pUserA = block.GetOnlineUser(0);
    const XPQUser *pUserB = block.GetUser(0);
    HR_OP(pConn->SendRejectBuddy(pTask, pUserA, pUserB, false));
END_COMMAND(Reject)

BEG_COMMAND(RejectNever)
    XPQUser *pUserA = block.GetOnlineUser(0);
    const XPQUser *pUserB = block.GetUser(0);
    HR_OP(pConn->SendRejectBuddy(pTask, pUserA, pUserB, true));
END_COMMAND(RejectNever)

BEG_COMMAND(Block)
    XPQUser *pUserA = block.GetOnlineUser(0);
    const XPQUser *pUserB = block.GetOnlineOrOfflineUser(1);
    HR_OP(pConn->SendBlock(pTask, pUserA, pUserB));
END_COMMAND(Block)

BEG_COMMAND(Unblock)
    XPQUser *pUserA = block.GetOnlineUser(0);
    const XPQUser *pUserB = block.GetUser(0);
    HR_OP(pConn->SendUnblock(pTask, pUserA, pUserB, false));
END_COMMAND(Unblock)

BEG_COMMAND(UnblockAll)
    XPQUser *pUserA = block.GetOnlineUser(0);
    HR_OP(pConn->SendUnblock(pTask, pUserA, (XPQUser*)0, true));
END_COMMAND(UnblockAll)

BEG_COMMAND(AddAffiliatesEncountered)
    if(block.Count() > 1)
    {
        XPQUser *pUser = block.GetOnlineUser(0); // steal the first user as the owner
        HR_OP(pConn->SendAddAffiliates(
                    pTask, 
                    pUser, 
                    X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_ENCOUNTERED_INDEX),
                    pUser->TitleId(),
                    block.Users()+1, 
                    (WORD)(block.Count()-1)));
    }
END_COMMAND(AddAffiliatesEncountered)

BEG_COMMAND(AddAffiliatesCompletedGame)
    if(block.Count() > 1)
    {
        XPQUser *pUser = block.GetOnlineUser(0); // steal the first user as the owner
        HR_OP(pConn->SendAddAffiliates(
                    pTask, 
                    pUser, 
                    X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_COMPLETED_GAME_INDEX),
                    pUser->TitleId(),
                    block.Users()+1, 
                    (WORD)(block.Count()-1)));
    }
END_COMMAND(AddAffiliatesCompletedGame)

BEG_COMMAND(AddAffiliatesPositiveFeedback)
    XPQUser *pUserA = block.GetOnlineUser(0);
    XPQUser *pUserB = block.GetOnlineUser(1);
    HR_OP(pConn->SendAddAffiliates(
            pTask, 
            pUserA, 
            X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_POSITIVE_FEEDBACK_INDEX), 
            pUserA->TitleId(),
            (const XPQUser**)&pUserB,
            1));
END_COMMAND(AddAffiliatesPositiveFeedback)

BEG_COMMAND(AddAffiliatesNegativeFeedback)
    XPQUser *pUserA = block.GetOnlineUser(0);
    XPQUser *pUserB = block.GetOnlineUser(1);
    HR_OP(pConn->SendAddAffiliates(
            pTask, 
            pUserA, 
            X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX), 
            pUserA->TitleId(),
            (const XPQUser**)&pUserB,
            1));
END_COMMAND(AddAffiliatesNegativeFeedback)

BEG_COMMAND(AddAffiliatesFavoritesList)
    XPQUser *pUserA = block.GetOnlineUser(0);
    XPQUser *pUserB = block.GetOnlineUser(1);
    HR_OP(pConn->SendAddAffiliates(
            pTask, 
            pUserA, 
            X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_FAVORITES_INDEX), 
            pUserA->TitleId(),
            (const XPQUser**)&pUserB,
            1));
END_COMMAND(AddAffiliatesFavoritesList)

BEG_COMMAND(IsAffiliate)
    XPQUser *pUserA = block.GetOnlineUser(0);
    XPQUser *pUserB = block.GetOnlineUser(1);
    HR_OP(pConn->SendIsAffiliate(pTask, pUserA, pUserB));
END_COMMAND(IsAffiliate)

BEG_COMMAND(QueryAffiliatesDashRecentPlayers)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendQueryAffiliates(
            pTask, 
            pUser, 
            X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_ENCOUNTERED_INDEX),
            100,
            0,
            FALSE));
END_COMMAND(QueryAffiliatesDashRecentPlayers)

BEG_COMMAND(QueryAffiliatesDashFavorites)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendQueryAffiliates(
            pTask, 
            pUser, 
            X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_FAVORITES_INDEX),
            100,
            0,
            FALSE));
END_COMMAND(QueryAffiliatesDashFavorites)

BEG_COMMAND(QueryAffiliatesMatch)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendQueryAffiliates(
            pTask, 
            pUser,
            X_AFFILIATE_FLAGS_IN_USE,
            0,
            pUser->TitleId(),
            TRUE));
END_COMMAND(QueryAffiliatesMatch)

BEG_COMMAND(Invite)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendInvite(
                    pTask, 
                    pUser, 
                    (const XPQUser**)block.Users()+1, 
                    (WORD)(block.Count()-1)));
END_COMMAND(Invite)

BEG_COMMAND(CancelInvite)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendCancelInvite(
                    pTask, 
                    pUser, 
                    block.ROUsers(), 
                    (WORD)(block.ROCount())));
END_COMMAND(CancelInvite)

BEG_COMMAND(AnswerInviteYes)
    XPQUser *pUser = block.GetOnlineUser(0);
    const XPQUser *pHost = block.GetUser(0);
    HR_OP(pConn->SendAnswerInvite(pTask, pUser, pHost, pHost->MatchId(), true));
END_COMMAND(AnswerInviteYes)

BEG_COMMAND(AnswerInviteNo)
    XPQUser *pUser = block.GetOnlineUser(0);
    const XPQUser *pHost = block.GetUser(0);
    HR_OP(pConn->SendAnswerInvite(pTask, pUser, pHost, pHost->MatchId(), false));
END_COMMAND(AnswerInviteNo)

BEG_COMMAND(PartyInvite)
    XPQUser *pUser = block.GetOnlineUser(0);
    const XPQUser *pTarget = block.GetOnlineOrOfflineUser(1);

    ULONGLONG rgRecipients[100];
    DWORD cRecipients = 0;

    for(DWORD i = 1, c = block.Count(); i < c; ++i)
    {
        rgRecipients[cRecipients++] = block.GetOnlineOrOfflineUser(i)->UserId();
    }

	HR_OP(pConn->SendSendMessage(pTask, pUser, XONLINE_MSG_TYPE_PARTY_CHAT_INVITE, 0, 0, rgRecipients, (WORD)cRecipients, NULL, 0, (WORD)1440)); 
END_COMMAND(PartyInvite)

BEG_COMMAND(SendMessage)
    XPQUser *pUser = block.GetOnlineUser(0);
    const XPQUser *pTarget = block.GetOnlineOrOfflineUser(1);

    ULONGLONG rgRecipients[100];
    DWORD cRecipients = 0;

    for(DWORD i = 1, c = block.Count(); i < c; ++i)
    {
        rgRecipients[cRecipients++] = block.GetOnlineOrOfflineUser(i)->UserId();
    }

	// TODO: This always uses title custom messages.  Should use expected ratio of message types.
    HR_OP(pConn->SendSendMessage(pTask, pUser, XONLINE_MSG_TYPE_TITLE_CUSTOM, 0, 0, rgRecipients, (WORD)cRecipients, NULL, 0, (WORD)(43200))); 
END_COMMAND(SendMessage)

BEG_COMMAND(EnumMessages)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendEnumMessages(pTask, pUser));   
END_COMMAND(EnumMessages)

BEG_COMMAND(MessageSummaryNext)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendMessageSummary(pTask, pUser, pUser->GetNextUnreadMessageId()));
END_COMMAND(MessageSummaryNext)

BEG_COMMAND(MessageSummary2Next)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendMessageSummary2(pTask, pUser, pUser->GetNextUnreadMessageId()));
END_COMMAND(MessageSummary2Next)

BEG_COMMAND(MessageDetailsNext)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendMessageDetails(pTask, pUser, pUser->GetNextUnreadMessageId(), XONLINE_MSG_FLAG_READ, 0));
END_COMMAND(MessageDetailsNext)

BEG_COMMAND(MessageFlagReadNext)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendMessageFlags(pTask, pUser, pUser->GetNextUnreadMessageId(), XONLINE_MSG_FLAG_READ, 0));
END_COMMAND(MessageFlagReadNext)

BEG_COMMAND(MessageDeleteNext)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendMessageDelete(pTask, pUser, pUser->GetNextReadMessageId(), false));
END_COMMAND(MessageDeleteNext)

BEG_COMMAND(MessageDeleteNextAndBlock)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendMessageDelete(pTask, pUser, pUser->GetNextUnreadMessageId(), true));
END_COMMAND(MessageDeleteNextAndBlock)

BEG_COMMAND(MessageRevokeNext)
    XPQUser *pUser = block.GetOnlineUser(0);
    const XPQUser *pTarget = block.GetUser(0);

    // TODO: possibly enable multiple recipients
    // I don't think this will work unless I get a real message ID from the user
    Q_RECIPIENT_RESULT recipient;
    recipient.qwUserID = pTarget->UserId();
    recipient.dwMessageID = 1;
    HR_OP(pConn->SendMessageRevoke(pTask, pUser, &recipient, 1));
END_COMMAND(MessageRevokeNext)

BEG_COMMAND(DeleteTitle)
    XPQUser *pUser = block.GetOnlineUser(0);
    DWORD dwTitle = pUser->GetOfflineTitle();
    HR_OP(pConn->SendDeleteTitle(pTask, pUser, dwTitle));
END_COMMAND(DeleteTitle)

BEG_COMMAND(EnumTitles)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendEnumTitles(pTask, pUser));
END_COMMAND(EnumTitles)

BEG_COMMAND(CreateTeam)
    XPQUser *pUser = block.GetOnlineUser(0);
    
    WCHAR wszTeamName[XONLINE_MAX_TEAM_NAME_SIZE];
    WCHAR wszTeamDescription[XONLINE_MAX_TEAM_DESCRIPTION_SIZE];
    WCHAR wszTeamMotto[XONLINE_MAX_TEAM_MOTTO_SIZE];
    WCHAR wszTeamUrl[XONLINE_MAX_TEAM_URL_SIZE];
    BYTE  rgbTeamData[XONLINE_MAX_TEAM_DATA_SIZE];
    BYTE  rgbMemberData[XONLINE_MAX_TEAM_MEMBER_DATA_SIZE];

    GenerateRandomCWString(wszTeamName, 4, XONLINE_MAX_TEAM_NAME_SIZE-1);
    GenerateRandomCWString(wszTeamDescription, 4, XONLINE_MAX_TEAM_DESCRIPTION_SIZE-1);
    GenerateRandomCWString(wszTeamMotto, 4, XONLINE_MAX_TEAM_MOTTO_SIZE-1);
    GenerateRandomCWString(wszTeamUrl, 4, XONLINE_MAX_TEAM_URL_SIZE-1);

    GenerateRandomBytes(rgbTeamData, XONLINE_MAX_TEAM_DATA_SIZE);
    GenerateRandomBytes(rgbMemberData, XONLINE_MAX_TEAM_MEMBER_DATA_SIZE);

    // Send the request
    if(FAILED(hr = pConn->SendCreateTeam(
                pTask, 
                pUser,
                wszTeamName,
                wszTeamDescription,
                wszTeamMotto,
                wszTeamUrl,
                rgbTeamData,
                XONLINE_MAX_TEAM_DATA_SIZE,
                rgbMemberData,
                XONLINE_MAX_TEAM_MEMBER_DATA_SIZE)))
    {
        goto lbDone;
    }

END_COMMAND(CreateTeam)

BEG_COMMAND(ManageTeam)
    XPQUser *pUser = block.GetOnlineUser(0);

    const XPQTeamData *pTeamData;

    HR_OP(pUser->GetRandomStorageItem(USERPOOL_TEAM_ID, (const void**)&pTeamData));

    if(0 == pTeamData)
    {
        ERR1(TaskMgr, "[Command_ManageTeam::Execute]: requires at least one team to manage, user: %I64x", 
                pUser->UserId());
        hr = E_FAIL;
        goto lbDone;
    }

    WCHAR wszTeamName[XONLINE_MAX_TEAM_NAME_SIZE];
    WCHAR wszTeamDescription[XONLINE_MAX_TEAM_DESCRIPTION_SIZE];
    WCHAR wszTeamMotto[XONLINE_MAX_TEAM_MOTTO_SIZE];
    WCHAR wszTeamUrl[XONLINE_MAX_TEAM_URL_SIZE];
    BYTE  rgbTeamData[XONLINE_MAX_TEAM_DATA_SIZE];
    BYTE  rgbMemberData[XONLINE_MAX_TEAM_MEMBER_DATA_SIZE];

    GenerateRandomCWString(wszTeamName, 4, XONLINE_MAX_TEAM_NAME_SIZE-1);
    GenerateRandomCWString(wszTeamDescription, 4, XONLINE_MAX_TEAM_DESCRIPTION_SIZE-1);
    GenerateRandomCWString(wszTeamMotto, 4, XONLINE_MAX_TEAM_MOTTO_SIZE-1);
    GenerateRandomCWString(wszTeamUrl, 4, XONLINE_MAX_TEAM_URL_SIZE-1);

    GenerateRandomBytes(rgbTeamData, XONLINE_MAX_TEAM_DATA_SIZE);

    HR_OP(pConn->SendManageTeam(
                pTask, 
                pUser, 
                pTeamData->qwTeamId, 
                wszTeamName,
                wszTeamDescription,
                wszTeamMotto,
                wszTeamUrl,
                rgbTeamData,
                XONLINE_MAX_TEAM_DATA_SIZE));
END_COMMAND(ManageTeam)

BEG_COMMAND(DeleteTeam)
    XPQUser *pUser = block.GetOnlineUser(0);

    const XPQTeamData *pTeamData;
    HR_OP(pUser->GetRandomStorageItem(USERPOOL_TEAM_ID, (const void**)&pTeamData));
    if(0 == pTeamData)
    {
        ERR1(TaskMgr, "[Command_DeleteTeam::Execute]: requires at least one team to delete, user: %I64x", 
                pUser->UserId());
        hr = E_FAIL;
        goto lbDone;
    }

    HR_OP(pConn->SendDeleteTeam(
                pTask,
                pUser,
                pTeamData->qwTeamId));
END_COMMAND(DeleteTeam)

BEG_COMMAND(ListTeams)
    XPQUser *pUser = block.GetOnlineUser(0);

    ULONGLONG rgqwTeamIds[1];
    HR_OP(pConn->SendListTeams(pTask, pUser, rgqwTeamIds, 0));
END_COMMAND(ListTeams)

BEG_COMMAND(ListUserTeams)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendListUserTeams(pTask, pUser));
END_COMMAND(ListUserTeams)

BEG_COMMAND(RecruitTeamMember)
    XPQUser *pUser = block.GetOnlineUser(0);
    const XPQUser *pRecruit = block.GetOnlineOrOfflineUser(1);

    BYTE rgbMemberData[XONLINE_MAX_TEAM_MEMBER_DATA_SIZE];
    GenerateRandomBytes(rgbMemberData, XONLINE_MAX_TEAM_MEMBER_DATA_SIZE);

    const XPQTeamData *pTeamData;
    HR_OP(pUser->GetRandomStorageItem(USERPOOL_TEAM_ID, (const void**)&pTeamData));
    if(0 == pTeamData)
    {
        ERR1(TaskMgr, "[Command_RecruitTeamMember::Execute]: requires at least one team to recruit a user, user: %I64x", 
                pUser->UserId());
        hr = E_FAIL;
        goto lbDone;
    }

    HR_OP(pConn->SendRecruitTeamMember(
                    pTask, 
                    pUser, 
                    pRecruit, 
                    pTeamData->qwTeamId, 
                    0,
                    rgbMemberData, 
                    XONLINE_MAX_TEAM_MEMBER_DATA_SIZE));
END_COMMAND(RecruitTeamMember)

BEG_COMMAND(JoinTeamYes)
    XPQUser *pUser = block.GetOnlineUser(0);
    XPQTeamMemberData *pMemberData;
    HR_OP(pUser->GetTeamRecruitment(&pMemberData));
    if(0 == pMemberData)
    {
        ERR1(TaskMgr, "[Command_JoinTeamYes::Execute]: requires a team recruitment object, user: %I64x",
                pUser->UserId());
        hr = E_FAIL;
        goto lbDone;
    }
    HR_OP(pConn->SendJoinTeam(pTask, pUser, pMemberData->qwTeamId, 0, PINVITE_REPLY_YES));
END_COMMAND(JoinTeamYes)

BEG_COMMAND(JoinTeamNo)
    XPQUser *pUser = block.GetOnlineUser(0);
    XPQTeamMemberData *pMemberData;
    HR_OP(pUser->GetTeamRecruitment(&pMemberData));
    if(0 == pMemberData)
    {
        ERR1(TaskMgr, "[Command_JoinTeamNo::Execute]: requires a team recruitment object, user: %I64x",
                pUser->UserId());
        hr = E_FAIL;
        goto lbDone;
    }
    HR_OP(pConn->SendJoinTeam(pTask, pUser, pMemberData->qwTeamId, 0, PINVITE_REPLY_NO));
END_COMMAND(JoinTeamNo)

BEG_COMMAND(JoinTeamNever)
    XPQUser *pUser = block.GetOnlineUser(0);
    XPQTeamMemberData *pMemberData;
    HR_OP(pUser->GetTeamRecruitment(&pMemberData));
    if(0 == pMemberData)
    {
        ERR1(TaskMgr, "[Command_JoinTeamNever::Execute]: requires a team recruitment object, user: %I64x",
                pUser->UserId());
        hr = E_FAIL;
        goto lbDone;
    }
    HR_OP(pConn->SendJoinTeam(pTask, pUser, pMemberData->qwTeamId, 0, PINVITE_REPLY_NEVER));
END_COMMAND(JoinTeamNever)

BEG_COMMAND(ManageTeamMemberPromote)
    XPQUser *pUser = block.GetOnlineUser(0);
    XPQUser *pMember = 0;
    const XPQTeamData *pTeamData;
    DWORD dwUserIndex;
    DWORD dwMemberPriv;

    // Get a random owned team for this user
    HR_OP(pUser->GetRandomStorageItem(USERPOOL_TEAM_ID, (const void**)&pTeamData));
    if(0 == pTeamData)
    {
        ERR1(TaskMgr, "[Command_ManageTeamMemberPromote::Execute]: requires at least one team to find user for promotion, user: %I64x", 
                pUser->UserId());
        hr = E_FAIL;
        goto lbDone;
    }
    // Generate new member bytes
    BYTE rgbMemberData[XONLINE_MAX_TEAM_MEMBER_DATA_SIZE];
    GenerateRandomBytes(rgbMemberData, XONLINE_MAX_TEAM_MEMBER_DATA_SIZE);

    // If we don't find a user to manage we will just modify our own member data bytes
    if(S_OK != pTeamData->FindMemberInState(XPQ_TEAM_MEMBER_STATE_MEMBER, &dwUserIndex))
    {
        pMember = pUser;
        dwMemberPriv = XPQ_TEAM_MEMBER_PRIV_OWNER;
        DBG1(TaskMgr, "[Command_ManageTeamMemberPromote::Execute]: doing a plain manage on owner since no members available to promote, user: %I64x",
                pUser->UserId());
    }
    else
    {
        pMember = gpUserMgr->UserPtrFromIndex(dwUserIndex);
        if(0 == pMember)
        {
            ERR3(TaskMgr, "[Command_ManageTeamMemberPromote::Execute]: invalid user index in member list %u, out of range, user: %I64x, team: %I64x",
                    dwUserIndex,
                    pUser->UserId(),
                    pTeamData->qwTeamId);
            goto lbDone;
        }
    }
    
    HR_OP(pConn->SendManageTeamMember(
                    pTask, 
                    pUser, 
                    pMember, 
                    pTeamData->qwTeamId, 
                    dwMemberPriv, 
                    rgbMemberData, 
                    XONLINE_MAX_TEAM_MEMBER_DATA_SIZE));
END_COMMAND(ManageTeamMemberPromote)

BEG_COMMAND(ManageTeamMemberDemote)
    XPQUser *pUser = block.GetOnlineUser(0);
    XPQUser *pMember = 0;
    const XPQTeamData *pTeamData;
    DWORD dwUserIndex;
    DWORD dwMemberPriv;

    // Get a random owned team for this user
    HR_OP(pUser->GetRandomStorageItem(USERPOOL_TEAM_ID, (const void**)&pTeamData));
    if(0 == pTeamData)
    {
        ERR1(TaskMgr, "[Command_ManageTeamMemberDemote::Execute]: requires at least one team to find user for demotion, user: %I64x", 
                pUser->UserId());
        hr = E_FAIL;
        goto lbDone;
    }

    // Generate new member bytes
    BYTE rgbMemberData[XONLINE_MAX_TEAM_MEMBER_DATA_SIZE];
    GenerateRandomBytes(rgbMemberData, XONLINE_MAX_TEAM_MEMBER_DATA_SIZE);

    // If we don't find a user to manage we will just modify our own member data bytes
    if(S_OK != pTeamData->FindMemberInState(XPQ_TEAM_MEMBER_STATE_OFFICER, &dwUserIndex))
    {
        pMember = pUser;
        dwMemberPriv = XPQ_TEAM_MEMBER_PRIV_OWNER;
        DBG1(TaskMgr, "[Command_ManageTeamMemberDemote::Execute]: doing a plain manage on owner since no members available to demote, user: %I64x",
                pUser->UserId());
    }
    else
    {
        dwMemberPriv = XPQ_TEAM_MEMBER_PRIV_NORMAL;
        pMember = gpUserMgr->UserPtrFromIndex(dwUserIndex);
        if(0 == pMember)
        {
            ERR3(TaskMgr, "[Command_ManageTeamMemberPromote::Execute]: invalid user index in member list %u, out of range, user: %I64x, team: %I64x",
                    dwUserIndex,
                    pUser->UserId(),
                    pTeamData->qwTeamId);
            goto lbDone;
        }
    }
    
    HR_OP(pConn->SendManageTeamMember(
                    pTask, 
                    pUser, 
                    pMember, 
                    pTeamData->qwTeamId, 
                    dwMemberPriv, 
                    rgbMemberData, 
                    XONLINE_MAX_TEAM_MEMBER_DATA_SIZE));
END_COMMAND(ManageTeamMemberDemote)

BEG_COMMAND(RemoveTeamMember)
    XPQUser *pUser = block.GetOnlineUser(0);
    const XPQUser *pMember = 0;
    DWORD dwUserIndex = 0;

    const XPQTeamData *pTeamData;
    XPQTeamMemberData *pMemberData;

    HR_OP(pUser->GetRandomStorageItem(USERPOOL_TEAM_ID, (const void**)&pTeamData));
    if(0 == pTeamData)
    {
        ERR1(TaskMgr, "[Command_RemoveTeamMember::Execute]: requires at least one team to find a member to remove, user: %I64x", 
                pUser->UserId());
        hr = E_FAIL;
        goto lbDone;
    }

    if(S_OK != pTeamData->FindMemberInState(XPQ_TEAM_MEMBER_STATE_MEMBER, &dwUserIndex))
    {
        ERR2(TaskMgr, "[Command_RemoveTeamMember::Execute]: no member available to remove in team: %I64x, user: %I64x",
                pTeamData->qwTeamId,
                pUser->UserId());
        hr = E_FAIL;
        goto lbDone;
    }

    pMember = gpUserMgr->UserPtrFromIndex(dwUserIndex);
    if(0 == pMember)
    {
        ERR3(TaskMgr, "[Command_RemoveTeamMember::Execute]: invalid user index supplied from team, user: %I64x, team: %I64x, userindex: %u",
                pUser->UserId(),
                pTeamData->qwTeamId,
                dwUserIndex);
        hr = E_FAIL;
        goto lbDone;
    }

    HR_OP(pConn->SendRemoveTeamMember(pTask, pUser, pMember, pTeamData->qwTeamId));
END_COMMAND(RemoveTeamMember)

BEG_COMMAND(ListTeamMembers)
    XPQUser *pUser = block.GetOnlineUser(0);
    ULONGLONG qwTeamId = 0;

    const XPQTeamData *pTeamData;
    const XPQTeamMemberData *pMemberData;

    HR_OP(pUser->GetRandomStorageItem(USERPOOL_TEAM_ID, (const void**)&pTeamData));
    HR_OP(pUser->GetRandomStorageItem(USERPOOL_TEAM_MEMBER_ID, (const void**)&pMemberData));

    if(0 == pTeamData && 0 == pMemberData)
    {
        ERR1(TaskMgr, "[Command_ListTeamMembers::Execute]: requires at least one team or membership record to list members, user: %I64x", 
                pUser->UserId());
        hr = E_FAIL;
        goto lbDone;
    }

    qwTeamId = (0 != pTeamData) ? pTeamData->qwTeamId : pMemberData->qwTeamId;

    HR_OP(pConn->SendListTeamMembers(pTask, pUser, qwTeamId, false));
END_COMMAND(ListTeamMembers)

BEG_COMMAND(ListTeamMembersAndRecruits)
    XPQUser *pUser = block.GetOnlineUser(0);
    ULONGLONG qwTeamId = 0;

    const XPQTeamData *pTeamData;
    const XPQTeamMemberData *pMemberData;

    HR_OP(pUser->GetRandomStorageItem(USERPOOL_TEAM_ID, (const void**)&pTeamData));
    HR_OP(pUser->GetRandomStorageItem(USERPOOL_TEAM_MEMBER_ID, (const void**)&pMemberData));

    if(0 == pTeamData && 0 == pMemberData)
    {
        ERR1(TaskMgr, "[Command_ListTeamMembersAndRecruits::Execute]: requires at least one team or membership record to list members, user: %I64x", 
                pUser->UserId());
        hr = E_FAIL;
        goto lbDone;
    }

    qwTeamId = (0 != pTeamData) ? pTeamData->qwTeamId : pMemberData->qwTeamId;

    HR_OP(pConn->SendListTeamMembers(pTask, pUser, qwTeamId, true));
END_COMMAND(ListTeamMembersAndRecruits)

BEG_COMMAND(GetTeamTicket)
    XPQUser *pUser = block.GetOnlineUser(0);
    ULONGLONG qwTeamId = 0;

    const XPQTeamData *pTeamData;
    const XPQTeamMemberData *pMemberData;

    HR_OP(pUser->GetRandomStorageItem(USERPOOL_TEAM_ID, (const void**)&pTeamData));
    HR_OP(pUser->GetRandomStorageItem(USERPOOL_TEAM_MEMBER_ID, (const void**)&pMemberData));

    if(0 == pTeamData && 0 == pMemberData)
    {
        ERR1(TaskMgr, "[Command_GetTeamTicket::Execute]: requires at least one team or membership record to get team ticket, user: %I64x", 
                pUser->UserId());
        hr = E_FAIL;
        goto lbDone;
    }

    HR_OP(pConn->SendGetTeamTicket(pTask, pUser));
END_COMMAND(GetTeamTicket)

BEG_COMMAND(WebFriends)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendWebFriends(pTask, pUser));
END_COMMAND(WebFriends)

BEG_COMMAND(GetFriendsList)
    // TODO: make other user argument read-only non-lock
    XPQUser *pUser = block.GetOnlineUser(0);
    const XPQUser *pOther = block.GetOnlineOrOfflineUser(1);
    HR_OP(pConn->SendGetFriendsList(pTask, pUser, pOther));
END_COMMAND(GetFriendsList)

BEG_COMMAND(GetPresenceInfo)
    // TODO: make other user argument read-only non-lock
    XPQUser *pUser = block.GetOnlineUser(0);
    const XPQUser *pOther = block.GetOnlineOrOfflineUser(1);
    HR_OP(pConn->SendGetPresenceInfo(pTask, pUser, pOther));
END_COMMAND(GetPresenceInfo)

BEG_COMMAND(FindUserByName)
    XPQUser *pUser = block.GetOnlineUser(0);
    const XPQUser *pOther = block.GetOnlineOrOfflineUser(1);
    HR_OP(pConn->SendFindUser(pTask, pUser, 0, pOther->Name()));
END_COMMAND(FindUserByName)

BEG_COMMAND(FindUserById)
    XPQUser *pUser = block.GetOnlineUser(0);
    const XPQUser *pOther = block.GetOnlineOrOfflineUser(1);
    HR_OP(pConn->SendFindUser(pTask, pUser, pOther->UserId(), ""));
END_COMMAND(FindUserById)

BEG_COMMAND(FindUsers)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendFindUsers(
                    pTask, 
                    pUser, 
                    (const XPQUser**)block.Users()+1, 
                    (WORD)(block.Count()-1)));
END_COMMAND(FindUsers)

BEG_COMMAND(InvalidateUser)
    XPQUser *pUser = block.GetOnlineUser(0);
    HR_OP(pConn->SendInvalidateUser(pTask, pUser));
END_COMMAND(InvalidateUser)

BEG_COMMAND(Echo)
    XPQUser *pUser = block.GetOnlineOrOfflineUser(0);
    HR_OP(pConn->SendEcho(pTask, pUser));
END_COMMAND(Echo)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\dumpmsg.h ===
// Copyright  2001 Microsoft.  ALL RIGHTS RESERVED

///////////////////////////////////////////////////////////////////////////////
// Dump.h
//  Template functions to load messages into buffers
//

#ifndef _XPENGINE_DUMP_HELPERS_H_
#define _XPENGINE_DUMP_HELPERS_H_

//------------------------------------------------------------------------------
//  Base Msg  
//------------------------------------------------------------------------------
template <class T> 
HRESULT WriteMsgData( 
    T*          pSrc, 
    DWORD       dwSPI,
    bool        bHttpAuth,
    BYTE*       pDest, 
    DWORD       dwDest, 
    DWORD*      pdwDumped )
{
	HRESULT hr;
	DWORD dwHeader;
	DWORD dwT = sizeof( T );

	if( (dwT > dwDest) || 
        (NULL == pDest) || 
        (NULL == pSrc) )
    {
		hr = E_INVALIDARG;
		goto lbDone;
    }

	if(FAILED(hr = WriteHttpHeader(dwSPI, bHttpAuth, pDest, dwDest, pSrc->dwMsgType, dwT, &dwHeader)))
	{
		goto lbDone;
	}

	( (BASE_MSG_HEADER*)pSrc )->dwMsgLen = dwT - sizeof( BASE_MSG_HEADER );
	memcpy( (void*)(pDest + dwHeader), pSrc, dwT );
	*pdwDumped = dwT + dwHeader;


	hr = S_OK;
lbDone:
	return hr;
}

//------------------------------------------------------------------------------
//  Base Msg  
//------------------------------------------------------------------------------
template <class T> 
BYTE* GetMsgData(T* pSrc)
{
	DWORD dwT = sizeof( T );

	( (BASE_MSG_HEADER*)pSrc )->dwMsgLen = dwT - sizeof( BASE_MSG_HEADER );

	return (BYTE*)pSrc;
}


//------------------------------------------------------------------------------
//  Base Msg + 1 block of extended data
//------------------------------------------------------------------------------
template <class T> 
HRESULT WriteMsgData( 
    T*          pSrc, 
    DWORD       dwSPI,
    bool        bHttpAuth,
    const BYTE* pExData, 
    DWORD       dwExData, 
    BYTE*       pDest, 
    DWORD       dwDest, 
    DWORD*      pdwDumped )
{
	HRESULT hr;
	DWORD dwHeader;
	DWORD dwT   = sizeof( T );
	DWORD dwALL = dwT + dwExData;

	if( (dwALL > dwDest) || 
        (NULL == pDest) || 
        (NULL == pSrc) || 
        (NULL == pExData) )
    {
		hr = E_INVALIDARG;
		goto lbDone;
    }

	if(FAILED(hr = WriteHttpHeader(dwSPI, bHttpAuth, pDest, dwDest, pSrc->dwMsgType, dwALL, &dwHeader)))
	{
		goto lbDone;
	}

	( (BASE_MSG_HEADER*)pSrc )->dwMsgLen = dwALL - sizeof( BASE_MSG_HEADER );
	memcpy( (void*)(pDest + dwHeader), pSrc, dwT );
	memcpy( (void*)(pDest + dwHeader + dwT), pExData, dwExData );
	*pdwDumped = dwALL + dwHeader;

lbDone:
	return hr;
}

//------------------------------------------------------------------------------
//  Base Msg + 2 blocks of extended data
//------------------------------------------------------------------------------
template <class T> 
HRESULT WriteMsgData( 
    T*          pSrc, 
    DWORD       dwSPI,
    bool        bHttpAuth,
    const BYTE* pExData1, 
    DWORD       dwExData1, 
    const BYTE* pExData2, 
    DWORD       dwExData2, 
    BYTE*       pDest, 
    DWORD       dwDest, 
    DWORD*      pdwDumped )
{
	HRESULT hr;
	DWORD dwHeader;
	DWORD dwT = sizeof( T );
	DWORD dwALL = dwT + dwExData1 + dwExData2;

	if( (dwALL > dwDest) || 
        (NULL == pDest) || 
        (NULL == pSrc) || 
        (NULL == pExData1) || 
        (NULL == pExData2) )
    {
		hr = E_INVALIDARG;
		goto lbDone;
    }

	if(FAILED(hr = WriteHttpHeader(dwSPI, bHttpAuth, pDest, dwDest, pSrc->dwMsgType, dwALL, &dwHeader)))
	{
		goto lbDone;
	}

	( (BASE_MSG_HEADER*)pSrc )->dwMsgLen = dwALL - sizeof( BASE_MSG_HEADER );
	memcpy( (void*)(pDest + dwHeader), pSrc, dwT );
	memcpy( (void*)(pDest + dwHeader + dwT), pExData1, dwExData1 );
    memcpy( (void*)(pDest + dwHeader + dwT + dwExData1), pExData2, dwExData2 );
	*pdwDumped = dwALL + dwHeader;

lbDone:
	return hr;
}

//------------------------------------------------------------------------------
//  Base Msg + 3 blocks of extended data
//------------------------------------------------------------------------------
template <class T> 
HRESULT WriteMsgData( 
    T*          pSrc, 
    DWORD       dwSPI,
    bool        bHttpAuth,
    const BYTE* pExData1, 
    DWORD       dwExData1, 
    const BYTE* pExData2, 
    DWORD       dwExData2, 
    const BYTE* pExData3, 
    DWORD       dwExData3, 
    BYTE*       pDest, 
    DWORD       dwDest, 
    DWORD*      pdwDumped )
{
	HRESULT hr;
	DWORD dwHeader;
	DWORD dwT = sizeof( T );
	DWORD dwALL = dwT + dwExData1 + dwExData2 + dwExData3;

	if( (dwALL > dwDest) || 
        (NULL == pDest) || 
        (NULL == pSrc) || 
        (NULL == pExData1) || 
        (NULL == pExData2) || 
        (NULL == pExData3) )
    {
		hr = E_INVALIDARG;
		goto lbDone;
    }

	if(FAILED(hr = WriteHttpHeader(dwSPI, bHttpAuth, pDest, dwDest, pSrc->dwMsgType, dwALL, &dwHeader)))
	{
		goto lbDone;
	}

	( (BASE_MSG_HEADER*)pSrc )->dwMsgLen = dwALL - sizeof( BASE_MSG_HEADER );
	memcpy( (void*)(pDest + dwHeader), pSrc, dwT );
	memcpy( (void*)(pDest + dwHeader + dwT), pExData1, dwExData1 );
    memcpy( (void*)(pDest + dwHeader + dwT + dwExData1), pExData2, dwExData2 );
    memcpy( (void*)(pDest + dwHeader + dwT + dwExData1 + dwExData2), pExData3, dwExData3 );
	*pdwDumped = dwALL + dwHeader;

lbDone:
	return hr;
}

/////////////////////////////////////////////////
// Dump
//  Base Msg + 4 blocks of extended data
//
template <class T> 
HRESULT WriteMsgData( 
    T*          pSrc, 
    DWORD       dwSPI,
    bool        bHttpAuth,
    const BYTE* pExData1, 
    DWORD       dwExData1, 
    const BYTE* pExData2, 
    DWORD       dwExData2, 
    const BYTE* pExData3, 
    DWORD       dwExData3, 
    const BYTE* pExData4, 
    DWORD       dwExData4, 
    BYTE*       pDest, 
    DWORD       dwDest, 
    DWORD*      pdwDumped )
{
	HRESULT hr;
	DWORD dwHeader;
	DWORD dwT = sizeof( T );
	DWORD dwALL = dwT + dwExData1 + dwExData2 + dwExData3 + dwExData4;

	if( (dwALL > dwDest) || 
        (NULL == pDest) || 
        (NULL == pSrc) || 
        (NULL == pExData1) || 
        (NULL == pExData2) || 
        (NULL == pExData3) || 
        (NULL == pExData4) )
    {
		hr = E_INVALIDARG;
		goto lbDone;
    }

	if(FAILED(hr = WriteHttpHeader(dwSPI, bHttpAuth, pDest, dwDest, pSrc->dwMsgType, dwALL, &dwHeader)))
	{
		goto lbDone;
	}

	( (BASE_MSG_HEADER*)pSrc )->dwMsgLen = dwALL - sizeof( BASE_MSG_HEADER );
	memcpy( (void*)(pDest + dwHeader), pSrc, dwT );
	memcpy( (void*)(pDest + dwHeader + dwT), pExData1, dwExData1 );
    memcpy( (void*)(pDest + dwHeader + dwT + dwExData1), pExData2, dwExData2 );
    memcpy( (void*)(pDest + dwHeader + dwT + dwExData1 + dwExData2), pExData3, dwExData3 );
    memcpy( (void*)(pDest + dwHeader + dwT + dwExData1 + dwExData2 + dwExData3), pExData4, dwExData4 );
	*pdwDumped = dwALL + dwHeader;

lbDone:
	return hr;
}

//------------------------------------------------------------------------------
//  Base Msg + 5 blocks of extended data
//------------------------------------------------------------------------------
template <class T> 
HRESULT WriteMsgData( 
    T*          pSrc, 
    DWORD       dwSPI,
    bool        bHttpAuth,
    const BYTE* pExData1, 
    DWORD       dwExData1, 
    const BYTE* pExData2, 
    DWORD       dwExData2, 
    const BYTE* pExData3, 
    DWORD       dwExData3, 
    const BYTE* pExData4, 
    DWORD       dwExData4, 
    const BYTE* pExData5, 
    DWORD       dwExData5, 
    BYTE*       pDest, 
    DWORD       dwDest, 
    DWORD*      pdwDumped )
{
	HRESULT hr;
	DWORD dwHeader;
	DWORD dwT = sizeof( T );
	DWORD dwALL = dwT + dwExData1 + dwExData2 + dwExData3 + dwExData4 + dwExData5;

	if( (dwALL > dwDest) || 
        (NULL == pDest) || 
        (NULL == pSrc) || 
        (NULL == pExData1) || 
        (NULL == pExData2) || 
        (NULL == pExData3) || 
        (NULL == pExData4) || 
        (NULL == pExData5) )
    {
		hr = E_INVALIDARG;
		goto lbDone;
    }

	if(FAILED(hr = WriteHttpHeader(dwSPI, bHttpAuth, pDest, dwDest, pSrc->dwMsgType, dwALL, &dwHeader)))
	{
		goto lbDone;
	}

	( (BASE_MSG_HEADER*)pSrc )->dwMsgLen = dwALL - sizeof( BASE_MSG_HEADER );
	memcpy( (void*)(pDest + dwHeader), pSrc, dwT );
	memcpy( (void*)(pDest + dwHeader + dwT), pExData1, dwExData1 );
    memcpy( (void*)(pDest + dwHeader + dwT + dwExData1), pExData2, dwExData2 );
    memcpy( (void*)(pDest + dwHeader + dwT + dwExData1 + dwExData2), pExData3, dwExData3 );
    memcpy( (void*)(pDest + dwHeader + dwT + dwExData1 + dwExData2 + dwExData3), pExData4, dwExData4 );
    memcpy( (void*)(pDest + dwHeader + dwT + dwExData1 + dwExData2 + dwExData3 + dwExData4), pExData5, dwExData5 );
	*pdwDumped = dwALL + dwHeader;

lbDone:
	return hr;
}

//------------------------------------------------------------------------------
//  Base Msg + 6 blocks of extended data
//------------------------------------------------------------------------------
template <class T> 
HRESULT WriteMsgData( 
    T*          pSrc, 
    DWORD       dwSPI,
    bool        bHttpAuth,
    const BYTE* pExData1, 
    DWORD       dwExData1, 
    const BYTE* pExData2, 
    DWORD       dwExData2, 
    const BYTE* pExData3, 
    DWORD       dwExData3, 
    const BYTE* pExData4, 
    DWORD       dwExData4, 
    const BYTE* pExData5, 
    DWORD       dwExData5, 
    const BYTE* pExData6, 
    DWORD       dwExData6,
    BYTE*       pDest, 
    DWORD       dwDest, 
    DWORD*      pdwDumped )
{
	HRESULT hr;
	DWORD dwHeader;
	DWORD dwT = sizeof( T );
	DWORD dwALL = dwT + dwExData1 + dwExData2 + dwExData3 + dwExData4 + dwExData5 + dwExData6;

	if( (dwALL > dwDest) || 
        (NULL == pDest) || 
        (NULL == pSrc) || 
        (NULL == pExData1) || 
        (NULL == pExData2) || 
        (NULL == pExData3) || 
        (NULL == pExData4) || 
        (NULL == pExData5) ||
        (NULL == pExData6) )
    {
		hr = E_INVALIDARG;
		goto lbDone;
    }

	if(FAILED(hr = WriteHttpHeader(dwSPI, bHttpAuth, pDest, dwDest, pSrc->dwMsgType, dwALL, &dwHeader)))
	{
		goto lbDone;
	}

	( (BASE_MSG_HEADER*)pSrc )->dwMsgLen = dwALL - sizeof( BASE_MSG_HEADER );
	memcpy( (void*)(pDest + dwHeader), pSrc, dwT );
	memcpy( (void*)(pDest + dwHeader + dwT), pExData1, dwExData1 );
    memcpy( (void*)(pDest + dwHeader + dwT + dwExData1), pExData2, dwExData2 );
    memcpy( (void*)(pDest + dwHeader + dwT + dwExData1 + dwExData2), pExData3, dwExData3 );
    memcpy( (void*)(pDest + dwHeader + dwT + dwExData1 + dwExData2 + dwExData3), pExData4, dwExData4 );
    memcpy( (void*)(pDest + dwHeader + dwT + dwExData1 + dwExData2 + dwExData3 + dwExData4), pExData5, dwExData5 );
    memcpy( (void*)(pDest + dwHeader + dwT + dwExData1 + dwExData2 + dwExData3 + dwExData4 + dwExData5), pExData6, dwExData6 );
	*pdwDumped = dwALL + dwHeader;

lbDone:
	return hr;
}


#endif // _XPENGINE_DUMP_HELPERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\FdConn.h ===
#pragma once


#define FDCONN_STATE_DISCONNECTED    0
#define FDCONN_STATE_DISCONNECTING   1
#define FDCONN_STATE_CONNECTED       2
#define FDCONN_STATE_CONNECTING      3
#define FDCONN_STATE_SENDINPROGRESS  4
#define FDCONN_STATE_RECVINPROGRESS  5

#define FDCONN_BUFFER_SZ             0x8000

class AsyncSocket;
class CompletionPort;
class XPQTask;
class XPQUser;

class FdConnection : public BasePresenceConnection
{
protected:
    typedef HRESULT (FdConnection::*PfnCompletionRoutine)();

    static DWORD         ms_dwReceiveTimeout;
    static DWORD         ms_dwSendTimeout;
    static WORD          ms_wPPORT; 
    static WORD          ms_wMPORT; 
    static WORD          ms_wTPORT; 
    static WORD          ms_wDPORT; 
    static bool          ms_bStaticInitialized;

    AsyncSocket*         m_pConn;
    CompletionPort*      m_pCP;
    DWORD                m_dwState;

    BYTE*                m_pbBuffer;
    DWORD                m_cbBuffer;
    DWORD                m_cbBufferPending;
    
    XPQTask*             m_pTask;
    XPQUser*             m_pUser;
    const XPQUser*       m_pTargetUser;
    ULONGLONG            m_qwTargetContext;

    DWORD                m_dwFdAddr;
    WORD                 m_wPort;
    WORD                 m_wSrcPort;
    DWORD                m_dwSPI;
    DWORD                m_dwMsgType;

    DWORD                m_dwStartTicks;
    DWORD                m_dwEndTicks;

    DWORD                m_dwHeaderLength;
    DWORD                m_dwContentLength;

    HRESULT              m_hrServer;
    DWORD                m_dwHttpStatus;

    PfnCompletionRoutine m_pfnCompletion;

    // Called as part of the receive loop 
    HRESULT ParseHeaders();

    // Set the context members that will be used in completion
    // handling
    HRESULT SetContext(
            XPQTask*             pTask,
            XPQUser*             pUser,
            PfnCompletionRoutine pfnCompletion);

    // Targeted context for a specific user
    HRESULT SetContext(
            XPQTask*             pTask,
            XPQUser*             pUser,
            const XPQUser*       pTargetUser,
            PfnCompletionRoutine pfnCompletion);

public:

    //------------------------------------------------------------------------------
    // Lifetime management
    //------------------------------------------------------------------------------

    FdConnection();
    ~FdConnection();

    static void SetReceiveTimeout(DWORD dwMillis);
    static void SetSendTimeout(DWORD dwMillis);

    HRESULT Create(
            CompletionPort* pCP, 
            DWORD           dwFdAddr);
    void Destroy();
    void CleanReset();

    HRESULT CheckConnected() { return m_pConn->CheckConnected(); }

    //------------------------------------------------------------------------------
    // Property accessors
    //------------------------------------------------------------------------------
    HANDLE  ConnectionHandle()   const { return (HANDLE)m_pConn->Handle(); }
    bool    IsConnected()        const { return FDCONN_STATE_DISCONNECTED != m_dwState; }
    HRESULT ServerHR()           const { return m_hrServer; }
    DWORD   HttpStatus()         const { return m_dwHttpStatus; }
    DWORD   State()              const { return m_dwState; }
    DWORD   LastOpStartTicks()   const { return m_dwStartTicks; }

    //------------------------------------------------------------------------------
    // Common connection handlers
    //
    // StartConnect, StartSend, StartReceive can be called multiple times 
    // to pump the respective IO operation. StartConnect and StartSend
    // should only be called once with parameter provided.
    //------------------------------------------------------------------------------
    HRESULT StartConnect(DWORD dwAddr = 0, WORD  wPort = 0);
    HRESULT CompleteConnect();
    HRESULT Disconnect();

    HRESULT StartSend(XPQMsg *pMsg = 0, WORD wPort = 0);
    HRESULT CompleteSend(DWORD dwTransferred);

    HRESULT StartReceive();
    HRESULT CompleteReceive(DWORD dwTransferred, bool *pbCompletionDelivered);

    //------------------------------------------------------------------------------
    // Message transport
    //------------------------------------------------------------------------------
    
    HRESULT SendAlive(
        XPQTask*      pTask, 
        XPQUser*      pUser);
    HRESULT CompleteAlive();

    HRESULT SendLogoff(
        XPQTask*      pTask,
        XPQUser*      pUser);
    HRESULT CompleteLogoff();

    HRESULT SendDeadXbox(
        XPQTask*      pTask, 
        XPQUser*      pUser);
    HRESULT CompleteDeadXbox();

    HRESULT SendDeadUser(
        XPQTask*      pTask, 
        XPQUser*      pUser);
    HRESULT CompleteDeadUser();

    HRESULT SendCheckTitleMessages(
        XPQTask*      pTask,
        XPQUser*      pUser,
        DWORD         dwTitleId);
    HRESULT CompleteCheckTitleMessages();

    HRESULT SendUpdateState( 
        XPQTask*      pTask,
        XPQUser*      pUser);
    HRESULT CompleteUpdateState();

    virtual HRESULT SendUpdateStateBatch(
        XPQTask*      pTask,
        XPQUser*      pUser,
        CSgMsgNotifyCliUpdate *prgUdpates,
        DWORD         cUpdates);
    HRESULT CompleteUpdateStateBatch();

    HRESULT SendUpdateState2( 
        XPQTask*      pTask,
        XPQUser*      pUser);
    HRESULT CompleteUpdateState2();

    HRESULT SendDequeue(
        XPQTask*      pTask,
        XPQUser*      pUser,
        P_QUEUE_TYPES eQType);
    HRESULT CompleteDequeue();

    HRESULT SendPeerSubscribe( 
        XPQTask*        pTask,
        XPQUser*        pUser,
        const XPQUser** rgpPeers,
        WORD            wPeers);
    HRESULT CompletePeerSubscribe();
	HRESULT CompletePeerSubscribeEx();

    HRESULT SendPeerUnsubscribe(
        XPQTask*       pTask,
        XPQUser*       pUser);
    HRESULT CompletePeerUnsubscribe();

    HRESULT SendAddBuddy(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pBuddy, 
        bool           bByName = false );
    HRESULT CompleteAddBuddy();

    HRESULT SendAcceptBuddy( 
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pBuddy );
    HRESULT CompleteAcceptBuddy();

    HRESULT SendRejectBuddy( 
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pBuddy, 
        bool           bNever = false );
    HRESULT CompleteRejectBuddy();
    
    HRESULT SendDeleteBuddy( 
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pBuddy );
    HRESULT CompleteDeleteBuddy();
   
    HRESULT SendBlock(   
        XPQTask*        pTask,
        XPQUser*        pUser,
        const XPQUser*  pBlock);
    HRESULT CompleteBlock();
    
    HRESULT SendUnblock( 
        XPQTask*        pTask,
        XPQUser*        pUser,
        const XPQUser*  pUnblock,
        bool            bAll = false );
    HRESULT CompleteUnblock();

    HRESULT SendAddAffiliates(
        XPQTask*        pTask,
        XPQUser*        pUser,
        DWORD           dwListFlag,
        DWORD           dwTitleId,
        const XPQUser** rgpAffiliates,
        WORD            cwAffiliates);
    HRESULT CompleteAddAffiliates();

    HRESULT SendIsAffiliate(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pAffiliate);
    HRESULT CompleteIsAffiliate();

    HRESULT SendQueryAffiliates(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwListFlags,
        DWORD          cdwLimit,
        DWORD          dwOnlineTitleId,
        BOOL           fUseDatacenter);
    HRESULT CompleteQueryAffiliates();

    HRESULT SendInvite( 
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser** apBuddy, 
        WORD           wCount );
    HRESULT CompleteInvite();
    
    HRESULT SendCancelInvite( 
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser** apBuddy, 
        WORD           wCount );
    HRESULT CompleteCancelInvite();
    
    HRESULT SendAnswerInvite( 
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pHost, 
        ULONGLONG      qwMatchSessionId,
        bool           bYes );
    HRESULT CompleteAnswerInvite(); 

    HRESULT SendSendMessage(
        XPQTask*       pTask,
        XPQUser*       pUser,
		BYTE		   bMsgType,
        ULONGLONG      qwContext,
        DWORD          dwFlags,
        ULONGLONG*     pqwRecipients,
        WORD           wRecipients,
        BYTE*          pbDetails,
        WORD           wDetails,
		WORD		   wExpire);
    HRESULT CompleteSendMessage();

    HRESULT SendEnumMessages(
        XPQTask*       pTask,
        XPQUser*       pUser);
    HRESULT CompleteEnumMessages();

    HRESULT SendEnumMessages2(
        XPQTask*       pTask,
        XPQUser*       pUser);
    HRESULT CompleteEnumMessages2();

    HRESULT SendMessageSummary(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwMsgId);
    HRESULT CompleteMessageSummary();

    HRESULT SendMessageSummary2(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwMsgId);
    HRESULT CompleteMessageSummary2();

    HRESULT SendMessageDetails(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwMsgId,
        DWORD          dwMsgSetFlags,
        DWORD          dwMsgUnsetFlags);
    HRESULT CompleteMessageDetails();

    HRESULT SendMessageFlags(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwMsgId,
        DWORD          dwSetFlags,
        DWORD          dwClearFlags );
    HRESULT CompleteMessageFlags();

    HRESULT SendMessageDelete(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwMsgId,
        bool           bBlock );
    HRESULT CompleteMessageDelete();

    HRESULT SendMessageRevoke(
        XPQTask*                  pTask,
        XPQUser*                  pUser,
        const Q_RECIPIENT_RESULT *prgRecipientResults,
        WORD                      wcRecipients);
    HRESULT CompleteMessageRevoke();

    HRESULT SendMessageRevokeEx(
        XPQTask*                  pTask,
        XPQUser*                  pUser,
        ULONGLONG                 qwSenderId,
        ULONGLONG                 qwSenderContext,
        DWORD                     dwFlags,
        WORD                      wPropTag,
        BYTE                      bMessageType,
        const Q_RECIPIENT_RESULT* prgRecipients,  
        WORD                      cRecipients,
        const BYTE*               prbProp,
        WORD                      cbProp);
    HRESULT CompleteMessageRevokeEx();
    
    HRESULT SendUpdateNickname(
        XPQTask*       pTask,
        XPQUser*       pUser,
        BYTE*          pbNickname, 
        WORD           wNicknameLen );
    HRESULT CompleteUpdateNickname();

    HRESULT SendDeleteTitle(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwTitleId);
    HRESULT CompleteDeleteTitle();

    HRESULT SendEnumTitles(
        XPQTask*       pTask,
        XPQUser*       pUser);
    HRESULT CompleteEnumTitles();
   
    HRESULT SendCreateTeam(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const WCHAR*   wszTeamName,
        const WCHAR*   wszTeamDescription,
        const WCHAR*   wszTeamMotto,
        const WCHAR*   wszTeamURL,
        BYTE*          pbTeamData, 
        WORD           wTeamDataLen,
        BYTE*          pbCreatorData, 
        WORD           wCreatorDataLen);
    HRESULT CompleteCreateTeam();
        
    HRESULT SendManageTeam(
        XPQTask*       pTask,
        XPQUser*       pUser,
        ULONGLONG      qwTeamId,
        const WCHAR*   wszTeamName,
        const WCHAR*   wszTeamDescription,
        const WCHAR*   wszTeamMotto,
        const WCHAR*   wszTeamURL,
        BYTE*          pbTeamData, 
        WORD           wTeamDataLen );
    HRESULT CompleteManageTeam();

    HRESULT SendDeleteTeam(
        XPQTask*       pTask,
        XPQUser*       pUser,
        ULONGLONG      qwTeamId );
    HRESULT CompleteDeleteTeam();

    HRESULT SendListTeams(
        XPQTask*       pTask,
        XPQUser*       pUser,
        ULONGLONG*     aqwTeamIds, 
        WORD           wNumIds );
    HRESULT CompleteListTeams();

    HRESULT SendListUserTeams(
        XPQTask*       pTask,
        XPQUser*       pUser);
    HRESULT CompleteListUserTeams();

    HRESULT SendRecruitTeamMember(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pRecruit,
        ULONGLONG      qwTeamId,
        DWORD          dwMemberPriv,
        BYTE*          pbData, 
        WORD           wDataLen);
    HRESULT CompleteRecruitTeamMember();

    HRESULT SendJoinTeam(
        XPQTask*         pTask,
        XPQUser*         pUser,
        ULONGLONG        qwTeamId,
        DWORD            dwRecruitMsgId,
        P_INVITE_REPLIES eReply );
    HRESULT CompleteJoinTeam();

    HRESULT SendManageTeamMember(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pMember,
        ULONGLONG      qwTeamId,
        DWORD          dwMemberPriv,
        BYTE*          pbData, 
        WORD           wDataLen );
    HRESULT CompleteManageTeamMember();
            
    HRESULT SendRemoveTeamMember(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pMember,
        ULONGLONG      qwTeamId);
    HRESULT CompleteRemoveTeamMember();

    HRESULT SendListTeamMembers(
        XPQTask*       pTask,   
        XPQUser*       pUser,   
        ULONGLONG      qwTeamId,
        bool           bShowRecruits );
    HRESULT CompleteListTeamMembers();

    HRESULT SendGetTeamTicket(
        XPQTask*       pTask,
        XPQUser*       pUser);
    HRESULT CompleteGetTeamTicket();

    HRESULT SendWebFriends(
        XPQTask*       pTask, 
        XPQUser*       pUser);
    HRESULT CompleteWebFriends();

    HRESULT SendGetFriendsList(
        XPQTask*       pTask, 
        XPQUser*       pUser,
        const XPQUser* pTargetUser);
    HRESULT CompleteGetFriendsList();

    HRESULT SendGetPresenceInfo(
        XPQTask*       pTask, 
        XPQUser*       pUser,
        const XPQUser* pTargetUser);
    HRESULT CompleteGetPresenceInfo();

    HRESULT SendFindUser(
        XPQTask*       pTask, 
        XPQUser*       pUser,
        ULONGLONG      qwFindId,
        const char*    pszGamerTag);
    HRESULT CompleteFindUser();

    HRESULT SendFindUsers(
        XPQTask*       pTask, 
        XPQUser*       pUser,
        const XPQUser** apFinds, 
		WORD  wCount);
    HRESULT CompleteFindUsers();

    HRESULT SendInvalidateUser(
        XPQTask*       pTask,
        XPQUser*       pUser);
    HRESULT CompleteInvalidateUser();

    HRESULT SendEcho(
        XPQTask*       pTask,
        XPQUser*       pUser);
    HRESULT CompleteEcho();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\FdConn.cpp ===
#include "StdAfx.h"
#include "FdConn.h"

extern HRESULT AppendNotifyCliUpdate(XPQTask *pTask, BasePresenceConnection *pConn, XPQUser *pUser, BOOL fFromAlive);

MGMT_DefineLoggingCategory( FdConn );

MGMT_ImportConfigSetting( ConnectionMgr, FDPortForPresNoti );
MGMT_ImportConfigSetting( ConnectionMgr, FDPortForMessaging );
MGMT_ImportConfigSetting( ConnectionMgr, FDPortForTeams );
MGMT_ImportConfigSetting( ConnectionMgr, FDPortForPresNoti );
MGMT_ImportConfigSetting( ConnectionMgr, FDPortForMessaging );
MGMT_ImportConfigSetting( ConnectionMgr, FDPortForTeams );
MGMT_ImportConfigSetting( ConnectionMgr, FDPortForDataCenter );


#define FAIL_GOTO_DONE(op, expr) if(FAILED((expr))) { ERR1(FdConn, #op " failed " #expr ", HR: 0x%08x", hr); goto lbDone; }
#define VALIDATE_GOTO_DONE(op, expr) if(!((expr))) { ERR0(FdConn, #op " failed " #expr ); goto lbDone; }
#define VALIDATE(op, expr) if(!((expr))) { ERR0(FdConn, #op " validation failed for: " #expr ); }

HRESULT DeserializeReplyTeams(XPQUser *pUser, P_REPLY_TEAM *pTeam, DWORD cTeams, DWORD dwPayloadSize)
{
    HRESULT hr;
    XPQTeamMemberData *pMemberData;
    BYTE *pbExtra, *pbEnd;

    pbEnd = (BYTE*)pTeam + dwPayloadSize;
    
    for(DWORD i = 0; i < cTeams; ++i)
    {
        VALIDATE_GOTO_DONE(DESERIALIZE_TEAMS, pTeam->cbTeamName <= XONLINE_MAX_TEAM_NAME_SIZE);
        VALIDATE_GOTO_DONE(DESERIALIZE_TEAMS, pTeam->cbTeamDescription <= XONLINE_MAX_TEAM_DESCRIPTION_SIZE);
        VALIDATE_GOTO_DONE(DESERIALIZE_TEAMS, pTeam->cbTeamMotto <= XONLINE_MAX_TEAM_MOTTO_SIZE);
        VALIDATE_GOTO_DONE(DESERIALIZE_TEAMS, pTeam->cbTeamURL <= XONLINE_MAX_TEAM_URL_SIZE);
        VALIDATE_GOTO_DONE(DESERIALIZE_TEAMS, pTeam->cbTeamData <= XONLINE_MAX_TEAM_DATA_SIZE);
    
        if(FAILED(hr = pUser->GetOrCreateTeamMemberData(
                        pTeam->qwTeamID, 
                        pUser->TitleId(), 
                        XPQ_TEAM_MEMBER_STATE_MEMBER, 
                        &pMemberData)))
        {
            ERR2(FdConn, "[DeserializeReplyTeams]: GetOrCreateTeamMemberData() failed for user: %I64x, hr: 0x%08x",
                    pUser->UserId(),
                    hr);
            goto lbDone;
        }

        // Go to next team
        pbExtra = (BYTE*)(pTeam + 1);
        pbExtra += pTeam->cbTeamName;
        pbExtra += pTeam->cbTeamDescription;
        pbExtra += pTeam->cbTeamMotto;
        pbExtra += pTeam->cbTeamURL;
        pbExtra += pTeam->cbTeamData;

        VALIDATE_GOTO_DONE(DESERIALIZE_TEAMS, pbExtra <= pbEnd);

        pTeam = (P_REPLY_TEAM*)pbExtra;
    }

    hr = S_OK;

lbDone:
    return hr;
}

HRESULT DeserializeReplyUserTeams(XPQUser *pUser, P_REPLY_USER_TEAM *pTeam, DWORD cTeams, DWORD dwPayloadSize)
{
    HRESULT hr;
    XPQTeamMemberData *pMemberData;
    BYTE *pbEnd;

    pbEnd = (BYTE*)pTeam + dwPayloadSize;
    
    for(DWORD i = 0; i < cTeams; ++i)
    {
        if(FAILED(hr = pUser->GetOrCreateTeamMemberData(
                           pTeam->qwTeamID, 
                           pUser->TitleId(), 
                           pTeam->fMember ? XPQ_TEAM_MEMBER_STATE_MEMBER : XPQ_TEAM_MEMBER_STATE_RECRUIT,
                           &pMemberData)))
        {
            ERR2(FdConn, "[DeserializeReplyUserTeams]: GetOrCreateTeamMemberData() failed for team: %I64x, user: %I64x, hr: 0x%08x",
                    pUser->UserId(),
                    hr);
            goto lbDone;
        }

        VALIDATE_GOTO_DONE(DESERIALIZE_USER_TEAMS, (BYTE*)pTeam < pbEnd);

        // Go to next team
        ++pTeam;
    }

    hr = S_OK;

lbDone:
    return hr;
}

HRESULT DeserializeReplyTeamMembers(XPQUser *pUser, ULONGLONG qwTeamId, P_REPLY_TEAM_MEMBER *pMember, DWORD cMembers, DWORD dwPayloadSize)
{
    HRESULT hr;
    BYTE bMemberState;
    XPQTeamData *pTeamData;
    XPQTeamMemberData *pMemberData;
    DWORD dwUserIndex;
    BYTE *pbExtra, *pbEnd;
    bool bKeepTeamData = false;

    //
    // This record is only added temporarily so that we avoid scanning the reply 
    // twice
    //
    if(FAILED(hr = pUser->GetOrCreateTeamData(
                    qwTeamId, 
                    pUser->TitleId(), 
                    &pTeamData)))
    {
        ERR2(FdConn, "[DeserializeReplyTeamMembers]: GetOrCreateTeamData() failed for team: %I64x, user: %I64x, hr: 0x%08x",
                pUser->UserId(),
                hr);
        goto lbDone;
    }

    pbEnd = (BYTE*)pMember + dwPayloadSize;

    for(DWORD i = 0; i < cMembers; ++i)
    {
        VALIDATE_GOTO_DONE(DESERIALIZE_TEAM_MEMBERS, pMember->cbMemberName <= XONLINE_GAMERTAG_SIZE);
        VALIDATE_GOTO_DONE(DESERIALIZE_TEAM_MEMBERS, pMember->cbMemberData <= XONLINE_MAX_TEAM_MEMBER_DATA_SIZE);

        switch(pMember->dwMemberPriv)
        {
            case XPQ_TEAM_MEMBER_PRIV_OWNER:
                bMemberState = XPQ_TEAM_MEMBER_STATE_OWNER;
                break;
            case XPQ_TEAM_MEMBER_PRIV_OFFICER:
                bMemberState = XPQ_TEAM_MEMBER_STATE_OFFICER;
                break;
            case XPQ_TEAM_MEMBER_PRIV_NORMAL:
                bMemberState = XPQ_TEAM_MEMBER_STATE_MEMBER;
                break;
            case XPQ_TEAM_MEMBER_PRIV_NONE:
                bMemberState = XPQ_TEAM_MEMBER_STATE_RECRUIT;
                break;
        }

        // Validate that we got the data right
        _ASSERTE((TRUE == pMember->fMember) == (bMemberState != XPQ_TEAM_MEMBER_STATE_RECRUIT));

        // If the user is in the list (they should have one entry) make sure they have a member
        if(pUser->UserId() == pMember->qwMemberID)
        {
            if(FAILED(hr = pUser->GetOrCreateTeamMemberData(
                            qwTeamId,
                            pUser->TitleId(),
                            bMemberState,
                            &pMemberData)))
            {
                ERR3(FdConn, "[DeserializeReplyTeamMembers]: GetOrCreateTeamMemberData() failed for team: %I64x, user: %I64x, hr: 0x%08x",
                        pTeamData->qwTeamId,
                        pUser->UserId(),
                        hr);
                goto lbDone;
            }

            // Limit the population of team records from this Deserializer to owners. This simplifies the
            // task selection for promotion, demotion, team management and deletion. This also ensures
            // that we only have at most one team data record in memory for each team.
            if(XPQ_TEAM_MEMBER_STATE_OWNER == bMemberState)
            {
                bKeepTeamData = true;
            }
        }
        
        dwUserIndex = gpUserMgr->UserIndexFromId(pMember->qwMemberID);
        if(dwUserIndex > gpUserMgr->TotalUserCount())
        {
            ERR3(FdConn, "[DeserializeReplyTeamMembers]: invalid user id (out-of-range) in team list for team: %I64x, user: %I64x, member: %I64x",
                    qwTeamId,
                    pUser->UserId(),
                    pMember->qwMemberID);
            continue;
        }

        if(S_FALSE == pTeamData->UpdateMember(dwUserIndex, bMemberState))
        {
            if(S_OK != pTeamData->AddMember(dwUserIndex, bMemberState))
            {
                ERR3(FdConn, "[DeserializeReplyTeamMembers]: XPQTeamData::AddMember() failed for team: %I64x, user: %I64x, member: %I64x",
                        qwTeamId,
                        pUser->UserId(),
                        pMember->qwMemberID);
            }
        }


        // Copy extra varlength data
        pbExtra = (BYTE*)(pMember + 1);
        pbExtra += pMember->cbMemberName; // skip name
        pbExtra += pMember->cbMemberData;

        VALIDATE_GOTO_DONE(DESERIALIZE_USER_TEAMS, pbExtra <= pbEnd);

        // Go to next team
        pMember = (P_REPLY_TEAM_MEMBER*)pbExtra;
    }

    hr = S_OK;

lbDone:

    if(FAILED(hr) || !bKeepTeamData)
    {
        if(FAILED(hr = pUser->RemoveTeamData(pTeamData->qwTeamId, 0)))
        {
            ERR3(FdConn, "[DeserializeReplyTeamMembers]: XPQUser::RemoveTeamData() failed for temporary team data, user: %I64x, team: %I64x, HR: 0x%08x",
                    pUser->UserId(),
                    pTeamData->qwTeamId,
                    hr);
        }
    }

    return hr;
}

//------------------------------------------------------------------------------
// FdConn static member data
//------------------------------------------------------------------------------
DWORD FdConnection::ms_dwReceiveTimeout     = 30000;
DWORD FdConnection::ms_dwSendTimeout        = 30000;
WORD FdConnection::ms_wPPORT                = 0;
WORD FdConnection::ms_wMPORT                = 0;
WORD FdConnection::ms_wTPORT                = 0;
WORD FdConnection::ms_wDPORT                = 0;
bool FdConnection::ms_bStaticInitialized    = false;

//------------------------------------------------------------------------------
// FdConn static methods
void FdConnection::SetReceiveTimeout(DWORD dwMillis)
{
    ms_dwReceiveTimeout = dwMillis;
}

void FdConnection::SetSendTimeout(DWORD dwMillis)
{
    ms_dwSendTimeout  = dwMillis;
}

//------------------------------------------------------------------------------
// FdConn instance methods
//------------------------------------------------------------------------------

FdConnection::FdConnection() : BasePresenceConnection(FDCONNECTION),
    m_pConn(0),
    m_pCP(0),
    m_dwState(FDCONN_STATE_DISCONNECTED),
    m_pbBuffer(0),
    m_cbBuffer(0),
    m_cbBufferPending(0),
    m_pTask(0),
    m_pUser(0),
    m_pTargetUser(0),
    m_qwTargetContext(0),
    m_dwFdAddr(0),
    m_wPort(0),
    m_wSrcPort(0),
    m_dwSPI(INVALID_SPI),
    m_dwMsgType(0),
    m_dwStartTicks(0),
    m_dwEndTicks(0),
    m_dwHeaderLength(0),
    m_dwContentLength(0),
    m_hrServer(0),
    m_dwHttpStatus(0),
    m_pfnCompletion(0)
{
}

FdConnection::~FdConnection()
{
    Destroy();
}

HRESULT FdConnection::Create(CompletionPort *pPort, DWORD dwFdAddr)
{
    HRESULT hr = E_FAIL;

    if(0 == pPort || 0 == dwFdAddr)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    m_pCP      = pPort;
    m_dwFdAddr = dwFdAddr;


    m_pConn = new AsyncSocket();
    if (m_pConn == NULL)
    {
        ERR0( FdConn, "[FdConnection::Create] - create async. socket failed");
        hr = E_OUTOFMEMORY;
        goto lbDone;
    }

    m_pbBuffer   = new BYTE[FDCONN_BUFFER_SZ];
    if(0 == m_pbBuffer)
    {
        ERR0( FdConn, "[FdConnection::Create] - create input buffer failed");
        hr = E_OUTOFMEMORY;
        goto lbDone;
    }

    m_pbBuffer  = new BYTE[FDCONN_BUFFER_SZ];
    if(0 == m_pbBuffer)
    {
        ERR0( FdConn, "[FdConnection::Create] - create output buffer failed");
        hr = E_OUTOFMEMORY;
        goto lbDone;
    }

    m_cbBuffer         = 0;
    m_cbBuffer        = 0;
    m_cbBufferPending = 0;

    hr = S_OK;

    // Do one time static initialization
    if(!ms_bStaticInitialized)
    {
        ms_wPPORT = MGMT_GetConfigSetting(ConnectionMgr, FDPortForPresNoti).GetWORD();
        ms_wMPORT = MGMT_GetConfigSetting(ConnectionMgr, FDPortForMessaging).GetWORD();
        ms_wTPORT = MGMT_GetConfigSetting(ConnectionMgr, FDPortForTeams).GetWORD();
        ms_wDPORT = MGMT_GetConfigSetting(ConnectionMgr, FDPortForDataCenter).GetWORD();
        ms_bStaticInitialized = true;
    }

lbDone:

    return hr;
}

void FdConnection::Destroy()
{
    HRESULT hr;

    if(FAILED(hr = m_pConn->Shutdown(SD_BOTH)))
    {
        ERR1(FdConn, "[FdConnection::Destroy]: AsyncSocket::Shutdown() failed, HR: 0x%08x", hr);
    }

    if(FAILED(hr = m_pConn->Close()))
    {
        ERR1(FdConn, "[FdConnection::Destroy]: AsyncSocket::Close() failed, HR: 0x%08x", hr);
    }

    if(0 != m_pConn)
    {
        delete m_pConn;
		m_pConn = NULL;
    }

    if(0 != m_pbBuffer)
    {
        delete[] m_pbBuffer;
		m_pbBuffer = NULL;
    }

    m_cbBuffer = 0;
    m_cbBufferPending = 0;
    m_dwState = FDCONN_STATE_DISCONNECTED;
}

// Try to make the connection clean for another user
// HTTP Keep Alive: Don't close the socket and don't set the connection state to disconnected
void FdConnection::CleanReset()
{
    HRESULT hr;

    // Close out the connection object
    if(0 != m_pConn)
    {
        // Ensure our side of the connection is closed
        m_pConn->Close();
    }

    if(0 != m_wSrcPort)
    {
        // Notify the connection manager that the port mapped slot is no longer in use
        sockaddr_in laddr;
        if(FAILED(hr = gpConnMgr->DisableAndUnmapSlot(m_wSrcPort)))
        {
            ERR1(FdConn, "[FdConnection::CleanReset]: XPQConnectionMgr::DisableAndUnmapSlot() failed, HR: 0x%08x", hr);
        }
    }

    m_cbBuffer        = 0;
    m_cbBuffer        = 0;
    m_cbBufferPending = 0;
    m_dwState         = FDCONN_STATE_DISCONNECTED;
    m_wPort           = 0;
    m_wSrcPort        = 0;
    m_dwSPI           = INVALID_SPI;
    m_dwMsgType       = 0;
    m_hrServer        = 0;
    m_dwHttpStatus    = 0;
}

HRESULT FdConnection::SetContext(XPQTask *pTask, XPQUser *pUser, PfnCompletionRoutine pfnCompletion)
{
    if(0 == pTask || 0 == pUser || 0 == pfnCompletion)
    {
        return E_INVALIDARG;
    }

    m_pTask           = pTask;
    m_pUser           = pUser;
    m_pfnCompletion   = pfnCompletion;
    m_pTargetUser     = 0;
    m_qwTargetContext = 0;
    
    return S_OK;
}

HRESULT FdConnection::SetContext(XPQTask *pTask, XPQUser *pUser, const XPQUser *pTargetUser, PfnCompletionRoutine pfnCompletion)
{
    if(0 == pTask || 0 == pUser || 0 == pTargetUser || 0 == pfnCompletion)
    {
        return E_INVALIDARG;
    }

    m_pTask           = pTask;
    m_pUser           = pUser;
    m_pTargetUser     = pTargetUser;
    m_pfnCompletion   = pfnCompletion;
    m_qwTargetContext = 0;
    
    return S_OK;
}

HRESULT FdConnection::StartConnect(DWORD dwAddr, WORD wPort)
{
    HRESULT hr;
    struct sockaddr_in addr = {0,};

    _ASSERTE(0 != m_pConn);
    _ASSERTE(0 != m_pCP);
    
    if(0 != wPort)
    {
        m_dwFdAddr = dwAddr;
        m_wPort    = wPort;
    }

    m_dwState = FDCONN_STATE_CONNECTING;
    m_dwStartTicks = GetTickCount();

    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = dwAddr;
    addr.sin_port = htons(wPort);
    
    hr = m_pConn->Connect(&addr, m_pTask); 
    if(FAILED(hr))
    {
        DWORD dwHADDR = htonl(dwAddr);
        ERR3(FdConn, "[FdConnection::StartConnect]: Failed for address: %s:%u, HR: 0x%08x",
                inet_ntoa(addr.sin_addr), 
                wPort, 
                hr);
        goto lbDone;
    }

lbDone:

    return hr;
}

HRESULT FdConnection::CompleteConnect()
{
    struct sockaddr_in addr = {0,};
    HRESULT hr = S_OK;

    _ASSERTE(FDCONN_STATE_CONNECTING == m_dwState);

    if(FAILED(hr = m_pConn->GetOverlappedResult(m_pTask)))
    {
        goto lbDone;
    }

    m_dwState = FDCONN_STATE_CONNECTED;

    if(FAILED(hr = m_pConn->SetSendTimeout(max(ms_dwSendTimeout, m_pTask->Timeout()))))
    {
        goto lbDone;
    }


    if(FAILED(hr = m_pConn->SetReceiveTimeout(max(ms_dwReceiveTimeout, m_pTask->Timeout()))))
    {
        goto lbDone;
    }
    
    // If we have a queued send
    if(m_cbBuffer > 0)
    {
        TRACE1(FdConn, L_DEBUG, "[FdConnection::CompleteConnect]: send pending out buffer bytes: %u", m_cbBuffer);
        hr = StartSend();
        goto lbDone;        
    }
    else
    {
        hr = E_UNEXPECTED;
        goto lbDone;
    }

lbDone:

    if(FAILED(hr))
    {
        ERR1(FdConn, "[FdConnection::CompleteConnect]: failed, HR: 0x%08x", hr);
    }

    return hr;
}

HRESULT FdConnection::Disconnect()
{
    HRESULT hr;

    TRACE0(FdConn, L_DEBUG, "[FdConnection::Disconnect]: disconnect called");

    m_dwState = FDCONN_STATE_DISCONNECTING;

    // If the shutdown failed with an error that didn't indicate 
    // that the socket was already closed then skip the clean disconnect
    hr = m_pConn->Shutdown(SD_SEND);
    if(FAILED(hr) && WSAENOTCONN != HRESULT_CODE(hr))
    {
        ERR1(FdConn, "[FdConnection::Disconnect]: AsyncSocket::Shutdown() failed returned HR: 0x%08x", hr);
        m_dwState = FDCONN_STATE_DISCONNECTED;
        goto lbDone;
    }

    // Clear the socket receive buffer
    hr = m_pConn->Receive(m_pbBuffer + m_cbBuffer, FDCONN_BUFFER_SZ - m_cbBuffer, m_pTask);
    if(FAILED(hr))
    {
        ERR1(FdConn, "[FdConnection::Disconnect]: AsyncSocket::Receive() failed, HR: 0x%08x", hr);
        m_dwState = FDCONN_STATE_DISCONNECTED;
        goto lbDone;
    }

lbDone: 

    return hr;
}

//------------------------------------------------------------------------------
// Send the message payload 
//------------------------------------------------------------------------------
HRESULT FdConnection::StartSend(XPQMsg *pMsg, WORD wPort)
{
    HRESULT hr = E_FAIL;

    _ASSERTE(FDCONN_STATE_DISCONNECTING != m_dwState);

    if(0 != wPort)
    {
	    m_wPort = wPort;
	}

    // Pack the message into the output buffer when supplied (on the first send)
    if(0 != pMsg)
    {
        m_dwMsgType = pMsg->Type();
        m_cbBuffer = pMsg->DumpMsg(m_pbBuffer, FDCONN_BUFFER_SZ);
        if(0 == m_cbBuffer)
        {
            hr = E_FAIL;
            ERR0(FdConn, "[FdConnection::StartSend]: DumpFdMsg() only reported packing 0 bytes");
            goto lbDone;
        }


        TRACE5( FdConn, L_DEBUG, "[FdConnection::StartSend]: thread[%d] sending XPQMsg Type: %d, Bytes: %d, UserId: %I64x, Port: %d", 
            GetCurrentThreadId(), 
            m_dwMsgType, 
            m_cbBuffer, 
            m_pUser->UserId(), 
            m_wPort );
    }

    
    // Start the connection if we're not in a connected state
    if(!IsConnected())
    {

        // Create the socket handle and attach it to the io completion port
        hr = m_pConn->CreateTcp();
        if(FAILED(hr))
        {
            ERR1(FdConn, "[FdConnection::StartSend]: CreateTcp() failed: HR: 0x%08x", hr);
            goto lbDone;
        }

        //hr = m_pConn->SetReuseAddr(TRUE);
        //if(FAILED(hr))
        //{
        //    ERR1(FdConn, "[FdConnection::StartSend]: SetReuseAddr() failed: HR: 0x%08x", hr);
        //    goto lbDone;
        //}

        hr = m_pCP->Attach((HANDLE)m_pConn->Handle(), (ULONG_PTR)m_pConn->Handle(), 1);
        if(FAILED(hr))
        {
            ERR1(FdConn, "[FdConnection::StartSend]: Attach() failed: HR: 0x%08x", hr);
            goto lbDone;
        }

        hr = StartConnect(m_dwFdAddr, m_wPort);
        if(FAILED(hr))
        {
            ERR1(FdConn, "[FdConnection::StartSend]: StartConnect() failed: HR: 0x%08x", hr);
        }

        goto lbDone;
    }

    //
    // Set AuthData callback info 
    //
    struct sockaddr_in laddr;
    if(FAILED(hr = m_pConn->GetLocalAddress(&laddr)))
    {
        ERR1(FdConn, "[FdConnection::StartSend]: AsyncSocket::GetLocalAddress() failed, HR: 0x%08x", hr);
        goto lbDone;
    }

    _ASSERTE(INVALID_SPI != m_pUser->Spi());
    if(INVALID_SPI != m_pUser->Spi())
    {
        if(FAILED(hr = gpConnMgr->EnableAndMapSlot( 
                        m_pUser->Spi(),
                        m_pUser->SlotIndex(),
                        PMSG_DEAD_USER == m_dwMsgType ? 0 : m_pUser->UserId(),
                        &laddr )))
        {
            ERR3(FdConn, "[FdConnection::SendMessage]: EnableAndMapSlot() failed, SPI: %08x:%u, HR: 0x%80x", 
                    m_pUser->Spi(),
                    m_pUser->SlotIndex(),
                    hr);
			m_wSrcPort = 0;
            goto lbDone;
        }
    }

    // Cache src port for cleaning up the slot
    m_wSrcPort = ntohs(laddr.sin_port);
    
    // Send Request
    m_dwStartTicks = GetTickCount();
    m_dwState = FDCONN_STATE_SENDINPROGRESS; 
    m_cbBufferPending = m_cbBuffer;
    hr = m_pConn->Send(m_pbBuffer, m_cbBuffer, m_pTask);
    if( FAILED( hr ) )
    {
        ERR2( FdConn, "[FdConnection::StartSend]: send failed, HR: 0x%08x - thread[%d]", hr, GetCurrentThreadId() );
        goto lbDone;
    }

    hr = S_OK;

    TRACE1(FdConn, L_DEBUG, "[FdConnection::StartSend]: %u bytes pending", m_cbBufferPending);

lbDone:

    // If any operation on send failed make sure the socket is put back to a 
    // disconnected state, unless its the address already in use error.
	// this error will get cleaned up when the task times out so that this
	// port will remain locked
    if(FAILED(hr) && hr != HRESULT_FROM_WIN32(WSAEADDRINUSE))
    {
        // Attempt to close the socket, this is a non-fatal
        if(FAILED(m_pConn->Close()))
        {
            ERR1(FdConn, "[FdConnection::StartSend]: AsyncSocket::Close() failed, HR: 0x%08x", hr);
        }
        m_dwState = FDCONN_STATE_DISCONNECTED;
    }

    return hr;
}

HRESULT FdConnection::CompleteSend(DWORD dwTransferred)
{
    HRESULT hr = E_FAIL;

    _ASSERTE(FDCONN_STATE_SENDINPROGRESS == m_dwState);
    _ASSERTE(dwTransferred <= m_cbBufferPending);

    if(dwTransferred > m_cbBufferPending)
    {
        ERR2(FdConn, "[FdConnection::CompleteSend]: dwTransferred: %u exceeded the ammount of buffer marked pending: %u",
                dwTransferred, m_cbBufferPending);
        goto lbDone;
    }

    if(FAILED(hr = m_pConn->GetOverlappedResult(m_pTask)))
    {
        goto lbDone;
    }

    m_cbBufferPending -= dwTransferred;

    TRACE2(FdConn, L_DEBUG, "[FdConnection::CompleteSend]: pending: %u, outbuffer :%u ", m_cbBufferPending, m_cbBuffer);

    if(0 == m_cbBufferPending)
    {
        TRACE0(FdConn, L_DEBUG, "[FdConnection::CompleteSend]: all bytes sent, reading resonse");

        // Transition to the receiving state
        hr = StartReceive();
        if(FAILED(hr))
        {
            ERR1(FdConn, "[FdConnection::CompleteSend]: StartReceive transition failed, HR: 0x%08x", hr);
            goto lbDone;
        }
    }
    else
    {
        // Continue sending pending bytes
        hr = m_pConn->Send(m_pbBuffer + (m_cbBuffer - m_cbBufferPending), m_cbBufferPending, m_pTask);
        if(FAILED(hr))
        {
            ERR3(FdConn, "[FdConnection::CompleteSend]: Continue send failed, HR: 0x%08x, outbuffer: %u, pending: %u", 
                    hr, m_cbBuffer, m_cbBufferPending);
            goto lbDone;
        }

    }

lbDone:

    return hr;
}

HRESULT FdConnection::StartReceive()
{
    HRESULT hr = E_FAIL;

    _ASSERTE(FDCONN_STATE_RECVINPROGRESS != m_dwState);

    // Clear receive state
    m_cbBuffer         = 0;
    m_dwHeaderLength   = 0;
    m_dwContentLength  = 0;
    m_dwHttpStatus     = 0;
    m_hrServer         = S_OK;

    TRACE0(FdConn, L_DEBUG, "[FdConnection::StartReceive]: starting");

    // Receive incoming data
    m_dwState = FDCONN_STATE_RECVINPROGRESS;
    m_dwStartTicks = GetTickCount();
    hr = m_pConn->Receive(m_pbBuffer, FDCONN_BUFFER_SZ, m_pTask);
    if(FAILED(hr))
    {
        ERR1( FdConn, "[FdConnection::StartReceive]: failed with HR: 0x%08x, disconnecting", hr);
        goto lbDone;
    }

    hr = S_OK;

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteReceive(DWORD dwTransferred, bool *pbCompletionDelivered)
{
    HRESULT hr = S_OK;

    _ASSERTE(FDCONN_STATE_RECVINPROGRESS == m_dwState || FDCONN_STATE_DISCONNECTING == m_dwState);

    TRACE2(FdConn, L_DEBUG, "[FdConnection::CompleteReceive]: transferred: %u, cbInBuffer: %u", dwTransferred, m_cbBuffer);

    if(m_cbBuffer + dwTransferred > FDCONN_BUFFER_SZ)
    {
        ERR1(FdConn, "[FdConnection::CompleteReceieve]: receive exceeded internal buffer (%u bytes)", m_cbBuffer + dwTransferred);
        hr = E_FAIL;
        goto lbDone;
    }

    if(FAILED(hr = m_pConn->GetOverlappedResult(m_pTask)))
    {
        goto lbDone;
    }

    if(0 == m_cbBuffer && 0 == dwTransferred)
    {
        ERR0(FdConn, "[FdConnection::CompleteReceive]: pre-maturely disconnected");
        hr = E_FAIL;
        goto lbDone;
    }

    //
    // Record received data
    //
    m_cbBuffer += dwTransferred;

    //
    // Parse header if we don't have it yet
    //
    if(0 == m_dwHeaderLength)
    {
        BYTE *pEndHeaders = (BYTE*)SearchString( (char*)m_pbBuffer, m_cbBuffer, "\r\n\r\n" ); 
        if( 0 == pEndHeaders )
        {
            // Continue receiving
            hr = m_pConn->Receive(m_pbBuffer + m_cbBuffer, FDCONN_BUFFER_SZ - m_cbBuffer, m_pTask);
            if(FAILED(hr))
            {
                ERR2( FdConn, "[FdConnection::CompleteReceive]: continue receive for header data failed, HR: 0x%08x, in: %u", 
                        hr, m_cbBuffer);
            }
            goto lbDone;
        }

        // measure header length, add 0x0d0a0d0a
        m_dwHeaderLength = pEndHeaders - m_pbBuffer + 4;

        _ASSERTE(m_dwHeaderLength > 4);
        _ASSERTE(m_dwHeaderLength < FDCONN_BUFFER_SZ);

        hr = ParseHeaders();
        if(FAILED(hr))
        {
            ERR1( FdConn, "[FdConnection::CompleteReceive]: ParseHeaders failed, HR: 0x%08x", hr);
            goto lbDone;
        }
    }

    hr = S_OK;

lbDone:

    //
    // Read completion conditions
    //
    if(SUCCEEDED(hr))
    {
        // If the receive process succeeded and we have a full expected request buffer
        if(dwTransferred > 0)
        {
            if(m_cbBuffer == (m_dwHeaderLength + m_dwContentLength))
            {
// HTTP Keep Alive:  complete the task but keep the socket open
//	            _ASSERTE(m_pfnCompletion);
//				hr = (this->*m_pfnCompletion)();
//				*pbCompletionDelivered = true;
                TRACE1(FdConn, L_DEBUG, "[FdConnection::CompleteReceive]: %u bytes receieved, disconnecting", dwTransferred);
                hr = Disconnect();
                if(FAILED(hr))
                {
                    ERR1(FdConn, "[FdConnection::CompleteReceive]: could not cleanly disconnect, HR: 0x%08x", hr);
                }
            }
            else
            {
                // Continue trying to receive data if we got a positive read and have not fufilled
                // read the entire content length
                hr = m_pConn->Receive(m_pbBuffer + m_cbBuffer, FDCONN_BUFFER_SZ - m_cbBuffer, m_pTask);
                if(FAILED(hr))
                {
                    ERR4( FdConn, "[FdConnection::CompleteReceive]: continue receive for payload failed, HR: 0x%08x, in: %u, header: %u, content: %u", 
                        hr, m_cbBuffer, m_dwHeaderLength, m_dwContentLength);
                }
            }
        }
        else // dwTransferred == 0
        {
            // Attempt to close the socket, this is a non-fatal
            if(FAILED(hr = m_pConn->Close()))
            {
                ERR1(FdConn, "[FdConnection::CompleteReceive]: AsyncSocket::Close() failed, HR: 0x%08x", hr);
            }

            m_dwState = FDCONN_STATE_DISCONNECTED;

            TRACE0(FdConn, L_DEBUG, "[FdConnection::CompleteReceive]: socket closed, message received, delivering completion");

            _ASSERTE(m_pfnCompletion);
            hr = (this->*m_pfnCompletion)();
			*pbCompletionDelivered = true;

            if(FAILED(hr))
            {
                sockaddr_in peeraddr;

                ERR8(FdConn, "[FdConnection::CompleteReceive]: completion routine failed for task: %s, id: %u, HR: 0x%08x, serverhr: 0x%08x, httpstatus: %u, user: %I64x, SPI: %08x:%u",
                        m_pTask->Name(),
                        m_pTask->ID(),
                        hr,
                        m_hrServer,
                        m_dwHttpStatus,
                        m_pUser ? m_pUser->UserId() : 0,
                        m_pUser ? m_pUser->Spi() : 0,
                        m_pUser ? m_pUser->SlotIndex() : 0);

                // This percolates up and will be handled by the failure case in of the HandleIo() caller
            }
        }
    }

    return hr;
}

HRESULT FdConnection::ParseHeaders()
{
    register const char *ps;
    register char *pd;
    register char *pe;

    char szToken[32];
    BYTE *pszSearch;
    HRESULT hr = E_FAIL;
    DWORD dwStatus;
    DWORD dwOffset;


    //  Skip protocol 'HTTP/1.1 '
    ps = (const char*)m_pbBuffer;
    while(*ps && ' ' != *ps)
    {
        ps++;
    }
    ps++;

    // Read status from current position ' XXX.X'
    dwStatus = 0;
    pd = szToken;
    pe = szToken + sizeof(szToken);
    while(*ps && pd < pe && ' ' != *ps && '.' != *ps)
    {
        *pd++ = *ps++;
    }
    *pd = '\0';
    ps++;

    dwStatus          = strtoul(szToken, '\0', 10);
    dwOffset          = 0;
    m_dwHttpStatus    = dwStatus;
    m_hrServer        = 0;
    m_dwContentLength = 0;

    if(500 == dwStatus)
    {
        // Read the server error
        pszSearch = (BYTE*)SearchString( (char*)m_pbBuffer, m_dwHeaderLength, "X-Err: " );
        if( NULL != pszSearch )
        {
            pszSearch += sizeof("X-Err: ")-1;
            dwOffset = pszSearch - m_pbBuffer;
            if(dwOffset >= m_dwHeaderLength)
            {
                ERR1(FdConn, "[FdConnection::ParseHeaders()]: Not enough header data to parse an X-Err at offset: %u", dwOffset);
                goto lbDone;
            }
            m_hrServer = ParseHexDWORD( (const char*)pszSearch, m_dwHeaderLength - dwOffset);
        }
   
        if(FAILED(m_hrServer))
        {
            ERR1(FdConn, "[FdConnection::ParseHeaders]: Server error: HR: 0x%08x", m_hrServer);
        }
    }

    // Get content length
    pszSearch = (BYTE*)SearchString((char*)m_pbBuffer, m_cbBuffer, "Content-Length: " );
    if( NULL == pszSearch )
    {
        TRACE1(FdConn, L_DEBUG, "[FdConnection::ParseHeaders]: Content-Length header missing for server status: %u", dwStatus);
        // non-fatal goto lbDone;
    }
    else
    {
        pszSearch += sizeof("Content-Length: ")-1;
        DWORD dwOffset = pszSearch - m_pbBuffer;

        // Make sure there is enough buffer left to scan
        if(dwOffset >= m_dwHeaderLength)
        {
            ERR1(FdConn, "[FdConnection::ParseHeaders]: Not enough buffer to extract the content length header at offset: %u", dwOffset);
            goto lbDone;
        }

        // Parse the header value
        m_dwContentLength  = ParseDWORD( (const char*)pszSearch, m_dwHeaderLength - dwOffset);
    }

    // Make sure reply buffer is big enough
    if( m_dwHeaderLength + m_dwContentLength > FDCONN_BUFFER_SZ)
    {
        ERR1(FdConn, "[FdConnection::ParseHeaders]: Reply buffer is too small for message data (%u)", m_dwHeaderLength + m_dwContentLength);
        goto lbDone;
    }

    hr = S_OK;

lbDone:


    return hr;
}

//------------------------------------------------------------------------------
// Alive
//------------------------------------------------------------------------------
HRESULT FdConnection::SendAlive(XPQTask *pTask, XPQUser *pUser)
{
    HRESULT   hr;
    bool      bCloaked      = true;
    bool      bVoice        = false;
    bool      bPlaying      = false;
    bool      bJoinable     = false;
    BYTE      nGuests       = 0;
    DWORD     dwState       = 0;


	if(pUser->IsXenonTitleId()) // Alive2
	{
		XPMsgAlive2 msgAlive2( XPQConnectionMgr::GetPtr()->GetDefSgAddr() );

		dwState = P_STATE_MASK_ONLINE |
			(bCloaked  ? P_STATE_MASK_CLOAKED  : 0L) |
			(bVoice    ? P_STATE_MASK_VOICE    : 0L) |
			(bPlaying  ? P_STATE_MASK_PLAYING  : 0L) |
			(bJoinable ? P_STATE_MASK_JOINABLE : 0L) |
			((nGuests & 0x03) << 5);

		// Set context
		FAIL_GOTO_DONE(ALIVE, hr = SetContext(pTask, pUser, &FdConnection::CompleteAlive));

		pUser->ClearOnlineState();

		// Pack message
		msgAlive2.SetXboxId( pUser->XboxId() );
		msgAlive2.SetSpi( pUser->Spi() );
		msgAlive2.SetUserId( pUser->UserId() );
		msgAlive2.SetAcctName( pUser->Name() );
		msgAlive2.SetBuddyListVer( pUser->BuddyListVer() );
		msgAlive2.SetBlockListVer( pUser->BlockListVer() );

		// send this information now to tell
		// the FD this is a new client and it
		// should use Connection Server.
		XBOX_LIBRARY_VERSION ver;
		ver.wMajorVersion = 0;
		ver.wMinorVersion = 0;
		ver.wBuildNumber = 0;
		ver.wQFENumber = 0;

		msgAlive2.SetClientLibVer( ver );
		msgAlive2.SetTitleId( pUser->TitleId() );
		msgAlive2.SetXNAdder( pUser->XNAddr() );
		msgAlive2.SetXNKId( pUser->XNKId() );
		msgAlive2.SetXNKey( pUser->XNKey() );
		msgAlive2.SetNonce( pUser->Nonce() );

		// Send the message
		FAIL_GOTO_DONE(ALIVE, hr = StartSend(&msgAlive2, ms_wPPORT));
	}
	else // Alive
	{
		XPMsgAlive msgAlive( XPQConnectionMgr::GetPtr()->GetDefSgAddr() );

		dwState = P_STATE_MASK_ONLINE |
			(bCloaked  ? P_STATE_MASK_CLOAKED  : 0L) |
			(bVoice    ? P_STATE_MASK_VOICE    : 0L) |
			(bPlaying  ? P_STATE_MASK_PLAYING  : 0L) |
			(bJoinable ? P_STATE_MASK_JOINABLE : 0L) |
			((nGuests & 0x03) << 5);

		// Set context
		FAIL_GOTO_DONE(ALIVE, hr = SetContext(pTask, pUser, &FdConnection::CompleteAlive));

		pUser->ClearOnlineState();

		// Pack message
		msgAlive.SetXboxId( pUser->XboxId() );
		msgAlive.SetSpi( pUser->Spi() );
		msgAlive.SetUserId( pUser->UserId() );
		msgAlive.SetAcctName( pUser->Name() );
		msgAlive.SetBuddyListVer( pUser->BuddyListVer() );
		msgAlive.SetBlockListVer( pUser->BlockListVer() );
		msgAlive.SetTitleId( pUser->TitleId() );
		msgAlive.SetMatchId( 0 );
		msgAlive.SetState( dwState );

		// Send the message
		FAIL_GOTO_DONE(ALIVE, hr = StartSend(&msgAlive, ms_wPPORT));
	}

lbDone:
    // Should be able to just change the users state now. If the send fails
    // we will back out the state update. If we don't do this we may get a QVAL
    // before the alive completes and the connectionmgr will believe the user
    // is not online.
    if(SUCCEEDED(hr) && 0 != m_pUser)
    {
        m_pUser->SetState(dwState);
    }

    return hr;
}

HRESULT FdConnection::CompleteAlive()
{
    HRESULT hr = E_FAIL;


    P_ALIVE_REPLY_MSG* pMsg = (P_ALIVE_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    // Process reply
    VALIDATE_GOTO_DONE(ALIVE, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(ALIVE, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(ALIVE, m_cbBuffer >= sizeof(P_ALIVE_REPLY_MSG));
    VALIDATE_GOTO_DONE(ALIVE, PMSG_ALIVE_REPLY == pMsg->dwMsgType);
    VALIDATE_GOTO_DONE(ALIVE, pMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    
    if(FAILED(pMsg->hr) && (pMsg->hr != XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT))
    {
        m_hrServer = pMsg->hr;
        goto lbDone;
    }

    m_pUser->SetBuddyListVersion(pMsg->dwBuddyListVersion);
    m_pUser->SetBlockListVersion(pMsg->dwBlockListVersion);
        
    BYTE* pData    = (BYTE*)(pMsg + 1);
    BYTE* pEndData = (BYTE*)(pMsg + m_cbBuffer);
    WORD wi, cw;
    const XPQUser *pBuddy;

    for(wi = 0, cw = pMsg->cBuddiesSent; wi < cw; ++wi)
    {
        P_REPLY_BUDDY* pReplyBuddy = (P_REPLY_BUDDY*)pData;

        pBuddy = gpUserMgr->UserPtrFromId(pReplyBuddy->qwBuddyID);
        VALIDATE_GOTO_DONE(ALIVE, 0 != pBuddy);

        m_pUser->AddBuddy(pBuddy, pReplyBuddy->bStatus);

        VALIDATE_GOTO_DONE(ALIVE, pReplyBuddy->cbAcctName <= XONLINE_GAMERTAG_SIZE);

        const char *pszBuddyName = (const char*)(pReplyBuddy + 1);
        if(0 != strncmp(pszBuddyName, pBuddy->Name(), pReplyBuddy->cbAcctName))
        {
            ERR5(FdConn, "[FdConnection::CompleteAlive]: invalid buddy name: user: %I64x, buddy reply: %s (%u) != buddy name: %s (buddyid: %I64x)",
                    m_pUser->UserId(),
                    pszBuddyName,
                    pReplyBuddy->cbAcctName,
                    pBuddy->Name(),
                    pBuddy->UserId());
        }

        pData += sizeof(P_REPLY_BUDDY) + pReplyBuddy->cbAcctName;
    }
    
    for(wi = 0, cw = pMsg->cBlocksSent; wi < cw; ++wi)
    {
        P_REPLY_BLOCK* pReplyBlock = (P_REPLY_BLOCK*)pData;
        const XPQUser *pBlock = gpUserMgr->UserPtrFromId(pReplyBlock->qwBlockID);
        if(pBlock)
        {
            m_pUser->AddBlock(pBlock);
        }
        pData += sizeof( P_REPLY_BLOCK );
    }

    // Update user to the default state (that presence enforces on logon)
    // Change the pool flags so that the user will be released into the online
    // pool.
    m_pUser->SetPoolFlags(USERPOOL_INFO_FLAGS_ONLINE, USERPOOL_INFO_FLAGS_OFFLINE);
    
	hr = AppendNotifyCliUpdate(m_pTask, this, m_pUser, TRUE);

lbDone:

    // Backout the user state
    if(FAILED(hr) && 0 != m_pUser)
    {
        // Clear the user's online state
        m_pUser->SetState(0);
    }

    return hr;
}

//------------------------------------------------------------------------------
// Logoff
//------------------------------------------------------------------------------
HRESULT FdConnection::SendLogoff(
    XPQTask* pTask,
    XPQUser* pUser)
{
    HRESULT hr;
    
    // Generate message
    XPMsgDeadUser msgDeadUser(gpConnMgr->GetDefSgAddr());

    FAIL_GOTO_DONE(LOGOFF, hr = SetContext(pTask, pUser, &FdConnection::CompleteLogoff));

    msgDeadUser.SetXboxId( pUser->XboxId() );
    msgDeadUser.SetSpi( pUser->Spi() );
    msgDeadUser.SetUserId(pUser->UserId());

    // Remove user from SG slot info, this is required for the dead
    // user message to work correctly
    FAIL_GOTO_DONE(LOGOFF, hr = gpConnMgr->RemoveUserFromSlot(pUser));

    // Indicate the user is now considered offline, this will ensure the 
    // user will be released with their resources into the offline pool
    pUser->SetPoolFlags(USERPOOL_INFO_FLAGS_OFFLINE, USERPOOL_INFO_FLAGS_ONLINE);

    // Send the message
    FAIL_GOTO_DONE(LOGOFF, hr = StartSend(&msgDeadUser, ms_wPPORT));

lbDone:
    return hr;
}


HRESULT FdConnection::CompleteLogoff()
{
    HRESULT hr = E_FAIL;

    // Verify completion for logging purposes
    VALIDATE_GOTO_DONE(LOGOFF, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(LOGOFF, SUCCEEDED(m_hrServer));

    hr = S_OK;
    
lbDone:
    // We can't reliable assume a user is still logged on when this request
    // fails, we have already removed them from their slot and it we will
    // be better off just to assume they are offline (this better mimicks 
    // real world usage anyways)
    m_pUser->LogoffCleanup();

    return hr;
}

//------------------------------------------------------------------------------
// DeadXbox
//------------------------------------------------------------------------------
HRESULT FdConnection::SendDeadXbox(XPQTask *pTask, XPQUser *pUser)
{
    HRESULT hr;

    XPMsgDeadXbox msgDeadXbox( gpConnMgr->GetDefSgAddr() );
    
    FAIL_GOTO_DONE(DEAD_XBOX, hr = SetContext(pTask, pUser, &FdConnection::CompleteDeadXbox));

    msgDeadXbox.SetXboxId( pUser->XboxId() );
    msgDeadXbox.SetSpi( pUser->Spi() );

    FAIL_GOTO_DONE(DEAD_XBOX, hr = StartSend(&msgDeadXbox, ms_wPPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteDeadXbox()
{
    HRESULT hr = E_FAIL;

    VALIDATE_GOTO_DONE(DEAD_XBOX, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(DEAD_XBOX, SUCCEEDED(m_hrServer));

    // TODO: set the user state to offline
    
    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// DeadUser
//------------------------------------------------------------------------------
HRESULT FdConnection::SendDeadUser(XPQTask *pTask, XPQUser *pUser)
{
    HRESULT hr;

    XPMsgDeadUser msgDeadUser(gpConnMgr->GetDefSgAddr());

    FAIL_GOTO_DONE(DEAD_USER, hr = SetContext(pTask, pUser, &FdConnection::CompleteDeadUser));

    msgDeadUser.SetUserId(pUser->UserId());
    msgDeadUser.SetXboxId(pUser->XboxId());
    msgDeadUser.SetSpi(pUser->Spi());

    FAIL_GOTO_DONE(DEAD_USER, hr = StartSend(&msgDeadUser, ms_wPPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteDeadUser()
{
    HRESULT hr = E_FAIL;

    VALIDATE_GOTO_DONE(DEAD_USER, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(DEAD_USER, SUCCEEDED(m_hrServer));

    // TODO: set the user state to offline

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// CheckTitleMessages
//------------------------------------------------------------------------------
HRESULT FdConnection::SendCheckTitleMessages(XPQTask *pTask, XPQUser *pUser, DWORD dwNewTitleId)
{
    HRESULT hr;
    XPQSlotInfo slotInfo;


    XPMsgCheckTitleMessages msgCheckTitleMessages(gpConnMgr->GetDefSgAddr());

    FAIL_GOTO_DONE(CHECK_TITLE_MESSAGES, hr = gpConnMgr->GetSlotInfo(pUser->Spi(), slotInfo));
    FAIL_GOTO_DONE(CHECK_TITLE_MESSAGES, hr = SetContext(pTask, pUser, &FdConnection::CompleteCheckTitleMessages));

    msgCheckTitleMessages.SetUserId(pUser->UserId());
    msgCheckTitleMessages.SetXboxId(pUser->XboxId());
    msgCheckTitleMessages.SetSpi(pUser->Spi());

    msgCheckTitleMessages.SetTitleId(pUser->TitleId());
    msgCheckTitleMessages.SetAltTitleId1(slotInfo.dwAltTitleIds[0]);
    msgCheckTitleMessages.SetAltTitleId2(slotInfo.dwAltTitleIds[1]);
    msgCheckTitleMessages.SetAltTitleId3(slotInfo.dwAltTitleIds[2]);
    msgCheckTitleMessages.SetAltTitleId4(slotInfo.dwAltTitleIds[3]);
    msgCheckTitleMessages.SetTitleVersion(slotInfo.dwTitleVersion);
    msgCheckTitleMessages.SetTitleRegion(slotInfo.dwTitleRegion);

    FAIL_GOTO_DONE(CHECK_TITLE_MESSAGES, hr = StartSend(&msgCheckTitleMessages, ms_wMPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteCheckTitleMessages()
{
    HRESULT hr = E_FAIL;

    P_CHECK_TITLE_MESSAGES_REPLY_MSG *pReplyMsg = (P_CHECK_TITLE_MESSAGES_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(CHECK_TITLE_MESSAGES, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(CHECK_TITLE_MESSAGES, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(CHECK_TITLE_MESSAGES, m_cbBuffer >= sizeof(P_CHECK_TITLE_MESSAGES_REPLY_MSG));
    VALIDATE_GOTO_DONE(CHECK_TITLE_MESSAGES, pReplyMsg->dwMsgType == PMSG_CHECK_TITLE_MESSAGES_REPLY );
    VALIDATE_GOTO_DONE(CHECK_TITLE_MESSAGES, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof( BASE_MSG_HEADER )) );
    VALIDATE_GOTO_DONE(CHECK_TITLE_MESSAGES, pReplyMsg->dwMsgLen == sizeof(HRESULT) );

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }
    
    hr = S_OK;

lbDone:
    return hr;
}


//------------------------------------------------------------------------------
// Update State
//------------------------------------------------------------------------------
HRESULT FdConnection::SendUpdateState(
    XPQTask*  pTask,
    XPQUser*  pUser)
{
    HRESULT hr;
    
    XPMsgState msgState( gpConnMgr->GetDefSgAddr() );

    // Set context
    FAIL_GOTO_DONE(UPDATE_STATE, hr = SetContext(pTask, pUser, &FdConnection::CompleteUpdateState));

    // Pack message
    msgState.SetUserId( pUser->UserId() );
    msgState.SetXboxId( pUser->XboxId() );
    msgState.SetSpi( pUser->Spi() );
    msgState.SetMatchSesId( pUser->MatchId() );
    msgState.SetState(pUser->State());
    msgState.SetTitleData( pUser->TitleData(), pUser->TitleDataLen() );

    FAIL_GOTO_DONE(UPDATE_STATE, hr = StartSend(&msgState, ms_wDPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteUpdateState()
{
    HRESULT hr = E_FAIL;

    VALIDATE_GOTO_DONE(UPDATE_STATE, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(UPDATE_STATE, SUCCEEDED(m_hrServer));

    hr = S_OK;

lbDone:
    return hr;
}

HRESULT FdConnection::SendUpdateState2(
    XPQTask*  pTask,
    XPQUser*  pUser)
{
    HRESULT hr;
    
    XPMsgState msgState( gpConnMgr->GetDefSgAddr() );

    // Set context
    FAIL_GOTO_DONE(UPDATE_STATE, hr = SetContext(pTask, pUser, &FdConnection::CompleteUpdateState));

    // Pack message
    msgState.SetUserId( pUser->UserId() );
    msgState.SetXboxId( pUser->XboxId() );
    msgState.SetSpi( pUser->Spi() );
    msgState.SetMatchSesId( pUser->MatchId() );
    msgState.SetState(pUser->State());
    msgState.SetTitleData( pUser->TitleData(), pUser->TitleDataLen() );

    FAIL_GOTO_DONE(UPDATE_STATE, hr = StartSend(&msgState, ms_wDPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteUpdateState2()
{
    HRESULT hr = E_FAIL;

    VALIDATE_GOTO_DONE(UPDATE_STATE, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(UPDATE_STATE, SUCCEEDED(m_hrServer));

    hr = S_OK;

lbDone:
    return hr;
}

HRESULT FdConnection::SendUpdateStateBatch(
    XPQTask*      pTask,
    XPQUser*      pUser,
    CSgMsgNotifyCliUpdate *prgUpdates,
    DWORD         cUpdates)
{
    HRESULT hr;

    FAIL_GOTO_DONE(UPDATE_STATE_BATCH, hr = SetContext(pTask, pUser, &FdConnection::CompleteUpdateStateBatch));

    // Manually pack the request
    // We don't have an XPQMsg type for this so we do it manually
    DWORD dwPayload = cUpdates * sizeof(CSgMsgNotifyCliUpdate);
    DWORD dwHeader = 0;

    FAIL_GOTO_DONE(UPDATE_STATE_BATCH, hr = WriteHttpHeader(0, false, m_pbBuffer, FDCONN_BUFFER_SZ, SGMSG_TYPE_NOTIFY_CLI_UPD, dwPayload, &dwHeader));

    if(dwHeader + dwPayload > FDCONN_BUFFER_SZ)
    {
        hr = E_FAIL;
        ERR2(FdConn, "[FdConnection::SendUpdateStateBatch]: batch update overflowed the connection buffer: header: %u, payload: %u",
                dwHeader,
                dwPayload);
        goto lbDone;
    }

    // Set the total payload size
    m_cbBuffer = dwHeader + dwPayload;

    // Copy in the post data after the HTTP header
    CopyMemory(m_pbBuffer + dwHeader, prgUpdates, dwPayload);

    FAIL_GOTO_DONE(UPDATE_STATE_BATCH, hr = StartSend(NULL, ms_wDPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteUpdateStateBatch()
{
    HRESULT hr = E_FAIL;

    VALIDATE_GOTO_DONE(UPDATE_STATE_BATCH, 200 == m_dwHttpStatus);

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// Dequeue
//------------------------------------------------------------------------------
HRESULT FdConnection::SendDequeue(  
    XPQTask*      pTask,
    XPQUser*      pUser, 
    P_QUEUE_TYPES eQType)
{
    HRESULT hr;

    // Setup message
    XQMsgDequeue msgDequeue( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(DEQUEUE, hr = SetContext(pTask, pUser, &FdConnection::CompleteDequeue));

    msgDequeue.SetUserId( pUser->UserId() );
    msgDequeue.SetXboxId( pUser->XboxId() );
    msgDequeue.SetSpi( pUser->Spi() );
    msgDequeue.SetQType( eQType );
    msgDequeue.SetMaxTotalItemDataSize( 2048 - sizeof( Q_LIST_REPLY_MSG ) );
   
    FAIL_GOTO_DONE(DEQUEUE, hr = StartSend(&msgDequeue, ms_wPPORT));
lbDone:
    return hr;
}

HRESULT FdConnection::CompleteDequeue()
{
    HRESULT hr = E_FAIL;

    Q_LIST_REPLY_MSG* pMsg = (Q_LIST_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);
    BYTE* pData = (BYTE*)pMsg + sizeof(Q_LIST_REPLY_MSG);
    DWORD cdwQVal = pMsg->cdwQVals;

    VALIDATE_GOTO_DONE(DEQUEUE, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(DEQUEUE, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(DEQUEUE, m_cbBuffer >= sizeof(Q_LIST_REPLY_MSG));
    VALIDATE_GOTO_DONE(DEQUEUE, pMsg->dwMsgType == QMSG_LIST_REPLY );
    VALIDATE_GOTO_DONE(DEQUEUE, pMsg->dwMsgLen == (m_dwContentLength - sizeof( BASE_MSG_HEADER )) );
    VALIDATE_GOTO_DONE(DEQUEUE, pMsg->qwUserID == m_pUser->UserId());
    

    if(FAILED(pMsg->hr))
    {
        m_hrServer = pMsg->hr;
    }
    
    if(15 == cdwQVal)
    {
        SGQVal qval = *(SGQVal*)pData;

        //
        // Handle the qval in the dequeue response which will collapse any pending
        // notification state on this user.
        //
        qval.m_qwUserId = pMsg->qwUserID;
        FAIL_GOTO_DONE(DEQUEUE, hr = m_pUser->ProcessQVal(qval));
    }

    // Skip qvals data
    pData += cdwQVal * sizeof( DWORD );

    if( pMsg->wQLeft > 0 )
    {
        DBG1(FdConn, "[FdConnection::CompleteDequeue]: list reply had qitems left: %u", pMsg->wQLeft);
    }

    WORD wNumItems = pMsg->wNumItems;
    for(WORD wi = 0; wi < wNumItems; ++wi)
    {
        XPQUser *pBuddy;
        Q_LIST_ITEM* pItem = (Q_LIST_ITEM*)pData;
        pData += sizeof(Q_LIST_ITEM);

        switch( pMsg->wQType )
        {
            case PQUEUE_BUDDY_REQ:
            case PQUEUE_LIST_CHANGE:
                {
                    P_LIST_CHANGE_ITEM* pChangeItem = (P_LIST_CHANGE_ITEM*)pData;

                    // Move data pointer to next item
                    pData += sizeof(P_LIST_CHANGE_ITEM) + pChangeItem->cbTargetAcctName;

                    if(HRESULT_FROM_WIN32(ERROR_USER_EXISTS) == pChangeItem->hr 
                        || XONLINE_E_NOTIFICATION_FRIEND_PENDING == pChangeItem->hr
                        || 0x80040e2f == pChangeItem->hr) // DB_E_INTEGRITY_VIOLATION
                    {
                        // Ignore these errors
                        break;
                    }

                    if(FAILED( pChangeItem->hr )) 
                    {
                        ERR3(FdConn, "[FdConnection::CompleteDequeue]: user[%I64x] list item: %u, had HR: 0x%08x", 
                                m_pUser->UserId(), wi, pChangeItem->hr );
                        break;
                    }

                    if( pChangeItem->dwListVersion <= m_pUser->BuddyListVer())
                    {
                        TRACE3(FdConn, L_NORMAL, "[FdConnection::CompleteDequeue]: user[%I64x] stale list change %u <= %u", 
                                m_pUser->UserId(), pChangeItem->dwListVersion, m_pUser->BuddyListVer());
                        break;
                    }

                    pBuddy = gpUserMgr->UserPtrFromId(pChangeItem->qwTargetID); 
                    if(0 == pBuddy)
                    {
                        ERR3(FdConn, "[Fdconnection::CompleteDequeue]: user[%I64x] friend out of users range: %I64x (%I64)",
                                m_pUser->UserId(),
                                pChangeItem->qwTargetID,
                                pChangeItem->qwTargetID - gpUserMgr->BaseUserId());
                        break;
                    }

                    TRACE3(FdConn, L_DEBUG, "[FdConnection::CompleteDequeue]: user[%I64x] dequeued buddy operation op(%u) for buddy[%I64x]",
                            m_pUser->UserId(), 
                            pChangeItem->wOperationID, 
                            pBuddy->UserId());

                    switch( pChangeItem->wOperationID )
                    {
                        case PLIST_BUDDY_NOP:
                            break;
                        case PLIST_BUDDY_ADD:
                            m_pUser->AddBuddy(pBuddy, P_BUDDY_STATUS_PENDING);
                            break;
                        case PLIST_BUDDY_ADDED:
                            m_pUser->AddBuddy(pBuddy, P_BUDDY_STATUS_REQUEST);
                            break;

                        case PLIST_BUDDY_ACCEPT:
                            m_pUser->AddBuddy(pBuddy, P_BUDDY_STATUS_OK);
                            hr = m_pUser->CleanupBuddyData(pBuddy);
                            if(FAILED(hr))
                            {
                                ERR2(FdConn, "[FdConnection::CompleteDequeue]: XPQUser::CleanupBuddyData() failed for user: %I64x, HR: 0x%08x",
                                        m_pUser->UserId(),
                                        hr);
                            }
        
                            break;

                        case PLIST_BUDDY_REJECT:
                        case PLIST_BUDDY_DELETE:
                            {
                                m_pUser->RemoveBuddy(pBuddy);   
                                break;
                            }
                        default:
                            ERR3(FdConn, "[FdConnection::CompleteDequeue]: invalid operation ID: %u for user[%I64x] from buddy[%I64x]",
                                    pChangeItem->wOperationID,
                                    m_pUser->UserId(),
                                    pBuddy->UserId());

                            _ASSERTE( false );
                    }

                    m_pUser->SetBuddyListVersion(pChangeItem->dwListVersion);
                }
                break;
            case PQUEUE_PRESENCE:
                {
                    P_PRESENCE_ITEM* pPresenceItem = (P_PRESENCE_ITEM*)pData;

                    // TBD!!! Deal with these later
                    // ULONGLONG qwBuddyID;
                    // DWORD dwTitleID;
                    // DWORD dwState;
                    // ULONGLONG qwMatchSessionID;
                    // WORD  cbNickname;
                    // WORD  cbTitleStuff;
                    // // byte rgbNickName[];              // Binary
                    // // byte rgbTitleStuff[];            // Binary

                    pData += 
                        sizeof(P_PRESENCE_ITEM) + 
                        pPresenceItem->cbNickname +
                        pPresenceItem->cbTitleStuff;

                    break;
                }
            case PQUEUE_INVITE:
                {
                    P_INVITATION_ITEM* pInviteItem = (P_INVITATION_ITEM*)pData;

                    XPQUser *pHostUser  = gpUserMgr->UserPtrFromId(pInviteItem->qwHostID);
                    m_pUser->AddReceivedInvite(pHostUser, pInviteItem->dwTitleID, pInviteItem->qwMatchSessionID);
                    
                    pData += sizeof(P_INVITATION_ITEM);

                    break;
                }
            case PQUEUE_INVITE_ANSWER:
                {
                    P_INVITATION_ANSWER_ITEM* pAnswerItem = (P_INVITATION_ANSWER_ITEM*)pData;
#if 0
                    XPQUser *pInvitee    = gpUserMgr->UserPtrFromId(pAnswerItem->qwInviteeID);
                    DWORD dwInviteeIndex = pInvitee->UserIndex();

                    _ASSERTE(pInvitee->HasReceivedInvite(m_pUser));
                    _ASSERTE(LODWORD(pAnswerItem->qwMatchSessionID) == pInvitee->UserIndex());
                    _ASSERTE(HIDWORD(pAnswerItem->qwMatchSessionID) == pInvitee->TitleId());
                    
                    switch( pAnswerItem->wAnswer )
                    {
                        case PINVITE_REPLY_NO:
                            break;
                        case PINVITE_REPLY_YES:
                            break;
                        default:
                            _ASSERTE( false );
                    }
#endif

                    pData += sizeof(P_INVITATION_ANSWER_ITEM);

                    break;
                }
            case PQUEUE_PEER_PRESENCE:
                {
                    P_PEER_PRESENCE_ITEM* pPresenceItem = (P_PEER_PRESENCE_ITEM*)pData;

                    // TBD!!! Deal with these later
                    // ULONGLONG qwBuddyID;
                    // DWORD dwTitleID;
                    // DWORD dwState;
                    // ULONGLONG qwMatchSessionID;
                    // WORD  cbTitleStuff;
                    // // byte rgbTitleStuff[];            // Binary

                    pData += 
                        sizeof(P_PEER_PRESENCE_ITEM) + 
                        pPresenceItem->cbTitleStuff;

                    break;
                } 
            case PQUEUE_PRESENCE_2:
                {
                    P_PRESENCE_2_ITEM* pPresenceItem = (P_PRESENCE_2_ITEM*)pData;

                    // TBD!!! Deal with these later
                    // ULONGLONG qwBuddyID;
                    // DWORD dwTitleID;
                    // DWORD dwState;
                    // ULONGLONG qwMatchSessionID;
                    // WORD  cbNickname;
                    // WORD  cbTitleStuff;
                    // // byte rgbNickName[];              // Binary
                    // // byte rgbTitleStuff[];            // Binary

                    pData += 
                        sizeof(P_PRESENCE_2_ITEM) + 
                        pPresenceItem->cbRichPresence +
                        pPresenceItem->cbData;

                    break;
                }
            default:
                _ASSERTE( false );
        }
    }

    hr = S_OK;

lbDone:

    return hr;
}

//------------------------------------------------------------------------------
// Peer Subscribe
//------------------------------------------------------------------------------
HRESULT FdConnection::SendPeerSubscribe( 
    XPQTask*         pTask,
    XPQUser*         pUser,
    const XPQUser**  rgpPeers, 
    WORD             wCount )
{
    HRESULT hr;

	if(pUser->IsXenonTitleId())
	{
		// Setup message
		XPMsgPeerSubscribeEx msgPeerSubscribeEx( gpConnMgr->GetDefSgAddr() );

		FAIL_GOTO_DONE(PEER_SUBSCRIBE, hr = SetContext(pTask, pUser, &FdConnection::CompletePeerSubscribeEx));

		msgPeerSubscribeEx.SetUserId( pUser->UserId() );
		msgPeerSubscribeEx.SetXboxId( pUser->XboxId() );
		msgPeerSubscribeEx.SetSpi( pUser->Spi() );

		ULONGLONG rgqwPeers[MAX_PEER_SUBSCRIPTIONS];

		WORD wPeerUpdateCount = wCount;
		DWORD dwFlags         = 0;
		FAIL_GOTO_DONE(PEER_SUBSCRIBE, hr = pUser->UpdatePeers(rgpPeers, rgqwPeers, wPeerUpdateCount, dwFlags));
		_ASSERTE(wPeerUpdateCount <= MAX_PEER_SUBSCRIPTIONS);

		msgPeerSubscribeEx.SetFlags(dwFlags);
		msgPeerSubscribeEx.SetPeers(rgqwPeers, wPeerUpdateCount);
		

		// Send the message
		FAIL_GOTO_DONE(PEER_SUBSCRIBE, hr = StartSend(&msgPeerSubscribeEx, ms_wPPORT));
	}
	else
	{
		// Setup message
		XPMsgPeerSubscribe msgPeerSubscribe( gpConnMgr->GetDefSgAddr() );

		FAIL_GOTO_DONE(PEER_SUBSCRIBE, hr = SetContext(pTask, pUser, &FdConnection::CompletePeerSubscribe));

		msgPeerSubscribe.SetUserId( pUser->UserId() );
		msgPeerSubscribe.SetXboxId( pUser->XboxId() );
		msgPeerSubscribe.SetSpi( pUser->Spi() );

		ULONGLONG rgqwPeers[MAX_PEER_SUBSCRIPTIONS];

		_ASSERTE(wCount <= MAX_PEER_SUBSCRIPTIONS);
		for( WORD wI = 0; wI < wCount; ++wI )
		{
			rgqwPeers[wI] = rgpPeers[wI]->UserId();   
		}

		msgPeerSubscribe.SetPeers(rgqwPeers, wCount);

		// Send the message
		FAIL_GOTO_DONE(PEER_SUBSCRIBE, hr = StartSend(&msgPeerSubscribe, ms_wPPORT));
	}

lbDone:
    return hr;
}

HRESULT FdConnection::CompletePeerSubscribeEx()
{
    HRESULT hr = E_FAIL;

	P_PEER_SUBSCRIBE_EX_REPLY_MSG* pReply = (P_PEER_SUBSCRIBE_EX_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

	// Process reply
	VALIDATE_GOTO_DONE(PEER_SUBSCRIBE, 200 == m_dwHttpStatus);
	VALIDATE_GOTO_DONE(PEER_SUBSCRIBE, SUCCEEDED(m_hrServer));
	VALIDATE_GOTO_DONE(PEER_SUBSCRIBE, m_cbBuffer >= sizeof(P_PEER_SUBSCRIBE_EX_REPLY_MSG));
	VALIDATE_GOTO_DONE(PEER_SUBSCRIBE, PMSG_PEER_SUBSCRIBE_EX_REPLY == pReply->dwMsgType);
	VALIDATE_GOTO_DONE(PEER_SUBSCRIBE, pReply->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));

	if(FAILED(pReply->hr))
	{
		m_hrServer = pReply->hr;
		goto lbDone;
	}
	
	// TODO: add peer links 

    hr = S_OK;

lbDone:
    return hr;
}

HRESULT FdConnection::CompletePeerSubscribe()
{
    HRESULT hr = E_FAIL;

	P_PEER_SUBSCRIBE_REPLY_MSG* pReply = (P_PEER_SUBSCRIBE_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

	// Process reply
	VALIDATE_GOTO_DONE(PEER_SUBSCRIBE, 200 == m_dwHttpStatus);
	VALIDATE_GOTO_DONE(PEER_SUBSCRIBE, SUCCEEDED(m_hrServer));
	VALIDATE_GOTO_DONE(PEER_SUBSCRIBE, m_cbBuffer >= sizeof(P_PEER_SUBSCRIBE_REPLY_MSG));
	VALIDATE_GOTO_DONE(PEER_SUBSCRIBE, PMSG_PEER_SUBSCRIBE_REPLY == pReply->dwMsgType);
	VALIDATE_GOTO_DONE(PEER_SUBSCRIBE, pReply->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));

	if(FAILED(pReply->hr))
	{
		m_hrServer = pReply->hr;
		goto lbDone;
	}

    // TODO: add peer links 

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// PeerUnsubscribe
//------------------------------------------------------------------------------
HRESULT FdConnection::SendPeerUnsubscribe(XPQTask *pTask, XPQUser *pUser)
{
    HRESULT hr;

    XPMsgPeerUnsubscribe msgPeerUnsubscribe( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(PEER_UNSUBSCRIBE, hr = SetContext(pTask, pUser, &FdConnection::CompletePeerUnsubscribe));

    // Setup message
    msgPeerUnsubscribe.SetUserId( pUser->UserId() );
    msgPeerUnsubscribe.SetXboxId( pUser->XboxId() );
    msgPeerUnsubscribe.SetSpi( pUser->Spi() );


    FAIL_GOTO_DONE(PEER_UNSUBSCRIBE, hr = StartSend(&msgPeerUnsubscribe, ms_wPPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompletePeerUnsubscribe()
{
    HRESULT hr = E_FAIL;

    P_PEER_UNSUBSCRIBE_REPLY_MSG* pReplyMsg = (P_PEER_UNSUBSCRIBE_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(PEER_UNSUBSCRIBE, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(PEER_UNSUBSCRIBE, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(PEER_UNSUBSCRIBE, m_dwContentLength >= sizeof(P_PEER_UNSUBSCRIBE_REPLY_MSG));
    VALIDATE_GOTO_DONE(PEER_UNSUBSCRIBE, PMSG_PEER_UNSUBSCRIBE_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(PEER_UNSUBSCRIBE, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(PEER_UNSUBSCRIBE, pReplyMsg->dwMsgLen == sizeof(HRESULT));

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// Add Buddy
//------------------------------------------------------------------------------
HRESULT FdConnection::SendAddBuddy( 
    XPQTask* pTask,
    XPQUser* pUser,
    const XPQUser* pBuddy, 
    bool     bByName )
{
    HRESULT hr;

    // Setup message
    XPMsgAdd msgAdd( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(ADD_BUDDY, hr = SetContext(pTask, pUser, pBuddy, &FdConnection::CompleteAddBuddy));

    msgAdd.SetSenderId( pUser->UserId() );
    msgAdd.SetXboxId( pUser->XboxId() );
    msgAdd.SetSpi( pUser->Spi() );

    if( bByName )
    {
        msgAdd.SetBuddyName( pBuddy->Name() );
    }
    else
    {
        msgAdd.SetBuddyId( pBuddy->UserId() );
    }

    // Send the message
    FAIL_GOTO_DONE(ADD_BUDDY, hr = StartSend(&msgAdd, ms_wPPORT));
    
lbDone:
    return hr;
}

HRESULT FdConnection::CompleteAddBuddy()
{
    HRESULT hr = E_FAIL;

    // No reply payload
    VALIDATE_GOTO_DONE(ADD_BUDDY, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(ADD_BUDDY, SUCCEEDED(m_hrServer));

    hr = S_OK;
lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// Accept Buddy
//------------------------------------------------------------------------------
HRESULT FdConnection::SendAcceptBuddy( 
    XPQTask* pTask,
    XPQUser* pUser,
    const XPQUser* pBuddy )
{
    HRESULT hr;

    // Setup message
    XPMsgAccept msgAccept( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(ACCEPT_BUDDY, hr = SetContext(pTask, pUser, pBuddy, &FdConnection::CompleteAcceptBuddy));

    msgAccept.SetUserId( pUser->UserId() );
    msgAccept.SetXboxId( pUser->XboxId() );
    msgAccept.SetSpi( pUser->Spi() );
    msgAccept.SetBuddyId( pBuddy->UserId() );

    // Send the message
    FAIL_GOTO_DONE(ACCEPT_BUDDY, hr = StartSend(&msgAccept, ms_wPPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteAcceptBuddy()
{
    HRESULT hr = E_FAIL;

    // No reply payload
    VALIDATE_GOTO_DONE(ACCEPT_BUDDY, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(ACCEPT_BUDDY, SUCCEEDED(m_hrServer));

    // We'll get another notification telling us the status of the buddy
    // at which point we'll add the full buddy link
    FAIL_GOTO_DONE(ACCEPT_BUDDY, hr = m_pUser->RemoveBuddy(m_pTargetUser));

    hr = S_OK;
lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// Reject Buddy
//------------------------------------------------------------------------------
HRESULT FdConnection::SendRejectBuddy(
    XPQTask* pTask,
    XPQUser* pUser,
    const XPQUser* pBuddy, 
    bool     bNever )
{
    HRESULT hr;

    // Setup message
    MsgReject msgReject( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(REJECT_BUDDY, hr = SetContext(pTask, pUser, pBuddy, &FdConnection::CompleteRejectBuddy));

    msgReject.SetUserId( pUser->UserId() );
    msgReject.SetXboxId( pUser->XboxId() );
    msgReject.SetSpi( pUser->Spi() );
    msgReject.SetBuddyId( pBuddy->UserId() );
    msgReject.SetNever( bNever );

    // Send and process message
    FAIL_GOTO_DONE(REJECT_BUDDY, hr = StartSend(&msgReject, ms_wPPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteRejectBuddy()
{
    HRESULT hr = E_FAIL;

    // No reply payload
    VALIDATE_GOTO_DONE(REJECT_BUDDY, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(REJECT_BUDDY, SUCCEEDED(m_hrServer));

    FAIL_GOTO_DONE(REJECT_BUDDY, hr = m_pUser->RemoveBuddy(m_pTargetUser));

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// Delete Buddy
//------------------------------------------------------------------------------
HRESULT FdConnection::SendDeleteBuddy( 
    XPQTask* pTask,
    XPQUser* pUser,
    const XPQUser* pBuddy)
{
    HRESULT hr;

    // Setup message
    XPMsgDelete msgDelete( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(DELETE_BUDDY, hr = SetContext(pTask, pUser, pBuddy, &FdConnection::CompleteDeleteBuddy)); 

    msgDelete.SetUserId( pUser->UserId() );
    msgDelete.SetXboxId( pUser->XboxId() );
    msgDelete.SetSpi( pUser->Spi() );
    msgDelete.SetBuddyId( pBuddy->UserId() );

    // Send and process message
    FAIL_GOTO_DONE(DELETE_BUDDY, hr = StartSend(&msgDelete, ms_wPPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteDeleteBuddy()
{
    HRESULT hr = E_FAIL;

    // No reply payload
    VALIDATE_GOTO_DONE(DELETE_BUDDY, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(DELETE_BUDDY, SUCCEEDED(m_hrServer));

    FAIL_GOTO_DONE(DELETE_BUDDY, hr = m_pUser->RemoveBuddy(m_pTargetUser));

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// Block
//------------------------------------------------------------------------------
HRESULT FdConnection::SendBlock( 
    XPQTask* pTask,
    XPQUser* pUser,
    const XPQUser* pBlock)
{
    HRESULT hr;

    // Setup message
    XPMsgBlock msgBlock( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(BLOCK, hr = SetContext(pTask, pUser, pBlock, &FdConnection::CompleteBlock));

    msgBlock.SetUserId( pUser->UserId() );
    msgBlock.SetXboxId( pUser->XboxId() );
    msgBlock.SetSpi( pUser->Spi() );
    msgBlock.SetBlockId( pBlock->UserId() );

    // Send and process message
    FAIL_GOTO_DONE(BLOCK, hr = StartSend(&msgBlock, ms_wPPORT));

lbDone:

    return hr;
}

HRESULT FdConnection::CompleteBlock()
{
    HRESULT hr = E_FAIL;

    // No reply payload
    VALIDATE_GOTO_DONE(BLOCK, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(BLOCK, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(BLOCK, 0 != m_pTargetUser);

    // Add the blocked user 
    if(FAILED(hr = m_pUser->AddBlock(m_pTargetUser)))
    {
        ERR3(FdConn, "[FdConnection::CompleteBlock]: internally failed to add block to user: %I64x for user: %I64x, HR: 0x%08x",
                m_pUser->UserId(),
                m_pTargetUser->UserId(),
                hr);
        goto lbDone;
    }
    
    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// Unblock
//------------------------------------------------------------------------------
HRESULT FdConnection::SendUnblock( 
    XPQTask  *pTask,
    XPQUser  *pUser,
    const XPQUser  *pUnblock,
    bool     bAll )
{
    HRESULT hr;

    // Setup message
    XPMsgUnblock msgUnblock( gpConnMgr->GetDefSgAddr() );

    msgUnblock.SetUserId( pUser->UserId() );
    msgUnblock.SetXboxId( pUser->XboxId() );
    msgUnblock.SetSpi( pUser->Spi() );

    if(0 != pUnblock)
    {
        FAIL_GOTO_DONE(UNBLOCK, hr = SetContext(pTask, pUser, pUnblock, &FdConnection::CompleteUnblock));
        msgUnblock.SetBlockId( pUnblock->UserId() );
    }
    else
    {
        FAIL_GOTO_DONE(UNBLOCK, hr = SetContext(pTask, pUser, &FdConnection::CompleteUnblock));
        msgUnblock.SetBlockIdToUnblockAll();
    }


    // Send and process message
    FAIL_GOTO_DONE(UNBLOCK, hr = StartSend(&msgUnblock, ms_wPPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteUnblock()
{
    HRESULT hr = E_FAIL;

    // No reply payload
    VALIDATE_GOTO_DONE(UNBLOCK, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(UNBLOCK, SUCCEEDED(m_hrServer));
    
    if( 0 == m_pTargetUser )
    {
        if(FAILED(hr = m_pUser->RemoveAllBlocks()))
        {
            ERR2(FdConn, "[FdConnection::CompleteBlock]: internally failed to remove all blocks on user: %I64x, HR: 0x%08x",
                m_pUser->UserId(),
                hr);
            goto lbDone;
        }
    }
    else
    {
        if(FAILED(hr = m_pUser->RemoveBlock(m_pTargetUser)))
        {
            ERR3(FdConn, "[FdConnection::CompleteUnblock]: internally failed to remove block on user: %I64x for user: %I64x, HR: 0x%08x",
                m_pUser->UserId(),
                m_pTargetUser->UserId(),
                hr);
            goto lbDone;
        }
    }
    
    hr = S_OK;

lbDone:
    return hr;
}

HRESULT FdConnection::SendAddAffiliates(
        XPQTask*         pTask,
        XPQUser*         pUser,
        DWORD            dwListFlag,
        DWORD            dwTitleId,
        const XPQUser**  rgpAffiliates,
        WORD             cwAffiliates)
{
    HRESULT hr;
    ULONGLONG rgqwAffiliates[X_ADD_AFFILIATE_MAX];
    XPMsgAddAffiliates msgAdd(gpConnMgr->GetDefSgAddr());

    if(cwAffiliates > X_ADD_AFFILIATE_MAX)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    FAIL_GOTO_DONE(ADD_AFFILIATES, hr = SetContext(pTask, pUser, &FdConnection::CompleteAddAffiliates));

    msgAdd.SetSenderId(pUser->UserId());
    msgAdd.SetXboxId(pUser->XboxId());
    msgAdd.SetSpi(pUser->Spi());
    msgAdd.SetListFlag(dwListFlag);
    msgAdd.SetTitleId(dwTitleId);

    for( WORD wI = 0; wI < cwAffiliates; ++wI )
    {
        rgqwAffiliates[wI] = rgpAffiliates[wI]->UserId();
    }

    msgAdd.SetAffiliates(rgqwAffiliates, cwAffiliates);
    msgAdd.ValidateAffiliates();

    FAIL_GOTO_DONE(ADD_AFFILIATES, hr = StartSend(&msgAdd, ms_wPPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteAddAffiliates()
{
    HRESULT hr = E_FAIL;

    // No reply data
    VALIDATE_GOTO_DONE(ADD_AFFILIATES, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(ADD_AFFILIATES, SUCCEEDED(m_hrServer));

    hr = S_OK;

lbDone:
    return hr;
}

HRESULT FdConnection::SendIsAffiliate(
        XPQTask*  pTask,
        XPQUser*  pUser,
        const XPQUser*  pAffiliate)
{
    HRESULT hr;

    XPMsgIsAffiliate msgIsAffiliate(gpConnMgr->GetDefSgAddr());

    FAIL_GOTO_DONE(ADD_AFFILIATES, hr = SetContext(pTask, pUser, pAffiliate, &FdConnection::CompleteIsAffiliate));

    msgIsAffiliate.SetSenderId(pUser->UserId());
    msgIsAffiliate.SetXboxId(pUser->XboxId());
    msgIsAffiliate.SetSpi(pUser->Spi());
    msgIsAffiliate.SetAffiliateId(pAffiliate->UserId());

    FAIL_GOTO_DONE(ADD_AFFILIATES, hr = StartSend(&msgIsAffiliate, ms_wPPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteIsAffiliate()
{
    HRESULT hr = E_FAIL;

    P_IS_AFFILIATE_REPLY_MSG *pReplyMsg = (P_IS_AFFILIATE_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(IS_AFFILIATE, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(IS_AFFILIATE, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(IS_AFFILIATE, m_dwContentLength >= sizeof(P_IS_AFFILIATE_REPLY_MSG));
    VALIDATE_GOTO_DONE(IS_AFFILIATE, PMSG_IS_AFFILIATE_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(IS_AFFILIATE, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(IS_AFFILIATE, pReplyMsg->dwMsgLen == sizeof(HRESULT) + sizeof(ULONGLONG) + sizeof(DWORD));
    VALIDATE_GOTO_DONE(IS_AFFILIATE, pReplyMsg->qwAffiliateID == m_pTargetUser->UserId());

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }


    hr = S_OK;

lbDone:
    return hr;
}

HRESULT FdConnection::SendQueryAffiliates(
        XPQTask*  pTask,
        XPQUser*  pUser,
        DWORD     dwListFlags,
        DWORD     cdwLimit,
        DWORD     dwOnlineTitleId,
        BOOL      fUseDatacenter)
{
    HRESULT hr;

    XPMsgQueryAffiliates msgQuery(gpConnMgr->GetDefSgAddr());

    FAIL_GOTO_DONE(QUERY_AFFILIATES, hr = SetContext(pTask, pUser, &FdConnection::CompleteQueryAffiliates));

    msgQuery.SetSenderId(pUser->UserId());
    msgQuery.SetXboxId(pUser->XboxId());
    msgQuery.SetSpi(pUser->Spi());
    msgQuery.SetListFlags(dwListFlags);
    msgQuery.SetLimit(cdwLimit);
    msgQuery.SetOnlineTitleId(dwOnlineTitleId);

    WORD wPort = fUseDatacenter ? ms_wDPORT : ms_wPPORT;
    FAIL_GOTO_DONE(QUERY_AFFILIATES, hr = StartSend(&msgQuery, wPort));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteQueryAffiliates()
{
    HRESULT hr = E_FAIL;


    P_QUERY_AFFILIATES_REPLY_MSG *pReplyMsg = (P_QUERY_AFFILIATES_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(QUERY_AFFILIATES, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(QUERY_AFFILIATES, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(QUERY_AFFILIATES, m_dwContentLength >= sizeof(P_QUERY_AFFILIATES_REPLY_MSG));
    VALIDATE_GOTO_DONE(QUERY_AFFILIATES, PMSG_QUERY_AFFILIATES_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(QUERY_AFFILIATES, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(QUERY_AFFILIATES, pReplyMsg->dwMsgLen == (sizeof(HRESULT) + sizeof(DWORD) + (sizeof(P_QUERY_AFFILIATES_REPLY_DATA_MSG)*pReplyMsg->cdwResults)));

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    hr = S_OK;

lbDone:
    return hr;
}


HRESULT FdConnection::SendInvite( 
    XPQTask*  pTask,
    XPQUser*  pUser,
    const XPQUser** apBuddy, 
    WORD      wCount )
{
    HRESULT hr;

    XPMsgInvite msgInvite( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(INVITE, hr = SetContext(pTask, pUser, &FdConnection::CompleteInvite));

    // If invitation send fails we will remove this pending
    // invite record.
    XPQInviteData *pInvite;
    FAIL_GOTO_DONE(INVITE, hr = m_pUser->AddPendingInvite(&pInvite, apBuddy, wCount));

    // Setup message
    msgInvite.SetUserId( pUser->UserId() );
    msgInvite.SetXboxId( pUser->XboxId() );
    msgInvite.SetSpi( pUser->Spi() );
    msgInvite.SetTitleId( pUser->TitleId() );
    msgInvite.SetMatchId( pUser->MatchId() );
    
    

    for( WORD wI = 0; wI < wCount; ++wI )
    {
        ULONGLONG qwBuddyId = apBuddy[wI]->UserId();
        msgInvite.AddInvitees( &qwBuddyId, 1 );
    }


    FAIL_GOTO_DONE(INVITE, hr = StartSend(&msgInvite, ms_wPPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteInvite()
{
    HRESULT hr = E_FAIL;

    VALIDATE_GOTO_DONE(INVITE, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(INVITE, SUCCEEDED(m_hrServer));
    
    hr = S_OK;

lbDone:
    if(FAILED(hr))
    {
        m_pUser->ClearPendingInvite();
    }

    
    return hr;
}

HRESULT FdConnection::SendCancelInvite( 
    XPQTask*  pTask,
    XPQUser*  pUser,
    const XPQUser** apBuddy, 
    WORD      wCount )
{
    HRESULT hr;
    const XPQInviteData *pInvite;

    // Setup message
    XPMsgCancelInvite msgCancelInvite( gpConnMgr->GetDefSgAddr() );
    
    FAIL_GOTO_DONE(CANCEL_INVITE, hr = SetContext(pTask, pUser, &FdConnection::CompleteCancelInvite));

    hr = pUser->GetPendingInvite(&pInvite);
    if(S_FALSE == hr)
    {
        _ASSERT(!"Should have had valid pending invite");
        hr = E_FAIL;
    }

    if(FAILED(hr))
    {
        goto lbDone;
    }

    msgCancelInvite.SetUserId( pUser->UserId() );
    msgCancelInvite.SetXboxId( pUser->XboxId() );
    msgCancelInvite.SetSpi( pUser->Spi() );
    msgCancelInvite.SetMatchId( pInvite->qwSessionId );
    for( WORD wI = 0; wI < wCount; ++wI )
    {
        ULONGLONG qwBuddyId = apBuddy[wI]->UserId();
        msgCancelInvite.AddInvitees( &qwBuddyId, 1 );
    }

    FAIL_GOTO_DONE(CancelInvite, hr = StartSend(&msgCancelInvite, ms_wPPORT));

lbDone:

    pUser->ClearPendingInvite();

    return hr;
}

HRESULT FdConnection::CompleteCancelInvite()
{
    HRESULT hr = E_FAIL;
    
    VALIDATE_GOTO_DONE(CANCEL_INVITE, 200 == m_dwHttpStatus);

    VALIDATE_GOTO_DONE(CANCEL_INVITE, SUCCEEDED(m_hrServer));

    // Remove the pending invite from user
    m_pUser->ClearPendingInvite();

    hr = S_OK;

lbDone:
    return hr;
}

HRESULT FdConnection::SendAnswerInvite(  
    XPQTask*  pTask,
    XPQUser*  pUser,
    const XPQUser*  pHost, 
    ULONGLONG qwMatchId, 
    bool      bYes )
{
    HRESULT hr;
    HRESULT hrRemove;
    const XPQInviteData *pInvite;

    // Setup message
    XPMsgInviteAnswer msgInviteAnswer( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(ANSWER_INVITE, hr = SetContext(pTask, pUser, pHost, &FdConnection::CompleteAnswerInvite));

    hr = pUser->GetReceivedInvite(pHost, &pInvite);
    if(S_FALSE == hr)
    {
        _ASSERT(!"Should have had valid received invite");
        hr = E_FAIL;
    }
    if(FAILED(hr))
    {
        goto lbDone;
    }

    msgInviteAnswer.SetUserId( pUser->UserId() );
    msgInviteAnswer.SetXboxId( pUser->XboxId() );
    msgInviteAnswer.SetSpi( pUser->Spi() );
    msgInviteAnswer.SetHostId( pHost->UserId() );
    msgInviteAnswer.SetMatchId( pInvite->qwSessionId );

    m_qwTargetContext = bYes ? PINVITE_REPLY_YES : PINVITE_REPLY_NO;
    msgInviteAnswer.SetAnswer((WORD)m_qwTargetContext);

    // Clear the old invite data
    if(FAILED(hrRemove = pUser->RemoveReceivedInvite(pHost)))
    {
        ERR3(FdConn, "Failed to remove received invite, user: %I64x, session: %I64x, HR: 0x%08x",
                pUser->UserId(),
                pInvite->qwSessionId,
                hrRemove);
    }

    FAIL_GOTO_DONE(ANSWER_INVITE, hr = StartSend(&msgInviteAnswer, ms_wPPORT));

lbDone:

    
    return hr;
}

HRESULT FdConnection::CompleteAnswerInvite()
{
    HRESULT hr = E_FAIL;

    VALIDATE_GOTO_DONE(ANSWER_INVITE, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(ANSWER_INVITE, SUCCEEDED(m_hrServer));

    // Mark invites as accepted 
    if(m_qwTargetContext == PINVITE_REPLY_YES)
    {
        m_pUser->SetMatchId(m_pTargetUser->MatchId());
        m_pUser->SetMatchExpire(gpUserMgr->GenerateSessionExpiration());
    }
    else
    {
        m_pUser->SetMatchId(0);
    }

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// SendMessage
//------------------------------------------------------------------------------
HRESULT FdConnection::SendSendMessage(
    XPQTask*            pTask,
    XPQUser*            pUser,
	BYTE				bMsgType,
    ULONGLONG           qwContext,
    DWORD               dwFlags,
    ULONGLONG*          pqwRecipients,
    WORD                wRecipients,
    BYTE*               pbDetails,
    WORD                wDetails,
	WORD				wExpire)
{
    HRESULT hr;

    XQMsgSendMessage msgSendMessage( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(SEND_MESSAGE, hr = SetContext(pTask, pUser, &FdConnection::CompleteSendMessage));

    // Setup message
    msgSendMessage.SetUserId( pUser->UserId() );
    msgSendMessage.SetXboxId( pUser->XboxId() );
    msgSendMessage.SetSpi( pUser->Spi() );
    msgSendMessage.SetSenderContext( qwContext );
    msgSendMessage.SetTitleId( pUser->TitleId() );
    msgSendMessage.SetExpireMinutes( wExpire );
    msgSendMessage.SetSenderName( pUser->Name() );
    msgSendMessage.SetMessageType( bMsgType );
    msgSendMessage.SetMessageFlags( dwFlags );
    msgSendMessage.AddRecipients( pqwRecipients, wRecipients );
    msgSendMessage.AddDetails( pbDetails, wDetails );

    FAIL_GOTO_DONE(SEND_MESSAGE, hr = StartSend(&msgSendMessage, ms_wMPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteSendMessage()
{
    HRESULT hr;

    Q_SEND_MESSAGE_REPLY_MSG* pReplyMsg = (Q_SEND_MESSAGE_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);
    Q_RECIPIENT_RESULT*       pResults  = (Q_RECIPIENT_RESULT*)(pReplyMsg + 1);

    VALIDATE_GOTO_DONE(SEND_MESSAGE, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(SEND_MESSAGE, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(SEND_MESSAGE, m_dwContentLength >= sizeof(Q_SEND_MESSAGE_REPLY_MSG));
    VALIDATE_GOTO_DONE(SEND_MESSAGE, QMSG_SEND_MESSAGE_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(SEND_MESSAGE, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(SEND_MESSAGE, pReplyMsg->cRecipients > 0);

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    for( WORD i = 0; i < pReplyMsg->cRecipients; ++i )
    {  
        if( pResults[ i ].dwMessageID & XONLINE_MSG_ID_SEND_FAILED )
        {
            ERR2(FdConn, "[FdConnection::CompleteSendMessage]:  recipient result failed: user: %I64x, hr: 0x%08x", 
                    pResults[i].qwUserID,
                    pResults[i].hrRecipient);
        }
    }

    hr = S_OK;

lbDone:
    return hr;
}


//------------------------------------------------------------------------------
// EnumMessages
//------------------------------------------------------------------------------
HRESULT FdConnection::SendEnumMessages(XPQTask *pTask, XPQUser *pUser)
{
    HRESULT hr;

    XQMsgEnumMessages msgEnumMessages( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(ENUM_MESSAGES, hr = SetContext(pTask, pUser, &FdConnection::CompleteEnumMessages));

    // Setup message
    msgEnumMessages.SetUserId( pUser->UserId() );
    msgEnumMessages.SetXboxId( pUser->XboxId() );
    msgEnumMessages.SetSpi( pUser->Spi() );

    // Send and process message
    FAIL_GOTO_DONE(ENUM_MESSAGES, hr = StartSend(&msgEnumMessages, ms_wMPORT));

lbDone:
    return hr;
}


HRESULT FdConnection::CompleteEnumMessages()
{
    HRESULT hr = E_FAIL;

    Q_ENUM_MESSAGES_REPLY_MSG* pReplyMsg = (Q_ENUM_MESSAGES_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(ENUM_MESSAGES, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(ENUM_MESSAGES, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(ENUM_MESSAGES, m_dwContentLength >= sizeof(Q_ENUM_MESSAGES_REPLY_MSG));
    VALIDATE_GOTO_DONE(ENUM_MESSAGES, pReplyMsg->dwMsgType == QMSG_ENUM_MESSAGES_REPLY);
    VALIDATE_GOTO_DONE(ENUM_MESSAGES, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof( BASE_MSG_HEADER )));
    VALIDATE_GOTO_DONE(ENUM_MESSAGES, pReplyMsg->dwMsgLen == ( sizeof(HRESULT) + sizeof(WORD) + (pReplyMsg->cMessages * sizeof( Q_MESSAGE_SUMMARY ))));

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    // Walk summaries and propulate user info with summary data
    Q_MESSAGE_SUMMARY* pSummaries = (Q_MESSAGE_SUMMARY*)(pReplyMsg + 1);
    for( WORD iSum = 0; iSum < pReplyMsg->cMessages; ++iSum )
    {
        DBG2(FdConn, "[FdConnection::CompleteEnumMessages]: user: %I64x, enumerating message: 0x%08x", 
                m_pUser->UserId(),
                pSummaries[iSum].dwMessageID);

        // System message
        if(0 == pSummaries[iSum].qwSenderID)
        {
            continue;
        }

        if(FAILED(hr = m_pUser->ProcessSummary(&pSummaries[iSum])))
        {
            ERR3(FdConn, "[FdConnection::CompleteEnumMessages]: ProcessSummary() failed for user: %I64x, HR: 0x%08x, msg: 0x%08x",
                m_pUser->UserId(),
                hr,
                pSummaries[iSum].dwMessageID);

            continue;
        }
    }

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// EnumMessages2
//------------------------------------------------------------------------------
HRESULT FdConnection::SendEnumMessages2(
    XPQTask*    pTask,
    XPQUser*    pUser)
{
    HRESULT hr;

    XQMsgEnumMessages2 msgEnumMessages(gpConnMgr->GetDefSgAddr());

    FAIL_GOTO_DONE(ENUM_MESSAGES_2, hr = SetContext(pTask, pUser, &FdConnection::CompleteEnumMessages2));

    msgEnumMessages.SetUserId(pUser->UserId());
    msgEnumMessages.SetXboxId(pUser->XboxId());
    msgEnumMessages.SetSpi(pUser->Spi());

    FAIL_GOTO_DONE(ENUM_MESSAGES_2, hr = StartSend(&msgEnumMessages));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteEnumMessages2()
{
    HRESULT hr = E_FAIL;

    Q_ENUM_MESSAGES_2_REPLY_MSG* pReplyMsg = (Q_ENUM_MESSAGES_2_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(ENUM_MESSAGES_2, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(ENUM_MESSAGES_2, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(ENUM_MESSAGES_2, m_dwContentLength >= sizeof(Q_ENUM_MESSAGES_2_REPLY_MSG));
    VALIDATE_GOTO_DONE(ENUM_MESSAGES_2, pReplyMsg->dwMsgType == QMSG_ENUM_MESSAGES_2_REPLY);
    VALIDATE_GOTO_DONE(ENUM_MESSAGES_2, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof( BASE_MSG_HEADER )));
    VALIDATE_GOTO_DONE(ENUM_MESSAGES_2, pReplyMsg->dwMsgLen == ( sizeof(HRESULT) + sizeof(WORD) + (pReplyMsg->cMessages * sizeof( Q_MESSAGE_SUMMARY_2 ))));

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    // Walk summaries and propulate user info with summary data
    Q_MESSAGE_SUMMARY_2* pSummaries = (Q_MESSAGE_SUMMARY_2*)(pReplyMsg + 1);
    for( WORD iSum = 0; iSum < pReplyMsg->cMessages; ++iSum )
    {
        DBG2(FdConn, "[FdConnection::CompleteEnumMessages2]: user: %I64x, enumerating message: 0x%08x", 
                m_pUser->UserId(),
                pSummaries[iSum].dwMessageID);

        if(FAILED(hr = m_pUser->ProcessSummary2(&pSummaries[iSum])))
        {
            ERR3(FdConn, "[FdConnection::CompleteEnumMessages2]: ProcessSummary2() failed for user: %I64x, HR: 0x%08x, msg: 0x%08x",
                m_pUser->UserId(),
                hr,
                pSummaries[iSum].dwMessageID);

            continue;
        }
    }

    hr = S_OK;

lbDone:
    return hr;
}


//------------------------------------------------------------------------------
// MessageSummary
//------------------------------------------------------------------------------
HRESULT FdConnection::SendMessageSummary(
    XPQTask*    pTask,
    XPQUser*    pUser,
    DWORD       dwMsgId)
{
    HRESULT hr;

    XQMsgMessageSummary msgMessageSummary( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(MESSAGE_SUMMARY, hr = SetContext(pTask, pUser, &FdConnection::CompleteMessageSummary));

    msgMessageSummary.SetUserId( pUser->UserId() );
    msgMessageSummary.SetXboxId( pUser->XboxId() );
    msgMessageSummary.SetSpi( pUser->Spi() );
    msgMessageSummary.SetMessageId( dwMsgId );

    FAIL_GOTO_DONE(MESSAGE_SUMMARY, hr = StartSend(&msgMessageSummary, ms_wMPORT));

lbDone:
    return hr;
}


HRESULT FdConnection::CompleteMessageSummary()
{
    HRESULT hr = E_FAIL;
    
    Q_MESSAGE_SUMMARY_REPLY_MSG* pReplyMsg = (Q_MESSAGE_SUMMARY_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(MESSAGE_SUMMARY, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(MESSAGE_SUMMARY, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(MESSAGE_SUMMARY, m_dwContentLength >= sizeof(Q_MESSAGE_SUMMARY_REPLY_MSG));
    VALIDATE_GOTO_DONE(MESSAGE_SUMMARY, QMSG_MESSAGE_SUMMARY_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(MESSAGE_SUMMARY, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(MESSAGE_SUMMARY, pReplyMsg->dwMsgLen == sizeof(HRESULT) + sizeof(Q_MESSAGE_SUMMARY));

    if(XONLINE_E_MESSAGE_INVALID_MESSAGE_ID == pReplyMsg->hr)
    {
        hr = S_OK;
        goto lbDone;
    }

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    if(FAILED(hr = m_pUser->ProcessSummary(&pReplyMsg->summary)))
    {
        ERR3(FdConn, "[FdConnection::CompleteMessageSummary]: ProcessSummary() failed for user: %I64x, HR: 0x%08x, msg: 0x%08x",
                m_pUser->UserId(),
                hr,
                pReplyMsg->summary.dwMessageID);
        goto lbDone;
    }
          
    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// MessageSummary2
//------------------------------------------------------------------------------
HRESULT FdConnection::SendMessageSummary2(
    XPQTask*    pTask,
    XPQUser*    pUser,
    DWORD       dwMsgId)
{
    HRESULT hr;

    XQMsgMessageSummary2 msgMessageSummary( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(MESSAGE_SUMMARY_2, hr = SetContext(pTask, pUser, &FdConnection::CompleteMessageSummary2));

    msgMessageSummary.SetUserId( pUser->UserId() );
    msgMessageSummary.SetXboxId( pUser->XboxId() );
    msgMessageSummary.SetSpi( pUser->Spi() );
    msgMessageSummary.SetMessageId( dwMsgId );


    FAIL_GOTO_DONE(MESSAGE_SUMMARY, hr = StartSend(&msgMessageSummary, ms_wMPORT));

lbDone:
    return hr;
} 

HRESULT FdConnection::CompleteMessageSummary2()
{
    HRESULT hr = E_FAIL;

    Q_MESSAGE_SUMMARY_2_REPLY_MSG* pReplyMsg = (Q_MESSAGE_SUMMARY_2_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(MESSAGE_SUMMARY_2, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(MESSAGE_SUMMARY_2, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(MESSAGE_SUMMARY_2, m_dwContentLength >= sizeof(Q_MESSAGE_SUMMARY_2_REPLY_MSG));
    VALIDATE_GOTO_DONE(MESSAGE_SUMMARY_2, QMSG_MESSAGE_SUMMARY_2_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(MESSAGE_SUMMARY_2, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(MESSAGE_SUMMARY_2, pReplyMsg->dwMsgLen == sizeof(HRESULT) + sizeof(Q_MESSAGE_SUMMARY_2));

    if(XONLINE_E_MESSAGE_INVALID_MESSAGE_ID == pReplyMsg->hr)
    {
        hr = S_OK;
        goto lbDone;
    }

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    if(FAILED(hr = m_pUser->ProcessSummary2(&pReplyMsg->summary)))
    {
        ERR3(FdConn, "[FdConnection::CompleteMessageSummary2]: ProcessSummary2() failed for user: %I64x, HR: 0x%08x, msg: 0x%08x",
                m_pUser->UserId(),
                hr,
                pReplyMsg->summary.dwMessageID);
        goto lbDone;
    }
          
    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// MessageDetails
//------------------------------------------------------------------------------
HRESULT FdConnection::SendMessageDetails(
    XPQTask *pTask,
    XPQUser *pUser,
    DWORD dwMsgId,
    DWORD dwSetFlags,
    DWORD dwClearFlags )
{
    HRESULT hr;

    // Setup message
    XQMsgMessageDetails msgMessageDetails( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(MESSAGE_DETAILS, hr = SetContext(pTask, pUser, &FdConnection::CompleteMessageDetails));
    m_qwTargetContext = dwSetFlags;
    m_qwTargetContext <<= 32;
    m_qwTargetContext |= dwMsgId;

    msgMessageDetails.SetUserId( pUser->UserId() );
    msgMessageDetails.SetXboxId( pUser->XboxId() );
    msgMessageDetails.SetSpi( pUser->Spi() );
    msgMessageDetails.SetMessageId( dwMsgId );
    msgMessageDetails.SetFlagsToSet( dwSetFlags );
    msgMessageDetails.SetFlagsToClear( dwClearFlags );

    FAIL_GOTO_DONE(MESSAGE_DETAILS, hr = StartSend(&msgMessageDetails, ms_wMPORT));
    
lbDone:

    return hr;
}

HRESULT FdConnection::CompleteMessageDetails()
{
    HRESULT hr = E_FAIL;

    // Send and process message
    
    Q_MESSAGE_DETAILS_REPLY_MSG* pReplyMsg = (Q_MESSAGE_DETAILS_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(MESSAGE_DETAILS, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(MESSAGE_DETAILS, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(MESSAGE_DETAILS, m_dwContentLength >= sizeof(Q_MESSAGE_DETAILS_REPLY_MSG));
    VALIDATE_GOTO_DONE(MESSAGE_DETAILS, QMSG_MESSAGE_DETAILS_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(MESSAGE_DETAILS, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(MESSAGE_DETAILS, pReplyMsg->dwMsgLen ==  (sizeof(HRESULT) + sizeof(Q_MESSAGE_SUMMARY) + pReplyMsg->summary.cbDetails));
    
    if(XONLINE_E_MESSAGE_INVALID_MESSAGE_ID == pReplyMsg->hr)
    {
        hr = m_pUser->RemoveMessage((DWORD)m_qwTargetContext);
        goto lbDone;
    }

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    if(FAILED(hr = m_pUser->ProcessDetails(&pReplyMsg->summary, (const BYTE*)(pReplyMsg + 1))))
    {
        ERR2(FdConn, "[FdConnection::CompleteMessageDetails]: ProcessDetails() failed for user: %I64x, HR: 0x%08x",
                m_pUser->UserId(),
                hr);
        goto lbDone;
    }

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// SetMessageFlags
//------------------------------------------------------------------------------
HRESULT FdConnection::SendMessageFlags(
    XPQTask* pTask,
    XPQUser* pUser,
    DWORD dwMsgId,
    DWORD dwSetFlags,
    DWORD dwClearFlags )
{
    HRESULT hr;

    // Setup message
    XQMsgMessageFlags msgMessageFlags( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(MESSAGE_FLAGS, hr = SetContext(pTask, pUser, &FdConnection::CompleteMessageFlags));
    m_qwTargetContext = dwSetFlags;
    m_qwTargetContext <<= 32;
    m_qwTargetContext |= dwMsgId;

    msgMessageFlags.SetUserId( pUser->UserId() );
    msgMessageFlags.SetXboxId( pUser->XboxId() );
    msgMessageFlags.SetSpi( pUser->Spi() );
    msgMessageFlags.SetMessageId( dwMsgId );
    msgMessageFlags.SetFlagsToSet( dwSetFlags );
    msgMessageFlags.SetFlagsToClear( dwClearFlags );

    FAIL_GOTO_DONE(MESSAGE_FLAGS, hr = StartSend(&msgMessageFlags, ms_wMPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteMessageFlags()
{
    HRESULT hr = E_FAIL;

    Q_MESSAGE_FLAGS_REPLY_MSG* pReplyMsg = (Q_MESSAGE_FLAGS_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(MESSAGE_FLAGS, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(MESSAGE_FLAGS, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(MESSAGE_FLAGS, m_dwContentLength >= sizeof(Q_MESSAGE_FLAGS_REPLY_MSG));
    VALIDATE_GOTO_DONE(MESSAGE_FLAGS, QMSG_MESSAGE_FLAGS_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(MESSAGE_FLAGS, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(MESSAGE_FLAGS, pReplyMsg->dwMsgLen == sizeof(HRESULT));

    DWORD dwFlags = (DWORD)(m_qwTargetContext >> 32);
    DWORD dwMsgId = (DWORD)(m_qwTargetContext & 0xffffffff);

    if(XONLINE_E_MESSAGE_INVALID_MESSAGE_ID == pReplyMsg->hr)
    {
        hr = m_pUser->RemoveMessage(dwMsgId);
        goto lbDone;
    }

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }


    _ASSERTE(0 != m_pUser);

    FAIL_GOTO_DONE(MESSAGE_FLAGS, hr = m_pUser->ProcessMessage(
                -1,
                dwMsgId,
                0,
                dwFlags,
                0,
                0,
                0,
                (const BYTE*)0));

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// MessageDelete
//------------------------------------------------------------------------------
HRESULT FdConnection::SendMessageDelete(
    XPQTask *pTask,
    XPQUser *pUser,
    DWORD dwMsgId,
    bool  bBlock )
{
    HRESULT hr;

    // Setup message
    XQMsgDeleteMessage msgMessageDelete( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(MESSAGE_DELETE, hr = SetContext(pTask, pUser, &FdConnection::CompleteMessageDelete));
    m_qwTargetContext = dwMsgId;

    msgMessageDelete.SetUserId( pUser->UserId() );
    msgMessageDelete.SetXboxId( pUser->XboxId() );
    msgMessageDelete.SetSpi( pUser->Spi() );
    msgMessageDelete.SetMessageId( dwMsgId );
    msgMessageDelete.SetFlags( bBlock ? XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER : 0 );

    FAIL_GOTO_DONE(MESSAGE_DELETE, hr = StartSend(&msgMessageDelete, ms_wMPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteMessageDelete()
{
    HRESULT hr = E_FAIL;

    Q_DELETE_MESSAGE_REPLY_MSG* pReplyMsg = (Q_DELETE_MESSAGE_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);
    
    VALIDATE_GOTO_DONE(MESSAGE_DELETE, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(MESSAGE_DELETE, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(MESSAGE_DELETE, m_dwContentLength >= sizeof(Q_DELETE_MESSAGE_REPLY_MSG));
    VALIDATE_GOTO_DONE(MESSAGE_DELETE, QMSG_DELETE_MESSAGE_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(MESSAGE_DELETE, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(MESSAGE_DELETE, pReplyMsg->dwMsgLen == sizeof(HRESULT));

    if(XONLINE_E_MESSAGE_INVALID_MESSAGE_ID == pReplyMsg->hr)
    {
        hr = m_pUser->RemoveMessage((DWORD)m_qwTargetContext);
        goto lbDone;
    }
     
    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    if(FAILED(hr = m_pUser->RemoveMessage((DWORD)m_qwTargetContext)))
    {
        ERR3(FdConn, "[FdConnection::CompleteMessageDelete]: failed to delete user: %I64, message: %u, HR: 0x%08x",
                m_pUser->UserId(),
                (DWORD)m_qwTargetContext,
                hr);
        goto lbDone;
    }

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// MessageRevoke
//------------------------------------------------------------------------------
HRESULT FdConnection::SendMessageRevoke(
    XPQTask *pTask,
    XPQUser *pUser,
    const Q_RECIPIENT_RESULT* prgRecipients, 
    WORD                      wcRecipients )
{
    HRESULT hr;
    
   
    XQMsgRevokeMessage msgMessageRevoke( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(MESSAGE_REVOKE, hr = SetContext(pTask, pUser, &FdConnection::CompleteMessageRevoke));

    msgMessageRevoke.SetUserId( pUser->UserId() );
    msgMessageRevoke.SetXboxId( pUser->XboxId() );
    msgMessageRevoke.SetSpi( pUser->Spi() );
    msgMessageRevoke.AddRecipients( prgRecipients, wcRecipients );
    
    FAIL_GOTO_DONE(MESSAGE_REVOKE, hr = StartSend(&msgMessageRevoke, ms_wMPORT));

lbDone:
    return hr;
}
   
HRESULT FdConnection::CompleteMessageRevoke()
{
    HRESULT hr = E_FAIL;

    Q_REVOKE_MESSAGE_REPLY_MSG* pReplyMsg = (Q_REVOKE_MESSAGE_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(MESSAGE_REVOKE, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(MESSAGE_REVOKE, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(MESSAGE_REVOKE, m_dwContentLength >= sizeof(Q_REVOKE_MESSAGE_REPLY_MSG));
    VALIDATE_GOTO_DONE(MESSAGE_REVOKE, QMSG_REVOKE_MESSAGE_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(MESSAGE_REVOKE, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(MESSAGE_REVOKE, pReplyMsg->dwMsgLen == sizeof(HRESULT));

    if(XONLINE_E_MESSAGE_INVALID_MESSAGE_ID == pReplyMsg->hr)
    {
        hr = S_OK;
        goto lbDone;
    }

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// MessageRevokeEx
//------------------------------------------------------------------------------
HRESULT FdConnection::SendMessageRevokeEx(
    XPQTask*                  pTask,
    XPQUser*                  pUser,
    ULONGLONG                 qwSenderId,
    ULONGLONG                 qwSenderContext,
    DWORD                     dwFlags,
    WORD                      wPropTag,
    BYTE                      bMessageType,
    const Q_RECIPIENT_RESULT* prgRecipients,  
    WORD                      cRecipients,
    const BYTE*               prbProp,
    WORD                      cbProp)
{
    HRESULT hr;
    
   
    XQMsgRevokeMessageEx msgMessageRevokeEx( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(MESSAGE_REVOKE_EX, hr = SetContext(pTask, pUser, &FdConnection::CompleteMessageRevokeEx));

    msgMessageRevokeEx.SetUserId( pUser->UserId() );
    msgMessageRevokeEx.SetXboxId( pUser->XboxId() );
    msgMessageRevokeEx.SetSpi( pUser->Spi() );
    msgMessageRevokeEx.AddRecipients( prgRecipients, cRecipients );
    
    FAIL_GOTO_DONE(MESSAGE_REVOKE_EX, hr = StartSend(&msgMessageRevokeEx, ms_wMPORT));

lbDone:
    return hr;
}
   
HRESULT FdConnection::CompleteMessageRevokeEx()
{
    HRESULT hr = E_FAIL;

    Q_REVOKE_MESSAGE_REPLY_MSG* pReplyMsg = (Q_REVOKE_MESSAGE_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(MESSAGE_REVOKE_EX, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(MESSAGE_REVOKE_EX, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(MESSAGE_REVOKE_EX, m_dwContentLength >= sizeof(Q_REVOKE_MESSAGE_REPLY_MSG));
    VALIDATE_GOTO_DONE(MESSAGE_REVOKE_EX, QMSG_REVOKE_MESSAGE_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(MESSAGE_REVOKE_EX, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(MESSAGE_REVOKE_EX, pReplyMsg->dwMsgLen == sizeof(HRESULT));

    if(XONLINE_E_MESSAGE_INVALID_MESSAGE_ID == pReplyMsg->hr)
    {
        hr = S_OK;
        goto lbDone;
    }

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
    }

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// UpdateNickname
//------------------------------------------------------------------------------
HRESULT FdConnection::SendUpdateNickname( 
    XPQTask* pTask,
    XPQUser* pUser,
    BYTE*    pbNickname, 
    WORD     wNicknameLen )
{
    HRESULT hr;

    XPMsgNickName msgNickname( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(UPDATE_NICKNAME, hr = SetContext(pTask, pUser, &FdConnection::CompleteUpdateNickname));
    
    // Setup message
    msgNickname.SetUserId( pUser->UserId() );
    msgNickname.SetXboxId( pUser->XboxId() );
    msgNickname.SetSpi( pUser->Spi() );
    msgNickname.SetNickname( pbNickname, wNicknameLen );
    _ASSERTE( wNicknameLen == msgNickname.NicknameLen() );

    // Send and process message
    FAIL_GOTO_DONE(UPDATE_NICKNAME, hr = StartSend(&msgNickname, ms_wPPORT));

lbDone:
    return hr;
}


HRESULT FdConnection::CompleteUpdateNickname()
{
    HRESULT hr = E_FAIL;

    VALIDATE_GOTO_DONE(SEND_MESSAGE, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(SEND_MESSAGE, SUCCEEDED(m_hrServer));

    hr = S_OK;
    
lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// DeleteTitle
//------------------------------------------------------------------------------
HRESULT FdConnection::SendDeleteTitle( 
    XPQTask* pTask,
    XPQUser* pUser,
    DWORD    dwTitleId)
{
    HRESULT hr;

    XQMsgDeleteTitle msgDeleteTitle( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(DELETE_TITLE, hr = SetContext(pTask, pUser, &FdConnection::CompleteDeleteTitle));
    
    // Setup message
    msgDeleteTitle.SetUserId( pUser->UserId() );
    msgDeleteTitle.SetXboxId( pUser->XboxId() );
    msgDeleteTitle.SetSpi( pUser->Spi() );
    msgDeleteTitle.SetTitleId(dwTitleId);

    // Send and process message
    FAIL_GOTO_DONE(DELETE_TITLE, hr = StartSend(&msgDeleteTitle, ms_wMPORT));

lbDone:
    return hr;
}


HRESULT FdConnection::CompleteDeleteTitle()
{
    HRESULT hr = E_FAIL;

    Q_DELETE_TITLE_REPLY_MSG* pReplyMsg = (Q_DELETE_TITLE_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(DELETE_TITLE, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(DELETE_TITLE, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(DELETE_TITLE, m_dwContentLength >= sizeof(Q_DELETE_TITLE_REPLY_MSG));
    VALIDATE_GOTO_DONE(DELETE_TITLE, QMSG_DELETE_TITLE_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(DELETE_TITLE, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(DELETE_TITLE, pReplyMsg->dwMsgLen == sizeof(HRESULT));

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    hr = S_OK;
    
lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// EnumTitles
//------------------------------------------------------------------------------
HRESULT FdConnection::SendEnumTitles( 
    XPQTask* pTask,
    XPQUser* pUser)
{
    HRESULT hr;

    XQMsgEnumTitles msgEnumTitles( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(ENUM_TITLES, hr = SetContext(pTask, pUser, &FdConnection::CompleteEnumTitles));
    
    // Setup message
    msgEnumTitles.SetUserId( pUser->UserId() );
    msgEnumTitles.SetXboxId( pUser->XboxId() );
    msgEnumTitles.SetSpi( pUser->Spi() );

    // Send and process message
    FAIL_GOTO_DONE(ENUM_TITLES, hr = StartSend(&msgEnumTitles, ms_wMPORT));

lbDone:
    return hr;
}


HRESULT FdConnection::CompleteEnumTitles()
{
    HRESULT hr = E_FAIL;

    Q_ENUM_TITLES_REPLY_MSG* pReplyMsg = (Q_ENUM_TITLES_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(ENUM_TITLES, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(ENUM_TITLES, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(ENUM_TITLES, m_dwContentLength >= sizeof(Q_ENUM_TITLES_REPLY_MSG));
    VALIDATE_GOTO_DONE(ENUM_TITLES, QMSG_ENUM_TITLES_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(ENUM_TITLES, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(ENUM_TITLES, pReplyMsg->dwMsgLen == (sizeof(HRESULT) + sizeof(WORD) + (pReplyMsg->cTitles * sizeof(Q_USER_TITLE))));

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    hr = S_OK;
    
lbDone:
    return hr;
}


//------------------------------------------------------------------------------
// Do Create Team
//------------------------------------------------------------------------------
HRESULT FdConnection::SendCreateTeam(
    XPQTask*     pTask,
    XPQUser*     pUser,
    const WCHAR* wszTeamName,
    const WCHAR* wszTeamDescription,
    const WCHAR* wszTeamMotto,
    const WCHAR* wszTeamURL,
    BYTE*        pbTeamData, 
    WORD         wTeamDataLen,
    BYTE*        pbCreatorData, 
    WORD         wCreatorDataLen)
{
    HRESULT hr;

    XTMsgTeamCreate msgTeamCreate( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(CREATE_TEAM, hr = SetContext(pTask, pUser, &FdConnection::CompleteCreateTeam));

    // Setup message
    msgTeamCreate.SetUserId( pUser->UserId() );
    msgTeamCreate.SetXboxId( pUser->XboxId() );
    msgTeamCreate.SetSpi( pUser->Spi() );
    msgTeamCreate.SetTitleId( pUser->TitleId() );
    msgTeamCreate.SetMaxMembers( XPQ_TEAM_DATA_MAX_MEMBERS );
    msgTeamCreate.SetTeamName( wszTeamName );
    msgTeamCreate.SetTeamDescription( wszTeamDescription );
    msgTeamCreate.SetTeamMotto( wszTeamMotto );
    msgTeamCreate.SetTeamURL( wszTeamURL );
    msgTeamCreate.SetTeamData( pbTeamData, wTeamDataLen );
    msgTeamCreate.SetCreatorData( pbCreatorData, wCreatorDataLen );


    FAIL_GOTO_DONE(CREATE_TEAM, hr = StartSend(&msgTeamCreate, ms_wTPORT));

lbDone:
    
    return hr;
}

HRESULT FdConnection::CompleteCreateTeam()
{
    HRESULT hr = E_FAIL;
    XPQTeamData *pTeamData;
    XPQTeamMemberData *pMemberData;

    P_TEAM_CREATE_REPLY_MSG* pReplyMsg = (P_TEAM_CREATE_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(TEAM_CREATE, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(TEAM_CREATE, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(TEAM_CREATE, m_dwContentLength >= sizeof(P_TEAM_CREATE_REPLY_MSG));
    VALIDATE_GOTO_DONE(TEAM_CREATE, PMSG_TEAM_CREATE_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(TEAM_CREATE, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(TEAM_CREATE, pReplyMsg->dwMsgLen == sizeof(HRESULT)+sizeof(ULONGLONG)+sizeof(FILETIME));
     

    if(XONLINE_E_TEAMS_USER_TEAMS_FULL == pReplyMsg->hr)
    {
        hr = S_OK;
        goto lbDone;
    }

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }


    // Generate the datablocks
    if(FAILED(hr = m_pUser->GetOrCreateTeamData(pReplyMsg->qwTeamID, m_pUser->TitleId(), &pTeamData)))
    {
        ERR2(FdConn, "[FdConnection::CompleteCreateTeam]: failed to create team data blocks for user: %I64x, HR: 0x%08x",
                m_pUser->UserId(),
                hr);
        goto lbDone;
    }

    pTeamData->AddMember(m_pUser->UserIndex(), XPQ_TEAM_MEMBER_STATE_OWNER); 

    if(FAILED(hr = m_pUser->GetOrCreateTeamMemberData(pReplyMsg->qwTeamID, m_pUser->TitleId(), XPQ_TEAM_MEMBER_STATE_OWNER, &pMemberData)))
    {
        ERR2(FdConn, "[FdConnection::CompleteCreateTeam]: failed to create team data blocks for user: %I64x, HR: 0x%08x",
                m_pUser->UserId(),
                hr);
        goto lbDone;
    }

    hr = S_OK;

lbDone:

    return hr;
}

//------------------------------------------------------------------------------
// ManageTeam
//------------------------------------------------------------------------------
HRESULT FdConnection::SendManageTeam(
    XPQTask*     pTask,
    XPQUser*     pUser,
    ULONGLONG    qwTeamId,
    const WCHAR* wszTeamName,
    const WCHAR* wszTeamDescription,
    const WCHAR* wszTeamMotto,
    const WCHAR* wszTeamURL,
    BYTE*        pbTeamData, 
    WORD         wTeamDataLen )
{
    HRESULT hr;

    // Setup message
    XTMsgTeamManageTeam msgManageTeam( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(TEAM_MANAGE_TEAM, hr = SetContext(pTask, pUser, &FdConnection::CompleteManageTeam));
    m_qwTargetContext = qwTeamId;

    msgManageTeam.SetUserId( pUser->UserId() );
    msgManageTeam.SetXboxId( pUser->XboxId() );
    msgManageTeam.SetSpi( pUser->Spi() );
    msgManageTeam.SetTitleId( pUser->TitleId() );
    msgManageTeam.SetTeamId( qwTeamId );
    msgManageTeam.SetTeamName( wszTeamName );
    msgManageTeam.SetTeamDescription( wszTeamDescription );
    msgManageTeam.SetTeamMotto( wszTeamMotto );
    msgManageTeam.SetTeamURL( wszTeamURL );
    msgManageTeam.SetTeamData( pbTeamData, wTeamDataLen );

    FAIL_GOTO_DONE(TEAM_MANAGE_TEAM, hr = StartSend(&msgManageTeam, ms_wTPORT));

lbDone:

    return hr;
}

HRESULT FdConnection::CompleteManageTeam()
{
    HRESULT hr = E_FAIL;

    P_TEAM_MANAGE_TEAM_REPLY_MSG* pReplyMsg = (P_TEAM_MANAGE_TEAM_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(TEAM_MANAGE_TEAM, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(TEAM_MANAGE_TEAM, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(TEAM_MANAGE_TEAM, m_dwContentLength >= sizeof(P_TEAM_MANAGE_TEAM_REPLY_MSG));
    VALIDATE_GOTO_DONE(TEAM_MANAGE_TEAM, PMSG_TEAM_MANAGE_TEAM_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(TEAM_MANAGE_TEAM, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(TEAM_MANAGE_TEAM, pReplyMsg->dwMsgLen == sizeof(HRESULT));

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
    }

    hr = S_OK;

lbDone:

    return hr;
}

//------------------------------------------------------------------------------
// DeleteTeam
//------------------------------------------------------------------------------
HRESULT FdConnection::SendDeleteTeam(
    XPQTask*  pTask,
    XPQUser*  pUser,
    ULONGLONG qwTeamId )
{
    HRESULT hr;

    // Setup message
    XTMsgTeamDelete msgDeleteTeam( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(TEAM_DELETE, hr = SetContext(pTask, pUser, &FdConnection::CompleteDeleteTeam));
    m_qwTargetContext = qwTeamId;

    msgDeleteTeam.SetUserId( pUser->UserId() );
    msgDeleteTeam.SetXboxId( pUser->XboxId() );
    msgDeleteTeam.SetSpi( pUser->Spi() );
    msgDeleteTeam.SetTitleId( pUser->TitleId() );
    msgDeleteTeam.SetTeamId( qwTeamId );

    FAIL_GOTO_DONE(TEAM_DELETE, hr = StartSend(&msgDeleteTeam, ms_wTPORT));

lbDone:

    return hr;
}

HRESULT FdConnection::CompleteDeleteTeam()
{
    HRESULT hr = E_FAIL;

    P_TEAM_DELETE_REPLY_MSG* pReplyMsg = (P_TEAM_DELETE_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(TEAM_DELETE, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(TEAM_DELETE, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(TEAM_DELETE, m_dwContentLength >= sizeof(P_TEAM_DELETE_REPLY_MSG));
    VALIDATE_GOTO_DONE(TEAM_DELETE, PMSG_TEAM_DELETE_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(TEAM_DELETE, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(TEAM_DELETE, pReplyMsg->dwMsgLen == sizeof(HRESULT));

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
    }

    if(FAILED(hr = m_pUser->RemoveTeamData(m_qwTargetContext, 0)))
    {
        ERR3(FdConn, "[FdConnection::CompleteDeleteTeam]: failed to delete team record, user: %I64x, team: %I64x, HR: 0x%08x",
                m_pUser->UserId(),
                m_qwTargetContext,
                hr);
        goto lbDone;
    }

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// ListTeams
//------------------------------------------------------------------------------
HRESULT FdConnection::SendListTeams(
    XPQTask*   pTask,
    XPQUser*   pUser,
    ULONGLONG* aqwTeamIds, 
    WORD       wNumIds )
{
    HRESULT hr;

    XTMsgListTeams msgListTeams( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(TEAM_LIST_TEAMS, hr = SetContext(pTask, pUser, &FdConnection::CompleteListTeams));

    msgListTeams.SetUserId( pUser->UserId() );
    msgListTeams.SetXboxId( pUser->XboxId() );
    msgListTeams.SetSpi( pUser->Spi() );
    msgListTeams.SetTitleId( pUser->TitleId() );
    msgListTeams.AddTeamIds( aqwTeamIds, wNumIds );

    // Clear existing teams
    FAIL_GOTO_DONE(TEAM_LIST_USER_TEAMS, hr = pUser->RemoveTeamData(0, pUser->TitleId()));

    FAIL_GOTO_DONE(TEAM_LIST_TEAMS, hr = StartSend(&msgListTeams, ms_wTPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteListTeams()
{
    HRESULT hr = E_FAIL;
    
    P_TEAM_LIST_TEAMS_REPLY_MSG* pReplyMsg = (P_TEAM_LIST_TEAMS_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(TEAM_LIST_TEAMS, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(TEAM_LIST_TEAMS, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(TEAM_LIST_TEAMS, m_dwContentLength >= sizeof(P_TEAM_LIST_TEAMS_REPLY_MSG));
    VALIDATE_GOTO_DONE(TEAM_LIST_TEAMS, PMSG_TEAM_LIST_TEAMS_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(TEAM_LIST_TEAMS, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
    }

    P_REPLY_TEAM *pTeam = (P_REPLY_TEAM*)(pReplyMsg+1);

    FAIL_GOTO_DONE(TEAM_LIST_TEAMS, hr = DeserializeReplyTeams(m_pUser, pTeam, pReplyMsg->cTeams, pReplyMsg->dwMsgLen));

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// ListUserTeams
//------------------------------------------------------------------------------
HRESULT FdConnection::SendListUserTeams(
    XPQTask*   pTask,
    XPQUser*   pUser)
{
    HRESULT hr;

    XTMsgListUserTeams msgListUserTeams( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(TEAM_LIST_USER_TEAMS, hr = SetContext(pTask, pUser, &FdConnection::CompleteListUserTeams));

    msgListUserTeams.SetUserId( pUser->UserId() );
    msgListUserTeams.SetXboxId( pUser->XboxId() );
    msgListUserTeams.SetSpi( pUser->Spi() );
    msgListUserTeams.SetTitleId( pUser->TitleId() );

    // Clear existing teams
    FAIL_GOTO_DONE(TEAM_LIST_USER_TEAMS, hr = pUser->RemoveTeamData(0, pUser->TitleId()));

    FAIL_GOTO_DONE(TEAM_LIST_USER_TEAMS, hr = StartSend(&msgListUserTeams, ms_wTPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteListUserTeams()
{
    HRESULT hr = E_FAIL;
    
    P_TEAM_LIST_USER_TEAMS_REPLY_MSG* pReplyMsg = (P_TEAM_LIST_USER_TEAMS_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(TEAM_LIST_USER_TEAMS, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(TEAM_LIST_USER_TEAMS, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(TEAM_LIST_USER_TEAMS, m_dwContentLength >= sizeof(P_TEAM_LIST_USER_TEAMS_REPLY_MSG));
    VALIDATE_GOTO_DONE(TEAM_LIST_USER_TEAMS, PMSG_TEAM_LIST_USER_TEAMS_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(TEAM_LIST_USER_TEAMS, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    
    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    P_REPLY_USER_TEAM *pTeam = (P_REPLY_USER_TEAM*)(pReplyMsg+1);

    FAIL_GOTO_DONE(TEAM_LIST_USER_TEAMS, hr = DeserializeReplyUserTeams(m_pUser, pTeam, pReplyMsg->cTeams, pReplyMsg->dwMsgLen));

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// RecruitTeamMember
//------------------------------------------------------------------------------
HRESULT FdConnection::SendRecruitTeamMember(
    XPQTask*        pTask,
    XPQUser*        pUser,
    const XPQUser*  pRecruit,
    ULONGLONG       qwTeamId,
    DWORD           dwMemberPriv,
    BYTE*           pbData, 
    WORD            wDataLen)
{
    HRESULT hr;

    // Setup message
    XTMsgTeamRecruit msgRecruitMember( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(TEAM_RECRUIT, hr = SetContext(pTask, pUser, pRecruit, &FdConnection::CompleteRecruitTeamMember));
    m_pTargetUser = pRecruit;
    m_qwTargetContext = qwTeamId;

    msgRecruitMember.SetUserId( pUser->UserId() );
    msgRecruitMember.SetXboxId( pUser->XboxId() );
    msgRecruitMember.SetSpi( pUser->Spi() );
    msgRecruitMember.SetTitleId( pUser->TitleId() );
    msgRecruitMember.SetTeamId( qwTeamId );
    msgRecruitMember.SetMemberId( pRecruit->UserId() );
    msgRecruitMember.SetMemberPriv( dwMemberPriv );
    msgRecruitMember.SetMemberData( pbData, wDataLen );
    msgRecruitMember.SetMessageFlags( 0 ); 

    XMSG_DETAILS details;
    memset( &details, 0, sizeof( XMSG_DETAILS ) );
    msgRecruitMember.AddDetails( (BYTE*)&details, sizeof( XMSG_DETAILS ) );

    FAIL_GOTO_DONE(TEAM_RECRUIT, hr = StartSend(&msgRecruitMember, ms_wTPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteRecruitTeamMember()
{
    HRESULT hr = E_FAIL;

    P_TEAM_RECRUIT_REPLY_MSG* pReplyMsg = (P_TEAM_RECRUIT_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(TEAM_RECRUIT, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(TEAM_RECRUIT, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(TEAM_RECRUIT, m_dwContentLength >= sizeof(P_TEAM_RECRUIT_REPLY_MSG));
    VALIDATE_GOTO_DONE(TEAM_RECRUIT, PMSG_TEAM_RECRUIT_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(TEAM_RECRUIT, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(TEAM_RECRUIT, pReplyMsg->dwMsgLen == sizeof(HRESULT));

    // Ignore this hresult
    if(XONLINE_E_TEAMS_USER_ALREADY_EXISTS == pReplyMsg->hr)
    {
        hr = S_OK;
        goto lbDone;
    }

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    // Update the owned team record, the receipient of the message or team enumeration will handle
    // updating/adding their own membership record
    XPQTeamData *pTeamData;
    FAIL_GOTO_DONE(TEAM_RECRUIT, m_pUser->GetTeam(m_qwTargetContext, &pTeamData));
    if(S_OK != (hr = pTeamData->AddMember(m_pTargetUser->UserIndex(), XPQ_TEAM_MEMBER_STATE_RECRUIT)))
    {
        ERR3(FdConn, "[FdConnection::CompleteRecruitTeamMember]: failed to add member: %I64x to team: %I64x owned by user: %I64x (not enough space)",
                m_pTargetUser->UserId(),
                m_qwTargetContext,
                m_pUser->UserId());
        goto lbDone;
    }
    
    hr = S_OK;

lbDone:

    return hr;
}

//------------------------------------------------------------------------------
// JoinTeam
//------------------------------------------------------------------------------
HRESULT FdConnection::SendJoinTeam(
    XPQTask*         pTask,
    XPQUser*         pUser,
    ULONGLONG        qwTeamId,
    DWORD            dwRecruitMsgId,
    P_INVITE_REPLIES eReply )
{
    HRESULT hr;

    // Setup message
    XTMsgTeamJoin msgJoinTeam( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(TEAM_JOIN, hr = SetContext(pTask, pUser, &FdConnection::CompleteJoinTeam));
    m_qwTargetContext = qwTeamId;

    msgJoinTeam.SetUserId( pUser->UserId() );
    msgJoinTeam.SetXboxId( pUser->XboxId() );
    msgJoinTeam.SetSpi( pUser->Spi() );
    msgJoinTeam.SetTitleId( pUser->TitleId() );
    msgJoinTeam.SetTeamId( qwTeamId );
    msgJoinTeam.SetRecruitMsgId( dwRecruitMsgId );
    msgJoinTeam.SetAnswer( (BYTE)eReply );

    XPQTeamMemberData *pMemberData;
    FAIL_GOTO_DONE(TEAM_JOIN, hr = m_pUser->GetTeamMember(m_qwTargetContext, &pMemberData));

    // Transitory state
    if(PINVITE_REPLY_YES == eReply)
    {
        pMemberData->bState = XPQ_TEAM_MEMBER_STATE_ACCEPT_RECRUIT;
    }
    else
    {
        pMemberData->bState = XPQ_TEAM_MEMBER_STATE_DECLINE_RECRUIT;
    }

    FAIL_GOTO_DONE(TEAM_JOIN, hr = StartSend(&msgJoinTeam, ms_wTPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteJoinTeam()
{
    HRESULT hr = E_FAIL;

    P_TEAM_JOIN_REPLY_MSG* pReplyMsg = (P_TEAM_JOIN_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(TEAM_JOIN, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(TEAM_JOIN, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(TEAM_JOIN, m_dwContentLength >= sizeof(P_TEAM_JOIN_REPLY_MSG));
    VALIDATE_GOTO_DONE(TEAM_JOIN, PMSG_TEAM_JOIN_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(TEAM_JOIN, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(TEAM_JOIN, pReplyMsg->dwMsgLen == sizeof(HRESULT));

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    XPQTeamMemberData *pMemberData;
    FAIL_GOTO_DONE(TEAM_JOIN, hr = m_pUser->GetTeamMember(m_qwTargetContext, &pMemberData));


    if(XPQ_TEAM_MEMBER_STATE_ACCEPT_RECRUIT == pMemberData->bState)
    {
        pMemberData->bState = XPQ_TEAM_MEMBER_STATE_MEMBER;
    }
    else
    {
        m_pUser->RemoveTeamMember(m_qwTargetContext);
    }

    hr = S_OK;

lbDone:

    return hr;
}

//------------------------------------------------------------------------------
// ManageTeamMember
//------------------------------------------------------------------------------
HRESULT FdConnection::SendManageTeamMember(
    XPQTask*       pTask,
    XPQUser*       pUser,
    const XPQUser* pMember,
    ULONGLONG      qwTeamId,
    DWORD          dwMemberPriv,
    BYTE*          pbData, 
    WORD           wDataLen )
{
    HRESULT hr;

    XTMsgTeamManageMember msgManageMember( gpConnMgr->GetDefSgAddr() );

    if(0 == pbData || wDataLen > XONLINE_MAX_TEAM_MEMBER_DATA_SIZE)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    FAIL_GOTO_DONE(TEAM_MANAGE_MEMBER, hr = SetContext(pTask, pUser, pMember, &FdConnection::CompleteManageTeamMember));
    m_qwTargetContext = qwTeamId;

    msgManageMember.SetUserId( pUser->UserId() );
    msgManageMember.SetXboxId( pUser->XboxId() );
    msgManageMember.SetSpi( pUser->Spi() );
    msgManageMember.SetTitleId( pUser->TitleId() );
    msgManageMember.SetTeamId( qwTeamId );
    msgManageMember.SetMemberId( pMember->UserId() );
    msgManageMember.SetMemberPriv( dwMemberPriv );
    msgManageMember.SetMemberData( pbData, wDataLen );
    
    // Optimistically assume the operation will succeed, the privs may not have been updated
    // or change from another officer/owner so this will have to be enumerated again anyways
    XPQTeamData *pTeamData;
	hr = pUser->GetTeam(qwTeamId, &pTeamData);
    if(FAILED(hr) || S_FALSE == hr)
    {
        ERR3(FdConn, "[FdConnection::SendManageTeamMember]: failed to get team for update, user: %I64x, team: %I64x, HR: 0x%08x",
                pUser->UserId(),
                qwTeamId,
                hr);

        // Non-fatal
    }
    else
    {
        if(S_OK != pTeamData->UpdateMember(pMember->UserIndex(), (BYTE)(dwMemberPriv & 0xFF)))
        {
            ERR4(FdConn, "[FdConnection::SendManageTeamMember]: failed to update member, user: %I64x, team: %I64x, memberIndex: %u, privs: 0x%08x",
                pUser->UserId(),
                qwTeamId,
                pMember->UserIndex(),
                dwMemberPriv);

        }
    }

    FAIL_GOTO_DONE(TEAM_MANAGE_MEMBER, hr = StartSend(&msgManageMember, ms_wTPORT));

    
lbDone:
    return hr;
}

HRESULT FdConnection::CompleteManageTeamMember()
{
    HRESULT hr = E_FAIL;

    P_TEAM_MANAGE_MEMBER_REPLY_MSG* pReplyMsg = (P_TEAM_MANAGE_MEMBER_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(TEAM_MANAGE_MEMBER, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(TEAM_MANAGE_MEMBER, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(TEAM_MANAGE_MEMBER, m_dwContentLength >= sizeof(P_TEAM_MANAGE_MEMBER_REPLY_MSG));
    VALIDATE_GOTO_DONE(TEAM_MANAGE_MEMBER, PMSG_TEAM_MANAGE_MEMBER_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(TEAM_MANAGE_MEMBER, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(TEAM_MANAGE_MEMBER, pReplyMsg->dwMsgLen == sizeof(HRESULT));

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    hr = S_OK;

lbDone:

    return hr;
}

//------------------------------------------------------------------------------
// RemoveTeamMember
//------------------------------------------------------------------------------
HRESULT FdConnection::SendRemoveTeamMember(
    XPQTask*       pTask,
    XPQUser*       pUser,
    const XPQUser*       pMember,
    ULONGLONG      qwTeamId)
{
    HRESULT hr;

    // Setup message
    XTMsgTeamRemove msgRemoveMember( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(TEAM_REMOVE_MEMBER, hr = SetContext(pTask, pUser, pMember, &FdConnection::CompleteRemoveTeamMember));
    m_qwTargetContext = qwTeamId;

    msgRemoveMember.SetUserId( pUser->UserId() );
    msgRemoveMember.SetXboxId( pUser->XboxId() );
    msgRemoveMember.SetSpi( pUser->Spi() );
    msgRemoveMember.SetTitleId( pUser->TitleId() );
    msgRemoveMember.SetTeamId( qwTeamId );
    msgRemoveMember.SetMemberId( pMember->UserId() );

    FAIL_GOTO_DONE(TEAM_REMOVE_MEMBER, hr = StartSend(&msgRemoveMember, ms_wTPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteRemoveTeamMember()
{
    HRESULT hr = E_FAIL;

    P_TEAM_REMOVE_REPLY_MSG* pReplyMsg = (P_TEAM_REMOVE_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(TEAM_REMOVE_MEMBER, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(TEAM_REMOVE_MEMBER, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(TEAM_REMOVE_MEMBER, m_dwContentLength >= sizeof(P_TEAM_MANAGE_MEMBER_REPLY_MSG));
    VALIDATE_GOTO_DONE(TEAM_REMOVE_MEMBER, PMSG_TEAM_MANAGE_MEMBER_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(TEAM_REMOVE_MEMBER, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    VALIDATE_GOTO_DONE(TEAM_REMOVE_MEMBER, pReplyMsg->dwMsgLen == sizeof(HRESULT));

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    XPQTeamData *pTeamData;
    FAIL_GOTO_DONE(TEAM_REMOVE_MEMBER, hr = m_pUser->GetTeam(m_qwTargetContext, &pTeamData));

    if(S_OK != pTeamData->RemoveMember(m_pTargetUser->UserIndex()))
    {
        ERR3(FdConn, "[FdConnection::CompleteRemoveTeamMember]: could not RemoveMember from team data, user: %I64x, team: %I64x, member: %I64x",
                m_pUser->UserId(),
                m_qwTargetContext,
                m_pTargetUser->UserId());
        goto lbDone;
    }
    
    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// ListTeamMembers
//------------------------------------------------------------------------------
HRESULT FdConnection::SendListTeamMembers(
    XPQTask   *pTask,
    XPQUser   *pUser,
    ULONGLONG qwTeamId,
    bool      bShowRecruits )
{
    HRESULT hr;

    XTMsgListTeamMembers msgListMembers( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(TEAM_LIST_MEMBERS, hr = SetContext(pTask, pUser, &FdConnection::CompleteListTeamMembers));
    m_qwTargetContext = qwTeamId;

    msgListMembers.SetUserId( pUser->UserId() );
    msgListMembers.SetXboxId( pUser->XboxId() );
    msgListMembers.SetSpi( pUser->Spi() );
    msgListMembers.SetTitleId( pUser->TitleId() );
    msgListMembers.SetTeamId( qwTeamId );
    msgListMembers.SetShowRecruits( bShowRecruits ? TRUE : FALSE );

    FAIL_GOTO_DONE(TEAM_LIST_MEMBERS, hr = StartSend(&msgListMembers, ms_wTPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteListTeamMembers()
{
    HRESULT hr = E_FAIL;

    P_TEAM_LIST_MEMBERS_REPLY_MSG* pReplyMsg = (P_TEAM_LIST_MEMBERS_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(TEAM_LIST_MEMBERS, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(TEAM_LIST_MEMBERS, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(TEAM_LIST_MEMBERS, m_dwContentLength >= sizeof(P_TEAM_LIST_MEMBERS_REPLY_MSG));
    VALIDATE_GOTO_DONE(TEAM_LIST_MEMBERS, PMSG_TEAM_LIST_MEMBERS_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(TEAM_LIST_MEMBERS, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));
    
    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    P_REPLY_TEAM_MEMBER *pMember = (P_REPLY_TEAM_MEMBER*)(pReplyMsg + 1);

    FAIL_GOTO_DONE(TEAM_LIST_MEMBERS, hr =  DeserializeReplyTeamMembers(
                m_pUser, 
                m_qwTargetContext, 
                pMember, 
                pReplyMsg->cMembers, 
                pReplyMsg->dwMsgLen ));

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// Do Get Team Ticket
//------------------------------------------------------------------------------
HRESULT FdConnection::SendGetTeamTicket(XPQTask *pTask, XPQUser *pUser)
{
    HRESULT hr;

    XTMsgTeamGetTicket msgGetTeamTicket( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(TEAM_GET_TICKET, hr = SetContext(pTask, pUser, &FdConnection::CompleteGetTeamTicket));

    msgGetTeamTicket.SetUserId( pUser->UserId() );
    msgGetTeamTicket.SetXboxId( pUser->XboxId() );
    msgGetTeamTicket.SetSpi( pUser->Spi() );
    msgGetTeamTicket.SetTitleId( pUser->TitleId() );

    FAIL_GOTO_DONE(TEAM_GET_TICKET, hr = StartSend(&msgGetTeamTicket, ms_wTPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteGetTeamTicket()
{
    HRESULT hr = E_FAIL;

    P_TEAM_GET_TICKET_REPLY_MSG* pReplyMsg = (P_TEAM_GET_TICKET_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(TEAM_GET_TICKET, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(TEAM_GET_TICKET, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(TEAM_GET_TICKET, m_dwContentLength >= sizeof(P_TEAM_GET_TICKET_REPLY_MSG));
    VALIDATE_GOTO_DONE(TEAM_GET_TICKET, PMSG_TEAM_GET_TICKET_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(TEAM_GET_TICKET, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    hr = S_OK;

lbDone:
    return hr;
}

HRESULT FdConnection::SendWebFriends(XPQTask *pTask, XPQUser *pUser)
{
    HRESULT hr;

    XPMsgWebFriends msgWebFriends( gpConnMgr->GetDefSgAddr() );

    FAIL_GOTO_DONE(WEB_FRIENDS, hr = SetContext(pTask, pUser, &FdConnection::CompleteWebFriends));

    msgWebFriends.SetUserId( pUser->UserId() );
    msgWebFriends.SetXboxId( pUser->XboxId() );
    msgWebFriends.SetSpi( pUser->Spi() );
    msgWebFriends.SetHttpAuth(true);

    FAIL_GOTO_DONE(WEB_FRIENDS, hr = StartSend(&msgWebFriends, ms_wDPORT));

lbDone:
    return hr;
}


HRESULT FdConnection::CompleteWebFriends()
{
    HRESULT hr = E_FAIL;

    P_GET_FRIENDS_LIST_REPLY_MSG* pReplyMsg = (P_GET_FRIENDS_LIST_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(WEB_FRIENDS, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(WEB_FRIENDS, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(WEB_FRIENDS, m_dwContentLength >= sizeof(P_GET_FRIENDS_LIST_REPLY_MSG));
    VALIDATE_GOTO_DONE(WEB_FRIENDS, PMSG_WEB_FRIENDS_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(WEB_FRIENDS, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// GetFriendsList
//------------------------------------------------------------------------------
HRESULT FdConnection::SendGetFriendsList(
            XPQTask *pTask, 
            XPQUser *pUser, 
            const XPQUser *pTargetUser)
{
    HRESULT hr = E_FAIL;

    XPMsgGetFriendsList msgGetFriendsList(gpConnMgr->GetDefSgAddr());

    FAIL_GOTO_DONE(GET_FRIENDS_LIST, hr = SetContext(pTask, pUser, pTargetUser, &FdConnection::CompleteGetFriendsList));

    msgGetFriendsList.SetSenderId(pUser->UserId());
    msgGetFriendsList.SetXboxId(pUser->XboxId());
    msgGetFriendsList.SetSpi(pUser->Spi());
    msgGetFriendsList.SetTarget(pTargetUser->UserId());
    msgGetFriendsList.SetHttpAuth(true);

    FAIL_GOTO_DONE(GET_FRIENDS_LIST, hr = StartSend(&msgGetFriendsList, ms_wDPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteGetFriendsList()
{
    HRESULT hr = E_FAIL;

    P_GET_FRIENDS_LIST_REPLY_MSG* pReplyMsg = (P_GET_FRIENDS_LIST_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(GET_FRIENDS_LIST, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(GET_FRIENDS_LIST, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(GET_FRIENDS_LIST, m_dwContentLength >= sizeof(P_GET_FRIENDS_LIST_REPLY_MSG));
    VALIDATE_GOTO_DONE(GET_FRIENDS_LIST, PMSG_GET_FRIENDS_LIST_REPLY == pReplyMsg->dwMsgType);
    VALIDATE_GOTO_DONE(GET_FRIENDS_LIST, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof(BASE_MSG_HEADER)));

    if(FAILED(pReplyMsg->hr))
    {
        m_hrServer = pReplyMsg->hr;
        goto lbDone;
    }

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// GetPresenceInfo
//------------------------------------------------------------------------------
HRESULT FdConnection::SendGetPresenceInfo(
            XPQTask *pTask, 
            XPQUser *pUser, 
            const XPQUser *pTargetUser)
{
    HRESULT hr;

    XPMsgGetPresenceInfo msgGetPresenceInfo(gpConnMgr->GetDefSgAddr());

    FAIL_GOTO_DONE(GET_PRESENCE_INFO, hr = SetContext(pTask, pUser, pTargetUser, &FdConnection::CompleteGetPresenceInfo));

    msgGetPresenceInfo.SetSenderId(pUser->UserId());
    msgGetPresenceInfo.SetXboxId(pUser->XboxId());
    msgGetPresenceInfo.SetSpi(pUser->Spi());
    msgGetPresenceInfo.SetTarget(pTargetUser->UserId());
    msgGetPresenceInfo.SetHttpAuth(true);

    FAIL_GOTO_DONE(GET_PRESENCE_INFO, hr = StartSend(&msgGetPresenceInfo, ms_wDPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteGetPresenceInfo()
{
    HRESULT hr = E_FAIL;

    P_GET_PRESENCE_INFO_MSG *pReplyMsg = (P_GET_PRESENCE_INFO_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(GET_PRESENCE_INFO, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(GET_PRESENCE_INFO, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(GET_PRESENCE_INFO, m_cbBuffer >= sizeof(P_GET_PRESENCE_INFO_MSG));
    VALIDATE_GOTO_DONE(GET_PRESENCE_INFO, pReplyMsg->dwMsgType == PMSG_PRESENCE_INFO_REPLY );
    VALIDATE_GOTO_DONE(GET_PRESENCE_INFO, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof( BASE_MSG_HEADER )) );

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// FindUser
//------------------------------------------------------------------------------
HRESULT FdConnection::SendFindUser(XPQTask *pTask, XPQUser *pUser, ULONGLONG qwFindId, const char *pszGamerTag)
{
    HRESULT hr;

    XPMsgFindUser msgFindUser(gpConnMgr->GetDefSgAddr());

    FAIL_GOTO_DONE(FIND_USER, hr = SetContext(pTask, pUser, &FdConnection::CompleteFindUser));

    msgFindUser.SetUserId(pUser->UserId());
    msgFindUser.SetXboxId(pUser->XboxId());
    msgFindUser.SetSpi(pUser->Spi());

    msgFindUser.SetFindId(qwFindId);
    msgFindUser.SetGamerTag(pszGamerTag);

    FAIL_GOTO_DONE(FIND_USER, hr = StartSend(&msgFindUser, ms_wPPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteFindUser()
{
    HRESULT hr = E_FAIL;

    P_FIND_USER_REPLY_MSG *pReplyMsg = (P_FIND_USER_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(FIND_USER, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(FIND_USER, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(FIND_USER, m_cbBuffer >= sizeof(P_FIND_USER_REPLY_MSG));
    VALIDATE_GOTO_DONE(FIND_USER, pReplyMsg->dwMsgType == PMSG_FIND_USER_REPLY );
    VALIDATE_GOTO_DONE(FIND_USER, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof( BASE_MSG_HEADER )) );
    VALIDATE_GOTO_DONE(FIND_USER, pReplyMsg->dwMsgLen == sizeof(ULONGLONG) + XONLINE_GAMERTAG_SIZE );
    VALIDATE_GOTO_DONE(FIND_USER, pReplyMsg->qwFoundID != 0);
    VALIDATE_GOTO_DONE(FIND_USER, pReplyMsg->szGamerTag[0] != 0);
    
    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// FindUsers
//------------------------------------------------------------------------------
HRESULT FdConnection::SendFindUsers(XPQTask *pTask, XPQUser *pUser, const XPQUser** apFinds, WORD  wCount)
{
    HRESULT hr;

	XPMsgFindUsers msgFindUsers(gpConnMgr->GetDefSgAddr());

    FAIL_GOTO_DONE(FIND_USERS, hr = SetContext(pTask, pUser, &FdConnection::CompleteFindUsers));

    msgFindUsers.SetUserId(pUser->UserId());
    msgFindUsers.SetXboxId(pUser->XboxId());
    msgFindUsers.SetSpi(pUser->Spi());

    for( WORD wI = 0; wI < wCount; ++wI )
    {
		P_FIND_USERS_DATA Find;
		Find.qwUserID = apFinds[wI]->UserId();
        msgFindUsers.AddFinds( &Find, 1 );
    }

    FAIL_GOTO_DONE(FIND_USERS, hr = StartSend(&msgFindUsers, ms_wPPORT));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteFindUsers()
{
    HRESULT hr = E_FAIL;

    P_FIND_USERS_REPLY_MSG *pReplyMsg = (P_FIND_USERS_REPLY_MSG*)(m_pbBuffer + m_dwHeaderLength);

    VALIDATE_GOTO_DONE(FIND_USERS, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(FIND_USERS, SUCCEEDED(m_hrServer));
    VALIDATE_GOTO_DONE(FIND_USERS, m_cbBuffer >= sizeof(P_FIND_USERS_REPLY_MSG));
    VALIDATE_GOTO_DONE(FIND_USERS, pReplyMsg->dwMsgType == PMSG_FIND_USERS_REPLY );
    VALIDATE_GOTO_DONE(FIND_USERS, pReplyMsg->dwMsgLen == (m_dwContentLength - sizeof( BASE_MSG_HEADER )) );
    
    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// InvalidateUser
//------------------------------------------------------------------------------
HRESULT FdConnection::SendInvalidateUser(XPQTask *pTask, XPQUser *pUser)
{
    HRESULT hr;
    
    XPMsgInvalidateUser msgInvalidateUser(gpConnMgr->GetDefSgAddr());

    FAIL_GOTO_DONE(INVALIDATE_USER, hr = SetContext(pTask, pUser, &FdConnection::CompleteInvalidateUser));

    msgInvalidateUser.SetUserId(pUser->UserId());
    msgInvalidateUser.SetXboxId(pUser->XboxId());
    msgInvalidateUser.SetSpi(pUser->Spi());
    msgInvalidateUser.SetHttpAuth(true);

    FAIL_GOTO_DONE(INVALIDATE_USER, hr = StartSend(&msgInvalidateUser, ms_wDPORT));
    
lbDone:
    return hr;
}

HRESULT FdConnection::CompleteInvalidateUser()
{
    HRESULT hr = E_FAIL;

    VALIDATE_GOTO_DONE(INVALIDATE_USER, 200 == m_dwHttpStatus);
    VALIDATE_GOTO_DONE(INVALIDATE_USER, SUCCEEDED(m_hrServer));

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// Echo, testing raw ASP.NET perf
//------------------------------------------------------------------------------
HRESULT FdConnection::SendEcho(XPQTask *pTask, XPQUser *pUser)
{
    HRESULT hr;

    XPMsgEcho msgEcho(gpConnMgr->GetDefSgAddr());

    FAIL_GOTO_DONE(ECHO, hr = SetContext(pTask, pUser, &FdConnection::CompleteEcho));

    FAIL_GOTO_DONE(ECHO, hr = StartSend(&msgEcho, 14000));

lbDone:
    return hr;
}

HRESULT FdConnection::CompleteEcho()
{
    HRESULT hr = E_FAIL;

    VALIDATE_GOTO_DONE(ECHO, 200 == m_dwHttpStatus);

    hr = S_OK;

lbDone:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\main.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2002 Microsoft.  ALL RIGHTS RESERVED
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

// Our local pointers that we get from creating the 
// instances. 
static XPQStress *pStress;
static XPQConnectionMgr *pConnMgr;
static XPQUserMgr *pUserMgr;
static XPQTaskMgr *pTaskMgr;

// Local arguments structure
struct Arguments
{
    DWORD dwClientID;
    ULONGLONG qwBasePuid;
    DWORD dwUserCount;
};


//------------------------------------------------------------------------------
// Local function and command callback definition
DWORD cmd_quit(const char **argv, DWORD argc);
DWORD cmd_lscale(const char **argv, DWORD argc);
DWORD cmd_stats(const char **argv, DWORD argc);
DWORD cmd_tset(const char **argv, DWORD argc);
DWORD cmd_tget(const char **argv, DWORD argc);
DWORD cmd_tget_details(const char **argv, DWORD argc);
DWORD cmd_cal(const char **argv, DWORD argc);
DWORD cmd_errors(const char **argv, DWORD argc);
DWORD cmd_tpending(const char **argv, DWORD argc);
DWORD cmd_treset(const char **argv, DWORD argc);
DWORD cmd_showuser(const char **argv, DWORD argc);
DWORD cmd_setxepct(const char **argv, DWORD argc);
DWORD cmd_setucspct(const char **argv, DWORD argc);
DWORD cmd_sgsenddelay(const char **argv, DWORD argc);
DWORD cmd_setrecvto(const char **argv, DWORD argc);
DWORD cmd_setsendto(const char **argv, DWORD argc);
DWORD cmd_addtrace(const char **argv, DWORD argc);
DWORD cmd_remtrace(const char **argv, DWORD argc);
DWORD cmd_showtraces(const char **argv, DWORD argc);
DWORD cmd_kickonerror(const char **argv, DWORD argc);
DWORD cmd_stateticks(const char **argv, DWORD argc);
DWORD cmd_disableqvals(const char **argv, DWORD argc);
DWORD cmd_help(const char **argv, DWORD argc);

struct Cmd
{
    char szName[16];
    char szDesc[64];
    DWORD (*pfnCallback)(const char** argv, DWORD argc);
} 
rgCommands[] = {
    { "quit",           "                          - quit the stress app",       cmd_quit },
    { "lscale",         "<0.0-1.0>                 - scale task load",           cmd_lscale },
    { "tset",           "<TaskExpr> <prop> <value> - change task property",      cmd_tset },
    { "tget",           "<TaskExpr>                - get task property",         cmd_tget },
    { "tget_details",   "<TaskExpr>                - get task property details", cmd_tget_details },
    { "stats",          "                          - show program statistics",   cmd_stats },
    { "cal",            "<logarea> <level>         - change area logging level", cmd_cal },
    { "errors",         "                          - show last errors",          cmd_errors },
    { "tpending",       "[millis]                  - show pending tasks",        cmd_tpending },
    { "trset",          "                          - reset task counters",       cmd_treset },
    { "showuser",       "<puid>                    - show a user record",        cmd_showuser },
    { "setxepct",       "<0-100>                   - %% allowed xenon online",   cmd_setxepct },
    { "setucspct",      "<0-100>                   - %% state field unchanged on update",   cmd_setucspct },
	{ "sgsenddelay",    "<millis>                  - millis for sg send delay",  cmd_sgsenddelay },
	{ "setrecvto",      "<millis>                  - millis for recv timeout",   cmd_setrecvto },
    { "setsendto",      "<millis>                  - millis for send timeout",   cmd_setsendto },
    { "addtrace",       "<puid>                    - trace a specific user",     cmd_addtrace },
    { "remtrace",       "<index>                   - turn off a specific trace", cmd_remtrace },
    { "showtraces",     "                          - show all active traces",    cmd_showtraces },
    { "kickonerror",    "                          - kick a user off live error",cmd_kickonerror },
    { "stateticks",     "                          - set max ticks for state",   cmd_stateticks },
    { "disableqvals",   "                          - disable qval replies (for testing)",cmd_disableqvals },
    { "help",           "                          - bleeeeet",                  cmd_help }
};




//------------------------------------------------------------------------------
// Command line argument parsing
bool ParseArgs(
    int   argc, 
    char* argv[],
    Arguments &outArgs)
{
    bool bOK = false;

    if( argc == 2 )
    {
        char *pszMarker = strchr(argv[1], ':');
        char *pszClientId;
        char *pszClientTotal;

        DWORD dwClientId;
        DWORD dwClientTotal;
        DWORD dwUserCount;
        DWORD dwTotalUserCount;
        ULONGLONG qwBasePuid;

        if(pszMarker)
        {
            *pszMarker = '\0';

            qwBasePuid = ParsePuid(argv[1]);
            if(0 == qwBasePuid)
            {
                printf("Invalid base user puid: %I64x\n",
                        qwBasePuid);
                goto lbDone;
            }

            dwTotalUserCount = strtoul(pszMarker+1, NULL, 10);
            if(0 == dwTotalUserCount)
            {
                printf("Invalid user count: %u\n",
                        dwTotalUserCount);
                goto lbDone;
            }

            //
            // Try to parse the extra partition info
            //
            pszClientId = strchr(pszMarker+1, ':');
            if(pszClientId)
            {
                pszClientTotal = strchr(pszClientId+1, ':');
            }

            if(pszClientId && pszClientTotal)
            {
                *pszClientId    = '\0';
                *pszClientTotal = '\0';
                dwClientId      = strtoul(pszClientId+1, NULL, 10);
                dwClientTotal   = strtoul(pszClientTotal+1, NULL, 10);

                if(0 == dwClientTotal)
                {
                    printf("Invalid client total: %u\n",
                            dwClientTotal);
                    goto lbDone;
                }

                if(dwClientId >= dwClientTotal)
                {
                    printf("Invalid client ID (%u) >= client total (%u)\n",
                            dwClientId,
                            dwClientTotal);
                    goto lbDone;
                }
                else
                {
                    dwUserCount = dwTotalUserCount / dwClientTotal;
                    qwBasePuid  = qwBasePuid + (dwUserCount * dwClientId);
                }
            }
            else
            {
                dwClientId    = 0;
                dwClientTotal = 1;
                dwUserCount   = dwTotalUserCount;
            }

            outArgs.dwClientID  = dwClientId;
            outArgs.qwBasePuid  = qwBasePuid;
            outArgs.dwUserCount = dwUserCount;

            printf("[ Client: %u/%u - 0x%I64x:%u (of %u)]\n", 
                    dwClientId,
                    dwClientTotal,
                    qwBasePuid,
                    dwUserCount,
                    dwTotalUserCount);
            bOK = true;
        }
        else
        {
            outArgs.dwClientID = strtoul(argv[1], NULL, 10);
            outArgs.qwBasePuid = 0;
            outArgs.dwUserCount = 0;

            if(outArgs.dwClientID <= 9)
            {
                bOK = true;
            }
        }
    }

lbDone:
    if( !bOK )
    {
        printf( "Usage: %s <ClientID|BasePuid:Count[:ClientID:Total]>\n", argv[0] );
        printf( "   ClientID          - 0 to 9, unique for each concurant test client.\n" );
        printf( "   BasePuid:Count    - Base user puid and count of users see test\\tools\\BulkUsers.\n");
        printf( "   [:ClientID:Total] - ClientID / Total Clients for partitioning user space\n");
    }

    return bOK;
}


void __stdcall DumpException(const char *pszMessage, Exception &ex)
{
    printf("%s: '%s' at FILE: %s(%d), ERROR: HRESULT: %08x:%08x\n",
            pszMessage,
            ex.GetText(),
            ex.GetFile(),
            ex.GetLine(),
            ex.GetCode(),
            ex.GetHRESULT());

    ERR6(Log, "%s: '%s' at FILE %s(%d), ERROR: HRESULT: %08x:%08x\n",
            pszMessage,
            ex.GetText(), 
            ex.GetFile(), 
            ex.GetLine(),
            ex.GetCode(),
            ex.GetHRESULT());
}

///////////////////////////////////////
// Main 
//
int __cdecl main(
    int   argc, 
    char* argv[] )
{
    HRESULT hr;
    Arguments args;

    if( !ParseArgs( argc, argv, args) )
    {
        goto lbDone;
    }

    // Initialize random number
    srand( time( NULL ) );

    pStress    = new XPQStress;
    pConnMgr   = new XPQConnectionMgr;
    pUserMgr   = new XPQUserMgr;
    pTaskMgr   = new XPQTaskMgr;

    // Create stress main object
    if(FAILED(hr = pStress->Create()))
    {
        ERR1(Log, "[main] XPQStress::Create() failed, hr: 0x%08x", hr);
        goto lbCleanup;
    }
    HANDLE hStopEvent = pStress->GetStopEvent();

	if(FAILED(hr = g_CPresCfg.Init()))
	{
        XomNtEvent(XEVENT_PRESENCE_CONFIG_81, "Unrecoverable failure while initializing: Load configuration failed hr=0x%X", hr);
        goto lbCleanup;
	}

    // Create all of the managers
    if(FAILED(hr = pUserMgr->Create(args.dwClientID, args.qwBasePuid, args.dwUserCount, hStopEvent)))
    {
        ERR1(Log, "[main] XPQUserMgr::Create() failed, hr: 0x%08x", hr);
        goto lbCleanup;
    }
    if(FAILED(hr = pConnMgr->Create(hStopEvent, pUserMgr->MaxActive() * 2)))
    {
        ERR1(Log, "[main] XPQConnectionMgr::Create() failed, hr: 0x%08x", hr);
        goto lbCleanup;
    }
    if(FAILED(hr = pTaskMgr->Create(hStopEvent)))
    {
        ERR1(Log, "[main] XPQTaskMgr::Create() failed, hr: 0x%08x", hr);
        goto lbCleanup;
    }

    // Start all threads
    TRACE0(Log, L_HIGH, "[main] Starting task and connection manager threads" );
    if(FAILED(hr = pTaskMgr->ResumeThreads()))
    {
        goto lbCleanup;
    }

    if(FAILED(hr = pConnMgr->ResumeThreads()))
    {
        goto lbCleanup;
    }

    Sleep( 100 );

    TRACE0(Log, L_HIGH, "[main] Task and connection managers running - type 'quit' to exit, 'help' to see commands." );
    
    char szInput[ 128 ];
    char *rgpszParam[16];
    char *pszParse, *pszDst;
    DWORD cbInput;
    DWORD cParam;

    while( true )
    {
        if(fgets( szInput, sizeof(szInput), stdin ) )
        {
            // Terminate input buffer
            cbInput = strlen(szInput) - 1;
            while(isspace(szInput[cbInput]))
            {
                szInput[cbInput--] = '\0';
            }

            // Parse the parameters
            cParam = 0;
            rgpszParam[cParam++] = szInput;
        
            for(pszParse = szInput; (pszParse < &szInput[cbInput]) && *pszParse; ++pszParse)
            {
                if(' ' == *pszParse)
                {
                    *pszParse = '\0';
                    rgpszParam[cParam++] = pszParse + 1;
                }

                // max params hit 
                if(cParam == 16)
                {
                    break;
                }
            }

            for(DWORD i = 0; i < sizeof(rgCommands)/sizeof(rgCommands[0]); ++i)
            {
                if(!_stricmp(rgCommands[i].szName, rgpszParam[0]))
                {
                    rgCommands[i].pfnCallback((const char**)rgpszParam, cParam);
                }
            }
        }
    }

lbCleanup:
    // Signal All stop
    TRACE0(Log, L_HIGH, "[main] main finished" );
    pStress->AllStop();

    printf("Stress finished.\n");

    delete pConnMgr;
    delete pStress;
    delete pUserMgr;
    delete pTaskMgr;

    // Dump all heap leaks
#if defined(_DEBUG)
    g_XHeap.HeapLeaks();
#endif
lbDone:
    return 0;
}

DWORD cmd_quit(const char **argv, DWORD argc)
{
    pStress->AllStop();
    return 0;
}

DWORD cmd_lscale(const char **argv, DWORD argc)
{
    SchedulerTaskThread *pScheduler = pTaskMgr->GetScheduler();

    if(argc > 1)
    {
        float fLoadScale = (float)strtod(argv[1], NULL);
        float fOldLoadScale = pScheduler->LoadScale();
        pScheduler->SetLoadScale(fLoadScale);

        printf("Scheduler load scale updated %2.4f -> %2.4f\n",
                fOldLoadScale,
                pScheduler->LoadScale());
    }
    else
    {
        printf("usage: lscale <load scaling factor> (currently: %2.4f)\n", pScheduler->LoadScale());
    }
    return 0;
}


DWORD cmd_stats(const char **argv, DWORD argc)
{
    pUserMgr->LogStats();
    pConnMgr->LogStats();
    pTaskMgr->LogStats();
    
    return 0;
}

DWORD cmd_cal(const char **argv, DWORD argc)
{
    if(argc > 1)
    {
        const char *pszCategoryName = argv[1];
        DWORD dwEnable = strtoul(argv[2], NULL, 10); 
        Logging::Category *pCategory;

        if(Console::GetInstance().GetLoggingCategory(pszCategoryName, &pCategory))
        {
            if(argc > 2)
            {
                printf("Changing [%s] enable level: %u -> %u\n",
                        pszCategoryName,
                        pCategory->GetEnableLevel(),
                        dwEnable);

                pCategory->SetEnableLevel(dwEnable);
            }
            else
            {
                printf("Category [%s] enable level: %u\n",
                        pszCategoryName,
                        pCategory->GetEnableLevel());
            }
        }
    }
    else
    {
        printf("usage: cal <logcategory> <leve>\n");
    }

    return 0;
}

DWORD cmd_tset(const char **argv, DWORD argc)
{
    if(argc < 3)
    {
        printf("usage: tset <taskexpr> <'tps'|'enable'> <newvalue>\n");
    }

    const CVPtrArray &TaskPacing = pTaskMgr->GetTaskSchedule();

    for(DWORD i = 0, c = TaskPacing.GetSize(); i < c; ++i)
    {
        XPQTaskPacing *pTaskPacing = 0;
        XPQTask *pTask = 0;

        if(TaskPacing.GetAt(i, (void**)&pTaskPacing))
        {
            pTask = pTaskPacing->Task();

            if(strstr(pTask->Name(), argv[1]))
            {
                if(!_stricmp("tps", argv[2]))
                {
                    char *pend;
                    double dDesiredTPS = strtod(argv[3], &pend);
                    if(pend && *pend)
                    {
                        printf("Invalid character at: %s\n", pend);
                    }

                    if(dDesiredTPS < 0)
                    {
                        printf("Desired TPS of %.2f is invalid, use the enable setting for turning off a task\n",
                                dDesiredTPS);
                    }
                    else
                    {
                        printf("Changing [%s] desired TPS: %.2f -> %.2f\n", 
                                pTask->Name(), 
                                pTaskPacing->DesiredTPS(),
                                dDesiredTPS);
                        pTaskPacing->SetDesiredTPS(dDesiredTPS);
                    }
                }
                else if(!_stricmp("enable", argv[2]))
                {
                    if(!_stricmp("yes", argv[3]) || !_stricmp("true", argv[3]))
                    {
                        pTaskPacing->SetEnabled(true);
                        printf("Enabled [%s]\n", 
                                pTask->Name());
                    }
                    else
                    {
                        pTaskPacing->SetEnabled(false);
                        printf("Disabled [%s]\n", 
                                pTask->Name());
                    }
                }
                else if(!_stricmp("trace", argv[2]))
                {
                    if(!_stricmp("yes", argv[3]) || !_stricmp("true", argv[3]))
                    {
                        pTaskPacing->SetTracing(true);
                        printf("Enabled tracing [%s]\n", pTask->Name());
                    }
                    else
                    {
                        pTaskPacing->SetTracing(false);
                        printf("Disabled tracing [%s]\n", pTask->Name());
                    }
                }
				else if(!_stricmp("SendToINH", argv[2]))
                {
                    if(!_stricmp("yes", argv[3]) || !_stricmp("true", argv[3]))
                    {
                        pTask->SetSendToINH(true);
                        printf("Send to INH [%s]\n", 
                                pTask->Name());
                    }
                    else
                    {
                        pTask->SetSendToINH(false);
                        printf("Send to FD [%s]\n", 
                                pTask->Name());
                    }
                }
                else if(!_stricmp("timeout", argv[2]))
                {
                    char *pend;
                    DWORD dwTimeout = strtoul(argv[3], &pend, 10);
                    if(pend && *pend)
                    {
                        printf("Invalid character at: %s\n", pend);
                    }

                    if(dwTimeout == 0)
                    {
                        printf("Desired timeout of %u is invalid\n",
                                dwTimeout);
                    }
                    else
                    {
                        printf("Changing [%s] timeout millis: %u -> %u\n", 
                                pTask->Name(), 
                                pTask->Timeout(),
                                dwTimeout);
                        pTask->SetTimeout(dwTimeout);
                    }
                }
            }
        }
    }

    return 0;
}

void print_task(XPQTaskPacing *pTaskPacing, XPQTask *pTask, bool bDetails)
{
    if(bDetails)
    {
        printf("-- Task: [%s]\n"
            "  Enabled:           [%s]\n"
            "  Tracing:           [%s]\n"
            "  Timeout:           [%ums]\n"
            "  Tps (Cur/Tgt):     [%.2f/%.2f]\n"
            "  SchRate (Avg/Max): [%.2f/%.2f]\n"
            "  Time (Avg/Max):    [%.2f/%.2f]\n"
            "  Rtt (Avg/Max):     [%.2f/%.2f]\n"
            "  Active:            [%g]\n"
            "  Sch/Err/Stv/To:    [%g] [%g] [%g] [%g]\n",
    
            pTask->Name(),
            pTaskPacing->Enabled() ? "true" : "false",
            pTask->Tracing() ? "true" : "false",
            pTask->Timeout(),
            pTaskPacing->ActualTPS(), pTaskPacing->DesiredTPS(),
            pTaskPacing->AvgScheduled.fAverage, pTaskPacing->AvgScheduled.fMax,
            pTaskPacing->AvgElapsed.fAverage, pTaskPacing->AvgElapsed.fMax,
            pTaskPacing->AvgRTT.fAverage, pTaskPacing->AvgRTT.fMax,
            pTaskPacing->Scheduled.fInstance - pTaskPacing->Completed.fInstance,
            pTaskPacing->Scheduled.fInstance,
            pTaskPacing->ServerErrors.fInstance,
            pTaskPacing->Starved.fInstance,
            pTaskPacing->Timeouts.fInstance);
    }
    else
    {
        printf("Task: %c[%32s] Tps: [%4.2f/%4.2f] Active: [%g] Errors: [%g] Starved: [%g] Timeouts [%g]\n",
            pTaskPacing->Enabled() ? '+' : '-',
            pTask->Name(),
            pTaskPacing->ActualTPS(), pTaskPacing->DesiredTPS(),
            pTaskPacing->Scheduled.fInstance - pTaskPacing->Completed.fInstance,
            pTaskPacing->ServerErrors.fInstance,
            pTaskPacing->Starved.fInstance,
            pTaskPacing->Timeouts.fInstance);
    }
}

void print_task_errors(XPQTaskPacing *pTaskPacing, XPQTask *pTask)
{
    printf("[%32s]: Failed: %g\n%",
            pTask->Name(),
            pTaskPacing->ServerErrors.fInstance);
    printf("  [0x%08x] [0x%08x] [0x%08x] [0x%08x]\n",
            pTaskPacing->ErrorLog[0],
            pTaskPacing->ErrorLog[1],
            pTaskPacing->ErrorLog[2],
            pTaskPacing->ErrorLog[3]);
    printf("  [0x%08x] [0x%08x] [0x%08x] [0x%08x]\n",   
            pTaskPacing->ErrorLog[4],
            pTaskPacing->ErrorLog[5],
            pTaskPacing->ErrorLog[6],
            pTaskPacing->ErrorLog[7]);
}

DWORD cmd_errors(const char **argv, DWORD argc)
{
    const CVPtrArray &TaskPacing = pTaskMgr->GetTaskSchedule();
    for(DWORD i = 0, c = TaskPacing.GetSize(); i < c; ++i)
    {
        XPQTaskPacing *pTaskPacing = 0;
        XPQTask *pTask;

        if(TaskPacing.GetAt(i, (void**)&pTaskPacing))
        {
            pTask = pTaskPacing->Task();
            if(argc > 1)
            {
                if(strstr(pTask->Name(), argv[1]))
                {
                    print_task_errors(pTaskPacing, pTask);  
                }
            }
            else
            {
                print_task_errors(pTaskPacing, pTask);
            }
        }
    }
    return 0;
}

void print_tasks(const char *pszName, bool bDetails)
{
    const CVPtrArray &TaskPacing = pTaskMgr->GetTaskSchedule();

    for(DWORD i = 0, c = TaskPacing.GetSize(); i < c; ++i)
    {
        XPQTaskPacing *pTaskPacing = 0;
        XPQTask *pTask = 0;

        if(TaskPacing.GetAt(i, (void**)&pTaskPacing))
        {
            pTask = pTaskPacing->Task();
            
            if(0 != pszName)
            {
                if(strstr(pTask->Name(), pszName))
                {
                    print_task(pTaskPacing, pTask, bDetails); 
                }
            }
            else
            {
                print_task(pTaskPacing, pTask, bDetails);
            }
        }
    }
}

DWORD cmd_tget(const char **argv, DWORD argc)
{
    if(argc > 1)
    {
        print_tasks(argv[1], false);
    }
    else
    {
        print_tasks(NULL, false);
    }
    return 0;
}

DWORD cmd_tget_details(const char **argv, DWORD argc)
{
    if(argc > 1)
    {
        print_tasks(argv[1], true);
    }
    else
    {
        print_tasks(NULL, true);
    }
    return 0;
}


DWORD cmd_tpending(const char **argv, DWORD argc)
{
    DWORD dwInProgressMillis = 30000;

    if(argc > 1)
    {
        dwInProgressMillis = strtoul(argv[1], NULL, 10);
    }

    gpTaskMgr->LogTasksInProgress(dwInProgressMillis);

    return 0;
}

DWORD cmd_treset(const char **argv, DWORD argc)
{
    const CVPtrArray &TaskPacing = pTaskMgr->GetTaskSchedule();
    for(DWORD i = 0, c = TaskPacing.GetSize(); i < c; ++i)
    {
        XPQTaskPacing *pTaskPacing = 0;
        XPQTask *pTask = 0;

        if(TaskPacing.GetAt(i, (void**)&pTaskPacing))
        {
            pTaskPacing->Scheduled.Clear();
            pTaskPacing->Completed.Clear();
            pTaskPacing->Starved.Clear();
            pTaskPacing->Yielded.Clear();
            pTaskPacing->ServerErrors.Clear();
            pTaskPacing->ClientErrors.Clear();
			pTaskPacing->AvgScheduled.Clear();
            pTaskPacing->AvgElapsed.Clear();
            pTaskPacing->AvgRTT.Clear();
        }
    }

    return 0;
}

DWORD cmd_showuser(const char **argv, DWORD argc)
{
    if(argc < 2)
    {
        printf("usage: showuser <puid>\n");
        return -1;
    }
    

    ULONGLONG qwUserId = ParsePuid(argv[1]);
    XPQUser *pUser = gpUserMgr->UserPtrFromId(qwUserId);

    if(0 == pUser)
    {
        printf("could not find user: %I64x\n", qwUserId);
        return -1;
    }

    printf("User: %I64x '%s'\n", pUser->UserId(), pUser->Name());
    printf("  State:        %08x\n", pUser->State());
    printf("  PoolFlags:    %08x\n", pUser->GetPoolFlags());
    printf("  Spi:          %08x\n", pUser->Spi());
    printf("  TitleId:      %08x\n", pUser->TitleId());
    printf("  IsXenon:      %s\n", pUser->IsXenonTitleId() ? "YES" : "NO");
    printf("  UserFlags:    %08x\n", pUser->UserFlags());
    printf("  MatchId:      %I64x\n", pUser->MatchId());
    printf("  MatchExpire:  %u\n", pUser->MatchExpire() ? pUser->MatchExpire() - GetTickCount() : 0);

    printf("  TitleDatalen: %u\n", pUser->TitleDataLen());
    printf("  LastUsed:     %u\n", GetTickCount() - pUser->GetLastInuseTime());
    printf("  TouchCount:   %u\n", pUser->GetTouchCount());

    return 0;
}

DWORD cmd_setxepct(const char **argv, DWORD argc)
{
    if(argc < 2)
    {
        printf("usage: setxepct <1-100>\n");
        return -1;
    }

    DWORD dwPercentage = strtoul(argv[1], NULL, 10);
    if(dwPercentage > 100)
    {
        dwPercentage = 100;
    }

    gpUserMgr->SetXenonPercentage(dwPercentage);

    printf("updated allowed xenon online percentage %u\n", dwPercentage);

    return 0;
}

DWORD cmd_setucspct(const char **argv, DWORD argc)
{
    if(argc < 2)
    {
        printf("usage: setucspct <1-100>\n");
        return -1;
    }

    DWORD dwPercentage = strtoul(argv[1], NULL, 10);
    if(dwPercentage > 100)
    {
        dwPercentage = 100;
    }

    gpUserMgr->SetStateBitsUnchangedPercentage(dwPercentage);

    printf("updated percentage when state updates contains identical state bits %u\n", dwPercentage);

    return 0;
}

DWORD cmd_sgsenddelay(const char **argv, DWORD argc)
{
    if(argc < 2)
    {
        printf("usage: sgsenddelay <millis>\n");
        return -1;
    }

    DWORD dwSendDelay = strtoul(argv[1], NULL, 10);
    gpConnMgr->SetSGSendDelay(dwSendDelay);

    printf("set sg send delay to %u\n", dwSendDelay);

    return 0;
}


DWORD cmd_setrecvto(const char **argv, DWORD argc)
{
    if(argc < 2)
    {
        printf("usage: setrecvto <millis>\n");
        return -1;
    }

    DWORD dwMillis = strtoul(argv[1], NULL, 10);
    FdConnection::SetReceiveTimeout(dwMillis);

    printf("updated fdconn receive timeout: %u\n", dwMillis);

    return 0;
}

DWORD cmd_setsendto(const char **argv, DWORD argc)
{
    if(argc < 2)
    {
        printf("usage: setsendto <millis>\n");
        return -1;
    }

    DWORD dwMillis = strtoul(argv[1], NULL, 10);
    FdConnection::SetReceiveTimeout(dwMillis);

    printf("updated fdconn send timeout: %u\n", dwMillis);

    return 0;
}

DWORD cmd_addtrace(const char **argv, DWORD argc)
{
    if(argc < 2)
    {
        printf("usage: addtrace <puid>\n");
        return -1;
    }

    QWORD qwUserPuid = ParsePuid(argv[1]);
    XPQUser *pUser = gpUserMgr->UserPtrFromId(qwUserPuid);
    if(0 == pUser)
    {
        printf("user: 0x%I64x was not recognized by the user manager. check your puid range\n");
    }
    else
    {
        XPQUserMgr::AddUserTrace(pUser);
        printf("added user 0x%I64x to the user manager tracer\n", pUser->UserId());
    }

    return 0;
}


DWORD cmd_remtrace(const char **argv, DWORD argc)
{
    if(argc < 2)
    {
        printf("usage: remtrace <index>\n");
        return -1;
    }

    DWORD dwTraceIndex = strtoul(argv[1], NULL, 10);    
    if(!XPQUserMgr::RemoveUserTrace(dwTraceIndex))
    {
        printf("failed to remove trace index: %u\n", dwTraceIndex);
    }
    else
    {
        printf("succefully removed trace index: %u\n", dwTraceIndex);
    }
     
    return 0;
}

DWORD cmd_showtraces(const char **argv, DWORD argc)
{
    XPQUserMgr::ShowUserTraces();

    return 0;
}

DWORD cmd_kickonerror(const char **argv, DWORD argc)
{
    if(argc < 2)
    {
        printf("usage: kickonerror <true|false>\n");
        return -1;
    }

    bool bKickOnError = argv[1][0] == 't' || argv[1][0] == 'y';
    gpUserMgr->SetKickOnError(bKickOnError);

    printf("set user manager kick on error to: %s\n", bKickOnError ? "true" : "false");

    return 0;
}

DWORD cmd_stateticks(const char **argv, DWORD argc)
{
    if(argc < 3)
    {
        printf("usage: stateticks <bucketname> <ticks>\n");
        return -1;
    }

    const char *pszBucketName = argv[1];
    DWORD dwBucketId = USERPOOL_MAX_ID;
    for(DWORD i = 0; i < USERPOOL_MAX_ID; ++i)
    {
        if(!_stricmp(rgszBucketNames[i], pszBucketName))
        {
            dwBucketId = i;
            break;
        }
    }
    
    if(USERPOOL_MAX_ID == dwBucketId)
    {
        printf("invalid bucket name: %s\n", pszBucketName);
        return -1;
    }

    DWORD dwMaxTicks = strtoul(argv[2], NULL, 10); 
    if(0 == dwMaxTicks)
    {
        printf("invalid expiration ticks: %u\n", dwMaxTicks);
        return -1;
    }

    DWORD dwOldTicks = gpUserMgr->SetStateExpirationTicks(dwBucketId, dwMaxTicks);

    printf("set timeout for state type: %s from %u -> %u\n", 
            rgszBucketNames[dwBucketId],
            dwOldTicks,
            dwMaxTicks);

    return 0;
}

DWORD cmd_disableqvals(const char **argv, DWORD argc)
{
    if(argc < 2)
    {
        printf("usage: delayqval <ticks>\n");
        return -1;
    }

    bool bDisable = argv[1][0] == 't' || argv[1][0] == 'y';
    gpConnMgr->SetDisableQVals(bDisable);

    printf("set qval disable to %s\n", bDisable ? "true" : "false");

    return 0;
}

DWORD cmd_help(const char **argv, DWORD argc)
{
    printf("Commands:\n");

    for(DWORD i = 0; i < sizeof(rgCommands)/sizeof(rgCommands[0]); ++i)
    {
        printf(" %-20s - %s\n", rgCommands[i].szName, rgCommands[i].szDesc);
    }
     
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\INHConnection.cpp ===
#include "stdafx.h"

INHConnection::INHConnection() : BasePresenceConnection(INHCONNECTION)
{
}

HRESULT INHConnection::Init()
{
	HRESULT hr;

	// Create the main switchboard object
    m_pCSwitchboard = new CSwitchboard;
    if( NULL == m_pCSwitchboard )
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_82, "Unrecoverable failure while initializing: Failed to allocate switchboard");
        hr = E_OUTOFMEMORY;
        goto lbDone;
    }

    hr = m_pCSwitchboard->Init();
    if( FAILED( hr ) )
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_83, "Unrecoverable failure while initializing: Failed to init switchboard hr=0x%X", hr);
        goto lbDone;
    }

lbDone:
	return hr;
}

void INHConnection::Heartbeat()
{
	m_pCSwitchboard->OnHeartbeat();
}

void INHConnection::Attach(CompletionPort* pCP)
{
	m_pCP = pCP;
}

HRESULT INHConnection::SendDequeue(  
    XPQTask*      pTask,
    XPQUser*      pUser, 
    P_QUEUE_TYPES eQType)
{
    HRESULT hr = S_OK;

    // Setup message
    XQMsgDequeue *msgDequeue = new XQMsgDequeue( gpConnMgr->GetDefSgAddr() );
    msgDequeue->SetUserId( pUser->UserId() );
    msgDequeue->SetXboxId( pUser->XboxId() );
    msgDequeue->SetSpi( pUser->Spi() );
    msgDequeue->SetQType( eQType );
    msgDequeue->SetMaxTotalItemDataSize( 2048 - sizeof( Q_LIST_REPLY_MSG ) );
   
	// context will own the message memory
	CRequestContext *request = new CRequestContext(msgDequeue);
	request->Init(pTask, pUser, m_pCSwitchboard, m_pCP);

	// Queue to Switchboard
	m_pCSwitchboard->PostCompletion(request);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\MsgBuilder.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2002 Microsoft.  ALL RIGHTS RESERVED
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"



///////////////////////////////////////////////////////////
//  XPQ Msg Hdr
///////////////////////////////////////////////////////////

// Static Sequence Number
__declspec(align(32)) DWORD g_dwNextSeqNum = 1;

// Added to http User Agent
char* g_pszClientVer = ".5936";


//------------------------------------------------------------------------------
// Write a HTTP header for the given message type and payload size
//------------------------------------------------------------------------------
HRESULT WriteHttpHeader( 
        DWORD dwSPI,
        bool  bHttpAuth,
        BYTE* pbDestBuffer, 
        DWORD cbDestBuffer, 
        DWORD dwMsgType, 
        DWORD dwPayloadSize, 
        DWORD *pdwHeaderLen)
{
    HRESULT hr;
    DWORD dwHeaderLen;

    if(0 == pbDestBuffer || 0 == cbDestBuffer || 0 == pdwHeaderLen)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    *pdwHeaderLen = 0;

    // Use Msg Type to Select propper http header values
    char* pszServer = "";
    char* pszUri = "/xpnfront/";
    DWORD dwService = 0;
    switch( dwMsgType )
    {
        // Skip HTTP header on INH messages
        case PMSG_HELLO:
        case QMSG_HELLO:
        case PMSG_DEAD_SG:
        case QMSG_DEAD_SG:
            goto lbDone;

        case PMSG_ALIVE:
        case PMSG_ALIVE_2:
        case PMSG_ADD:
        case PMSG_ADD_2:
        case PMSG_DELETE:
        case PMSG_ACCEPT:
        case PMSG_REJECT:
        case PMSG_BLOCK:
        case PMSG_UNBLOCK:
        case PMSG_INVITE:
        case PMSG_INVITE_2:
        case PMSG_CANCEL:
        case PMSG_INVITE_ANSWER:
        case PMSG_NICKNAME:
        case PMSG_STATE:
        case PMSG_STATE_2:
        case PMSG_DEAD_USER:
        case PMSG_WEB_FRIENDS:
        case PMSG_PEER_SESSION:
        case PMSG_PEER_SUBSCRIBE:
        case PMSG_PEER_SUBSCRIBE_EX:
		case PMSG_PEER_UNSUBSCRIBE:
        case PMSG_ADD_AFFILIATES:
        case PMSG_IS_AFFILIATE:
        case PMSG_QUERY_AFFILIATES:
        case PMSG_GET_PRESENCE_INFO:
        case PMSG_INVALIDATE_USER:
        case PMSG_FIND_USER:
		case PMSG_FIND_USERS:
        case PMSG_CHECK_TITLE_MESSAGES:
        case PMSG_GET_FRIENDS_LIST:
            pszServer = "xpresence.srf";
            dwService = XONLINE_PRESENCE_SERVICE;
            break;
        case PMSG_TEAM_LIST_TEAMS:
        case PMSG_TEAM_LIST_MEMBERS:
        case PMSG_TEAM_CREATE:
        case PMSG_TEAM_DELETE:
        case PMSG_TEAM_REMOVE:
        case PMSG_TEAM_MANAGE_TEAM:
        case PMSG_TEAM_MANAGE_MEMBER:
        case PMSG_TEAM_RECRUIT:
        case PMSG_TEAM_JOIN:
        case PMSG_TEAM_GET_TICKET:
        case PMSG_TEAM_LIST_USER_TEAMS:
            pszServer = "xteams.srf";
            dwService = XONLINE_TEAM_SERVICE;
            break;
        case QMSG_DEQUEUE:
            pszServer = "xnotification.srf";
            dwService = XONLINE_PRESENCE_SERVICE;
            break;
        case QMSG_ENUM_MESSAGES:
        case QMSG_MESSAGE_SUMMARY:
        case QMSG_MESSAGE_DETAILS:
        case QMSG_DELETE_MESSAGE:
        case QMSG_SEND_MESSAGE:
        case QMSG_REVOKE_MESSAGE:
        case QMSG_DELETE_TITLE:
        case QMSG_ENUM_TITLES:
        case QMSG_MESSAGE_FLAGS:
        case QMSG_ENUM_SYSTEM_MESSAGES:
        case QMSG_SYSTEM_MESSAGE_DETAILS:
        case QMSG_DELETE_SYSTEM_MESSAGE:
        case QMSG_SEND_SYSTEM_MESSAGE:
        case QMSG_REVOKE_MESSAGE_EX:
        case QMSG_ENUM_MESSAGES_2:
        case QMSG_MESSAGE_SUMMARY_2:
            pszServer = "xmessaging.srf";
            dwService = XONLINE_MESSAGING_SERVICE;
            break;
        case SGMSG_TYPE_NOTIFY_CLI_UPD:
            pszServer = "state.ashx";
            dwService = XONLINE_PRESENCE_SERVICE;
            break;
        case MSG_ECHO:
            pszUri    = "/xnull/";
            pszServer = "xnull.asmx";
            dwService = XONLINE_PRESENCE_SERVICE;
            break;
        default:
            _ASSERTE( !"Invalid Message Type" );
            hr = E_INVALIDARG;
            goto lbDone;
    }

    
    if(bHttpAuth)
    {
        XPQSlotInfo slot;

        // Lookup the slot data
        if(FAILED(hr = gpConnMgr->GetSlotInfo(dwSPI, slot)))
        {
            goto lbDone;
        }

        // Create the http auth data
        BYTE szHttpAuthHeader[((((sizeof(XPQHttpAuthData)+2)/3)*4)+1)];
        XPQHttpAuthData authData;
        authData.Initialize(slot);

        _ASSERTE(0 != authData.wLanguageID);
        _ASSERTE(0 != authData.rgXUIDs[0].dwUserFlags);

        if(FAILED(hr = Base64Encode(
                (BYTE*)&authData, 
                sizeof(XPQHttpAuthData), 
                szHttpAuthHeader,
                sizeof(szHttpAuthHeader))))
        {
            goto lbDone;
        }

        _ASSERTE(INVALID_SPI != dwSPI);

        dwHeaderLen = (DWORD)_snprintf( (char*)pbDestBuffer,
                cbDestBuffer,
                "POST %s%s HTTP/1.0\r\n"
				//"Host: www.xbox.com\r\n" // HTTP/1.1
                "User-Agent: %x/1.00%s\r\n"
                "Content-Length: %lu\r\n"
                "Content-Type: xon/%x\r\n"
                "HTTPAuthData: %s\r\n"
                "\r\n",
                pszUri,
                pszServer,
                dwService,
                (g_pszClientVer != NULL) ? g_pszClientVer : "",
                dwPayloadSize,
                dwService,
                szHttpAuthHeader);
    }
    else
    {
        dwHeaderLen = (DWORD)_snprintf( (char*)pbDestBuffer,
                cbDestBuffer,
                "POST %s%s HTTP/1.0\r\n"
				//"Host: www.xbox.com\r\n"  // HTTP/1.1
                "User-Agent: %x/1.00%s\r\n"
                "Content-Length: %lu\r\n"
                "Content-Type: xon/%x\r\n"
                "\r\n",
                pszUri,
                pszServer,
                dwService,
                (g_pszClientVer != NULL) ? g_pszClientVer : "",
                dwPayloadSize,
                dwService );
    }

    *pdwHeaderLen = dwHeaderLen;

    hr = S_OK;

lbDone:
    return hr;
}


///////////////////////////////////////////////////////////
//  XP Msg Alive
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XPMsgAlive::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg, 
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_acAcctNameBuf, 
                    m_Msg.cbAcctName,
                    m_abTitleDataBuf, 
                    m_Msg.cbTitleStuff,
                    m_abNicknameBuf,
                    m_Msg.cbNickname,
                    pbMsgBuff,
                    dwBufLen,
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}


///////////////////////////////////////////////////////////
//  XP Msg Alive 2
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XPMsgAlive2::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg, 
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_acAcctNameBuf,
                    m_Msg.cbAcctName,
                    pbMsgBuff,
                    dwBufLen,
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}


///////////////////////////////////////////////////////////
//  XP Msg Add
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XPMsgAdd::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg,
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_acBuddyAcctNameBuf,
                    m_Msg.cbBuddyAcctname,
                    pbMsgBuff,
                    dwBufLen,
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}

///////////////////////////////////////////////////////////
//  XP Msg Add 2
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XPMsgAdd2::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg,
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_abDetails,
                    m_Msg.cbDetails,
                    pbMsgBuff,
                    dwBufLen, 
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}


///////////////////////////////////////////////////////////
//  XP Msg FindUsers
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XPMsgFindUsers::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg,
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_FindUsersData,
                    m_Msg.cdwQueries * sizeof( P_FIND_USERS_DATA ),
                    pbMsgBuff,
                    dwBufLen, 
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}

///////////////////////////////////////////////////////////
//  XP Msg Invite
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XPMsgInvite::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg,
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_aqwInvitees,
                    m_Msg.cInvitees * sizeof( ULONGLONG ),
                    pbMsgBuff,
                    dwBufLen, 
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}

///////////////////////////////////////////////////////////
//  XP Msg Invite 2
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XPMsgInvite2::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg,
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_aqwInvitees,
                    m_Msg.cInvitees * sizeof( ULONGLONG ),
                    (BYTE*)m_abDetails,
                    m_Msg.cbDetails,
                    pbMsgBuff,
                    dwBufLen, 
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}

///////////////////////////////////////////////////////////
//  XP Msg Cancel Invite
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XPMsgCancelInvite::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg,
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_aqwInvitees,
                    m_Msg.cInvitees * sizeof( ULONGLONG ),
                    pbMsgBuff,
                    dwBufLen,
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}


///////////////////////////////////////////////////////////
//  XP Msg Nickname
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XPMsgNickName::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg,
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    m_abNicknameBuf,
                    m_Msg.cbNickname,
                    pbMsgBuff,
                    dwBufLen,
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}


///////////////////////////////////////////////////////////
//  XP Msg State
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XPMsgState::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData(
                    &m_Msg,
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    m_abTitleDataBuf,
                    m_Msg.cbTitleStuff,
                    pbMsgBuff,
                    dwBufLen,
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}


///////////////////////////////////////////////////////////
//  XP Msg Peer Subscribe
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XPMsgPeerSubscribe::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg,
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_aqwSrcUserIDs,
                    m_Msg.cSrcUserIDs * sizeof( ULONGLONG ),
                    pbMsgBuff,
                    dwBufLen, 
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}

///////////////////////////////////////////////////////////
//  XP Msg Peer Subscribe
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XPMsgPeerSubscribeEx::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg,
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_aqwSrcUserIDs,
                    m_Msg.cUserIDs * sizeof( ULONGLONG ),
                    pbMsgBuff,
                    dwBufLen, 
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}

///////////////////////////////////////////////////////////
//  XP MsgAddAffiliates
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XPMsgAddAffiliates::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg,
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_aqwAffiliateIDs,
                    m_Msg.cwAffiliates * sizeof( ULONGLONG ),
                    pbMsgBuff,
                    dwBufLen,
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}

DWORD XPMsgGetPresenceInfo::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData(
                    &m_Msg,
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)&m_qwTargetId,
                    m_Msg.cdwUsers * sizeof( ULONGLONG ),
                    pbMsgBuff, 
                    dwBufLen,
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}

///////////////////////////////////////////////////////////
//  XT Msg List Teams
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XTMsgListTeams::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg,
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_aqwTeamIds,
                    m_Msg.cTeamIDs * sizeof( ULONGLONG ),
                    pbMsgBuff,
                    dwBufLen,
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}

///////////////////////////////////////////////////////////
//  XT Msg Team Create
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XTMsgTeamCreate::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg, 
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_wszTeamName,
                    m_Msg.cbTeamName,
                    (BYTE*)m_wszTeamDescription,
                    m_Msg.cbTeamDescription,
                    (BYTE*)m_wszTeamMotto,
                    m_Msg.cbTeamMotto,
                    (BYTE*)m_wszTeamURL,
                    m_Msg.cbTeamURL,
                    m_pbTeamData,
                    m_Msg.cbTeamData,
                    m_pbCreatorData,
                    m_Msg.cbCreatorData,
                    pbMsgBuff,
                    dwBufLen,
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}

///////////////////////////////////////////////////////////
//  XT Msg Team Manage Team
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XTMsgTeamManageTeam::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg, 
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_wszTeamName,
                    m_Msg.cbTeamName,
                    (BYTE*)m_wszTeamDescription,
                    m_Msg.cbTeamDescription,
                    (BYTE*)m_wszTeamMotto,
                    m_Msg.cbTeamMotto,
                    (BYTE*)m_wszTeamURL,
                    m_Msg.cbTeamURL,
                    m_pbTeamData,
                    m_Msg.cbTeamData,
                    pbMsgBuff,
                    dwBufLen,
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );    
}


///////////////////////////////////////////////////////////
//  XT Msg Team Manage Member
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XTMsgTeamManageMember::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData(
                    &m_Msg, 
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    m_pbMemberData,
                    m_Msg.cbMemberData,
                    pbMsgBuff,
                    dwBufLen,
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}

///////////////////////////////////////////////////////////
//  XT Msg Team Recruit
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XTMsgTeamRecruit::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg, 
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    m_abDetails,
                    m_Msg.cbDetails,
                    m_pbMemberData,
                    m_Msg.cbMemberData,
                    pbMsgBuff,
                    dwBufLen,
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}

///////////////////////////////////////////////////////////
//  XQMsg Send Message
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XQMsgSendMessage::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg, 
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_aqwRecipients,
                    m_Msg.cRecipients * sizeof( *m_aqwRecipients ),
                    m_abDetails,
                    m_Msg.cbDetails,
                    pbMsgBuff,
                    dwBufLen,
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}


///////////////////////////////////////////////////////////
//  XQMsg Revoke Message
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XQMsgRevokeMessage::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg, 
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_aRecipients,
                    m_Msg.cRecipients * sizeof( *m_aRecipients ),
                    pbMsgBuff,
                    dwBufLen,
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}

///////////////////////////////////////////////////////////
//  XQMsg Revoke Message
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XQMsgRevokeMessageEx::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg, 
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    (BYTE*)m_rgRecipients, 
                    m_Msg.cRecipients * sizeof( m_rgRecipients[0] ),
                    m_rgbProp, 
                    m_Msg.cbProp,
                    pbMsgBuff, 
                    dwBufLen, 
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}

///////////////////////////////////////////////////////////
//  XQMsg Send System Message
///////////////////////////////////////////////////////////

///////////////////////////////////////
// Dump Msg
//
DWORD XQMsgSendSystemMessage::DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
{
    SetNextSeqNum();

    DWORD dwDumped;
    if( FAILED( WriteMsgData( 
                    &m_Msg, 
                    m_Msg.sgaddr.dwSpiSg,
                    m_bHttpAuth,
                    m_abDetails,
                    m_Msg.cbDetails,
                    pbMsgBuff,
                    dwBufLen,
                    &dwDumped ) ) )
    {
        dwDumped = 0L;
    }

    return( dwDumped );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\pconn.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

#define PCONN_HELLO_DESC "XPNFD"
#define PCONN_HELLO_DESC_LEN sizeof(PCONN_HELLO_DESC)

/*****************************************************************************

CompareUsersByPresDest

Compare user pointers by destination presence server.  
Used by the bsearch and qsort libary routines.

*****************************************************************************/
static int __cdecl CompareUsersByPresDest( const void *pCLeft, const void *pCRight )
{
    int iDestLeft = (int) g_CPresCfg.MapUserToPresSrv(*((const QWORD *)pCLeft));
    int iDestRight = (int) g_CPresCfg.MapUserToPresSrv(*(const QWORD *)pCRight);

    return iDestRight - iDestLeft;
}

/*****************************************************************************

CPresConnection::CPresConnection

Constructor

*****************************************************************************/
CPresConnection::CPresConnection() :
    m_pCompPort(NULL),
    m_pCallback(NULL),
    m_pCSwitchboard(NULL)
{
    memset(&m_sa, 0, sizeof(sockaddr_in));
}

/*****************************************************************************

CPresConnection::~CPresConnection

Destructor

*****************************************************************************/
CPresConnection::~CPresConnection()
{
    SAFE_RELEASE(m_pCSwitchboard);
    SAFE_RELEASE(m_pCompPort);
}

/*****************************************************************************

CPresConnection::Init

Initializer, must be called before first use.

*****************************************************************************/
HRESULT CPresConnection::Init(
    sockaddr_in *pAddr,
    CCompletionPort *pCompPort,
    CPresConnectionCallback *pCallback,
    CSwitchboard *pCSwitchboard)
{
    HRESULT hr = S_OK;
    CServerSocket *pSock = NULL;

    // Validate arguments
    if((NULL == pCompPort) || 
       (NULL == pAddr) || 
       (NULL == pCallback))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }
    
    // Set references
    XOMASSERT(NULL == m_pCallback);
    m_pCallback = pCallback;

    XOMASSERT(NULL == m_pCompPort);
    pCompPort->AddRef();
    m_pCompPort = pCompPort;

    XOMASSERT(NULL == m_pCSwitchboard);
    m_pCSwitchboard = pCSwitchboard;
    pCSwitchboard->AddRef();

    // Store off the destination address for future use
    memcpy(&m_sa, pAddr, sizeof(sockaddr_in));

    // Create a new TCP socket for use by this connection
    hr = CServerSocket::CreateInstance(&pSock, pCompPort, pCompPort);
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_51, "CPresConnection::Init failed to create CServerSocket instance (%X)", hr);
        goto lDone;
    }

    // Bind it to a local address
    sockaddr_in saBind;
    memset(&saBind, 0, sizeof(saBind));

    saBind.sin_family = AF_INET;

    hr = pSock->Init( IPPROTO_TCP, &saBind, FALSE );
    if( FAILED( hr ) )
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_52, "CPresConnection::Init failed to init CServerSocket object (%X)", hr);
        goto lDone;
    }
    
    // Start the connecting process
    hr = AttachAndConnect(pSock, pAddr);
    if(FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CONFIG_53,
            "CPresConnection::Init failed to initiate connect for server @ %s:%d (%X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port ),
            hr);
        goto lDone;
    }

lDone:

    SAFE_RELEASE( pSock );
    
    return hr;
}

/*****************************************************************************

CPresConnection::SendMsgHello

Sends a Hello message.

*****************************************************************************/
HRESULT CPresConnection::SendMsgHello() 
{
    HRESULT hr = S_OK;
    P_HELLO_MSG *pHelloMsg = NULL;
    CTCPCntVarBuffer *pCHelloBuffer = NULL;

    // Send a hello message to the Q server (will be sent once we connect)
    pCHelloBuffer = CTCPCntVarBuffer::CreateInstance(sizeof(P_HELLO_MSG) + PCONN_HELLO_DESC_LEN);
    if (pCHelloBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pHelloMsg = (P_HELLO_MSG *) pCHelloBuffer->GetBuffer();

    pHelloMsg->dwMsgType = PMSG_HELLO;
    pHelloMsg->dwSeqNum = 0;
    pHelloMsg->sgaddr = sgaddrIgnore;
    pHelloMsg->dwProtocolVersion = CURRENT_XQPROTOCOL_VER;
    memcpy((char *)(pHelloMsg + 1), PCONN_HELLO_DESC, PCONN_HELLO_DESC_LEN);
    pHelloMsg->dwMsgLen = sizeof(P_HELLO_MSG) + PCONN_HELLO_DESC_LEN - sizeof(BASE_MSG_HEADER);

    hr = Send(pCHelloBuffer);
    if(FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CONFIG_54,
            "CPresConnection::SendMsgHello failed to send HELLO to server @ %s:%d (%X)", 
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port ),
            hr);
        goto lDone;
    }

lDone:

    SAFE_RELEASE(pCHelloBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::SendMsg

Sends a Generic message with a sequence number equal to the context id

*****************************************************************************/
HRESULT CPresConnection::SendMsg(DWORD dwContextId, BASE_MSG_HEADER *pMsgIn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCMsgBuffer = NULL;
    BASE_MSG_HEADER *pMsgOut;
    DWORD dwMsgLen;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    // Calculate the message length
    dwMsgLen = pMsgIn->dwMsgLen + sizeof(BASE_MSG_HEADER);

    // Allocate a buffer
    pCMsgBuffer = CTCPCntVarBuffer::CreateInstance(dwMsgLen);
    if (pCMsgBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pMsgOut = (BASE_MSG_HEADER *) pCMsgBuffer->GetBuffer();

    // Copy the source
    memcpy(pMsgOut, pMsgIn, dwMsgLen);

    // Set the sequence number equal to the context id
    pMsgOut->dwSeqNum = dwContextId;

    hr = Send(pCMsgBuffer);
    if(FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CONFIG_55,
            "CPresConnection::SendMsg failed to send to server @ %s:%d (%X)", 
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port ),
            hr);
        goto lDone;
    }

lDone:

    SAFE_RELEASE(pCMsgBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::OnConnect

Called by the base class when the connection completes

*****************************************************************************/
void CPresConnection::OnConnect()
{
    if (m_pCallback != NULL)
    {
        m_pCallback->OnConnect(this);
    }
    else
    {
        XOMASSERT(FALSE);
    }
}

/*****************************************************************************

CPresConnection::OnDisconnect

Called by the base class when the connection is lost

*****************************************************************************/
void CPresConnection::OnDisconnect(HRESULT hrReason ) 
{
    if (m_pCallback != NULL)
    {
        m_pCallback->OnDisconnect(this);
    }
    else
    {
        XOMASSERT(FALSE);
    }
}

/*****************************************************************************

CPresConnection::ProcessMessage

Validates the reply message type, then calls the appropriate message handler.

*****************************************************************************/
void CPresConnection::ProcessMessage(BYTE *pMsg, DWORD cbEntireMsg)
{
    BASE_MSG_HEADER *pHeader = (BASE_MSG_HEADER *)pMsg;
    CPConnReceiveContext *pCCtx = new CPConnReceiveContext(this);
    if (pCCtx == NULL)
    {
        return;
    }

    // make a buffer to hold the whole message.
    pCCtx->m_cbEntireMsg = pHeader->dwMsgLen + sizeof(BASE_MSG_HEADER);
    XOMASSERT(pCCtx->m_cbEntireMsg == cbEntireMsg);
    pCCtx->m_pMsg = new BYTE[pCCtx->m_cbEntireMsg];
    if (pCCtx->m_pMsg == NULL)
    {
        delete pCCtx;
        pCCtx = NULL;
    }
    memcpy(pCCtx->m_pMsg, pMsg, cbEntireMsg);
    m_pCSwitchboard->PostCompletion(pCCtx);
    pCCtx = NULL;
}

/*****************************************************************************

CPresConnection::ProcessPConnMessage

Validates the reply message type, then calls the appropriate message handler.

*****************************************************************************/
void CPresConnection::ProcessPConnMessage(BYTE *pMsg, DWORD cbEntireMsg)
{
    if ((m_pCSwitchboard == NULL) || (pMsg == NULL))
    {
        XOMASSERT(FALSE);
        return;
    }

// Somehow this definition was missing...
#ifndef QMSG_MIN_REPLY_TYPE
#define QMSG_MIN_REPLY_TYPE QMSG_LIST_REPLY
#endif
    
    static struct
    {
        DWORD dwMsgType;
        DWORD dwMinSize;
        MsgHandler pfnMsgHandler;
        
    }   s_MsgHandlers[1 + QMSG_MAX_REPLY_TYPE - QMSG_MIN_REPLY_TYPE] =
    {
        { QMSG_LIST_REPLY,                   sizeof(Q_LIST_REPLY_MSG),                   (MsgHandler) &CPresConnection::ProcessMsgListReply },
        { QMSG_WEB_LIST_REPLY,               sizeof(Q_WEB_LIST_REPLY_MSG),               (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { QMSG_ENUM_MESSAGES_REPLY,          sizeof(Q_ENUM_MESSAGES_REPLY_MSG),          (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { QMSG_MESSAGE_SUMMARY_REPLY,        sizeof(Q_MESSAGE_SUMMARY_REPLY_MSG),        (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { QMSG_MESSAGE_DETAILS_REPLY,        sizeof(Q_MESSAGE_DETAILS_REPLY_MSG),        (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { QMSG_DELETE_MESSAGE_REPLY,         sizeof(Q_DELETE_MESSAGE_REPLY_MSG),         (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { QMSG_SEND_MESSAGE_REPLY,           sizeof(Q_SEND_MESSAGE_REPLY_MSG),           (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { QMSG_REVOKE_MESSAGE_REPLY,         sizeof(Q_REVOKE_MESSAGE_REPLY_MSG),         (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { QMSG_DELETE_TITLE_REPLY,           sizeof(Q_DELETE_TITLE_REPLY_MSG),           (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { QMSG_ENUM_TITLES_REPLY,            sizeof(Q_ENUM_TITLES_REPLY_MSG),            (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { QMSG_MESSAGE_FLAGS_REPLY,          sizeof(Q_MESSAGE_FLAGS_REPLY_MSG),          (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { QMSG_ENUM_SYSTEM_MESSAGES_REPLY,   sizeof(Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG),   (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { QMSG_SYSTEM_MESSAGE_DETAILS_REPLY, sizeof(Q_SYSTEM_MESSAGE_DETAILS_REPLY_MSG), (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { QMSG_DELETE_SYSTEM_MESSAGE_REPLY,  sizeof(Q_DELETE_SYSTEM_MESSAGE_REPLY_MSG),  (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { QMSG_SEND_SYSTEM_MESSAGE_REPLY,    sizeof(Q_SEND_SYSTEM_MESSAGE_REPLY_MSG),    (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { QMSG_ENUM_MESSAGES_2_REPLY,        sizeof(Q_ENUM_MESSAGES_2_REPLY_MSG),        (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { QMSG_MESSAGE_SUMMARY_2_REPLY,      sizeof(Q_MESSAGE_SUMMARY_2_REPLY_MSG),      (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { QMSG_LIST_REPLY_2,                 sizeof(Q_LIST_REPLY_2_MSG),                 (MsgHandler) &CPresConnection::ProcessMsgListReply2   },
	};
    
    HRESULT hr = S_OK;
    BASE_MSG_HEADER *pMsgHeader = (BASE_MSG_HEADER *) pMsg;
    DWORD dwMsgType = pMsgHeader->dwMsgType;
   
    if((dwMsgType < QMSG_MIN_REPLY_TYPE) || (dwMsgType > QMSG_MAX_REPLY_TYPE))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CONFIG_70, 
            "Type 0x%X from server @ %s:%d", 
            dwMsgType, 
            inet_ntoa(m_sa.sin_addr), 
            ntohs(m_sa.sin_port));
        hr = E_INVALIDARG;
        goto lDone;
    }

    // Make sure we have the right table entry
    XOMASSERT(s_MsgHandlers[dwMsgType - QMSG_MIN_REPLY_TYPE].dwMsgType == dwMsgType);
    
    // Minimum size check
    if (cbEntireMsg < s_MsgHandlers[dwMsgType - QMSG_MIN_REPLY_TYPE].dwMinSize)
    {
        XomNtEvent(
            XEVENT_PRESENCE_CONFIG_71,
            "Type 0x%X from server @ %s:%d (size %d < %d)",
            dwMsgType, 
            inet_ntoa(m_sa.sin_addr), 
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            s_MsgHandlers[dwMsgType - QMSG_MIN_REPLY_TYPE].dwMinSize);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }
    
    // Run the message handler
    XOMASSERT(s_MsgHandlers[dwMsgType - QMSG_MIN_REPLY_TYPE].dwMsgType == dwMsgType);
    (this->*s_MsgHandlers[ dwMsgType - QMSG_MIN_REPLY_TYPE ].pfnMsgHandler)(
        pMsgHeader,
        cbEntireMsg );
    
lDone:

    return;
}

/*****************************************************************************

CPresConnection::ProcessMsgNotSupported

Process an unsupported message

*****************************************************************************/
void CPresConnection::ProcessMsgNotSupported(BASE_MSG_HEADER *pMsg, DWORD cbEntireMsg)
{
	HRESULT hr = S_OK;
}

/*****************************************************************************

CQueueConnection::ProcessMsgListReply

Process a List Reply message

*****************************************************************************/
void CPresConnection::ProcessMsgListReply(Q_LIST_REPLY_MSG *pMsg, DWORD cbEntireMsg)
{
    m_pCSwitchboard->ProcessMsgListReply(pMsg, cbEntireMsg);
}

/*****************************************************************************

CQueueConnection::ProcessMsgListReply2

Process a List Reply message

*****************************************************************************/
void CPresConnection::ProcessMsgListReply2(Q_LIST_REPLY_2_MSG *pMsg, DWORD cbEntireMsg)
{
    m_pCSwitchboard->ProcessMsgListReply2(pMsg, cbEntireMsg);
}

/*****************************************************************************

CXPCluster::CXPCluster

Constructor

*****************************************************************************/
CXPCluster::CXPCluster() :
    m_pCCompPort(NULL),
    m_rgCPConnInfo(NULL),
    m_pCSwitchboard(NULL)
{
}

/*****************************************************************************

CXPCluster::~CXPCluster

Destructor

*****************************************************************************/
CXPCluster::~CXPCluster()
{
    Shutdown();
}

/*****************************************************************************

CXPCluster::Init

Initializer, must be called before first use.

*****************************************************************************/
HRESULT CXPCluster::Init(CCompletionPort *pCompPort, CSwitchboard *pCSwitchboard)
{
    HRESULT hr = S_OK;
    DWORD dwIndex;

    // Validate arguments
    if( NULL == pCompPort )
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // Set references to our completion port and switchboard
    XOMASSERT( NULL == m_pCCompPort );
    m_pCCompPort = pCompPort;
    m_pCCompPort->AddRef();

    XOMASSERT( NULL == m_pCSwitchboard );
    m_pCSwitchboard = pCSwitchboard;
    m_pCSwitchboard->AddRef();

    // Init our array of server connections
    m_rgCPConnInfo = new CPConnInfo[g_CPresCfg.GetNumPresServers()];
    if (m_rgCPConnInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    for (dwIndex = 0; dwIndex < g_CPresCfg.GetNumPresServers(); dwIndex++)
    {
        m_rgCPConnInfo[dwIndex].pCPresConn = NULL;
        m_rgCPConnInfo[dwIndex].fInit = TRUE;
        m_rgCPConnInfo[dwIndex].fConnected = FALSE;
        m_rgCPConnInfo[dwIndex].fAlt = FALSE;
    }

    // Connect up
    hr = AttemptConnections();

    hr = S_OK;
    
lDone:
    return hr;
}

/*****************************************************************************

CXPCluster::Shutdown

Deinitializer, must be called before first use.

*****************************************************************************/
void CXPCluster::Shutdown()
{
    SAFE_RELEASE(m_pCCompPort);
    SAFE_RELEASE(m_pCSwitchboard);

    if (m_rgCPConnInfo != NULL)
    {
        delete[] m_rgCPConnInfo;
        m_rgCPConnInfo = NULL;
    }
}

/*****************************************************************************

CXPCluster::PeriodicHeartbeat

Called periodicly on service heartbeat.  Does maintainence such as 
reattempting connections.

*****************************************************************************/
void CXPCluster::PeriodicHeartbeat()
{
    HRESULT hr;

    hr = AttemptConnections();
}

/*****************************************************************************

CXPCluster::SendMsgByUserId

Sends an message to a presence server based on user id

*****************************************************************************/
HRESULT CXPCluster::SendMsgByUserId(DWORD dwContextId, QWORD qwUserId, BASE_MSG_HEADER *pMsg)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    DWORD dwServer = 0;
 
    // Figure out what server to send to
    dwServer = g_CPresCfg.MapUserToPresSrv(qwUserId);

    // Send it
    if (m_rgCPConnInfo[dwServer].fConnected)
    {
        hr = m_rgCPConnInfo[dwServer].pCPresConn->SendMsg(dwContextId, pMsg);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
    }

    if(FAILED(hr) && (hr != HRESULT_FROM_WIN32(WSAENOTCONN)))
    {
        XomNtEvent( 
            XEVENT_PRESENCE_CONFIG_58,
            "CXPCluster::SendMsgByUserId to server %d failed hr=0x%X",
            dwServer,
            hr);
    }
            
    return hr;
}


/*****************************************************************************

CXPCluster::OnConnect

Connect callback from one of the connection objects.  Used to do bookkeeping
on the connection object array.

*****************************************************************************/
void CXPCluster::OnConnect(CPresConnection *pCConn)
{
    XOMASSERT(m_rgCPConnInfo != NULL);

    DWORD dwIndex;

    // Find the connection pointer in the array
    // CONSIDER: Pass an index to the connection object to avoid this
    dwIndex = 0;
    while (dwIndex < g_CPresCfg.GetNumPresServers()) 
    {
        if (m_rgCPConnInfo[dwIndex].pCPresConn == pCConn)
        {
            pCConn->SendMsgHello();

            // Update the bookkepping
            m_rgCPConnInfo[dwIndex].fInit = FALSE;
            m_rgCPConnInfo[dwIndex].fConnected = TRUE;
            return;
        }

        dwIndex++;
    }
}

/*****************************************************************************

CXPCluster::OnDisconnect

Drop callback from one of the connection objects.  Used to do bookkeeping
on the connection object array.

*****************************************************************************/
void CXPCluster::OnDisconnect(CPresConnection *pCConn)
{
    XOMASSERT(m_rgCPConnInfo != NULL);

    DWORD dwIndex;

    // Find the connection pointer in the array
    // CONSIDER: Pass an index to the connection object to avoid this
    dwIndex = 0;
    while (dwIndex < g_CPresCfg.GetNumPresServers()) 
    {
        if (m_rgCPConnInfo[dwIndex].pCPresConn == pCConn)
        {
            // Update the bookkepping
            SAFE_RELEASE(m_rgCPConnInfo[dwIndex].pCPresConn);
            m_rgCPConnInfo[dwIndex].fInit = FALSE;
            m_rgCPConnInfo[dwIndex].fConnected = FALSE;
            return;
        }

        dwIndex++;
    }
}

/*****************************************************************************

CXPCluster::AttemptConnections

Attempt to reestablish connections with disconnected qservers.

*****************************************************************************/
HRESULT CXPCluster::AttemptConnections()
{
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    DWORD dwIndex;

    // For each connection
    for (dwIndex = 0; dwIndex < g_CPresCfg.GetNumPresServers(); dwIndex++)
    {
        // If disconnected and not connectiong
        if (m_rgCPConnInfo[dwIndex].pCPresConn == NULL)
        {
            // Make a new connection to the designated Presence server
            m_rgCPConnInfo[dwIndex].pCPresConn = new CPresConnection;
            if(NULL == m_rgCPConnInfo[dwIndex].pCPresConn)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            if (m_rgCPConnInfo[dwIndex].fInit || m_rgCPConnInfo[dwIndex].fAlt)
            {
                // Use the primary address
                m_rgCPConnInfo[dwIndex].fAlt = FALSE;
                
                hr = m_rgCPConnInfo[dwIndex].pCPresConn->Init(
                    g_CPresCfg.GetPresServerAddr(dwIndex),
                    m_pCCompPort,
                    this,
                    m_pCSwitchboard);
            }
            else
            {
                // Use the alternate address
                m_rgCPConnInfo[dwIndex].fAlt = TRUE;
                
                hr = m_rgCPConnInfo[dwIndex].pCPresConn->Init(
                    g_CPresCfg.GetPresServerAddr(dwIndex),
                    m_pCCompPort,
                    this,
                    m_pCSwitchboard);
            }
            if(FAILED(hr))
            {
                SAFE_RELEASE(m_rgCPConnInfo[dwIndex].pCPresConn);
            }
        }
    }

lDone:

    return hr;
}

/*****************************************************************************

CXPCluster::SortUsersByDestination

Sort an array of users by destination machine

*****************************************************************************/
void CXPCluster::SortUsersByDestination(DWORD cUsers, QWORD *rgqwUsers)
{
    if (cUsers < 3)
    {
        // No gain by sorting
        return;
    }

    qsort(rgqwUsers, cUsers, sizeof(QWORD), CompareUsersByPresDest);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\INHConnection.h ===
#pragma once
class CSwitchboard;
class CRequestContextIndex;

class INHConnection : public BasePresenceConnection
{
private:
	CSwitchboard *m_pCSwitchboard;
    CompletionPort*      m_pCP;

public:
	
	INHConnection();
	HRESULT Init();
	void Attach(CompletionPort* pCP);
	void Heartbeat();

    //------------------------------------------------------------------------------
    // Message transport
    //------------------------------------------------------------------------------
    
    virtual HRESULT SendAlive(
        XPQTask*      pTask, 
        XPQUser*      pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendLogoff(
        XPQTask*      pTask,
        XPQUser*      pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendDeadXbox(
        XPQTask*      pTask, 
        XPQUser*      pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendDeadUser(
        XPQTask*      pTask, 
        XPQUser*      pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendCheckTitleMessages(
        XPQTask*      pTask,
        XPQUser*      pUser,
        DWORD         dwTitleId){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendUpdateState( 
        XPQTask*      pTask,
        XPQUser*      pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendUpdateStateBatch(
        XPQTask*      pTask,
        XPQUser*      pUser,
        CSgMsgNotifyCliUpdate *prgUdpates,
        DWORD         cUpdates){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendUpdateState2( 
        XPQTask*      pTask,
        XPQUser*      pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendDequeue(
        XPQTask*      pTask,
        XPQUser*      pUser,
        P_QUEUE_TYPES eQType);

    virtual HRESULT SendPeerSubscribe( 
        XPQTask*        pTask,
        XPQUser*        pUser,
        const XPQUser** rgpPeers,
        WORD            wPeers){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendPeerUnsubscribe(
        XPQTask*       pTask,
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendAddBuddy(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pBuddy, 
        bool           bByName = false ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendAcceptBuddy( 
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pBuddy ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendRejectBuddy( 
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pBuddy, 
        bool           bNever = false ){_ASSERTE(0); return E_FAIL;}
    
    virtual HRESULT SendDeleteBuddy( 
        XPQTask*       pTask,
        XPQUser*       pUser,
		const XPQUser* pBuddy ){_ASSERTE(0); return E_FAIL;}
   
    virtual HRESULT SendBlock(   
        XPQTask*        pTask,
        XPQUser*        pUser,
        const XPQUser*  pBlock){_ASSERTE(0); return E_FAIL;}
    
    virtual HRESULT SendUnblock( 
        XPQTask*        pTask,
        XPQUser*        pUser,
        const XPQUser*  pUnblock,
        bool            bAll = false ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendAddAffiliates(
        XPQTask*        pTask,
        XPQUser*        pUser,
        DWORD           dwListFlag,
        DWORD           dwTitleId,
        const XPQUser** rgpAffiliates,
        WORD            cwAffiliates){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendIsAffiliate(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pAffiliate){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendQueryAffiliates(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwListFlags,
        DWORD          cdwLimit,
        DWORD          dwOnlineTitleId,
        BOOL           fUseDatacenter){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendInvite( 
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser** apBuddy, 
        WORD           wCount ){_ASSERTE(0); return E_FAIL;}
    
    virtual HRESULT SendCancelInvite( 
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser** apBuddy, 
        WORD           wCount ){_ASSERTE(0); return E_FAIL;}
    
    virtual HRESULT SendAnswerInvite( 
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pHost, 
        ULONGLONG      qwMatchSessionId,
        bool           bYes ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendSendMessage(
        XPQTask*       pTask,
        XPQUser*       pUser,
		BYTE		   bMsgType,
        ULONGLONG      qwContext,
        DWORD          dwFlags,
        ULONGLONG*     pqwRecipients,
        WORD           wRecipients,
        BYTE*          pbDetails,
        WORD           wDetails,
		WORD		   wExpire){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendEnumMessages(
        XPQTask*       pTask,
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendEnumMessages2(
        XPQTask*       pTask,
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendMessageSummary(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwMsgId){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendMessageSummary2(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwMsgId){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendMessageDetails(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwMsgId,
        DWORD          dwMsgSetFlags,
        DWORD          dwMsgUnsetFlags){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendMessageFlags(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwMsgId,
        DWORD          dwSetFlags,
        DWORD          dwClearFlags ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendMessageDelete(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwMsgId,
        bool           bBlock ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendMessageRevoke(
        XPQTask*                  pTask,
        XPQUser*                  pUser,
        const Q_RECIPIENT_RESULT *prgRecipientResults,
        WORD                      wcRecipients){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendMessageRevokeEx(
        XPQTask*                  pTask,
        XPQUser*                  pUser,
        ULONGLONG                 qwSenderId,
        ULONGLONG                 qwSenderContext,
        DWORD                     dwFlags,
        WORD                      wPropTag,
        BYTE                      bMessageType,
        const Q_RECIPIENT_RESULT* prgRecipients,  
        WORD                      cRecipients,
        const BYTE*               prbProp,
        WORD                      cbProp){_ASSERTE(0); return E_FAIL;}
    
    virtual HRESULT SendUpdateNickname(
        XPQTask*       pTask,
        XPQUser*       pUser,
        BYTE*          pbNickname, 
        WORD           wNicknameLen ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendDeleteTitle(
        XPQTask*       pTask,
        XPQUser*       pUser,
        DWORD          dwTitleId){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendEnumTitles(
        XPQTask*       pTask,
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}
   
    virtual HRESULT SendCreateTeam(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const WCHAR*   wszTeamName,
        const WCHAR*   wszTeamDescription,
        const WCHAR*   wszTeamMotto,
        const WCHAR*   wszTeamURL,
        BYTE*          pbTeamData, 
        WORD           wTeamDataLen,
        BYTE*          pbCreatorData, 
        WORD           wCreatorDataLen){_ASSERTE(0); return E_FAIL;}
        
    virtual HRESULT SendManageTeam(
        XPQTask*       pTask,
        XPQUser*       pUser,
        ULONGLONG      qwTeamId,
        const WCHAR*   wszTeamName,
        const WCHAR*   wszTeamDescription,
        const WCHAR*   wszTeamMotto,
        const WCHAR*   wszTeamURL,
        BYTE*          pbTeamData, 
        WORD           wTeamDataLen ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendDeleteTeam(
        XPQTask*       pTask,
        XPQUser*       pUser,
        ULONGLONG      qwTeamId ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendListTeams(
        XPQTask*       pTask,
        XPQUser*       pUser,
        ULONGLONG*     aqwTeamIds, 
        WORD           wNumIds ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendListUserTeams(
        XPQTask*       pTask,
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendRecruitTeamMember(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pRecruit,
        ULONGLONG      qwTeamId,
        DWORD          dwMemberPriv,
        BYTE*          pbData, 
        WORD           wDataLen){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendJoinTeam(
        XPQTask*         pTask,
        XPQUser*         pUser,
        ULONGLONG        qwTeamId,
        DWORD            dwRecruitMsgId,
        P_INVITE_REPLIES eReply ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendManageTeamMember(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pMember,
        ULONGLONG      qwTeamId,
        DWORD          dwMemberPriv,
        BYTE*          pbData, 
        WORD           wDataLen ){_ASSERTE(0); return E_FAIL;}
            
    virtual HRESULT SendRemoveTeamMember(
        XPQTask*       pTask,
        XPQUser*       pUser,
        const XPQUser* pMember,
        ULONGLONG      qwTeamId){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendListTeamMembers(
        XPQTask*       pTask,   
        XPQUser*       pUser,   
        ULONGLONG      qwTeamId,
        bool           bShowRecruits ){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendGetTeamTicket(
        XPQTask*       pTask,
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendWebFriends(
        XPQTask*       pTask, 
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendGetFriendsList(
        XPQTask*       pTask, 
        XPQUser*       pUser,
        const XPQUser* pTargetUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendGetPresenceInfo(
        XPQTask*       pTask, 
        XPQUser*       pUser,
        const XPQUser* pTargetUser){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendFindUser(
        XPQTask*       pTask, 
        XPQUser*       pUser,
        ULONGLONG      qwFindId,
        const char*    pszGamerTag){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendFindUsers(
        XPQTask*       pTask, 
        XPQUser*       pUser,
        const XPQUser** apFinds, 
		WORD  wCount){_ASSERTE(0); return E_FAIL;}

    virtual HRESULT SendInvalidateUser(
        XPQTask*       pTask,
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}
  
	virtual HRESULT SendEcho(
        XPQTask*       pTask,
        XPQUser*       pUser){_ASSERTE(0); return E_FAIL;}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\MsgBuilder.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2002 Microsoft.  ALL RIGHTS RESERVED
/////////////////////////////////////////////////////////////////////////////
#pragma once

// Messages not covered
// ---------------------
//
//  PMSG_ANNOUNCE   
//  PMSG_SUBSCRIBED 
//  PMSG_UNSUBSCRIBE
//  PMSG_ADDED      
//  PMSG_ACCEPTED   
//  PMSG_REMOVED    
//  PMSG_KICK       
//  PMSG_SYNC
//  PMSG_REFRESH
//  PMSG_WEB_ALIVE
//  PMSG_WEB_ANNOUNCE
//  PMSG_WEB_SUBSCRIBED
//  PMSG_WEB_UNSUBSCRIBE
//  PMSG_ALIVE_INTERNAL
//  PMSG_WATCH_START
//  PMSG_WATCH_STOP

//  QMSG_USER_INFO
//  QMSG_ADD
//  QMSG_DELETE
//  QMSG_DELETE_MATCHES
//  QMSG_LIST
//  QMSG_WEB_USER_INFO
//  QMSG_WEB_PRESENCE
//  QMSG_WEB_LIST
//  QMSG_REVOKE_MESSAGE_EX

extern DWORD g_dwNextSeqNum; // Shared thread safe counter
extern char* g_pszClientVer; // Added to http User Agent

// Empty messages for testing raw ASP.NET FD performance
#define MSG_ECHO  0x0000ffee
typedef struct ECHO_MSG : public BASE_MSG_HEADER
{
    DWORD dwFoo;
} ECHO_MSG;



/////////////////////////////////////////////////
// XPQSgAddr
//  
//  Simple utility wrapper for SGADDR
//
class XPQSgAddr
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPQSgAddr()
    {
        Zero();
    }

    XPQSgAddr( DWORD dwIP, DWORD dwSpi, ULONGLONG qwXboxId )
    {
        m_SGADDR.inaSg.S_un.S_addr = dwIP;
        m_SGADDR.dwSpiSg           = dwSpi;
        m_SGADDR.qwXboxID          = qwXboxId;
        memset( m_SGADDR.abReserved, 0, 4 );
    }

    XPQSgAddr( const SGADDR& rSGADDR )
    {
        memcpy( &m_SGADDR, &rSGADDR, sizeof( SGADDR ) );
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Zero
    //
    void Zero()
    {
        memset( this, 0, sizeof( XPQSgAddr ) );
    }

    ///////////////////////////////////
    // operator: SGADDR cast
    //
    operator SGADDR() const { return( m_SGADDR ); }

    ///////////////////////////////////
    // operator: comparison
    //
    bool operator==( const XPQSgAddr& rhs ) 
    {
        return( 0 == memcmp( &(rhs.m_SGADDR), &m_SGADDR, sizeof( SGADDR ) ) );
    }
    bool operator==( const SGADDR& rhs ) 
    {
        return( 0 == memcmp( &(rhs), &m_SGADDR, sizeof( SGADDR ) ) );
    }

    ///////////////////////////////////
    // IP
    //
    DWORD IP() const          { return m_SGADDR.inaSg.S_un.S_addr; }
    void  SetIP( DWORD dwIP ) { m_SGADDR.inaSg.S_un.S_addr = dwIP; }

    ///////////////////////////////////
    // Spi
    //
    DWORD Spi() const           { return m_SGADDR.dwSpiSg;  }
    void  SetSpi( DWORD dwSpi ) { m_SGADDR.dwSpiSg = dwSpi; }

    ///////////////////////////////////
    // Xbox Id
    //
    ULONGLONG XboxId() const                  { return m_SGADDR.qwXboxID;     }
    void      SetXboxId( ULONGLONG qwXboxId ) { m_SGADDR.qwXboxID = qwXboxId; }

    ///////////////////////////////////
    // Reserved
    //
    void SetReserved( DWORD dwRes ) { memcpy( m_SGADDR.abReserved, &dwRes, sizeof( DWORD ) ); }

private:

    SGADDR m_SGADDR;
};


/////////////////////////////////////////////////
// XPQMsg
//
//  Base class to define common virtual interface
//  
class XPQMsg
{
public:
    enum { kMaxDumpSize = 8192 };

	virtual BYTE* GetMsg() = 0;
    virtual DWORD DumpMsg( BYTE* pbMsgBUff, DWORD dwBufLen ) = 0;
    virtual DWORD Type() const = 0;
    virtual DWORD SeqNum() const = 0;
};


/////////////////////////////////////////////////
// XPQMsgHdr
//
//  Templatized base class for speific messages sent  
//  to presence or notification servers to wrap common 
//  BASE_MSG_HEADER.
//  
template< class MSG, DWORD ID >
class XPQMsgHdr : public XPQMsg
{
public:
    
    ///////////////////////////////////
    // Ctor
    //
    XPQMsgHdr( const XPQSgAddr& rSgAddr ) 
    {
        m_Msg.dwMsgType = ID;
        m_Msg.dwSeqNum  = 0;
        m_Msg.sgaddr    = (SGADDR)rSgAddr;
        m_bHttpAuth     = false;
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }


	BYTE *GetMsg() 
	{ 
        SetNextSeqNum();
		return GetMsgData( &m_Msg );
	}

    ///////////////////////////////////
    // DumpMsg
    //  Messages with Extra Data should overide
    //
    DWORD DumpMsg( BYTE* pbMsgBUff, DWORD dwBufLen )
    {
        SetNextSeqNum();

        DWORD dwDumped;
        if( FAILED( WriteMsgData( 
                        &m_Msg, 
                        m_Msg.sgaddr.dwSpiSg,
                        m_bHttpAuth,
                        pbMsgBUff, 
                        dwBufLen, 
                        &dwDumped ) ) )
        {
            dwDumped = 0L;
        }

        return( dwDumped );
    }

    ///////////////////////////////////
    // Type 
    //
    DWORD Type() const { return m_Msg.dwMsgType; }

    ///////////////////////////////////
    // Seq Num
    //
    static DWORD GetNextSeqNum() 
    { 
        return InterlockedIncrement( (LPLONG)&g_dwNextSeqNum );
    }
    DWORD SeqNum() const              { return m_Msg.dwSeqNum;     }
    void  SetSeqNum( DWORD dwSeqNum ) { m_Msg.dwSeqNum = dwSeqNum; }
    void  SetNextSeqNum()             { m_Msg.dwSeqNum = GetNextSeqNum(); }

    ///////////////////////////////////
    // SG IP
    //
    DWORD IP() const          { return m_Msg.sgaddr.inaSg.S_un.S_addr; }
    void  SetIP( DWORD dwIP ) { m_Msg.sgaddr.inaSg.S_un.S_addr = dwIP; }

    ///////////////////////////////////
    // SG Spi
    //
    DWORD Spi() const           { return m_Msg.sgaddr.dwSpiSg;  }
    void  SetSpi( DWORD dwSpi ) { m_Msg.sgaddr.dwSpiSg = dwSpi; }

    ///////////////////////////////////
    // Xbox Id
    //
    ULONGLONG XboxId() const                  { return m_Msg.sgaddr.qwXboxID;     }
    void      SetXboxId( ULONGLONG qwXboxId ) { m_Msg.sgaddr.qwXboxID = qwXboxId; }
        
    ///////////////////////////////////
    // SGAddr
    //
    XPQSgAddr  SgAddr() const                         { return XPQSgAddr( m_Msg.sgaddr ); }
    void       SetSgAddr( const XPQSgAddr& rSgAddr )  { m_Msg.sgaddr = (SGADDR)rSgAddr;   }

    ///////////////////////////////////
    // HttpAuth
    //
    bool       HttpAuth() const                       { return m_bHttpAuth; }
    void       SetHttpAuth(bool bHttpAuth)            { m_bHttpAuth = bHttpAuth; }

    ///////////////////////////////////
    // Extra Message Data Size Constants
    //
    enum 
    {
        kMaxExpectedHelloDesc = 80, // MAX_HELLO_DESCRIPTION_LEN
        kHelloDescBufSize     = 81,
        kMaxExpectedAcctName  = 16, // XONLINE_GAMERTAG_SIZE
        kAcctNameBufSize      = 17,
        kMaxExpectedTitleData = 8,  // MAX_TITLE_STATE_BYTES
        kTitleDataBufSize     = 9,
        kMaxExpectedNickName  = 24, // MAX_NICKNAME_BYTES
        kNicknameBufSize      = 25
    };

protected:

    ///////////////////////////////////
    // Set Null Term Char Data
    //  Utility to load a Null terminated extra message data char buffer with a given
    //  psz string, returns length of source including terminating null.
    //
    WORD SetNullTermCharData( 
        const char* pszNewVal,  // Null terminated source
        char* aBuf,             // desitation buffer
        WORD wBufSize )         // size of destination buffer
    {
        if( NULL == pszNewVal )
        {
            return 0;
        }

        strncpy( aBuf, pszNewVal, wBufSize );
        return( strlen( pszNewVal ) + 1 );
    }

    ///////////////////////////////////
    // Set Null Term Char Data
    //  Utility to load a Null terminated extra message data char buffer with a given
    //  psz string, returns length of source including terminating null.
    //
    WORD SetNullTermWCharData( 
        const WCHAR* pwszNewVal,  // Null terminated source
        WCHAR* aBuf,              // desitation buffer
        WORD wBufSize )           // size of destination buffer
    {
        if( NULL == pwszNewVal )
        {
            return 0;
        }

        wcsncpy( aBuf, pwszNewVal, wBufSize );
        return( (wcslen( pwszNewVal ) + 1) * sizeof(WCHAR) );
    }

    ///////////////////////////////////
    // Set Data 
    //  Utility to load a extra message buffer, returns size of source.
    //
    template< class T >
    WORD SetData( 
        const T* pcNewVal, // source buffer
        WORD wNewSize,     // size of source buffer
        T* aBuf,           // desitation buffer
        WORD wBufSize )    // size of destination buffer
    {
        memcpy( aBuf, pcNewVal, min( wNewSize, wBufSize ) );
        return wNewSize;  // This can be intentionaly wrong (dest > src)
    }

    MSG     m_Msg;          // The P & N Message Struct
    bool    m_bHttpAuth;    // True when we need to add HttpAuth headers
};


/////////////////////////////////////////////////
// XP|XQ MsgHello
//
//  Semantics are curently identical for P&N servers
//
template< class MSG, DWORD ID >
class XPQMsgHello : public XPQMsgHdr<MSG,ID>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPQMsgHello()
    :
        XPQMsgHdr<MSG,ID>( XPQSgAddr() )
    {
        SetDefProtocolVer();
        SetDefDescription();
    }

    XPQMsgHello( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<MSG,ID>( rSgAddr )
    {
        SetDefProtocolVer();
        SetDefDescription();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    virtual DWORD DumpMsg( BYTE* pbMsgBuff, DWORD dwBufLen )
    {
        SetNextSeqNum();
      
        DWORD dwDumped;
        if( FAILED( WriteMsgData( 
                        &m_Msg, 
                        m_Msg.sgaddr.dwSpiSg,
                        m_bHttpAuth,
                        (BYTE*)m_acDescBuf, m_dwDescSize, 
                        pbMsgBuff, dwBufLen, &dwDumped ) ) )
        {
            dwDumped = 0L;
        }

        return( dwDumped );
    }

    ///////////////////////////////////
    // Protocol Version
    //
    DWORD ProtocolVer() const           { return m_Msg.dwProtocolVersion;       }
    void  SetProtocolVer( DWORD dwVer ) { m_Msg.dwProtocolVersion = dwVer;      }
    void  SetDefProtocolVer()           { m_Msg.dwProtocolVersion = 0x00010000; }

    ///////////////////////////////////
    // Description
    //
    const char* Description()    const { return m_acDescBuf;  }
    WORD        DescriptionLen() const { return m_dwDescSize; }
    void SetDescription( const char* pcDescBuf, WORD wLen )
    {
        m_dwDescSize = SetData<char>( pcDescBuf, wLen, m_acDescBuf, kHelloDescBufSize );
    }
    void SetDescription( const char* pszDesc )
    {
        m_dwDescSize = SetNullTermCharData( pszDesc, m_acDescBuf, kHelloDescBufSize );
    }
    void SetDefDescription()
    {
        SetDescription( "v1.0");
    }

private:

    // Extra message data - oversized with explicit len to allow invalid data
    char  m_acDescBuf[ kHelloDescBufSize ]; // Null terminated 
    DWORD m_dwDescSize;                     // Includes terminating \0
};
typedef XPQMsgHello<P_HELLO_MSG,PMSG_HELLO> XPMsgHello;
typedef XPQMsgHello<Q_HELLO_MSG,QMSG_HELLO> XQMsgHello;


/////////////////////////////////////////////////
// XP|XQ MsgDeadSG
//
//  No data beyond base Header.
//
typedef XPQMsgHdr<P_DEAD_SG_MSG,PMSG_DEAD_SG> XPMsgDeadSG;
typedef XPQMsgHdr<Q_DEAD_SG_MSG,QMSG_DEAD_SG> XQMsgDeadSG;


/////////////////////////////////////////////////
// XP|XQ MsgDeadXbox
//
//  No data beyond base Header.
//
typedef XPQMsgHdr<P_DEAD_XBOX_MSG,PMSG_DEAD_XBOX> XPMsgDeadXbox;
typedef XPQMsgHdr<Q_DEAD_XBOX_MSG,QMSG_DEAD_XBOX> XQMsgDeadXbox;


/////////////////////////////////////////////////
// XP|XQ MsgDeadUser
//
//  Semantics are curently identical for P&N servers
//
template< class MSG, DWORD ID >
class XPQMsgDeadUser : public XPQMsgHdr<MSG,ID>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPQMsgDeadUser( ULONGLONG qwUserId = MAKEQWORD(0L,0L) )
    :
        XPQMsgHdr<MSG,ID>( XPQSgAddr() )
    {
        m_Msg.qwUserID = qwUserId;
    }

    XPQMsgDeadUser( const XPQSgAddr& rSgAddr, ULONGLONG qwUserId = MAKEQWORD( 0L, 0L) )
    :
        XPQMsgHdr<MSG,ID>( rSgAddr )
    {
        m_Msg.qwUserID = qwUserId;
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }
};
typedef XPQMsgDeadUser<P_DEAD_USER_MSG,PMSG_DEAD_USER> XPMsgDeadUser;
typedef XPQMsgDeadUser<Q_DEAD_USER_MSG,QMSG_DEAD_USER> XQMsgDeadUser;

/////////////////////////////////////////////////
// XP MsgAlive
//
//  Presence: Logon
//
class XPMsgAlive : public XPQMsgHdr<P_ALIVE_MSG,PMSG_ALIVE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgAlive()
    :
        XPQMsgHdr<P_ALIVE_MSG,PMSG_ALIVE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgAlive( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_ALIVE_MSG,PMSG_ALIVE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID           = MAKEQWORD( 0L, 0L );
        m_Msg.dwTitleID          = 1L;
        m_Msg.dwBuddyListVersion = 0L;
        m_Msg.dwBlockListVersion = 0L;
        m_Msg.dwState            = P_STATE_MASK_ONLINE;
        m_Msg.qwMatchSessionID   = MAKEQWORD( 1L, 0L );
        m_Msg.cbAcctName         = 0;
        m_Msg.cbTitleStuff       = 0;
        m_Msg.cbNickname         = 0;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleId ) { m_Msg.dwTitleID = dwTitleId; }

    ///////////////////////////////////
    // Buddy List Version
    //
    DWORD BuddyListVer() const           { return m_Msg.dwBuddyListVersion;  }
    void  SetBuddyListVer( DWORD dwVer ) { m_Msg.dwBuddyListVersion = dwVer; }

    ///////////////////////////////////
    // Block List Version
    //
    DWORD BlockListVer() const           { return m_Msg.dwBlockListVersion;  }
    void  SetBlockListVer( DWORD dwVer ) { m_Msg.dwBlockListVersion = dwVer; }

    ///////////////////////////////////
    // State
    //
    DWORD State() const             { return m_Msg.dwState;    }
    void  SetState( DWORD dwState ) { m_Msg.dwState = dwState; }

    ///////////////////////////////////
    // Match Session Id
    //
    ULONGLONG MatchId() const                 { return m_Msg.qwMatchSessionID;    }
    void      SetMatchId( ULONGLONG qwSesId ) { m_Msg.qwMatchSessionID = qwSesId; }

    ///////////////////////////////////
    // Account Name
    //
    const char* AcctName() const    { return m_acAcctNameBuf;  }
    WORD        AcctNameLen() const { return m_Msg.cbAcctName; }
    void SetAcctName( const char* pcNameBuf, WORD wLen )
    {
        m_Msg.cbAcctName = SetData<char>( pcNameBuf, wLen, m_acAcctNameBuf, kAcctNameBufSize );
    }
    void SetAcctName( const char* pszName )
    {
        m_Msg.cbAcctName = SetNullTermCharData( pszName, m_acAcctNameBuf, kAcctNameBufSize );
    }

    ///////////////////////////////////
    // Title Data
    //
    const BYTE* TitleData() const    { return m_abTitleDataBuf;   }
    WORD        TitleDataLen() const { return m_Msg.cbTitleStuff; }
    void SetTitleData( const BYTE* pbData, WORD wLen )
    {
        m_Msg.cbTitleStuff = SetData<BYTE>( pbData, wLen, m_abTitleDataBuf, kTitleDataBufSize );
    }

    ///////////////////////////////////
    // NickName
    //
    const BYTE* Nickname() const    { return m_abNicknameBuf;  }
    WORD        NicknameLen() const { return m_Msg.cbNickname; }
    void SetNickname( const BYTE* pbNickname, WORD wLen )
    {
        m_Msg.cbNickname = SetData<BYTE>( pbNickname, wLen, m_abNicknameBuf, kNicknameBufSize );
    }

private:

    // Extra message data - oversized to allow invalid data
    char m_acAcctNameBuf[ kAcctNameBufSize ]; // Null terminated 
    BYTE m_abTitleDataBuf[ kTitleDataBufSize ];
    BYTE m_abNicknameBuf[ kNicknameBufSize ];
};

/////////////////////////////////////////////////
// XP MsgAlive2
//
//  Presence: Logon
//
class XPMsgAlive2 : public XPQMsgHdr<P_ALIVE_2_MSG,PMSG_ALIVE_2>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgAlive2()
    :
        XPQMsgHdr<P_ALIVE_2_MSG,PMSG_ALIVE_2>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgAlive2( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_ALIVE_2_MSG,PMSG_ALIVE_2>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.dwTitleID      = 1L;
        m_Msg.dwTitleVersion = 1L;
        m_Msg.dwTitleRegion  = 1L;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // XN ADDR
    //
    const XNADDR& XNAddr() const                      { return m_Msg.xnaddr;    }     
    void          SetXNAdder( const XNADDR& rXnAddr ) { m_Msg.xnaddr = rXnAddr; }
    
    ///////////////////////////////////
    // XN KID
    //
    const XNKID& XNKId() const                   { return m_Msg.xnkid;   }     
    void         SetXNKId( const XNKID& rXnKId ) { m_Msg.xnkid = rXnKId; }
    
    ///////////////////////////////////
    // XN Key
    //
    const XNKEY& XNKey() const                   { return m_Msg.xnkey;   }     
    void         SetXNKey( const XNKEY& rXnKey ) { m_Msg.xnkey = rXnKey; }

    ///////////////////////////////////
    // XBox (Client) Library Version
    const XBOX_LIBRARY_VERSION& ClientLibVer() const                                { return m_Msg.clientVersion; }     
    void                        SetClientLibVer( const XBOX_LIBRARY_VERSION& rVer ) { m_Msg.clientVersion = rVer; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleId ) { m_Msg.dwTitleID = dwTitleId; }

    ///////////////////////////////////
    // Title Version
    //
    DWORD TitleVersion() const                { return m_Msg.dwTitleVersion;       }
    void  SetTitleVersion( DWORD dwTitleVer ) { m_Msg.dwTitleVersion = dwTitleVer; }

    ///////////////////////////////////
    // Title Region
    //
    DWORD TitleRegion() const               { return m_Msg.dwTitleRegion;      }
    void  SetTitleRegion( DWORD dwTitleRegion ) { m_Msg.dwTitleRegion = dwTitleRegion; }

    ///////////////////////////////////
    // IP Port I
    //  IP port of the client on the Internet
    WORD IPPortI() const            { return m_Msg.ipportI;      }
    void SetIPPortI( WORD ipportI ) { m_Msg.ipportI = ipportI; }

    ///////////////////////////////////
    // IP Address I
    //  IP address of the client on the Internet
    const IN_ADDR& IPAddressI() const                    { return m_Msg.ipaI;  }
    void           SetIPAddressI( const IN_ADDR& rIpaI ) { m_Msg.ipaI = rIpaI; }

    ///////////////////////////////////
    // Nonce
    //  A random nonce associated with this session
    LARGE_INTEGER Nonce() const             { return m_Msg.liNonce;  }
    void  SetNonce( LARGE_INTEGER liNonce ) { m_Msg.liNonce = liNonce; }

    ///////////////////////////////////
    // Init Time
    //  FILETIME marking session initiation with SG
    LARGE_INTEGER TimeInit() const                { return m_Msg.liTimeInit;        }
    void  SetTimeInit( LARGE_INTEGER liTimeInit ) { m_Msg.liTimeInit = liTimeInit; }

    ///////////////////////////////////
    // Buddy List Version
    //
    DWORD BuddyListVer() const           { return m_Msg.dwBuddyListVersion;  }
    void  SetBuddyListVer( DWORD dwVer ) { m_Msg.dwBuddyListVersion = dwVer; }

    ///////////////////////////////////
    // Block List Version
    //
    DWORD BlockListVer() const           { return m_Msg.dwBlockListVersion;  }
    void  SetBlockListVer( DWORD dwVer ) { m_Msg.dwBlockListVersion = dwVer; }

    ///////////////////////////////////
    // Account Name
    //
    const char* AcctName() const    { return m_acAcctNameBuf;  }
    WORD        AcctNameLen() const { return m_Msg.cbAcctName; }
    void SetAcctName( const char* pcNameBuf, WORD wLen )
    {
        m_Msg.cbAcctName = SetData<char>( pcNameBuf, wLen, m_acAcctNameBuf, kAcctNameBufSize );
    }
    void SetAcctName( const char* pszName )
    {
        m_Msg.cbAcctName = SetNullTermCharData( pszName, m_acAcctNameBuf, kAcctNameBufSize );
    }

private:

    // Extra message data - oversized to allow invalid data
    char m_acAcctNameBuf[ kAcctNameBufSize ]; // Null terminated 
};

/////////////////////////////////////////////////
// XP MsgAdd
//
//  Presence: Buddy Request
//
class XPMsgAdd : public XPQMsgHdr<P_ADD_MSG,PMSG_ADD>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgAdd()
    :
        XPQMsgHdr<P_ADD_MSG,PMSG_ADD>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgAdd( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_ADD_MSG,PMSG_ADD>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwSenderID      = MAKEQWORD(0L,0L);
        m_Msg.qwBuddyID       = MAKEQWORD(0L,0L);
        m_Msg.cbBuddyAcctname = 0;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    virtual DWORD DumpMsg( BYTE* pbMsgBUff, DWORD dwBufLen );

    ///////////////////////////////////
    // Sender Id
    //
    ULONGLONG SenderId() const                  { return m_Msg.qwSenderID;     }
    void      SetSenderId( ULONGLONG qwUserId ) { m_Msg.qwSenderID = qwUserId; }

    ///////////////////////////////////
    // Buddy Id
    //
    ULONGLONG BuddyId() const                  { return m_Msg.qwBuddyID;     }
    void      SetBuddyId( ULONGLONG qwUserId ) { m_Msg.qwBuddyID = qwUserId; }

    ///////////////////////////////////
    // Buddy Name
    //
    const char* BuddyName() const    { return m_acBuddyAcctNameBuf;     }
    WORD        BUddyNameLen() const { return m_Msg.cbBuddyAcctname; }
    void SetBuddyName( const char* pcNameBuf, WORD wLen )
    {
        m_Msg.cbBuddyAcctname = SetData<char>( pcNameBuf, wLen, m_acBuddyAcctNameBuf, kAcctNameBufSize );
    }
    void SetBuddyName( const char* pszName )
    {
        m_Msg.cbBuddyAcctname = SetNullTermCharData( pszName, m_acBuddyAcctNameBuf, kAcctNameBufSize );
    }

private:
    
    // Extra message data - oversized to allow invalid data
    char m_acBuddyAcctNameBuf[ kAcctNameBufSize ]; // Null terminated 
};

/////////////////////////////////////////////////
// XP MsgAdd2
//
//  Presence: Buddy Request 2
//
class XPMsgAdd2 : public XPQMsgHdr<P_ADD_2_MSG,PMSG_ADD_2>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgAdd2()
    :
        XPQMsgHdr<P_ADD_2_MSG,PMSG_ADD_2>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgAdd2( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_ADD_2_MSG,PMSG_ADD_2>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwSenderID     = MAKEQWORD(0L,0L);
        m_Msg.qwBuddyID      = MAKEQWORD(0L,0L);
        m_Msg.dwMessageFlags = 0;
        m_Msg.cbDetails      = 0;

        memset( m_Msg.szBuddyAcctName, 0, sizeof( m_Msg.szBuddyAcctName ) );
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    virtual DWORD DumpMsg( BYTE* pbMsgBUff, DWORD dwBufLen );

    ///////////////////////////////////
    // Sender Id
    //
    ULONGLONG SenderId() const                  { return m_Msg.qwSenderID;     }
    void      SetSenderId( ULONGLONG qwUserId ) { m_Msg.qwSenderID = qwUserId; }

    ///////////////////////////////////
    // Buddy Id
    //
    ULONGLONG BuddyId() const                  { return m_Msg.qwBuddyID;     }
    void      SetBuddyId( ULONGLONG qwUserId ) { m_Msg.qwBuddyID = qwUserId; }

    ///////////////////////////////////
    // Message Flags
    //
    DWORD MessageFlags() const                    { return m_Msg.dwMessageFlags;           }
    void  SetMessageFlags( DWORD dwMessageFlags ) { m_Msg.dwMessageFlags = dwMessageFlags; }

    ///////////////////////////////////
    // Buddy Name
    //  ASCII Null terminated, only used if qwBuddyID == 0
    //
    const char* BuddyName() const { return m_Msg.szBuddyAcctName; }
    void SetBuddyName( const char* pszName )  
    { 
        strncpy( m_Msg.szBuddyAcctName, pszName, XONLINE_GAMERTAG_SIZE ); 
    }

    ///////////////////////////////////
    // Details
    //
    const BYTE* Details() const    { return m_abDetails;     }
    WORD        DetailsLen() const { return m_Msg.cbDetails; }  

private:
    BYTE m_abDetails[ XONLINE_MAX_MESSAGE_DETAILS ]; // 4096
};

/////////////////////////////////////////////////
// XP MsgDelete
//
//  Presence: Buddy Delete
//
class XPMsgDelete : public XPQMsgHdr<P_DELETE_MSG,PMSG_DELETE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgDelete()
    :
        XPQMsgHdr<P_DELETE_MSG,PMSG_DELETE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgDelete( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_DELETE_MSG,PMSG_DELETE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID  = MAKEQWORD(0L,0L);
        m_Msg.qwBuddyID = MAKEQWORD(0L,0L);
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Buddy Id
    //
    ULONGLONG BuddyId() const                  { return m_Msg.qwBuddyID;     }
    void      SetBuddyId( ULONGLONG qwUserId ) { m_Msg.qwBuddyID = qwUserId; }
};

/////////////////////////////////////////////////
// XP MsgAccept
//
//  Presence: Accept a buddy request
//
class XPMsgAccept : public XPQMsgHdr<P_ACCEPT_MSG,PMSG_ACCEPT>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgAccept() 
    : 
        XPQMsgHdr<P_ACCEPT_MSG,PMSG_ACCEPT>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgAccept( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_ACCEPT_MSG,PMSG_ACCEPT>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID  = MAKEQWORD(0L,0L);
        m_Msg.qwBuddyID = MAKEQWORD(0L,0L);
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Buddy Id
    //
    ULONGLONG BuddyId() const                  { return m_Msg.qwBuddyID;     }
    void      SetBuddyId( ULONGLONG qwUserId ) { m_Msg.qwBuddyID = qwUserId; }
};

/////////////////////////////////////////////////
// XP MsgReject
//
//  Presence: Decline a buddy request
//
class MsgReject : public XPQMsgHdr<P_REJECT_MSG,PMSG_REJECT>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    MsgReject()
    :
        XPQMsgHdr<P_REJECT_MSG,PMSG_REJECT>( XPQSgAddr() )
    {
        SetDefaults();
    }

    MsgReject( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_REJECT_MSG,PMSG_REJECT>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID  = MAKEQWORD(0L,0L);
        m_Msg.qwBuddyID = MAKEQWORD(0L,0L);
        m_Msg.fNever    = FALSE;
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Buddy Id
    //
    ULONGLONG BuddyId() const                  { return m_Msg.qwBuddyID;     }
    void      SetBuddyId( ULONGLONG qwUserId ) { m_Msg.qwBuddyID = qwUserId; }

    ///////////////////////////////////
    // Never flag
    //
    BOOL Never() const           { return m_Msg.fNever;   }
    void SetNever( bool bNever ) { m_Msg.fNever = bNever ? TRUE : FALSE; }
};

/////////////////////////////////////////////////
// XP MsgBlock
//
//  Presence: Add to mute list
//
class XPMsgBlock : public XPQMsgHdr<P_BLOCK_MSG,PMSG_BLOCK>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgBlock() 
    : 
        XPQMsgHdr<P_BLOCK_MSG,PMSG_BLOCK>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgBlock( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_BLOCK_MSG,PMSG_BLOCK>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID  = MAKEQWORD(0L,0L);
        m_Msg.qwBlockID = MAKEQWORD(0L,0L);
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Block Id
    //
    ULONGLONG BlockId() const                  { return m_Msg.qwBlockID;     }
    void      SetBlockId( ULONGLONG qwUserId ) { m_Msg.qwBlockID = qwUserId; }
};

/////////////////////////////////////////////////
// XP MsgUnBlock
//
//  Presence: Remove from mute list
//
class XPMsgUnblock : public XPQMsgHdr<P_UNBLOCK_MSG,PMSG_UNBLOCK>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgUnblock() 
    : 
        XPQMsgHdr<P_UNBLOCK_MSG,PMSG_UNBLOCK>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgUnblock( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_UNBLOCK_MSG,PMSG_UNBLOCK>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID  = MAKEQWORD(0L,0L);
        m_Msg.qwBlockID = MAKEQWORD(0L,0L);
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Block Id
    //
    ULONGLONG BlockId() const                  { return m_Msg.qwBlockID;             }
    void      SetBlockId( ULONGLONG qwUserId ) { m_Msg.qwBlockID = qwUserId;         }
    void      SetBlockIdToUnblockAll()         { m_Msg.qwBlockID = MAKEQWORD(0L,0L); }
};

/////////////////////////////////////////////////
// XP MsgInvite
//
//  Presence: Invite to join game
//
class XPMsgInvite : public XPQMsgHdr<P_INVITE_MSG,PMSG_INVITE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgInvite() 
    : 
        XPQMsgHdr<P_INVITE_MSG,PMSG_INVITE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgInvite( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_INVITE_MSG,PMSG_INVITE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID         = MAKEQWORD(0L,0L);
        m_Msg.dwTitleID        = 1L;
        m_Msg.qwMatchSessionID = MAKEQWORD(1L,0L);
        m_Msg.cInvitees        = 0;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleId ) { m_Msg.dwTitleID = dwTitleId; }

    ///////////////////////////////////
    // Match Session Id
    //
    ULONGLONG MatchId() const                   { return m_Msg.qwMatchSessionID;      }
    void      SetMatchId( ULONGLONG qwMatchId ) { m_Msg.qwMatchSessionID = qwMatchId; }

    ///////////////////////////////////
    // Invitees
    //
    const ULONGLONG* Invitees() const    { return m_aqwInvitees;   }
    WORD             InviteesLen() const { return m_Msg.cInvitees; }  
    WORD AddInvitees( ULONGLONG* aqwInvitees, WORD wLen )
    {
        WORD wInvited = min( wLen, MAX_BUDDIES - m_Msg.cInvitees );
        memcpy( &(m_aqwInvitees[ m_Msg.cInvitees ]), aqwInvitees, wInvited * sizeof( ULONGLONG ) );
        m_Msg.cInvitees += wInvited;
        return wInvited;
    }

private:

    ULONGLONG m_aqwInvitees[ MAX_BUDDIES ]; // 100
};

/////////////////////////////////////////////////
// XP MsgInvite2
//
//  Presence: Invite to join game
//
class XPMsgInvite2 : public XPQMsgHdr<P_INVITE_2_MSG,PMSG_INVITE_2>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgInvite2() 
    : 
        XPQMsgHdr<P_INVITE_2_MSG,PMSG_INVITE_2>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgInvite2( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_INVITE_2_MSG,PMSG_INVITE_2>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID        = MAKEQWORD(0L,0L);
        m_Msg.qwSenderContext = MAKEQWORD(0L,0L);
        m_Msg.dwTitleID       = 1L;
        m_Msg.cInvitees       = 0;
        m_Msg.dwMessageFlags  = 0;
        m_Msg.cbDetails       =0 ;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleId ) { m_Msg.dwTitleID = dwTitleId; }

    ///////////////////////////////////
    // Match Session Id
    //
    ULONGLONG MatchId() const                   { return m_Msg.qwSenderContext;      }
    void      SetMatchId( ULONGLONG qwMatchId ) { m_Msg.qwSenderContext = qwMatchId; }

    ///////////////////////////////////
    // Message Flags
    //
    DWORD MessageFlags() const                    { return m_Msg.dwMessageFlags;           }
    void  SetMessageFlags( DWORD dwMessageFlags ) { m_Msg.dwMessageFlags = dwMessageFlags; }

    ///////////////////////////////////
    // Invitees
    //
    const ULONGLONG* Invitees() const    { return m_aqwInvitees;   }
    WORD             InviteesLen() const { return m_Msg.cInvitees; }  
    WORD AddInvitees( ULONGLONG* aqwInvitees, WORD wLen )
    {
        WORD wInvited = min( wLen, MAX_BUDDIES - m_Msg.cInvitees );
        memcpy( &(m_aqwInvitees[ m_Msg.cInvitees ]), aqwInvitees, wInvited * sizeof( ULONGLONG ) );
        m_Msg.cInvitees += wInvited;
        return wInvited;
    }

    ///////////////////////////////////
    // Details
    //
    const BYTE* Details() const    { return m_abDetails;     }
    WORD        DetailsLen() const { return m_Msg.cbDetails; }  

private:

    ULONGLONG m_aqwInvitees[ MAX_BUDDIES                  ]; // 100
    BYTE      m_abDetails  [ XONLINE_MAX_MESSAGE_DETAILS  ]; // 4096
};

/////////////////////////////////////////////////
// XP MsgCancelInvite
//
//  Presence: Cancel Invitaions to join game
//
class XPMsgCancelInvite : public XPQMsgHdr<P_CANCEL_MSG,PMSG_CANCEL>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgCancelInvite() 
    : 
        XPQMsgHdr<P_CANCEL_MSG,PMSG_CANCEL>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgCancelInvite( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_CANCEL_MSG,PMSG_CANCEL>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID         = MAKEQWORD(0L,0L);
        m_Msg.qwMatchSessionID = MAKEQWORD(1L,0L);
        m_Msg.cInvitees        = 0;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Match Session Id
    //
    ULONGLONG MatchId() const                   { return m_Msg.qwMatchSessionID;      }
    void      SetMatchId( ULONGLONG qwMatchId ) { m_Msg.qwMatchSessionID = qwMatchId; }

    ///////////////////////////////////
    // Invitees
    //
    const ULONGLONG* Invitees() const    { return m_aqwInvitees;   }
    WORD             InviteesLen() const { return m_Msg.cInvitees; }  
    WORD AddInvitees( ULONGLONG* aqwInvitees, WORD wLen )
    {
        WORD wInvited = min( wLen, MAX_BUDDIES - m_Msg.cInvitees );
        memcpy( &(m_aqwInvitees[ m_Msg.cInvitees ]), aqwInvitees, wInvited * sizeof( ULONGLONG ) );
        m_Msg.cInvitees += wInvited;
        return wInvited;
    }

private:

    ULONGLONG m_aqwInvitees[ MAX_BUDDIES ]; // 100
};

/////////////////////////////////////////////////
// XP MsgInviteAnswer
//
//  Presence: Answers an Invitaion to join game
//
class XPMsgInviteAnswer : public XPQMsgHdr<P_INVITE_ANSWER_MSG,PMSG_INVITE_ANSWER>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgInviteAnswer() 
    : 
        XPQMsgHdr<P_INVITE_ANSWER_MSG,PMSG_INVITE_ANSWER>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgInviteAnswer( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_INVITE_ANSWER_MSG,PMSG_INVITE_ANSWER>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID         = MAKEQWORD(0L,0L);
        m_Msg.qwHostID         = MAKEQWORD(0L,0L);
        m_Msg.qwMatchSessionID = MAKEQWORD(1L,0L);
        m_Msg.wAnswer          = PINVITE_REPLY_YES;
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Host Id
    //
    ULONGLONG HostId() const                  { return m_Msg.qwHostID;     }
    void      SetHostId( ULONGLONG qwHostId ) { m_Msg.qwHostID = qwHostId; }

    ///////////////////////////////////
    // Match Session Id
    //
    ULONGLONG MatchId() const                   { return m_Msg.qwMatchSessionID;      }
    void      SetMatchId( ULONGLONG qwMatchId ) { m_Msg.qwMatchSessionID = qwMatchId; }

    ///////////////////////////////////
    // Answer
    //
    WORD Answer() const            { return m_Msg.wAnswer;              }  
    void SetAnswer( WORD wAnswer ) { m_Msg.wAnswer = wAnswer;           } 
    void AnswerYes()               { m_Msg.wAnswer = PINVITE_REPLY_YES; }  
    void AnswerNo()                { m_Msg.wAnswer = PINVITE_REPLY_NO;  }   
};

/////////////////////////////////////////////////
// XP MsgNickname
//
class XPMsgNickName : public XPQMsgHdr<P_NICKNAME_MSG,PMSG_NICKNAME>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgNickName()
    :
        XPQMsgHdr<P_NICKNAME_MSG,PMSG_NICKNAME>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgNickName( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_NICKNAME_MSG,PMSG_NICKNAME>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID   = MAKEQWORD( 0L, 0L );
        m_Msg.cbNickname = 0;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Nickname
    //
    const BYTE* Nickname() const    { return m_abNicknameBuf;   }
    WORD        NicknameLen() const { return m_Msg.cbNickname; }
    void SetNickname( const BYTE* pbData, WORD wLen )
    {
        m_Msg.cbNickname = SetData<BYTE>( pbData, wLen, m_abNicknameBuf, kNicknameBufSize );
    }

private:

    // Extra message data - oversized to allow invalid data
    BYTE m_abNicknameBuf[ kNicknameBufSize ];
};

/////////////////////////////////////////////////
// XP MsgState
//
class XPMsgState : public XPQMsgHdr<P_STATE_MSG,PMSG_STATE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgState()
    :
        XPQMsgHdr<P_STATE_MSG,PMSG_STATE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgState( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_STATE_MSG,PMSG_STATE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID           = MAKEQWORD( 0L, 0L );
        m_Msg.dwState            = P_STATE_MASK_ONLINE;
        m_Msg.qwMatchSessionID   = MAKEQWORD( 1L, 0L );
        m_Msg.cbTitleStuff       = 0;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // State
    //
    DWORD State() const             { return m_Msg.dwState;    }
    void  SetState( DWORD dwState ) { m_Msg.dwState = dwState; }

    ///////////////////////////////////
    // Match Session Id
    //
    ULONGLONG MatchSesId() const                 { return m_Msg.qwMatchSessionID;    }
    void      SetMatchSesId( ULONGLONG qwSesId ) { m_Msg.qwMatchSessionID = qwSesId; }

    ///////////////////////////////////
    // Title Data
    //
    const BYTE* TitleData() const    { return m_abTitleDataBuf;   }
    WORD        TitleDataLen() const { return m_Msg.cbTitleStuff; }
    void SetTitleData( const BYTE* pbData, WORD wLen )
    {
        m_Msg.cbTitleStuff = SetData<BYTE>( pbData, wLen, m_abTitleDataBuf, kTitleDataBufSize );
    }

private:

    // Extra message data - oversized to allow invalid data
    BYTE m_abTitleDataBuf[ kTitleDataBufSize ];
};

/////////////////////////////////////////////////
// XP MsgWebFriends
//
//  Presence: Get State of friends in a batch
//
class XPMsgWebFriends : public XPQMsgHdr<P_WEB_FRIENDS_MSG,PMSG_WEB_FRIENDS>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgWebFriends() 
    : 
        XPQMsgHdr<P_WEB_FRIENDS_MSG,PMSG_WEB_FRIENDS>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgWebFriends( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_WEB_FRIENDS_MSG,PMSG_WEB_FRIENDS>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID  = MAKEQWORD(0L,0L);
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }
};

/////////////////////////////////////////////////
// XP MsgGetFriendsList
//
//  Presence: Lookup one block of presence data
//
class XPMsgGetFriendsList : public XPQMsgHdr<P_GET_FRIENDS_LIST_MSG,PMSG_GET_FRIENDS_LIST>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgGetFriendsList() 
        : 
        XPQMsgHdr<P_GET_FRIENDS_LIST_MSG,PMSG_GET_FRIENDS_LIST>( XPQSgAddr() )
        {
            SetDefaults();
        }

    XPMsgGetFriendsList( const XPQSgAddr& rSgAddr )
        :
        XPQMsgHdr<P_GET_FRIENDS_LIST_MSG,PMSG_GET_FRIENDS_LIST>( rSgAddr )
        {
            SetDefaults();
        }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwSenderID      = MAKEQWORD(0L,0L);
        m_Msg.qwTargetID      = MAKEQWORD(0L,0L);
    }

    ULONGLONG SenderId() const                    { return m_Msg.qwSenderID;     }
    void      SetSenderId( ULONGLONG qwSenderId ) { m_Msg.qwSenderID = qwSenderId; }

    void      SetTarget( ULONGLONG qwTargetId )       
    { 
        m_Msg.qwTargetID = qwTargetId;
    }
};


/////////////////////////////////////////////////
// XP MsgPeerSubscribe Ex
//
//  Presence: Subscribe to a set of peers
//
class XPMsgPeerSubscribeEx : public XPQMsgHdr<P_PEER_SUBSCRIBE_EX_MSG,PMSG_PEER_SUBSCRIBE_EX>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgPeerSubscribeEx() 
    : 
        XPQMsgHdr<P_PEER_SUBSCRIBE_EX_MSG,PMSG_PEER_SUBSCRIBE_EX>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgPeerSubscribeEx( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_PEER_SUBSCRIBE_EX_MSG,PMSG_PEER_SUBSCRIBE_EX>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID = MAKEQWORD(0L,0L);
		m_Msg.dwFlags  = 0;
        m_Msg.cUserIDs = 0;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // List flags
    //
    DWORD     Flags() const                   { return m_Msg.dwFlags;     }
    void      SetFlags( DWORD dwFlags )       { m_Msg.dwFlags = dwFlags;  }

    ///////////////////////////////////
    // UserIDs
    //
    const ULONGLONG* Peers() const    { return m_aqwSrcUserIDs;   }
    WORD             PeersLen() const { return m_Msg.cUserIDs; }  
    WORD SetPeers( ULONGLONG* aqwPeers, WORD wLen )
    {
        WORD wPeers = min( wLen, MAX_PEER_SUBSCRIPTIONS);
        memcpy( m_aqwSrcUserIDs, aqwPeers, wPeers * sizeof( ULONGLONG ) );
        m_Msg.cUserIDs = wPeers;
        return wPeers;
    }

private:

    ULONGLONG m_aqwSrcUserIDs[ MAX_PEER_SUBSCRIPTIONS ]; // 100
};


/////////////////////////////////////////////////
// XP MsgPeerSubscribe
//
//  Presence: Subscribe to a set of peers
//
class XPMsgPeerSubscribe : public XPQMsgHdr<P_PEER_SUBSCRIBE_MSG,PMSG_PEER_SUBSCRIBE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgPeerSubscribe() 
    : 
        XPQMsgHdr<P_PEER_SUBSCRIBE_MSG,PMSG_PEER_SUBSCRIBE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgPeerSubscribe( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_PEER_SUBSCRIBE_MSG,PMSG_PEER_SUBSCRIBE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID    = MAKEQWORD(0L,0L);
        m_Msg.cSrcUserIDs = 0;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // SrcUserIDs
    //
    const ULONGLONG* Peers() const    { return m_aqwSrcUserIDs;   }
    WORD             PeersLen() const { return m_Msg.cSrcUserIDs; }  
    WORD SetPeers( ULONGLONG* aqwPeers, WORD wLen )
    {
        WORD wPeers = min( wLen, MAX_PEER_SUBSCRIPTIONS);
        memcpy( m_aqwSrcUserIDs, aqwPeers, wPeers * sizeof( ULONGLONG ) );
        m_Msg.cSrcUserIDs = wPeers;
        return wPeers;
    }

private:

    ULONGLONG m_aqwSrcUserIDs[ MAX_PEER_SUBSCRIPTIONS ]; // 100
};



/////////////////////////////////////////////////
// XP MsgPeerUnsubscribe
//
//  Presence: Peer Unsubscribe
//
class XPMsgPeerUnsubscribe : public XPQMsgHdr<P_PEER_UNSUBSCRIBE_MSG,PMSG_PEER_UNSUBSCRIBE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgPeerUnsubscribe() 
    : 
        XPQMsgHdr<P_PEER_UNSUBSCRIBE_MSG,PMSG_PEER_UNSUBSCRIBE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgPeerUnsubscribe( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_PEER_UNSUBSCRIBE_MSG,PMSG_PEER_UNSUBSCRIBE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID = MAKEQWORD(0L,0L);
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }  
};

/////////////////////////////////////////////////
// XP MsgPeerSession
//
//  Presence: Get Peer Session Info
//
class XPMsgPeerSession : public XPQMsgHdr<P_PEER_SESSION_MSG,PMSG_PEER_SESSION>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgPeerSession() 
    : 
        XPQMsgHdr<P_PEER_SESSION_MSG,PMSG_PEER_SESSION>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgPeerSession( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_PEER_SESSION_MSG,PMSG_PEER_SESSION>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID     = MAKEQWORD(0L,0L);
        m_Msg.qwHostUserID = MAKEQWORD(0L,0L);
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Host Id
    //
    ULONGLONG HostId() const                      { return m_Msg.qwHostUserID;         }
    void      SetHostId( ULONGLONG qwHostUserID ) { m_Msg.qwHostUserID = qwHostUserID; }
};

/////////////////////////////////////////////////
// XP MsgAddAffiliates
//
//  Presence: Add affiliates relationships
//
class XPMsgAddAffiliates : public XPQMsgHdr<P_ADD_AFFILIATES_MSG,PMSG_ADD_AFFILIATES>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgAddAffiliates() 
    : 
        XPQMsgHdr<P_ADD_AFFILIATES_MSG,PMSG_ADD_AFFILIATES>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgAddAffiliates( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_ADD_AFFILIATES_MSG,PMSG_ADD_AFFILIATES>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwSenderID     = MAKEQWORD(0L,0L);
        m_Msg.dwListFlag     = 0;
        m_Msg.dwTitleID      = 0;
        m_Msg.cwAffiliates   = 0;
    }

    ///////////////////////////////////
    // Sender Id
    //
    ULONGLONG SenderId() const                    { return m_Msg.qwSenderID;     }
    void      SetSenderId( ULONGLONG qwSenderId ) { m_Msg.qwSenderID = qwSenderId; }

    ///////////////////////////////////
    // List Flag
    //
    DWORD     ListFlag() const                   { return m_Msg.dwListFlag;         }
    void      SetListFlag( DWORD dwListFlag )    { m_Msg.dwListFlag = dwListFlag;    }

    ///////////////////////////////////
    // Title ID
    //
    DWORD     TitleId() const                     { return m_Msg.dwTitleID;         }
    void      SetTitleId( DWORD dwTitleId )       { m_Msg.dwTitleID = dwTitleId; }

    ///////////////////////////////////
    // Affiliate PUID array 
    //
    const ULONGLONG* Affiliates() const    { return m_aqwAffiliateIDs;   }
    WORD             AffiliatesLen() const { return m_Msg.cwAffiliates; }  
    WORD             SetAffiliates( ULONGLONG* aqwAffiliates, WORD wLen )
    {
        WORD cwAffiliates = min( wLen, X_ADD_AFFILIATE_MAX );
        memcpy( m_aqwAffiliateIDs, aqwAffiliates, cwAffiliates * sizeof( ULONGLONG ) );
        m_Msg.cwAffiliates = cwAffiliates;
        
        return cwAffiliates;
    }

    void ValidateAffiliates()
    {
        for(WORD i = 0; i < m_Msg.cwAffiliates; ++i)
        {
            _ASSERTE(0 != m_aqwAffiliateIDs[i]);
        }
    }
private:
    ULONGLONG m_aqwAffiliateIDs[ X_ADD_AFFILIATE_MAX ]; // 16
};

/////////////////////////////////////////////////
// XP MsgIsAffiliate
//
//  Presence: Test single affiliate relationship
//
class XPMsgIsAffiliate : public XPQMsgHdr<P_IS_AFFILIATE_MSG,PMSG_IS_AFFILIATE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgIsAffiliate() 
    : 
        XPQMsgHdr<P_IS_AFFILIATE_MSG,PMSG_IS_AFFILIATE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgIsAffiliate( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_IS_AFFILIATE_MSG,PMSG_IS_AFFILIATE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwSenderID     = MAKEQWORD(0L,0L);
        m_Msg.qwAffiliateID  = MAKEQWORD(0L,0L);
    }

    ///////////////////////////////////
    // Sender Id
    //
    ULONGLONG SenderId() const                          { return m_Msg.qwSenderID;     }
    void      SetSenderId( ULONGLONG qwSenderId )       { m_Msg.qwSenderID = qwSenderId; }
    
    ///////////////////////////////////
    //  Affiliate Id
    //
    ULONGLONG AffiliateId() const                       { return m_Msg.qwSenderID;     }
    void      SetAffiliateId( ULONGLONG qwAffiliateId ) { m_Msg.qwAffiliateID = qwAffiliateId; }
};

/////////////////////////////////////////////////
// XP MsgQueryAffiliates
//
//  Presence: Request affiliate information
//
class XPMsgQueryAffiliates : public XPQMsgHdr<P_QUERY_AFFILIATES_MSG,PMSG_QUERY_AFFILIATES>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgQueryAffiliates() 
        : 
        XPQMsgHdr<P_QUERY_AFFILIATES_MSG,PMSG_QUERY_AFFILIATES>( XPQSgAddr() )
        {
            SetDefaults();
        }

    XPMsgQueryAffiliates( const XPQSgAddr& rSgAddr )
        :
        XPQMsgHdr<P_QUERY_AFFILIATES_MSG,PMSG_QUERY_AFFILIATES>( rSgAddr )
        {
            SetDefaults();
        }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwSenderID      = MAKEQWORD(0L,0L);
        m_Msg.dwListFlags     = 0;
        m_Msg.cdwLimit        = 0;
        m_Msg.dwOnlineTitleID = 0;
    }

    ///////////////////////////////////
    // Sender Id
    //
    ULONGLONG SenderId() const                    { return m_Msg.qwSenderID;     }
    void      SetSenderId( ULONGLONG qwSenderId ) { m_Msg.qwSenderID = qwSenderId; }

    ///////////////////////////////////
    // List flags
    //
    DWORD     ListFlags() const                   { return m_Msg.dwListFlags;     }
    void      SetListFlags( DWORD dwListFlags )   { m_Msg.dwListFlags = dwListFlags; }
    
    ///////////////////////////////////
    // Sender Id
    //
    DWORD     Limit() const                       { return m_Msg.cdwLimit;     }
    void      SetLimit( DWORD cdwLimit )          { m_Msg.cdwLimit = cdwLimit; }

    ///////////////////////////////////
    // Sender Id
    //
    DWORD     OnlineTitleId() const               { return m_Msg.dwOnlineTitleID;     }
    void      SetOnlineTitleId( DWORD dwTitleID ) { m_Msg.dwOnlineTitleID = dwTitleID; }
};

/////////////////////////////////////////////////
// XP MsgGetPresenceInfo
//
//  Presence: Lookup one block of presence data
//
class XPMsgGetPresenceInfo : public XPQMsgHdr<P_GET_PRESENCE_INFO_MSG,PMSG_GET_PRESENCE_INFO>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgGetPresenceInfo() 
        : 
        XPQMsgHdr<P_GET_PRESENCE_INFO_MSG,PMSG_GET_PRESENCE_INFO>( XPQSgAddr() )
        {
            SetDefaults();
        }

    XPMsgGetPresenceInfo( const XPQSgAddr& rSgAddr )
        :
        XPQMsgHdr<P_GET_PRESENCE_INFO_MSG,PMSG_GET_PRESENCE_INFO>( rSgAddr )
        {
            SetDefaults();
        }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.dwContext       = 0;
        m_Msg.qwSenderID      = MAKEQWORD(0L,0L);
        m_Msg.cdwUsers        = 0;
    }

    ULONGLONG SenderId() const                    { return m_Msg.qwSenderID;     }
    void      SetSenderId( ULONGLONG qwSenderId ) { m_Msg.qwSenderID = qwSenderId; }

    void      SetTarget( ULONGLONG qwTargetId )   
    { 
        m_qwTargetId = qwTargetId; 
        if(0 != qwTargetId)
        {
            m_Msg.cdwUsers = 1;  
        }
    }

private:
    ULONGLONG m_qwTargetId;
};
/////////////////////////////////////////////////
// XP MsgInvalidateUser
//
//  Presence: refresh the users data from database
//
class XPMsgInvalidateUser : public XPQMsgHdr<P_INVALIDATE_USER_MSG,PMSG_INVALIDATE_USER>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgInvalidateUser() 
        : 
        XPQMsgHdr<P_INVALIDATE_USER_MSG,PMSG_INVALIDATE_USER>( XPQSgAddr() )
        {
            SetDefaults();
        }

    XPMsgInvalidateUser( const XPQSgAddr& rSgAddr )
        :
        XPQMsgHdr<P_INVALIDATE_USER_MSG,PMSG_INVALIDATE_USER>( rSgAddr )
        {
            SetDefaults();
        }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID        = MAKEQWORD(0L,0L);
    }

    ULONGLONG UserId() const                    { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId )   { m_Msg.qwUserID = qwUserId; }
};

/////////////////////////////////////////////////
// XP MsgFindUser
//
//  Presence: lookup a user with puid or gamertag
//
class XPMsgFindUser : public XPQMsgHdr<P_FIND_USER_MSG,PMSG_FIND_USER>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgFindUser() 
        : 
        XPQMsgHdr<P_FIND_USER_MSG,PMSG_FIND_USER>( XPQSgAddr() )
        {
            SetDefaults();
        }

    XPMsgFindUser( const XPQSgAddr& rSgAddr )
        :
        XPQMsgHdr<P_FIND_USER_MSG,PMSG_FIND_USER>( rSgAddr )
        {
            SetDefaults();
        }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID      = MAKEQWORD(0L,0L);
        m_Msg.qwFindID      = 0;
        m_Msg.szGamerTag[0] = MAKEQWORD(0L,0L);;
    }

    ULONGLONG   UserId() const                          { return m_Msg.qwUserID;     }
    void        SetUserId( ULONGLONG qwUserId )       { m_Msg.qwUserID = qwUserId; }

    ULONGLONG   FindId() const                          { return m_Msg.qwFindID;     }
    void        SetFindId( ULONGLONG qwFindId )         { m_Msg.qwFindID = qwFindId; }
    
    const char* GamerTag() const                        { return m_Msg.szGamerTag;     }
    void        SetGamerTag( const char *pszGamerTag )  { strncpy(m_Msg.szGamerTag, pszGamerTag, XONLINE_GAMERTAG_SIZE); }
};

/////////////////////////////////////////////////
// XP MsgFindUsers
//
//  Presence: lookup users with puid or gamertag
//
class XPMsgFindUsers : public XPQMsgHdr<P_FIND_USERS_MSG,PMSG_FIND_USERS>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgFindUsers() 
        : 
        XPQMsgHdr<P_FIND_USERS_MSG,PMSG_FIND_USERS>( XPQSgAddr() )
        {
            SetDefaults();
        }

    XPMsgFindUsers( const XPQSgAddr& rSgAddr )
        :
        XPQMsgHdr<P_FIND_USERS_MSG,PMSG_FIND_USERS>( rSgAddr )
        {
            SetDefaults();
        }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID      = MAKEQWORD(0L,0L);
		m_Msg.cdwQueries    = 0;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ULONGLONG   UserId() const                          { return m_Msg.qwUserID;     }
    void        SetUserId( ULONGLONG qwUserId )       { m_Msg.qwUserID = qwUserId; }

	const P_FIND_USERS_DATA* Finds() const    { return m_FindUsersData;   }
    DWORD                    FindsLen() const { return m_Msg.cdwQueries;  }  
    
	DWORD AddFinds( P_FIND_USERS_DATA* Finds, WORD wLen )
    {
        DWORD wFinds = min( wLen, MAX_BUDDIES - m_Msg.cdwQueries );
        memcpy( &(m_FindUsersData[ m_Msg.cdwQueries ]), Finds, wFinds * sizeof( P_FIND_USERS_DATA ) );
        m_Msg.cdwQueries += wFinds;
        return wFinds;
    }

private:
	
	P_FIND_USERS_DATA m_FindUsersData[MAX_BUDDIES];
};

/////////////////////////////////////////////////
// XP MsgCheckTitleMessages
//
//  Presence: do a logon style check of our messages without aliving
//
class XPMsgCheckTitleMessages : public XPQMsgHdr<P_CHECK_TITLE_MESSAGES_MSG,PMSG_CHECK_TITLE_MESSAGES>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgCheckTitleMessages() 
        : 
        XPQMsgHdr<P_CHECK_TITLE_MESSAGES_MSG,PMSG_CHECK_TITLE_MESSAGES>( XPQSgAddr() )
        {
            SetDefaults();
        }

    XPMsgCheckTitleMessages( const XPQSgAddr& rSgAddr )
        :
        XPQMsgHdr<P_CHECK_TITLE_MESSAGES_MSG,PMSG_CHECK_TITLE_MESSAGES>( rSgAddr )
        {
            SetDefaults();
        }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID        = MAKEQWORD(0L,0L);
        m_Msg.dwTitleID       = 0;
        m_Msg.dwAltTitleID1   = 0;
        m_Msg.dwAltTitleID2   = 0;
        m_Msg.dwAltTitleID3   = 0;
        m_Msg.dwAltTitleID4   = 0;
        m_Msg.dwTitleVersion  = 0;
        m_Msg.dwTitleRegion   = 0;
    }

    ULONGLONG UserId() const                        { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId )       { m_Msg.qwUserID = qwUserId; }

    DWORD     TitleId() const                       { return m_Msg.dwTitleID;     }
    void      SetTitleId( DWORD dwTitleId )         { m_Msg.dwTitleID = dwTitleId; }

    DWORD     AltTitleId1() const                   { return m_Msg.dwAltTitleID1;     }
    void      SetAltTitleId1( DWORD dwTitleId )     { m_Msg.dwAltTitleID1 = dwTitleId; }

    DWORD     AltTitleId2() const                   { return m_Msg.dwAltTitleID2;     }
    void      SetAltTitleId2( DWORD dwTitleId )     { m_Msg.dwAltTitleID2 = dwTitleId; }

    DWORD     AltTitleId3() const                   { return m_Msg.dwAltTitleID3;     }
    void      SetAltTitleId3( DWORD dwTitleId )     { m_Msg.dwAltTitleID3 = dwTitleId; }

    DWORD     AltTitleId4() const                   { return m_Msg.dwAltTitleID4;     }
    void      SetAltTitleId4( DWORD dwTitleId )     { m_Msg.dwAltTitleID4 = dwTitleId; }

    DWORD     TitleVersion() const                  { return m_Msg.dwTitleVersion;     }
    void      SetTitleVersion( DWORD dwTitleVersion ){ m_Msg.dwTitleVersion = dwTitleVersion; }

    DWORD     TitleRegion() const               { return m_Msg.dwTitleRegion;     }
    void      SetTitleRegion( DWORD dwTitleRegion ) { m_Msg.dwTitleRegion = dwTitleRegion; }
};

/////////////////////////////////////////////////
// XT MsgListTeams
//
//  Teams: List Teams
//
class XTMsgListTeams : public XPQMsgHdr<P_TEAM_LIST_TEAMS_MSG,PMSG_TEAM_LIST_TEAMS>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XTMsgListTeams() 
    : 
        XPQMsgHdr<P_TEAM_LIST_TEAMS_MSG,PMSG_TEAM_LIST_TEAMS>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XTMsgListTeams( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_TEAM_LIST_TEAMS_MSG,PMSG_TEAM_LIST_TEAMS>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID  = MAKEQWORD(0L,0L);
        m_Msg.dwTitleID = 0;
        m_Msg.cTeamIDs  = 0;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleID ) { m_Msg.dwTitleID = dwTitleID; }

    ///////////////////////////////////
    // Team Ids
    //
    const ULONGLONG* TeamIds() const    { return m_aqwTeamIds;   }
    DWORD            TeamIdsLen() const { return m_Msg.cTeamIDs; }  
    DWORD AddTeamIds( ULONGLONG* aqwTeamIds, WORD wLen )
    {
        if(wLen > 0)
        {
            DWORD wAdded = min( wLen, XONLINE_MAX_TEAM_COUNT - m_Msg.cTeamIDs );
            memcpy( &(m_aqwTeamIds[ m_Msg.cTeamIDs ]), aqwTeamIds, wAdded * sizeof( ULONGLONG ) );
            m_Msg.cTeamIDs += wAdded;
            return wAdded;
        }
        else
        {
            return 0;
        }
    }

private:

    ULONGLONG m_aqwTeamIds[ XONLINE_MAX_TEAM_COUNT ]; // 8
};

/////////////////////////////////////////////////
// XT MsgListTeamMembers
//
//  Teams: List Teams
//
class XTMsgListTeamMembers : public XPQMsgHdr<P_TEAM_LIST_MEMBERS_MSG,PMSG_TEAM_LIST_MEMBERS>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XTMsgListTeamMembers() 
    : 
        XPQMsgHdr<P_TEAM_LIST_MEMBERS_MSG,PMSG_TEAM_LIST_MEMBERS>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XTMsgListTeamMembers( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_TEAM_LIST_MEMBERS_MSG,PMSG_TEAM_LIST_MEMBERS>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID      = MAKEQWORD(0L,0L);
        m_Msg.dwTitleID     = 0;
        m_Msg.qwTeamID      = MAKEQWORD(0L,0L);
        m_Msg.fShowRecruits = FALSE;
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleID ) { m_Msg.dwTitleID = dwTitleID; }

    ///////////////////////////////////
    // Team Id
    //
    ULONGLONG TeamId() const                  { return m_Msg.qwTeamID;     }
    void      SetTeamId( ULONGLONG qwTeamId ) { m_Msg.qwTeamID = qwTeamId; }

    ///////////////////////////////////
    // Team Id
    //
    BOOL ShowRecruits() const                  { return m_Msg.fShowRecruits;          }
    void SetShowRecruits( BOOL fShowRecruits ) { m_Msg.fShowRecruits = fShowRecruits; }
};

/////////////////////////////////////////////////
// XT MsgTeamCreate
//
//  Teams: Create a Team
//
class XTMsgTeamCreate : public XPQMsgHdr<P_TEAM_CREATE_MSG,PMSG_TEAM_CREATE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XTMsgTeamCreate() 
    : 
        XPQMsgHdr<P_TEAM_CREATE_MSG,PMSG_TEAM_CREATE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XTMsgTeamCreate( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_TEAM_CREATE_MSG,PMSG_TEAM_CREATE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID          = MAKEQWORD(0L,0L);
        m_Msg.dwTitleID         = 0;
        m_Msg.dwMaxMembers      = 0;
        m_Msg.cbTeamName        = 0;
        m_Msg.cbTeamDescription = 0;
        m_Msg.cbTeamMotto       = 0;
        m_Msg.cbTeamURL         = 0;
        m_Msg.cbTeamData        = 0;
        m_Msg.cbCreatorData     = 0;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleID ) { m_Msg.dwTitleID = dwTitleID; }

    ///////////////////////////////////
    // Max Members
    //
    ULONGLONG MaxMembers() const                  { return m_Msg.dwMaxMembers;         }
    void      SetMaxMembers( DWORD dwMaxMembers ) { m_Msg.dwMaxMembers = dwMaxMembers; }

    ///////////////////////////////////
    // Team Name
    //
    LPCWSTR TeamName() const    { return m_wszTeamName;    }
    WORD    TeamNameLen() const { return m_Msg.cbTeamName; }
    void SetTeamName( LPCWSTR wszTeamName, WORD wLen )
    {
        m_Msg.cbTeamName = SetData<WCHAR>( wszTeamName, wLen, m_wszTeamName, MAX_TEAM_NAME_BYTES );
    }
    void SetTeamName( LPCWSTR wszTeamName )
    {
        m_Msg.cbTeamName = SetNullTermWCharData( wszTeamName, m_wszTeamName, MAX_TEAM_NAME_CHAR );
    }

    ///////////////////////////////////
    // Team Description
    //
    LPCWSTR TeamDescription() const    { return m_wszTeamDescription;    }
    WORD    TeamDescriptionLen() const { return m_Msg.cbTeamDescription; }
    void SetTeamDescription( LPCWSTR wszTeamDescription, WORD wLen )
    {
        m_Msg.cbTeamDescription = SetData<WCHAR>( wszTeamDescription, wLen, m_wszTeamDescription, MAX_TEAM_DESCRIPTION_BYTES );
    }
    void SetTeamDescription( LPCWSTR wszTeamDescription )
    {
        m_Msg.cbTeamDescription = SetNullTermWCharData( wszTeamDescription, m_wszTeamDescription, MAX_TEAM_DESCRIPTION_CHAR );
    }

    ///////////////////////////////////
    // Team Motto
    //
    LPCWSTR TeamMotto() const    { return m_wszTeamMotto;    }
    WORD    TeamMottoLen() const { return m_Msg.cbTeamMotto; }
    void SetTeamMotto( LPCWSTR wszTeamMotto, WORD wLen )
    {
        m_Msg.cbTeamMotto = SetData<WCHAR>( wszTeamMotto, wLen, m_wszTeamMotto, MAX_TEAM_MOTTO_BYTES );
    }
    void SetTeamMotto( LPCWSTR wszTeamMotto )
    {
        m_Msg.cbTeamMotto = SetNullTermWCharData( wszTeamMotto, m_wszTeamMotto, MAX_TEAM_MOTTO_CHAR );
    }

    ///////////////////////////////////
    // Team URL
    //
    LPCWSTR TeamURL() const    { return m_wszTeamURL;    }
    WORD    TeamURLLen() const { return m_Msg.cbTeamURL; }
    void SetTeamURL( LPCWSTR wszTeamURL, WORD wLen )
    {
        m_Msg.cbTeamURL = SetData<WCHAR>( wszTeamURL, wLen, m_wszTeamURL, MAX_TEAM_URL_BYTES );
    }
    void SetTeamURL( LPCWSTR wszTeamURL )
    {
        m_Msg.cbTeamURL = SetNullTermWCharData( wszTeamURL, m_wszTeamURL, MAX_TEAM_URL_CHAR );
    }

    ///////////////////////////////////
    // Team Data
    //
    const BYTE* TeamData() const    { return m_pbTeamData;     }
    WORD        TeamDataLen() const { return m_Msg.cbTeamData; }
    void SetTeamData( const BYTE* pbData, WORD wLen )
    {
        m_Msg.cbTeamData = SetData<BYTE>( pbData, wLen, m_pbTeamData, MAX_TEAM_DATA_BYTES );
    }

    ///////////////////////////////////
    // Creator Data
    //
    const BYTE* CreatorData() const    { return m_pbCreatorData;     }
    WORD        CreatorDataLen() const { return m_Msg.cbCreatorData; }
    void SetCreatorData( const BYTE* pbData, WORD wLen )
    {
        m_Msg.cbCreatorData = SetData<BYTE>( pbData, wLen, m_pbCreatorData, MAX_TEAM_MEMBER_DATA_BYTES );
    }

private:

    WCHAR m_wszTeamName[        MAX_TEAM_NAME_CHAR         ];
    WCHAR m_wszTeamDescription[ MAX_TEAM_DESCRIPTION_CHAR  ];
    WCHAR m_wszTeamMotto[       MAX_TEAM_MOTTO_CHAR        ];
    WCHAR m_wszTeamURL[         MAX_TEAM_URL_CHAR          ];
    BYTE  m_pbTeamData[         MAX_TEAM_DATA_BYTES        ];
    BYTE  m_pbCreatorData[      MAX_TEAM_MEMBER_DATA_BYTES ];
};

/////////////////////////////////////////////////
// XT MsgTeamDelete
//
//  Teams: Delete a Team
//
class XTMsgTeamDelete : public XPQMsgHdr<P_TEAM_DELETE_MSG,PMSG_TEAM_DELETE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XTMsgTeamDelete() 
    : 
        XPQMsgHdr<P_TEAM_DELETE_MSG,PMSG_TEAM_DELETE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XTMsgTeamDelete( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_TEAM_DELETE_MSG,PMSG_TEAM_DELETE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID  = MAKEQWORD(0L,0L);
        m_Msg.dwTitleID = 0;
        m_Msg.qwTeamID  = MAKEQWORD(0L,0L);
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleID ) { m_Msg.dwTitleID = dwTitleID; }

    ///////////////////////////////////
    // Team Id
    //
    ULONGLONG TeamId() const                  { return m_Msg.qwTeamID;     }
    void      SetTeamId( ULONGLONG qwTeamId ) { m_Msg.qwTeamID = qwTeamId; }
};

/////////////////////////////////////////////////
// XT MsgTeamRemove
//
//  Teams: Remove a Team Member
//
class XTMsgTeamRemove : public XPQMsgHdr<P_TEAM_REMOVE_MSG,PMSG_TEAM_REMOVE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XTMsgTeamRemove() 
    : 
        XPQMsgHdr<P_TEAM_REMOVE_MSG,PMSG_TEAM_REMOVE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XTMsgTeamRemove( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_TEAM_REMOVE_MSG,PMSG_TEAM_REMOVE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID   = MAKEQWORD(0L,0L);
        m_Msg.dwTitleID  = 0;
        m_Msg.qwTeamID   = MAKEQWORD(0L,0L);
        m_Msg.qwMemberID = MAKEQWORD(0L,0L);
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const                   { return m_Msg.dwTitleID;  }
    void  SetTitleId( DWORD dwTitleID ) { m_Msg.dwTitleID = dwTitleID; }

    ///////////////////////////////////
    // Team Id
    //
    ULONGLONG TeamId() const                  { return m_Msg.qwTeamID;     }
    void      SetTeamId( ULONGLONG qwTeamId ) { m_Msg.qwTeamID = qwTeamId; }

    ///////////////////////////////////
    // Member Id
    //
    ULONGLONG MemberId() const                  { return m_Msg.qwMemberID;         }
    void      SetMemberId( ULONGLONG qwMemberId ) { m_Msg.qwMemberID = qwMemberId; }
};

/////////////////////////////////////////////////
// XT MsgTeamManageTeam
//
//  Teams: Manage a Team
//
class XTMsgTeamManageTeam : public XPQMsgHdr<P_TEAM_MANAGE_TEAM_MSG,PMSG_TEAM_MANAGE_TEAM>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XTMsgTeamManageTeam() 
    : 
        XPQMsgHdr<P_TEAM_MANAGE_TEAM_MSG,PMSG_TEAM_MANAGE_TEAM>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XTMsgTeamManageTeam( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_TEAM_MANAGE_TEAM_MSG,PMSG_TEAM_MANAGE_TEAM>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID          = MAKEQWORD(0L,0L);
        m_Msg.dwTitleID         = 0;
        m_Msg.qwTeamID          = MAKEQWORD(0L,0L);
        m_Msg.cbTeamName        = 0;
        m_Msg.cbTeamDescription = 0;
        m_Msg.cbTeamMotto       = 0;
        m_Msg.cbTeamURL         = 0;
        m_Msg.cbTeamData        = 0;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const                   { return m_Msg.dwTitleID;  }
    void  SetTitleId( DWORD dwTitleID ) { m_Msg.dwTitleID = dwTitleID; }

    ///////////////////////////////////
    // Team Id
    //
    ULONGLONG TeamId() const                  { return m_Msg.qwTeamID;     }
    void      SetTeamId( ULONGLONG qwTeamId ) { m_Msg.qwTeamID = qwTeamId; }

    ///////////////////////////////////
    // Team Name
    //
    LPCWSTR TeamName() const    { return m_wszTeamName;    }
    WORD    TeamNameLen() const { return m_Msg.cbTeamName; }
    void SetTeamName( LPCWSTR wszTeamName, WORD wLen )
    {
        m_Msg.cbTeamName = SetData<WCHAR>( wszTeamName, wLen, m_wszTeamName, MAX_TEAM_NAME_BYTES );
    }
    void SetTeamName( LPCWSTR wszTeamName )
    {
        m_Msg.cbTeamName = SetNullTermWCharData( wszTeamName, m_wszTeamName, MAX_TEAM_NAME_CHAR );
    }

    ///////////////////////////////////
    // Team Description
    //
    LPCWSTR TeamDescription() const    { return m_wszTeamDescription;    }
    WORD    TeamDescriptionLen() const { return m_Msg.cbTeamDescription; }
    void SetTeamDescription( LPCWSTR wszTeamDescription, WORD wLen )
    {
        m_Msg.cbTeamDescription = SetData<WCHAR>( wszTeamDescription, wLen, m_wszTeamDescription, MAX_TEAM_DESCRIPTION_BYTES );
    }
    void SetTeamDescription( LPCWSTR wszTeamDescription )
    {
        m_Msg.cbTeamDescription = SetNullTermWCharData( wszTeamDescription, m_wszTeamDescription, MAX_TEAM_DESCRIPTION_CHAR );
    }

    ///////////////////////////////////
    // Team Motto
    //
    LPCWSTR TeamMotto() const    { return m_wszTeamMotto;    }
    WORD    TeamMottoLen() const { return m_Msg.cbTeamMotto; }
    void SetTeamMotto( LPCWSTR wszTeamMotto, WORD wLen )
    {
        m_Msg.cbTeamMotto = SetData<WCHAR>( wszTeamMotto, wLen, m_wszTeamMotto, MAX_TEAM_MOTTO_BYTES );
    }
    void SetTeamMotto( LPCWSTR wszTeamMotto )
    {
        m_Msg.cbTeamMotto = SetNullTermWCharData( wszTeamMotto, m_wszTeamMotto, MAX_TEAM_MOTTO_CHAR );
    }

    ///////////////////////////////////
    // Team URL
    //
    LPCWSTR TeamURL() const    { return m_wszTeamURL;    }
    WORD    TeamURLLen() const { return m_Msg.cbTeamURL; }
    void SetTeamURL( LPCWSTR wszTeamURL, WORD wLen )
    {
        m_Msg.cbTeamURL = SetData<WCHAR>( wszTeamURL, wLen, m_wszTeamURL, MAX_TEAM_URL_BYTES );
    }
    void SetTeamURL( LPCWSTR wszTeamURL )
    {
        m_Msg.cbTeamURL = SetNullTermWCharData( wszTeamURL, m_wszTeamURL, MAX_TEAM_URL_CHAR );
    }

    ///////////////////////////////////
    // Team Data
    //
    const BYTE* TeamData() const    { return m_pbTeamData;     }
    WORD        TeamDataLen() const { return m_Msg.cbTeamData; }
    void SetTeamData( const BYTE* pbData, WORD wLen )
    {
        m_Msg.cbTeamData = SetData<BYTE>( pbData, wLen, m_pbTeamData, MAX_TEAM_DATA_BYTES );
    }

private:

    WCHAR m_wszTeamName[        MAX_TEAM_NAME_CHAR        ];
    WCHAR m_wszTeamDescription[ MAX_TEAM_DESCRIPTION_CHAR ];
    WCHAR m_wszTeamMotto[       MAX_TEAM_MOTTO_CHAR       ];
    WCHAR m_wszTeamURL[         MAX_TEAM_URL_CHAR         ];
    BYTE  m_pbTeamData[         MAX_TEAM_DATA_BYTES       ];
};

/////////////////////////////////////////////////
// XT MsgTeamManageMember
//
//  Teams: Manage a Team Member
//
class XTMsgTeamManageMember : public XPQMsgHdr<P_TEAM_MANAGE_MEMBER_MSG,PMSG_TEAM_MANAGE_MEMBER>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XTMsgTeamManageMember() 
    : 
        XPQMsgHdr<P_TEAM_MANAGE_MEMBER_MSG,PMSG_TEAM_MANAGE_MEMBER>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XTMsgTeamManageMember( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_TEAM_MANAGE_MEMBER_MSG,PMSG_TEAM_MANAGE_MEMBER>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID     = MAKEQWORD(0L,0L);
        m_Msg.dwTitleID    = 0;
        m_Msg.qwTeamID     = MAKEQWORD(0L,0L);
        m_Msg.qwMemberID   = MAKEQWORD(0L,0L);
        m_Msg.dwMemberPriv = 0;
        m_Msg.cbMemberData = 0;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleID ) { m_Msg.dwTitleID = dwTitleID; }

    ///////////////////////////////////
    // Team Id
    //
    ULONGLONG TeamId() const                  { return m_Msg.qwTeamID;     }
    void      SetTeamId( ULONGLONG qwTeamId ) { m_Msg.qwTeamID = qwTeamId; }

    ///////////////////////////////////
    // Member Id
    //
    ULONGLONG MemberId() const                  { return m_Msg.qwMemberID;         }
    void      SetMemberId( ULONGLONG qwMemberId ) { m_Msg.qwMemberID = qwMemberId; }

    ///////////////////////////////////
    // Member Priv
    //
    DWORD MemberPriv() const                  { return m_Msg.dwMemberPriv;         }
    void  SetMemberPriv( DWORD dwMemberPriv ) { m_Msg.dwMemberPriv = dwMemberPriv; }

    ///////////////////////////////////
    // Member Data
    //
    const BYTE* MemberData() const    { return m_pbMemberData;   }
    WORD        MemberDataLen() const { return m_Msg.cbMemberData; }
    void SetMemberData( const BYTE* pbData, WORD wLen )
    {
        m_Msg.cbMemberData = SetData<BYTE>( pbData, wLen, m_pbMemberData, MAX_TEAM_MEMBER_DATA_BYTES );
    }

private:

    BYTE m_pbMemberData[ MAX_TEAM_MEMBER_DATA_BYTES ];
};

/////////////////////////////////////////////////
// XT MsgTeamRecruit
//
//  Teams: Recruit a user to a Team
//
class XTMsgTeamRecruit : public XPQMsgHdr<P_TEAM_RECRUIT_MSG,PMSG_TEAM_RECRUIT>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XTMsgTeamRecruit() 
    : 
        XPQMsgHdr<P_TEAM_RECRUIT_MSG,PMSG_TEAM_RECRUIT>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XTMsgTeamRecruit( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_TEAM_RECRUIT_MSG,PMSG_TEAM_RECRUIT>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID       = MAKEQWORD(0L,0L);
        m_Msg.dwTitleID      = 0;
        m_Msg.qwTeamID       = MAKEQWORD(0L,0L);
        m_Msg.qwMemberID     = MAKEQWORD(0L,0L);
        m_Msg.dwMemberPriv   = 0;
        m_Msg.dwMessageFlags = 0;
        m_Msg.cbMemberData   = 0;
        m_Msg.cbDetails      = 0;

        memset( &(m_Msg.szMemberName), 0, XONLINE_GAMERTAG_SIZE * sizeof( CHAR) );
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleID ) { m_Msg.dwTitleID = dwTitleID; }

    ///////////////////////////////////
    // Team Id
    //
    ULONGLONG TeamId() const                  { return m_Msg.qwTeamID;     }
    void      SetTeamId( ULONGLONG qwTeamId ) { m_Msg.qwTeamID = qwTeamId; }

    ///////////////////////////////////
    // Member Id
    //
    ULONGLONG MemberId() const                    { return m_Msg.qwMemberID;       }
    void      SetMemberId( ULONGLONG qwMemberId ) { m_Msg.qwMemberID = qwMemberId; }

    ///////////////////////////////////
    // Member Priv
    //
    DWORD MemberPriv() const                  { return m_Msg.dwMemberPriv;         }
    void  SetMemberPriv( DWORD dwMemberPriv ) { m_Msg.dwMemberPriv = dwMemberPriv; }

    ///////////////////////////////////
    // Message Flags
    //
    DWORD MessageFlags() const                    { return m_Msg.dwMessageFlags;           }
    void  SetMessageFlags( DWORD dwMessageFlags ) { m_Msg.dwMessageFlags = dwMessageFlags; }

    ///////////////////////////////////
    // Member Data
    //
    const BYTE* MemberData() const    { return m_pbMemberData;     }
    WORD        MemberDataLen() const { return m_Msg.cbMemberData; }
    void SetMemberData( const BYTE* pbData, WORD wLen )
    {
        m_Msg.cbMemberData = SetData<BYTE>( pbData, wLen, m_pbMemberData, MAX_TEAM_MEMBER_DATA_BYTES );
    }

    ///////////////////////////////////
    // Message Details
    //
    const BYTE* Details() const    { return m_abDetails;     }
    WORD        DetailsLen() const { return m_Msg.cbDetails; }  
    void AddDetails( const BYTE* abDetails, WORD wLen )
    {
        memcpy_s ( m_abDetails, sizeof(m_abDetails), abDetails, wLen);
        m_Msg.cbDetails = min(wLen, sizeof(m_abDetails));
    }

private:

    BYTE m_abDetails   [ XONLINE_MAX_MESSAGE_DETAILS ]; // 4096
    BYTE m_pbMemberData[ MAX_TEAM_MEMBER_DATA_BYTES  ];
};

/////////////////////////////////////////////////
// XT MsgTeamJoin
//
//  Teams: Answer a team recruit
//
class XTMsgTeamJoin : public XPQMsgHdr<P_TEAM_JOIN_MSG,PMSG_TEAM_JOIN>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XTMsgTeamJoin() 
    : 
        XPQMsgHdr<P_TEAM_JOIN_MSG,PMSG_TEAM_JOIN>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XTMsgTeamJoin( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_TEAM_JOIN_MSG,PMSG_TEAM_JOIN>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID       = MAKEQWORD(0L,0L);
        m_Msg.dwTitleID      = 0;
        m_Msg.qwTeamID       = MAKEQWORD(0L,0L);
        m_Msg.dwRecruitMsgID = MAKEQWORD(0L,0L);
        m_Msg.bAnswer        = 0;
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleID ) { m_Msg.dwTitleID = dwTitleID; }

    ///////////////////////////////////
    // Team Id
    //
    ULONGLONG TeamId() const                  { return m_Msg.qwTeamID;     }
    void      SetTeamId( ULONGLONG qwTeamId ) { m_Msg.qwTeamID = qwTeamId; }

    ///////////////////////////////////
    // Recruit Msg ID
    //
    DWORD RecruitMsgId() const                    { return m_Msg.dwRecruitMsgID;           }
    void  SetRecruitMsgId( DWORD dwRecruitMsgId ) { m_Msg.dwRecruitMsgID = dwRecruitMsgId; }

    ///////////////////////////////////
    // Answer
    //
    DWORD Answer() const            { return m_Msg.bAnswer; }
    void  SetAnswer( BYTE bAnswer ) { m_Msg.bAnswer = bAnswer; }
};

/////////////////////////////////////////////////
// XT MsgTeamGetTicket
//
//  Teams: Get a Team ticket
//
class XTMsgTeamGetTicket : public XPQMsgHdr<P_TEAM_GET_TICKET_MSG,PMSG_TEAM_GET_TICKET>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XTMsgTeamGetTicket() 
    : 
        XPQMsgHdr<P_TEAM_GET_TICKET_MSG,PMSG_TEAM_GET_TICKET>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XTMsgTeamGetTicket( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_TEAM_GET_TICKET_MSG,PMSG_TEAM_GET_TICKET>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID  = MAKEQWORD(0L,0L);
        m_Msg.dwTitleID = 0;
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;     }
    void  SetTitleId( DWORD dwTitleID ) { m_Msg.dwTitleID = dwTitleID; }
};

/////////////////////////////////////////////////
// XT MsgListUserTeams
//
//  Teams: retrieve a user's teams including pending 
//  recruited teams.
//
class XTMsgListUserTeams : public XPQMsgHdr<P_TEAM_LIST_USER_TEAMS_MSG,PMSG_TEAM_LIST_USER_TEAMS>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XTMsgListUserTeams() 
    : 
        XPQMsgHdr<P_TEAM_LIST_USER_TEAMS_MSG,PMSG_TEAM_LIST_USER_TEAMS>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XTMsgListUserTeams( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<P_TEAM_LIST_USER_TEAMS_MSG,PMSG_TEAM_LIST_USER_TEAMS>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID  = MAKEQWORD(0L,0L);
        m_Msg.dwTitleID = 0;
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleID ) { m_Msg.dwTitleID = dwTitleID; }
};

/////////////////////////////////////////////////
// XQ MsgDequeue
//
//  Notification: Gets Queue Items
//
class XQMsgDequeue : public XPQMsgHdr<Q_DEQUEUE_MSG,QMSG_DEQUEUE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgDequeue()
    :
        XPQMsgHdr<Q_DEQUEUE_MSG,QMSG_DEQUEUE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgDequeue( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_DEQUEUE_MSG,QMSG_DEQUEUE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID               = MAKEQWORD(0L,0L);
        m_Msg.wQType                 = 0xffff;
        m_Msg.dwStartItemID          = 0L;
        m_Msg.wMaxItems              = 12;
        m_Msg.dwMaxTotalItemDataSize = 256;
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Q Type
    //
    WORD QType() const           { return m_Msg.wQType;   }
    void SetQType( WORD wQType ) { m_Msg.wQType = wQType; }

    ///////////////////////////////////
    // Start Item Id
    //
    DWORD StartItemId() const                  { return m_Msg.dwStartItemID;   }
    void SetStartItemId( DWORD dwStartItemId ) { m_Msg.dwStartItemID = dwStartItemId; }

    ///////////////////////////////////
    // Max Items
    //
    WORD MaxItems() const              { return m_Msg.wMaxItems;   }
    void SetMaxItems( WORD wMaxItems ) { m_Msg.wMaxItems = wMaxItems; }

    ///////////////////////////////////
    // Max Total Item Data Size
    //
    DWORD MaxTotalItemDataSize() const { return m_Msg.dwMaxTotalItemDataSize;   }
    void SetMaxTotalItemDataSize( DWORD dwMaxTotalItemDataSize ) 
    { 
        m_Msg.dwMaxTotalItemDataSize = dwMaxTotalItemDataSize; 
    }
};

/////////////////////////////////////////////////
// XQMsg EnumMessages
//
//  Messaging: Enumerate a user's messages
//
class XQMsgEnumMessages : public XPQMsgHdr<Q_ENUM_MESSAGES_MSG,QMSG_ENUM_MESSAGES>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgEnumMessages()
    :
        XPQMsgHdr<Q_ENUM_MESSAGES_MSG,QMSG_ENUM_MESSAGES>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgEnumMessages( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_ENUM_MESSAGES_MSG,QMSG_ENUM_MESSAGES>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID = MAKEQWORD(0L,0L);
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }
};

/////////////////////////////////////////////////
// XQMsg EnumMessages2
//
//  Messaging: Enumerate a user's messages
//
class XQMsgEnumMessages2 : public XPQMsgHdr<Q_ENUM_MESSAGES_2_MSG,QMSG_ENUM_MESSAGES_2>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgEnumMessages2()
    :
        XPQMsgHdr<Q_ENUM_MESSAGES_2_MSG,QMSG_ENUM_MESSAGES_2>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgEnumMessages2( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_ENUM_MESSAGES_2_MSG,QMSG_ENUM_MESSAGES_2>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID = MAKEQWORD(0L,0L);
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }
};

/////////////////////////////////////////////////
// XQMsg MessageSummary
//
//  Messaging: Retrieve the summary for a message
//
class XQMsgMessageSummary : public XPQMsgHdr<Q_MESSAGE_SUMMARY_MSG,QMSG_MESSAGE_SUMMARY>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgMessageSummary()
    :
        XPQMsgHdr<Q_MESSAGE_SUMMARY_MSG,QMSG_MESSAGE_SUMMARY>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgMessageSummary( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_MESSAGE_SUMMARY_MSG,QMSG_MESSAGE_SUMMARY>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID    = MAKEQWORD(0L,0L);
        m_Msg.dwMessageID = 0;
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Message Id
    //
    DWORD     MessageId() const                 { return m_Msg.dwMessageID;        }
    void      SetMessageId( DWORD dwMessageId ) { m_Msg.dwMessageID = dwMessageId; }
};

/////////////////////////////////////////////////
// XQMsg MessageSummary2
//
//  Messaging: Retrieve the summary for a message
//
class XQMsgMessageSummary2 : public XPQMsgHdr<Q_MESSAGE_SUMMARY_2_MSG,QMSG_MESSAGE_SUMMARY_2>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgMessageSummary2()
    :
        XPQMsgHdr<Q_MESSAGE_SUMMARY_2_MSG,QMSG_MESSAGE_SUMMARY_2>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgMessageSummary2( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_MESSAGE_SUMMARY_2_MSG,QMSG_MESSAGE_SUMMARY_2>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID    = MAKEQWORD(0L,0L);
        m_Msg.dwMessageID = 0;
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Message Id
    //
    DWORD     MessageId() const                 { return m_Msg.dwMessageID;        }
    void      SetMessageId( DWORD dwMessageId ) { m_Msg.dwMessageID = dwMessageId; }
};

/////////////////////////////////////////////////
// XQMsg MessageDetails
//
//  Messaging: Retrieve the summary and details for a message, can also alter flags
//
class XQMsgMessageDetails : public XPQMsgHdr<Q_MESSAGE_DETAILS_MSG,QMSG_MESSAGE_DETAILS>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgMessageDetails()
    :
        XPQMsgHdr<Q_MESSAGE_DETAILS_MSG,QMSG_MESSAGE_DETAILS>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgMessageDetails( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_MESSAGE_DETAILS_MSG,QMSG_MESSAGE_DETAILS>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID     = MAKEQWORD(0L,0L);
        m_Msg.dwMessageID  = 0;
        m_Msg.dwSetFlags   = 0;
        m_Msg.dwUnsetFlags = 0;
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Message Id
    //
    DWORD MessageId() const                 { return m_Msg.dwMessageID;        }
    void  SetMessageId( DWORD dwMessageId ) { m_Msg.dwMessageID = dwMessageId; }

    ///////////////////////////////////
    // Set Flags
    //
    DWORD FlagsToSet() const                { return m_Msg.dwSetFlags;         }
    void  SetFlagsToSet( DWORD dwSetFlags ) { m_Msg.dwSetFlags = dwSetFlags;   }

    ///////////////////////////////////
    // Unset Flags
    //
    DWORD FlagsToClear() const                  { return m_Msg.dwUnsetFlags;         }
    void  SetFlagsToClear( DWORD dwUnsetFlags ) { m_Msg.dwUnsetFlags = dwUnsetFlags; }
};

/////////////////////////////////////////////////
// XQMsg MessageFlags
//
//  Messaging: Change flags on a message
//
class XQMsgMessageFlags : public XPQMsgHdr<Q_MESSAGE_FLAGS_MSG,QMSG_MESSAGE_FLAGS>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgMessageFlags()
    :
        XPQMsgHdr<Q_MESSAGE_FLAGS_MSG,QMSG_MESSAGE_FLAGS>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgMessageFlags( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_MESSAGE_FLAGS_MSG,QMSG_MESSAGE_FLAGS>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID     = MAKEQWORD(0L,0L);
        m_Msg.dwMessageID  = 0;
        m_Msg.dwSetFlags   = 0;
        m_Msg.dwUnsetFlags = 0;
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Message Id
    //
    DWORD MessageId() const                 { return m_Msg.dwMessageID;        }
    void  SetMessageId( DWORD dwMessageId ) { m_Msg.dwMessageID = dwMessageId; }

    ///////////////////////////////////
    // Set Flags
    //
    DWORD FlagsToSet() const                { return m_Msg.dwSetFlags;         }
    void  SetFlagsToSet( DWORD dwSetFlags ) { m_Msg.dwSetFlags = dwSetFlags;   }

    ///////////////////////////////////
    // Unset Flags
    //
    DWORD FlagsToClear() const                  { return m_Msg.dwUnsetFlags;         }
    void  SetFlagsToClear( DWORD dwUnsetFlags ) { m_Msg.dwUnsetFlags = dwUnsetFlags; }
};

/////////////////////////////////////////////////
// XQMsg DeleteMessage
//
//  Messaging: Delete a message
//
class XQMsgDeleteMessage : public XPQMsgHdr<Q_DELETE_MESSAGE_MSG,QMSG_DELETE_MESSAGE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgDeleteMessage()
    :
        XPQMsgHdr<Q_DELETE_MESSAGE_MSG,QMSG_DELETE_MESSAGE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgDeleteMessage( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_DELETE_MESSAGE_MSG,QMSG_DELETE_MESSAGE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID    = MAKEQWORD(0L,0L);
        m_Msg.dwMessageID = 0;
        m_Msg.dwFlags     = 0;
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Message Id
    //
    DWORD MessageId() const                 { return m_Msg.dwMessageID;        }
    void  SetMessageId( DWORD dwMessageId ) { m_Msg.dwMessageID = dwMessageId; }

    ///////////////////////////////////
    // Flags
    //
    DWORD Flags() const                 { return m_Msg.dwFlags;    }
    void  SetFlags( DWORD dwFlags )     { m_Msg.dwFlags = dwFlags; }
};

/////////////////////////////////////////////////
// XQMsg SendMessage
//
//  Messaging: Send a new message
//
class XQMsgSendMessage : public XPQMsgHdr<Q_SEND_MESSAGE_MSG,QMSG_SEND_MESSAGE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgSendMessage()
    :
        XPQMsgHdr<Q_SEND_MESSAGE_MSG,QMSG_SEND_MESSAGE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgSendMessage( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_SEND_MESSAGE_MSG,QMSG_SEND_MESSAGE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwSenderID      = MAKEQWORD(0L,0L);
        m_Msg.qwSenderContext = 0;
        m_Msg.dwMessageFlags  = 0;
        m_Msg.dwSenderTitleID = 0;
        m_Msg.wExpireMinutes  = 0;
        m_Msg.cbDetails       = 0;
        m_Msg.cRecipients     = 0;
        m_Msg.bMessageType    = 0;
        
        memset( m_Msg.szSenderName, 0, sizeof( m_Msg.szSenderName ) );
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwSenderID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwSenderID = qwUserId; }

    ///////////////////////////////////
    // Sender Context
    //
    ULONGLONG SenderContext() const                         { return m_Msg.qwSenderContext;            }
    void      SetSenderContext( ULONGLONG qwSenderContext ) { m_Msg.qwSenderContext = qwSenderContext; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwSenderTitleID;      }
    void  SetTitleId( DWORD dwTitleId ) { m_Msg.dwSenderTitleID = dwTitleId; }

    ///////////////////////////////////
    // Expire Minutes
    //
    WORD ExpireMinutes() const                   { return m_Msg.wExpireMinutes;           }
    void SetExpireMinutes( WORD wExpireMinutes ) { m_Msg.wExpireMinutes = wExpireMinutes; }

    ///////////////////////////////////
    // Message Type
    //
    BYTE MessageType() const                  { return m_Msg.bMessageType;         }
    void SetMessageType( BYTE bMessageType )  { m_Msg.bMessageType = bMessageType; }

    ///////////////////////////////////
    // Message Flags
    //
    DWORD MessageFlags() const                    { return m_Msg.dwMessageFlags;           }
    void  SetMessageFlags( DWORD dwMessageFlags ) { m_Msg.dwMessageFlags = dwMessageFlags; }

    ///////////////////////////////////
    // Sender Name
    //
    const char* SenderName() const { return m_Msg.szSenderName; } // NOTE: This won't be null-terminated
    void SetSenderName( const char* pszName )  
    { 
        strncpy( m_Msg.szSenderName, pszName, sizeof( m_Msg.szSenderName ) ); 
    }

    ///////////////////////////////////
    // Recipients
    //
    const ULONGLONG* Recipients() const    { return m_aqwRecipients;   }
    WORD             RecipientsLen() const { return m_Msg.cRecipients; }  
    WORD AddRecipients( ULONGLONG* aqwRecipients, WORD wLen )
    {
        WORD wAdded = min( wLen, XONLINE_MAX_MESSAGE_RECIPIENTS - m_Msg.cRecipients );
        memcpy( &(m_aqwRecipients[ m_Msg.cRecipients ]), aqwRecipients, wAdded * sizeof( ULONGLONG ) );
        m_Msg.cRecipients += wAdded;
        return wAdded;
    }

    ///////////////////////////////////
    // Details
    //
    const BYTE* Details() const    { return m_abDetails;     }
    WORD        DetailsLen() const { return m_Msg.cbDetails; }  
    void AddDetails( const BYTE* abDetails, WORD wLen )
    {
        memcpy_s( m_abDetails, sizeof(m_abDetails), abDetails, wLen );
        m_Msg.cbDetails = min(wLen, sizeof(m_abDetails));
    }

private:
    ULONGLONG m_aqwRecipients[ XONLINE_MAX_MESSAGE_RECIPIENTS ]; // 100
    BYTE      m_abDetails    [ XONLINE_MAX_MESSAGE_DETAILS    ]; // 4096
};

/////////////////////////////////////////////////
// XQMsg RevokeMessage
//
//  Messaging: Revoke a previously sent message
//
class XQMsgRevokeMessage : public XPQMsgHdr<Q_REVOKE_MESSAGE_MSG,QMSG_REVOKE_MESSAGE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgRevokeMessage()
    :
        XPQMsgHdr<Q_REVOKE_MESSAGE_MSG,QMSG_REVOKE_MESSAGE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgRevokeMessage( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_REVOKE_MESSAGE_MSG,QMSG_REVOKE_MESSAGE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwSenderID      = MAKEQWORD(0L,0L);
        m_Msg.qwSenderContext = 0;
        m_Msg.cRecipients     = 0;
        m_Msg.bMessageType    = 0;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwSenderID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwSenderID = qwUserId; }

    ///////////////////////////////////
    // Recipients
    //
    const Q_RECIPIENT_RESULT* Recipients() const    { return m_aRecipients;     }
    WORD                      RecipientsLen() const { return m_Msg.cRecipients; }  
    WORD AddRecipients( const Q_RECIPIENT_RESULT* aRecipients, WORD wLen )
    {
        WORD wAdded = min( wLen, XONLINE_MAX_MESSAGE_RECIPIENTS - m_Msg.cRecipients );
        memcpy( &(m_aRecipients[ m_Msg.cRecipients ]), aRecipients, wAdded * sizeof( Q_RECIPIENT_RESULT ) );
        m_Msg.cRecipients += wAdded;
        return wAdded;
    }

private:

    Q_RECIPIENT_RESULT m_aRecipients[ XONLINE_MAX_MESSAGE_RECIPIENTS ]; // 100
};

/////////////////////////////////////////////////
// XQMsg RevokeMessage
//
//  Messaging: Revoke a previously sent message
//
class XQMsgRevokeMessageEx : public XPQMsgHdr<Q_REVOKE_MESSAGE_EX_MSG,QMSG_REVOKE_MESSAGE_EX>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgRevokeMessageEx()
    :
        XPQMsgHdr<Q_REVOKE_MESSAGE_EX_MSG,QMSG_REVOKE_MESSAGE_EX>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgRevokeMessageEx( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_REVOKE_MESSAGE_EX_MSG,QMSG_REVOKE_MESSAGE_EX>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwSenderID      = MAKEQWORD(0L,0L);
        m_Msg.qwSenderContext = 0;
        m_Msg.dwFlags         = 0;
        m_Msg.wPropTag        = 0;
        m_Msg.cRecipients     = 0;
        m_Msg.cbProp          = 0;
        m_Msg.bMessageType    = 0;
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ULONGLONG UserId() const                  { return m_Msg.qwSenderID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwSenderID = qwUserId; }

    ULONGLONG SenderContext() const           { return m_Msg.qwSenderContext; }
    void      SetSenderContext(ULONGLONG qwSenderContext) { m_Msg.qwSenderContext = qwSenderContext; }

    DWORD     Flags() const                   { return m_Msg.dwFlags; }
    void      SetFlags(DWORD dwFlags)         { m_Msg.dwFlags = dwFlags; }

    WORD      PropTag() const                 { return m_Msg.wPropTag; }
    void      SetPropTag(WORD wPropTag)       { m_Msg.wPropTag = wPropTag; }

    BYTE      MessageType() const             { return m_Msg.bMessageType; }
    void      SetMessageType(BYTE bType)      { m_Msg.bMessageType = bType; }


    ///////////////////////////////////
    // Recipients
    //
    const Q_RECIPIENT_RESULT* Recipients() const    { return m_rgRecipients;     }
    WORD                      RecipientsLen() const { return m_Msg.cRecipients; }  
    WORD AddRecipients( const Q_RECIPIENT_RESULT* prgRecipients, WORD wcRecipients )
    {
        WORD wAdded = min( wcRecipients, XONLINE_MAX_MESSAGE_RECIPIENTS - m_Msg.cRecipients );
        memcpy( &(m_rgRecipients[ m_Msg.cRecipients ]), prgRecipients, wAdded * sizeof( Q_RECIPIENT_RESULT ) );
        m_Msg.cRecipients += wAdded;
        return wAdded;
    }

    WORD SetProperties(BYTE *prgbProp, WORD wcbProp)
    {
        WORD wcbCopied = min(wcbProp, 1024);
        memcpy(m_rgbProp, prgbProp, wcbCopied);
        m_Msg.cbProp = wcbCopied;
        return wcbCopied;
    }

private:

    Q_RECIPIENT_RESULT m_rgRecipients[ XONLINE_MAX_MESSAGE_RECIPIENTS ]; // 100
    BYTE               m_rgbProp[1024];
};

/////////////////////////////////////////////////
// XQMsg DeleteTitle
//
//  Messaging: Delete a title from a user's list of owned titles
//
class XQMsgDeleteTitle : public XPQMsgHdr<Q_DELETE_TITLE_MSG,QMSG_DELETE_TITLE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgDeleteTitle()
    :
        XPQMsgHdr<Q_DELETE_TITLE_MSG,QMSG_DELETE_TITLE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgDeleteTitle( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_DELETE_TITLE_MSG,QMSG_DELETE_TITLE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID  = MAKEQWORD(0L,0L);
        m_Msg.dwTitleID = 0;
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleId ) { m_Msg.dwTitleID = dwTitleId; }
};

/////////////////////////////////////////////////
// XQMsg EnumTitles
//
//  Messaging: Enumerate a user's owned titles
//
class XQMsgEnumTitles : public XPQMsgHdr<Q_ENUM_TITLES_MSG,QMSG_ENUM_TITLES>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgEnumTitles()
    :
        XPQMsgHdr<Q_ENUM_TITLES_MSG,QMSG_ENUM_TITLES>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgEnumTitles( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_ENUM_TITLES_MSG,QMSG_ENUM_TITLES>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.qwUserID = MAKEQWORD(0L,0L);
    }

    ///////////////////////////////////
    // User Id
    //
    ULONGLONG UserId() const                  { return m_Msg.qwUserID;     }
    void      SetUserId( ULONGLONG qwUserId ) { m_Msg.qwUserID = qwUserId; }
};

/////////////////////////////////////////////////
// XQMsg EnumSystemMessages
//
//  Messaging: Enumerate system messages
//
class XQMsgEnumSystemMessages : public XPQMsgHdr<Q_ENUM_SYSTEM_MESSAGES_MSG,QMSG_ENUM_SYSTEM_MESSAGES>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgEnumSystemMessages()
    :
        XPQMsgHdr<Q_ENUM_SYSTEM_MESSAGES_MSG,QMSG_ENUM_SYSTEM_MESSAGES>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgEnumSystemMessages( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_ENUM_SYSTEM_MESSAGES_MSG,QMSG_ENUM_SYSTEM_MESSAGES>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.dwTitleID = 0;
    }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleId ) { m_Msg.dwTitleID = dwTitleId; }
};

/////////////////////////////////////////////////
// XQMsg SystemMessageDetails
//
//  Messaging: Retrieve the summary and details for a system message
//
class XQMsgSystemMessageDetails : public XPQMsgHdr<Q_SYSTEM_MESSAGE_DETAILS_MSG,QMSG_SYSTEM_MESSAGE_DETAILS>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgSystemMessageDetails()
    :
        XPQMsgHdr<Q_SYSTEM_MESSAGE_DETAILS_MSG,QMSG_SYSTEM_MESSAGE_DETAILS>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgSystemMessageDetails( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_SYSTEM_MESSAGE_DETAILS_MSG,QMSG_SYSTEM_MESSAGE_DETAILS>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.dwTitleID   = 0;
        m_Msg.dwMessageID = 0;
    }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleId ) { m_Msg.dwTitleID = dwTitleId; }

    ///////////////////////////////////
    // Message Id
    //
    DWORD MessageId() const                 { return m_Msg.dwMessageID;        }
    void  SetMessageId( DWORD dwMessageId ) { m_Msg.dwMessageID = dwMessageId; }
};

/////////////////////////////////////////////////
// XQMsg DeleteSystemMessage
//
//  Messaging: Delete a system message
//
class XQMsgDeleteSystemMessage : public XPQMsgHdr<Q_DELETE_SYSTEM_MESSAGE_MSG,QMSG_DELETE_SYSTEM_MESSAGE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgDeleteSystemMessage()
    :
        XPQMsgHdr<Q_DELETE_SYSTEM_MESSAGE_MSG,QMSG_DELETE_SYSTEM_MESSAGE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgDeleteSystemMessage( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_DELETE_SYSTEM_MESSAGE_MSG,QMSG_DELETE_SYSTEM_MESSAGE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.dwTitleID   = 0;
        m_Msg.dwMessageID = 0;
        m_Msg.dwFlags     = 0;
    }

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleId ) { m_Msg.dwTitleID = dwTitleId; }

    ///////////////////////////////////
    // Message Id
    //
    DWORD MessageId() const                 { return m_Msg.dwMessageID;        }
    void  SetMessageId( DWORD dwMessageId ) { m_Msg.dwMessageID = dwMessageId; }

    ///////////////////////////////////
    // Flags
    //
    DWORD Flags() const             { return m_Msg.dwFlags;    }
    void  SetFlags( DWORD dwFlags ) { m_Msg.dwFlags = dwFlags; }
};

/////////////////////////////////////////////////
// XQMsg SendSystemMessage
//
//  Messaging: Send a system message
//
class XQMsgSendSystemMessage : public XPQMsgHdr<Q_SEND_SYSTEM_MESSAGE_MSG,QMSG_SEND_SYSTEM_MESSAGE>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XQMsgSendSystemMessage()
    :
        XPQMsgHdr<Q_SEND_SYSTEM_MESSAGE_MSG,QMSG_SEND_SYSTEM_MESSAGE>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XQMsgSendSystemMessage( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<Q_SEND_SYSTEM_MESSAGE_MSG,QMSG_SEND_SYSTEM_MESSAGE>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.dwTitleID       = 0;
        m_Msg.qwSenderContext = 0;
        m_Msg.dwRegion        = 0;
        m_Msg.dwMessageFlags  = 0;
        m_Msg.wExpireMinutes  = 0;
        m_Msg.cbDetails       = 0;
        m_Msg.bMessageType    = 0;
        
        memset( m_Msg.szSenderName, 0, sizeof( m_Msg.szSenderName ) );
        memset( m_Msg.szDescription, 0, sizeof( m_Msg.szDescription ) );

        // Default to current UTC time
        SYSTEMTIME systime;
        GetSystemTime( &systime );
        SystemTimeToFileTime( &systime, &m_Msg.ftSentTime );
    }

    ///////////////////////////////////
    // DumpMsg
    //  Overiden for extra data
    //
    DWORD DumpMsg( BYTE* pMsgBuff, DWORD dwBufLen );

    ///////////////////////////////////
    // Title Id
    //
    DWORD TitleId() const               { return m_Msg.dwTitleID;      }
    void  SetTitleId( DWORD dwTitleId ) { m_Msg.dwTitleID = dwTitleId; }

    ///////////////////////////////////
    // Sender Context
    //
    ULONGLONG SenderContext() const                         { return m_Msg.qwSenderContext;            }
    void      SetSenderContext( ULONGLONG qwSenderContext ) { m_Msg.qwSenderContext = qwSenderContext; }

    ///////////////////////////////////
    // Sent Time
    //
    FILETIME SentTime() const                   { return m_Msg.ftSentTime;       }
    void     SetSentTime( FILETIME ftSentTime ) { m_Msg.ftSentTime = ftSentTime; }

    ///////////////////////////////////
    // Region
    //
    DWORD Region() const              { return m_Msg.dwRegion;     }
    void  SetRegion( DWORD dwRegion ) { m_Msg.dwRegion = dwRegion; }

    ///////////////////////////////////
    // Message Flags
    //
    DWORD MessageFlags() const                    { return m_Msg.dwMessageFlags;           }
    void  SetMessageFlags( DWORD dwMessageFlags ) { m_Msg.dwMessageFlags = dwMessageFlags; }

    ///////////////////////////////////
    // Expire Minutes
    //
    WORD ExpireMinutes() const                   { return m_Msg.wExpireMinutes;           }
    void SetExpireMinutes( WORD wExpireMinutes ) { m_Msg.wExpireMinutes = wExpireMinutes; }

    ///////////////////////////////////
    // Message Type
    //
    BYTE MessageType() const                 { return m_Msg.bMessageType;         }
    void SetMessageType( BYTE bMessageType ) { m_Msg.bMessageType = bMessageType; }

    ///////////////////////////////////
    // Sender Name
    //
    const char* SenderName() const { return m_Msg.szSenderName; } // NOTE: This won't be null-terminated
    void        SetSenderName( const char* pszName )  
    { 
        strncpy( m_Msg.szSenderName, pszName, sizeof( m_Msg.szSenderName ) ); 
    }

    ///////////////////////////////////
    // Description
    //
    const char* Description() const { return m_Msg.szDescription; }
    void        SetDescription( const char* pszDesc )  
    { 
        strncpy( m_Msg.szDescription, pszDesc, sizeof( m_Msg.szDescription ) ); 
    }

    ///////////////////////////////////
    // Details
    //
    const BYTE* Details() const    { return m_abDetails;     }
    WORD        DetailsLen() const { return m_Msg.cbDetails; }  

private:

    BYTE  m_abDetails[ XONLINE_MAX_MESSAGE_DETAILS ]; // 4096
};

class XPMsgEcho : public XPQMsgHdr<ECHO_MSG,MSG_ECHO>
{
public:

    ///////////////////////////////////
    // Ctor
    //
    XPMsgEcho()
    :
        XPQMsgHdr<ECHO_MSG,MSG_ECHO>( XPQSgAddr() )
    {
        SetDefaults();
    }

    XPMsgEcho( const XPQSgAddr& rSgAddr )
    :
        XPQMsgHdr<ECHO_MSG,MSG_ECHO>( rSgAddr )
    {
        SetDefaults();
    }

    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

    ///////////////////////////////////
    // Set Defaults
    //
    void SetDefaults()
    {
        m_Msg.dwFoo           = 0xaabbccdd;
    }
};

//------------------------------------------------------------------------------
// 
// Create the HTTP request with the given message type and message object. If 
// the message object is provided it will be passed the dest buffer to it's 
// DumpMsg() method.
//
//------------------------------------------------------------------------------ 
HRESULT WriteHttpHeader( DWORD dwSPI, bool bHttpAuth, BYTE* pbDestBuffer, DWORD cbDestBuffer, DWORD dwMsgType, DWORD dwPayload, DWORD *pdwHeaderLen);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\pconn.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef PCONN_H_INCLUDED
#define PCONN_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CPresConnectionCallback;
class CSwitchboard;

/*****************************************************************************

CTCPCntMessageBasedPlugin_PN

Protocol message length definition for presence and notification

*****************************************************************************/
struct CTCPCntMessageBasedPlugin_PN
{
    int operator ()(
        const BYTE* pBuffer,
        DWORD cbBuffer
    ) const
    {
        BASE_MSG_HEADER *pHdr;

        if(cbBuffer < sizeof(BASE_MSG_HEADER))
        {
            return 0;
        }

        pHdr = (BASE_MSG_HEADER *) pBuffer;

        if ((pHdr->dwMsgLen + sizeof(BASE_MSG_HEADER)) > CTCPCnt_RECEIVE_BUFFER_LENGTH)
        {
            if (cbBuffer < CTCPCnt_RECEIVE_BUFFER_LENGTH)
            {
                return 0;
            }
            
            return CTCPCnt_RECEIVE_BUFFER_LENGTH;
        }
        
        if (cbBuffer < (pHdr->dwMsgLen + sizeof(BASE_MSG_HEADER)))
        {
            return 0;
        }

        return (pHdr->dwMsgLen + sizeof(BASE_MSG_HEADER));
    }
};

/*****************************************************************************

CPresConnection

Contains one presence server  peer connection.  Does reply parsing, simple 
processing and validation of replies before calling into the implemention of 
the logic behind the reply.

*****************************************************************************/
class CPresConnection : public CTCPCntMessageBased<CTCPCntMessageBasedPlugin_PN>
{
public:
    CPresConnection();
    virtual ~CPresConnection();

    void *operator new(size_t len) { return XAlloc(len); }
    void operator delete(void *pv) { XFree(pv); }

    HRESULT Init(
        sockaddr_in *pAddr,
        CCompletionPort *pCompPort,
        CPresConnectionCallback *pCallback,
        CSwitchboard *pCSwitchboard);

    HRESULT SendMsgHello();

    HRESULT SendMsg(DWORD dwContextId, BASE_MSG_HEADER *pMsgIn);

    virtual void ProcessPConnMessage(BYTE *pMsg, DWORD cbEntireMsg);

protected:
    virtual void OnConnect();
    virtual void OnDisconnect(HRESULT hrReason );

    virtual void ProcessMessage(BYTE *pMsg, DWORD cbEntireMsg);

    // Message handler methods
    typedef void (CPresConnection::*MsgHandler)(
        BASE_MSG_HEADER *pMsgHeader,
        DWORD cbEntireMsg);

    void ProcessMsgNotSupported(BASE_MSG_HEADER *pMsg, DWORD cbEntireMsg);
    void ProcessMsgListReply(Q_LIST_REPLY_MSG *pMsg, DWORD cbEntireMsg);
	void ProcessMsgListReply2(Q_LIST_REPLY_2_MSG *pMsg, DWORD cbEntireMsg);


    CCompletionPort *m_pCompPort;
    CPresConnectionCallback *m_pCallback;
    CSwitchboard *m_pCSwitchboard;
    sockaddr_in m_sa;
};

/*****************************************************************************

CPresConnectionCallback

Callback interface for presence server peer connections.

*****************************************************************************/
class CPresConnectionCallback
{
public:
    virtual void OnConnect(CPresConnection *pCConn) = 0;
    virtual void OnDisconnect(CPresConnection *pCConn) = 0;
};

/*****************************************************************************

CXPCluster

Contains all presence server peer connections.  Builds messages and dispatches 
them to the appropriate presence server(s).

*****************************************************************************/
class CXPCluster : 
    public CPresConnectionCallback
{
public:
    CXPCluster();

    ~CXPCluster();

    IMPLEMENT_REFCOUNT;

    HRESULT Init(CCompletionPort *pCompPort, CSwitchboard *pCSwitchboard);
    void Shutdown();

    void PeriodicHeartbeat();

    HRESULT SendMsgHello();

    HRESULT SendMsgByUserId(DWORD dwContextId, QWORD qwUserId, BASE_MSG_HEADER *pMsg);

    // CPresConnectionCallback methods
    virtual void OnConnect(CPresConnection *pCConn);

    virtual void OnDisconnect(CPresConnection *pCConn);

protected:

    HRESULT AttemptConnections();

    void SortUsersByDestination(DWORD cUsers, QWORD *rgqwUsersSrc);

    // Persistant per-connection information
    struct CPConnInfo
    {
        CPresConnection *pCPresConn;
        BOOL fInit;
        BOOL fConnected;
        BOOL fAlt;

        void *operator new(size_t len) { return XAlloc(len); }
        void *operator new[] (size_t len) { return XAlloc(len); }
        void operator delete(void *pv) { XFree(pv); }
        void operator delete[] (void*pv) { XFree(pv); }
    };

    CCompletionPort *m_pCCompPort;
    CPConnInfo *m_rgCPConnInfo;
    CSwitchboard *m_pCSwitchboard;
};

#endif  // PCONN_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\presconfig.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

extern ConfigWrapper __gConfigWrapper;

CPresenceConfig g_CPresCfg;

/*****************************************************************************

CPresenceConfig::Init

Initialize the config object

*****************************************************************************/
HRESULT CPresenceConfig::Init() 
{
    HRESULT hr = S_OK;
  
	hr = __gConfigWrapper.Initialize();
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = Load();

lDone:

    return hr;
}

HRESULT CPresenceConfig::Reload(struct ISettingChangeEventArgs * eventArgs)
{
    CComBSTR SettingChange;
    CComBSTR bsValueNew = CComBSTR(NULL);
    HRESULT hr = S_OK;
    DWORD dwValue;

    if (eventArgs == NULL)
    {
        hr = E_POINTER;
        goto lDone;
    }

    hr = eventArgs->get_Setting(&SettingChange);
    if (FAILED(hr))
    {
        goto lDone;
    }
    
    hr = eventArgs->get_ValueNew(&bsValueNew);
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:
    return hr;
}

/*****************************************************************************

CPresenceConfig::Load

(Re)load the configuration

*****************************************************************************/
HRESULT CPresenceConfig::LoadSettings() 
{
    // settings that require extra work to take effect
    m_dwSGQValSendPort = GetDWORDSetting(Setting_presence_SGQValSendPort);
    m_dwSGQValRecvPort = GetDWORDSetting(Setting_presence_SGQValRecvPort);
    m_dwUserIndexSize = GetDWORDSetting(Setting_presence_UserIndexSize);
    m_dwXBoxIndexSize = GetDWORDSetting(Setting_presence_XBoxIndexSize);
    m_dwSGIndexSize = GetDWORDSetting(Setting_presence_SGIndexSize);
    m_dwConcurrentSQLThreads = GetDWORDSetting(Setting_presence_ConcurrentSQLThreads);
    m_dwNumSQLThreads = GetDWORDSetting(Setting_presence_NumSQLThreads);
    m_dwPeerPort = GetDWORDSetting(Setting_presence_PeerPort);

    // simple settings
    m_dwHeartbeatDelay = GetDWORDSetting(Setting_presence_HeartbeatDelay);
    m_dwMaxQValsPerHeartbeat = GetDWORDSetting(Setting_presence_MaxQValsPerHeartbeat);
    m_dwPresUserCleanupDelay = GetDWORDSetting(Setting_presence_PresUserCleanupDelay);
    m_dwIdleQValsCheck = GetDWORDSetting(Setting_presence_IdleQValsCheck);
    GetDWORDArraySetting(Setting_presence_QValRetryDelays, &m_dwQValRetryDelaysLen, m_rgdwQValRetryDelays);
    m_dwWebUserTimeout = GetDWORDSetting(Setting_presence_WebUserTimeout);
    m_dwDeadSgOnFailedQVal = GetDWORDSetting(Setting_presence_DeadSgOnFailedQVal);
    m_dwStartNumPoolBuffers = GetDWORDSetting(Setting_presence_StartNumPoolBuffers);
    m_dwMaxNumPoolBuffers = GetDWORDSetting(Setting_presence_MaxNumPoolBuffers);
    m_dwPoolBufferSize = GetDWORDSetting(Setting_presence_PoolBufferSize);
    m_dwMaxPresenceUsers = GetDWORDSetting(Setting_presence_MaxPresenceUsers);
    m_dwMaxRichPresenceBytes = GetDWORDSetting(Setting_presence_MaxRichPresenceBytes);
    m_dwExpirationCheckInterval = GetDWORDSetting(Setting_presence_ExpirationCheckInterval);
    m_dwMessageTimeout = GetDWORDSetting(Setting_presence_MessageTimeout);
    m_dwMessagingDailySends = GetDWORDSetting(Setting_presence_MessagingDailySends);
    m_dwMessagingDailyRecipients = GetDWORDSetting(Setting_presence_MessagingDailyRecipients);
    m_dwBucketReloadDelay = GetDWORDSetting(Setting_presence_BucketReloadDelay);
    GetDWORDArraySetting(Setting_presence_ValidMessageTypes, &m_dwValidMessageTypesLen, m_rgdwValidMessageTypes);
    GetDWORDArraySetting(Setting_presence_MessageTypeExpiration, &m_dwMessageTypeExpirationsLen, m_rgdwMessageTypeExpirations);
    m_fQueryAfffiliatesOkToPeerSubscribe = GetDWORDSetting(Setting_presence_QueryAffiliatesOkToPeerSubscribe);
    m_dwAffiliatesEncounteredListSize = GetDWORDSetting(Setting_presence_AffiliatesEncounteredListSize);
    m_dwAffiliatesCompletedGameListSize = GetDWORDSetting(Setting_presence_AffiliatesCompletedGameListSize);
    m_dwAffiliatesPositiveFeedbackListSize = GetDWORDSetting(Setting_presence_AffiliatesPositiveFeedbackListSize);
    m_dwAffiliatesNegativeFeedbackListSize = GetDWORDSetting(Setting_presence_AffiliatesNegativeFeedbackListSize);
    m_dwAffiliatesAvoidingMeListSize = GetDWORDSetting(Setting_presence_AffiliatesAvoidingMeListSize);
    m_dwAffiliatesFavoritesListSize = GetDWORDSetting(Setting_presence_AffiliatesFavoritesListSize);
    m_dwProtocolVersion = GetDWORDSetting(Setting_global_protocolVersion);
    m_dwStateBitsNotifyWhitelist = GetDWORDSetting(Setting_presence_StateBitsNotifyWhitelist);
    m_fEnableRichPresence = GetDWORDSetting(Setting_presence_EnableRichPresence);

    if (m_dwMaxRichPresenceBytes > MAX_TITLE_DATA_BYTES)
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_29, "CPresenceConfig::Load() - Configured Max RichPresence State data is greater than what the SG protocol allows. See usage of MAX_TITLE_DATA_BYTES. Maximum allowed setting is ", MAX_TITLE_DATA_BYTES );
    }

    return S_OK;
}

HRESULT CPresenceConfig::Load() 
{
    HRESULT hr = S_OK;

    hr = LoadSettings();
    if (FAILED(hr))
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_30, "CPresenceConfig::Load() - Failed to load Settings, hr=0x%08X", hr );
        goto lDone;
    }    

    hr = LoadXonWatchIPs();
    if (FAILED(hr))
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_31, "CPresenceConfig::Load() - Failed to load XonWatchIPs, hr=0x%08X", hr );
        goto lDone;
    }

    hr = LoadPresenceServers();
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_32, "CPresenceConfig::Load() - Failed to load Presence servers, hr=0x%08X", hr );
        goto lDone;
    }
    
    hr = LoadBucketMap();
    if (FAILED(hr))
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_33, "CPresenceConfig::Load() - Failed to load bucket map, hr=0x%08X", hr );
        goto lDone;
    }

lDone:
    return hr;
}

/*****************************************************************************

CPresenceConfig::GetDWORDSetting

Get a DWORD settting

*****************************************************************************/
DWORD CPresenceConfig::GetDWORDSetting(CComBSTR Setting, CComBSTR bsSetting)
{
    DWORD dwRetVal = 0;
    HRESULT hr = S_OK;

    if (bsSetting == NULL)
    {
        hr = __gConfigWrapper->GetSetting( Setting, &bsSetting );
    }
    
    if( FAILED( hr ) || (bsSetting == NULL))
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_35, "CPresenceConfig::GetDWORDSetting() - Config.GetSetting failed, hr=0x%08X", hr );

        return 0;
    }

    if( ( L'0' == bsSetting[ 0 ] ) && ( L'x' == bsSetting[ 1 ] ) )
    {
        if( 0 >= swscanf( bsSetting, L"%x", &dwRetVal ) )
        {
            dwRetVal = 0;
        }
    }
    else
    {
        dwRetVal = (DWORD) _wtoi(bsSetting);
    }

    return dwRetVal;
}

/*****************************************************************************

GetDWORDArraySetting

*****************************************************************************/
void CPresenceConfig::GetDWORDArraySetting(
    CComBSTR Setting,
    DWORD *pdwLen,
    DWORD *rgdwVal,
    CComBSTR bsSetting)
{
    // BUGBUG put in a new array, then swap

    LPCWSTR wszRead;
    int iRet;
    HRESULT hr = S_OK;

    if (bsSetting == NULL)
    {
        // Get the string to parse
        hr = __gConfigWrapper->GetSetting( Setting, &bsSetting );
    }
    
    if( FAILED( hr ) || (bsSetting == NULL))
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_36, "CPresenceConfig::GetDWORDArraySetting() - Config.GetSetting failed, hr=0x%08X", hr );

        *pdwLen = 0;
        return;
    }

    wszRead = bsSetting;
    *pdwLen = 0;
    for (;;)
    {
        // Check the size limit
        if (*pdwLen >= P_MAX_DWORD_ARRAY)
        {
            break;
        }

        // Try to get an element
        if( ( '0' == wszRead[ 0 ] ) && ( 'x' == wszRead[ 1 ] ) )
        {
            iRet = swscanf(wszRead, L"%x", rgdwVal + *pdwLen);
        }
        else
        {
            iRet = swscanf(wszRead, L"%d", rgdwVal + *pdwLen);
        }

        // Did we get anything
        if (iRet != 1) 
        {
            break;
        }

        // Next element
        *pdwLen = *pdwLen + 1;

        while ((*wszRead != '\0') && (*wszRead != ','))
        {
            wszRead++;
        }

        while ((*wszRead == ',') || (*wszRead == ' ') || (*wszRead == '\t'))
        {
            wszRead++;
        }
    }
    
}

/*****************************************************************************

CPresenceConfig::LoadXonWatchIPs

Load the list of valid XonWatch IP addresses

*****************************************************************************/
HRESULT CPresenceConfig::LoadXonWatchIPs()
{
    HRESULT hr = S_OK;
    CComBSTR bsXonWatchIPs;
    WCHAR *wszAddr;
    WCHAR *wszRead;
    DWORD dwIndex = 0;
    HOSTENT *pHE = NULL;

    hr = __gConfigWrapper->GetSetting( Setting_presence_XonWatchIPs, &bsXonWatchIPs );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_37, "CPresenceConfig::LoadXonWatchIPs() - Config.GetSetting failed, hr=0x%08X", hr );
        goto lDone;
    }

    wszAddr = bsXonWatchIPs;
    wszRead = bsXonWatchIPs;

    while (*wszRead != L'\0') 
    {
        XonWatchIP *pNew = new XonWatchIP[m_cXonWatchIPs + 1];
        memcpy(pNew, m_psXonWatchIPs, m_cXonWatchIPs * sizeof(XonWatchIP));
        delete[] m_psXonWatchIPs;
        m_psXonWatchIPs = pNew;

        while ((*wszRead != L',') && (*wszRead != L'\0'))
        {
            wszRead++;
        }
        if (*wszRead == ',')
        {
            *wszRead = '\0';
            wszRead++;
        }

        // Get the address
        pHE = gethostbyname( CW2A(wszAddr ) );
        if( NULL == pHE )
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError() );
            goto lDone;
        }

        memset(&(m_psXonWatchIPs[dwIndex].inaIP), 0, sizeof(in_addr));
        memcpy(&(m_psXonWatchIPs[dwIndex].inaIP), pHE->h_addr, pHE->h_length);

        while ((*wszRead == ' ') || (*wszRead == '\t'))
        {
            wszRead++;
        }
        wszAddr = wszRead;

        while ((*wszRead != ';') && (*wszRead != '\0'))
        {
            wszRead++;
        }
        if (*wszRead == ';')
        {
            *wszRead = '\0';
            wszRead++;
        }

        // Get the mask
        pHE = gethostbyname( CW2A(wszAddr) );
        if( NULL == pHE )
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError() );
            goto lDone;
        }

        memset(&(m_psXonWatchIPs[dwIndex].inaMask), 0, sizeof(in_addr));
        memcpy(&(m_psXonWatchIPs[dwIndex].inaMask), pHE->h_addr, pHE->h_length);

        while ((*wszRead == ' ') || (*wszRead == '\t'))
        {
            wszRead++;
        }
        wszAddr = wszRead;

        m_cXonWatchIPs++;
        dwIndex++;
    }

lDone:
    return hr;
}

/*****************************************************************************

CPresenceConfig::LoadPresenceServers

Load the list of all Presence servers

*****************************************************************************/
HRESULT CPresenceConfig::LoadPresenceServers()
{
    HRESULT hr = S_OK;
    BSTR* pbstr = NULL;
    SAFEARRAY* pArray = NULL;

    hr = __gConfigWrapper->GetServerListByInterface( Interface_xpserver, &pArray );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_38, "CPresenceConfig::LoadPresenceServers() - GetServerListByInterface failed, hr=0x%08X", hr );
        goto lDone;
    }

    hr = SafeArrayAccessData( pArray, (void**) &pbstr );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_39, "CPresenceConfig::LoadPresenceServers() - SafeArrayAccessData failed, hr=0x%08X", hr );
        goto lDone;
    }

    for( DWORD iServer = 0; iServer < pArray->rgsabound->cElements; iServer++ )
    {
        if( FAILED( AddServer( pbstr[ iServer ], m_cPresServers ) ) )
        {
            XomNtEvent( XEVENT_PRESENCE_CONFIG_40, "CPresenceConfig::LoadPresenceServers() - AddServer failed, hr=0x%08X", hr );
            goto lDone;
        }
        m_cPresServers++;
    }

    SafeArrayUnaccessData( pArray );
    pbstr = NULL;

    SafeArrayDestroy( pArray );
    pArray = NULL;

lDone:
    if( NULL != pbstr )
    {
        SafeArrayUnaccessData( pArray );
        pbstr = NULL;
    }
    if( NULL != pArray )
    {
        SafeArrayDestroy( pArray );
        pArray = NULL;
    }

    return hr;
}


/*****************************************************************************

CPresenceConfig::IsValidOnWatchAddr

Returns true if the given address is valid for XonWatch operations

*****************************************************************************/
BOOL CPresenceConfig::IsValidOnWatchAddr(IN_ADDR inaddr)
{
    DWORD dwIndex = 0;

    for (dwIndex = 0; dwIndex < m_cXonWatchIPs; dwIndex++)
    {
        if ((inaddr.S_un.S_addr & m_psXonWatchIPs[dwIndex].inaMask.S_un.S_addr) == 
            m_psXonWatchIPs[dwIndex].inaIP.S_un.S_addr)
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*****************************************************************************

CPresenceConfig::MapUserToPresSrv

Map a user to a presence server

*****************************************************************************/
DWORD CPresenceConfig::MapUserToPresSrv(QWORD qwUserID, BOOL fAlt)
{
    if (qwUserID == 0)
    {
        // There are a couple valid cases where this function gets called for puid 0.
        // Reenable this assert if there are problems with pconn messages going to the wrong servers.
        // XOMASSERT(FALSE);
        XomNtEvent(XEVENT_PRESENCE_CODE_192, "MapUserToPresSrv called for puid = 0 !!");

        // Since we removed P_NO_ALT_SERVER, we dont want to return P_NOT_FOUND anymore either.
        // There may have been some code that depended on the two values being the same.  By returning
        // the local server index, we can ensure that nobody will try to pass 0xFFFFFFFF as an array index when
        // trying to send or forward to another server.  This may result in a local shortcut message that ends up
        // returning E_NO_SUCH_USER when FindPresence() is called for user 0.
        return GetMyPresServerIndex();
    }
        
    DWORD dwHash = HashPUID(qwUserID);
    DWORD dwRet = m_rgBucketMap[dwHash].dwServerIndex;

    if (fAlt)
    {
        DWORD dwAlt = m_rgBucketMap[dwHash].dwNextServerIndex;
        dwRet = ((dwRet == dwAlt) || (!m_rgBucketMap[dwHash].fAltServerValid)) ? dwRet : dwAlt;
    }
    
    return dwRet;
}

/*****************************************************************************

CPresenceConfig::GetPresServerName

Get a Presence server name by index

*****************************************************************************/
CComBSTR CPresenceConfig::GetPresServerName(DWORD dwIndex)
{
    if (dwIndex >= m_cPresServers)
    {
        return CComBSTR(L"NULL");
    }
    else
    {
        return m_rgPresServers[dwIndex].bstrInterfaceName;
    }
}

/*****************************************************************************

CPresenceConfig::GetPresServerAddr

Get a Presence server address by index

*****************************************************************************/
sockaddr_in *CPresenceConfig::GetPresServerAddr(DWORD dwIndex)
{
    if (dwIndex >= m_cPresServers)
    {
        return NULL;
    }
    else
    {
        return &(m_rgPresServers[dwIndex].sa);
    }
}

/*****************************************************************************

CPresenceConfig::GetPresServerPeerAddr

Get a Presence server peer address by index

*****************************************************************************/
sockaddr_in *CPresenceConfig::GetPresServerPeerAddr(DWORD dwIndex)
{
    if (dwIndex >= m_cPresServers)
    {
        return NULL;
    }
    else
    {
        return &(m_rgPresServers[dwIndex].saPeer);
    }
}

/*****************************************************************************

CPresenceConfig::GetPresServerAddr

Return FALSE if we shouldn't be receiving messages for this user

*****************************************************************************/
BOOL CPresenceConfig::CheckDestination(QWORD qwUserID)
{
    if (qwUserID == 0)
    {
        XOMASSERT(FALSE);
        XomNtEvent(XEVENT_PRESENCE_CODE_193, "CheckDestination called for puid = 0 !!");
        return FALSE;
    }
        
    DWORD dwHash = HashPUID(qwUserID);
    
    if ((m_dwMyIndex == m_rgBucketMap[dwHash].dwNextServerIndex) ||
        (m_dwMyIndex == m_rgBucketMap[dwHash].dwServerIndex))
    {
        return TRUE;
    }
    
    return FALSE;
}


HRESULT CPresenceConfig::ChangeBucketMap(
    DWORD dwBucket,
    CComBSTR bsCurrentServer,
    CComBSTR bsNextServer,
    DATE dtStart,
    BOOL fMine)
{    
    HRESULT hr = S_OK;
    
    if (dwBucket > m_dwBucketCount)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    DWORD dwNewCurrentServer = GetServerByName(bsCurrentServer);
    DWORD dwNewNextServer = GetServerByName(bsNextServer);

    if ((dwNewCurrentServer == m_rgBucketMap[dwBucket].dwNextServerIndex) && (dwNewNextServer == dwNewCurrentServer))
    {
        // migration is done.
        hr = S_FALSE;
        
        if (fMine)
        {
            // local server needs to wait to be sure everyone else is notified first.
            goto lDone;
        }
    }
    else if (dwNewCurrentServer != m_rgBucketMap[dwBucket].dwServerIndex)
    {
        // changing the current server is bad.
        hr = E_INVALIDARG;
        XomNtEvent(XEVENT_PRESENCE_CONFIG_45, "CPresenceConfig::ChangeBucketMap(bucket = %d, newCurrent = %s): current server changed before next server.", dwBucket, CW2A(bsCurrentServer));
        goto lDone;
    }

    if ((dwNewNextServer != m_rgBucketMap[dwBucket].dwNextServerIndex) && fMine)
    {
        // we dont use this alt server until the time hits.
        m_rgBucketMap[dwBucket].fAltServerValid = FALSE;
    }

    m_rgBucketMap[dwBucket].dtStart = dtStart;
    m_rgBucketMap[dwBucket].dwNextServerIndex = GetServerByName(bsNextServer);
    m_rgBucketMap[dwBucket].dwServerIndex = GetServerByName(bsCurrentServer);

lDone:

    return hr;
}

/*****************************************************************************

CPresenceConfig::LoadBucketMap

Load the bucket map from the database

*****************************************************************************/
HRESULT CPresenceConfig::LoadBucketMap()
{
    DWORD dwNow = GetTickCount();
    
    // Only execute if we're stale
    if ((m_dwLastBucketLoad != 0) &&
        ((dwNow - m_dwLastBucketLoad) < m_dwBucketReloadDelay))
    {
        return S_OK;
    }

    HRESULT hr = S_OK;

    DWORD cBuckets;
    PresServerBucketConfig *rgBucketMap = NULL;
    PresServerBucketConfig *rgOldBucketMap = NULL;

    hr = __gConfigWrapper->GetBucketCount( Interface_xpserver, &cBuckets );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_46, "CPresenceConfig::LoadBucketMap() - Config.GetPartitionCount failed, hr=0x%08X", hr );
        goto lDone;
    }

    rgBucketMap = new PresServerBucketConfig[ cBuckets ];
    for( DWORD iBucket = 0; iBucket < cBuckets; iBucket++ )
    {
        CComPtr<IBucketServer> pServer;
        CComBSTR bsCurrentServer;
        CComBSTR bsNextServer;
        DATE dtMigrationStart;

        hr = __gConfigWrapper->GetBucketServer( Interface_xpserver, iBucket, &pServer );
        if( FAILED( hr ) )
        {
            XomNtEvent( XEVENT_PRESENCE_CONFIG_47, "CPresenceConfig::LoadBucketMap() - Config.GetBucketServer failed, hr=0x%08X", hr );
            goto lDone;
        }

        hr = pServer->get_CurrentServerName( &bsCurrentServer );
        if( FAILED( hr ) )
        {
            XomNtEvent( XEVENT_PRESENCE_CONFIG_48, "CPresenceConfig::LoadBucketMap() - IBucketServer.CurrentServer failed, hr=0x%08X", hr );
            goto lDone;
        }

        hr = pServer->get_NextServerName( &bsNextServer );
        if( FAILED( hr ) )
        {
            XomNtEvent( XEVENT_PRESENCE_CONFIG_49, "CPresenceConfig::LoadBucketMap() - IBucketServer.NextServer failed, hr=0x%08X", hr );
            goto lDone;
        }

        hr = pServer->get_NextServerStart( &dtMigrationStart );
        if( FAILED( hr ) )
        {
            XomNtEvent( XEVENT_PRESENCE_CONFIG_50, "CPresenceConfig::LoadBucketMap() - IBucketServer.NextServerStart failed, hr=0x%08X", hr );
            goto lDone;
        }

        rgBucketMap[ iBucket ].dwServerIndex = GetServerByName( bsCurrentServer );
        rgBucketMap[ iBucket ].dwNextServerIndex = GetServerByName( bsNextServer );
        rgBucketMap[ iBucket ].dtStart = dtMigrationStart;
        rgBucketMap[ iBucket ].cBucketUsers = 0;
        rgBucketMap[ iBucket ].fAltServerValid = TRUE;
    }

    // Replace the old map
    rgOldBucketMap = m_rgBucketMap;
    m_dwBucketCount = cBuckets;
    m_rgBucketMap = rgBucketMap;
    rgBucketMap = NULL;
    
    m_dwLastBucketLoad = dwNow;

lDone:

    if (rgBucketMap != NULL)
    {
        delete[] rgBucketMap;
    }
    if (rgOldBucketMap != NULL)
    {
        delete[] rgOldBucketMap;
    }

    return hr;
}

/*****************************************************************************

CPresenceConfig::HashPUID

Hash a PUID

*****************************************************************************/
DWORD CPresenceConfig::HashPUID(QWORD qwPUID) 
{ 
    // NOTE: make sure this is always the same as GetBucketNum() defined in Config.cs
    return (DWORD)(qwPUID % m_dwBucketCount);
}

/*****************************************************************************

CPresenceConfig::GetServerByName

Get a server by interface name

*****************************************************************************/
DWORD CPresenceConfig::GetServerByName(BSTR m_bstrInterfaceName)
{
    DWORD dwIndex;

    for (dwIndex = 0; dwIndex < m_cPresServers; dwIndex++)
    {
        if (m_rgPresServers[dwIndex].bstrInterfaceName == m_bstrInterfaceName)
        {
            return dwIndex;
        }
    }
    return P_NOT_FOUND;
}

/*****************************************************************************

CPresenceConfig::GetHostAddrs

Get the local IP addresses

*****************************************************************************/
HRESULT CPresenceConfig::GetHostAddrs(in_addr *rgsaAddrs, DWORD *pcAddrs) 
{
    HRESULT hr = S_OK;
    int iRet= 0;
    DWORD dwIndex;
    CHAR szLocalHost [256];
    LPHOSTENT phe = NULL;
 
    // Get the local hostname
    iRet = gethostname(szLocalHost, 256);
    if (iRet != 0) 
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
        goto lDone; 
    }

    // Resolve hostname for local address
    phe = gethostbyname((LPSTR)szLocalHost);
    if (phe == NULL)
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
        goto lDone;
    }

    for (dwIndex = 0; (phe->h_addr_list[dwIndex] != NULL) && (dwIndex < *pcAddrs); dwIndex++) 
    {
        memcpy(rgsaAddrs + dwIndex, phe->h_addr_list[dwIndex], sizeof(in_addr));
    }

    *pcAddrs = dwIndex;

lDone:

    if (FAILED(hr))
    {
        pcAddrs = 0;
    }

    return hr;
}

/*****************************************************************************

CPresenceConfig::AddServer

Add a new presence server

*****************************************************************************/

HRESULT CPresenceConfig::AddServer(BSTR bstrServerName, DWORD dwServerIndex)
{
    HRESULT hr = S_OK;
    DWORD dwIndex;
    CComPtr<IInterfaceInfo> pInterfaceInfo;
    CComBSTR bsIPAddress;
    long lPort;
    HOSTENT *pHE = NULL;
    in_addr rgsaAddrs[8]; 
    DWORD cAddrs = 8;
    
    // Figure out our local addresses
    hr = GetHostAddrs(rgsaAddrs, &cAddrs);
    if (FAILED(hr))
    {
        goto lDone;
    }

    if (dwServerIndex >= P_MAX_P_SERVERS)
    {
        return E_FAIL;
    }

    m_rgPresServers[dwServerIndex].bstrInterfaceName = bstrServerName;

    // Build a socket address for the signature server
    memset (&(m_rgPresServers[dwServerIndex].sa), 0, sizeof(sockaddr_in));
    m_rgPresServers[dwServerIndex].sa.sin_family = AF_INET;
    memset (&(m_rgPresServers[dwServerIndex].saPeer), 0, sizeof(sockaddr_in));
    m_rgPresServers[dwServerIndex].saPeer.sin_family = AF_INET;

    hr = __gConfigWrapper->GetInterface(bstrServerName, Interface_xpserver, &pInterfaceInfo);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = pInterfaceInfo->get_IPAddressString(&bsIPAddress);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = pInterfaceInfo->get_Port(&lPort);
    if (FAILED(hr))
    {
        goto lDone;
    }

    pHE = gethostbyname( CW2A(bsIPAddress) );
    if( NULL == pHE )
    {
        hr = HRESULT_FROM_WIN32( WSAGetLastError() );
        goto lDone;
    }

    memcpy( &(m_rgPresServers[dwServerIndex].sa.sin_addr), pHE->h_addr, pHE->h_length );
    m_rgPresServers[dwServerIndex].sa.sin_port = htons( (WORD)lPort );
    memcpy( &(m_rgPresServers[dwServerIndex].saPeer.sin_addr), pHE->h_addr, pHE->h_length );
    m_rgPresServers[dwServerIndex].saPeer.sin_port = htons( (WORD)m_dwPeerPort );

    // Is it me?
    for (dwIndex = 0; dwIndex < cAddrs; dwIndex++)
    {
        if (rgsaAddrs[dwIndex].s_addr == m_rgPresServers[dwServerIndex].sa.sin_addr.s_addr)
        {
            m_dwMyIndex = dwServerIndex;
            break;
        }
    }

lDone:
    return hr;
}

HRESULT CPresenceConfig::ChangeServerList(DWORD cServers, CComBSTR *rgbsServers)
{
    HRESULT hr = S_OK;
    DWORD *rgdwIndexMap = NULL;
    PresServerConfig *rgNewPresServers = NULL;
    DWORD dwOldServer = 0;
    DWORD dwNewServer = 0;

    // build a translation map for the indices
    rgdwIndexMap = new DWORD[m_cPresServers];
    if (rgdwIndexMap == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    for (dwOldServer = 0; dwOldServer < m_cPresServers; dwOldServer++)
    {
        rgdwIndexMap[dwOldServer] = 0xFFFFFFFF;
        for (dwNewServer = 0; dwNewServer < cServers; dwNewServer++)
        {
            if (rgbsServers[dwNewServer] == m_rgPresServers[dwOldServer].bstrInterfaceName)
            {
                rgdwIndexMap[dwOldServer] = dwNewServer;
            }
        }
    }

    // make a new connection list and copy over any old connections that still remain.
    rgNewPresServers = new PresServerConfig[cServers];
    if (rgNewPresServers == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    for (dwOldServer = 0; dwOldServer < m_cPresServers; dwOldServer++)
    {
        if (rgdwIndexMap[dwOldServer] != 0xFFFFFFFF)
        {
            rgNewPresServers[rgdwIndexMap[dwOldServer]].bstrInterfaceName = m_rgPresServers[dwOldServer].bstrInterfaceName;
            memcpy(&(rgNewPresServers[rgdwIndexMap[dwOldServer]].sa), &(m_rgPresServers[dwOldServer].sa), sizeof(sockaddr_in));
            memcpy(&(rgNewPresServers[rgdwIndexMap[dwOldServer]].saPeer), &(m_rgPresServers[dwOldServer].saPeer), sizeof(sockaddr_in));
        }
    }

    // copy back over the real list
    for (m_cPresServers = 0; m_cPresServers < cServers; m_cPresServers++)
    {
        m_rgPresServers[m_cPresServers].bstrInterfaceName = rgNewPresServers[m_cPresServers].bstrInterfaceName;
        memcpy(&(m_rgPresServers[m_cPresServers].sa), &(rgNewPresServers[m_cPresServers].sa), sizeof(sockaddr_in));
        memcpy(&(m_rgPresServers[m_cPresServers].saPeer), &(rgNewPresServers[m_cPresServers].saPeer), sizeof(sockaddr_in));
    }

    // update my server index
    m_dwMyIndex = rgdwIndexMap[m_dwMyIndex];

    // make new connections
    for (dwNewServer = 0; dwNewServer < cServers; dwNewServer++)
    {
        if (rgNewPresServers[dwNewServer].bstrInterfaceName.Length() == 0)
        {
            hr = AddServer(rgbsServers[dwNewServer], dwNewServer);
            if (FAILED(hr))
            {
                goto lDone;
            }
        }
    }

    // rearrange the bucket map
    for (DWORD dwBucket = 0; dwBucket < m_dwBucketCount; dwBucket++)
    {
        m_rgBucketMap[dwBucket].dwServerIndex = rgdwIndexMap[m_rgBucketMap[dwBucket].dwServerIndex];
        m_rgBucketMap[dwBucket].dwNextServerIndex = rgdwIndexMap[m_rgBucketMap[dwBucket].dwNextServerIndex];
    }

lDone:

    SAFE_ARRAYDELETE(rgdwIndexMap);
    SAFE_ARRAYDELETE(rgNewPresServers);

    return hr;
}


// CPresConfigListener notification handlers

HRESULT __stdcall CPresConfigListener::SettingChange (
    struct ISettingChangeEventArgs * e )
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT __stdcall CPresConfigListener::InterfaceBucketChange (
    struct IInterfaceBucketChangeEventArgs * e )
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT __stdcall CPresConfigListener::ServerListChange(
    struct IServerListChangeEventArgs * e )
{
    HRESULT hr = S_OK;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\presconfig.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once

#define P_MAX_DWORD_ARRAY 25
#define P_MAX_P_SERVERS 100
#define P_NOT_FOUND 0xFFFFFFFF

class CPresenceConfig;

struct PresServerConfig
{
    CComBSTR bstrInterfaceName;
    sockaddr_in sa;
    sockaddr_in saPeer;
};

struct PresServerBucketConfig
{
    DWORD cBucketUsers;
    DWORD dwServerIndex;
    DWORD dwNextServerIndex;
    DATE dtStart;
    BOOL fAltServerValid;
};


class CPresConfigListener : public CConfigListenerBase
{

    IMPLEMENT_REFCOUNT_COM
        
public:

    CPresConfigListener()
    { }

    virtual ~CPresConfigListener() 
    {
    }

    STDMETHODIMP QueryInterface( REFIID riid, void** ppObj )
    {
        HRESULT hr;

        if(ppObj == NULL)
            return E_POINTER;

        if(riid == IID_IUnknown)
        {
            *ppObj = (void*)(IUnknown*)this;
            hr = S_OK;
            AddRef();
        }
        else if (riid == _uuidof(IConfigListener))
        {
            *ppObj = (void*)(IConfigListener*)this;
            hr = S_OK;
            AddRef();
        }
        else
            hr = E_NOINTERFACE;

        return hr;
    }    

    virtual HRESULT __stdcall SettingChange (
        /*[in]*/ struct ISettingChangeEventArgs * e );

    virtual HRESULT __stdcall InterfaceBucketChange (
        /*[in]*/ struct IInterfaceBucketChangeEventArgs * e );

    virtual HRESULT __stdcall ServerListChange (
        /*[in]*/ struct IServerListChangeEventArgs * e );
};


// NOTE:  all queries to Config from within presence are cached through this class.

class CPresenceConfig
{
public:
    CPresenceConfig() :
        m_dwLastBucketLoad(0),
        m_dwMyIndex(P_NOT_FOUND),
        m_pConfigListener(NULL)
    {}
    ~CPresenceConfig()
    {
        Shutdown();
    }

    DWORD GetHeartbeatDelay() { return m_dwHeartbeatDelay; }
    DWORD GetMaxQValsPerHeartbeat() { return m_dwMaxQValsPerHeartbeat; }
    DWORD GetPresUserCleanupDelay() { return m_dwPresUserCleanupDelay; }
    DWORD GetIdleQValsCheck() { return m_dwIdleQValsCheck; }
    u_short GetSGQValSendPort() { return (u_short) m_dwSGQValSendPort; }
    u_short GetSGQValRecvPort() { return (u_short) m_dwSGQValRecvPort; }
    DWORD *GetQValRetryDelays() { return m_rgdwQValRetryDelays; }
    DWORD GetQValRetryDelaysLen() { return m_dwQValRetryDelaysLen; }
    DWORD GetUserIndexSize() { return m_dwUserIndexSize; }
    DWORD GetXBoxIndexSize() { return m_dwXBoxIndexSize; }
    DWORD GetSGIndexSize() { return m_dwSGIndexSize; }
    DWORD GetWebUserTimeout() { return m_dwWebUserTimeout; }
    DWORD GetDeadSgOnFailedQVal() { return m_dwDeadSgOnFailedQVal; }
    DWORD GetConcurrentSQLThreads() { return m_dwConcurrentSQLThreads; }
    DWORD GetNumSQLThreads() { return m_dwNumSQLThreads; }
    DWORD GetStartNumPoolBuffers() { return m_dwStartNumPoolBuffers; }
    DWORD GetMaxNumPoolBuffers() { return m_dwMaxNumPoolBuffers; }
    DWORD GetPoolBufferSize() { return m_dwPoolBufferSize; }
    DWORD GetMaxPresenceUsers() { return m_dwMaxPresenceUsers; }
    DWORD GetMaxRichPresenceBytes() { return m_dwMaxRichPresenceBytes; }
    DWORD GetExpirationCheckInterval() { return m_dwExpirationCheckInterval; }
    WORD GetPeerPort() { return (WORD) m_dwPeerPort; }
    DWORD GetMessageTimeout() { return (WORD) m_dwMessageTimeout; }
    DWORD GetStateBitsNotifyWhitelist() { return m_dwStateBitsNotifyWhitelist; }
    BOOL GetEnableRichPresence() { return m_fEnableRichPresence; }

    DWORD GetValidMessageType(DWORD dwType)
    { 
        if (dwType > m_dwValidMessageTypesLen)
        {
            return 0xFFFFFFFF;
        }
        else
        {
            return m_rgdwValidMessageTypes[dwType];
        }
    }
    DWORD GetValidMessageTypesLen() { return m_dwValidMessageTypesLen; }
    DWORD GetMessageTypeExpiration(DWORD dwType)
    {
        if (dwType > m_dwValidMessageTypesLen)
        {
            return 43200; // 30 days
        }
        else
        {
            return m_rgdwMessageTypeExpirations[dwType]; 
        }
    }
    DWORD GetMessageTypeExpirationsLen() { return m_dwMessageTypeExpirationsLen; }

    DWORD GetMessagingDailySends() { return m_dwMessagingDailySends; }
    DWORD GetMessagingDailyRecipients() { return m_dwMessagingDailyRecipients; }

    BOOL GetQueryAffiliatesOkToPeerSubscribe() { return m_fQueryAfffiliatesOkToPeerSubscribe; }

    DWORD GetAffiliatesEncounteredListSize() { return m_dwAffiliatesEncounteredListSize; }
    DWORD GetAffiliatesCompletedGameListSize() { return m_dwAffiliatesCompletedGameListSize; }
    DWORD GetAffiliatesPositiveFeedbackListSize() { return m_dwAffiliatesPositiveFeedbackListSize; }
    DWORD GetAffiliatesNegativeFeedbackListSize() { return m_dwAffiliatesNegativeFeedbackListSize; }
    DWORD GetAffiliatesAvoidingMeListSize() { return m_dwAffiliatesAvoidingMeListSize; }
    DWORD GetAffiliatesFavoritesListSize() { return m_dwAffiliatesFavoritesListSize; }

    DWORD GetProtocolVersion() {return m_dwProtocolVersion; }

    HRESULT Init();
    void Shutdown()
    {
        if (m_pConfig && m_pConfigListener)
        {
            m_pConfig->putref_ConfigListener(NULL);
            m_pConfigListener->Release();
            m_pConfigListener = NULL;
        }
        if (m_pConfig)
        {
            m_pConfig.Release();
            m_pConfig = NULL;
        }
    }

    CComBSTR GetWebStoreApplicationName(CComBSTR virtualInterface)
    {
        long siteId;
        IVirtualInterfaceInfo *piVII = NULL;
        CComBSTR bstrWBAName;
        
        HRESULT hr = m_pConfig->get_SiteId(&siteId);
        if (FAILED(hr))
        {
            goto lDone;
        }
        
        hr = m_pConfig->GetVirtualInterface(virtualInterface, siteId, &piVII);
        if (FAILED(hr) || (piVII == NULL))
        {
            goto lDone;
        }

        hr = piVII->get_WebstoreApp(&bstrWBAName);
        if (FAILED(hr))
        {
            goto lDone;
        }

    lDone:

        if (piVII != NULL)
        {
            piVII->Release();
        }

        return bstrWBAName;
    }

    HRESULT Reload(struct ISettingChangeEventArgs * eventArgs);
    HRESULT ChangeBucketMap(DWORD dwBucket, CComBSTR bsCurrentServer, CComBSTR bsNextServer, DATE dtStart, BOOL fMine);
    HRESULT LoadBucketMap();

    HRESULT ChangeServerList(DWORD cServers, CComBSTR *rgbsServers);

    CComBSTR GetBucketCurrentServerName(DWORD dwBucket)
    {
        return m_rgPresServers[m_rgBucketMap[dwBucket].dwServerIndex].bstrInterfaceName;
    }

    CComBSTR GetBucketNextServerName(DWORD dwBucket)
    {
        return m_rgPresServers[m_rgBucketMap[dwBucket].dwNextServerIndex].bstrInterfaceName;
    }

    DWORD GetBucketCount() { return m_dwBucketCount; }

    DWORD GetBucketUserCount(DWORD dwBucket)
    {
        return m_rgBucketMap[dwBucket].cBucketUsers;
    }

    void AddBucketUser(QWORD qwUserID)
    {
        m_rgBucketMap[HashPUID(qwUserID)].cBucketUsers++;
    }

    void RemoveBucketUser(QWORD qwUserID)
    {
        m_rgBucketMap[HashPUID(qwUserID)].cBucketUsers--;
    }

    BOOL IsBucketMine(DWORD dwBucket)
    {
        return (m_rgBucketMap[dwBucket].dwServerIndex == m_dwMyIndex);
    }

    void CompleteBucketMigration(DWORD dwBucket)
    {
        m_pConfig->CompleteMigration(Interface_xpserver, dwBucket);
    }

    void SetBucketValidAltServerFlag(DWORD dwBucket, BOOL fValid)
    {
        m_rgBucketMap[dwBucket].fAltServerValid = fValid;
    }

    BOOL IsValidOnWatchAddr(IN_ADDR inaddr);
	DWORD MapUserToPresSrv(QWORD qwUserID, BOOL fAlt = FALSE);
    DWORD GetNumPresServers() { return m_cPresServers; }
    CComBSTR GetPresServerName(DWORD dwIndex);
    sockaddr_in *GetPresServerAddr(DWORD dwIndex);
    sockaddr_in *GetPresServerPeerAddr(DWORD dwIndex);
    DWORD GetMyPresServerIndex() { return m_dwMyIndex; }
    BOOL CheckDestination(QWORD qwUserID);
    DWORD HashPUID(QWORD qwPUID);

    CComBSTR GetNPDBName() { return m_bsNPDBName; }
    CComBSTR GetNPDBAddress() { return m_bsNPDBAddress; }

protected:

    HRESULT Load();
    HRESULT LoadSettings();
    HRESULT LoadXonWatchIPs();
    HRESULT LoadPresenceServers();
    HRESULT LoadNPDBInfo();

    DWORD GetDWORDSetting(CComBSTR Setting, CComBSTR bsValue = CComBSTR(NULL));
    void GetDWORDArraySetting(CComBSTR Setting, DWORD *pdwLen, DWORD *rgdwVal, CComBSTR bsValue = CComBSTR(NULL));

    DWORD GetServerByName(BSTR m_bstrInterfaceName);
    HRESULT GetHostAddrs(in_addr *rgsaAddrs, DWORD *pcAddrs);
    HRESULT AddServer(BSTR bstrInterfaceName, DWORD dwServerIndex);

    CComPtr<IConfig> m_pConfig;
    CPresConfigListener *m_pConfigListener;
        
    DWORD m_dwHeartbeatDelay;
    DWORD m_dwMaxQValsPerHeartbeat;
    DWORD m_dwPresUserCleanupDelay;
    DWORD m_dwIdleQValsCheck;
    DWORD m_dwSGQValSendPort;
    DWORD m_dwSGQValRecvPort;
    DWORD m_rgdwQValRetryDelays[P_MAX_DWORD_ARRAY];
    DWORD m_dwQValRetryDelaysLen;
    DWORD m_dwUserIndexSize;
    DWORD m_dwXBoxIndexSize;
    DWORD m_dwSGIndexSize;
    DWORD m_dwWebUserTimeout;
    DWORD m_dwDeadSgOnFailedQVal;
    DWORD m_dwConcurrentSQLThreads;
    DWORD m_dwNumSQLThreads;
    DWORD m_dwStartNumPoolBuffers;
    DWORD m_dwMaxNumPoolBuffers;
    DWORD m_dwPoolBufferSize;
    DWORD m_dwMaxPresenceUsers;
    DWORD m_dwMaxRichPresenceBytes;
    DWORD m_dwExpirationCheckInterval;
    DWORD m_dwPeerPort;
    DWORD m_dwMessageTimeout;
    DWORD m_dwBucketReloadDelay;
    DWORD m_rgdwValidMessageTypes[P_MAX_DWORD_ARRAY];
    DWORD m_dwValidMessageTypesLen;
    DWORD m_rgdwMessageTypeExpirations[P_MAX_DWORD_ARRAY];
    DWORD m_dwMessageTypeExpirationsLen;
    DWORD m_dwMessagingDailySends;
    DWORD m_dwMessagingDailyRecipients;
    BOOL m_fQueryAfffiliatesOkToPeerSubscribe;
    DWORD m_dwAffiliatesEncounteredListSize;
    DWORD m_dwAffiliatesCompletedGameListSize;
    DWORD m_dwAffiliatesPositiveFeedbackListSize;
    DWORD m_dwAffiliatesNegativeFeedbackListSize;
    DWORD m_dwAffiliatesAvoidingMeListSize;
    DWORD m_dwAffiliatesFavoritesListSize;
    DWORD m_dwProtocolVersion;
    DWORD m_dwStateBitsNotifyWhitelist;
    DWORD m_fEnableRichPresence;
        
    struct XonWatchIP {
        in_addr inaIP;
        in_addr inaMask;
    };

    DWORD m_cXonWatchIPs;
    XonWatchIP *m_psXonWatchIPs;

    // Bucket info
    DWORD m_dwLastBucketLoad;
    DWORD m_dwBucketCount;
    PresServerBucketConfig *m_rgBucketMap;

    // Server info
    DWORD m_cPresServers;
    DWORD m_dwMyIndex;
    PresServerConfig m_rgPresServers[P_MAX_P_SERVERS];

    CComBSTR m_bsNPDBAddress;
    CComBSTR m_bsNPDBName;
};

extern CPresenceConfig g_CPresCfg;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\QVal.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2002 Microsoft.  ALL RIGHTS RESERVED
/////////////////////////////////////////////////////////////////////////////
#pragma once

struct SGQVal
{
    DWORD m_qvalFlags;
    DWORD m_dwFlags;
    DWORD m_qvalNewInvite;
    DWORD m_qvalNewMsgIds;
    DWORD m_dwMsgId1;
    DWORD m_dwMsgId2;
    DWORD m_dwMsgId3;
    DWORD m_qvalNewMsgData;
    DWORD m_dwMsgData1;
    DWORD m_dwMsgData2;
    DWORD m_dwMsgData3;
    DWORD m_qvalDelMsgIds;
    DWORD m_dwDelId1;
    DWORD m_dwDelId2;
    DWORD m_dwDelId3;

    // Extra data not part of actual packet
    ULONGLONG m_qwUserId;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\Scheduler.h ===
#pragma once

class XPQTaskMgr;
class WorkerTaskThread;
class SchedulerTaskThread : public TaskThread
{
public:

    SchedulerTaskThread();
    ~SchedulerTaskThread();

    HRESULT  SetCompletionPort(CompletionPort *pCP);

    HRESULT  PostCompletedTask(XPQTask *pTask);
    HRESULT  PostFailedTask(XPQTask *pTask);

    void     LogStats() const;

    void     SetLoadScale(float fScale);
    float    LoadScale() const;

protected:

    void     ProcessCleanupQueue(const CVPtrArray &TaskList);
    void     ProcessFailedQueue();
	DWORD    GetLeftToSchedule(const CVPtrArray &TaskList, DWORD *prgLeftToSchedule);
    void     DistributeTasks(
                    const CVPtrArray &TaskList, 
                    DWORD dwInProgressLeft,
                    DWORD dwTasksLeft,
                    DWORD *prgLeftToSchedule);
    DWORD    ScheduleTasks(
                    XPQTaskPacing *pTaskPacing,
                    DWORD dwToSchedule);
    void     ProcessPendingQVals();

    void     MarkResources(XPQUserMgr *pUserMgr, TaskResourceMark &Mark);

    void     ValidateResourceRelease(
                XPQTask *pTask,
                TaskResourceMark &MarkA, 
                TaskResourceMark &MarkB,
                TaskResourceMark &Aquired,
                TaskResourceMark &Released);

    void     ValidateResourceAquire(
                XPQTask *pTask,
                TaskResourceMark &MarkA, 
                TaskResourceMark &MarkB,
                TaskResourceMark &Aquired);

    void     RunInternal();

    HRESULT  AquireConnection(BasePresenceConnection **ppOutConn, bool SendToINH);
    void     ReleaseConnection(BasePresenceConnection *pConn);


private:
    DWORD                  m_dwFailedTaskTimeout;
	DWORD                  m_dwMaxInProgress;
    CompletionPort*        m_pCP;
    LockFreeFifo<XPQTask*> m_CleanupQueue;

	// failed queue to be cleaned up and a Peek at front
	XPQTask *			   m_pFrontFailedTask;
	LockFreeFifo<XPQTask*> m_FailedQueue;

	CVPtrList              m_FreeConnList;
    float                  m_fLoadScale;                   
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\switchboard.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

MGMT_DefineLoggingCategory( Switchboard );
#define FAIL_GOTO_DONE(op, expr) if(FAILED((expr))) { ERR1(Switchboard, #op " failed " #expr ", HR: 0x%08x", hr); goto lbDone; }

/*****************************************************************************

CRequestContext::CRequestContext

Constructor

*****************************************************************************/
CRequestContext::CRequestContext(XPQMsg * pMsg) :
    m_dwContextId(0),
    m_pCContextIndexNext(NULL),
    m_pCContextIndexBack(NULL),
	m_pUser(NULL),
	m_pTask(NULL),
	m_pSwitchboard(NULL)
	{
		// we own this memory now and need to delete it
		m_pMsg = pMsg;
	}

/*****************************************************************************

CRequestContext::~CRequestContext

Destructor

*****************************************************************************/
CRequestContext::~CRequestContext()
{
	SAFE_DELETE(m_pMsg);
    SAFE_RELEASE(m_pSwitchboard);
	SAFE_RELEASE(m_pCP);
}

/*****************************************************************************

CRequestContext::OnIoCompletion

*****************************************************************************/
void CRequestContext::OnIoCompletion( 
    DWORD dwError, 
    DWORD cbTransferred, 
    ULONG_PTR ulpKey,
    CCompletionContext *pCtx )
{
    XOMASSERT( NULL != m_pSwitchboard );
    XOMASSERT( pCtx == this );

    m_pSwitchboard->ProcessRequest(this);
}

/*****************************************************************************

CRequestContext::Init

*****************************************************************************/
void CRequestContext::Init(XPQTask*      pTask,
						   XPQUser*      pUser, 
						   CSwitchboard *pCSwitchboard,
						   CompletionPort* pCP)
{
	m_pTask = pTask;
	m_pUser = pUser;
	m_pSwitchboard = pCSwitchboard;
	m_pSwitchboard->AddRef();
	m_pCP = pCP;
	m_pCP->AddRef();
}

/*****************************************************************************

CRequestContext::SetHR

*****************************************************************************/
void CRequestContext::SetHR(HRESULT hr)
{
	m_pTask->Completed(hr);
}



/*****************************************************************************

CRequestContextIndex::CRequestContextIndex

Constructor

*****************************************************************************/
CRequestContextIndex::CRequestContextIndex() :
    m_cBuckets(0),
    m_rgpCRequestContextHashTable(NULL),
	m_dwNumEntries(0)
{
}

/*****************************************************************************

CRequestContextIndex::~CRequestContextIndex

Destructor

*****************************************************************************/
CRequestContextIndex::~CRequestContextIndex()
{
    if (m_rgpCRequestContextHashTable != NULL)
    {
        delete m_rgpCRequestContextHashTable;
    }
}

/*****************************************************************************

CRequestContextIndex::Init

Initializer

*****************************************************************************/
HRESULT CRequestContextIndex::Init()
{
    HRESULT hr = S_OK;

    m_cBuckets = g_CPresCfg.GetBucketCount();

    m_rgpCRequestContextHashTable = new CRequestContext *[m_cBuckets];
    if (m_rgpCRequestContextHashTable == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    memset(m_rgpCRequestContextHashTable, 0, sizeof(CRequestContext *) * m_cBuckets);

lDone:
    return hr;
}

/*****************************************************************************

CRequestContextIndex::AddContext

*****************************************************************************/
void CRequestContextIndex::AddContext(CRequestContext *pCCtx)
{
    DWORD dwBucket = Hash(pCCtx->GetContextId());
    CRequestContext *pCBucket = NULL;

    pCCtx->AddRef();

    pCBucket = m_rgpCRequestContextHashTable[dwBucket];

    pCCtx->m_pCContextIndexNext = pCBucket;
    pCCtx->m_pCContextIndexBack = NULL;

    if (pCBucket != NULL)
    {
        pCBucket->m_pCContextIndexBack = pCCtx;
    }

    m_rgpCRequestContextHashTable[dwBucket] = pCCtx;
	++m_dwNumEntries;
}

/*****************************************************************************

CRequestContextIndex::RemoveContext

*****************************************************************************/
void CRequestContextIndex::RemoveContext(CRequestContext *pCCtx)
{
    DWORD dwBucket = Hash(pCCtx->GetContextId());

    // Fix up the item behind me
    if (pCCtx->m_pCContextIndexBack != NULL)
    {
        pCCtx->m_pCContextIndexBack->m_pCContextIndexNext = pCCtx->m_pCContextIndexNext;
    }
    else if (m_rgpCRequestContextHashTable[dwBucket] == pCCtx)
    {
        // Go back to the index
        m_rgpCRequestContextHashTable[dwBucket] = pCCtx->m_pCContextIndexNext;
    }

    // Fix up the item in front of me
    if (pCCtx->m_pCContextIndexNext != NULL)
    {
        pCCtx->m_pCContextIndexNext->m_pCContextIndexBack = pCCtx->m_pCContextIndexBack;
    }

    // Mark the removed item as not in the list
    pCCtx->m_pCContextIndexNext = NULL;
    pCCtx->m_pCContextIndexBack = NULL;

    pCCtx->Release();
	--m_dwNumEntries;
}

/*****************************************************************************

CRequestContextIndex::GetContext

*****************************************************************************/
CRequestContext *CRequestContextIndex::GetContext(DWORD dwContextId)
{
    DWORD dwBucket = Hash(dwContextId);
    CRequestContext *pCCtx;

    pCCtx = m_rgpCRequestContextHashTable[dwBucket];
    while (pCCtx != NULL)
    {
        if (pCCtx->GetContextId() == dwContextId)
        {
            return pCCtx;
        }
        else
        {
            pCCtx = pCCtx->m_pCContextIndexNext;
        }

    }

    return NULL;
}

const SGADDR sgaddrIgnore = { 0, 0, 0, 0, 0, 0, 0};

/*****************************************************************************

CHeartbeatHandler::Release

*****************************************************************************/
ULONG CHeartbeatHandler::AddRef()
{
    return m_pSwitchboard->AddRef();
}

/*****************************************************************************

CHeartbeatHandler::Release

*****************************************************************************/
ULONG CHeartbeatHandler::Release()
{
    return m_pSwitchboard->Release();
}

/*****************************************************************************

CHeartbeatHandler::OnIoCompletion

*****************************************************************************/
void CHeartbeatHandler::OnIoCompletion( 
    DWORD dwError, 
    DWORD cbTransferred, 
    ULONG_PTR ulpKey,
    CCompletionContext *pCtx )
{
    XOMASSERT( NULL != m_pSwitchboard );
    XOMASSERT( pCtx == this );

    m_pSwitchboard->PeriodicHeartbeat();
}

/*****************************************************************************

CSwitchboard::CSwitchboard

Constructor

*****************************************************************************/
// Allow this to be used in initialization
#pragma warning( disable:4355 ) 

CSwitchboard::CSwitchboard() :
    m_pCompPort( NULL ),
    m_HeartbeatHandler( this ),
    m_dwLastIndex(0)
{
    // Set last heartbeat to now
    m_dwLastHeartBeat = GetTickCount();
}

#pragma warning( default:4355 )


/*****************************************************************************

CSwitchboard::~CSwitchboard

Destructor

*****************************************************************************/
CSwitchboard::~CSwitchboard()
{
    Shutdown();
}


/*****************************************************************************

CSwitchboard::Init

Initializer, must be called before first use.

*****************************************************************************/
HRESULT CSwitchboard::Init()
{
    HRESULT hr = S_OK;

    // Create worker threads to deal with incoming network traffic
    hr = CCompletionPort::CreateInstance(
        0,  // dwConcurrancy
        1,  // dwThreadPoolSize
        THREAD_PRIORITY_HIGHEST,
        &m_pCompPort );
    
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_59, "Unrecoverable failure while initializing: CCompPort::CreateInstance failed (%X)", hr);
        goto lDone;
    }

    // Initialize our clusters
    hr = m_CXPCluster.Init(m_pCompPort, this);
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_60, "Unrecoverable failure while initializing: m_CXPCluster.Init failed (%X)", hr);
        goto lDone;
    }
   
	// Create the request context index
    hr = m_RequestContextIndex.Init();
    if( FAILED( hr ) )
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_85, "Unrecoverable failure while initializing: Failed to init request context index hr=0x%X", hr);
        goto lDone;
    }

    hr = S_OK;
    
lDone:

    return hr;
}

/*****************************************************************************

CSwitchboard::Shutdown

Deinitializer

*****************************************************************************/
void CSwitchboard::Shutdown()
{
    // CONSIDER: formal XPCluster and XQCluster shutdown
    if ( m_pCompPort != NULL)
    {
        m_pCompPort->Shutdown();
        m_pCompPort->Release();
        m_pCompPort = NULL;
    }
}

/*****************************************************************************

CSwitchboard::OnHeartbeat

Regularly called from ServiceMain.  Posts a heartbeat object to the main 
completion port.

*****************************************************************************/
void CSwitchboard::OnHeartbeat()
{
	if(m_dwLastHeartBeat + 1000 < GetTickCount())
	{
		HRESULT hr;
	    
		if (m_pCompPort != NULL)
		{
			hr = m_pCompPort->PostCompletion( &m_HeartbeatHandler );
			XOMASSERT( SUCCEEDED( hr ) );
		}
		else
		{
			XOMASSERT(FALSE);
		}
	}
}

/*****************************************************************************

CSwitchboard::PeriodicHeartbeat

Callback from listening socket.

*****************************************************************************/
void CSwitchboard::PeriodicHeartbeat()
{
	m_dwLastHeartBeat = GetTickCount();
    m_CXPCluster.PeriodicHeartbeat();
}

/*****************************************************************************

CSwitchboard::ProcessReqeust

Process a request

*****************************************************************************/
void CSwitchboard::ProcessRequest(CRequestContext *pRequest)
{
	HRESULT hr = S_OK;
	XPQMsg *pMsg = pRequest->GetMsg();
	Q_DEQUEUE_MSG* msgDequeue = (Q_DEQUEUE_MSG*)pMsg->GetMsg();
	pRequest->SetContextId(pMsg->SeqNum());
	hr = SendMsgDequeue(pRequest->GetContextId(),msgDequeue);
	if(FAILED(hr))
	{
		if(pRequest != NULL)
			pRequest->Complete();
		SAFE_RELEASE(pRequest);
	}
	else
	{
		m_RequestContextIndex.AddContext(pRequest);
	}
}

/*****************************************************************************

CSwitchboard::ProcessMsgListReply

Process a List Reply message

*****************************************************************************/
void CSwitchboard::ProcessMsgListReply(Q_LIST_REPLY_MSG *pMsg, DWORD cbEntireMsg)
{
	HRESULT hr;
    CRequestContext *pCCtx = NULL;

    // Find the matching context
    pCCtx = m_RequestContextIndex.GetContext(pMsg->dwSeqNum);
    if (pCCtx != NULL)
    {
		m_RequestContextIndex.RemoveContext(pCCtx);
		BYTE* pData = (BYTE*)pMsg + sizeof(Q_LIST_REPLY_MSG);
		DWORD cdwQVal = pMsg->cdwQVals;

		XPQUser* pUser = pCCtx->GetUser();
		XPQTask* pTask = pCCtx->GetTask();

		if(FAILED(pMsg->hr))
		{
			pTask->Completed(pMsg->hr);
		}
	    
		if(15 == cdwQVal)
		{
			SGQVal qval = *(SGQVal*)pData;

			//
			// Handle the qval in the dequeue response which will collapse any pending
			// notification state on this user.
			//
			qval.m_qwUserId = pMsg->qwUserID;
			FAIL_GOTO_DONE(DEQUEUE, hr = pUser->ProcessQVal(qval));
		}

		// Skip qvals data
		pData += cdwQVal * sizeof( DWORD );

		if( pMsg->wQLeft > 0 )
		{
			DBG1(Switchboard, "[FdConnection::CompleteDequeue]: list reply had qitems left: %u", pMsg->wQLeft);
		}

		WORD wNumItems = pMsg->wNumItems;
		for(WORD wi = 0; wi < wNumItems; ++wi)
		{
			XPQUser *pBuddy;
			Q_LIST_ITEM* pItem = (Q_LIST_ITEM*)pData;
			pData += sizeof(Q_LIST_ITEM);

			switch( pMsg->wQType )
			{
				case PQUEUE_BUDDY_REQ:
				case PQUEUE_LIST_CHANGE:
					{
						P_LIST_CHANGE_ITEM* pChangeItem = (P_LIST_CHANGE_ITEM*)pData;

						// Move data pointer to next item
						pData += sizeof(P_LIST_CHANGE_ITEM) + pChangeItem->cbTargetAcctName;

						if(HRESULT_FROM_WIN32(ERROR_USER_EXISTS) == pChangeItem->hr 
							|| XONLINE_E_NOTIFICATION_FRIEND_PENDING == pChangeItem->hr
							|| 0x80040e2f == pChangeItem->hr) // DB_E_INTEGRITY_VIOLATION
						{
							// Ignore these errors
							break;
						}

						if(FAILED( pChangeItem->hr )) 
						{
							ERR3(Switchboard, "[FdConnection::CompleteDequeue]: user[%I64x] list item: %u, had HR: 0x%08x", 
									pUser->UserId(), wi, pChangeItem->hr );
							break;
						}

						if( pChangeItem->dwListVersion <= pUser->BuddyListVer())
						{
							TRACE3(Switchboard, L_NORMAL, "[FdConnection::CompleteDequeue]: user[%I64x] stale list change %u <= %u", 
									pUser->UserId(), pChangeItem->dwListVersion, pUser->BuddyListVer());
							break;
						}

						pBuddy = gpUserMgr->UserPtrFromId(pChangeItem->qwTargetID); 
						if(0 == pBuddy)
						{
							ERR3(Switchboard, "[Fdconnection::CompleteDequeue]: user[%I64x] friend out of users range: %I64x (%I64)",
									pUser->UserId(),
									pChangeItem->qwTargetID,
									pChangeItem->qwTargetID - gpUserMgr->BaseUserId());
							break;
						}

						TRACE3(Switchboard, L_DEBUG, "[FdConnection::CompleteDequeue]: user[%I64x] dequeued buddy operation op(%u) for buddy[%I64x]",
								pUser->UserId(), 
								pChangeItem->wOperationID, 
								pBuddy->UserId());

						switch( pChangeItem->wOperationID )
						{
							case PLIST_BUDDY_NOP:
								break;
							case PLIST_BUDDY_ADD:
								pUser->AddBuddy(pBuddy, P_BUDDY_STATUS_PENDING);
								break;
							case PLIST_BUDDY_ADDED:
								pUser->AddBuddy(pBuddy, P_BUDDY_STATUS_REQUEST);
								break;

							case PLIST_BUDDY_ACCEPT:
								pUser->AddBuddy(pBuddy, P_BUDDY_STATUS_OK);
								hr = pUser->CleanupBuddyData(pBuddy);
								if(FAILED(hr))
								{
									ERR2(Switchboard, "[FdConnection::CompleteDequeue]: XPQUser::CleanupBuddyData() failed for user: %I64x, HR: 0x%08x",
											pUser->UserId(),
											hr);
								}
	        
								break;

							case PLIST_BUDDY_REJECT:
							case PLIST_BUDDY_DELETE:
								{
									pUser->RemoveBuddy(pBuddy);   
									break;
								}
							default:
								ERR3(Switchboard, "[FdConnection::CompleteDequeue]: invalid operation ID: %u for user[%I64x] from buddy[%I64x]",
										pChangeItem->wOperationID,
										pUser->UserId(),
										pBuddy->UserId());

								_ASSERTE( false );
						}

						pUser->SetBuddyListVersion(pChangeItem->dwListVersion);
					}
					break;
				case PQUEUE_PRESENCE:
					{
						P_PRESENCE_ITEM* pPresenceItem = (P_PRESENCE_ITEM*)pData;

						// TBD!!! Deal with these later
						// ULONGLONG qwBuddyID;
						// DWORD dwTitleID;
						// DWORD dwState;
						// ULONGLONG qwMatchSessionID;
						// WORD  cbNickname;
						// WORD  cbTitleStuff;
						// // byte rgbNickName[];              // Binary
						// // byte rgbTitleStuff[];            // Binary

						pData += 
							sizeof(P_PRESENCE_ITEM) + 
							pPresenceItem->cbNickname +
							pPresenceItem->cbTitleStuff;

						break;
					}
				case PQUEUE_INVITE:
					{
						P_INVITATION_ITEM* pInviteItem = (P_INVITATION_ITEM*)pData;

						XPQUser *pHostUser  = gpUserMgr->UserPtrFromId(pInviteItem->qwHostID);
						pUser->AddReceivedInvite(pHostUser, pInviteItem->dwTitleID, pInviteItem->qwMatchSessionID);
	                    
						pData += sizeof(P_INVITATION_ITEM);

						break;
					}
				case PQUEUE_INVITE_ANSWER:
					{
						P_INVITATION_ANSWER_ITEM* pAnswerItem = (P_INVITATION_ANSWER_ITEM*)pData;
	#if 0
						XPQUser *pInvitee    = gpUserMgr->UserPtrFromId(pAnswerItem->qwInviteeID);
						DWORD dwInviteeIndex = pInvitee->UserIndex();

						_ASSERTE(pInvitee->HasReceivedInvite(pUser));
						_ASSERTE(LODWORD(pAnswerItem->qwMatchSessionID) == pInvitee->UserIndex());
						_ASSERTE(HIDWORD(pAnswerItem->qwMatchSessionID) == pInvitee->TitleId());
	                    
						switch( pAnswerItem->wAnswer )
						{
							case PINVITE_REPLY_NO:
								break;
							case PINVITE_REPLY_YES:
								break;
							default:
								_ASSERTE( false );
						}
	#endif

						pData += sizeof(P_INVITATION_ANSWER_ITEM);

						break;
					}
				case PQUEUE_PEER_PRESENCE:
					{
						P_PEER_PRESENCE_ITEM* pPresenceItem = (P_PEER_PRESENCE_ITEM*)pData;

						// TBD!!! Deal with these later
						// ULONGLONG qwBuddyID;
						// DWORD dwTitleID;
						// DWORD dwState;
						// ULONGLONG qwMatchSessionID;
						// WORD  cbTitleStuff;
						// // byte rgbTitleStuff[];            // Binary

						pData += 
							sizeof(P_PEER_PRESENCE_ITEM) + 
							pPresenceItem->cbTitleStuff;

						break;
					} 
				case PQUEUE_PRESENCE_2:
					{
						P_PRESENCE_2_ITEM* pPresenceItem = (P_PRESENCE_2_ITEM*)pData;

						// TBD!!! Deal with these later
						// ULONGLONG qwBuddyID;
						// DWORD dwTitleID;
						// DWORD dwState;
						// ULONGLONG qwMatchSessionID;
						// WORD  cbNickname;
						// WORD  cbTitleStuff;
						// // byte rgbNickName[];              // Binary
						// // byte rgbTitleStuff[];            // Binary

						pData += 
							sizeof(P_PRESENCE_2_ITEM) + 
							pPresenceItem->cbRichPresence +
							pPresenceItem->cbData;

						break;
					}
				default:
					_ASSERTE( false );
			}
		}
    }
    else
    {
        // Context not found
        // Not an event because a timeout could trigger this
        TRACE1(
            Switchboard,
            L_NORMAL,
            "CSwitchboard::ProcessMsgListReply - Not expecting List reply for context %d.",
            pMsg->dwSeqNum);
    }


    hr = S_OK;

lbDone:

	if(pCCtx != NULL)
		pCCtx->Complete();
	SAFE_RELEASE(pCCtx);
	return;
}

/*****************************************************************************

CSwitchboard::ProcessMsgListReply

Process a List Reply message

*****************************************************************************/
void CSwitchboard::ProcessMsgListReply2(Q_LIST_REPLY_2_MSG *pMsg, DWORD cbEntireMsg)
{
	HRESULT hr;
    CRequestContext *pCCtx = NULL;

    // Find the matching context
    pCCtx = m_RequestContextIndex.GetContext(pMsg->dwSeqNum);
    if (pCCtx != NULL)
    {
		m_RequestContextIndex.RemoveContext(pCCtx);
		BYTE* pData = (BYTE*)pMsg + sizeof(Q_LIST_REPLY_2_MSG);
		DWORD cdwQVal = pMsg->cdwQVals;

		XPQUser* pUser = pCCtx->GetUser();
		XPQTask* pTask = pCCtx->GetTask();

		if(FAILED(pMsg->hr))
		{
			pTask->Completed(pMsg->hr);
		}
	    
		if(15 == cdwQVal)
		{
			SGQVal qval = *(SGQVal*)pData;

			//
			// Handle the qval in the dequeue response which will collapse any pending
			// notification state on this user.
			//
			qval.m_qwUserId = pMsg->qwUserID;
			FAIL_GOTO_DONE(DEQUEUE, hr = pUser->ProcessQVal(qval));
		}

		// Skip qvals data
		pData += cdwQVal * sizeof( DWORD );

		if( pMsg->wQLeft > 0 )
		{
			DBG1(Switchboard, "[FdConnection::CompleteDequeue]: list reply had qitems left: %u", pMsg->wQLeft);
		}

		WORD wNumItems = pMsg->wNumItems;
		for(WORD wi = 0; wi < wNumItems; ++wi)
		{
			XPQUser *pBuddy;
			Q_LIST_ITEM* pItem = (Q_LIST_ITEM*)pData;
			pData += sizeof(Q_LIST_ITEM);

			switch( pMsg->wQType )
			{
				case PQUEUE_BUDDY_REQ:
				case PQUEUE_LIST_CHANGE:
					{
						P_LIST_CHANGE_ITEM* pChangeItem = (P_LIST_CHANGE_ITEM*)pData;

						// Move data pointer to next item
						pData += sizeof(P_LIST_CHANGE_ITEM) + pChangeItem->cbTargetAcctName;

						if(HRESULT_FROM_WIN32(ERROR_USER_EXISTS) == pChangeItem->hr 
							|| XONLINE_E_NOTIFICATION_FRIEND_PENDING == pChangeItem->hr
							|| 0x80040e2f == pChangeItem->hr) // DB_E_INTEGRITY_VIOLATION
						{
							// Ignore these errors
							break;
						}

						if(FAILED( pChangeItem->hr )) 
						{
							ERR3(Switchboard, "[FdConnection::CompleteDequeue]: user[%I64x] list item: %u, had HR: 0x%08x", 
									pUser->UserId(), wi, pChangeItem->hr );
							break;
						}

						if( pChangeItem->dwListVersion <= pUser->BuddyListVer())
						{
							TRACE3(Switchboard, L_NORMAL, "[FdConnection::CompleteDequeue]: user[%I64x] stale list change %u <= %u", 
									pUser->UserId(), pChangeItem->dwListVersion, pUser->BuddyListVer());
							break;
						}

						pBuddy = gpUserMgr->UserPtrFromId(pChangeItem->qwTargetID); 
						if(0 == pBuddy)
						{
							ERR3(Switchboard, "[Fdconnection::CompleteDequeue]: user[%I64x] friend out of users range: %I64x (%I64)",
									pUser->UserId(),
									pChangeItem->qwTargetID,
									pChangeItem->qwTargetID - gpUserMgr->BaseUserId());
							break;
						}

						TRACE3(Switchboard, L_DEBUG, "[FdConnection::CompleteDequeue]: user[%I64x] dequeued buddy operation op(%u) for buddy[%I64x]",
								pUser->UserId(), 
								pChangeItem->wOperationID, 
								pBuddy->UserId());

						switch( pChangeItem->wOperationID )
						{
							case PLIST_BUDDY_NOP:
								break;
							case PLIST_BUDDY_ADD:
								pUser->AddBuddy(pBuddy, P_BUDDY_STATUS_PENDING);
								break;
							case PLIST_BUDDY_ADDED:
								pUser->AddBuddy(pBuddy, P_BUDDY_STATUS_REQUEST);
								break;

							case PLIST_BUDDY_ACCEPT:
								pUser->AddBuddy(pBuddy, P_BUDDY_STATUS_OK);
								hr = pUser->CleanupBuddyData(pBuddy);
								if(FAILED(hr))
								{
									ERR2(Switchboard, "[FdConnection::CompleteDequeue]: XPQUser::CleanupBuddyData() failed for user: %I64x, HR: 0x%08x",
											pUser->UserId(),
											hr);
								}
	        
								break;

							case PLIST_BUDDY_REJECT:
							case PLIST_BUDDY_DELETE:
								{
									pUser->RemoveBuddy(pBuddy);   
									break;
								}
							default:
								ERR3(Switchboard, "[FdConnection::CompleteDequeue]: invalid operation ID: %u for user[%I64x] from buddy[%I64x]",
										pChangeItem->wOperationID,
										pUser->UserId(),
										pBuddy->UserId());

								_ASSERTE( false );
						}

						pUser->SetBuddyListVersion(pChangeItem->dwListVersion);
					}
					break;
				case PQUEUE_PRESENCE:
					{
						P_PRESENCE_ITEM* pPresenceItem = (P_PRESENCE_ITEM*)pData;

						// TBD!!! Deal with these later
						// ULONGLONG qwBuddyID;
						// DWORD dwTitleID;
						// DWORD dwState;
						// ULONGLONG qwMatchSessionID;
						// WORD  cbNickname;
						// WORD  cbTitleStuff;
						// // byte rgbNickName[];              // Binary
						// // byte rgbTitleStuff[];            // Binary

						pData += 
							sizeof(P_PRESENCE_ITEM) + 
							pPresenceItem->cbNickname +
							pPresenceItem->cbTitleStuff;

						break;
					}
				case PQUEUE_INVITE:
					{
						P_INVITATION_ITEM* pInviteItem = (P_INVITATION_ITEM*)pData;

						XPQUser *pHostUser  = gpUserMgr->UserPtrFromId(pInviteItem->qwHostID);
						pUser->AddReceivedInvite(pHostUser, pInviteItem->dwTitleID, pInviteItem->qwMatchSessionID);
	                    
						pData += sizeof(P_INVITATION_ITEM);

						break;
					}
				case PQUEUE_INVITE_ANSWER:
					{
						P_INVITATION_ANSWER_ITEM* pAnswerItem = (P_INVITATION_ANSWER_ITEM*)pData;
	#if 0
						XPQUser *pInvitee    = gpUserMgr->UserPtrFromId(pAnswerItem->qwInviteeID);
						DWORD dwInviteeIndex = pInvitee->UserIndex();

						_ASSERTE(pInvitee->HasReceivedInvite(pUser));
						_ASSERTE(LODWORD(pAnswerItem->qwMatchSessionID) == pInvitee->UserIndex());
						_ASSERTE(HIDWORD(pAnswerItem->qwMatchSessionID) == pInvitee->TitleId());
	                    
						switch( pAnswerItem->wAnswer )
						{
							case PINVITE_REPLY_NO:
								break;
							case PINVITE_REPLY_YES:
								break;
							default:
								_ASSERTE( false );
						}
	#endif

						pData += sizeof(P_INVITATION_ANSWER_ITEM);

						break;
					}
				case PQUEUE_PEER_PRESENCE:
					{
						P_PEER_PRESENCE_ITEM* pPresenceItem = (P_PEER_PRESENCE_ITEM*)pData;

						// TBD!!! Deal with these later
						// ULONGLONG qwBuddyID;
						// DWORD dwTitleID;
						// DWORD dwState;
						// ULONGLONG qwMatchSessionID;
						// WORD  cbTitleStuff;
						// // byte rgbTitleStuff[];            // Binary

						pData += 
							sizeof(P_PEER_PRESENCE_ITEM) + 
							pPresenceItem->cbTitleStuff;

						break;
					} 
				case PQUEUE_PRESENCE_2:
					{
						P_PRESENCE_2_ITEM* pPresenceItem = (P_PRESENCE_2_ITEM*)pData;

						// TBD!!! Deal with these later
						// ULONGLONG qwBuddyID;
						// DWORD dwTitleID;
						// DWORD dwState;
						// ULONGLONG qwMatchSessionID;
						// WORD  cbNickname;
						// WORD  cbTitleStuff;
						// // byte rgbNickName[];              // Binary
						// // byte rgbTitleStuff[];            // Binary

						pData += 
							sizeof(P_PRESENCE_2_ITEM) + 
							pPresenceItem->cbRichPresence +
							pPresenceItem->cbData;

						break;
					}
				default:
					_ASSERTE( false );
			}
		}
    }
    else
    {
        // Context not found
        // Not an event because a timeout could trigger this
        TRACE1(
            Switchboard,
            L_NORMAL,
            "CSwitchboard::ProcessMsgListReply - Not expecting List reply for context %d.",
            pMsg->dwSeqNum);
    }


    hr = S_OK;

lbDone:

	if(pCCtx != NULL)
		pCCtx->Complete();
	SAFE_RELEASE(pCCtx);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\StdAfx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once

// Common Headers
// --------------

#include <winsock2.h>
#include "wmsstd.h"
#include "wsockntp.h"
#include <atlsafe.h>
#include <atlbase.h>
#include <atlcom.h>
#include "xalloc.h"
#include "xmgmt.h"
#include <stdio.h>
#include <crtdbg.h>
#include <process.h>
#include <time.h>
#include <addref.h>
#include <math.h>

#include <list>
#include <map>
#include <vector>
#include <set>

// dstruct headers
#include <tptrarr.h>
#include <vptrarr.h>
#include <vptrlist.h>

// ntsvc headers
#include "tcpcnt.h"
#include "compport.h"

#include "xonlinep.h"

// core lib files (only include what is needed)
#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblConfig;

#include "Memory.h"
#include "Management.h"
#include "Win32Event.h"
#include "Utility.h"
#include "NetworkEndpoint.h"
#include "AsyncSocket.h"
#include "CompletionPort.h"
#include "THashTable.h"
#include "ScopeTimer.h"
#include "Counter.h"
#include "SafeCounter.h"
#include "TLockFreeFifo.h"
#include "TBuffer.h"

// local includes
#include <commonconfig.h>
#include "xeventids.h"
#include "ntservice.h"
#include "servsock.h"
#include "ConfigListener.h"
#include "presconfig.h"
#include "QVal.h"
#include "Command.h"
#include "Task.h"
#include "BasePresenceConnection.h"
#include "FdConn.h"
#include "INHConnection.h"
#include "ConnectionMgr.h"
#include "TaskThread.h"
#include "TaskPacing.h"
#include "Scheduler.h"
#include "Worker.h"
#include "TaskMgr.h"
#include "UserMgr.h"
#include "XPQStress.h"
#include "DumpMsg.h"
#include "MsgBuilder.h"
#include "DetailsBuilder.h"
#include "User.h"
#include "pconn.h"
#include "switchboard.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\Scheduler.cpp ===
#include "stdafx.h"

#define SCHEDULER_DEBUG 1

MGMT_ImportConfigSetting( TaskMgr, MaxInProgress);
MGMT_ImportConfigSetting( TaskMgr, SchedulerTimeSlice);
MGMT_ImportConfigSetting( TaskMgr, SchedulerLoadScale);
MGMT_ImportConfigSetting( TaskMgr, FailedTaskTimeout);

MGMT_ImportLoggingCategory( TaskMgr );
MGMT_ImportLoggingCategory( TaskTrace );
MGMT_DefineLoggingCategory( Scheduler );

Counter Cycles("Cycles");
Counter Scheduled("Scheduled");
Counter Cleaned("Cleaned");
Counter Starved("Starved");
Counter Errors("Errors");
Counter Timeouts("Timeouts");
Counter InProgress("InProgress");

ScopeTimer __SchedulerLoop("Scheduler");
ScopeTimer __ProcessQVals("ProcessQVals");
ScopeTimer __Cleanup("Cleanup");
ScopeTimer __DistributeTasks("DistributeTasks");

RunningAverageCounter __SchedulerLoopAvg("SchedulerLoopAvg");
RunningAverageCounter __ProcessQValsAvg("ProcessQValsAvg");
RunningAverageCounter __CleanupAvg("CleanupAvg");
RunningAverageCounter __DistributeTasksAvg("DistributeTasksAvg");
RunningAverageCounter __GlobalRTT("GlobalRTT");


DWORD   dwNextTaskId  = 0;

// Schedule timers
float  fElapsed = 0.0;
float  fTotalElapsed = 0.0;

//------------------------------------------------------------------------------
// 
// SchedulerTaskThread implementation
// 
//------------------------------------------------------------------------------

SchedulerTaskThread::SchedulerTaskThread() :
    m_pCP(0),
    m_fLoadScale(1),
	m_pFrontFailedTask(0),
	m_dwFailedTaskTimeout(0)
{
    m_CleanupQueue.Create(16384);
    m_FailedQueue.Create(16384);
	m_FreeConnList.Initialize(1024, 0);
}

SchedulerTaskThread::~SchedulerTaskThread()
{
    SAFE_RELEASE(m_pCP);
}

HRESULT SchedulerTaskThread::SetCompletionPort(CompletionPort *pCP)
{
    if(0 == pCP)
    {
        return E_INVALIDARG;
    }

    SAFE_REPLACEREF(m_pCP, pCP);

    return S_OK;
}

HRESULT SchedulerTaskThread::PostCompletedTask(XPQTask *pTask)
{
    _ASSERTE(0 != pTask);

    if(0 != pTask && !m_CleanupQueue.Enqueue(pTask))
    {
        return E_FAIL;
    }
    
    return S_OK;
}

HRESULT SchedulerTaskThread::PostFailedTask(XPQTask *pTask)
{
    _ASSERTE(0 != pTask);

    if(0 != pTask && !m_FailedQueue.Enqueue(pTask))
    {
        return E_FAIL;
    }

    return S_OK;
}

void SchedulerTaskThread::MarkResources(XPQUserMgr *pUserMgr, TaskResourceMark &Mark)
{
    Mark.dwNumOnline= pUserMgr->Online();
    Mark.dwNumOffline = pUserMgr->Offline();
}

static void __stdcall __Compare(const char *pszName, XPQTask *pTask, DWORD v1, DWORD v2)
{
    if(v1 != v2)
    {
        ERR4(Scheduler, "[%-20s] Resource validation error: %s: (%u != %u) != 0", 
            pTask ? pTask->Name() : "<NullTask>",
            pszName, 
            v1, 
            v2);
    }
}

// 
// Here we want to validate that the number of resources that are reported
// as released from an internal task should match the total delta resources
// before and after the task does the release.
//
// We also validate that the sum of reported aquired resources matches
// the sum of released resources.
//
void SchedulerTaskThread::ValidateResourceRelease(
        XPQTask *pTask,
        TaskResourceMark &MarkA, 
        TaskResourceMark &MarkB,
        TaskResourceMark &Aquired,
        TaskResourceMark &Released)
{
    DWORD dwSumMarkA = MarkA.dwNumOnline + MarkA.dwNumOffline;
    DWORD dwSumMarkB = MarkB.dwNumOnline + MarkB.dwNumOffline;
    DWORD dwSumAquired = Aquired.dwNumOnline + Aquired.dwNumOffline;
    DWORD dwSumReleased = Released.dwNumOnline + Released.dwNumOffline;

    __Compare("MarkB-MarkA == Released (NumOnline+NumOffline)", pTask, dwSumMarkB - dwSumMarkA, dwSumReleased);
    __Compare("Aquired == Released (NumOnline+NumOffline)", pTask, dwSumAquired, dwSumReleased);
}

void SchedulerTaskThread::ValidateResourceAquire(
        XPQTask *pTask,
        TaskResourceMark &MarkA, 
        TaskResourceMark &MarkB,
        TaskResourceMark &Aquired)
{
    DWORD dwSumMarkA = MarkA.dwNumOnline + MarkA.dwNumOffline;
    DWORD dwSumMarkB = MarkB.dwNumOnline + MarkB.dwNumOffline;
    DWORD dwSumAquired = Aquired.dwNumOnline + Aquired.dwNumOffline;

    _ASSERTE(dwSumMarkB > 0);
    __Compare("MarkA-MarkB == Aquired (NumOnline+NumOffline)", pTask, dwSumMarkA - dwSumMarkB, dwSumAquired);
}

void SchedulerTaskThread::LogStats() const 
{
    TRACE4(TaskMgr, L_OOB, "Scheduler: InProgress (now/max): (%g/%g), Avg/Max RTT(ms): %5.2f/%5.2f",
            InProgress.fInstance,
            InProgress.fMax,
            __GlobalRTT.fAverage,
            __GlobalRTT.fMax);
    TRACE6(TaskMgr, L_OOB, "Scheduler: Scheduled: %9.0f, Timeouts: %9.0f, Errors: %9.0f, Starved: %9.0f, FailedQueue: %9.0f, Cleaned: %9.0f",
            Scheduled.fTotal,
            Timeouts.fTotal,
            Errors.fTotal,
            Starved.fTotal,
            m_FailedQueue.Count(),
			Cleaned.fTotal);
    TRACE6(TaskMgr, L_OOB, "Scheduler: Cycles: %4.2f/s, Scheduled: %4.2f/s, Timeouts: %4.2f/s Errors: %4.2f/s, Starved: %4.2f/s, Cleaned: %4.2f/s",
            Cycles.fRate,
            Scheduled.fRate,
            Timeouts.fRate,
            Errors.fRate,
            Starved.fRate,
            Cleaned.fRate);
    TRACE4(TaskMgr, L_OOB, "Scheduler: Total: %2.8f, ProcessQvals: %2.8f, Cleanup: %2.8f, DistributeTasks: %2.8f",
            __SchedulerLoopAvg.fAverage,
            __ProcessQValsAvg.fAverage,
            __CleanupAvg.fAverage,
            __DistributeTasksAvg.fAverage);
}

void SchedulerTaskThread::RunInternal()
{
    HRESULT     hr;
    DWORD       dwTasksLeft;
    float       fTimeSlice;

    Cycles.Clear();
    Scheduled.Clear();
    Cleaned.Clear();
    Starved.Clear();
    Errors.Clear();
	Timeouts.Clear();
    InProgress.Clear();

    hr = E_FAIL;

    // Get local references to managers 
    XPQStress  *pStress  = XPQStress::GetPtr();

    // Validate required startup data
    _ASSERTE(NULL != pStress);
    _ASSERTE(INVALID_HANDLE_VALUE != m_hStopEvent);

    // Get task scheduling list and validate
    const CVPtrArray &TaskList = gpTaskMgr->GetTaskSchedule();
    if(0 == TaskList.GetSize())
    {
        ERR0(TaskMgr, "[SchedulerTaskThread::RunInternal]: task schedule list size was 0, nothing to schedule");
        goto lbShutdown;
    }

    // Get load scale factor from config
    m_fLoadScale          = MGMT_GetConfigSetting(TaskMgr, SchedulerLoadScale).GetFloat();
    m_dwMaxInProgress     = MGMT_GetConfigSetting(TaskMgr, MaxInProgress).GetDWORD();
    fTimeSlice            = MGMT_GetConfigSetting(TaskMgr, SchedulerTimeSlice).GetFloat();
	m_dwFailedTaskTimeout = MGMT_GetConfigSetting(TaskMgr, FailedTaskTimeout).GetDWORD();

    DWORD *prgdwLeftToSchedule  = new DWORD[TaskList.GetSize()];

    if(0 == m_dwMaxInProgress)
    {
        ERR1(Scheduler, "[SchedulerTaskThread::RunInternal]: invalid settings for max in progress: %u",
                m_dwMaxInProgress);
        goto lbShutdown;
    }

    TRACE2(Scheduler, L_HIGH, "[SchedulerTaskThread::RunInternal]: MaxInProgress: %u, TimeSlice: %g",
            m_dwMaxInProgress,
            fTimeSlice);

    // Continue until signaled
    while( true )
    {
        __SchedulerLoop.Enter();

#if 0
        if(WAIT_TIMEOUT != WaitForSingleObject( m_hStopEvent, 0))
        {
            TRACE0(Scheduler, L_HIGH, "[SchedulerTaskThread::RunInternal]: Shutdown event has been set.. leaving loop");
            break;
        }
#endif

        //
        // Cause all qvals to be processed and turned into bucket data
        //
        __ProcessQVals.Enter();
        ProcessPendingQVals();   
        __ProcessQVals.Leave();

        //
        // Cleanup any tasks posted
        //
        __Cleanup.Enter();
		ProcessFailedQueue();
		ProcessCleanupQueue(TaskList);
        __Cleanup.Leave();

		// Heartbeat our connections
		gpConnMgr->Heartbeat();

        // 
        // Check our max in progress limit
        //
        if(m_dwMaxInProgress == (DWORD)InProgress.fInstance)
        {
            ERR2(Scheduler, "[SchedulerTaskThread::RunInternal]: starvation (pre-task query, all workers too busy), online: %u, offline: %u",
                    gpUserMgr->Online(),
                    gpUserMgr->Offline());
            ++Starved;
            goto lbEndScheduleLoop;
        }
        
        __DistributeTasks.Enter();
        dwTasksLeft = GetLeftToSchedule(TaskList, prgdwLeftToSchedule);
		DistributeTasks(
                    TaskList, 
                    m_dwMaxInProgress - (DWORD)InProgress.fInstance, 
                    dwTasksLeft, 
                    prgdwLeftToSchedule);
        __DistributeTasks.Leave();

        //
        // Poll counters every 5 seconds
        //
        if(fTotalElapsed > 5.0)
        {
            Cycles.Poll(fTotalElapsed);
            Scheduled.Poll(fTotalElapsed);
            Cleaned.Poll(fTotalElapsed);
            Starved.Poll(fTotalElapsed);
            Errors.Poll(fTotalElapsed);
            Timeouts.Poll(fTotalElapsed);

            // Reset our max RTT to keep it fresh
            __GlobalRTT.fMax = __GlobalRTT.fInstance;
        
            fTotalElapsed = 0.0;
        }

lbEndScheduleLoop:  

        while(fTimeSlice > 0 && fElapsed < 1.0 && true)
        {
            __SchedulerLoop.Capture(&fElapsed);
            if((fTimeSlice - fElapsed) < 0.0f)
            {
                break;
            }

            // Yield to workers
            Sleep(0);
        }

        ++Cycles;
        __SchedulerLoop.Leave();
        fElapsed = __SchedulerLoop.fCaptured;
        fTotalElapsed += fElapsed;

        // Record timers
        __SchedulerLoopAvg.SampleValue(__SchedulerLoop.fCaptured);
        __ProcessQValsAvg.SampleValue(__ProcessQVals.fCaptured);
        __CleanupAvg.SampleValue(__Cleanup.fCaptured);
        __DistributeTasksAvg.SampleValue(__DistributeTasks.fCaptured);
    }

lbShutdown:

    // If we got here from bad startup we should notify other
    // theads that we won't be doing any scheduling and the whole
    // app should shutdown
    pStress->AllStop();

    // Release thread allocated data
    SAFE_DELETE(m_pCP);
    SAFE_ARRAY_DELETE(prgdwLeftToSchedule);

    TRACE1( Scheduler, L_NORMAL, "[SchedulerTaskThread::RunInternal]: thread [%d] exiting", GetCurrentThreadId() );
}

DWORD SchedulerTaskThread::GetLeftToSchedule(const CVPtrArray &TaskList, DWORD *prgLeftToSchedule)
{
    XPQTaskPacing *pTaskPacing;
    DWORD dwLeftToSchedule;
    DWORD dwTotalLeftToSchedule = 0;

    for(DWORD i = 0, c = TaskList.GetSize(); i < c; ++i)
    {
        if(!TaskList.GetAt(i, (void**)&pTaskPacing))
        {
            ERR1(Scheduler, "[SchedulerTaskThread::GetLeftToSchedule]: query TaskList[%u] failed unexpected", i);
            break;
        }

        if(!pTaskPacing->Enabled())
        {
            continue;
        }

        // Find out how many tasks of this type are left to schedule from the last elapsed timeslice
        dwLeftToSchedule = pTaskPacing->LeftToSchedule(fElapsed, m_fLoadScale);
        prgLeftToSchedule[i] = dwLeftToSchedule;
        dwTotalLeftToSchedule += dwLeftToSchedule;
    }

    return dwTotalLeftToSchedule;
}

void SchedulerTaskThread::DistributeTasks(const CVPtrArray &TaskList, DWORD dwInProgressLeft, DWORD dwTasksLeft, DWORD *prgLeftToSchedule)
{
    HRESULT hr;
    DWORD dwScheduled;
    DWORD dwToSchedule;
    float fSchedulerRatio;
    XPQTaskPacing *pTaskPacing;

    for(DWORD i = 0, c = TaskList.GetSize(); i < c; ++i)
    {
        if(!TaskList.GetAt(i, (void**)&pTaskPacing))
        {
            ERR1(Scheduler, "[SchedulerTaskThread::DistributeTasks]: query TaskList[%u] failed unexpected", i);
            break;
        }

        if(!pTaskPacing->Enabled())
        {
            pTaskPacing->RecordScheduled(fElapsed, 0);
            continue;
        }

        dwToSchedule = prgLeftToSchedule[i];

        // If we don't have enough in progress left to schedule
        // all of our tasks than we are going to hande out portions
        // of the inprogress pool
        if(dwTasksLeft > dwInProgressLeft)
        {
            // Figure out the ratio of total scheduled tasks this task represents
            fSchedulerRatio = float(dwToSchedule) / float(dwTasksLeft);

            dwToSchedule = (DWORD)(fSchedulerRatio * dwInProgressLeft);
        }

        if(dwToSchedule > 0)
        {
            dwScheduled = ScheduleTasks(pTaskPacing, dwToSchedule);
        }
        else
        {
            dwScheduled = 0;
        }

        pTaskPacing->RecordScheduled(fElapsed, dwScheduled);
    }
}

DWORD SchedulerTaskThread::ScheduleTasks(XPQTaskPacing *pTaskPacing, DWORD dwToSchedule)
{
    HRESULT hr;
    XPQTask *pTask;
    DWORD dwScheduled = 0;
    XPQTaskAllocator *pAllocator;
    BasePresenceConnection *pConn;
    XPQTaskResourceBlock Resources;
    TaskResourceMark  MarkA;
    TaskResourceMark  MarkB;
    TaskResourceMark  Released;
    TaskResourceMark  Aquired;
    
    pAllocator = pTaskPacing->Task()->TaskAllocator();

    while(dwToSchedule--)
    {   
        pTask = 0;
        pConn = 0;
        Resources.Clear();
        Aquired.Clear();
        Released.Clear();
        MarkA.Clear();
        MarkB.Clear();

        // 
        // Aquire resources using this tasks resource allocation
        // strategy
        //
        MarkResources(gpUserMgr, MarkA);
        hr = pAllocator->Allocate(Resources, Aquired);
        if(FAILED(hr))
        {
            ERR2(TaskMgr, "[XPQTask::AquireResources]: failed to aquire resources from task type: %s, HR: 0x%08x", pTaskPacing->Task()->Name(), hr);
            if(pTaskPacing->Task()->Tracing())
            {
                ERR2(TaskTrace, "Error trying to aquire resources for task: %s, HR: 0x%08x", pTaskPacing->Task()->Name(), hr);
            }
            goto lbDoneLoop;
        }
        else if(S_FALSE == hr)
        {
            pTaskPacing->RecordStarved();
            ++Starved;
            if(pTaskPacing->Task()->Tracing())
            {
                ERR2(TaskTrace, "Starved trying to aquire resources for task: %s, HR: 0x%08x", pTaskPacing->Task()->Name(), hr);
            }
            break;
        }
        MarkResources(gpUserMgr, MarkB);
        ValidateResourceAquire(pTaskPacing->Task(), MarkA, MarkB, Aquired); 
        
        //
        // We have a valid resource block now attempt to get
        // a task object.
        //
        pTask = gpTaskMgr->AquireTask();
        if(0 == pTask)
        {
            TRACE3(Scheduler, L_DEBUG, "[SchedulerTaskThread::ScheduleTasks]: starvation (no task objects available), online: %u, offline: %u, inuse: %u",
                    gpUserMgr->Online(),
                    gpUserMgr->Offline(),
                    gpUserMgr->Inuse());
            hr = E_FAIL;
            goto lbDoneLoop;
        }
        pTaskPacing->Task()->Clone(++dwNextTaskId, pTask);

        TRACE3(TaskMgr, L_NORMAL, "[SchedulerTaskThread::ScheduleTasks]: starting new task: %s, id: %u (inprogress: %g)",
                pTask->Name(),
                pTask->ID(),
                InProgress.fInstance);  

		if(FAILED(hr = AquireConnection(&pConn, pTaskPacing->Task()->SendToINH())))
		{
			ERR1(TaskMgr, "[SchedulerTaskThread::ScheduleTasks]: could not get a free connection: HR: 0x%08x", hr);
			goto lbDoneLoop;
		}

        hr = pTask->AttachResources(Resources, Aquired, pConn);
        if(FAILED(hr))
        {
            ERR1(TaskMgr, "[SchedulerTaskThread::ScheduleTasks]: pTask->AttachResources() failed, HR: 0x%08x", hr);
            goto lbDoneLoop;
        }

		pTask->SetTracing(pTaskPacing->Tracing());
        pTask->RecordStart();

        _ASSERTE((Aquired.dwNumOnline + Aquired.dwNumOffline) > 0);
        hr = m_pCP->PostCompletion(pTask, 0, 0);
        if(FAILED(hr))
        {
            ERR1(TaskMgr, "[SchedulerTaskThread::ScheduleTasks]: CompletionPort::PostCompletion() failed, HR: 0x%08x", hr);
            goto lbDoneLoop;
        }

        ++dwScheduled;
        ++InProgress;
        ++Scheduled;
        
lbDoneLoop:
        if(FAILED(hr))
        {
            if(pConn)
            {
                ReleaseConnection(pConn);
            }

			if(pTask)
            {
                pTask->Clear();
                gpTaskMgr->ReleaseTask(pTask);
            }

            // Release the resource block
            if((Aquired.dwNumOffline + Aquired.dwNumOnline) > 0)
            {
                MarkA.Clear();
                MarkB.Clear();
                MarkResources(gpUserMgr, MarkA);
                Resources.Release(Released);
                MarkResources(gpUserMgr, MarkB);
                ValidateResourceRelease(NULL, MarkA, MarkB, Aquired, Released);
            }

            // This task template will probably have trouble scheduling any more
            break;
        }
    }

    return dwScheduled;
}

void SchedulerTaskThread::ProcessCleanupQueue(const CVPtrArray &TaskList)
{
    HRESULT lastHR;
    BasePresenceConnection *pConn;
    XPQUser *pUser = 0;
    XPQTask *pTask = 0;
    XPQTaskPacing *pTaskPacing = 0;
    TaskResourceMark  MarkA;
    TaskResourceMark  MarkB;
    TaskResourceMark  Released;
    TaskResourceMark  Aquired;

    //
    // Do we have any finished tasks to clean up?
    //
    while(m_CleanupQueue.Dequeue(pTask))
    {
        _ASSERTE(0 != pTask);

        TRACE2(Scheduler, L_NORMAL, "[SchedulerTaskThread::ProcessCleanupQueue]: Cleaning up task: %s [%u]", 
                pTask->Name(), 
                pTask->ID());

        lastHR = pTask->LastHR();
		if(pTask->GetResourceBlock().Count() != 0)
		{
			pUser = pTask->GetResourceBlock().GetOnlineOrOfflineUser(0);

			// Clasify and mark errors
			switch(lastHR)
			{
			case __HRESULT_FROM_WIN32(WSAETIMEDOUT):
				USERTRACE3(pUser->UserId(), "Task timeout %s, Millis: %u, HR: 0x%08x", 
						pTask->Name(), 
						pTask->TotalTicks(), 
						lastHR);
				++Timeouts;
				break;
			// Non kickable errors
			case XONLINE_E_LOGON_SERVERS_TOO_BUSY:
			case XONLINE_E_NOTIFICATION_SERVER_BUSY:
				++Errors;
				break;
			default: 
				if(FAILED(lastHR))
				{
					// for all other server related errors, kick the user
					if((FACILITY_XONLINE<<16 == (0x7fff0000 & lastHR)) || HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER) == lastHR)
					{
						++Errors;

						if(gpUserMgr->KickOnError())
						{
							XPQUser *pUser = pTask->GetResourceBlock().GetOnlineOrOfflineUser(0);
							if(0 != pUser)
							{
								TRACE2(TaskMgr, L_HIGH, "[SchedulerTaskThread::ProcessCleanupQueue]: kicking user: %I64x for HR: 0x%08x",
										pUser->UserId(),
										lastHR);
								pUser->LogoffCleanup();
							}
						}
					}
				}

				USERTRACE4(pUser->UserId(), "Task complete %s, Millis: %u, HR: 0x%08x (Kicked?: %s)", 
							pTask->Name(), 
							pTask->TotalTicks(), 
							lastHR,
							(FACILITY_XONLINE<<16 == (0x7fff0000 & lastHR)) ? "yes" : "no");
			}
		}        
        MarkA.Clear();
        MarkB.Clear();
        Aquired.Clear();
        Released.Clear();

        // Mark current resources
        MarkResources(gpUserMgr, MarkA);

        // Get actual aquired resources
        pTask->GetAquiredResources(Aquired);

        // Release the internal resources
        pTask->DetachResources(Released, &pConn);

        _ASSERTE(pConn != NULL);
		ReleaseConnection(pConn);

        // Mark new resources
        MarkResources(gpUserMgr, MarkB);

        // Validate that the task released all of the resources it requested and that it
        // matches up with the actual resource queue changes
        ValidateResourceRelease(pTask, MarkA, MarkB, Aquired, Released);

        // Measure RTT
        if(TaskList.GetAt(pTask->TypeID(), (void**)&pTaskPacing))
        {
            pTask->RecordFinish();
            pTaskPacing->RecordCompleted((float)pTask->TotalTicks(), pTask->LastHR());
        }

        // Measure total RTT
        __GlobalRTT.SampleValue((float)pTask->TotalTicks());

        gpTaskMgr->ReleaseTask(pTask);

        ++Cleaned;
        --InProgress;
    }
}

void SchedulerTaskThread::ProcessFailedQueue()
{
	DWORD dwNow = GetTickCount();
	while(true)
	{
		if(m_pFrontFailedTask == NULL && !m_FailedQueue.Dequeue(m_pFrontFailedTask))
		{
			m_pFrontFailedTask = NULL;
			return;
		}

		// kill as many timeouts as we find in a row
		if(m_pFrontFailedTask->StartTicks() + m_dwFailedTaskTimeout < dwNow)
		{
			HRESULT hr = PostCompletedTask(m_pFrontFailedTask);
			if(FAILED(hr))
			{
				PostFailedTask(m_pFrontFailedTask);
				m_pFrontFailedTask = NULL;
				return;
			}
			m_pFrontFailedTask = NULL;
		}
		else
		{
			return;
		}
	}
}

void SchedulerTaskThread::ProcessPendingQVals()
{
    XPQUser *pUser;
    LONG lProcess;
    DWORD dwUserIndex;
    SGQVal qval;


    // Process the qval packet queue
    LockFreeFifo<SGQVal> &queue = gpConnMgr->GetQValPacketQueue();
    lProcess = queue.Count();

    while(lProcess-- > 0)
    {
        if(!queue.Dequeue(qval))
        {
            ERR1(TaskMgr, "[SchedulerTaskThread::ProcessPendingQVals]: qval packet queue should still have %d items left", 
                    lProcess);
            break;
        }

        pUser = gpUserMgr->UserPtrFromId(qval.m_qwUserId);
        if(0 == pUser)
        {
            ERR1(TaskMgr, "[SchedulerTaskThread::ProcessPendingQVals]: unrecognized user ID in qval: %I64x", 
                    qval.m_qwUserId);
            continue;
        }

        // Make the user requeue
        if(pUser->IsLocked())
        {
            // Defer notifications for this user until they are finished
            // with their current task
            pUser->DeferQVal(qval);
            continue;
        }

		if(pUser->HasPoolFlag(USERPOOL_INFO_FLAGS_ONLINE))
		{
			pUser->ProcessQVal(qval);
		}
    }
}

HRESULT SchedulerTaskThread::AquireConnection(BasePresenceConnection **ppOutConnection, bool SendToINH)
{
    HRESULT hr;

	BasePresenceConnection *pConn = 0;

    if(0 == ppOutConnection)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

	if(SendToINH)
	{
		INHConnection* inhConn = gpConnMgr->GetINHConnection();
		inhConn->Attach(m_pCP);
		pConn = inhConn;
	}
	else
	{
		*ppOutConnection = 0;
		if(!m_FreeConnList.RemoveHead((void**)&pConn))
		{
			FdConnection *fdConn = new FdConnection();
			if(0 == fdConn)
			{
				hr = E_OUTOFMEMORY;
				goto lbDone;
			}

			hr = fdConn->Create(m_pCP, gpConnMgr->FDIP());
			if(FAILED(hr))
			{
				ERR1(TaskMgr, "[WorkerTaskThread::AquireConnection]: failed to create a new connection object, HR: 0x%08x", hr);
				SAFE_DELETE(pConn);
				goto lbDone;
			}
			pConn = fdConn;
		}
	}

    _ASSERTE(pConn);
    *ppOutConnection = pConn;
    hr = S_OK;

lbDone:
    return hr;
}

void SchedulerTaskThread::ReleaseConnection(BasePresenceConnection *pConn)
{
	if(pConn->Type() == FDCONNECTION)
	{
		FdConnection *fdConn = (FdConnection*)pConn;
		fdConn->CleanReset();

		// We don't want to keep too many free connections around
		if(m_FreeConnList.GetCount() > m_dwMaxInProgress)
		{
			SAFE_DELETE(pConn);
		}
		else
		{
			// AddTail failed, release the connection object
			if(!m_FreeConnList.AddTail((void*)pConn))
			{
				SAFE_DELETE(pConn);
			}
		}
	}
}

void SchedulerTaskThread::SetLoadScale(float fLoadScale)
{
    m_fLoadScale = fLoadScale;
}

float SchedulerTaskThread::LoadScale() const
{
    return m_fLoadScale;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\task.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2002 Microsoft.  ALL RIGHTS RESERVED
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "ConnectionMgr.h"

// Forward Declarations
class XPQUser;
class XPQUserMgr;

//------------------------------------------------------------------------------
// Structure for marking the ammount and type
// of resources aquired to perform a specific
// task. This is used to validate resource release
// and provide feedback in the event of resource
// starvation.
//------------------------------------------------------------------------------
struct TaskResourceMark
{
    DWORD dwNumOnline;          // Number of online users required
    DWORD dwNumOffline;         // Number of offline users required

    inline void Clear()
    {
        dwNumOnline = 0;
        dwNumOffline = 0;
    }
};

//------------------------------------------------------------------------------
// Storage for task execution unit that will hold onto a set of users
// for the duration of time that a task is active.
//------------------------------------------------------------------------------
#define TASK_RESOURCE_BLOCK_MAX 128
class XPQTaskResourceBlock
{
protected:

    // Normal users pulled from writable lists
    XPQUser*       m_rgpUsers[TASK_RESOURCE_BLOCK_MAX];
    DWORD          m_dwcUsers;  

    // Read only users that are associated with the 
    // request
    const XPQUser* m_rgpROUsers[TASK_RESOURCE_BLOCK_MAX];
    DWORD          m_dwcROUsers;    
public:
    XPQTaskResourceBlock();
    ~XPQTaskResourceBlock();
    
    const XPQUser **Users()   const { return (const XPQUser**)&m_rgpUsers[0]; }
    const XPQUser **ROUsers() const { return (const XPQUser**)&m_rgpROUsers[0]; }
    DWORD Count()             const { return m_dwcUsers; }
    DWORD ROCount()           const { return m_dwcROUsers; }

    // Add an online or offline writable user
    void AddOnlineUser(XPQUser *pUser);
    void AddOfflineUser(XPQUser *pUser);

    // Get an online or offline writable user
    XPQUser *GetOnlineUser(DWORD dwIndex) const;
    XPQUser *GetOfflineUser(DWORD dwIndex) const;
    XPQUser *GetOnlineOrOfflineUser(DWORD dwIndex) const;

    // Add a read-only user
    void AddUser(const XPQUser *pUser);

    // Get a read-only user
    const XPQUser *GetUser(DWORD dwIndex);

    // Release all writable users
    void Release(TaskResourceMark &Released);

    void Clear();
};

//------------------------------------------------------------------------------
// Allocation schemes differ for the type of task. This class wraps up knoledge
// about allocation schemes and exposes it to the rest of the system in a 
// consistent way.
//------------------------------------------------------------------------------

enum AllocatorPool
{
    kAllocatorPool_None,
    kAllocatorPool_Offline,
    kAllocatorPool_OfflineForAlive,
    kAllocatorPool_Online,
    kAllocatorPool_Random,

    kAllocatorPool_Max

};

struct XPQAllocationCommand
{
    AllocatorPool    ePool;
    DWORD            dwPoolFlags;
    DWORD            dwMinCount;
    DWORD            dwMaxCount;
};

// You can only have one command per pool really
#define ALLOCATOR_MAX_COMMANDS 3

class XPQTaskAllocator
{
protected:
    XPQAllocationCommand m_rgCommands[ALLOCATOR_MAX_COMMANDS];
    DWORD                m_dwcCommands;
    
    XPQTaskAllocator();

    HRESULT AddAllocCommand(AllocatorPool ePool, DWORD dwPoolFlags, DWORD dwMinCount, DWORD dwMaxCount);
    DWORD CountCommands() const { return m_dwcCommands; }

public:
    ~XPQTaskAllocator();

    IMPLEMENT_REFCOUNT;


    //------------------------------------------------------------------------------
    // Get an allocator specified by the pszTypeName parameter. If the name is 
    // incorrect NULL is returned. This does not allocate a new allocator.
    //------------------------------------------------------------------------------
    static HRESULT GetAllocator(
                const char *pszAllocatorSpec,
                XPQTaskAllocator **ppOutAllocator);

    //------------------------------------------------------------------------------
    // Allocate users using the strategy of this allocator
    //------------------------------------------------------------------------------
    HRESULT Allocate(
                XPQTaskResourceBlock &rResourceBlock, 
                TaskResourceMark &Aquired);
};

//------------------------------------------------------------------------------
// Sentinal task state, other task states index into the specific command
// that is currently active.
//------------------------------------------------------------------------------
#define TASK_STATE_STARTING  0
#define TASK_STATE_FINISHED  -1

class WorkerTaskThread;
class BasePresenceConnection;

//------------------------------------------------------------------------------
// Task unit
//
//  Main unit of execution controls resource usage and tracks IO across multiple
//  requests for a given set of users allocated from the XPQTaskAllocator.
//
//  All of the actions taken by a task are executed by Command objects.
//------------------------------------------------------------------------------
class XPQTask : public SOCKET_OVERLAPPED
{
protected:
    friend class XPQTaskMgr;

    XPQTask*              m_pNext;
    XPQTask*              m_pPrev;
    DWORD                 m_dwID;
    DWORD                 m_dwTypeID;
    const char*           m_pszName;
    TaskResourceMark      m_Aquired;
    XPQTaskResourceBlock  m_Resources;
    XPQTaskAllocator*     m_pAllocator;
    float                 m_fTPS;
    DWORD                 m_dwStartTicks;
    DWORD                 m_dwTotalTicks;
    DWORD                 m_dwEndTicks;
    DWORD                 m_dwLastCommandTicks;
    DWORD                 m_dwTimeout;
    Command*              m_pCommand;
    BasePresenceConnection* m_pConn;
    bool                  m_bIsCopy;
    bool                  m_bTracing;
    HRESULT               m_hr;
	bool				  m_bSendToINH;
public:
    XPQTask();
    XPQTask(DWORD dwID);
    ~XPQTask();

    //------------------------------------------------------------------------------
    // Create a new task template and load it's data from the configuration pszName.
    //------------------------------------------------------------------------------
    static XPQTask* CreateAndLoad(const char *pszName);


    //------------------------------------------------------------------------------
    // Clone a task template to create a new unattached task object that is 
    // ready to run.
    //------------------------------------------------------------------------------
    void Clone(DWORD dwNewID, XPQTask *pNewTask);

    //------------------------------------------------------------------------------
    // Called by CreateAndLoad to initalize internal task members.
    //------------------------------------------------------------------------------
    HRESULT   Create();


    //------------------------------------------------------------------------------
    // Property accessors
    //------------------------------------------------------------------------------
    DWORD       ID()               const { return m_dwID; }
    DWORD       TypeID()           const { return m_dwTypeID; }
    const char *Name()             const { return m_pszName; }
    float       TPS()              const { return m_fTPS; }
    DWORD       StartTicks()       const { return m_dwStartTicks; } 
    DWORD       EndTicks()         const { return m_dwEndTicks; } 
    DWORD       TotalTicks()       const { return m_dwTotalTicks; }
    DWORD       LastCommandTicks() const { return m_dwLastCommandTicks; }
    DWORD       Timeout()          const { return m_dwTimeout; } 
    HRESULT     LastHR()           const { return m_hr; } 
    bool        Tracing()          const { return m_bTracing; }
	bool		SendToINH()		   const { return m_bSendToINH; }
    

    void        SetTypeID(DWORD dwTypeId);
    void        SetTPS(float fTPS);
    void        SetAllocator(XPQTaskAllocator *pAllocator);
    void        SetName(const char *pszName);
    void        SetTracing(bool bTracing);
	void		SetSendToINH(bool bSendToINH);
    void        SetTimeout(DWORD dwTimeout);

    void        SetCommand(Command *pCommand);
    XPQTaskAllocator *TaskAllocator() const { return m_pAllocator; }

    //------------------------------------------------------------------------------
    // Clear persistent members
    //------------------------------------------------------------------------------
    void Clear();

    //------------------------------------------------------------------------------
    // Reset timers and record start time
    //------------------------------------------------------------------------------
    void RecordStart();

    //------------------------------------------------------------------------------
    // Mark finish time and calculate total time in ticks that task was active
    //------------------------------------------------------------------------------
    void RecordFinish();


    //------------------------------------------------------------------------------
    // Re-Entry point for the task
    //------------------------------------------------------------------------------
    HRESULT Run();

    //------------------------------------------------------------------------------
    // IO handler for the task, delegates to connection 
    //------------------------------------------------------------------------------
    HRESULT HandleIo(DWORD dwTransferred, bool *pbCompletionDelivered);

    //------------------------------------------------------------------------------
    // Attach the resources required to this thread.
    //------------------------------------------------------------------------------
    HRESULT AttachResources(
                    XPQTaskResourceBlock &Resources, 
                    TaskResourceMark &Aquired, 
                    BasePresenceConnection *pConn);

    //------------------------------------------------------------------------------
    // Release any internal resources
    //------------------------------------------------------------------------------
    void DetachResources(
                    TaskResourceMark &Released,
                    BasePresenceConnection **ppOutConnection);

    //------------------------------------------------------------------------------
    // Handle IO from the completion port, this is the case when the task was
    // posted to a socket operation.
    //------------------------------------------------------------------------------
    HRESULT HandleIo();

    //------------------------------------------------------------------------------
    // Note the completion of the task and store the appropriate hresult, it will
    // query and store the server hresult in the case of a server failure.
    //------------------------------------------------------------------------------
    HRESULT Completed(HRESULT hr);

    //------------------------------------------------------------------------------
    // Resource access
    //------------------------------------------------------------------------------
    XPQTaskResourceBlock &GetResourceBlock();

    //------------------------------------------------------------------------------
    // Get the connection object for this task, it will be used for every command
    //------------------------------------------------------------------------------
    BasePresenceConnection* GetConnection() const;
    bool HasConnection() const { return 0 != m_pConn; }

    //------------------------------------------------------------------------------
    // Read the internal resource mark that represents the local resources
    // aquired by this task.
    //------------------------------------------------------------------------------
    void GetAquiredResources(TaskResourceMark &Aquired) const;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\Task.cpp ===
#include "StdAfx.h"
#include "Task.h"

MGMT_ImportLoggingCategory(TaskMgr);
MGMT_ImportLoggingCategory(TaskTrace);

//------------------------------------------------------------------------------
// XPQTaskResourceBlock
//------------------------------------------------------------------------------
XPQTaskResourceBlock::XPQTaskResourceBlock()
{
    Clear();
}

XPQTaskResourceBlock::~XPQTaskResourceBlock()
{
}

void XPQTaskResourceBlock::Clear()
{
    ZeroMemory(m_rgpUsers, TASK_RESOURCE_BLOCK_MAX * sizeof(XPQUser*));
    ZeroMemory(m_rgpROUsers, TASK_RESOURCE_BLOCK_MAX * sizeof(XPQUser*));
    m_dwcUsers = 0;
    m_dwcROUsers = 0;
}

void XPQTaskResourceBlock::AddOfflineUser(XPQUser *pUser)
{
    _ASSERTE(pUser->HasPoolFlag(USERPOOL_INFO_FLAGS_OFFLINE));
    _ASSERTE(m_dwcUsers < TASK_RESOURCE_BLOCK_MAX);
    m_rgpUsers[m_dwcUsers++] = pUser;
}

void XPQTaskResourceBlock::AddOnlineUser(XPQUser *pUser)
{
    _ASSERTE(pUser->HasPoolFlag(USERPOOL_INFO_FLAGS_ONLINE));
    _ASSERTE(m_dwcUsers < TASK_RESOURCE_BLOCK_MAX);
    m_rgpUsers[m_dwcUsers++] = pUser;
}

XPQUser *XPQTaskResourceBlock::GetOnlineUser(DWORD dwIndex) const
{
    XPQUser *pUser = 0;

	if(m_dwcUsers > 0)
	{
		pUser = m_rgpUsers[dwIndex];
	}

    _ASSERTE(0 != pUser);
    _ASSERTE(pUser->HasPoolFlag(USERPOOL_INFO_FLAGS_ONLINE));

    return pUser;
}

XPQUser *XPQTaskResourceBlock::GetOnlineOrOfflineUser(DWORD dwIndex) const
{
    XPQUser *pUser = 0;

	if(m_dwcUsers > 0)
	{
		pUser = m_rgpUsers[dwIndex];
	}

    _ASSERTE(0 != pUser);

    return pUser;
}

XPQUser *XPQTaskResourceBlock::GetOfflineUser(DWORD dwIndex) const
{
    XPQUser *pUser = 0;

	if(m_dwcUsers > 0)
	{
		pUser = m_rgpUsers[dwIndex];
	}

    _ASSERTE(0 != pUser);
    _ASSERTE(pUser->HasPoolFlag(USERPOOL_INFO_FLAGS_OFFLINE));

    return pUser;
}

void XPQTaskResourceBlock::AddUser(const XPQUser *pUser)
{
    _ASSERTE(m_dwcROUsers < TASK_RESOURCE_BLOCK_MAX);
    m_rgpROUsers[m_dwcROUsers++] = pUser;
}

const XPQUser *XPQTaskResourceBlock::GetUser(DWORD dwIndex)
{
    const XPQUser *pUser = 0;

	if(m_dwcROUsers > 0)
	{
		pUser = m_rgpROUsers[dwIndex];
	}

    _ASSERTE(0 != pUser);

    return pUser;
}

void XPQTaskResourceBlock::Release(TaskResourceMark &Released)
{
    register DWORD dwi;
    register DWORD dwc;
    XPQUser *pUser;

    for(dwi = 0, dwc = m_dwcUsers; dwi < dwc; ++dwi)
    {
        pUser = m_rgpUsers[dwi];

        if(pUser->HasPoolFlag(USERPOOL_INFO_FLAGS_ONLINE))
        {
            gpUserMgr->ReleaseUser(pUser, USERPOOL_INFO_FLAGS_ONLINE);
            Released.dwNumOnline++;
        }
        else if(pUser->HasPoolFlag(USERPOOL_INFO_FLAGS_OFFLINE))
        {
            gpUserMgr->ReleaseUser(pUser, USERPOOL_INFO_FLAGS_OFFLINE);
            Released.dwNumOffline++;
        }
        else
        {
            _ASSERTE(false);
        }
    }

    m_dwcUsers = 0;
}

//------------------------------------------------------------------------------
// XPQTask implementation
//------------------------------------------------------------------------------

XPQTask *XPQTask::CreateAndLoad(const char *pszName)
{
    HRESULT hr = S_OK;

    float fTPS                   = 0;
    XPQTaskAllocator *pAllocator = 0;
    XPQTask *pTask               = 0;
    Command *pCommand            = 0;
    DWORD dwCountCommands        = 0;
    Setting *pSetting            = 0;

    Console &console = Console::GetInstance();
        
    if(!console.GetSetting(pszName, "TPS", &pSetting))
    {
        ERR1(TaskMgr, "No 'TPS' setting for task: %s", pszName);
        goto lbDone;
    }

    fTPS = pSetting->GetFloat();

    if(!console.GetSetting(pszName, "Allocator", &pSetting))
    {
        ERR1(TaskMgr, "[XPQTask::CreateAndLoad]: No 'Allocator' setting for task: %s", pszName);
        hr = E_INVALIDARG;
        goto lbDone;
    }

    if(FAILED(hr = XPQTaskAllocator::GetAllocator(pSetting->GetLPCSTR(), &pAllocator)))
    {
        ERR3(TaskMgr, "[XPQTask::CreateAndLoad]: No task allocator named: %s for task: %s, HR: 0x%08x", 
                pSetting->GetLPCSTR(), 
                pszName,
                hr);
        goto lbDone;
    }

    // Instantiate the task and load all of it's commands
    pTask = new XPQTask(0);
    hr = pTask->Create();
    if(FAILED(hr))
    {
        ERR1(TaskMgr, "[XPQTask::CreateAndLoad]: task template creation failed, HR: 0x%08x", hr);
        goto lbDone;
    }

    pTask->SetName(pszName);
    pTask->SetTPS(fTPS);
    pTask->SetAllocator(pAllocator);

    if(console.GetSetting(pszName, "Command", &pSetting))
    {
        Command *pCommand = Command::Create(pSetting->GetLPCSTR());
        if(0 == pCommand)
        {
            ERR2(TaskMgr, "[XPQTask::CreateAndLoad()]: Task: %s command name: '%s', could not create command",
                    pszName, pSetting->GetLPCSTR());
            SAFE_DELETE(pTask);
            hr = E_INVALIDARG;
            goto lbDone;
        }

        pTask->SetCommand(pCommand);
    }

    if(console.GetSetting(pszName, "Timeout", &pSetting))
    {
        DWORD dwTimeout = pSetting->GetDWORD();
        if(0 == dwTimeout)
        {
            ERR2(TaskMgr, "[XPQTask::CreateAndLoad()]: Task: %s invalid timeout: '%u', could not create task",
                    pszName, pSetting->GetLPCSTR());
            SAFE_DELETE(pTask);
            hr = E_INVALIDARG;
            goto lbDone;
        }
		pTask->SetTimeout(dwTimeout);
    }

    if(console.GetSetting(pszName, "SendToINH", &pSetting))
    {
        DWORD dwSendToINH = pSetting->GetDWORD();
		pTask->SetSendToINH(dwSendToINH != 0);
    }

lbDone:

    return pTask;
}

XPQTask::XPQTask(DWORD dwID) :
    m_pNext(0),
    m_dwID(dwID),
    m_dwTypeID(0),
    m_pszName(0),
    m_pAllocator(0),
    m_fTPS(0),
    m_dwStartTicks(0),
    m_dwTotalTicks(0),
    m_dwLastCommandTicks(0),
    m_dwEndTicks(0),
    m_dwTimeout(0),
    m_pCommand(0),
    m_pConn(0),
    m_bIsCopy(false),
    m_bTracing(false),
	m_bSendToINH(false),
    m_hr(0)
{
    // clear composited members
    XPQTask::Clear(); 
}

XPQTask::XPQTask() 
{
}

XPQTask::~XPQTask()
{
    if(!m_bIsCopy)
    {
        SAFE_DELETE(m_pCommand);
        if(0 != m_pszName)
        {
            XFree((void*)m_pszName);
        }
    }
}

HRESULT XPQTask::Create()
{
    return S_OK;
}

void XPQTask::Clone(DWORD dwNewID, XPQTask *pNewTask)
{
    pNewTask->m_dwID         = dwNewID;
    pNewTask->m_dwTypeID     = m_dwTypeID;
    pNewTask->m_pszName      = m_pszName;
    pNewTask->m_Aquired      = m_Aquired;
    pNewTask->m_pAllocator   = m_pAllocator;
    pNewTask->m_fTPS         = m_fTPS;
    pNewTask->m_dwStartTicks = m_dwStartTicks;
    pNewTask->m_dwTotalTicks = m_dwTotalTicks;
    pNewTask->m_dwEndTicks   = m_dwEndTicks;
    pNewTask->m_pCommand     = m_pCommand;
    pNewTask->m_dwTimeout    = m_dwTimeout;
    pNewTask->m_bTracing     = m_bTracing;
	pNewTask->m_bSendToINH   = m_bSendToINH;
    pNewTask->m_pConn        = 0;
    pNewTask->m_bIsCopy      = true;
    pNewTask->m_hr           = S_OK;
}

void XPQTask::Clear()
{
    SOCKET_OVERLAPPED::Clear(); // clear base structure
    m_Aquired.Clear();
    m_Resources.Clear();
}

void XPQTask::SetTypeID(DWORD dwTypeID)
{
    m_dwTypeID = dwTypeID;
}

void XPQTask::SetTPS(float fTPS)
{
    m_fTPS = fTPS;
}

void XPQTask::SetAllocator(XPQTaskAllocator *pAllocator)
{
    _ASSERTE(pAllocator);

    m_pAllocator = pAllocator;
}

void XPQTask::SetName(const char *pszName)
{
    m_pszName = Duplicate(pszName);
    _ASSERTE(m_pszName);
}

void XPQTask::SetTracing(bool bTracing)
{
    m_bTracing = bTracing;
}

void XPQTask::SetSendToINH(bool bSendToINH)
{
	m_bSendToINH = bSendToINH;
}

void XPQTask::SetTimeout(DWORD dwTimeout)
{
    m_dwTimeout = dwTimeout;
}

void XPQTask::GetAquiredResources(TaskResourceMark &Aquired) const
{
    // Copy out the aquired resource record
    Aquired = m_Aquired;
}


XPQTaskResourceBlock& XPQTask::GetResourceBlock()
{
    return m_Resources;
}

void XPQTask::DetachResources(
                TaskResourceMark &Released, 
                BasePresenceConnection **ppOutConnection)
{
    m_Resources.Release(Released);
    *ppOutConnection = m_pConn;
    m_pConn = 0;
}

BasePresenceConnection *XPQTask::GetConnection() const
{
    _ASSERTE(0 != m_pConn);
    return m_pConn;
}

void XPQTask::SetCommand(Command *pCommand)
{
    _ASSERTE(0 == m_pCommand);
    _ASSERTE(pCommand);
    m_pCommand = pCommand;
}

HRESULT XPQTask::AttachResources(
                XPQTaskResourceBlock &Resources,
                TaskResourceMark &Aquired,
                BasePresenceConnection *pConn)
{
    if((Aquired.dwNumOnline + Aquired.dwNumOffline) == 0)
    {
        return E_FAIL;
    }
    
    if(0 == pConn)
    {
        return E_INVALIDARG;
    }

    m_Resources = Resources;
    m_Aquired   = Aquired;
    m_pConn     = pConn;

    return S_OK;
}

void XPQTask::RecordStart()
{
    m_dwEndTicks    = 0;
    m_dwTotalTicks  = 0;
    m_dwStartTicks  = GetTickCount();
}

void XPQTask::RecordFinish()
{
    m_dwEndTicks    = GetTickCount();
    m_dwTotalTicks  = m_dwEndTicks - m_dwStartTicks;
}

HRESULT XPQTask::Run()
{
    HRESULT hr = E_FAIL;

    _ASSERTE(m_pCommand);

    m_dwLastCommandTicks = GetTickCount();
    hr = m_pCommand->Execute(this);
    if(FAILED(hr))
    {
		if(HasConnection() && m_pConn->Type() == FDCONNECTION)
		{
			ERR5(TaskMgr, "[XPQTask::Run]: Command execution failed, id: %u, command: %s, HR: 0x%08x, http: %u, serverhr: 0x%08x",
					m_dwID,
					m_pCommand->Name(), 
					hr,
					((FdConnection*)m_pConn)->HttpStatus(),
					((FdConnection*)m_pConn)->ServerHR());
		}
		else
		{
			ERR3(TaskMgr, "[XPQTask::Run]: Command execution failed, id: %u, command: %s, HR: 0x%08x",
					m_dwID,
					m_pCommand->Name(), 
					hr);
		}
        goto lbDone;
    }

	if(HasConnection() && m_pConn->Type() == FDCONNECTION)
	{
		USERTRACE4(m_Resources.GetOnlineOrOfflineUser(0)->UserId(), "Run task name: %s, hr: 0x%08x, serverHR: 0x%08x, status: %03u",
				m_pCommand->Name(),
				hr,
				((FdConnection*)m_pConn)->HttpStatus(),
				((FdConnection*)m_pConn)->ServerHR());
	}
	else
	{
		USERTRACE2(m_Resources.GetOnlineOrOfflineUser(0)->UserId(), "Run task name: %s, hr: 0x%08x",
				m_pCommand->Name(),
				hr);
	}

lbDone:
    return hr;
}

HRESULT XPQTask::HandleIo(DWORD cbTransferred, bool *pbCompletionDelivered)
{
    HRESULT hr = E_FAIL;

    _ASSERTE(0 != m_pConn && m_pConn->Type() == FDCONNECTION);
	FdConnection *fdConn = (FdConnection*)m_pConn;

    switch(dwOperation)
    {
        case SOCKET_OPERATION_RECV:
        case SOCKET_OPERATION_RECV_FROM:
            hr = fdConn->CompleteReceive(cbTransferred, pbCompletionDelivered);
            break;
        case SOCKET_OPERATION_SEND:
        case SOCKET_OPERATION_SEND_TO:
            hr = fdConn->CompleteSend(cbTransferred);
            break;
        case SOCKET_OPERATION_CONNECT:
            hr = fdConn->CompleteConnect();
            break;
    }

    return hr;
}

HRESULT XPQTask::Completed(HRESULT hr)
{
	if(m_bSendToINH)
	{
		m_hr = hr;
		return hr;
	}

    if(m_bTracing)
    {
        XPQUser *pUser = m_Resources.GetOnlineOrOfflineUser(0);
		TRACE8(TaskTrace, L_NORMAL, "Completed task: %s [%u], user: %I64x, localhr: 0x%08x, serverhr: 0x%08x, http: %u, connstate: %u, elapsed: %ums",
				m_pszName, 
				m_dwID,
				pUser ? pUser->UserId() : 0, 
				hr,
				((FdConnection*)m_pConn)->ServerHR(),
				((FdConnection*)m_pConn)->HttpStatus(),
				((FdConnection*)m_pConn)->State(),
				GetTickCount() - m_dwStartTicks);
    }

    if(FAILED(hr) && FAILED(((FdConnection*)m_pConn)->ServerHR()))
    {
        m_hr = ((FdConnection*)m_pConn)->ServerHR();
    }
    else
    {
        m_hr = hr;
    }

    return hr;
}


//------------------------------------------------------------------------------
// Task allocator implementation
//------------------------------------------------------------------------------

XPQTaskAllocator::XPQTaskAllocator() :
    m_dwcCommands(0)
{
}

XPQTaskAllocator::~XPQTaskAllocator()
{
}

bool GetPoolFlags(char *pszBucketName, DWORD &dwOutPoolFlags)
{
	DWORD i;
    for(i = 0; i < USERPOOL_MAX_ID; ++i)
    {
        if(!_stricmp(rgszBucketNames[i], pszBucketName))
        {
            dwOutPoolFlags |=  1 << i;
            break;
        }
    }
    
    return i < USERPOOL_MAX_ID;
}

bool GetPool(const char *pszPoolName, AllocatorPool &eOutPool, DWORD &dwOutPoolFlags)
{
    if(!_stricmp("Online", pszPoolName))
    {
        eOutPool = kAllocatorPool_Online;
        dwOutPoolFlags |= USERPOOL_INFO_FLAGS_ONLINE;
        return true;
    }
    else if(!_stricmp("Offline", pszPoolName))
    {
        eOutPool = kAllocatorPool_Offline;
        dwOutPoolFlags |= USERPOOL_INFO_FLAGS_OFFLINE;
        return true; 
    }
    else if(!_stricmp("OfflineForAlive", pszPoolName))
    {
        eOutPool = kAllocatorPool_OfflineForAlive;
        dwOutPoolFlags |= USERPOOL_INFO_FLAGS_OFFLINE_FOR_ALIVE;
        return true; 
    }
    else if(!_stricmp("Random", pszPoolName))
    {
        eOutPool = kAllocatorPool_Random;
        return true; 
    }
    else if(!_stricmp("None", pszPoolName))
    {
        eOutPool = kAllocatorPool_None;
        return true;
    }


    return false;
}

//------------------------------------------------------------------------------
// Internal definitions for the spec parser
#define TAS_POOL       0
#define TAS_COUNT_MIN  1
#define TAS_COUNT_MAX  2
#define TAS_BUCKET     3
#define TAS_WRITTEN() (pszBuffer - &szBuffer[0])
#define TAS_PROCESSED() (pszCursor - pszAllocatorSpec)
#define TAS_WRITE_CURSOR() *pszBuffer++ = *pszCursor;
#define TAS_CHANGE_STATE(N) dwState = N; pszBuffer = szBuffer; ZeroMemory(szBuffer, sizeof(szBuffer));
#define TAS_BAD_TOKEN()  ERR3(TaskMgr, "[XPQTaskAllocator::GetAllocator]: bad token '%c' in pool spec pos: %u of '%s'", \
                                *pszCursor, \
                                TAS_PROCESSED(), \
                                pszAllocatorSpec);
#define TAS_NO_TOKEN()  ERR3(TaskMgr, "[XPQTaskAllocator::GetAllocator]: no token at delim '%c' in pool spec pos: %u of '%s'", \
                                *pszCursor, \
                                TAS_PROCESSED(), \
                                pszAllocatorSpec);
#define TAS_BAD_NAME()  ERR3(TaskMgr, "[XPQTaskAllocator::GetAllocator]: name '%s' was not valid in pool spec pos: %u of '%s'", \
                                szBuffer, \
                                TAS_PROCESSED(), \
                                pszAllocatorSpec);

HRESULT XPQTaskAllocator::GetAllocator(
            const char *pszAllocatorSpec, 
            XPQTaskAllocator **ppOutAllocator)
{
    HRESULT hr;
    XPQTaskAllocator *pAllocator;
    const char *pszCursor, *pszCursorEnd;
    char szBuffer[128];
    char *pszBuffer;
    DWORD dwState;
    DWORD dwAllocatorSpecLen;

    // current command being parsed
    AllocatorPool ePool;
    DWORD dwPoolFlags;
    DWORD dwMinCount;
    DWORD dwMaxCount;

    if(0 == pszAllocatorSpec || 0 == ppOutAllocator)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    *ppOutAllocator = 0;


    //
    // Initialize parsing
    // 
    dwAllocatorSpecLen = (DWORD)strlen(pszAllocatorSpec);
    pszCursor          = pszAllocatorSpec;
    pszCursorEnd       = pszCursor + dwAllocatorSpecLen + 1;
    pszBuffer          = szBuffer;
    dwState            = 0;

    ZeroMemory(szBuffer, sizeof(szBuffer));

    ePool              = kAllocatorPool_Online;
    dwPoolFlags        = 0;
    dwMinCount         = 0;
    dwMaxCount         = 0;
    hr                 = E_FAIL;

    pAllocator         = new XPQTaskAllocator();

    while(pszCursor < pszCursorEnd)
    {
        switch(dwState)
        {
            //------------------------------------------------------------------------------
            case TAS_POOL:
            {
                switch(*pszCursor)
                {
                    case ':':
                        if(TAS_WRITTEN() == 0)
                        {
                            TAS_NO_TOKEN();
                            goto lbDone;
                        }
                        if(!GetPool(szBuffer, ePool, dwPoolFlags))
                        {
                            TAS_BAD_NAME();
                            goto lbDone;
                        }
                        TAS_CHANGE_STATE(TAS_COUNT_MIN);
                        break;
                    default:
                        if(!isalpha(*pszCursor))
                        {
                            TAS_BAD_TOKEN();
                            goto lbDone;
                        }
                        TAS_WRITE_CURSOR();
                        break;
                }
            }
            break;
            //------------------------------------------------------------------------------
            case TAS_COUNT_MIN:
            {
                switch(*pszCursor)
                {
                    case ':':
                        if(TAS_WRITTEN() == 0)
                        {
                            TAS_NO_TOKEN();
                            goto lbDone;
                        }
                        dwMinCount = strtoul(szBuffer, 0, 10);
                        TAS_CHANGE_STATE(TAS_BUCKET);
                        break;
                    case '-':
                        if(TAS_WRITTEN() == 0)
                        {
                            TAS_NO_TOKEN();
                            goto lbDone;
                        }
                        dwMinCount = strtoul(szBuffer, 0, 10);
                        TAS_CHANGE_STATE(TAS_COUNT_MAX);
                        break;
                    case 0:
                    case ',':
                        if(TAS_WRITTEN() == 0)
                        {
                            TAS_NO_TOKEN();
                            goto lbDone;
                        }

                        dwMinCount = strtoul(szBuffer, 0, 10);

                        // Save the current command parameters
                        if(FAILED(hr = pAllocator->AddAllocCommand(ePool, dwPoolFlags, dwMinCount, dwMaxCount)))
                        {
                            ERR1(TaskMgr, "[XPQTaskAllocator::GetAllocator]: could not add allocator command, HR: 0x%08x", hr);
                            goto lbDone;
                        }

                        dwPoolFlags = 0;
                        dwMinCount = 0;
                        dwMaxCount = 0;

                        TAS_CHANGE_STATE(TAS_POOL);
                        break;
                    default:
                        if(!isdigit(*pszCursor))
                        {
                            TAS_BAD_TOKEN();
                            goto lbDone;
                        }
                        TAS_WRITE_CURSOR();
                        break;
                }
            }
            break;
            //------------------------------------------------------------------------------
            case TAS_COUNT_MAX:
            {
                switch(*pszCursor)
                {
                    case ':':
                        if(TAS_WRITTEN() == 0)
                        {
                            TAS_NO_TOKEN();
                            goto lbDone;
                        }
                        dwMaxCount = strtoul(szBuffer, 0, 10);
                        TAS_CHANGE_STATE(TAS_BUCKET);
                        break;
                    case 0:
                    case ',':
                        if(TAS_WRITTEN() == 0)
                        {
                            TAS_NO_TOKEN();
                            goto lbDone;
                        }

                        dwMaxCount = strtoul(szBuffer, 0, 10);

                        // Save the current command parameters
                        if(FAILED(hr = pAllocator->AddAllocCommand(ePool, dwPoolFlags, dwMinCount, dwMaxCount)))
                        {
                            ERR1(TaskMgr, "[XPQTaskAllocator::GetAllocator]: could not add allocator command, HR: 0x%08x", hr);
                            goto lbDone;
                        }

                        dwPoolFlags = 0;
                        dwMinCount = 0;
                        dwMaxCount = 0;

                        TAS_CHANGE_STATE(TAS_POOL);
                        break;
                    default:
                        if(!isdigit(*pszCursor))
                        {
                            TAS_BAD_TOKEN();
                            goto lbDone;
                        }
                        TAS_WRITE_CURSOR();
                        break;
                }
            }
            break;
            //------------------------------------------------------------------------------
            case TAS_BUCKET:
            {
                switch(*pszCursor)
                {
                    case ':': 
                        if(TAS_WRITTEN() == 0)
                        {
                            TAS_NO_TOKEN();
                            goto lbDone;
                        }
                        
                        if(!GetPoolFlags(szBuffer, dwPoolFlags))
                        {
                            TAS_BAD_NAME();
                            goto lbDone;
                        }

                        // state goes back to itself to 
                        // allow multiple bucket queries
                        TAS_CHANGE_STATE(TAS_BUCKET);
                        break;
                    case 0:
                    case ',':
                        if(TAS_WRITTEN() == 0)
                        {
                            TAS_NO_TOKEN();
                            goto lbDone;
                        }

                        if(!GetPoolFlags(szBuffer, dwPoolFlags))
                        {
                            TAS_BAD_NAME();
                            goto lbDone;
                        }

                        // Save the current command parameters
                        if(FAILED(hr = pAllocator->AddAllocCommand(ePool, dwPoolFlags, dwMinCount, dwMaxCount)))
                        {
                            ERR1(TaskMgr, "[XPQTaskAllocator::GetAllocator]: could not add allocator command, HR: 0x%08x", hr);
                            goto lbDone;
                        }

                        dwPoolFlags = 0;
                        dwMinCount = 0;
                        dwMaxCount = 0;

                        TAS_CHANGE_STATE(TAS_POOL);
                        break;

                    default:
                        if(!isalpha(*pszCursor))
                        {
                            TAS_BAD_TOKEN();
                            goto lbDone;
                        }
                        TAS_WRITE_CURSOR();
                        break;
                }
            }
            break;
        } // end state switch

        pszCursor++;
    }

    hr = S_OK;

lbDone:

    if(SUCCEEDED(hr) && pAllocator->CountCommands() > 0)
    {
        *ppOutAllocator = pAllocator;       
    }
    else
    {
        ERR2(TaskMgr, "[XPQTaskAllocator::GetAllocator]: 0 commands were loaded for spec: %s, HR: 0x%08x", 
                pszAllocatorSpec,
                hr);
        SAFE_DELETE(pAllocator);
    }

    return hr;
}

HRESULT XPQTaskAllocator::AddAllocCommand(AllocatorPool ePool, DWORD dwPoolFlags, DWORD dwMinCount, DWORD dwMaxCount)
{
    if(0 == dwMinCount || (0 != dwMaxCount && dwMinCount > dwMaxCount))
    {
        return E_INVALIDARG;
    }

    if(m_dwcCommands == ALLOCATOR_MAX_COMMANDS)
    {
        return E_FAIL;
    }


    XPQAllocationCommand &cmd = m_rgCommands[m_dwcCommands++];

    cmd.ePool       = ePool;
    cmd.dwPoolFlags = dwPoolFlags;
    cmd.dwMinCount  = dwMinCount;
    cmd.dwMaxCount  = dwMaxCount;

    return S_OK;
}


HRESULT XPQTaskAllocator::Allocate(XPQTaskResourceBlock &Resources, TaskResourceMark &Aquired)
{
    HRESULT hr = S_OK;
    XPQUser* pUser;
    XPQAllocationCommand* pCommand;
    DWORD dwAllocCount;
    DWORD dwAllocated = 0;

    //
    // Stop allocating if we hit a miss condition or we run out of 
    // allocation commands to run.
    //
    for(DWORD i = 0, c = m_dwcCommands; S_OK == hr && i < c; ++i)
    {
        pCommand = &m_rgCommands[i];
        
        if(0 != pCommand->dwMaxCount)
        {
            dwAllocCount = (rand() % (pCommand->dwMaxCount-pCommand->dwMinCount)) + pCommand->dwMinCount;
        }
        else
        {
            dwAllocCount = pCommand->dwMinCount;
        }


        // Do a pre-check to see if we can even get the requested number
        // of users from the given pool
        if(kAllocatorPool_Online == pCommand->ePool && gpUserMgr->Online() < dwAllocCount)
        {
            DBG2(TaskMgr, "[XPQTaskAllocator::Allocate]: allocator only had %u online users (needed: %u)",
                    gpUserMgr->Online(),
                    dwAllocCount);
            hr = S_FALSE;
            goto lbDone;
        }
        else if(kAllocatorPool_Offline == pCommand->ePool && gpUserMgr->Offline() < dwAllocCount)
        {
            DBG2(TaskMgr, "[XPQTaskAllocator::Allocate]: allocator only had %u offline users (needed: %u)",
                    gpUserMgr->Offline(),
                    dwAllocCount);
            hr = S_FALSE;
            goto lbDone;
        }
        else if(kAllocatorPool_None == pCommand->ePool)
        {
            // No resources required for this, a null allocator
            hr = S_OK;
            goto lbDone;
        }


        //
        // Allocate the block of users
        //
        for(dwAllocated = 0; dwAllocated < dwAllocCount; ++dwAllocated)
        {
            switch(pCommand->ePool)
            {
                case kAllocatorPool_Random:
                    if(rand() > RAND_MAX/2) 
                    {
                        hr = gpUserMgr->AquireUser(
                                USERPOOL_INFO_FLAGS_OFFLINE|pCommand->dwPoolFlags,
                                Resources,
                                Aquired);
                    }
                    else
                    {
                        hr = gpUserMgr->AquireUser(
                                USERPOOL_INFO_FLAGS_ONLINE|pCommand->dwPoolFlags,
                                Resources,
                                Aquired);
                    }
                    break;
                case kAllocatorPool_Offline:
                    hr = gpUserMgr->AquireUser(
                            USERPOOL_INFO_FLAGS_OFFLINE|pCommand->dwPoolFlags,
                            Resources,
                            Aquired);
                    break;
                case kAllocatorPool_OfflineForAlive:
                    hr = gpUserMgr->AquireUser(
                            USERPOOL_INFO_FLAGS_OFFLINE_FOR_ALIVE|pCommand->dwPoolFlags,
                            Resources,
                            Aquired);
                    break;
                case kAllocatorPool_Online:
                    hr = gpUserMgr->AquireUser(
                            USERPOOL_INFO_FLAGS_ONLINE|pCommand->dwPoolFlags,
                            Resources,
                            Aquired);
                    break;
            }

            if(S_OK != hr)
            {
                if(FAILED(hr))
                {
                    ERR5(TaskMgr, "[XPQTaskAllocator::Allocate]: failed to allocate users, pool: %u, flags: 0x%08x, min: %u, max: %u, HR: 0x%08x",
                            pCommand->ePool,
                            pCommand->dwPoolFlags,
                            pCommand->dwMinCount,
                            pCommand->dwMaxCount,
                            hr);
                }

                goto lbDone;
            }
        }
    }

    hr = S_OK;

lbDone:

    // Release all allocated users if we didn't meet all required
    // allocation conditions
    if(S_OK != hr)
    {
        if(FAILED(hr))
        {
            ERR3(TaskMgr, "[XPQTaskAllocator::Allocate]: allocation failed, releasing %u online, %u offline users, HR: 0x%08x", 
                    Aquired.dwNumOnline,
                    Aquired.dwNumOffline,
                    hr);
        }

        TaskResourceMark Released;
        Released.Clear();
        Resources.Release(Released);
    
        _ASSERTE(Released.dwNumOnline == Aquired.dwNumOnline);
        _ASSERTE(Released.dwNumOffline == Aquired.dwNumOffline);

        Aquired.Clear();
    }
    else
    {
        _ASSERT(((Aquired.dwNumOnline + Aquired.dwNumOffline) > 0));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\switchboard.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef SWITCHBOARD_H_INCLUDED
#define SWITCHBOARD_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

extern const SGADDR sgaddrIgnore;

class CSwitchboard;
class XPQMsg;
class XPQTask;
class XPQUser;

/*****************************************************************************

CPConnReceiveContext

*****************************************************************************/
class CPConnReceiveContext :   
	public CCompletionContext,
	public CCompletionHandler
{
public:
    CPConnReceiveContext(
        CPresConnection *pCPConn) :
        m_pCPConn(pCPConn)
    {
        m_pCPConn->AddRef();
    }

    virtual ~CPConnReceiveContext()
    {
        SAFE_RELEASE(m_pCPConn);
        SAFE_ARRAYDELETE(m_pMsg);
    }

    IMPLEMENT_REFCOUNT


    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void OnIoCompletion( 
        DWORD dwError, 
        DWORD cbTransferred, 
        ULONG_PTR ulpKey,
        CCompletionContext *pCtx )
    {
        XOMASSERT( NULL != m_pCPConn );

        m_pCPConn->ProcessPConnMessage(m_pMsg, m_cbEntireMsg);

        Release();
    }
      
    virtual const char* GetContextDesc() { return "PConnReceive"; }

protected:
    CPresConnection *m_pCPConn;

public:
    BYTE *m_pMsg;
    DWORD m_cbEntireMsg;
};

/*****************************************************************************
CRequestContext
Context object for a single INH request
*****************************************************************************/
class CRequestContext : 
    public CCompletionContext,
    public CCompletionHandler
{
friend CRequestContextIndex;

public:

    CRequestContext(XPQMsg *pMsg);
    ~CRequestContext();

    void *operator new(size_t len) { return XAlloc(len); }
    void operator delete(void *pv) { XFree(pv); }

    IMPLEMENT_REFCOUNT;

    void Init(XPQTask*      pTask,
			  XPQUser*      pUser, 
			  CSwitchboard *pCSwitchboard,
			  CompletionPort* pCP);

    DWORD GetContextId() { return m_dwContextId; }
	void SetContextId(DWORD dwContextId) {m_dwContextId = dwContextId;}
	XPQMsg* GetMsg() { return m_pMsg; }
	XPQUser* GetUser() { return m_pUser; }
	XPQTask* GetTask() { return m_pTask; }

	void Complete()
	{
		m_pCP->PostCompletion(m_pTask,0,1);
	}

	void SetHR(HRESULT hr);

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void OnIoCompletion( 
        DWORD dwError, 
        DWORD cbTransferred, 
        ULONG_PTR ulpKey,
        CCompletionContext *pCtx );

protected:

    DWORD m_dwContextId;
    CRequestContext *m_pCContextIndexNext;
    CRequestContext *m_pCContextIndexBack;

	XPQMsg *      m_pMsg;
    XPQTask*      m_pTask;
    XPQUser*      m_pUser; 
    CSwitchboard *m_pSwitchboard;
	CompletionPort* m_pCP;
};

/*****************************************************************************

CRequestContextIndex

Index to find a request context by Id

*****************************************************************************/
class CRequestContextIndex
{
public:
    CRequestContextIndex();
    ~CRequestContextIndex();

    HRESULT Init();

    void AddContext(CRequestContext *pCCtx);
    void RemoveContext(CRequestContext *pCCtx);

    CRequestContext *GetContext(DWORD dwContextId);

protected:
    DWORD Hash(DWORD dwContextId) { return dwContextId % m_cBuckets; }

	DWORD m_dwNumEntries;
    DWORD m_cBuckets;
    CRequestContext **m_rgpCRequestContextHashTable;
};

/*****************************************************************************

CHeartbeatHandler

This object is posted to the main IO Completion port on a regular interval to
do maintainece processing such as retrying dead connections, cleanup, etc.

*****************************************************************************/
class CHeartbeatHandler : 
    public CCompletionContext,
    public CCompletionHandler
{
public:
    CHeartbeatHandler( CSwitchboard *pSwitchboard ) :
        m_pSwitchboard( pSwitchboard )
    {
    }

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual ULONG AddRef();
    virtual ULONG Release();

    virtual void OnIoCompletion( 
        DWORD dwError, 
        DWORD cbTransferred, 
        ULONG_PTR ulpKey,
        CCompletionContext *pCtx );
      
protected:
    CSwitchboard *m_pSwitchboard;
};

/*****************************************************************************

CSwitchboard

Main object for most service tasks.  Holds the main IO Completion port,
listening socket and instances other major objects.

*****************************************************************************/
class CSwitchboard
{
public:
    CSwitchboard();
    ~CSwitchboard();

    IMPLEMENT_REFCOUNT;
    
    HRESULT Init();
    
    void Shutdown();
    
    HRESULT PostCompletion( CCompletionContext *pCCtx )
    {
        return m_pCompPort->PostCompletion( pCCtx );
    }

	void ProcessRequest(CRequestContext *pRequest);

    // Outgoing messages
    HRESULT SendMsgDequeue(DWORD dwContextId, Q_DEQUEUE_MSG *pMsg) 
    { 
        return m_CXPCluster.SendMsgByUserId(dwContextId, pMsg->qwUserID, pMsg);
    }

	// Reply Handlers
	void ProcessMsgListReply(Q_LIST_REPLY_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgListReply2(Q_LIST_REPLY_2_MSG *pMsg, DWORD cbEntireMsg);

    // Heartbeat
    void OnHeartbeat();
    void PeriodicHeartbeat();

protected:
    
    // Completion port
    CCompletionPort *m_pCompPort;
    
    // Contained objects
    CHeartbeatHandler m_HeartbeatHandler;
    DWORD m_dwLastHeartBeat;
    DWORD m_dwLastIndex;
    CXPCluster m_CXPCluster;

	// Outstanding requests
	CRequestContextIndex m_RequestContextIndex;
};

#endif  // SWITCHBOARD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\TaskMgr.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2002 Microsoft.  ALL RIGHTS RESERVED
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

//------------------------------------------------------------------------------
//
// Task manager implementation
//
//------------------------------------------------------------------------------

// Pointer to singleton ms_pTaskMgr
XPQTaskMgr* XPQTaskMgr::ms_pTaskMgr = NULL;

// Ini File Settings
MGMT_DefineConfigSetting( TaskMgr, TaskThreads );
MGMT_DefineConfigSetting( TaskMgr, MaxInProgress );
MGMT_DefineConfigSetting( TaskMgr, SchedulerTimeSlice );
MGMT_DefineConfigSetting( TaskMgr, SchedulerLoadScale );
MGMT_DefineConfigSetting( TaskMgr, FailedTaskTimeout );

MGMT_DefineConfigSetting( TaskMgr, PeerSubscribeMinPeers );
MGMT_DefineConfigSetting( TaskMgr, PeerSubscribeMaxPeers );

MGMT_DefineLoggingCategory( TaskMgr );
MGMT_DefineLoggingCategory( TaskTrace );

XPQTaskMgr *gpTaskMgr = 0;

XPQTaskMgr::XPQTaskMgr()
:
    m_wThreads(0),
    m_ahThreads(NULL),
    m_pScheduler(0),
    m_prgWorkers(0),
    m_dwcWorkers(0),
    m_hStopEvent(INVALID_HANDLE_VALUE),
    m_pCP(0),
    m_prgTaskBuffer(0),
    m_dwcTasks(0),
    m_pTaskHead(0),
    m_pTasksInProgress(0),
    m_dwWorkerBatchTLS(TLS_OUT_OF_INDEXES)
{

    if(NULL == ms_pTaskMgr)
    {
        ms_pTaskMgr = this;
        gpTaskMgr = this;
    }

    ZeroMemory(&m_csTaskBuffer, sizeof(m_csTaskBuffer));
}

XPQTaskMgr::~XPQTaskMgr()
{
    Destroy(); 

    if(this == ms_pTaskMgr)
    {
        ms_pTaskMgr = NULL;
        gpTaskMgr = NULL;
    }

}

HRESULT XPQTaskMgr::Create( HANDLE hStopEvent )
{
    HRESULT hr = S_OK;

    _ASSERTE(INVALID_HANDLE_VALUE != hStopEvent);
    m_hStopEvent = hStopEvent;

    // Load all valid task settings
    if(!LoadTaskSettings())
    {
        ERR0(TaskMgr, "[XPQTaskMgr::Create]: failed to load any valid task settings");
        goto lbDone;
    }

    //
    // Allocate Thread Handle Array
    // 
    // Add one for the scheduler
    //
    m_dwcWorkers = (WORD) MGMT_GetConfigSetting(TaskMgr, TaskThreads).GetDWORD();
    TRACE1( TaskMgr, L_NORMAL, "[XPQTaskMgr::Create] - allocate worker thread handles [%d threads]", m_dwcWorkers );

    HANDLE* ahThreads = new HANDLE[ m_dwcWorkers ];
    _ASSERTE( NULL != ahThreads );
    if( NULL == ahThreads )
    {
        ERR1( TaskMgr, "[XPQTaskMgr::Create]: allocate worker thread handles failed, HR: 0x%08x", HRESULT_FROM_WIN32(GetLastError()) );
        hr = E_OUTOFMEMORY;
        goto lbDone;
    }
    memset( ahThreads, 0, sizeof( HANDLE ) * m_dwcWorkers );
    m_ahThreads = ahThreads;

    // Create the batch state update TLS
    m_dwWorkerBatchTLS = TlsAlloc();
    if(TLS_OUT_OF_INDEXES == m_dwWorkerBatchTLS)
    {
        ERR1( TaskMgr, "[XPQTaskMgr::Create]: failed to create state batch tls, hr: 0x%08x", hr);
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto lbDone;
    }

    //
    // Create the task IO completion port
    //
    m_pCP = new CompletionPort();
    if(0 == m_pCP)
    {
        hr = E_OUTOFMEMORY;
        goto lbDone;
    }

    if(FAILED(hr = m_pCP->Create(m_dwcWorkers)))
    {
        ERR1(TaskMgr, "[XPQTaskMgr::Create]: Failed to create task IO completion port, HR: 0x%08x", hr);
        goto lbDone;
    }

    //
    // Create the worker and scheduler thread wrappers
    //
    m_pScheduler = new SchedulerTaskThread();
    if(0 == m_pScheduler)
    {
        hr= E_OUTOFMEMORY;
        goto lbDone;
    }

    m_prgWorkers = new WorkerTaskThread[m_dwcWorkers];
    if(0 == m_prgWorkers)
    {
       hr = E_OUTOFMEMORY;
       goto lbDone;
    }
    
    //
    // Create the threads
    //
    TRACE0( TaskMgr, L_NORMAL, "[XPQTaskMgr::Create]: create threads" );

    m_wThreads = 0;
    unsigned uID = 0;

    //
    // Create scheduler thread
    //
    ahThreads[0] = (HANDLE) _beginthreadex( NULL, 0, &SchedulerThreadProc, m_pScheduler,  CREATE_SUSPENDED, &uID );
    _ASSERTE( NULL != ahThreads[0] );
    if( NULL == ahThreads[0] )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR1( TaskMgr, "[XPQTaskMgr::Create]: create scheduler thread failed, HR: 0x%08x", hr);
        goto lbDone;
    }
    m_wThreads++;

    hr = m_pScheduler->Create(hStopEvent, ahThreads[0], uID);
    if(FAILED(hr))
    {
        ERR1(TaskMgr, "[XPQTaskMgr::Create]: failed to create scheduler, HR: 0x%08x", hr);
        goto lbDone;
    }

    if(FAILED(hr = m_pScheduler->SetCompletionPort(m_pCP)))
    {
        ERR1(TaskMgr, "[XPQTaskMgr::Create]: Failed to create scheduler, HR: 0x%08x", hr);
        goto lbDone;
    }

    //
    // Create worker threads
    //
    for( WORD wWorkerI = 1; wWorkerI < m_dwcWorkers+1; ++wWorkerI )
    {
        ahThreads[wWorkerI] = (HANDLE) _beginthreadex( NULL, 0, &WorkerThreadProc, &m_prgWorkers[wWorkerI-1], CREATE_SUSPENDED, &uID );
        _ASSERTE( NULL != ahThreads[wWorkerI] );
        if( NULL == ahThreads[wWorkerI] )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR1( TaskMgr, "[XPQTaskMgr::Create]:  create threads failed, HR: 0x%08x", hr);
            goto lbDone;
        }
        m_prgWorkers[wWorkerI-1].Create(hStopEvent, ahThreads[wWorkerI], uID);
        m_prgWorkers[wWorkerI-1].SetCompletionPort(m_pCP);
        m_prgWorkers[wWorkerI-1].SetScheduler(m_pScheduler);
        m_wThreads++;
    }

    // 
    // Create task buffer, we can only queue tasks up to the max queued per thread * num threads
    // 
    DWORD dwMaxInProgress = MGMT_GetConfigSetting(TaskMgr, MaxInProgress).GetDWORD();
    _ASSERTE(0 != dwMaxInProgress);

    m_dwcTasks = (dwMaxInProgress * m_dwcWorkers);
    m_prgTaskBuffer = new XPQTask[m_dwcTasks];
    _ASSERTE(0 != m_prgTaskBuffer);
    if(0 == m_prgTaskBuffer)
    {
        hr = E_OUTOFMEMORY;
        ERR0(TaskMgr, "[XPQTaskMgr::Create]: Failed to allocate task buffer");
        goto lbDone;
    }


    ZeroMemory(m_prgTaskBuffer, (m_dwcTasks * sizeof(XPQTask)));
    
    for(DWORD i = 0, c = m_dwcTasks - 1; i < c; ++i)
    {
        m_prgTaskBuffer[i].m_pNext = &m_prgTaskBuffer[i+1];
    }

    m_pTaskHead = &m_prgTaskBuffer[0];

    InitializeCriticalSection(&m_csTaskBuffer);

    hr = S_OK;
    
lbDone:

    return hr;
}

XPQTask *XPQTaskMgr::AquireTask()
{
    EnterCriticalSection(&m_csTaskBuffer);
    XPQTask *pTask = m_pTaskHead;
    if(m_pTaskHead)
    {
        m_pTaskHead = m_pTaskHead->m_pNext;
        pTask->m_pNext = 0;
        --m_dwcTasks;
    }

    // Add the task to the inprogress list
    if(0 != m_pTasksInProgress)
    {
        m_pTasksInProgress->m_pPrev = pTask;
    }
    pTask->m_pNext = m_pTasksInProgress;
    m_pTasksInProgress = pTask; 

    LeaveCriticalSection(&m_csTaskBuffer);

    return pTask;
}

void XPQTaskMgr::ReleaseTask(XPQTask *pTask)
{
    // Validate task pointer and ensure it is not already in the 
    // free list
    _ASSERTE(0 != pTask);
    _ASSERTE(0 == pTask->m_Resources.Count());
    _ASSERTE(pTask == m_pTasksInProgress || pTask->m_pPrev || pTask->m_pNext);

    EnterCriticalSection(&m_csTaskBuffer);

    // Cleanup the in progress list
    if(pTask->m_pPrev)
    {
        pTask->m_pPrev->m_pNext = pTask->m_pNext;
    }
    if(pTask->m_pNext)
    {
        pTask->m_pNext->m_pPrev = pTask->m_pPrev;
    }
    if(pTask == m_pTasksInProgress)
    {
        m_pTasksInProgress = m_pTasksInProgress->m_pNext;
    }

    pTask->m_pPrev = 0;
    pTask->m_pNext = 0;

    pTask->Clear();

    pTask->m_pNext = m_pTaskHead;
    m_pTaskHead = pTask;
    ++m_dwcTasks;
    LeaveCriticalSection(&m_csTaskBuffer);
}

void XPQTaskMgr::LogStats() const
{
    m_pScheduler->LogStats();
    for(DWORD i = 0; i < m_dwcWorkers; ++i)
    {
        m_prgWorkers[i].LogStats();
    }
}

void XPQTaskMgr::LogTasksInProgress(DWORD dwMillis)
{
    EnterCriticalSection(&m_csTaskBuffer);

    DWORD dwcTasks  = 0;
    DWORD dwNow     = GetTickCount();
    DWORD dwStarted = dwNow - dwMillis;

    for(XPQTask *pTask = m_pTasksInProgress; pTask; pTask = pTask->m_pNext)
    {
        if(pTask->StartTicks() <= dwStarted)
        {
            BasePresenceConnection *pConn = pTask->GetConnection();
            TRACE5(TaskMgr, L_OOB, "Task[%u] %s, ConnState: %u, ConnOp: %u, InProgress: %ums",
                pTask->ID(),
                pTask->Name(),
				pConn ? (pConn->Type() == FDCONNECTION ? ((FdConnection*)pConn)->State(): -1) : -1,
                pTask->dwOperation,
                dwNow - pTask->StartTicks());
            dwcTasks++;
        }
    }

    TRACE2(TaskMgr, L_OOB, "%u tasks were pending for at least %u millis",
            dwcTasks,
            dwMillis);
    LeaveCriticalSection(&m_csTaskBuffer);
}

void XPQTaskMgr::Destroy()
{
    TRACE1( TaskMgr, L_NORMAL, "[XPQTaskMgr::Destroy]: shutting down: %u threads", m_wThreads );

    if( NULL != m_ahThreads )
    {
        if( m_wThreads > 0 )
        {
            // Make Sure threads are running
            ResumeThreads();

            // Wait for them to finish
            TRACE0( TaskMgr, L_NORMAL, "[XPQTaskMgr::Destroy]: waiting for threads to stop" );

            DWORD dwRet = WaitForMultipleObjects( m_wThreads, m_ahThreads, TRUE, INFINITE );

            if( WAIT_FAILED == dwRet )
            {
                ERR1(TaskMgr, "[XPQTaskMgr::Destroy]: WaitForMultipleObjects() failed, HR: 0x%08x", HRESULT_FROM_WIN32(GetLastError()));
            }

            // Close the thread Handles and free array
            for( WORD wThreadI = 0; wThreadI < m_wThreads; ++wThreadI )
            {
                SAFE_CLOSEHANDLE(m_ahThreads[wThreadI]);
            }
        }

        delete [] m_ahThreads;
    }

    for(DWORD dwi = 0, dwc = m_Tasks.GetSize(); dwi < dwc; ++dwi)
    {
        XPQTaskPacing *pTaskPacing;
        if(m_Tasks.GetAt(dwi, (void**)&pTaskPacing))
        {
            SAFE_DELETE(pTaskPacing);
        }
    }

    if(!TlsFree(m_dwWorkerBatchTLS))
    {
        ERR1(TaskMgr, "[XPQTaskMgr::Destroy]: failed to free TLS batch data, hr: 0x%08x",
                HRESULT_FROM_WIN32(GetLastError()));
    }

    SAFE_ARRAY_DELETE(m_prgWorkers);
    SAFE_ARRAY_DELETE(m_prgTaskBuffer);
    SAFE_DELETE(m_pScheduler);

    TRACE0( TaskMgr, L_NORMAL, "[XPQTaskMgr::Destroy]: finished" );
}

// Load all of the weights and pacings from the config file
bool XPQTaskMgr::LoadTaskSettings()
{
    Command* pCommand          = 0;
    Setting* pSetting          = 0;
    XPQTask* pTask             = 0;
    Console& console           = Console::GetInstance();
    SettingIterator* pIterator;

    TRACE0( TaskMgr, L_HIGH, "[XPQTaskMgr::LoadTaskSettings]: loading 'Active' tasks from the [Task.Setup] setting group" );

    // Iterate from beginning of settings
    console.GetSettingIterator(&pIterator, "Task.Setup", "Active");

    pSetting = pIterator->First();
    while(pSetting)
    {
        const char *pszValue = pSetting->GetLPCSTR();
        pTask = XPQTask::CreateAndLoad(pszValue);
        if(0 == pTask)
        {
            ERR1(TaskMgr, "[XPQTaskMgr::LoadTaskSettings]: Task data load failed: %s", pszValue);
            pSetting = pIterator->Next();
            continue;
        }
        else
        {
            TRACE2(TaskMgr, L_HIGH, "[XPQTaskMgr::LoadTaskSettings]: Task data loaded: %s, tps: %.2f", 
                    pTask->Name(), 
                    pTask->TPS());
        }

        XPQTaskPacing *pTaskPacing = new XPQTaskPacing(pTask);
        pTask->SetTypeID(m_Tasks.GetSize());
        m_Tasks.Add((void*)pTaskPacing, 0);
        pSetting = pIterator->Next();
    }

    SAFE_RELEASE(pIterator);

    return (m_Tasks.GetSize() > 0);
}

//
//  Resumes all threads that were CREATE_SUSPENDED
//
bool XPQTaskMgr::ResumeThreads()
{
    TRACE1( TaskMgr, L_NORMAL, "[XPQTaskMgr::ResumeThreads]: resuming %u threads", m_wThreads);
    for( WORD wThreadI = 0; wThreadI < m_wThreads; ++wThreadI )
    {
        DWORD dwRet = ResumeThread( m_ahThreads[wThreadI] );
        _ASSERTE( DWORD(-1) != dwRet );
        if( DWORD(-1) == dwRet )
        {
            TRACE0( TaskMgr, L_ERROR, "[XPQTaskMgr::ResumeThreads]: resuming threads failed" );
            return false;
        }
    }
    return true;
}

//------------------------------------------------------------------------------
// Thread entry points
//------------------------------------------------------------------------------

UINT __stdcall XPQTaskMgr::WorkerThreadProc( void* pArg )
{
    // Associate the batch data with the thread for it's duration
    WorkerBatchData batchData;
    TlsSetValue(gpTaskMgr->m_dwWorkerBatchTLS, (LPVOID)&batchData);

    TRACE1( TaskMgr, L_NORMAL, "[XPQTaskMgr::WorkerThreadProc]: thread [%d] started", GetCurrentThreadId() );
    WorkerTaskThread *pWorker = (WorkerTaskThread*)pArg; 
    pWorker->Run();

    TlsSetValue(gpTaskMgr->m_dwWorkerBatchTLS, (LPVOID)0);

    return 0;
}

UINT __stdcall XPQTaskMgr::SchedulerThreadProc(void *pArg)
{
    TRACE1( TaskMgr, L_NORMAL, "[XPQTaskMgr::SchedulerThreadProc]: thread [%d] started", GetCurrentThreadId() );
    SchedulerTaskThread *pScheduler = (SchedulerTaskThread*)pArg;
    pScheduler->Run();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\TaskPacing.cpp ===
#include "StdAfx.h"

MGMT_ImportLoggingCategory(TaskTrace);

//------------------------------------------------------------------------------
// Task pacing implementation
//------------------------------------------------------------------------------

#define EPSILON   0.00001
#define DECAY     0.99
#define DWORDWRAP 0xffffffff

DWORD XPQTaskPacing::LeftToSchedule(float fElapsed, float fLoadScale)
{
    float fDeltaTps;
    float fScheduleAmmt;
    float fScheduleAmmtActual;
    float fDesiredTps = m_fDesiredTps * fLoadScale;

    // Calculate how far off we are from desired TPS
    fDeltaTps = fDesiredTps - ActualTPS();

    // Calculate how many tasks to schedule for the last elapsed time slice
    fScheduleAmmt = ((fDesiredTps + fDeltaTps) * fElapsed) + m_fRemaining;
    
    // If the delta TPS out runs the desired tps and forces our scheduled ammt 
    // into the negative we want to completly skip this time slice to let things
    // stabalize
    if(fScheduleAmmt > 0.0f)
    {
        fScheduleAmmtActual = floor(fScheduleAmmt);

        // Save remainder for next timeslice
        m_fRemaining = fScheduleAmmt - fScheduleAmmtActual;
    }
    else
    {
        fScheduleAmmtActual = 0.0f;
        m_fRemaining = 0.0f;
    }

    _ASSERTE(fScheduleAmmtActual >= 0.0);

    return DWORD(fScheduleAmmtActual);
}

void XPQTaskPacing::RecordScheduled(float fElapsed, DWORD dwTasksScheduled)
{
    float fTasksScheduled = float(dwTasksScheduled);
    
    Scheduled += fTasksScheduled;

    AvgScheduled.SampleValue(fTasksScheduled);
    AvgElapsed.SampleValue(fElapsed);
}


void XPQTaskPacing::RecordCompleted(float fElapsed, HRESULT hr)
{
    ++Completed;

    if(HRESULT_FROM_WIN32(WSAETIMEDOUT) == hr)
    {
        ++Timeouts;
    }
	else if(HRESULT_FROM_WIN32(WSAEADDRINUSE) == hr || 
		HRESULT_FROM_WIN32(WSAECONNRESET) == hr || 
		HRESULT_FROM_WIN32(WSAECONNREFUSED) == hr ||
		HRESULT_FROM_WIN32(WSAENOBUFS) == hr ||
		HRESULT_FROM_WIN32(WSAECONNABORTED) == hr)

	{
		++ClientErrors;
	}
    else if(FAILED(hr))
    {
        ErrorLog[DWORD(floor(ServerErrors.fTotal)) % TASK_PACING_MAX_ERROR_LOG] = hr;
        ++ServerErrors;
    }
    
    AvgRTT.SampleValue(fElapsed);       
}


void XPQTaskPacing::RecordStarved()
{
    ++Starved;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\TaskPacing.h ===
#pragma once

//------------------------------------------------------------------------------
// Task pacing wraps the scheduling of tasks to run in the scheduler, an
// array of these structures are loaded and cached in the task manager
//------------------------------------------------------------------------------
class __declspec(align(32)) XPQTaskPacing
{
public:
#define TASK_PACING_MAX_ERROR_LOG 8
    HRESULT ErrorLog[TASK_PACING_MAX_ERROR_LOG];

    Counter Scheduled;
    Counter Completed;
    Counter Starved;
    Counter Yielded;
    Counter ClientErrors;
	Counter ServerErrors;
    Counter Timeouts;

    RunningAverageCounter AvgScheduled;
    RunningAverageCounter AvgElapsed;
    RunningAverageCounter AvgRTT;

protected:
    XPQTask* m_pTaskTemplate;

    // Task scheduling constants
    float m_fDesiredTps;
    float m_fAllowedInProgress;

    // Carry from last schedule attempt
    float m_fRemaining;

    // false to turn of task scheduling
    bool  m_bEnabled;
	
	// enable tracing for this specific task
	bool m_bTracing;

public:
    XPQTaskPacing(XPQTask *pTask)  :
        m_pTaskTemplate(pTask),
        m_fDesiredTps(0),
        m_fAllowedInProgress(0),
        m_fRemaining(0),
        m_bEnabled(true),
		m_bTracing(false),
        Scheduled("Scheduled"),
        Completed("Completed"),
        Starved("Starved"),
        Yielded("Yielded"),
        ServerErrors("ServerErrors"),
        ClientErrors("ClientErrors"),
		Timeouts("Timeouts"),
        AvgScheduled("AvgScheduled"),
        AvgElapsed("AvgElapsed"),
        AvgRTT("AvgRTT")
    {
        SetDesiredTPS(pTask->TPS());
        ZeroMemory(ErrorLog, TASK_PACING_MAX_ERROR_LOG*sizeof(HRESULT));

        Scheduled.Clear();
        Completed.Clear();
        Starved.Clear();
        Yielded.Clear();
        ServerErrors.Clear();
        ClientErrors.Clear();

        AvgScheduled.Clear();
        AvgElapsed.Clear();
        AvgRTT.Clear();
    }

    ~XPQTaskPacing()
    {
        SAFE_DELETE(m_pTaskTemplate);
    }

    DWORD     LeftToSchedule(float fElapsed, float fLoadScale);
    void      RecordScheduled(float fElapsed, DWORD dwTasksScheduled);
    void      RecordCompleted(float fElapsed, HRESULT hr);
    void      RecordStarved();

    XPQTask*  Task()       const { return m_pTaskTemplate; }
    float     DesiredTPS() const { return m_fDesiredTps; }
    float     ActualTPS()  const { return ((float)(AvgScheduled.fTotal / (AvgElapsed.fTotal + 0.000001))); }
    float     AverageRTT() const { return AvgRTT.fAverage; }
    bool      Enabled()    const { return m_bEnabled; }
	bool      Tracing()    const { return m_bTracing; }

    void      SetDesiredTPS(double dDesiredTps) 
    { 
        m_fDesiredTps = (float)dDesiredTps; 
        m_fAllowedInProgress = (float)((20 + m_fDesiredTps) * 2.0);
    }

    void      SetEnabled(bool bEnabled) 
	{ 
		m_bEnabled = bEnabled; 
	}

	void      SetTracing(bool bTracing)
	{
		m_bTracing = bTracing;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\TaskThread.cpp ===
#include "StdAfx.h"

MGMT_ImportLoggingCategory(TaskMgr);

//------------------------------------------------------------------------------
// Base TaskThread implementation
//------------------------------------------------------------------------------

TaskThread::TaskThread() :
    m_hStopEvent(INVALID_HANDLE_VALUE),
    m_hThread(INVALID_HANDLE_VALUE),
    m_uiThread(0)
{
}

TaskThread::~TaskThread()
{
    Stop(); 

    m_hThread = INVALID_HANDLE_VALUE;
    m_uiThread = 0;
}

HRESULT TaskThread::Create(HANDLE hStopEvent, HANDLE hThread, UINT uiThread)
{
    HRESULT hr = S_OK;

    // Grab internal members
    m_hStopEvent = hStopEvent;
    _ASSERTE(INVALID_HANDLE_VALUE != m_hStopEvent);

    m_hThread = hThread;
    _ASSERTE(INVALID_HANDLE_VALUE != m_hThread);

    m_uiThread = uiThread;

    return hr;
}

void TaskThread::Stop()
{
    if(m_hStopEvent != INVALID_HANDLE_VALUE)
    {
        SetEvent(m_hStopEvent);
    }

    TRACE2(TaskMgr, L_HIGH, "TaskThread::Stop(): waiting 30 seconds on thread Handle: %X, Id: %u..", 
            m_hThread, m_uiThread);

    DWORD dwStatus = WaitForSingleObject(m_hThread, 30 * 1000);

    TRACE1(TaskMgr, L_HIGH, "TaskThread::Stop(): WaitForSingleObject completed with status: %X, resuming", dwStatus);
}

void TaskThread::Run() 
{
    // Ensure that Create was called
    _ASSERTE(m_hThread != INVALID_HANDLE_VALUE);
    _ASSERTE(m_uiThread != 0);

    // Run internal processing
    RunInternal();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\TaskMgr.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2002 Microsoft.  ALL RIGHTS RESERVED
/////////////////////////////////////////////////////////////////////////////
#pragma once

#include "Task.h"


//------------------------------------------------------------------------------
// Worker batch update data, one of these structures is associate with each
// thread. Any data that needs to be accumulated by multiple tasks before it
// is sent can be added here.
//------------------------------------------------------------------------------
#define WORKER_BATCH_STATE_UPDATE_COUNT 100
struct WorkerBatchData
{
    DWORD                 cUpdates;
    CSgMsgNotifyCliUpdate rgUpdates[WORKER_BATCH_STATE_UPDATE_COUNT];
};

//------------------------------------------------------------------------------
// XPQ Task Manager
//
//  Manages Queue of Tasks, a thread that creates them,
//  and a # of threads to process them
//
//------------------------------------------------------------------------------
class XPQTaskMgr
{
private:

    // pointer to singleton instance.
    static XPQTaskMgr* ms_pTaskMgr;

    XPQTaskMgr( const XPQTaskMgr& );            // No implementaion
    XPQTaskMgr& operator=( const XPQTaskMgr& ); // No implementaion

    //void *operator new( size_t len ) { return XAlloc( len ); }
    //void operator delete( void *pv ) { XFree( pv ); }

public:

    static XPQTaskMgr* GetPtr() 
    { 
        _ASSERTE(ms_pTaskMgr);
        return ms_pTaskMgr; 
    }

    XPQTaskMgr();
    ~XPQTaskMgr();

    HRESULT Create( HANDLE hStopEvent );
    void Destroy();

    void Pause () {};

    bool LoadTaskSettings();
    bool ResumeThreads();

    const CVPtrArray &GetTaskSchedule() const { return m_Tasks; }

    // Buffered task access
    XPQTask *AquireTask();
    void ReleaseTask(XPQTask *pTask);

    // Show stats for the manager, scheduler and workers
    void LogStats() const;

    // Show all tasks in progress more than some set ammount
    void LogTasksInProgress(DWORD dwMillis);

    SchedulerTaskThread *GetScheduler() const { return m_pScheduler; }

    DWORD GetWorkerBatchTLS() const { return m_dwWorkerBatchTLS; }

private:
    
    // Thread entry
    static unsigned __stdcall WorkerThreadProc( void* ); 
    static unsigned __stdcall SchedulerThreadProc( void* ); 

    // Thread handles
    WORD    m_wThreads;
    HANDLE* m_ahThreads;
    
    // Scheduling thread wrapper
    SchedulerTaskThread* m_pScheduler;

    // Array of worker thread wrappers
    WorkerTaskThread*    m_prgWorkers;
    DWORD                m_dwcWorkers;

    // Event signaling thread stop time
    HANDLE m_hStopEvent;

    // Main completion port used for task IO
    CompletionPort *m_pCP;

    // Definitions of tasks, these will be cloned into running tasks
    CVPtrArray           m_Tasks;

    // Buffer of free tasks, stack head pointer, there
    // is a lock to protect this data but we should not be contending
    // on that lock often as a cross thread release is very rare
    XPQTask*             m_prgTaskBuffer;
    DWORD                m_dwcTasks;
    XPQTask*             m_pTaskHead;
    XPQTask*             m_pTasksInProgress;
    CRITICAL_SECTION     m_csTaskBuffer;

    DWORD                m_dwWorkerBatchTLS;
};

extern XPQTaskMgr *gpTaskMgr;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\TaskThread.h ===
#pragma once

//
// Scheduler/Worker thread object
//
class TaskThread
{
protected:
    HANDLE        m_hStopEvent;
    HANDLE        m_hThread;
    UINT          m_uiThread;

    // Override in base classes to provide thread implementation
    virtual void RunInternal() = 0;
public:

    TaskThread();
    virtual ~TaskThread();

    HRESULT    Create(HANDLE hStopEvent, HANDLE hThread, UINT uiThread);

    // Handles correct lifetime management
    void       Run();
    void       Stop();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\user.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2002 Microsoft.  ALL RIGHTS RESERVED
/////////////////////////////////////////////////////////////////////////////
#pragma once

// Forward Declarations
class  XPQUserMgr;

//------------------------------------------------------------------------------
// Defines for GI properties in rich presence blob
//------------------------------------------------------------------------------ 
#define XONLINE_STAT_DATATYPE_MASK     0xF0000000
#define XONLINE_STAT_NULL              0x00000000
#define XONLINE_STAT_LONG              0x10000000
#define XONLINE_STAT_LONGLONG          0x20000000
#define XONLINE_STAT_DOUBLE            0x30000000
#define XONLINE_STAT_LPCWSTR           0x40000000
#define XONLINE_STAT_FLOAT             0x50000000
#define XONLINE_STAT_BINARY            0x60000000
#define XONLINE_STAT_DATETIME          0x70000000

#define XBOXID_FROM_SPI(spi)           (PUID_BASE_XBOX | (spi))
#define XENONID_FROM_SPI(spi)          (PUID_BASE_XENON |(spi))


struct XPQInviteData;
struct XPQNotificationData;
struct XPQBuddyData;
struct XPQMessageData;
struct XPQTeamData;
struct XPQTeamMemberData;
struct XPQTitleData;
struct XPQBlockData;

struct XPQInviteData
{

#define XPQ_INVITE_MAX_PENDING         0x00000004
#define XPQ_INVITE_INDEX_NEXT          0xffffffff

#define XPQ_INVITE_FLAGS_OWNER         0x00000001
#define XPQ_INVITE_FLAGS_PENDING       0x00000002
#define XPQ_INVITE_FLAGS_RECEIVED      0x00000008
#define XPQ_INVITE_FLAGS_JOINED        0x00000010

#define XPQ_INVITE_LIST_SIZE           16

    DWORD     dwFlags;
    DWORD     dwHostIndex;
    DWORD     dwTitleId;
    DWORD     dwExpire;

    ULONGLONG qwSessionId;

    // For pending invites the invited users hang off the
    // end of the invitation data item.
    WORD      wcUsers;
    WORD      wcPending;
    DWORD     rgdwUsers[XPQ_INVITE_LIST_SIZE];

    void Clear()
    {
        dwFlags      = 0;
        dwHostIndex  = 0;
        dwTitleId    = 0;
        qwSessionId  = 0;
        wcUsers      = 0;
        wcPending    = 0;
    }
};

// Persist existence of a notification for retrieval
// (Populated from QVals)
struct XPQNotificationData
{
    DWORD               dwFlags;
    DWORD               dwSequence; 
};

// Persist existence of message for retrieval, or read
// (Populated from QVals)
struct XPQMessageData
{

#define XPQ_MESSAGE_STATE_PENDING   0
#define XPQ_MESSAGE_STATE_READ      1

    BYTE                bState;
    DWORD               dwId;
    DWORD               dwData;
    DWORD               dwFlags;
    DWORD               dwSenderIndex;
    DWORD               dwSequence;
};

// Persist existence of dequeued buddy operation
// (Populated from Dequeue)
struct XPQBuddyData
{
    BYTE                bStatus;
    DWORD               dwBuddyIndex;
};

// (Populated from PeerSubscribe)
struct XPQPeerData
{
    ULONGLONG               dwPeerId;
};

// Persist team management info
//  (Populate with ManageTeam)
struct XPQTeamData
{

#define XPQ_TEAM_DATA_MAX_MEMBERS 32

    ULONGLONG           qwTeamId;
    DWORD               dwTitleId;
    DWORD               dwExpire;
    DWORD               dwcMembers;
    DWORD               rgdwMemberIndexes[XPQ_TEAM_DATA_MAX_MEMBERS];
    BYTE                rgbMemberStates[XPQ_TEAM_DATA_MAX_MEMBERS];

    // To get members enumerate all memberdata storage
    // blocks that have a matching team ID

    void Copy(XPQTeamData *pSrc)
    {
        qwTeamId          = pSrc->qwTeamId;
        dwTitleId         = pSrc->dwTitleId;
        dwcMembers        = pSrc->dwcMembers;

        for(DWORD i = 0; i < dwcMembers; ++i)
        {
            rgdwMemberIndexes[i] = pSrc->rgdwMemberIndexes[i];
            rgbMemberStates[i] = pSrc->rgbMemberStates[i];
        }
    }

    void Clear()
    {
        qwTeamId    = 0;
        dwTitleId   = 0;
        dwcMembers  = 0;
        ZeroMemory(rgdwMemberIndexes, sizeof(DWORD) * XPQ_TEAM_DATA_MAX_MEMBERS);
        ZeroMemory(rgbMemberStates, sizeof(BYTE) * XPQ_TEAM_DATA_MAX_MEMBERS);
    }

    HRESULT FindMemberInState(BYTE bMemberState, DWORD *pOutUserIndex) const
    {
        HRESULT hr = S_FALSE;

        *pOutUserIndex = 0;

        for(DWORD i = 0; i < dwcMembers; ++i)
        {
            if(bMemberState == rgbMemberStates[i])
            {
                *pOutUserIndex = rgdwMemberIndexes[i];
                hr = S_OK;
                break;
            }
        }
           
        return hr;
    }

    HRESULT AddMember(DWORD dwUserIndex, BYTE bState)
    {
        HRESULT hr = S_FALSE;

        if(dwcMembers < XPQ_TEAM_DATA_MAX_MEMBERS)
        {
            rgdwMemberIndexes[dwcMembers] = dwUserIndex;
            rgbMemberStates[dwcMembers] = bState;
            dwcMembers++;
            hr = S_OK;
        }

        return hr;
    }

    HRESULT RemoveMember(DWORD dwUserIndex)
    {
        HRESULT hr = S_FALSE;

        for(DWORD i = 0; i < dwcMembers; ++i)
        {
            if(dwUserIndex == rgdwMemberIndexes[i])
            {
                dwcMembers--;
                rgdwMemberIndexes[i] = rgdwMemberIndexes[dwcMembers];
                rgbMemberStates[i]   = rgbMemberStates[dwcMembers];
                hr = S_OK;
                break;
            }
        }

        return hr;
    }

    HRESULT UpdateMember(DWORD dwUserIndex, BYTE bState)
    {
        HRESULT hr = S_FALSE;

        for(DWORD i = 0; i < dwcMembers; ++i)
        {
            if(dwUserIndex == rgdwMemberIndexes[i])
            {
                rgbMemberStates[i] = bState;
                hr = S_OK;
                break;
            }
        }

        return hr;
    }
};

// Membership block for tracking joined teams
//  (Populate with ListTeams)
//  (Populate with ListUserTeams)
struct XPQTeamMemberData
{

// Privilege bits
#define XPQ_TEAM_MEMBER_PRIV_OWNER              0xffffffff
#define XPQ_TEAM_MEMBER_PRIV_OFFICER            0x7fffffff
#define XPQ_TEAM_MEMBER_PRIV_NORMAL             0x00000001
#define XPQ_TEAM_MEMBER_PRIV_NONE               0x00000000

// States for TeamMemberData
#define XPQ_TEAM_MEMBER_STATE_INIT              0
#define XPQ_TEAM_MEMBER_STATE_RECRUIT           1
#define XPQ_TEAM_MEMBER_STATE_DECLINE_RECRUIT   2
#define XPQ_TEAM_MEMBER_STATE_ACCEPT_RECRUIT    3
#define XPQ_TEAM_MEMBER_STATE_MEMBER            4
#define XPQ_TEAM_MEMBER_STATE_OFFICER           5
#define XPQ_TEAM_MEMBER_STATE_OWNER             6

    ULONGLONG qwTeamId;
    DWORD     dwTitleId;
    BYTE      bState;

    void Copy(XPQTeamMemberData *pSrc)
    {
        qwTeamId      = pSrc->qwTeamId;
        dwTitleId     = pSrc->dwTitleId;
        bState        = pSrc->bState;
    }

    void Clear()
    {
        qwTeamId    = 0;
        dwTitleId   = 0;
        bState      = 0;
    }

    DWORD GeneratePrivileges()
    {
        DWORD dwMemberPrivs = 0;
        switch(bState)
        {
            case XPQ_TEAM_MEMBER_STATE_INIT:
            case XPQ_TEAM_MEMBER_STATE_DECLINE_RECRUIT:
            case XPQ_TEAM_MEMBER_STATE_ACCEPT_RECRUIT:
                _ASSERTE(!"Cannot generate privs for transitional member states");
                break;
            case XPQ_TEAM_MEMBER_STATE_RECRUIT:
                break;
            case XPQ_TEAM_MEMBER_STATE_MEMBER:
                dwMemberPrivs = XPQ_TEAM_MEMBER_PRIV_NORMAL;
                break;
            case XPQ_TEAM_MEMBER_STATE_OFFICER:
                dwMemberPrivs = XPQ_TEAM_MEMBER_PRIV_OFFICER;
                break;
            case XPQ_TEAM_MEMBER_STATE_OWNER:
                dwMemberPrivs = XPQ_TEAM_MEMBER_PRIV_OWNER;
                break;
        }
    }
};


// Persist played titles 
//  (Populate with EnumTitles)
struct XPQTitleData
{
#define XPQ_TITLE_DATA_LIST_SIZE 16
    DWORD dwcTitles;
    DWORD rgTitles[16];
};

struct XPQBlockData
{
#define XPQ_BLOCK_DATA_LIST_SIZE 8
    DWORD dwcBlocks;
    DWORD rgdwBlocks[XPQ_BLOCK_DATA_LIST_SIZE];
};


struct XPQUserOnlineStorage
{
    Buffer<XPQInviteData>                   Invites;
    Buffer<XPQNotificationData>             Notifications;
    Buffer<XPQBuddyData>                    Buddies;
    Buffer<XPQPeerData>                     Peers;
	Buffer<XPQMessageData>                  Messages;
    Buffer<XPQTeamData>                     Teams;
    Buffer<XPQTeamMemberData>               TeamMembers;
    Buffer<XPQTitleData>                    Titles;
    Buffer<XPQBlockData>                    Blocks;
    Buffer<SGQVal>                          DeferredQVals;

    void Clear()
    {
        Invites.Clear();
        Notifications.Clear();
        Buddies.Clear();
		Peers.Clear();
        Messages.Clear();
        Teams.Clear();
        TeamMembers.Clear();
        Titles.Clear();
        Blocks.Clear();
        DeferredQVals.Clear();
    }

    void Compact()
    {
        Invites.Compact();
        Notifications.Compact();
        Buddies.Compact();
		Peers.Compact();
        Messages.Compact();
        Teams.Compact();
        TeamMembers.Compact();
        Titles.Compact();
        Blocks.Compact();
        DeferredQVals.Compact();
    }

    DWORD Wasted()
    {
        DWORD dwBytes = 0;

        dwBytes += Invites.GetAvailBytes()          - Invites.GetCountBytes();
        dwBytes += Notifications.GetAvailBytes()    - Notifications.GetCountBytes();
        dwBytes += Buddies.GetAvailBytes()          - Buddies.GetCountBytes();
        dwBytes += Peers.GetAvailBytes()            - Peers.GetCountBytes();
		dwBytes += Messages.GetAvailBytes()         - Messages.GetCountBytes();
        dwBytes += Teams.GetAvailBytes()            - Teams.GetCountBytes();
        dwBytes += TeamMembers.GetAvailBytes()      - TeamMembers.GetCountBytes();
        dwBytes += Titles.GetAvailBytes()           - Titles.GetCountBytes();
        dwBytes += Blocks.GetAvailBytes()           - Blocks.GetCountBytes();
        dwBytes += DeferredQVals.GetAvailBytes()    - DeferredQVals.GetCountBytes();

        return dwBytes;
    }
};


extern XPQUserMgr *gpUserMgr;

//------------------------------------------------------------------------------
// XPQ User
//
//------------------------------------------------------------------------------
class XPQUser
{
private:
    //------------------------------------------------------------------------------
    // Private 2-phase construction only accessible internally and to to user mgr
    //------------------------------------------------------------------------------
    friend class XPQUserMgr;    

    XPQUser();
    ~XPQUser();

    void Create( DWORD dwIndex );

    XPQUser( const XPQUser& );            // No implementaion
    XPQUser& operator=( const XPQUser& ); // No implementaion



    void *operator new(   size_t len ) { return XAlloc( len ); }
    void *operator new[]( size_t len ) { return XAlloc( len ); }
    void operator delete(   void *pv ) { XFree( pv ); }
    void operator delete[]( void*pv  ) { XFree( pv ); }

public:

    void        ClearOnlineState();

    //------------------------------------------------------------------------------
    // User property accessors
    //------------------------------------------------------------------------------
    ULONGLONG   UserId()        const { return gpUserMgr->BaseUserId() + m_dwIndex; }
    DWORD       UserIndex()     const { return m_dwIndex; }         
	ULONGLONG   XboxId()        const { 
		// TODO: this wont be unique across instances of tasksvr.  May want to use user Id.
		return IsXenonTitleId() ? XENONID_FROM_SPI(m_dwSpi) : XBOXID_FROM_SPI(m_dwSpi); 
	}

    DWORD       Spi()           const { return 0x00ffffff & m_dwSpi; }
    DWORD       SlotIndex()     const { return 0x000000ff & (m_dwSpi>>24); }

    const char* Name()          const { return m_szAcctName; }
    ULONGLONG   MatchId()       const { return m_qwMatchId; }
    DWORD       MatchExpire()   const { return m_dwMatchExpireTime; }
    DWORD       TitleId()       const { return m_dwTitleId; } 
    bool        IsXenonTitleId()const { return m_dwTitleId >= kBaseXenonTitleId; }
    DWORD       UserFlags()     const { return m_dwUserFlags; } 

    const XNADDR& XNAddr()      const { return m_xnaddr;    }     
    const XNKID& XNKId()        const { return m_xnkid;   }     
    const XNKEY& XNKey()        const { return m_xnkey;   }
	LARGE_INTEGER Nonce()	    const { LARGE_INTEGER nonce; nonce.QuadPart = gpUserMgr->BaseUserId() + m_dwIndex; return nonce; }

    BYTE*       TitleData()           { return &m_rgbTitleData[0]; }
    WORD        TitleDataLen()  const { return m_wcbTitleData; }

    BYTE*       Nickname()            { return &m_rgbTitleData[MAX_TITLE_STATE_BYTES]; }
    WORD        NicknameLen()   const { return m_wNickname; }

    DWORD       BuddyListVer()  const { return m_dwBuddyListVer; }
    DWORD       BlockListVer()  const { return m_dwBlockListVer; }

    WORD        SetLanguageId(WORD wLanguageId);
    DWORD       SetUserFlags(DWORD dwUserFlags);

    DWORD       SetBuddyListVersion(DWORD dwVersion);  
    DWORD       SetBlockListVersion(DWORD dwVersion);
    DWORD       SetState(DWORD dwState);
    DWORD       SetTitleId(DWORD dwTitleId);
    ULONGLONG   SetMatchId(ULONGLONG qwMatchId);
    DWORD       SetMatchExpire(DWORD dwMatchExpire);
    DWORD       SetSpiInfo(DWORD dwSpi, DWORD dwSlotIndex);

#ifdef _DEBUG
    bool        HasValidSpi()
    {
        XPQSlotInfo slot;
        _ASSERTE(0xffffffff != m_dwSpi);
        _ASSERTE(SUCCEEDED(gpConnMgr->GetSlotInfo(m_dwSpi, slot)));
        _ASSERTE(slot.dwSPI == Spi());
        _ASSERTE(INVALID_SPI == slot.dwNextSPI);
        _ASSERTE(slot.rgqwUserIDs[SlotIndex()] == UserId());
        return true;
    }
#endif
    bool        HasValidSpi() const { return 0xffffffff != m_dwSpi; }


    //------------------------------------------------------------------------------
    // State accessors
    //------------------------------------------------------------------------------
    bool    IsOnline()         const { return 0 != (m_dwState & P_STATE_MASK_ONLINE); }
    bool    IsCloaked()        const { return 0 != (m_dwState & P_STATE_MASK_CLOAKED); }
    bool    IsVoiceEnabled()   const { return 0 != (m_dwState & P_STATE_MASK_VOICE); }
    bool    IsPlaying()        const { return 0 != (m_dwState & P_STATE_MASK_PLAYING); }
    bool    IsJoinable()       const { return 0 != (m_dwState & P_STATE_MASK_JOINABLE); }
    BYTE    GuestCount()       const { return (BYTE)((m_dwState & P_STATE_MASK_GUESTS) >> 5); }
    DWORD   State()            const { return m_dwState; }

    //------------------------------------------------------------------------------
    // User online local storage access
    //------------------------------------------------------------------------------
    HRESULT GetRandomStorageItem(DWORD dwBucketId, const void **ppOutStorage) const;
    void    ClearStorageItems();
    HRESULT AttachStorage(XPQUserOnlineStorage *pStorage);
    HRESULT DetachStorage(XPQUserOnlineStorage **ppOutStorage);
    XPQUserOnlineStorage *GetOnlineStorage() const;
    HRESULT CleanupStorage();
 
    //------------------------------------------------------------------------------
    // Peer operations
    //------------------------------------------------------------------------------
    DWORD   CountPeers() const;
	HRESULT UpdatePeers(const XPQUser**  rgpPeers, ULONGLONG* rgqwPeers, WORD &wCount, DWORD &dwFlags);
 
    //------------------------------------------------------------------------------
    // Buddy operations
    //------------------------------------------------------------------------------
    DWORD   CountBuddies() const;
    bool    IsBuddyListFull() const;
    HRESULT AddBuddy(const XPQUser *pBuddy, BYTE bStatus);
    HRESULT RemoveBuddy(const XPQUser *pBuddy);
    HRESULT CleanupBuddyData(const XPQUser *pBuddy);
    HRESULT GetFirstBuddyOperation(BYTE bStatus, const XPQBuddyData **ppOutBuddyOp);

    //------------------------------------------------------------------------------
    // Block list operations
    //------------------------------------------------------------------------------
    HRESULT  AddBlock(const XPQUser *pUser);
    HRESULT  GetBlocks(XPQBlockData **ppOutBlocks);
    HRESULT  RemoveBlock(const XPQUser *pUser);
    HRESULT  RemoveAllBlocks();

    //------------------------------------------------------------------------------
    // Inivitation operations
    //------------------------------------------------------------------------------
    HRESULT  GetPendingInvite(const XPQInviteData **ppOutInviteData) const;
    HRESULT  GetReceivedInvite(const XPQUser *pHost, const XPQInviteData **ppOutInviteData) const;

    HRESULT  AddPendingInvite(XPQInviteData **ppOutInviteData, const XPQUser **rgpUsers, WORD wcUsers);
    HRESULT  AddReceivedInvite(XPQUser *pHost, DWORD dwTitleId, ULONGLONG qwSessionId);
    HRESULT  RemoveReceivedInvite(const XPQUser *pFromHost);

    void     ClearAllInvites();
    void     ClearPendingInvite();

    ULONGLONG GenerateSessionId();

    //------------------------------------------------------------------------------
    // QVal processing
    //------------------------------------------------------------------------------
    bool          IsQueued( P_QUEUE_TYPES eType ) const { return (0L != (m_dwCurQflags & QFLAG_MASK( eType ))); }
    HRESULT       CollapseNotificationData();
    HRESULT       UpdateNotificationData(DWORD dwFlags, DWORD dwSequence);
    P_QUEUE_TYPES GetNextQueue() const;
    DWORD         LastNewMsgQValSeq()             const { return m_dwLastNewMsgQValSeq; }
    void          SetLastNewMsgQValSeq(DWORD dwSeq)     { m_dwLastNewMsgQValSeq = dwSeq; }
    DWORD         LastDelMsgQValSeq()             const { return m_dwLastDelMsgQValSeq; }
    void          SetLastDelMsgQValSeq(DWORD dwSeq)     { m_dwLastDelMsgQValSeq = dwSeq; }

    // Called by owner of user object when an explicit lock is owned
    HRESULT       ProcessQVal(const SGQVal &qval);

    // Called by the scheduler thread to serialize the qvals into the user record
    // at a point when it owns the lock
    HRESULT       DeferQVal(const SGQVal &qval);
    HRESULT       ProcessDeferredQVals();

    //------------------------------------------------------------------------------
    // Message handling
    //------------------------------------------------------------------------------
    HRESULT     ClearMessages();
    HRESULT     RemoveMessage(DWORD dwId);
    HRESULT     RemovePendingMessage( DWORD dwId );
    HRESULT     RemoveReadMessage( DWORD dwId );
    HRESULT     ProcessMessage(
                    DWORD dwSequence,
                    DWORD dwMessageId,
                    DWORD dwMessageData,
                    DWORD dwMessageFlags,
                    DWORD dwSenderIndex,
                    DWORD dwSenderTitleId,
                    ULONGLONG qwContextId,
                    const BYTE *pbDetails);
    HRESULT     ProcessSummary(const Q_MESSAGE_SUMMARY *pSummary);
    HRESULT     ProcessSummary2(const Q_MESSAGE_SUMMARY_2 *pSummary);
    HRESULT     ProcessDetails(const Q_MESSAGE_SUMMARY *pSummary, const BYTE *pbDetails);
    DWORD       GetNextReadMessageId();
    DWORD       GetNextUnreadMessageId();
    HRESULT     GetFirstMessage(BYTE bType, const XPQMessageData **ppOutMessageData);

    //------------------------------------------------------------------------------
    // Stats
    //------------------------------------------------------------------------------    
    DWORD GetLastInuseTime() const
    {
        return m_dwInuseTime;
    }

    DWORD GetTouchCount() const
    {
        return m_dwTouched;
    }

    //------------------------------------------------------------------------------
    // Team storage access
    //------------------------------------------------------------------------------ 
    DWORD       CountTeams(DWORD dwTitleId = 0) const;
    HRESULT     AddTeam(
                    ULONGLONG qwTeamId, 
                    DWORD dwTitleId,
                    XPQTeamData **ppOutTeamData);
    HRESULT     GetTeam(
                    ULONGLONG qwTeamId, 
                    XPQTeamData **ppOutTeamData) const;

    HRESULT     GetTeamIds(ULONGLONG *prgTeamIds, /*INOUT*/ DWORD *pdwcTeamIds);

    HRESULT     RemoveTeamData(ULONGLONG qwTeamId, DWORD dwTitleId);

    HRESULT     AddTeamMember(
                    ULONGLONG qwTeamId, 
                    DWORD dwTitleId,
                    BYTE bMemberState,
                    XPQTeamMemberData **ppOutMemberData);
    HRESULT     GetTeamMember(
                    ULONGLONG qwTeamId,
                    XPQTeamMemberData **ppOutMemberData) const;
    HRESULT     RemoveTeamMember(
                    ULONGLONG qwTeamId);

    HRESULT     GetTeamRecruitment(XPQTeamMemberData **ppOutMemberData) const;

    HRESULT     GetTeamDataForMember(
                    ULONGLONG qwMemberId,
                    XPQTeamData **ppOutTeamData,
                    XPQTeamMemberData **ppOutMemberData) const;
    
    // These team operations are for teams in that users online title ID
    HRESULT     GetOrCreateTeamData(
                    ULONGLONG qwTeamId, 
                    DWORD dwTitleId,
                    XPQTeamData **ppOutTeamData);
    HRESULT     GetOrCreateTeamMemberData(
                    ULONGLONG qwTeamId, 
                    DWORD dwTitleId,
                    BYTE bMemberState,
                    XPQTeamMemberData **ppOutTeamData);

    //------------------------------------------------------------------------------
    // Title storage access
    //------------------------------------------------------------------------------ 
    DWORD       CountTitles() const;
    DWORD       GetOfflineTitle() const;
    DWORD       GetTitle(DWORD dwIndex) const;

    //------------------------------------------------------------------------------
    // Constants
    //------------------------------------------------------------------------------
    enum { 
        kMaxAcctNameSize     = 16, // MAX_ACCTNAME_BYTES
        kBaseXboxTitleId     = 0x11000000,
        kBaseXenonTitleId    = 0x22000000,
        kBaseTitleId         = kBaseXboxTitleId,
        kCountXboxTitles     = 1024,
        kCountXenonTitles    = 16,
        kCountGameModes      = 4,
        kCountContexts       = 4,
        kCountContextValues  = 4,
        kCountProperties     = 4,
    };
    
    //------------------------------------------------------------------------------
    // Per user pool flags
    //------------------------------------------------------------------------------
    bool    IsLocked()                       const { return (0 != (m_dwPoolFlags & USERPOOL_LOCK_MASK)); }
    DWORD   GetPoolFlags()                   const { return m_dwPoolFlags; }
    bool    HasPoolFlag(DWORD dwPoolFlags)   const { return (0 != (m_dwPoolFlags & dwPoolFlags)); }
    void    SetPoolFlags(DWORD dwAddFlags, DWORD dwRemoveFlags = 0);

    //------------------------------------------------------------------------------
    // Xbox1 presence state
    //------------------------------------------------------------------------------
    WORD    SetTitleData(BYTE* abBuf, WORD wBufLen);
    WORD    SetTitleDataLen(WORD wBufLen);
    WORD    SetNickname(BYTE* abBuf, WORD wBufLen);

    //------------------------------------------------------------------------------
    // Xenon rich presence accessors
    //------------------------------------------------------------------------------
    HRESULT SetGameMode(DWORD dwGameMode);

    void    LogoffCleanup();
private:
    
    // Pool pointer
    //------------------------------------------------------------------------------
    XPQUser *m_pNext;
    XPQUser *m_pPrev;

    // Index of this user in the global index (could be removed and calculated via
    // pointer offset)
    //------------------------------------------------------------------------------
    DWORD m_dwIndex;  

    // SG Session Id (spi)
    //------------------------------------------------------------------------------
    DWORD        m_dwSpi;

    // User Account Name
    //------------------------------------------------------------------------------
    char m_szAcctName[ kMaxAcctNameSize ]; // Includes Null Terminator

    // Online state flags 
    //------------------------------------------------------------------------------
    DWORD m_dwState;

    // SG info user XUID flags
    //------------------------------------------------------------------------------
    DWORD m_dwUserFlags;

    // User Console Information
    //------------------------------------------------------------------------------
	XNADDR m_xnaddr;
	XNKID  m_xnkid;
	XNKEY  m_xnkey;

    // Title and Match Stuff, when we join a match we set the expire time
    // if we hit that time we zero our session ID
    //------------------------------------------------------------------------------
    DWORD     m_dwTitleId;
    ULONGLONG m_qwMatchId;
    DWORD     m_dwMatchExpireTime;
    WORD      m_wNickname;
    WORD      m_wcbTitleData;

    // Server list version
    //------------------------------------------------------------------------------
    DWORD m_dwBuddyListVer;
    DWORD m_dwBlockListVer;
  
    // QVal Stuff
    //------------------------------------------------------------------------------
    DWORD m_dwLastQValSeq;
    DWORD m_dwCurQflags;
    DWORD m_dwTotalNewInvites;
    DWORD m_dwLastNewMsgQValSeq;
    DWORD m_dwLastDelMsgQValSeq;

    // Stats
    //------------------------------------------------------------------------------
    DWORD m_dwInuseTime;        // last time in ticks placed a queue (online/offline)
    DWORD m_dwTouched;          // total times touched in the queue
    DWORD m_dwPoolFlags;        // bits marked for pools this user is member

    // Titlestuff/Richpresence state bytes
    //------------------------------------------------------------------------------
    BYTE  m_rgbTitleData[MAX_TITLE_DATA_BYTES];


    // User local storage, holding online user state, storage
    // flags holds a bit per storage item based on the type
    // ordinal.
    //------------------------------------------------------------------------------    
    XPQUserOnlineStorage* m_pStorage; 

    // Private lock accessors
    //------------------------------------------------------------------------------
    void Lock()
    {
        m_dwPoolFlags |= USERPOOL_LOCK_MASK;
        m_dwInuseTime = GetTickCount();
        m_dwTouched++;
    }
    void Unlock() 
    {
        m_dwPoolFlags &= ~USERPOOL_LOCK_MASK;
        m_dwInuseTime = GetTickCount() - m_dwInuseTime;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\Worker.h ===
#pragma once

class WorkerTaskThread : public TaskThread
{
    SchedulerTaskThread*  m_pScheduler;
    CompletionPort*       m_pCP;
    RunningAverageCounter m_HandleIoAvg;
    Counter               m_Completions;

public:

    WorkerTaskThread();
    ~WorkerTaskThread();

    void           SetScheduler(SchedulerTaskThread *pScheduler);
    void           SetCompletionPort(CompletionPort *pCP);
    
    HRESULT        PostTask(XPQTask *pTask);
    HRESULT        PostCompletedTask(XPQTask *pTask);

    void           LogStats() const;

protected:
    void           RunInternal();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\UserMgr.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2002 Microsoft.  ALL RIGHTS RESERVED
/////////////////////////////////////////////////////////////////////////////
#pragma once

#define USERMGR_STATE_QUEUE_SIZE        32 * 1024
#define USERMGR_STATE_TIMEOUT_DEFAULT   1000 * 60 * 5

//------------------------------------------------------------------------------
// Pool of users and definitions for marking users in various pools.
//
// Eventually the pool can be bucketed and the buckets can grow and shrink
// over time since we have a fixed size of users. The pool size would not change.
//------------------------------------------------------------------------------

#define USERPOOL_PENDING_INVITE_ID      0
#define USERPOOL_RECEIVED_INVITE_ID     1
#define USERPOOL_NOTIFICATION_ID        2
#define USERPOOL_PENDING_MSG_ID         3
#define USERPOOL_READ_MSG_ID            4
#define USERPOOL_PENDING_BUDDY_ID       5
#define USERPOOL_RECEIVED_BUDDY_ID      6
#define USERPOOL_FULL_BUDDY_ID          7
#define USERPOOL_TEAM_ID                8
#define USERPOOL_TEAM_MEMBER_ID         9 
#define USERPOOL_TEAM_RECRUIT_ID        10 
#define USERPOOL_TITLE_DATA_ID          11 
#define USERPOOL_BLOCK_DATA_ID          12 
#define USERPOOL_MAX_ID                 13 

#define USERPOOL_PENDING_INVITE_MASK    (1 << USERPOOL_PENDING_INVITE_ID)
#define USERPOOL_RECEIVED_INVITE_MASK   (1 << USERPOOL_RECEIVED_INVITE_ID)
#define USERPOOL_NOTIFICATION_MASK      (1 << USERPOOL_NOTIFICATION_ID)
#define USERPOOL_PENDING_MSG_MASK       (1 << USERPOOL_PENDING_MSG_ID)
#define USERPOOL_READ_MSG_MASK          (1 << USERPOOL_READ_MSG_ID)
#define USERPOOL_PENDING_BUDDY_MASK     (1 << USERPOOL_PENDING_BUDDY_ID)
#define USERPOOL_RECEIVED_BUDDY_MASK    (1 << USERPOOL_RECEIVED_BUDDY_ID)
#define USERPOOL_FULL_BUDDY_MASK        (1 << USERPOOL_FULL_BUDDY_ID)
#define USERPOOL_TEAM_MASK              (1 << USERPOOL_TEAM_ID)
#define USERPOOL_TEAM_MEMBER_MASK       (1 << USERPOOL_TEAM_MEMBER_ID)
#define USERPOOL_TEAM_RECRUIT_MASK      (1 << USERPOOL_TEAM_RECRUIT_ID)
#define USERPOOL_TITLE_DATA_MASK        (1 << USERPOOL_TITLE_DATA_ID)
#define USERPOOL_BLOCK_DATA_MASK        (1 << USERPOOL_BLOCK_DATA_ID)


#define USERPOOL_INFO_FLAGS_ONLINE              0x00010000
#define USERPOOL_INFO_FLAGS_OFFLINE             0x00020000
#define USERPOOL_INFO_FLAGS_OFFLINE_FOR_ALIVE   0x00040000

#define USERPOOL_LOCK_MASK              0x80000000
#define USERPOOL_INFO_MASK              0x00ff0000
#define USERPOOL_INFO_STATE_MASK        0x0000ffff

#define USERTRACES_MAX                  8

#define USERTRACE0(uid, fmt) if(gdwcUserTraces > 0) XPQUserMgr::UserTrace((uid), "[%s(%d)] " fmt "\n", __FILE__, __LINE__) 
#define USERTRACE1(uid, fmt, a1) if(gdwcUserTraces > 0) XPQUserMgr::UserTrace((uid), "[%s(%d)] " fmt "\n", __FILE__ , __LINE__ , a1) 
#define USERTRACE2(uid, fmt, a1, a2) if(gdwcUserTraces > 0) XPQUserMgr::UserTrace((uid), "[%s(%d)] " fmt "\n", __FILE__, __LINE__, a1, a2) 
#define USERTRACE3(uid, fmt, a1, a2, a3) if(gdwcUserTraces > 0) XPQUserMgr::UserTrace((uid), "[%s(%d)] " fmt "\n", __FILE__, __LINE__, a1, a2, a3) 
#define USERTRACE4(uid, fmt, a1, a2, a3, a4) if(gdwcUserTraces > 0) XPQUserMgr::UserTrace((uid), "[%s(%d)] " fmt  "\n", __FILE__, __LINE__, a1, a2, a3, a4) 
#define USERTRACE5(uid, fmt, a1, a2, a3, a4, a5) if(gdwcUserTraces > 0) XPQUserMgr::UserTrace((uid), "[%s(%d)] " fmt  "\n", __FILE__, __LINE__, a1, a2, a3, a4, a5) 
#define USERTRACE6(uid, fmt, a1, a2, a3, a4, a5, a6) if(gdwcUserTraces > 0) XPQUserMgr::UserTrace((uid), "[%s(%d)] " fmt  "\n", __FILE__, __LINE__, a1, a2, a3, a4, a5, a6) 
#define USERTRACE7(uid, fmt, a1, a2, a3, a4, a5, a6, a7) if(gdwcUserTraces > 0) XPQUserMgr::UserTrace((uid), "[%s(%d)] " fmt  "\n", __FILE__, __LINE__, a1, a2, a3, a4, a5, a6, a7) 
#define USERTRACE8(uid, fmt, a1, a2, a3, a4, a5, a6, a7, a8) if(gdwcUserTraces > 0) XPQUserMgr::UserTrace((uid), "[%s(%d)] " fmt  "\n", __FILE__, __LINE__, a1, a2, a3, a4, a5, a6, a7, a8) 


class XPQUser;

//------------------------------------------------------------------------------
// XPQ User Manager
//
//  Creates a growable set of Users, and provides
//  methods to look up or queue them for a variety 
//  of purposes
//------------------------------------------------------------------------------
class XPQUserMgr
{
public:
    static XPQUserMgr* GetPtr() 
    { 
        _ASSERTE(ms_pUserMgr);
        return ms_pUserMgr; 
    }

    XPQUserMgr();
    ~XPQUserMgr();

    HRESULT Create( DWORD dwClientID, 
                    ULONGLONG qwBaseUserId, 
                    DWORD dwUserCount, 
                    HANDLE hStopEvent );
    void Destroy();

    DWORD TotalUserCount() const    { return m_dwUserCount; }
    DWORD ActiveUserCount() const   { return m_dwActiveUsers; }
    DWORD InactiveUserCount() const { return m_dwInactiveUsers; }
    WORD  BuddyCount() const        { return m_wNumBuddies; }
    DWORD MinQSize() const          { return m_dwMinQSize; }

    void        ValidateUserIndex(DWORD dwI)        const { _ASSERTE(dwI < m_dwUserCount); }
    XPQUser*    UserPtrFromIndex( DWORD dwI )       const;
    XPQUser*    UserPtrFromId( ULONGLONG qwUserId ) const;
    DWORD       UserIndexFromId( ULONGLONG qwUserId ) const { return (DWORD)(qwUserId - m_qwBaseUserId); }
    ULONGLONG   BaseUserId()                        const { return m_qwBaseUserId; }
    ULONGLONG   BaseXboxId()                        const { return m_qwBaseXboxId; }

    //------------------------------------------------------------------------------
    // Pool accessors
    //------------------------------------------------------------------------------
    HRESULT     AquireUser(DWORD dwPoolFlags, XPQTaskResourceBlock &Resources, TaskResourceMark &Aquired);
    HRESULT     ReleaseUser(XPQUser *pUser, DWORD dwPoolFlags);
    HRESULT     NotifyState(const XPQUser *pUser, DWORD dwBucketId);

    // Pool counts
    DWORD       Inuse()     const { return m_dwcInuse; }
    DWORD       MaxInuse()  const { return m_dwcMaxInuse; }
    DWORD       Online()    const { return m_dwcOnline; }
    DWORD       Offline()   const { return m_dwcOffline; }
    DWORD       Xenon()     const { return m_dwcXenonUsers; }
    DWORD       MaxActive() const { return m_dwActiveUsers; }

    // This can be called from dequeue on a user who is locked by 
    // passing the user pointer otherwise it should only be called
    // from ProcessPendingQVals()
    HRESULT     HandleQVal(SGQVal &qval, XPQUser *pUser, bool bFromDequeue);

    // Show statistics in management
    void        LogStats() const;

    // Control how long a virtual session lasts
    DWORD       GenerateSessionExpiration();
    
    // Control how long certain state data may persist for an online user
    DWORD       GenerateStateExpiration(DWORD dwBucketId);
    DWORD       SetStateExpirationTicks(DWORD dwBucketId, DWORD dwMaxTicks);

    // Set the allowed % of xenon users logged in
    void        SetXenonPercentage(DWORD dwPercent);

    // Set the expected % of times the state field will be unchanged on update
    void        SetStateBitsUnchangedPercentage(DWORD dwPercent);
	DWORD		GetStateBitsUnchangedPercentage();

    // Set logoff behavior for users who receive a server error
    void        SetKickOnError(bool bKickOnError) { m_bKickOnError = bKickOnError; }
    bool        KickOnError() const { return m_bKickOnError; }

    //------------------------------------------------------------------------------
    // User tracing
    //------------------------------------------------------------------------------
    static bool AddUserTrace(XPQUser *pUser);
    static bool RemoveUserTrace(DWORD dwTraceIndex); 
    static void ShowUserTraces();
    static void UserTrace(QWORD qwUserId, const char *pszFormat, ... );

private:

    // pointer to singleton instance.
    static XPQUserMgr* ms_pUserMgr;


    XPQUserMgr( const XPQUserMgr& );            // No implementaion
    XPQUserMgr& operator=( const XPQUserMgr& ); // No implementaion

    // Get a plain online user, this will spool online users
    // until a valid online user is found.
    HRESULT AllocateOnlineUser(
                    DWORD dwPoolFlags,
                    XPQTaskResourceBlock &Resources,
                    TaskResourceMark &Aquired);
    
    // Search all buckets marked in pool flags, user indexes
    // will be pulled off the state queues until a desired
    // user is found.
    HRESULT AllocateFromBucket(
                    DWORD dwBucketId, 
                    DWORD dwPoolFlags, 
                    XPQTaskResourceBlock &Resources, 
                    TaskResourceMark &Aquired);

    void    AddUserToResourceBlock(
                    DWORD dwPoolFlags,
                    XPQUser *pUser, 
                    XPQUser **ppHead, 
                    XPQUser **ppTail, 
                    XPQTaskResourceBlock &Resources, 
                    TaskResourceMark &Aquired);

    void    LinkUser(
                    XPQUser *pUser,
                    XPQUser **ppHead,
                    XPQUser **ppTail);

    void    UnlinkUser(
                    XPQUser *pUser,
                    XPQUser **ppHead,
                    XPQUser **ppTail);

    HRESULT ProcessMessage(
                    DWORD dwUserIndex,
                    DWORD dwSequence,
                    DWORD dwId,
                    DWORD dwData);
    HRESULT RemoveMessages(
                    DWORD dwUserIndex,
                    DWORD dwId1,
                    DWORD dwId2,
                    DWORD dwId3);
    HRESULT UpdateNotificationData(
                    DWORD dwUserIndex,
                    DWORD dwFlags,
                    DWORD dwSequence);


    //void *operator new(   size_t len ) { return XAlloc( len ); }
    //void *operator new[]( size_t len ) { return XAlloc( len ); }
    //void operator delete(   void *pv ) { XFree( pv ); }
    //void operator delete[]( void*pv  ) { XFree( pv ); }

    DWORD      m_dwActiveUsers;   // Target number of concurrently active (logged in users)
    DWORD      m_dwInactiveUsers; // Target number of logged out users 
    WORD       m_wNumBuddies;     // Target number of Buddies per user
    DWORD      m_dwMinQSize;      // Mimimum User Q Size
    bool       m_bKickOnError;    // Kick the user on a server error

    // Raw user data
    XPQUser*   m_prgUsers;
    ULONGLONG  m_qwBaseUserId;
    ULONGLONG  m_qwBaseXboxId;
    DWORD      m_dwUserCount;

    // User pool and head markers
    XPQUser*   m_pOnline;
    XPQUser*   m_pOnlineTail;
    XPQUser*   m_pOffline;
    XPQUser*   m_pOfflineTail;
    DWORD      m_dwcOnline;
	DWORD      m_dwcOffline;
    DWORD      m_dwcInuse;
    DWORD      m_dwcMaxInuse;
    DWORD      m_dwcXenonUsers;
    DWORD      m_dwcXboxUsers;
	DWORD      m_dwStateBitsUnchangedPct;
	DWORD      m_dwXenonUsersPct;

    DWORD      m_dwMinSessionMillis;
    DWORD      m_dwMaxSessionMillis;

    XPQUser*   m_pLoggedOffUser;

    // One hash buffer for each queryable pool bucket type
    LockFreeFifo<DWORD> m_rgStateQueues[USERPOOL_MAX_ID]; 
    DWORD      m_rgdwStateExpirations[USERPOOL_MAX_ID];
};

extern XPQUserMgr *gpUserMgr;
extern const char *rgszBucketNames[USERPOOL_MAX_ID];
extern DWORD gdwcUserTraces;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\XPQStress.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2002 Microsoft.  ALL RIGHTS RESERVED
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

MGMT_DefineLoggingCategory( Log );
MGMT_DefineLoggingCategory( Debug );
MGMT_DefineLoggingCategory( QFlag );
MGMT_DefineLoggingCategory( Event );

///////////////////////////////////////////////////////////
// XPQ Stress
///////////////////////////////////////////////////////////

// Pointer to singleton instance
XPQStress* XPQStress::ms_pStress = NULL;

XPQStress::XPQStress()
:
    m_hStopEvent( INVALID_HANDLE_VALUE )
{
    if(ms_pStress == NULL)
    {
        ms_pStress = this;
    }
}

XPQStress::~XPQStress()
{
    Destroy();
}

HRESULT XPQStress::Create()
{
    HRESULT hr = S_OK;

    try
    {
        Console &console = Console::GetInstance();
        console.Initialize();
        console.ParseFile("XPQStress.ini");
    }
    catch(Exception &ex)
    {
        // It's okay to continue after config file parse failed in some cases
        // let the app report bad settings
        printf("Console::ParseFile failed: %s (Code: %d, HResult: %X) @ %s(%d)\n", 
                ex.GetText(), ex.GetCode(), ex.GetHRESULT(), ex.GetFile(), ex.GetLine());
    }



    // Create event that signals everything to stop (Manual reset, not signalled)
    TRACE0( Debug, L_NORMAL, "XPQStress::Create() - create stop event" );
    m_hStopEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    _ASSERTE( NULL != m_hStopEvent );
    if( NULL == m_hStopEvent )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        TRACE1( Debug, L_ERROR, "XPQStress::Create() - create stop event failed, hr: 0x%08x", hr);
        Destroy();
    }

    return hr;
}


void XPQStress::Destroy()
{
    TRACE0( Debug, L_NORMAL, "XPQStress::Destroy()" );

    if(INVALID_HANDLE_VALUE != m_hStopEvent )
    {
        AllStop();
        CloseHandle(m_hStopEvent);
        m_hStopEvent = NULL;
        Console::ReleaseInstance();
    }
}

void   XPQStress::AllStop()
{ 
    TRACE0( Debug, L_NORMAL, "XPQStress::AllStop() - set stop event" ); 
    SetEvent( m_hStopEvent ); 
}

bool   XPQStress::IsStopping()  
{ 
    return( WAIT_OBJECT_0 == WaitForSingleObject( m_hStopEvent, 0L ) ); 
}


HANDLE XPQStress::GetStopEvent() const
{ 
    return m_hStopEvent; 
}

///////////////////////////////////////
// Log Error Text
//
void XPQStress::LogErrorText(
        const char* pszText,
        XPQUser*    pUser,
        XPQTask*    pTask)
{
    _ASSERTE( NULL != pUser );
    _ASSERTE( NULL != pTask );
    INF3( Event, "Error[GENERIC]: Text: %s, User: %s, Task: %s",
             pszText, 
             pUser->Name(), 
             pTask->Name() );
}

///////////////////////////////////////
// Log Memory Error
//
void XPQStress::LogMemoryError(
    const char* pszContext,
    const char* pszObject,
    XPQUser*    pUser,
    XPQTask*    pTask)
{
    _ASSERTE( NULL != pUser );
    _ASSERTE( NULL != pTask );
    INF4( Event, "Error[MEMORY]: Context: %s, Object: %s, User: %s, Task: %s",
             pszContext, 
             pszObject, 
             pUser->Name(), 
             pTask->Name() );
}

///////////////////////////////////////
// Log HR
//
void XPQStress::LogHR(
    const char* pszContext,
    XPQUser*    pUser,
    XPQTask*    pTask,
    HRESULT     hr )
{
    _ASSERTE( NULL != pUser );
    _ASSERTE( NULL != pTask );
    INF4( Event, "Error[HR]: Context: %s, HR: %X, User: %s, Task: %s",
             pszContext, 
             hr,
             pUser->Name(), 
             pTask->Name() );
}

///////////////////////////////////////
// Log Tcp Error
//
void XPQStress::LogTcpError(
    const char*          pszOperation,
    TCPClientConnection* pFDClient,
    XPQUser*             pUser,
    XPQTask*             pTask,
    int                  iLastError )
{
    _ASSERTE( NULL != pUser );
    _ASSERTE( NULL != pTask );
    INF5( Event, "Error[TCP]: Operation: %s, HR: %X, ClientPort: %u, User: %s, Task: %s",
             pszOperation, 
             HRESULT_FROM_WIN32(iLastError), 
             ntohs( pFDClient->GetClientPort() ), 
             pUser->Name(), 
             pTask->Name() );
}

///////////////////////////////////////
// Log Http Error
//
void XPQStress::LogHttpError(
    TCPClientConnection* pFDClient,
    XPQUser*             pUser,
    XPQTask*             pTask,
    DWORD                dwXErr )
{
    _ASSERTE( NULL != pUser );
    _ASSERTE( NULL != pTask );
    if( 0 != dwXErr )
    {
        INF5( Event, "Error[HTTP]: HR: %X, ClientPort: %u, User: %s, Puid: %I64x, Task: %s",
                 dwXErr, 
                 ntohs( pFDClient->GetClientPort() ), 
                 pUser->Name(), 
                 pUser->UserId(), 
                 pTask->Name() );
    }
    else
    {
       INF4( Event, "Error[HTTP]: HR: 0, ClientPort: %u, User: %s, Puid: %I64x, Task: %s",
                ntohs( pFDClient->GetClientPort() ), 
                pUser->Name(), 
                pUser->UserId(), 
                pTask->Name());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\User.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2002 Microsoft.  ALL RIGHTS RESERVED
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

///////////////////////////////////////////////////////////
// XPQ User
///////////////////////////////////////////////////////////
//

MGMT_DefineLoggingCategory( User );


struct Base32
{
    BYTE DecTab[256];
    BYTE EncTab[32];

    Base32()
    {
        int count = 0;
        for(BYTE i = (BYTE)'a'; i <= 'z'; i++)
        {
            DecTab[i] = (BYTE)count;
            EncTab[count++] = (BYTE)i;
        }
        for(BYTE i = (BYTE)'0'; i < '6'; ++i)
        {
            DecTab[i] = (BYTE)count;
            EncTab[count++] = (BYTE)i;
        }
    }
};


// Helper to encode the user name from the PUID
void CreateUserName(char *pszUserName, const char *pszPrefix, ULONGLONG qwUserID)
{
    static Base32 __Base32;

    DWORD tabIndex = 0;
    DWORD i = 0;
    long shift = 0;
    ULONGLONG cursor = 0;

    // Copy in the prefix
    pszUserName[i++] = pszPrefix[0];
    pszUserName[i++] = pszPrefix[1];

    // Accumulate the bits in reverse order
    for(shift = 0; shift < 56; shift += 8)
    {
        cursor |= (qwUserID >> shift) & 0xff;
        cursor <<= 8;
    }

    // Write 5 bit chunks from the cursor
    for(shift = 59; shift > 0; shift -= 5)
    {
        DWORD tabIndex = (DWORD)((cursor >> shift) & 0x1f);
        _ASSERTE(tabIndex < 32);
        pszUserName[i++] = __Base32.EncTab[tabIndex];
    }

    // Write remainder
    tabIndex = (DWORD)(cursor & 0xf);
    pszUserName[i++] = __Base32.EncTab[tabIndex];

    // Terminate buffer
    pszUserName[i++] =  '\0';
}

//------------------------------------------------------------------------------
//
// User implementation
//
//------------------------------------------------------------------------------
XPQUser::XPQUser( )
:
    m_pNext(0),
    m_pPrev(0),
    m_dwIndex( 0 ),
    m_dwSpi( 0xffffffff ),
    m_dwState( 0 ),
    m_dwTitleId( 0 ),
    m_qwMatchId( MAKEQWORD( 0L, 0L ) ),
    m_dwMatchExpireTime(0),
    m_wNickname( 0 ),
    m_wcbTitleData( 0 ),
    m_dwBuddyListVer( 0L ),
    m_dwBlockListVer( 0L ),
    m_dwLastQValSeq( 0L ),
    m_dwCurQflags( 0L ),
    m_dwTotalNewInvites( 0L ),
    m_dwLastNewMsgQValSeq( 0L ),
    m_dwLastDelMsgQValSeq( 0L ),
    m_dwUserFlags( 0x02006700 ), // english speaking user in the US
    m_dwInuseTime( 0 ),
    m_dwTouched( 0 ),
    m_dwPoolFlags( 0 ),
    m_pStorage(0)
{
    m_rgbTitleData[0] = 0;
    m_szAcctName[0]   = 0;
}

XPQUser::~XPQUser()
{
}

void XPQUser::Create(DWORD dwIndex)
{
    m_dwIndex = dwIndex;
    CreateUserName(m_szAcctName, "BU", UserId());
}


//------------------------------------------------------------------------------
// Notification management
//------------------------------------------------------------------------------

// 
// Check queues in order, the idea being that lower numbered queues 
// are more important and change less than higher numbered queues (in the
// current implementation)
//
P_QUEUE_TYPES XPQUser::GetNextQueue() const
{ 
	WORD wi;
    for(wi = 0; wi < PQUEUE_NUM_TYPES; ++wi)
    {
        if(PQUEUE_TRANSIENT_MSGS == wi)
            continue;
        if(IsQueued((P_QUEUE_TYPES)wi))
            break;
    }

    return (P_QUEUE_TYPES)wi;
}

// Collapse all notification items
HRESULT XPQUser::CollapseNotificationData() 
{
    HRESULT hr;
    const XPQNotificationData *pNoti;
    const XPQNotificationData *pNotiEnd;
    const XPQNotificationData *pBestNoti;
    
    // No online storage
    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    // No notifications to collapse
    if(0 == m_pStorage->Notifications.GetCount())
    {
        SetPoolFlags(0, USERPOOL_NOTIFICATION_MASK);
		m_dwCurQflags = 0;
		hr = E_FAIL;
        goto lbDone;
    }

    pNoti       = m_pStorage->Notifications.First();
    pNotiEnd    = m_pStorage->Notifications.End();
    pBestNoti   = pNoti;

    while(pNoti < pNotiEnd)
    {
        if(pNoti->dwSequence >= pBestNoti->dwSequence && pNoti != pBestNoti)
        {
            // Replace the best notification
            m_pStorage->Notifications.Set(0, *pNoti);
            if(FAILED(hr = m_pStorage->Notifications.Remove(pNoti)))
            {
                goto lbDone;
            }

            pNotiEnd = m_pStorage->Notifications.End();
            continue;
        }

        ++pNoti;
    }

    m_dwLastQValSeq = pBestNoti->dwSequence;
    m_dwCurQflags   = pBestNoti->dwFlags;

	// always remove the notification, dequeue will add another one if it is required
	m_pStorage->Notifications.Remove((DWORD)0);
	SetPoolFlags(0, USERPOOL_NOTIFICATION_MASK);
    hr = S_OK;

lbDone:
    return hr;
}

// Called on receiving a new qval message for this user
HRESULT XPQUser::UpdateNotificationData(DWORD dwFlags, DWORD dwSequence)
{
    HRESULT hr = S_FALSE;

    if(0 != dwFlags && dwSequence >= m_dwLastQValSeq && 0 != m_pStorage)
    {
        XPQNotificationData noti;
        noti.dwFlags    = dwFlags;
        noti.dwSequence = dwSequence;

        hr = m_pStorage->Notifications.Append(noti);
        if(SUCCEEDED(hr))
        {
            SetPoolFlags(USERPOOL_NOTIFICATION_MASK, 0);
        }
    }
        
    return hr;
}

HRESULT XPQUser::ProcessQVal(const SGQVal &qval)
{
    HRESULT hr;
    DWORD dwType;
    DWORD dwSequence;

    // QFlags
    dwType = qval.m_qvalFlags & (QVAL_DSIZE_MASK | QVAL_INDEX_MASK); 
    if( QVAL_QFLAGS != dwType ) 
    {
        ERR2(User, "[XPQUser::ProcessQVal]: user[%I64x] bad qval in qflag position (0x%08x) is wrong type", 
                qval.m_qwUserId,
                qval.m_qvalFlags);
        goto lbDone;
    }

    dwSequence = QVAL_SEQ( qval.m_qvalFlags );

    // Add a notification bucket item if we have flags, remove in the case
    // we have zero'd our flags out
    if(FAILED(hr = UpdateNotificationData(qval.m_dwFlags, dwSequence)))
    {
        goto lbDone;
    }

    //------------------------------------------------------------------------------
    // New messages
    //
    dwType = qval.m_qvalNewMsgIds & (QVAL_DSIZE_MASK | QVAL_INDEX_MASK); 
    if( QVAL_NEW_MSG_IDS != dwType )
    {
        ERR2(User, "[XPQUser::ProcessQVal]: user[%I64x] bad qval in new messages IDs position (0x%08x) is wrong type", 
                qval.m_qwUserId,
                qval.m_qvalNewMsgIds);
        hr = E_FAIL;
        goto lbDone;
    }

    dwType = qval.m_qvalNewMsgData & (QVAL_DSIZE_MASK | QVAL_INDEX_MASK); 
    if( QVAL_NEW_MSG_DATA != dwType )
    {
        ERR2( User, 
                "[XPQUserMgr::HandleQVal]: user[%I64x] bad qval in new messages data data position (0x%08x) is wrong type", 
                qval.m_qwUserId,
                qval.m_qvalNewMsgData);
        hr = E_FAIL;
        goto lbDone;
    }

    dwSequence = QVAL_SEQ( qval.m_qvalNewMsgIds );
    
    if(0 != qval.m_dwMsgId1 && LastNewMsgQValSeq() < dwSequence)
    {
        SetLastNewMsgQValSeq(dwSequence);

        if(FAILED(hr = ProcessMessage(dwSequence, qval.m_dwMsgId1, qval.m_dwMsgData1, 0, 0, 0, 0, (const BYTE*)0)))
        {
            ERR4(User, "[XPQUser::ProcessQVal]: ProcessMessage failed for user: %I64x, message: %08x, data: %08x, hr: 0x%08x",
                    UserId(),
                    qval.m_dwMsgId1,
                    qval.m_dwMsgData1,
                    hr);
        }
    }
        
    //------------------------------------------------------------------------------
    // Deleted messages
    //
    dwType = qval.m_qvalDelMsgIds & (QVAL_DSIZE_MASK | QVAL_INDEX_MASK); 
    if( QVAL_MSG_DELETED != dwType )
    {
        ERR2(User, 
                "[XPQUser::ProcessQVal]: user [%I64x] bad qval in delete messages position (0x%08x) is wrong type", 
                qval.m_qwUserId,
                qval.m_qvalDelMsgIds);
        hr = E_FAIL;
        goto lbDone;
    }

    dwSequence = QVAL_SEQ( qval.m_qvalDelMsgIds );

    if(0 != qval.m_dwDelId1 && LastDelMsgQValSeq() < dwSequence)
    {
        SetLastDelMsgQValSeq(dwSequence);
        if(FAILED(hr = RemoveMessage(qval.m_dwDelId1)))
        {
            goto lbDone;
        }
    }

    hr = S_OK;

lbDone:

	// Notify the bucket allocator of new state data
	if(HasPoolFlag(USERPOOL_NOTIFICATION_MASK))
	{
		gpUserMgr->NotifyState(this, USERPOOL_NOTIFICATION_ID);
	}
	if(HasPoolFlag(USERPOOL_PENDING_MSG_MASK))
	{
		gpUserMgr->NotifyState(this, USERPOOL_PENDING_MSG_ID);
	}

    return hr;
}

HRESULT XPQUser::DeferQVal(const SGQVal &qval)
{
    HRESULT hr;

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    hr = m_pStorage->DeferredQVals.Append(qval);

lbDone:
    return hr;
}

HRESULT XPQUser::ProcessDeferredQVals()
{
    HRESULT hr;
    const SGQVal *pQVal;
    const SGQVal *pQValEnd;

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }
   
    pQVal       = m_pStorage->DeferredQVals.First();
    pQValEnd    = m_pStorage->DeferredQVals.End();

    while(pQVal < pQValEnd)
    {
        ProcessQVal(*pQVal);
        ++pQVal;
    }

    // Reset the counter to zero
    m_pStorage->DeferredQVals.Clear();

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// Messaging management
//------------------------------------------------------------------------------

HRESULT XPQUser::ClearMessages()
{
    HRESULT hr;
    XPQMessageData *pMessage;
    XPQMessageData *pMessageEnd;

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    m_pStorage->Notifications.Clear();
    hr = S_OK; 

lbDone:
    return hr;
}

HRESULT XPQUser::ProcessSummary(const Q_MESSAGE_SUMMARY *pSummary)
{
    // Make sure we got the message from a user that we know about
    const XPQUser *pUser = gpUserMgr->UserPtrFromId(pSummary->qwSenderID);
    if(0 != pUser)
    {
        return ProcessMessage(
                -1,
                pSummary->dwMessageID,
                pSummary->bMessageType << 24,
                pSummary->dwMessageFlags,
                pUser->UserIndex(),
                pSummary->dwSenderTitleID,
                pSummary->qwSenderContext,
                (const BYTE*)0);
    }
    else
    {
        return S_OK;
    }
}

HRESULT XPQUser::ProcessSummary2(const Q_MESSAGE_SUMMARY_2 *pSummary)
{
    const XPQUser *pUser = gpUserMgr->UserPtrFromId(pSummary->qwSenderID);
    if(0 != pUser)
    {
        return ProcessMessage(
                -1,
                pSummary->dwMessageID,
                pSummary->bMessageType << 24,
                pSummary->dwMessageFlags,
                pUser->UserIndex(),
                pSummary->dwSenderTitleID,
                pSummary->qwSenderContext,
                (const BYTE*)0);
    }
    else
    {
        return S_OK;
    }
}

HRESULT XPQUser::ProcessMessage(
        DWORD dwSequence,
        DWORD dwMessageId,
        DWORD dwMessageData,
        DWORD dwMessageFlags,
        DWORD dwSenderIndex,
        DWORD dwSenderTitleId,
        QWORD qwSenderContext,
        const BYTE *pbDetails)
{
    HRESULT hr;
    BYTE bState;
    DWORD cPending;
    DWORD cRead;
    XPQMessageData *pMessage;
    XPQMessageData *pMessageCur;
    const XPQMessageData *pMessageEnd;

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    if(-1 != dwSequence && dwSequence >= m_dwLastNewMsgQValSeq)
    {
        hr = S_OK;
        goto lbDone;
    }

    if(0 == dwMessageId)
    {
        hr = S_OK;
        goto lbDone;
    }

    cPending    = 0;
    cRead       = 0;
    pMessage    = 0;
    pMessageCur = m_pStorage->Messages.LockData();
    pMessageEnd = m_pStorage->Messages.End();
    
    // Find existing message item using the cursor
    // set pMessage to the cursor when found
    while(pMessageCur < pMessageEnd)
    {
        if(dwMessageId == pMessageCur->dwId)
        {
            // Don't count the message we're looking
            // for, we'll count it after we have determined
            // it's final state type
            pMessage = pMessageCur;
        }
        else
        {
            switch(pMessageCur->bState)
            {
                case XPQ_MESSAGE_STATE_PENDING:
                    ++cPending;
                    break;
                case XPQ_MESSAGE_STATE_READ:
                    ++cRead;
                    break;
            }
        }

		++pMessageCur;
    }

    //
    // Modify the state type based on the passed flags
    //
    if(0 == (XONLINE_MSG_FLAG_READ & dwMessageFlags))
    {
        bState = XPQ_MESSAGE_STATE_PENDING;
        ++cPending;
    }
    else
    {
        bState  = XPQ_MESSAGE_STATE_READ;
        ++cRead;
    }

    //
    // Update the user pool flags
    //
    if(cPending > 0)
    {
        SetPoolFlags(USERPOOL_PENDING_MSG_MASK, 0);
    }
    else
    {
        SetPoolFlags(0, USERPOOL_PENDING_MSG_MASK);
    }
    if(cRead > 0)
    {
        SetPoolFlags(USERPOOL_READ_MSG_MASK, 0);
    }
    else
    {
        SetPoolFlags(0, USERPOOL_READ_MSG_MASK);
    }
    

    //
    // Create a new storage item if none exists
    //
    if(0 == pMessage)
    {
        XPQMessageData message; 
        message.bState          = bState;
        message.dwId            = dwMessageId; 
        message.dwData          = 0;
        message.dwFlags         = 0;
        message.dwSenderIndex   = 0;
        message.dwSequence      = dwSequence;

		// we're going to get a new pointer to some message data here so
		// unlock the storage area
		m_pStorage->Messages.UnlockData();
        if(FAILED(hr = m_pStorage->Messages.Append(message, &pMessage)))
        {
            goto lbDone;
        }
    }
    else
    {
        pMessage->bState = bState;
    }

    _ASSERTE(0 != pMessage);

    // Overwrite message data with new data if provided
    if(dwMessageFlags)
    {
        pMessage->dwFlags       = dwMessageFlags; 
    }
    if(dwMessageData)
    {
        pMessage->dwData        = dwMessageData; 
    }
    if(dwSenderIndex)
    {
        pMessage->dwSenderIndex = dwSenderIndex;
    }
    
    // If this message is coming in off a valid sequence number, save it here
    if(-1 != dwSequence)
    {
        m_dwLastNewMsgQValSeq = dwSequence;
    }

    // Process the details for specific message types to provide additional 
    // state data.
    if(pbDetails)
    {
        switch((dwMessageData >> 24) & 0xff)
        {
            case XONLINE_MSG_TYPE_GAME_INVITE:
                {
                    // Extract  the session ID from the details
                    ULONGLONG qwSessionId = 0;
                    const XMSG_DETAILS *pDetails = (const XMSG_DETAILS*)pbDetails;
                    const XMSG_PROPERTY *pProperty = (const XMSG_PROPERTY*)(pDetails + 1);
                    const BYTE *prgData = (BYTE*)(pDetails + 1) + (sizeof(XMSG_PROPERTY) * pDetails->wPropCount);

                    for(WORD i = 0; i < pDetails->wPropCount; ++i)
                    {
                        if(XONLINE_MSG_PROP_SESSION_ID == pProperty->wPropTag)
                        {
                            qwSessionId = *(ULONGLONG*)(prgData + pProperty->wPropOffset);
                            break;
                        }
                        pProperty++;
                    }

                    if(0 != qwSessionId)
                    {
                        if(FAILED(hr = AddReceivedInvite(
                                gpUserMgr->UserPtrFromIndex(dwSenderIndex),
                                dwSenderTitleId,
                                qwSessionId)))
                        {
                            ERR4(User, "[XPQUser::ProcessMessage]: failed to add received invite, user: %I64x, hostindex: %u, titleid: 0x%8x, session: %I64x",
                                    UserId(),
                                    dwSenderIndex,
                                    dwSenderTitleId,
                                    qwSessionId);
                            goto lbDone;
                        }
                    }
                }
                break;
            case XONLINE_MSG_TYPE_TEAM_RECRUIT:
                {
                    // Pull the team ID for a team recruit
                    ULONGLONG qwTeamId = qwSenderContext;
                    XPQTeamMemberData *pMemberData;
                    if(FAILED(hr = AddTeamMember(qwSenderContext, dwSenderTitleId, XPQ_TEAM_MEMBER_STATE_RECRUIT, &pMemberData)))
                    {
                        ERR4(User, "[XPQUser::ProcessMessage]: failed to add received team recruit, user: %I64x, senderindex: %u, titleid: 0x%08x, teamid: %I64x",
                                UserId(),
                                dwSenderIndex,
                                dwSenderTitleId,
                                qwSenderContext);
                        goto lbDone;
                    }
                }
                break;
        }
    }

    hr = S_OK;

lbDone:
    if(m_pStorage)
    {
        m_pStorage->Messages.UnlockData();
    }

    return hr;
}

HRESULT XPQUser::ProcessDetails(const Q_MESSAGE_SUMMARY *pSummary, const BYTE *pbDetails)
{
    const XPQUser *pUser = gpUserMgr->UserPtrFromId(pSummary->qwSenderID);
    if(0 != pUser)
    {
        return ProcessMessage(
                -1, 
                pSummary->dwMessageID, 
                pSummary->bMessageType << 24, 
                pSummary->dwMessageFlags, 
                pUser->UserIndex(), 
                pSummary->dwSenderTitleID,
                pSummary->qwSenderContext,
                pbDetails);
    }
    else
    {
        return S_OK;
    }
}

DWORD XPQUser::GetNextReadMessageId()
{
    HRESULT hr;
    const XPQMessageData *pMessage;
   
    hr = GetFirstMessage(XPQ_MESSAGE_STATE_READ, &pMessage);
    if(S_OK == hr)
    {
        return pMessage->dwId;
    }
    else
    {
        ERR2(User, "[XPQUser::GetNextReadMessageId]: failed GetFirstMessage for user: %I64x, hr: 0x%08x",
                UserId(),
                hr);
        return 0;
    }
}

// Get the next unread message ID item, collapse any dups
DWORD XPQUser::GetNextUnreadMessageId()
{
    HRESULT hr;
    const XPQMessageData *pMessage;
   
    hr = GetFirstMessage(XPQ_MESSAGE_STATE_PENDING, &pMessage);
    if(S_OK == hr)
    {
        return pMessage->dwId;
    }
    else
    {
        ERR2(User, "[XPQUser::GetNextUnreadMessageId]: failed GetFirstMessage for user: %I64x, hr: 0x%08x",
                UserId(),
                hr);
        return 0;
    }
}

HRESULT XPQUser::GetFirstMessage(BYTE bState, const XPQMessageData **ppOutMessageData)
{
    HRESULT hr;
    const XPQMessageData *pMessage;
    const XPQMessageData *pMessageEnd;
    DWORD dwId = 0;

    if((bState != XPQ_MESSAGE_STATE_READ && bState != XPQ_MESSAGE_STATE_PENDING) || 0 == ppOutMessageData)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

	*ppOutMessageData = 0;
	hr = S_FALSE;

    pMessage    = m_pStorage->Messages.First();
    pMessageEnd = m_pStorage->Messages.End();

    for(; pMessage < pMessageEnd; ++pMessage)
    {
        if(bState == pMessage->bState)
        {
            *ppOutMessageData = pMessage;
			hr = S_OK;
            break;
        }
    }

lbDone:
    return hr;
}

HRESULT XPQUser::RemoveMessage(DWORD dwId)
{
    HRESULT hr = S_FALSE;
    const XPQMessageData *pMessage;
    const XPQMessageData *pMessageEnd;
    DWORD cRead;
    DWORD cPending;


    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    pMessage    = m_pStorage->Messages.First();
    pMessageEnd = m_pStorage->Messages.End();
    cRead       = 0;
    cPending    = 0;

    while(pMessage < pMessageEnd)
    {
        if(dwId == pMessage->dwId)
        {
            if(FAILED(hr = m_pStorage->Messages.Remove(pMessage)))
            {
                goto lbDone;
            }

            pMessageEnd = m_pStorage->Messages.End();
            continue;
        }

        switch(pMessage->bState)
        {
            case XPQ_MESSAGE_STATE_READ:
                cRead++;
                break;
            case XPQ_MESSAGE_STATE_PENDING:
                cPending++;
                break;
        }

        ++pMessage;
    }

    if(0 == cRead)
    {
        SetPoolFlags(0, USERPOOL_READ_MSG_MASK);
    }
    if(0 == cPending)
    {
        SetPoolFlags(0, USERPOOL_PENDING_MSG_MASK);
    }

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
//
// Team and Team membership management
//
//------------------------------------------------------------------------------

DWORD XPQUser::CountTeams(DWORD dwTitleId) const
{         
    HRESULT hr;
    const XPQTeamData *pTeam;
    const XPQTeamData *pTeamEnd;
    DWORD dwcTeams = 0;

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    pTeam    = m_pStorage->Teams.First();
    pTeamEnd = m_pStorage->Teams.End();

    while(pTeam < pTeamEnd)
    {
        if(0 == dwTitleId || dwTitleId == pTeam->dwTitleId)
        {
            dwcTeams++;
        }
        ++pTeam;
    }

lbDone:
    return dwcTeams;
}

HRESULT XPQUser::AddTeam(ULONGLONG qwTeamId, DWORD dwTitleId, XPQTeamData **ppOutTeamData) 
{ 
    HRESULT hr;

    if(0 == ppOutTeamData)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    XPQTeamData team;
    team.Clear();
    team.qwTeamId   = qwTeamId;
    team.dwTitleId  = dwTitleId;
    team.dwExpire   = gpUserMgr->GenerateStateExpiration(USERPOOL_TEAM_ID);

    hr = m_pStorage->Teams.Append(team, ppOutTeamData);
    SetPoolFlags(USERPOOL_TEAM_MASK, 0);

lbDone:
    return hr;
}

HRESULT XPQUser::GetTeam(ULONGLONG qwTeamId, XPQTeamData **ppOutTeamData) const 
{
    XPQTeamData *pTeam;
    const XPQTeamData *pTeamEnd;
    HRESULT hr = S_FALSE;

    if(0 == ppOutTeamData)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    *ppOutTeamData = 0;

    pTeam    = m_pStorage->Teams.LockData();
    pTeamEnd = m_pStorage->Teams.End();

    while(pTeam < pTeamEnd)
    {
        if(qwTeamId == pTeam->qwTeamId)
        {
            *ppOutTeamData = pTeam;
            hr = S_OK;
            break;
        }
        ++pTeam; 
    }

    m_pStorage->Teams.UnlockData();

lbDone:
    return hr; // qwTeamId;
}

HRESULT XPQUser::GetTeamIds(ULONGLONG *prgTeamIds, /*INOUT*/ DWORD *pdwcTeamIds)
{
    HRESULT hr;
    const XPQTeamData *pTeam;
    const XPQTeamData *pTeamEnd;
    const XPQTeamMemberData *pTeamMember;
    const XPQTeamMemberData *pTeamMemberEnd;
    DWORD dwiTeamId;
    DWORD dwcTeamIds;

    if(0 == prgTeamIds || 0 == pdwcTeamIds || 0 == *pdwcTeamIds)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }


    dwiTeamId = 0;
    dwcTeamIds = 0;


    pTeam    = m_pStorage->Teams.First();
    pTeamEnd = m_pStorage->Teams.End();

    while(pTeam < pTeamEnd && dwcTeamIds < *pdwcTeamIds)
    {
        prgTeamIds[dwiTeamId] = pTeam->qwTeamId;
        dwcTeamIds++;
        ++pTeam;
    }

    pTeamMember     = m_pStorage->TeamMembers.First();
    pTeamMemberEnd  = m_pStorage->TeamMembers.End();

    while(pTeamMember < pTeamMemberEnd && dwcTeamIds < *pdwcTeamIds)
    {
        prgTeamIds[dwiTeamId] = pTeamMember->qwTeamId;
        dwcTeamIds++;
        ++pTeamMember;
    }

    *pdwcTeamIds = dwcTeamIds;

lbDone:
    return hr;
}

HRESULT XPQUser::RemoveTeamData(ULONGLONG qwTeamId, DWORD dwTitleId)
{
    HRESULT hr;
    const XPQTeamData *pTeam;
    const XPQTeamData *pTeamEnd;
    const XPQTeamMemberData *pTeamMember;
    const XPQTeamMemberData *pTeamMemberEnd;

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    pTeam    = m_pStorage->Teams.First();
    pTeamEnd = m_pStorage->Teams.End();

    while(pTeam < pTeamEnd)
    {
        // remove teams
        if( qwTeamId == pTeam->qwTeamId || dwTitleId == pTeam->dwTitleId)
        {
            if(FAILED(hr = m_pStorage->Teams.Remove(pTeam)))
            {
                goto lbDone;
            }
            pTeamEnd = m_pStorage->Teams.End();
            continue;
        }

        ++pTeam;
    }
    
    pTeamMember    = m_pStorage->TeamMembers.First();
    pTeamMemberEnd = m_pStorage->TeamMembers.End();

    while(pTeamMember < pTeamMemberEnd)
    {
        // remove members and recruits
        if(qwTeamId == pTeamMember->qwTeamId || dwTitleId == pTeamMember->dwTitleId)
        {
            if(FAILED(hr = m_pStorage->TeamMembers.Remove(pTeamMember)))
            {
                goto lbDone;
            }
            pTeamMemberEnd = m_pStorage->TeamMembers.End(); 
            continue;
        }

        ++pTeamMember;
    }

    hr = S_OK;

lbDone:
    return hr;
}

HRESULT XPQUser::AddTeamMember(
        ULONGLONG qwTeamId,
        DWORD dwTitleId,
        BYTE bState,
        XPQTeamMemberData **ppOutMemberData)
{
    HRESULT hr;

    if(0 == ppOutMemberData)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    *ppOutMemberData = 0;

    XPQTeamMemberData member;
    member.qwTeamId     = qwTeamId;
    member.dwTitleId    = dwTitleId;
    member.bState       = bState;

    hr = m_pStorage->TeamMembers.Append(member, ppOutMemberData);

    // indicate this user has such data
    switch(member.bState)
    {
        case XPQ_TEAM_MEMBER_STATE_RECRUIT:
            SetPoolFlags(USERPOOL_TEAM_RECRUIT_MASK, 0);
            break;
        default:
            SetPoolFlags(USERPOOL_TEAM_MEMBER_MASK, 0);
            break;
    }

lbDone:
    return hr;
}

HRESULT XPQUser::GetTeamMember(
        ULONGLONG qwTeamId,
        XPQTeamMemberData **ppOutMemberData) const
{
    XPQTeamMemberData *pMember;
    const XPQTeamMemberData *pMemberEnd;
    HRESULT hr = S_FALSE;

    if(0 == ppOutMemberData)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    *ppOutMemberData = 0;

    pMember     = m_pStorage->TeamMembers.LockData();
    pMemberEnd  = m_pStorage->TeamMembers.End();

    while(pMember < pMemberEnd)
    {
        if(qwTeamId == pMember->qwTeamId)
        {
            *ppOutMemberData = pMember;
            hr = S_OK;
            break;
        }
        ++pMember;
    }

    m_pStorage->TeamMembers.UnlockData();

lbDone:
    return hr;
}

HRESULT XPQUser::RemoveTeamMember(ULONGLONG qwTeamId)
{
    HRESULT hr = E_FAIL;

    const XPQTeamMemberData *pMember;
    const XPQTeamMemberData *pMemberEnd;

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    pMember     = m_pStorage->TeamMembers.First();
    pMemberEnd  = m_pStorage->TeamMembers.End();

    while(pMember < pMemberEnd)
    {
        if(qwTeamId == pMember->qwTeamId)
        {
            hr = m_pStorage->TeamMembers.Remove(pMember);
            goto lbDone;
        }

        ++pMember;
    }

lbDone:
    return hr;
}

HRESULT XPQUser::GetTeamRecruitment(XPQTeamMemberData **ppOutMemberData) const
{
    HRESULT hr = S_FALSE;

    XPQTeamMemberData *pMember;
    const XPQTeamMemberData *pMemberEnd;

    if(0 == ppOutMemberData)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    *ppOutMemberData = 0;

    pMember     = m_pStorage->TeamMembers.LockData();
    pMemberEnd  = m_pStorage->TeamMembers.End();

    while(pMember < pMemberEnd)
    {
        if(m_dwTitleId == pMember->dwTitleId && XPQ_TEAM_MEMBER_STATE_RECRUIT == pMember->bState)
        {
            *ppOutMemberData = pMember;
            hr = S_OK;
            break;
        }
        pMember = pMember++;
    }

    m_pStorage->TeamMembers.UnlockData();

lbDone:
    return hr;
}

HRESULT XPQUser::GetOrCreateTeamData(ULONGLONG qwTeamId, DWORD dwTitleId, XPQTeamData **ppOutTeamData)
{
    HRESULT hr;

    if(0 == ppOutTeamData)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    *ppOutTeamData = 0;
    
    if(FAILED(hr = GetTeam(qwTeamId, ppOutTeamData)))
    {
        goto lbDone;
    }


    if(0 == *ppOutTeamData && FAILED(hr = AddTeam(qwTeamId, dwTitleId, ppOutTeamData)))
    {
        goto lbDone;
    }

lbDone:
    return hr;
}

HRESULT XPQUser::GetOrCreateTeamMemberData(ULONGLONG qwTeamId, DWORD dwTitleId, BYTE bMemberState, XPQTeamMemberData **ppOutMemberData)
{
    HRESULT hr;

    if(0 == ppOutMemberData)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    *ppOutMemberData = 0;

    if(FAILED(hr = GetTeamMember(qwTeamId, ppOutMemberData)))
    {
        goto lbDone;
    }

    if(0 == *ppOutMemberData && FAILED(hr = AddTeamMember(
                    qwTeamId,
                    dwTitleId, 
                    bMemberState,
                    ppOutMemberData)))
    {
        goto lbDone;
    }

lbDone:
    return hr;
}



//------------------------------------------------------------------------------
// Title storage access
//------------------------------------------------------------------------------
DWORD XPQUser::CountTitles() const
{
    HRESULT hr;
    const XPQTitleData *pTitle;
    DWORD dwcTitles = 0;

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    pTitle = m_pStorage->Titles.First();
    if(0 != pTitle)
    {
        return pTitle->dwcTitles;
    }

lbDone:
    return dwcTitles;
} 

DWORD XPQUser::GetOfflineTitle() const
{
    HRESULT hr;
    const XPQTitleData *pTitle;
    DWORD *prgTitles;
    DWORD dwcTitles;
    DWORD dwTitleId = 0;

    if(!GetOnlineStorage())
    {
        dwTitleId = 0;
        goto lbDone;
    }

    pTitle = m_pStorage->Titles.First(); 
     
    if(0 != pTitle)
    {
        prgTitles = (DWORD*)(pTitle+1);
        dwcTitles = pTitle->dwcTitles;

        for(DWORD dwIndex = 0; dwIndex < dwcTitles; ++dwIndex)
        {
            if(prgTitles[dwIndex] != m_dwTitleId)
            {
                dwTitleId = prgTitles[dwIndex];
                break;
            }
        }
    }

lbDone:
    return dwTitleId;
}

DWORD XPQUser::GetTitle(DWORD dwIndex) const
{
    HRESULT hr;
    const XPQTitleData *pTitle;
    DWORD dwTitleId = 0;

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    pTitle = m_pStorage->Titles.First(); 
    if(0 != pTitle && dwIndex < pTitle->dwcTitles)
    {
        dwTitleId = pTitle->rgTitles[dwIndex];
    }

lbDone:
    return dwTitleId;
}

//------------------------------------------------------------------------------
//
// User property accessors
//
//------------------------------------------------------------------------------
DWORD XPQUser::SetUserFlags(DWORD dwUserFlags)
{
    return m_dwUserFlags = dwUserFlags;
}

DWORD XPQUser::SetBuddyListVersion(DWORD dwVersion)
{
    return m_dwBuddyListVer = dwVersion;
}

DWORD XPQUser::SetBlockListVersion(DWORD dwVersion)
{
    return m_dwBlockListVer = dwVersion;
}

DWORD XPQUser::SetState(DWORD dwState)
{
    return m_dwState = dwState;
}

DWORD XPQUser::SetTitleId(DWORD dwTitleId)
{
    return m_dwTitleId = dwTitleId;
}

ULONGLONG XPQUser::SetMatchId(ULONGLONG qwMatchId)
{
    return m_qwMatchId = qwMatchId;
}

DWORD XPQUser::SetMatchExpire(DWORD dwMatchExpire)
{
    return m_dwMatchExpireTime = dwMatchExpire;
}

DWORD XPQUser::SetSpiInfo(DWORD dwSpi, DWORD dwSlotIndex)
{
    return m_dwSpi = (0x00ffffff & dwSpi) | (0xff000000 & (dwSlotIndex << 24));
}

void XPQUser::ClearOnlineState()
{
    m_dwLastQValSeq       = 0L;
    m_dwCurQflags         = 0L;
    m_dwTotalNewInvites   = 0L;
    m_dwLastNewMsgQValSeq = 0L;
    m_dwLastDelMsgQValSeq = 0L;
    m_dwState             = 0L;
}

void XPQUser::SetPoolFlags(DWORD dwAddFlags, DWORD dwRemoveFlags)
{
    if(0 != dwAddFlags)
    {
        m_dwPoolFlags |= dwAddFlags;
    }
    if(0 != dwRemoveFlags)
    {
        m_dwPoolFlags &= ~dwRemoveFlags;
    }
}

//------------------------------------------------------------------------------
// Xbox1 presence state
//------------------------------------------------------------------------------
WORD XPQUser::SetNickname( BYTE* pbBuffer, WORD cbBuffer )
{ 
    WORD wLen = 0;

    if(!IsXenonTitleId())
    {
        wLen = min( MAX_NICKNAME_BYTES, cbBuffer );

        memcpy( m_rgbTitleData+MAX_TITLE_STATE_BYTES, pbBuffer, wLen );
        m_wNickname = wLen;
    }
    else
    {
        ERR1(User, "[XPQUser::SetNickname]: xenon user: %I64x", UserId());
    }

    return wLen;
}

WORD XPQUser::SetTitleData( BYTE* pbBuffer, WORD cbBuffer )
{ 
    WORD wLen = 0;

    if(!IsXenonTitleId())
    {
        wLen = min( MAX_TITLE_STATE_BYTES, cbBuffer );
        CopyMemory( m_rgbTitleData, pbBuffer, wLen );
    }
    else
    {
        wLen = min( MAX_TITLE_DATA_BYTES, cbBuffer );
        CopyMemory( m_rgbTitleData, pbBuffer, wLen );
    }

    m_wcbTitleData = wLen;

    return wLen;
}

WORD XPQUser::SetTitleDataLen(WORD wcbTitleData)
{
    if(!IsXenonTitleId())
    {
        m_wcbTitleData = min(MAX_TITLE_STATE_BYTES, wcbTitleData);
    }
    else
    {
        m_wcbTitleData = min(MAX_TITLE_DATA_BYTES, wcbTitleData);
    }

    return m_wcbTitleData;
}

//------------------------------------------------------------------------------
// Xenon rich presence accessors
//------------------------------------------------------------------------------
HRESULT XPQUser::SetGameMode(DWORD dwGameMode)
{
    HRESULT hr;

    if(!IsXenonTitleId())
    {
        ERR2(User, "[XPQUser::SetGameMode]: xbox user: %I64x, title mode: %u", 
                UserId(), dwGameMode);
        hr = E_INVALIDARG;
    }
    else
    {
        if(0 == m_wcbTitleData)
        {
            // Do first time initialization of title data
            ZeroMemory(m_rgbTitleData, MAX_TITLE_DATA_BYTES);   
            m_wcbTitleData = MAX_TITLE_DATA_BYTES;
        }

        P_RICH_PRESENCE *pRP = (P_RICH_PRESENCE*)m_rgbTitleData;
        pRP->titlePresence = dwGameMode;
        hr = S_OK;
    }

    return hr;
}

HRESULT GetGIProperty(P_RICH_PRESENCE *pRP, DWORD dwIndex, GI_PROPERTY **ppProperty)
{
    // Find write position for properties
    register BYTE *pd = (BYTE*)(pRP+1) + (pRP->cContexts * sizeof(GI_CONTEXT));
    register BYTE *pe = pd + 256;
    register GI_PROPERTY *pProperty;
    WORD cProperties = pRP->cProperties;
    WORD wArrayLen;
    HRESULT hr = E_FAIL;

    if(ppProperty)
    {
        *ppProperty = (GI_PROPERTY*)0;
    }
    else
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }


    while(cProperties > 0 && pd < pe)
    {
        pProperty = (GI_PROPERTY*)pd;
        --cProperties;

        if((pProperty->id & (~XONLINE_STAT_DATATYPE_MASK)) == dwIndex)
        {
            *ppProperty = pProperty;
            hr = S_OK;
            break;
        }

        // Advance the pointer
        switch(pProperty->id & XONLINE_STAT_DATATYPE_MASK)
        {
            default:
                ERR2(User, "Unsupported type for property index: %u, id: 0x%08x",
                        dwIndex, pProperty->id);
                break;
            case XONLINE_STAT_LONG:
                pd += sizeof(DWORD) + sizeof(DWORD);
                break;
            case XONLINE_STAT_LONGLONG:
                pd += sizeof(DWORD) + sizeof(QWORD);
                break;
            case XONLINE_STAT_DOUBLE:
                pd += sizeof(DWORD) + sizeof(QWORD);
                break;
            case XONLINE_STAT_LPCWSTR:
                wArrayLen = *(WORD*)pd;     
                pd += sizeof(DWORD) + (sizeof(BYTE)*wArrayLen);
                break;
            case XONLINE_STAT_FLOAT:
                pd += sizeof(DWORD) + sizeof(DWORD);
                break;
            case XONLINE_STAT_BINARY:
                wArrayLen = *(WORD*)pd;     
                pd += sizeof(DWORD) + (sizeof(BYTE)*wArrayLen);
                break;
            case XONLINE_STAT_DATETIME:
                pd += sizeof(DWORD) + sizeof(QWORD);
                break;
        }

    } // end property loop

lbDone:
    return hr;
}


//------------------------------------------------------------------------------
// User online local storage access
//------------------------------------------------------------------------------
HRESULT XPQUser::GetRandomStorageItem(DWORD dwBucketId, const void **ppOutStorageItem) const
{
    HRESULT hr;
    DWORD dwcItems = 0;

    if(0 == ppOutStorageItem || dwBucketId >= USERPOOL_MAX_ID)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    *ppOutStorageItem = 0;

    const void *pStorage = 0;

    switch(dwBucketId)
    {
        default:
            hr = E_INVALIDARG;
            goto lbDone;
        case USERPOOL_PENDING_INVITE_ID:
			if(m_pStorage->Invites.GetCount() > 0)
			{
				pStorage = (const void*)(m_pStorage->Invites.First() + (rand() % m_pStorage->Invites.GetCount()));
			}
            break;
        case USERPOOL_NOTIFICATION_ID:
			if(m_pStorage->Notifications.GetCount() > 0)
			{
				pStorage = (const void*)(m_pStorage->Notifications.First() + (rand() % m_pStorage->Notifications.GetCount()));
			}
            break;
        case USERPOOL_PENDING_MSG_ID:
        case USERPOOL_READ_MSG_ID:
			if(m_pStorage->Messages.GetCount() > 0)
			{
				pStorage = (const void*)(m_pStorage->Messages.First() + (rand() % m_pStorage->Messages.GetCount()));
			}
            break;
        case USERPOOL_PENDING_BUDDY_ID:
        case USERPOOL_RECEIVED_BUDDY_ID:
        case USERPOOL_FULL_BUDDY_ID:
			if(m_pStorage->Buddies.GetCount() > 0)
			{
				pStorage = (const void*)(m_pStorage->Buddies.First() + (rand() % m_pStorage->Buddies.GetCount()));
			}
            break;
        case USERPOOL_TEAM_ID:
			if(m_pStorage->Teams.GetCount() > 0)
			{
				pStorage = (const void*)(m_pStorage->Teams.First() + (rand() % m_pStorage->Teams.GetCount()));
			}
            break;
        case USERPOOL_TEAM_MEMBER_ID:
        case USERPOOL_TEAM_RECRUIT_ID:
			if(m_pStorage->TeamMembers.GetCount() > 0)
			{
				pStorage = (const void*)(m_pStorage->TeamMembers.First() + (rand() % m_pStorage->TeamMembers.GetCount()));
			}
            break;
        case USERPOOL_TITLE_DATA_ID:
			if(m_pStorage->Titles.GetCount() > 0)
			{
				pStorage = (const void*)(m_pStorage->Titles.First() + (rand() % m_pStorage->Titles.GetCount()));
			}
            break;
        case USERPOOL_BLOCK_DATA_ID:
			if(m_pStorage->Blocks.GetCount() > 0)
			{
				pStorage = (const void*)(m_pStorage->Blocks.First() + (rand() % m_pStorage->Blocks.GetCount()));
			}
            break;
    }

    if(0 != pStorage)
    {
        *ppOutStorageItem = pStorage;
    }

lbDone:

    return hr;
}

void XPQUser::ClearStorageItems()
{
    if(GetOnlineStorage())
    {
        m_pStorage->Clear();
    }
}

HRESULT XPQUser::AttachStorage(XPQUserOnlineStorage *pStorage)
{
    HRESULT hr;

    if(0 != m_pStorage)
    {
        hr = E_FAIL;
        goto lbDone;
    }

    if(0 == pStorage)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    m_pStorage = pStorage;

lbDone:
    return hr;
}
    
HRESULT XPQUser::DetachStorage(XPQUserOnlineStorage **ppOutStorage)
{
    HRESULT hr;

    if(0 == ppOutStorage)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    *ppOutStorage = m_pStorage;
    m_pStorage = 0;

lbDone:
    return hr;
}

XPQUserOnlineStorage *XPQUser::GetOnlineStorage() const
{
    _ASSERTE(0 != m_pStorage);
    if(0 == m_pStorage)
    {
        ERR1(User, "[XPQUser::GetOnlineStorage]: no online storage for requested user %I64x", UserId());
    }

    return m_pStorage;
}

HRESULT XPQUser::CleanupStorage()
{
    HRESULT hr;
    DWORD dwNow;
    DWORD cPendingInvites;
    DWORD cReceivedInvites;
    const XPQInviteData *pInvite;
    const XPQInviteData *pInviteEnd;
    const XPQTeamData *pTeam;
    const XPQTeamData *pTeamEnd;

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    dwNow = GetTickCount();

    // Expire invitations
    pInvite = m_pStorage->Invites.First();
    pInviteEnd = m_pStorage->Invites.End();
    cPendingInvites = 0;
    cReceivedInvites = 0;
    while(pInvite < pInviteEnd)
    {
        if(WrapDWORDCompare(dwNow, pInvite->dwExpire) < 0)
        {
            m_pStorage->Invites.Remove(pInvite);
            pInviteEnd = m_pStorage->Invites.End();
            continue;
        }

        if(0 != (pInvite->dwFlags & XPQ_INVITE_FLAGS_RECEIVED))
        {
            ++cReceivedInvites;
        }
        if(0 != (pInvite->dwFlags & XPQ_INVITE_FLAGS_PENDING))
        {
            ++cReceivedInvites;
        }
        ++pInvite;
    }

    if(0 == cReceivedInvites)
    {
        SetPoolFlags(0, USERPOOL_RECEIVED_INVITE_MASK);
    }

    if(0 == cPendingInvites)
    {
        SetPoolFlags(0, USERPOOL_PENDING_INVITE_MASK);
    }

    // Expire team data
    pTeam = m_pStorage->Teams.First();
    pTeamEnd = m_pStorage->Teams.End();
    while(pTeam < pTeamEnd)
    {
        if(WrapDWORDCompare(dwNow, pTeam->dwExpire) < 0)
        {
            m_pStorage->Teams.Remove(pTeam);
            pTeamEnd = m_pStorage->Teams.End();
            continue;
        }
        ++pTeam;
    }

    if(0 == m_pStorage->Teams.GetCount())
    {
        SetPoolFlags(0, USERPOOL_TEAM_MASK);
    }

    // Compact storage 
    m_pStorage->Compact(); 

    hr = S_OK;

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// Peer operations
//------------------------------------------------------------------------------

DWORD XPQUser::CountPeers() const
{
    return m_pStorage ? m_pStorage->Peers.GetCount() : 0;
}

HRESULT XPQUser::UpdatePeers(const XPQUser**  rgpPeers, ULONGLONG* rgqwPeers, WORD &wCount, DWORD &dwFlags)
{
    HRESULT hr;

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

//#define X_PEER_SUBSCRIBE_EX_USER_FLAGS_ADD        0x0100000000000000
//#define X_PEER_SUBSCRIBE_EX_USER_FLAGS_REMOVE     0x0200000000000000
//#define X_PEER_SUBSCRIBE_EX_FLAGS_USE_DIFFS       0x1

	ULONGLONG* rgqwCurrentPeer = rgqwPeers;
    if(m_pStorage->Peers.GetCount() > 0)
    {
        dwFlags = X_PEER_SUBSCRIBE_EX_FLAGS_USE_DIFFS;

        wCount = 0;
        // randomly choose some subscribes to die
        while(m_pStorage->Peers.GetCount() > 0)
        {
            XPQPeerData* PeerData;
            PeerData = m_pStorage->Peers.First();
		    *rgqwCurrentPeer = PeerData->dwPeerId | X_PEER_SUBSCRIBE_EX_USER_FLAGS_REMOVE;
            m_pStorage->Peers.Remove((DWORD)0);
		    rgqwCurrentPeer++;          
            wCount++;
        }
    }
    else
    {
        dwFlags = 0;

	    m_pStorage->Peers.Clear();
	    for(WORD wI = 0; wI < wCount; wI++)
	    {
		    XPQPeerData PeerData;
		    *rgqwCurrentPeer = rgpPeers[wI]->UserId();
		    rgqwCurrentPeer++;
		    PeerData.dwPeerId = rgpPeers[wI]->UserId();
		    m_pStorage->Peers.Append(PeerData);
	    }
    }
lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// Buddy operations
//------------------------------------------------------------------------------

DWORD XPQUser::CountBuddies() const
{
    return m_pStorage ? m_pStorage->Buddies.GetCount() : 0;
}

bool XPQUser::IsBuddyListFull() const
{
    return MAX_BUDDIES == CountBuddies();
}

// Remove any pending or received buddy items
HRESULT XPQUser::CleanupBuddyData(const XPQUser *pUserBuddy)
{
    HRESULT hr = S_FALSE;
    const XPQBuddyData *pBuddy;
    const XPQBuddyData *pBuddyEnd;
    DWORD dwBuddyIndex = pUserBuddy->UserIndex();

    if(0 == pUserBuddy)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    pBuddy    = m_pStorage->Buddies.First();
    pBuddyEnd = m_pStorage->Buddies.End();

    while(pBuddy < pBuddyEnd)
    {
        if(pBuddy->dwBuddyIndex == dwBuddyIndex)
        {
            hr = m_pStorage->Buddies.Remove(pBuddy);
            if(FAILED(hr))
            {
                ERR3(User, "[XPQUser::CleanupBuddyData]: failed to remove buddy data on user: %I64x for buddy: %I64x, HR: 0x%08x",
                        UserId(),
                        pUserBuddy->UserId(),
                        hr);
            }
            pBuddyEnd = m_pStorage->Buddies.End();
            continue;
        }
        ++pBuddy;
    }

lbDone:
    return hr;
}

HRESULT XPQUser::AddBuddy(const XPQUser *pUserBuddy, BYTE bStatus)
{
    HRESULT hr;
    XPQBuddyData buddyOp;

    if(0 == pUserBuddy || bStatus > P_BUDDY_STATUS_REQUEST)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    switch(bStatus)
    {
    case P_BUDDY_STATUS_OK:
        if(FAILED(hr = CleanupBuddyData(pUserBuddy)))
        {
            ERR3(User, "[XPQUser::AddBuddy]: XPQUser::CleanupBuddyData() failed for user: %I64x, buddy: %I64x, HR: 0x%08x",
                    UserId(),
                    pUserBuddy->UserId(),
                    hr);
            goto lbDone;
        }
        buddyOp.bStatus         = bStatus;
        buddyOp.dwBuddyIndex    = pUserBuddy->UserIndex();
        m_pStorage->Buddies.Append(buddyOp);
        SetPoolFlags(USERPOOL_FULL_BUDDY_MASK, 0);
        break;
    case P_BUDDY_STATUS_PENDING:
        buddyOp.bStatus         = bStatus;
        buddyOp.dwBuddyIndex    = pUserBuddy->UserIndex();
        m_pStorage->Buddies.Append(buddyOp);
        SetPoolFlags(USERPOOL_PENDING_BUDDY_MASK, 0);
        break;
    case P_BUDDY_STATUS_REQUEST:
        buddyOp.bStatus         = bStatus;
        buddyOp.dwBuddyIndex    = pUserBuddy->UserIndex();
        m_pStorage->Buddies.Append(buddyOp);
        SetPoolFlags(USERPOOL_RECEIVED_BUDDY_MASK, 0);
        break;
    default:
        ERR3(User, "[XPQUser::AddBuddy]: Invalid buddy status: %d to AddBuddy(), User: %I64x, Buddy: %I64x",
                bStatus,
                UserId(),
                pUserBuddy->UserId());
        hr = E_INVALIDARG;
        break;
    }

lbDone:
    return hr;
}

HRESULT XPQUser::RemoveBuddy(const XPQUser *pUserBuddy)
{
    HRESULT hr;
    const XPQBuddyData *pBuddy;
    const XPQBuddyData *pBuddyEnd;
    DWORD dwBuddyIndex;
    DWORD cPending;
    DWORD cReceived;
    DWORD cFull;

    if(0 == pUserBuddy)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    pBuddy          = m_pStorage->Buddies.First();
    pBuddyEnd       = m_pStorage->Buddies.End();
    cReceived       = 0;
    cPending        = 0;
    cFull           = 0;
    dwBuddyIndex    = pUserBuddy->UserIndex();

    while(pBuddy < pBuddyEnd)
    {
        if(pBuddy->dwBuddyIndex == dwBuddyIndex)
        {
            if(FAILED(hr = m_pStorage->Buddies.Remove(pBuddy)))
            {
                ERR2(User, "[XPQUser::RemoveBuddy]: failed to remove buddy storage item for user: %I64x, HR: 0x%08x",
                        UserId(),
                        hr);
                goto lbDone;
            }
            pBuddyEnd = m_pStorage->Buddies.End();
            continue;
        }

        // Count other buddy operations to update our pool flags
        switch(pBuddy->bStatus)
        {
            case P_BUDDY_STATUS_PENDING:
                cPending++;
                break;
            case P_BUDDY_STATUS_REQUEST:
                cReceived++;
                break;
            case P_BUDDY_STATUS_OK:
                cFull++;
                break;

        }

        
        ++pBuddy;
    }

    // Clear pool flags when we run out of buddy operations
    if(0 == cPending)
    {
        SetPoolFlags(0, USERPOOL_PENDING_BUDDY_MASK);
    }
    if(0 == cReceived)
    {
        SetPoolFlags(0, USERPOOL_RECEIVED_BUDDY_MASK);
    }
    if(0 == cFull)
    {
        SetPoolFlags(0, USERPOOL_FULL_BUDDY_MASK);
    }

lbDone:
    return hr;
}

HRESULT XPQUser::GetFirstBuddyOperation(BYTE bStatus, const XPQBuddyData **ppOutBuddyOp)
{
    HRESULT hr = S_FALSE;
    const XPQBuddyData *pBuddy;
    const XPQBuddyData *pBuddyEnd;

    if(bStatus > P_BUDDY_STATUS_REQUEST || 0 == ppOutBuddyOp)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    pBuddy    = m_pStorage->Buddies.First();
    pBuddyEnd = m_pStorage->Buddies.End();

    while(pBuddy < pBuddyEnd)
    {
        if(bStatus == pBuddy->bStatus)
        {
            *ppOutBuddyOp = pBuddy;
            hr = S_OK;
            break;          
        }
        ++pBuddy;
    }

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// Block list operations
//------------------------------------------------------------------------------
HRESULT XPQUser::AddBlock(const XPQUser *pUser)
{
    HRESULT hr;
    XPQBlockData *pBlocks;  
    
    if(FAILED(hr = GetBlocks(&pBlocks)))
    {
        goto lbDone;
    }

    // Update the blocks with more memory if we need it
    if(pBlocks->dwcBlocks == XPQ_BLOCK_DATA_LIST_SIZE)
    {
        hr = S_FALSE;
        goto lbDone;
    }

    pBlocks->rgdwBlocks[pBlocks->dwcBlocks++] = pUser->UserIndex();
    SetPoolFlags(USERPOOL_BLOCK_DATA_MASK, 0);

    hr = S_OK;

lbDone:
    return hr;
}

HRESULT XPQUser::RemoveBlock(const XPQUser *pUser)
{
    HRESULT hr;
    XPQBlockData *pBlocks;
    DWORD *prgBlocks;
    DWORD dwcBlocks;
    DWORD dwiUser;
    DWORD i;

    if(FAILED(hr = GetBlocks(&pBlocks)))
    {
        goto lbDone;
    }

    if(0 == pBlocks)
    {
        hr = S_FALSE;
        goto lbDone;
    }

    dwiUser = pUser->UserIndex();
    dwcBlocks = pBlocks->dwcBlocks;
    prgBlocks = &(pBlocks->rgdwBlocks[0]);
    for(i = 0; i < dwcBlocks; ++i)
    {
        if(dwiUser == prgBlocks[i])
        {
            prgBlocks[i] = 0;
            prgBlocks[i] = prgBlocks[dwcBlocks-1];
            pBlocks->dwcBlocks--;
            break;
        }
    }

    if(0 == pBlocks->dwcBlocks)
    {
        hr = RemoveAllBlocks();
        goto lbDone;
    }

lbDone:
    return hr;
}

HRESULT XPQUser::RemoveAllBlocks()
{
    HRESULT hr;

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    if(m_pStorage->Blocks.GetCount() > 0)
    {
        hr = m_pStorage->Blocks.Remove((DWORD)0);
    }

    SetPoolFlags(0, USERPOOL_BLOCK_DATA_MASK);

lbDone:
    return hr;
}

HRESULT XPQUser::GetBlocks(XPQBlockData **ppOutBlocks)
{
    HRESULT hr;

    if(0 == ppOutBlocks)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    *ppOutBlocks = 0;

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    if(m_pStorage->Blocks.GetCount() > 0)
    {
        *ppOutBlocks = m_pStorage->Blocks.LockData();
        _ASSERTE(*ppOutBlocks);
        m_pStorage->Blocks.UnlockData();
        hr = S_OK;
    }
    else
    {
        // Create a new blocks data element
        XPQBlockData blocks;
        blocks.dwcBlocks    = 0;
        hr = m_pStorage->Blocks.Append(blocks, ppOutBlocks);
    }

lbDone:
    return hr;
}

//------------------------------------------------------------------------------
// Inivitation operations
//------------------------------------------------------------------------------

// Generate a hosted session index
HRESULT XPQUser::AddPendingInvite(XPQInviteData **ppOutInviteData, const XPQUser **rgpUsers, WORD wcUsers)
{
    HRESULT hr;
    XPQInviteData *pInvite;

    if(0 == ppOutInviteData)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    if(!GetOnlineStorage())
    { 
        hr = E_FAIL;
        goto lbDone;
    }

    // Clear any pending invites, we can only issue one invite at any
    // given time
    ClearPendingInvite();

    // Clamp wcUsers
    wcUsers = min(wcUsers, XPQ_INVITE_LIST_SIZE);

    m_qwMatchId = GenerateSessionId();
    m_dwMatchExpireTime = GetTickCount() + gpUserMgr->GenerateSessionExpiration();

    XPQInviteData invite;
    invite.dwFlags      = XPQ_INVITE_FLAGS_OWNER|XPQ_INVITE_FLAGS_PENDING;
    invite.dwExpire     = gpUserMgr->GenerateStateExpiration(USERPOOL_PENDING_INVITE_ID); 
    invite.dwHostIndex  = UserIndex();
    invite.dwTitleId    = TitleId();
    invite.qwSessionId  = m_qwMatchId;
    invite.wcUsers      = wcUsers;
    invite.wcPending    = wcUsers; // TODO: wanted to do decrement on each answer

    if(FAILED(hr = m_pStorage->Invites.Append(invite, &pInvite)))
    {
        goto lbDone;
    }

    // Append the user IDs
    DWORD *prgdwUserIndexes = pInvite->rgdwUsers;
    for(WORD i = 0; i < wcUsers; ++i)
    {
        prgdwUserIndexes[i] = rgpUsers[i]->UserIndex();
    }

    *ppOutInviteData = pInvite;

    SetPoolFlags(USERPOOL_PENDING_INVITE_MASK, 0);

lbDone:
    return hr;
}

HRESULT XPQUser::AddReceivedInvite(XPQUser *pFromHost, DWORD dwTitleId, ULONGLONG qwSessionId)
{
    HRESULT hr;
    XPQInviteData invite;

    invite.dwFlags      = XPQ_INVITE_FLAGS_RECEIVED;
    invite.dwExpire     = gpUserMgr->GenerateStateExpiration(USERPOOL_RECEIVED_INVITE_ID);
    invite.dwHostIndex  = pFromHost->UserIndex();
    invite.qwSessionId  = qwSessionId;
    invite.dwTitleId    = dwTitleId;
    invite.wcUsers      = 0;
    invite.wcPending    = 0;

    hr = m_pStorage->Invites.Append(invite);
    if(SUCCEEDED(hr))
    {
        SetPoolFlags(USERPOOL_RECEIVED_INVITE_MASK, 0);
    }

    return hr;
}

HRESULT XPQUser::RemoveReceivedInvite(const XPQUser *pFromHost)
{
    HRESULT hr;
    const XPQInviteData *pInvite;
    const XPQInviteData *pInviteEnd;

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    pInvite     = m_pStorage->Invites.First();
    pInviteEnd  = m_pStorage->Invites.End();

    while(pInvite < pInviteEnd)
    {
        if(XPQ_INVITE_FLAGS_RECEIVED == pInvite->dwFlags && pInvite->dwHostIndex == pFromHost->UserIndex())
        {
            m_pStorage->Invites.Remove(pInvite);
            pInviteEnd  = m_pStorage->Invites.End();
            continue;
        }

        ++pInvite;
    }

    hr = S_OK;

lbDone:
    return hr;
}


HRESULT XPQUser::GetPendingInvite(const XPQInviteData **ppOutInviteData) const
{
    HRESULT hr = S_FALSE;
    const XPQInviteData *pInvite;
    const XPQInviteData *pInviteEnd;

    if(0 == ppOutInviteData)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    *ppOutInviteData = 0;

    pInvite     = m_pStorage->Invites.First();
    pInviteEnd  = m_pStorage->Invites.End();

    while(pInvite < pInviteEnd)
    {
        if(0 != (XPQ_INVITE_FLAGS_PENDING & pInvite->dwFlags))
        {
            *ppOutInviteData = pInvite;
            hr = S_OK;
            break;
        }
        ++pInvite; 
    }

lbDone:
    return hr;
}

HRESULT XPQUser::GetReceivedInvite(const XPQUser *pHost, const XPQInviteData **ppOutInviteData) const
{
    HRESULT hr = S_FALSE;
    const XPQInviteData *pInvite;
    const XPQInviteData *pInviteEnd;
    DWORD dwHostIndex;

    if(0 == ppOutInviteData)
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    if(!GetOnlineStorage())
    {
        hr = E_FAIL;
        goto lbDone;
    }

    *ppOutInviteData = 0;

    pInvite     = m_pStorage->Invites.First();
    pInviteEnd  = m_pStorage->Invites.End();
    dwHostIndex = pHost ? pHost->UserIndex() : 0;

    while(pInvite < pInviteEnd)
    {
        if((0 == dwHostIndex || dwHostIndex == pInvite->dwHostIndex) && 0 != (XPQ_INVITE_FLAGS_RECEIVED & pInvite->dwFlags))
        {
            *ppOutInviteData = pInvite;
            hr = S_OK;
            break;
        }

        ++pInvite;
    }


lbDone:
    return hr;
}

void XPQUser::ClearAllInvites()
{
    m_pStorage->Invites.Clear();
}

void XPQUser::ClearPendingInvite()
{
    const XPQInviteData *pInvite;
    const XPQInviteData *pInviteEnd;

    _ASSERTE(0 != m_pStorage);

    pInvite     = m_pStorage->Invites.First();
    pInviteEnd  = m_pStorage->Invites.End();

    while(pInvite < pInviteEnd)
    {
        if(0 != (pInvite->dwFlags & XPQ_INVITE_FLAGS_PENDING))
        {
            m_pStorage->Invites.Remove(pInvite);
            break;
        }
        ++pInvite;
    }

    m_qwMatchId = 0;
    SetPoolFlags(0, USERPOOL_PENDING_INVITE_MASK);

}

ULONGLONG XPQUser::GenerateSessionId()
{
    ULONGLONG qwSessionId = TitleId();
    qwSessionId           = qwSessionId << 32;
    qwSessionId          |= (DWORD)UserIndex();

    return qwSessionId;
}

void XPQUser::LogoffCleanup()
{
    HRESULT hr;
    DWORD dwSPI = Spi();
	SetTitleId(0);

    if(INVALID_SPI != dwSPI)
    {
        // Not fatal operation, removing the user from the slot may not work if
        // logoff already removed the user
        hr = gpConnMgr->RemoveUserFromSlot(this);
        if(HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER) != hr && FAILED(hr))
        {
            ERR3(User, "[XPQUser::LogoffCleanup]: RemoveUserFromSlot() failed for user: %I64x, SPI: %08x, HR: 0x%08x",
                    UserId(),
                    dwSPI,
                    hr);
        }
        
        // If slot is empty release it
        if(FAILED(hr = gpConnMgr->ReleaseSlotIfEmpty(dwSPI)))
        {
            ERR3(User, "[XPQUser::LogoffCleanup]: ReleaseSlotIfEmpty() failed for user: %I64x, SPI: %08x, HR: 0x%08x",
                    UserId(),
                    dwSPI,
                    hr);
        }
    
        // Always clear the user SPI
        SetSpiInfo(INVALID_SPI, INVALID_SPI_SLOT_INDEX);
    }

    // Update user offline state and change the user's pool flags to place
    // them back in the offline pool.
    SetState(P_STATE_MASK_NONE);
    SetPoolFlags(USERPOOL_INFO_FLAGS_OFFLINE, USERPOOL_INFO_FLAGS_ONLINE);
    SetTitleDataLen(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\UserMgr.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2002 Microsoft.  ALL RIGHTS RESERVED
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

///////////////////////////////////////////////////////////
// XPQ User Manager
///////////////////////////////////////////////////////////

// Pointer to singleton instance
XPQUserMgr* XPQUserMgr::ms_pUserMgr = NULL;
XPQUserMgr *gpUserMgr = NULL;
DWORD gdwcUserTraces = 0;

DWORD rgdwUserFlags[] = 
{
    0x02006700, // en-US 
    0x0A001F00, // es-ES 
    0x08002200, // fr-FR 
    0x0C003200, // it-IT 
    0x04003500, // ja-JP 
    0x0E003800, // ko-KR 
    0x10006500, // zh-TW 
    0x12005400  // pt-PT 
};

// Ini File Settings
MGMT_DefineConfigSetting( UserMgr, Existing );
MGMT_DefineConfigSetting( UserMgr, PercentActive );
MGMT_DefineConfigSetting( UserMgr, MaxBuddies );

MGMT_DefineConfigSetting( UserMgr, PercentLogoffsComingRightBack );
MGMT_DefineConfigSetting( UserMgr, PercentLogonsInNewTitle );

MGMT_DefineConfigSetting( UserMgr, MinSessionMillis );
MGMT_DefineConfigSetting( UserMgr, MaxSessionMillis );

MGMT_DefineConfigSetting( UserMgr, PercentXenonUsers );
MGMT_DefineConfigSetting( UserMgr, PercentOnlyRichPresenceChanged );

MGMT_DefineLoggingCategory( UserMgr );

// Bucket names mapped from the USERPOOL_MASK ordinals
const char *rgszBucketNames[USERPOOL_MAX_ID] = 
{
    "PendingInvite",
    "ReceivedInvite",
    "Notification",
    "PendingMessage",
    "ReadMessage",
    "PendingBuddy",
    "ReceivedBuddy",
    "FullBuddy",
    "Team",
    "TeamMember",
    "TeamRecruit",
    "TitleData",
    "Blocks"
};


XPQUserMgr::XPQUserMgr() 
:   m_dwActiveUsers( 0L ),
    m_dwInactiveUsers( 0L ),  
    m_wNumBuddies( 0 ),
    m_dwMinQSize( 0L ),
    m_bKickOnError(true),
    m_prgUsers( NULL ),
    m_qwBaseUserId( 0L ),
    m_qwBaseXboxId( 0L ),
    m_dwUserCount( 0L ),
    m_pOnline( 0L ),
    m_pOffline( 0L ),
    m_dwcOnline( 0L ),
	m_dwcOffline( 0L ),
    m_dwcInuse( 0L ),
    m_dwcMaxInuse( 0L ),
    m_dwcXenonUsers( 0L ),
    m_dwcXboxUsers( 0L ),
	m_dwStateBitsUnchangedPct( 0L ),
    m_pLoggedOffUser(0),
	m_dwXenonUsersPct(0)
{
    if(NULL == ms_pUserMgr)
    {
        ms_pUserMgr = this;
        gpUserMgr = this;
    }
}

XPQUserMgr::~XPQUserMgr()
{
    Destroy(); 

    if(this == ms_pUserMgr)
    {
        ms_pUserMgr = NULL;
        gpUserMgr = NULL;
    }
}

HRESULT XPQUserMgr::Create( DWORD dwClientID, ULONGLONG qwBaseUserId, DWORD dwUserCount, HANDLE hStopEvent )
{
    HRESULT hr;

    _ASSERTE(0 != dwUserCount);
    _ASSERTE(INVALID_HANDLE_VALUE != hStopEvent);

    m_qwBaseUserId = qwBaseUserId;
    m_dwUserCount = dwUserCount;

    
    // Calcutlate Number of active users from target user count
    m_dwActiveUsers   = (m_dwUserCount * MGMT_GetConfigSetting(UserMgr, PercentActive).GetDWORD()) / 100;
    m_dwInactiveUsers = m_dwUserCount - m_dwActiveUsers;

    // Set the min user queue sizes to try to keep them balanced
    m_dwMinQSize = m_dwUserCount / 100; // 1%

    // Set the number of buddies each user should keep
    m_wNumBuddies = (WORD) MGMT_GetConfigSetting(UserMgr, MaxBuddies).GetDWORD();

    // Get session time bounds
    m_dwMinSessionMillis = MGMT_GetConfigSetting(UserMgr, MinSessionMillis).GetDWORD();
    m_dwMaxSessionMillis = MGMT_GetConfigSetting(UserMgr, MaxSessionMillis).GetDWORD();
    SetXenonPercentage(MGMT_GetConfigSetting(UserMgr, PercentXenonUsers).GetDWORD());
	SetStateBitsUnchangedPercentage(MGMT_GetConfigSetting(UserMgr, PercentOnlyRichPresenceChanged).GetDWORD());

    _ASSERTE(0 != m_dwMaxSessionMillis);
    _ASSERTE(0 != m_dwMinSessionMillis);
    _ASSERTE(m_dwMaxSessionMillis >= m_dwMinSessionMillis);

    TRACE5( UserMgr, L_HIGH, 
        "[XPQUserMgr::Create]: User count: %u, Active: %u, Inactive: %u, Min Queued: %u, Buddies: %u", 
        m_dwUserCount, 
        m_dwActiveUsers, 
        m_dwInactiveUsers,
        m_dwMinQSize, 
        m_wNumBuddies);

    TRACE2( UserMgr, L_HIGH, "[XPQUserMgr::Create]: MinSession: %u(ms), MaxSession: %u(ms)",
            m_dwMinSessionMillis, 
            m_dwMaxSessionMillis);

    // Allocate the user block and pool
    TRACE1( UserMgr, L_NORMAL, "[XPQUserMgr::Create]: allocating user pool data: %u users", m_dwUserCount );
    m_prgUsers = new XPQUser[m_dwUserCount];
    if(NULL == m_prgUsers) 
    {
        hr = E_OUTOFMEMORY;
        ERR0(UserMgr, "[XPQUserMgr::Create] allocate user block failed");
        goto lbDone;
    }

    //
    // Setup users, order links then shuffle the user pool
    //
    TRACE0(UserMgr, L_NORMAL, "[XPQUserMgr::Create]: shuffling user pool");
    DWORD *prgIndex = new DWORD[m_dwUserCount];
    for( DWORD dwi = 0; dwi < m_dwUserCount; ++dwi )
    {
        m_prgUsers[dwi].Create(dwi);
        m_prgUsers[dwi].SetPoolFlags(USERPOOL_INFO_FLAGS_OFFLINE);
        prgIndex[dwi] = dwi;
    }

    //
    // Shuffle the user buffer
    //
    DWORD dwTemp = 0;
    DWORD dwNext = 0;
    DWORD dwLast = 0;
    DWORD dwCount = m_dwUserCount * 3;
    while(dwCount > 0)
    {
        dwNext = rand() % (m_dwUserCount);
        dwTemp = prgIndex[dwNext];
        prgIndex[dwNext] = prgIndex[dwLast];
        prgIndex[dwLast] = dwTemp;
        dwLast = dwNext;
        --dwCount;
    }

    
    m_pOnline = NULL;
    m_pOnlineTail = NULL;
    m_dwcOffline = m_dwUserCount;

    // 
    // Create the offline linked list
    //

    m_pOffline = m_pOfflineTail = &m_prgUsers[prgIndex[0]];

    for( DWORD dwi = 1; dwi < m_dwUserCount; ++dwi )
    {
        XPQUser *pUser = &m_prgUsers[prgIndex[dwi]];

        pUser->m_pNext = m_pOffline;
        m_pOffline->m_pPrev = pUser;
        m_pOffline = pUser;
    }

    // Release Index
    SAFE_ARRAY_DELETE(prgIndex);  

    // Validate the offline pool    
    dwCount = 0;
    for(XPQUser *pUser = m_pOffline; pUser; pUser = pUser->m_pNext)
    {
        dwCount++;
    }
    _ASSERTE(dwCount == m_dwUserCount);

    // Create the fake logged off user to do dead user auth
    m_pLoggedOffUser = new XPQUser();

    // Create the state queues and set the default state timeouts
    for(DWORD i = 0; i < USERPOOL_MAX_ID; ++i)
    {
        if(FAILED(hr = m_rgStateQueues[i].Create(USERMGR_STATE_QUEUE_SIZE)))
        {
            ERR2(UserMgr, "[XPQUserMgr::Create]: failed to create state queue: %u, hr: 0x%08x", i, hr);
            goto lbDone;
        }

        m_rgdwStateExpirations[i] = USERMGR_STATE_TIMEOUT_DEFAULT;
    }

    hr = S_OK;

lbDone:
    TRACE0( UserMgr, L_NORMAL, "[XPQUserMgr::Create]: finished" );

    return hr;
}

void XPQUserMgr::Destroy()
{
    SAFE_ARRAY_DELETE(m_prgUsers);

    // Destroy the state queues
    for(DWORD i = 0; i < USERPOOL_MAX_ID; ++i)
    {
        m_rgStateQueues[i].Destroy();
    }
    m_pOnline = 0;
    m_pOffline = 0;
}

HRESULT XPQUserMgr::AquireUser(DWORD dwPoolFlags, XPQTaskResourceBlock &Resources, TaskResourceMark &Aquired)
{
    HRESULT hr;
    XPQUser *pUser;
    XPQUser **ppHead;
    XPQUser **ppTail;
    DWORD dwBucketId;
    
    if(0 == (dwPoolFlags & (USERPOOL_INFO_FLAGS_ONLINE|USERPOOL_INFO_FLAGS_OFFLINE|USERPOOL_INFO_FLAGS_OFFLINE_FOR_ALIVE)))
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    // False when we can't get a user, the default return code from this point
    hr = S_FALSE;

    //
    // Allocate a user from the offline pool with the intent to sign him in
    //
    if(0 != (dwPoolFlags & USERPOOL_INFO_FLAGS_OFFLINE_FOR_ALIVE))
    {
        // Don't allow more than active users online
        if(m_dwcOnline >= m_dwActiveUsers || 0 == m_pOffline)
        {
            goto lbDone;
        }

        hr = S_OK;
        pUser   = m_pOffline;
        AddUserToResourceBlock(
                dwPoolFlags,
                pUser,
                &m_pOffline,
                &m_pOfflineTail,
                Resources,
                Aquired);
        
        
        // Change the user title ID based on what we want them to be when we are allocating
        // a user for logon
        //
        // TODO: note that aquire slot will give the user the title of the
        // slot if you enable multiple people on a slot
        if((m_dwcXenonUsers == 0 && m_dwXenonUsersPct != 0) || m_dwcXenonUsers < (DWORD)(floor(0.01f * m_dwXenonUsersPct * (m_dwcXenonUsers + m_dwcXboxUsers))))
        {
            pUser->SetTitleId(XPQUser::kBaseXenonTitleId + (rand()  % XPQUser::kCountXenonTitles));
            m_dwcXenonUsers++;
        }
        else
        {
            pUser->SetTitleId(XPQUser::kBaseXboxTitleId + (rand()  % XPQUser::kCountXboxTitles));
			m_dwcXboxUsers++;
        }


        // Change the user flags locale
        DWORD dwSelector = rand() % (sizeof(rgdwUserFlags)/sizeof(DWORD));
        DWORD dwUserFlags = rgdwUserFlags[dwSelector];
        pUser->SetUserFlags(dwUserFlags);

        XPQUserOnlineStorage *pStorage = new XPQUserOnlineStorage();
        if(0 == pStorage)
        {
            hr = E_OUTOFMEMORY;
            goto lbDone;
        }


        if(FAILED(hr = pUser->AttachStorage(pStorage)))
        {
            ERR2(UserMgr, "[XPQUserMgr::AquireUser]: failed to attach storage to user: %I64x, HR: 0x%08x",
                    pUser->UserId(),
                    hr);
            goto lbDone;
        }

        // Generate a new spi data for the user from the connection manager
        if(FAILED(hr = gpConnMgr->AquireSlot(pUser)))
        {
            ERR2(UserMgr, "[XPQUserMgr::AquireUser]: failed to aquire slot data for user: %I64x, HR: 0x%08x",
                    pUser->UserId(),
                    hr);
            goto lbDone;
        }
        
        // Everything worked out, short cut the rest of this
        // method logic
        hr = S_OK;

        goto lbDone;
    }

    if(0 != (dwPoolFlags & USERPOOL_INFO_FLAGS_OFFLINE))
    {
        pUser   = m_pOffline;
        AddUserToResourceBlock(
                dwPoolFlags,
                pUser,
                &m_pOffline,
                &m_pOfflineTail,
                Resources,
                Aquired);
        // Everything worked out, short cut the rest of this
        // method logic
        hr = S_OK;

        goto lbDone; 
    }

    // 
    // If we don't want to do any bucket checks
    // simple pull the user from the top of the online
    // pool.
    //
    if(USERPOOL_INFO_FLAGS_ONLINE == dwPoolFlags)
    {
        if(0 == m_pOnline)
        {
            goto lbDone;
        }

        if(FAILED(hr = AllocateOnlineUser(dwPoolFlags, Resources, Aquired)))
        {
            goto lbDone;
        }

    }
    else
    {
        // 
        // Perform bucket checks
        //
        for(dwBucketId = 0; dwBucketId < USERPOOL_MAX_ID; ++dwBucketId)
        {
            if(0 == (dwPoolFlags & (1 << dwBucketId)))
            {
                continue;
            }

            hr = AllocateFromBucket(dwBucketId, dwPoolFlags, Resources, Aquired);
            if(FAILED(hr))
            {
                ERR2(UserMgr, "[XPQUserMgr::AquireUser]: AllocateFromBucket failed for pool flags: %08x, HR: 0x%08x", 
                        dwPoolFlags,
                        hr);
                goto lbDone;
            }
        }
    }

lbDone:
    return hr;
}

HRESULT XPQUserMgr::AllocateOnlineUser(DWORD dwPoolFlags, XPQTaskResourceBlock &Resources, TaskResourceMark &Aquired)
{
    XPQUser *pUser;
    XPQUser *pNext;
    XPQSlotInfo slot;
    HRESULT hr;

    // Start at the top of the pool, when no users or we run out
    // return default S_FALSE indicating resource failed alloc.
    pUser = m_pOnline;
    hr = S_FALSE;

    while(pUser)
    {

		// Move to the next item we can't get a lock on this user
        if(pUser->IsLocked())
        {
            pUser = pUser->m_pNext; 
			continue;
        }

		//
        // Check to make sure the user has not been kicked
        //
        if(FAILED(hr = gpConnMgr->GetSlotInfo(pUser->Spi(), slot)))
        {
            ERR2(UserMgr, "[XPQUserMgr::AllocateOnlineUser]: failed GetSlotInfo() for user: %I64x, spi: %08x",
                    pUser->UserId(),
                    pUser->Spi());
            goto lbDone;
        }

        if(slot.fKicked)
        {
            // Remove this user from the online pool, change their info flags
            // and pass them to release. Continue on to the next user.
            pNext = pUser->m_pNext; 

            UnlinkUser(pUser, &m_pOnline, &m_pOnlineTail);
            pUser->SetPoolFlags(0, USERPOOL_INFO_FLAGS_ONLINE);
            ReleaseUser(pUser, pUser->GetPoolFlags());

            pUser = pNext;

            continue;
        }

        // Found good user. This should not require very many iterations,
        // add them to the resource block and leave the loop.
        AddUserToResourceBlock(
                dwPoolFlags,
                pUser,
                &m_pOnline,
                &m_pOnlineTail,
                Resources,
                Aquired);

        hr = S_OK;

        break;
    }


lbDone:
    return hr;
}


HRESULT XPQUserMgr::AllocateFromBucket(DWORD dwBucketId, DWORD dwPoolFlags, XPQTaskResourceBlock &Resources, TaskResourceMark &Aquired)
{
    HRESULT hr;
    XPQUser *pUser;
    DWORD dwUserIndex;
    LockFreeFifo<DWORD> &queue = m_rgStateQueues[dwBucketId];
    DWORD count = queue.Count();

    // no matches
    hr = S_FALSE;

    while(queue.Dequeue(dwUserIndex) && count > 0)
    {
        count--;
        pUser = UserPtrFromIndex(dwUserIndex);

        if(0 == pUser)
        {
            ERR2(UserMgr, "[XPQUserMgr::AllocateFromBucket]: bucket: %u, invalid user index: %u",
                    dwBucketId,
                    dwUserIndex);
            continue;
        }

        // Move to the next item we can't get a lock on this user
        if(pUser->IsLocked())
        {
            // put the locked user back into the list for later processing.
            queue.Enqueue(dwUserIndex);
            continue;
        }

        // Skip users who are not online
        if(!pUser->HasPoolFlag(USERPOOL_INFO_FLAGS_ONLINE))
        {
            // when the user logs back on he will be added to the appropriate queues
            continue;
        }

        // Skip users who's state has been remove after it was
        // indexed
        if(!pUser->HasPoolFlag(1<<dwBucketId))
        {
            // this user no longer belongs in this queue
            continue;
        }

        // Got a user in a good state for an exclusive lock
        dwUserIndex = pUser->UserIndex();
        AddUserToResourceBlock(
                dwPoolFlags,
                pUser,
                &m_pOnline,
                &m_pOnlineTail,
                Resources,
                Aquired);

        //
        // Do special processing for specific bucket types to get 
        // attached users into the resource block
        //
        switch(dwBucketId)
        {
			default:
				hr = S_OK;
				break;
            case USERPOOL_PENDING_INVITE_ID:
                {
                    const XPQInviteData *pInvite;
                    hr = pUser->GetPendingInvite(&pInvite);
                    if(S_OK == hr)
                    {
                        _ASSERTE(0 != pInvite);
                        const DWORD *prgInvitees = pInvite->rgdwUsers;
                        _ASSERTE(pInvite->wcUsers > 0);
                        for(WORD i = 0; i < pInvite->wcUsers; ++i)
                        {
                            XPQUser *pInvitee = UserPtrFromIndex(prgInvitees[i]);
                            AddUserToResourceBlock(
                                    dwPoolFlags,
                                    pInvitee,
                                    NULL,
                                    NULL,
                                    Resources,
                                    Aquired);
                        }
                    }
                }
                break;
            case USERPOOL_RECEIVED_INVITE_ID:
                {
                    const XPQInviteData *pInvite;
                    hr = pUser->GetReceivedInvite(NULL, &pInvite);
                    if(S_OK == hr)
                    {
                        _ASSERTE(0 != pInvite);
                        XPQUser *pHost = UserPtrFromIndex(pInvite->dwHostIndex);
                        AddUserToResourceBlock(
                                dwPoolFlags,
                                pHost,
                                NULL,
                                NULL,
                                Resources,
                                Aquired);
                    }
                }
                break;
            case USERPOOL_PENDING_BUDDY_ID:
                {
                    const XPQBuddyData *pBuddyOp;
                    hr = pUser->GetFirstBuddyOperation(P_BUDDY_STATUS_PENDING, &pBuddyOp);
                    if(S_OK == hr)
                    {
                        XPQUser *pBuddy = UserPtrFromIndex(pBuddyOp->dwBuddyIndex);
                        AddUserToResourceBlock(
                                dwPoolFlags,
                                pBuddy,
                                NULL,
                                NULL,
                                Resources,
                                Aquired);
                    }
                }
            case USERPOOL_RECEIVED_BUDDY_ID:
                {
                    const XPQBuddyData *pBuddyOp;
                    hr = pUser->GetFirstBuddyOperation(P_BUDDY_STATUS_REQUEST, &pBuddyOp);
                    if(S_OK == hr)
                    {
                        XPQUser *pBuddy = UserPtrFromIndex(pBuddyOp->dwBuddyIndex);
                        AddUserToResourceBlock(
                                dwPoolFlags,
                                pBuddy,
                                NULL,
                                NULL,
                                Resources,
                                Aquired);
                    }
                }
                break;
            case USERPOOL_FULL_BUDDY_ID:
                {
                    const XPQBuddyData *pBuddyOp;
                    hr = pUser->GetFirstBuddyOperation(P_BUDDY_STATUS_OK, &pBuddyOp);
                    if(S_OK == hr)
                    {
                        XPQUser *pBuddy = UserPtrFromIndex(pBuddyOp->dwBuddyIndex);
                        AddUserToResourceBlock(
                                dwPoolFlags,
                                pBuddy,
                                NULL,
                                NULL,
                                Resources,
                                Aquired);
                    }
                }
            case USERPOOL_READ_MSG_ID:
                {
                    const XPQMessageData *pMessage;
                    hr = pUser->GetFirstMessage(XPQ_MESSAGE_STATE_READ, &pMessage);
                    if(S_OK == hr)
                    {
                        XPQUser *pSender = UserPtrFromIndex(pMessage->dwSenderIndex);
                        AddUserToResourceBlock(
                                dwPoolFlags,
                                pSender,
                                NULL,
                                NULL,
                                Resources,
                                Aquired);
                    }
                }
                break;
            case USERPOOL_BLOCK_DATA_ID:
                {
                    XPQBlockData *pBlocks;
                    hr = pUser->GetBlocks(&pBlocks);
                    if(S_OK == hr)
                    {
                        if(pBlocks->dwcBlocks == 0)
                        {
							hr = S_FALSE;
						}
						else
						{
                            DWORD dwUserIndex = pBlocks->rgdwBlocks[0];
                            XPQUser *pBlock = UserPtrFromIndex(dwUserIndex);
                            AddUserToResourceBlock(
                                    dwPoolFlags,
                                    pBlock,
                                    NULL,
                                    NULL,
                                    Resources,
                                    Aquired);

                        }
                    }
                }
                break;
        }

        // Leave the loop, either failed or S_FALSE or got a user S_OK here
        break;
    }

    return hr;
}

void XPQUserMgr::AddUserToResourceBlock(
                DWORD dwPoolFlags,
                XPQUser *pUser, 
                XPQUser **ppHead, 
                XPQUser **ppTail,
                XPQTaskResourceBlock &Resources, 
                TaskResourceMark &Aquired)
{
    if(0 != pUser && ppHead && ppTail)
    {
        DBG2(UserMgr, "[XPQUserMgr::AddUserToResourceBlock]: aquired lock for user: %I64x, pool flags: 0x%08x",
                pUser->UserId(),
                dwPoolFlags);

        //
        // Do book-keeping
        //
        if(0 != (dwPoolFlags & USERPOOL_INFO_FLAGS_ONLINE))
        {
            --m_dwcOnline;
            ++m_dwcInuse;
            Resources.AddOnlineUser(pUser);
            Aquired.dwNumOnline++;
            _ASSERTE(pUser->HasValidSpi());
        }
        else
        {
            --m_dwcOffline;
            ++m_dwcInuse;
            Resources.AddOfflineUser(pUser);
            Aquired.dwNumOffline++;
        }

        if(m_dwcInuse > m_dwcMaxInuse)
        {
            m_dwcMaxInuse = m_dwcInuse;
        }

        pUser->Lock();
        UnlinkUser(pUser, ppHead, ppTail);

        USERTRACE1(pUser->UserId(), "Aquired write access for pool flags: 0x%08x", dwPoolFlags);
    }
    else
    {
        // Read-only doesn't lock or unlink the user
        Resources.AddUser((const XPQUser*)pUser);

        USERTRACE1(pUser->UserId(), "Aquired read access for pool flags: 0x%08x", dwPoolFlags);
    }
}

void XPQUserMgr::LinkUser(XPQUser *pUser, XPQUser **ppHead, XPQUser **ppTail)
{
    if(*ppTail)
    {
        pUser->m_pPrev = *ppTail;
        (*ppTail)->m_pNext = pUser;
        *ppTail = pUser;
    }
    else
    {
        (*ppHead) = pUser;
        (*ppTail) = pUser;
    }
}

void XPQUserMgr::UnlinkUser(XPQUser *pUser, XPQUser **ppHead, XPQUser **ppTail)
{
    //
    // Unlink the user from the list
    //
    if(pUser->m_pNext)
    {
        pUser->m_pNext->m_pPrev = pUser->m_pPrev;
    }

    if(pUser->m_pPrev)
    {
        pUser->m_pPrev->m_pNext = pUser->m_pNext;
    }

    // 
    // Replace head of list
    //
    if(pUser == *ppHead)
    {
        // we're at the head of the list
        *ppHead = pUser->m_pNext;
        if(*ppHead)
        {
            (*ppHead)->m_pPrev = 0;
        }
    }

    // 
    // Replace tail of list
    //
    if(pUser == *ppTail)
    {
        *ppTail = pUser->m_pPrev;
        if(*ppTail)
        {
            (*ppTail)->m_pNext = 0;
        }
    }

    //
    // Remove user links and lock for usage
    //
    pUser->m_pNext = 0;
    pUser->m_pPrev = 0;
}

HRESULT XPQUserMgr::ReleaseUser(XPQUser *pUser, DWORD dwPoolFlags)
{
    HRESULT hr;

    if(0 == pUser || 0 == (dwPoolFlags & USERPOOL_INFO_FLAGS_ONLINE|USERPOOL_INFO_FLAGS_OFFLINE))
    {
        hr = E_INVALIDARG;
        goto lbDone;
    }

    
    if(0 != (dwPoolFlags & USERPOOL_INFO_FLAGS_ONLINE))
    {
        _ASSERTE(pUser->HasPoolFlag(USERPOOL_INFO_FLAGS_ONLINE));
        LinkUser(pUser, &m_pOnline, &m_pOnlineTail);

        _ASSERTE(pUser->HasValidSpi());

        ++m_dwcOnline;

        // Unpack any deferred qvals 
        pUser->ProcessDeferredQVals();

        hr = pUser->CleanupStorage(); 
        if(FAILED(hr))
        {
            ERR2(UserMgr, "[XPQUserMgr::CleanupStorage]: failed for user: %I64x, hr: 0x%08x",
                    pUser->UserId(),
                    hr);
        }

        // Unpack the pool flags to notify the allocator of new
        // state data
        DWORD dwPoolFlags = pUser->GetPoolFlags();
        for(DWORD i = 0; i < USERPOOL_MAX_ID; ++i)
        {
            if(0 != (dwPoolFlags & 1<<i))
            {
                m_rgStateQueues[i].Enqueue(pUser->UserIndex());
            }
        }

    }
    else
    {   
        _ASSERTE(pUser->HasPoolFlag(USERPOOL_INFO_FLAGS_OFFLINE));
		// They are no longer counted against our xenon users (we only account against
        // activae users)
        if(pUser->IsXenonTitleId())
        {
            --m_dwcXenonUsers;
        }
		else if(pUser->TitleId() != 0)
		{
			--m_dwcXboxUsers;
		}

        pUser->LogoffCleanup();
        
        LinkUser(pUser, &m_pOffline, &m_pOfflineTail);
        
        ++m_dwcOffline;

        // Detach the user storage record and release memory
        XPQUserOnlineStorage *pUserStorage;
        if(FAILED(hr = pUser->DetachStorage(&pUserStorage)))
        {
            ERR2(UserMgr, "[XPQUserMgr::ReleaseUser]: failed to detach storage for user: %I64x, hr: 0x%08x",
                    pUser->UserId(),
                    hr);

            // Fallthrough
        }
        SAFE_DELETE(pUserStorage);
    }

lbDone:

    if(0 != pUser)
    {
        pUser->Unlock();
        --m_dwcInuse;
    }

    return hr;
}

HRESULT XPQUserMgr::NotifyState(const XPQUser *pUser, DWORD dwBucketId)
{
    if(dwBucketId < USERPOOL_MAX_ID)
    {
        return m_rgStateQueues[dwBucketId].Enqueue(pUser->UserIndex());
    }
    else
    {
        return E_INVALIDARG;
    }
}

void  XPQUserMgr::LogStats() const
{
    TRACE5(UserMgr, L_OOB, "[XPQUserMgr::LogStats]: Online: %u (Xe: %u), Offline: %u, Inuse: %u, MaxInuse: %u",
        m_dwcOnline,
        m_dwcXenonUsers,
        m_dwcOffline,
        m_dwcInuse,
        m_dwcMaxInuse);

    //
    // Skip offline and online they are not used, represented by default user pools
    //
    for(DWORD i = USERPOOL_PENDING_INVITE_ID; i < USERPOOL_MAX_ID; ++i)
    {
        TRACE3(UserMgr, L_OOB, "[XPQUserMgr::LogStats]: Bucket: %u: %s, Count: %u",
                i, 
                rgszBucketNames[i], 
                m_rgStateQueues[i].Count());
    }
}

DWORD XPQUserMgr::GenerateSessionExpiration() 
{
    DWORD dwDuration = (rand() % (m_dwMaxSessionMillis - m_dwMinSessionMillis)) + m_dwMinSessionMillis;
    return GetTickCount() + dwDuration;
}

DWORD XPQUserMgr::GenerateStateExpiration(DWORD dwBucketId)
{
    _ASSERTE(dwBucketId < USERPOOL_MAX_ID);
    DWORD dwTicks = m_rgdwStateExpirations[dwBucketId];
    return GetTickCount() + dwTicks;
}

DWORD XPQUserMgr::SetStateExpirationTicks(DWORD dwBucketId, DWORD dwMaxTicks)
{
    DWORD dwOldValue = m_rgdwStateExpirations[dwBucketId];
    m_rgdwStateExpirations[dwBucketId] = dwMaxTicks;
    return dwOldValue;
}

void XPQUserMgr::SetXenonPercentage(DWORD dwPercent) 
{
	m_dwXenonUsersPct = dwPercent;
}

void XPQUserMgr::SetStateBitsUnchangedPercentage(DWORD dwPercent) 
{
	m_dwStateBitsUnchangedPct = dwPercent;
}

DWORD XPQUserMgr::GetStateBitsUnchangedPercentage()
{
	return m_dwStateBitsUnchangedPct;
}

//------------------------------------------------------------------------------
// User debug tracing
//------------------------------------------------------------------------------


static QWORD rgqwUserTraces[USERTRACES_MAX];
static DWORD rgdwUserTraceHits[USERTRACES_MAX];
bool XPQUserMgr::AddUserTrace(XPQUser *pUser) 
{
    if(gdwcUserTraces < USERTRACES_MAX)
    {
        rgqwUserTraces[gdwcUserTraces]      = pUser->UserId();
        rgdwUserTraceHits[gdwcUserTraces]   = 0;
        gdwcUserTraces++;

        return true;
    }
    else
    {
        return false;
    }
}

bool XPQUserMgr::RemoveUserTrace(DWORD dwTraceIndex)
{
    if(dwTraceIndex < gdwcUserTraces)
    {
        rgqwUserTraces[dwTraceIndex]       = rgqwUserTraces[gdwcUserTraces-1];
        rgdwUserTraceHits[dwTraceIndex]    = rgdwUserTraceHits[gdwcUserTraces-1];
        gdwcUserTraces--;

        return true;
    }
    else
    {
        return false;
    }
}

void XPQUserMgr::ShowUserTraces()
{
    for(DWORD i = 0; i < gdwcUserTraces; ++i)
    {
        printf("[%u]: 0x%I64x (hits: %u)\n", i, rgqwUserTraces[i], rgdwUserTraceHits[i]);
    }
}

void XPQUserMgr::UserTrace(QWORD qwUserId, const char *pszFormat, ... )
{
    va_list ap;
    
    va_start(ap, pszFormat);
    for(DWORD i = 0; i < gdwcUserTraces; ++i)
    {
        if(qwUserId == rgqwUserTraces[i])
        {
            rgdwUserTraceHits[i]++;
            printf("[%u] [%I64x] ", i, qwUserId);
            vprintf(pszFormat, ap);
        }
    }
    va_end(ap);
}

XPQUser* XPQUserMgr::UserPtrFromIndex(DWORD dwI) const
{
    _ASSERTE(dwI < m_dwUserCount); 
    return &m_prgUsers[ dwI ];
}

XPQUser* XPQUserMgr::UserPtrFromId( ULONGLONG qwUserId ) const
{ 
    DWORD dwIndex = (DWORD)(qwUserId - m_qwBaseUserId); 
    if( dwIndex >= m_dwUserCount)
    {
        TRACE3( 
            UserMgr, L_HIGH, 
            "XPQUserMgr::UserPtrFromId() - PUID is not valid: %I64x has index %lu greater than max %lu", 
            qwUserId, 
            dwIndex, 
            m_dwUserCount-1);
        return NULL;        
    }
    
    return &m_prgUsers[ dwIndex ];
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\Worker.cpp ===
#include "stdafx.h"

MGMT_ImportLoggingCategory( TaskMgr );




//------------------------------------------------------------------------------
//
// WorkerTaskThread
//
WorkerTaskThread::WorkerTaskThread() :
    m_pScheduler(0),
    m_pCP(0),
    m_HandleIoAvg("HandleIoAvg"),
    m_Completions("Completions")
{
}

WorkerTaskThread::~WorkerTaskThread()
{
    SAFE_RELEASE(m_pCP);
}

void WorkerTaskThread::SetScheduler(SchedulerTaskThread *pScheduler)
{
    m_pScheduler = pScheduler;
}

void WorkerTaskThread::SetCompletionPort(CompletionPort *pCP)
{
    SAFE_REPLACEREF(m_pCP, pCP);
}

HRESULT WorkerTaskThread::PostCompletedTask(XPQTask *pTask)
{
    HRESULT hr;

    hr = m_pScheduler->PostCompletedTask(pTask);
    if(FAILED(hr))
    {
        ERR1(TaskMgr, "[WorkerTaskThread::PostCompletedTask]: SchedulerTaskThread::PostCompletedTask() failed on scheduler thread, manually releasing task, HR: 0x%x08x", hr);
    }

    return hr;
}

void WorkerTaskThread::LogStats() const
{
    TRACE3(TaskMgr, L_OOB, "Worker[%05u]: Completions: (%4.2f/s) HandleIoTime(avg): %2.8fs",
            m_uiThread,
            m_Completions.fRate,
            m_HandleIoAvg.fAverage);
}

void WorkerTaskThread::RunInternal()
{
    XPQStress *pStress;
    XPQTaskMgr *pTaskMgr;
    XPQTask *pTask;
    DWORD dwTransferred;
    ULONG_PTR ulpKey;
    OVERLAPPED *pOV;
    HRESULT hr;
    bool bCompletionDelivered;
    float fWorkerElapsed;

    ScopeTimer  WorkerElapsed("WorkerElapsed");
    ScopeTimer  HandleIoTimer("HandleIoTimer");

    pStress  = XPQStress::GetPtr();
    pTaskMgr = XPQTaskMgr::GetPtr();

    _ASSERTE(NULL != m_pScheduler);
    _ASSERTE(NULL != pStress);
    _ASSERTE(NULL != pTaskMgr);

    WorkerElapsed.Enter();

    // Continue until signaled
    while( WAIT_TIMEOUT == WaitForSingleObject( m_hStopEvent, 0 ) )
    {
        hr = m_pCP->GetQueuedCompletion(&dwTransferred, &ulpKey, &pOV, INFINITE);
        if(FAILED(hr))  
        {
            DWORD dwError = HRESULT_CODE(hr);
            if(dwError == WAIT_TIMEOUT)
            {
                continue;
            }

            // A socket operation has invalidated this completion context, alert the task 
            // of failure and transition to allow cleaning up this task context on another
            // completion
            if(     WAIT_TIMEOUT != dwError 
                &&  ERROR_NETNAME_DELETED != dwError 
                &&  ERROR_IO_PENDING != dwError 
                &&  ERROR_DUP_NAME != dwError
                &&  ERROR_OPERATION_ABORTED != dwError
                &&  WSAECONNABORTED != dwError
                &&  ERROR_SEM_TIMEOUT != dwError
                &&  ERROR_CONNECTION_REFUSED != dwError
                &&  ERROR_CONNECTION_ABORTED != dwError)
            {
                ERR1(TaskMgr, "[WorkerTaskThread::RunInternal]: GetQueuedCompletion failed, HR: 0x%08x", hr);
                pStress->AllStop();
                continue;
            }

            DBG3(TaskMgr, "[WorkerTaskThread::RunInternal]: GetQueuedCompletion() ignoring negative HR: 0x%08x, Task: [%u] %s",
                    hr,
                    pTask ? pTask->ID() : 0,
                    pTask ? pTask->Name() : "<NULL>");
        }

        pTask = (XPQTask *)pOV;
        if(0 == pTask)
        {
            ERR0(TaskMgr, "[WorkerTaskThread::RunInternal]: overlapped return from queued completion was NULL");
            continue;
        }

        HandleIoTimer.Enter();
        bCompletionDelivered = false;

        // Determine type of task completion (IO or App)
        //
        // 0 based ulpKey signals a task posted on the main completion port
        // where a handle has not been associated with port
        //
        if(0 == ulpKey)
        {
            hr = pTask->Run();
            
            TRACE4(TaskMgr, L_NORMAL, "[WorkerTaskThread::RunInternal]: Worker: [%u] XPQTask::Run(): %s [%u], HR: 0x%08x", 
                    m_uiThread,
                    pTask->Name(),
                    pTask->ID(),
                    hr);
        }
        else if(!pTask->SendToINH())
        {
            // Pass in completion delivered flag so we know which thread
            // actual completed the request if we leave checking the completion
            // for a post check validation than we risk having a race condition
            // between the thread that disconnect and queued the final receive
            // and the second thread that actually sets a completion member
            hr = pTask->HandleIo(dwTransferred, &bCompletionDelivered);

            TRACE7(TaskMgr, L_NORMAL, "[WorkerTaskThread::RunInternal]: Worker: [%u] XPQTask::HandleIo(): %s [%u], HR: 0x%08x, connstate: %u, sockop: %u, transferred: %u", 
                    m_uiThread,
                    pTask->Name(),
                    pTask->ID(),
                    hr, 
                    ((FdConnection*)pTask->GetConnection())->State(),
                    pTask->dwOperation,
                    dwTransferred);
        }
		else if(pTask->SendToINH())
		{
			bCompletionDelivered = true;
		}
        HandleIoTimer.Leave();

        // Record time sample and completion
        m_HandleIoAvg.SampleValue(HandleIoTimer.fCaptured);
        ++m_Completions;

        // Check if it's time to poll our completion rate
        WorkerElapsed.Capture(&fWorkerElapsed);
        if(fWorkerElapsed > 5.0)
        {
            m_Completions.Poll(fWorkerElapsed);
            WorkerElapsed.Enter();
        }

        if(bCompletionDelivered || FAILED(hr))
        {
			if(!pTask->SendToINH())
			{
				FdConnection *fdConn = (FdConnection*)pTask->GetConnection();
				TRACE7(TaskMgr, L_DEBUG, "[WorkerTaskThread::RunInternal]: XPQTask::HandleIo() finished: %s [%u], HR: 0x%08x, connstate: %u, sockop: %u, transferred: %u, lastop(ms): %u", 
						pTask->Name(),
						pTask->ID(),
						hr, 
						fdConn->State(),
						pTask->dwOperation,
						dwTransferred,
						GetTickCount() - fdConn->LastOpStartTicks());
			}

            // Always cause the task to transition when we have a failure
            pTask->Completed(hr);

			if(bCompletionDelivered || hr == E_FAIL)
			{
				while(FAILED(hr = m_pScheduler->PostCompletedTask(pTask)))
				{
					ERR1(TaskMgr, "[WorkerTaskThread::RunInternal]: SchedulerTaskThread::PostCompletedTask() failed: HR: 0x%08x", hr);
					Sleep(0);
				}
			}
			else
			{
				// failed. Throw on a failed queue for timed completion
				while(FAILED(hr = m_pScheduler->PostFailedTask(pTask)))
				{
					ERR1(TaskMgr, "[WorkerTaskThread::RunInternal]: SchedulerTaskThread::PostFailedTask() failed: HR: 0x%08x", hr);
					Sleep(0);
				}
			}
        }
    }
    TRACE1( TaskMgr, L_NORMAL, "[WorkerTaskThread::RunInternal()]: thread [%d] exiting", GetCurrentThreadId() );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\scratch\HashedCritSec.cpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\XPQStress.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright  2002 Microsoft.  ALL RIGHTS RESERVED
/////////////////////////////////////////////////////////////////////////////
#pragma once

// Global logging areas
MGMT_ImportLoggingCategory( Log );
MGMT_ImportLoggingCategory( Debug );
MGMT_ImportLoggingCategory( QFlag );
MGMT_ImportLoggingCategory( Event );

/////////////////////////////////////////////////
// XPQ Stress 
//  UI independet object that does all the work
//
class XPQStress
{
public:

    XPQStress();
    ~XPQStress();
    
    static XPQStress* GetPtr() { return ms_pStress; }

    HRESULT Create();
    void Destroy();

    
    void   AllStop();     
    bool   IsStopping();   
    HANDLE GetStopEvent() const; 

    void LogErrorText( 
        const char* pszText,
        XPQUser*    pUser,
        XPQTask*    pTask);

    void LogMemoryError( 
        const char* pszContext,
        const char* pszObject,
        XPQUser*    pUser,
        XPQTask*    pTask);

    void LogHR( 
        const char* pszContext,
        XPQUser*    pUser,
        XPQTask*    pTask,
        HRESULT     hr );

    void LogTcpError( 
        const char*          pszOperation,
        TCPClientConnection* pFDClient, 
        XPQUser*             pUser, 
        XPQTask*             pTask,
        int                  iLastError );

    void LogHttpError( 
        TCPClientConnection* pFDClient, 
        XPQUser*             pUser, 
        XPQTask*             pTask,
        DWORD                dwXErr );

private:

    // pointer to singleton instance.
    static XPQStress* ms_pStress;

    // Lock down object creation, destruction, and assignmetn.  There can be only one.
    
    XPQStress( const XPQStress& );            // No implementaion
    XPQStress& operator=( const XPQStress& ); // No implementaion

    // Event that should be used to signal all stop
    HANDLE m_hStopEvent;
    //CComPtr<IConfig> m_pConfig;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\scratch\HashedCritSec.h ===
class XOHashedCritSec
{
public:
    static Create();

private:
    
    XOHashedCritSec();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\fd\installers.cs ===
using xonline.common.installer;
using xonline.common.config;

namespace xonline.server.query.fd 
{
    public class QueryFrontdoorExternal : XomIisConfigurator
    {
        public QueryFrontdoorExternal()
        {
            interfaceKey    = xonline.common.config.Interface.xqry;
        }
    }
    
    
    public class QueryFrontdoorInternal : XomIisConfigurator
    {
        public QueryFrontdoorInternal()
        {
            interfaceKey    = xonline.common.config.Interface.xqry_int;
        }
    
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\taskserver\scratch\WaitEventArray.h ===
/////////////////////////////////////////////////
//  Wait Event Array
//
//  Allows simple fast manipualtion of event arrays for 
//  use with WSAWaitForMultipleEvents.
//
struct XPQWaitEventArray
{
    ///////////////////////////////////
    // Ctor
    //
    explicit XPQWaitEventArray( 
        DWORD dwMaxEvents )
    :
        m_dwEvents( 0L ),
        m_dwMaxEvents( dwMaxEvents )
    {
        m_aEvents = new WSAEVENT[ m_dwMaxEvents ];
        _ASSERTE( NULL != m_aEvents );
    }

    ///////////////////////////////////
    // Dtor
    //
    ~XPQWaitEventArray()
    {
        delete[] m_aEvents;
    }

    ///////////////////////////////////
    // Add
    //
    void Add( const WSAEVENT& rEvent )
    {
        _ASSERTE( m_dwEvents < m_dwMaxEvents );
        memcpy( m_aEvents[ m_dwEvents++ ], &rEvent, sizeof( WSAEVENT ));
    }

    ///////////////////////////////////
    // Remove
    //
    // TBD - Shouldn't need to use this since remove will usually come
    //       after a lookup and the index will be known.  May want to add a 
    //       map for quick lookup otherwise.
    //
    void Remove( const WSAEVENT& rEvent )
    {
        DWORD dwRemove;
        for( dwRemove = 0, dwRemove < m_dwEvents; ++dwRemove )
        {
            if( 0 == memcmp( &rEvent, m_aEvents[ dwRemove ], sizeof( WSAEVENT ) ) )
            {
                break;
            }
        }
        Remove( dwRemove );
    }

    ///////////////////////////////////
    // Remove
    //
    void Remove( DWORD dwRemove )
    {
        _ASSERTE( (dwRemove >= 0) && (dwRemove < m_dwEvents) );
        memmove( 
            m_aEvents[ dwRemove ], 
            m_aEvents[ dwRemove + 1 ],
            (m_dwEvents - (dwRemove + 1)) * sizeof( WSAEVENT ) );
        --m_dwEvents;
    }

    ///////////////////////////////////
    // Remove
    //
    WSAEVENT& Lookup( DWORD dwWaitResult, DWORD* pIndex )
    {
        *pIndex = dwWaitResult - WSA_WAIT_EVENT_0;
        _ASSERTE( (*pIndex >= 0) && (*pIndex < dwEvents) );
        return( m_aEvents[ *pIndex ] );
    }

    ///////////////////////////////////

    DWORD      m_dwEvents;
    WSAEVENT[] m_aEvents;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\teamsfunc\TeamsTest.cs ===
using System;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;

namespace TeamsTest
{
	/// <summary>
	/// <TestSuite>Teams Test Plan (Presence Server)</TestSuite>
	///	<Tester>Jacob Repp</Tester>
	///	<Developer>Matt Childerston</Developer>
	///	<Developer>Peter Hansen</Developer>
	///	<PM>James Jen</PM>
	///	<Status>Draft</Status>
	/// </summary>
	///	<remarks>
	///	<Goal>Functional positive and negative test cases covering V2 and V3 teams features.</Goal>
	///	<Goal>Test code validation of Profile-UODB partitioning.</Goal>
	///	<Goal>Test code validation of Profile-UODB table data.</Goal>
	///	<NonGoal>Test of container environment (.NET, ASP.NET, IIS, Windows).</NonGoal>
	///	<NonGoal>Test of NT service startup/shutdown</NonGoal>
	///	<NonGoal>Test of internal INH only messages that are not exposed on the front-door</NonGoal>
	///	<Description>
	///		<p>
	///			Teams functional tests cover all of the 'PMSG_TEAM' messages that are exposed 
	///		on the presence front door. These are as follows:
	///		</p>
	///
	///		<p>
	///		<table class="test_data">
	///			<tr><td>TeamListTeams       </td><td>List all teams for user in a given title</td></tr>
	///			<tr><td>TeamListMembers     </td><td>List all members for a team</td></tr>
	///			<tr><td>TeamCreate          </td><td>Create a new team for a specific title</td></tr>
	///			<tr><td>TeamDelete          </td><td>Delete a specific team</td></tr>
	///			<tr><td>TeamRemove          </td><td>Remove a member from a team</td></tr>
	///			<tr><td>TeamManageTeam      </td><td>Change some mutable properties of a team</td></tr>
	///			<tr><td>TeamManageMember    </td><td>Change some mutable properties of a team member</td></tr>
	///			<tr><td>TeamRecruit         </td><td>Request a user be recruited to a team</td></tr>
	///			<tr><td>TeamJoin            </td><td>Acknoledge an outstanding team recruit</td></tr>
	///			<tr><td>TeamGetTicket       </td><td>Get a blob of data with per user member data for integration sanity</td></tr>
	///			<tr><td>TeamCreateXe        </td><td>(Deprecated) Create a cross-title team</td></tr>
	///			<tr><td>TeamManageXe        </td><td>(Deprecated) Change some mutable cross-title team properties</td></tr>
	///			<tr><td>TeamListUserTeams   </td><td>List all teams and outstanding team recruits for a user</td></tr>
	///		</table>
	///		</p>
	/// </Description>
	/// </remarks>
    /// 
    [Owner("shailesh"), TestFrequency("Regression"), TestCasePriority(3), ServerTestFramework.Description("Teams test case")]
	public class TeamsTest : TestSuite 
	{
		/// <summary>
		/// Setup for Stress Suite
		///	</summary>
		public override void InitializeStress( XmlDocument config ) 
		{
		}

		/// <summary>
		/// Create Stress Test List
		///	</summary>
		public override StressTestBaseList GetStressTests()
		{
			StressTestBaseList tests = new StressTestBaseList();

			return tests;
		}	

		/// <summary>
		/// Setup for Functional Suite
		///	</summary>
		public override void Initialize( XmlDocument config ) 
		{
			// make sure we don't have any required regional messages left over (this killed regressions once)
			SystemMsgFolder.DeleteAll( 10/*MsgTestUtil.DefaultSystemTitleID*/, SystemMessage.RevokeAlso.Yes );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\fd\remove.cs ===
// 
// Remove.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// xqry Front Door
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Web;
using System.Text;
using System.IO;
using System.Diagnostics;
using xonline.common.config;
using xonline.common.plugins;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.querylib;


namespace xonline.server.query.fd 
{
    public class Remove : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //      
        //      the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            RemoveCounters counters = new RemoveCounters();
            RemoveRequest req = new RemoveRequest();
            string logline;
            int i;
            HResult hr = HResult.XONLINE_E_QUERY_ERROR;

            
            try
            {
                counters.StartRequest(0);
                
                // check and fetch the source of the call                                               
                string            viface = CallSource.Check(VirtualInterface.xqry, VirtualInterface.xqry_int);  
                Source            source = Dataset.SourceFromRequest(viface, ctx);
                
                
                // read request header
                //
                req.ReadFromRequest(ctx.Request);                                
                
                // start counters with the actual title id                                               
                counters.StartRequest(req.titleId);
                
                // only verify sg info when coming in as an internet call..
                if (viface == VirtualInterface.xqry)
                {
                    SGInfo.VerifyTitleId(req.titleId);
                    SGInfo.VerifyUserId(req.userId);
                }
                
                //
                // Verify team id
                //
                if ((req.teamId != 0) && (viface != VirtualInterface.xqry_int))
                {
                    TeamTickets teamTickets = new TeamTickets(new BinaryReader(ctx.Request.InputStream));
                    if (viface == VirtualInterface.xqry)
                    {
                        teamTickets.VerifyTickets();
                    }
                    teamTickets.VerifyMembershipThrow(req.userId, req.teamId);
                }

                hr = Dataset.InternalRemove(source, req.titleId, req.userId, req.teamId, req.datasetId, req.procIndex, req.attribs);
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {                        
                logline = "REM|" + 
                    hr + "|" +
                    req.titleId.ToString("x8") + "|" + 
                    req.userId.ToString("x16") + "|" +
                    req.teamId.ToString("x16") + "|" + 
                    req.datasetId.ToString()   + "|";
                    
                    
                // Remove attributes
                if (null != req.attribs)
                {
                    for (i = 0; i < req.attribs.Length; i++)
                    {
                        if (i > 0) logline += ";";                
                        logline += req.attribs[i].Id + ",";
                        switch(req.attribs[i].Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                        {
                        case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: logline += req.attribs[i].lValue; break;
                        case XOn.X_ATTRIBUTE_DATATYPE_STRING: logline += req.attribs[i].strValue; break;
                        case XOn.X_ATTRIBUTE_DATATYPE_BLOB: logline += ByteConvert.ToString(req.attribs[i].binValue); break;
                        }
                    }
                }
                
                Xom.Log(XomAreaName.log, logline);
                
                counters.EndRequest(HResult.Failed(hr));            
            }
            
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Query, hr);
        }
        
                      
        
        //-----------------------------------------------------
        // IsReusable (IHttpHandler)
        //
        //      this dll doesn't hold request-specific state, so 
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }
            
    }              
    
    
    public class RemoveCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            RemoveCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            RemoveCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                RemoveCountersCategory.Current(hexTitleId).FailuresPerSecond,
                RemoveCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            RemoveCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            RemoveCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                RemoveCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                RemoveCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query FD: Remove", "Query FD: Remove" )]
	public class RemoveCountersCategory : XomPerformanceCounterCategory
	{
		
        static public RemoveCountersCategory _instance = new RemoveCountersCategory();
        static public RemoveCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (RemoveCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Remove request counters

		[XomPerformanceCounterAttr(
			"Remove requests/sec", 
			"Remove requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Remove total", 
			"Total Remove requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Remove failures/sec", 
			"Number of unsuccessful results returned by Remove per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Remove total failures", 
			"Total number unsuccessful results returned by Remove in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Remove avg. execution time", 
			"Remove Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\fd\add.cs ===
// 
// Add.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// xqry Front Door
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Diagnostics;
using System.Data.SqlClient;
using System.Text;
using System.Web;
using System.IO;
using xonline.common.config;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.server.querylib;

namespace xonline.server.query.fd 
{
public class Add : IHttpHandler
{
    //-----------------------------------------------------
    // ProcessRequest (IHttpHandler)
    //      
    //      the main entry point for http requests.
    //
    public void ProcessRequest(HttpContext ctx)
    {
        AddCounters counters = new AddCounters();
        AddRequest req = new AddRequest();
        AddResponse resp = new AddResponse();
        string      logline;
        int         i;
        HResult     hr = HResult.XONLINE_E_QUERY_ERROR;
        ulong       entityId;


        try
        {
            counters.StartRequest(0);

            // check and fetch the source of the call                                               
            string            viface = CallSource.Check(VirtualInterface.xqry, VirtualInterface.xqry_int);  
            Source            source = Dataset.SourceFromRequest(viface, ctx);

            // read request header
            //
            req.ReadFromRequest(ctx.Request);

            // start counters with the actual title id                                               
            counters.StartRequest(req.titleId);

            // only verify sg info when coming in as an internet call..
            if (viface == VirtualInterface.xqry)
            {
                SGInfo.VerifyTitleId(req.titleId);
                SGInfo.VerifyUserId(req.userId);
            }

            //
            // Verify team id
            //
            if ((req.teamId != 0) && (viface != VirtualInterface.xqry_int))
            {
                TeamTickets teamTickets = new TeamTickets(new BinaryReader(ctx.Request.InputStream));
                if (viface == VirtualInterface.xqry)
                {
                    teamTickets.VerifyTickets();
                }
                teamTickets.VerifyMembershipThrow(req.userId, req.teamId);
            }

            hr = Dataset.InternalAdd(source, req.titleId, req.userId, req.teamId, req.datasetId, req.attribs, out entityId);
            resp.entityId = entityId;
        }

        catch (XRLException e)
        {
            hr = e.HResult;
            throw;
        }
        finally
        {
            // Do logging

            logline = "ADD|" +
                      hr + "|" +
                      req.titleId.ToString("x8") + "|" +
                      req.userId.ToString("x16") + "|" +
                      req.teamId.ToString("x16") + "|" +
                      req.datasetId.ToString()   + "|";


            // add attributes
            if ((null != req) && (null != req.attribs))
            {
                for (i = 0; i < req.attribs.Length; i++)
                {
                    if (i > 0) logline += ";";
                    logline += req.attribs[i].Id + ",";
                    switch (req.attribs[i].Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: logline += req.attribs[i].lValue; break;
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING: logline += req.attribs[i].strValue; break;
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB: logline += ByteConvert.ToString(req.attribs[i].binValue); break;
                    }
                }
            }

            logline += "|" + resp.entityId.ToString("x16");

            Xom.Log(XomAreaName.log, logline);

            counters.EndRequest(HResult.Failed(hr));
        }


        XRLUtil.SetXRLResponse(ctx.Response, XOService.Query, hr, resp);
    }




    //-----------------------------------------------------
    // IsReusable (IHttpHandler)
    //
    //      this dll doesn't hold request-specific state, so 
    //      it's fine to reuse the same instance.
    //
    public bool IsReusable
    {
        get { return true;}
    }

}              


public class AddCounters
{
    private XomRequestTimeElapsed timeElapsed;
    string hexTitleId;


    public void StartRequest(uint titleId)
    {
        if (titleId != 0) hexTitleId = titleId.ToString("x8");
        timeElapsed = new XomRequestTimeElapsed();

        AddCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
        AddCountersCategory.Current(hexTitleId).RequestsTotal.Increment();

        XRLUtil.AddErrorPerfCounters(new PerformanceCounter[]{
                                     AddCountersCategory.Current(hexTitleId).FailuresPerSecond,
                                     AddCountersCategory.Current(hexTitleId).FailuresTotal
                                     });
    }

    public void EndRequest(bool failed)
    {
        AddCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
        AddCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   

        if (failed)
        {
            AddCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
            AddCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
        }
    }
}




[XomPerformanceCounterCategoryAttr( "Query FD: Add", "Query FD: Add" )]
public class AddCountersCategory : XomPerformanceCounterCategory
{

    static public AddCountersCategory _instance = new AddCountersCategory();
    static public AddCountersCategory Current(string titleId)
    {
        if (titleId == null)
        {
            titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
        }
        return(AddCountersCategory)_instance.GetInstance(titleId);
    }


    // Add request counters

    [XomPerformanceCounterAttr(
                              "Add requests/sec", 
                              "Add requests per second", 
                              PerformanceCounterType.RateOfCountsPerSecond32)]
    public PerformanceCounter RequestsPerSecond;

    [XomPerformanceCounterAttr(
                              "Add total", 
                              "Total Add requests recorded in the the current AppDomain.", 
                              PerformanceCounterType.NumberOfItems64)]
    public PerformanceCounter RequestsTotal;

    [XomPerformanceCounterAttr(
                              "Add failures/sec", 
                              "Number of unsuccessful results returned by Add per second in the current AppDomain.", 
                              PerformanceCounterType.RateOfCountsPerSecond32)]
    public PerformanceCounter FailuresPerSecond;

    [XomPerformanceCounterAttr(
                              "Add total failures", 
                              "Total number unsuccessful results returned by Add in the current AppDomain.",  
                              PerformanceCounterType.NumberOfItems64)]
    public PerformanceCounter FailuresTotal;

    [XomPerformanceCounterAttr(
                              "Add avg. execution time", 
                              "Add Total requests failed", 
                              PerformanceCounterType.AverageTimer32)]
    public PerformanceCounter AvgExecTime;

    [XomPerformanceCounterAttr(
                              "Avg waiting time base", 
                              "Avg waiting time base", 
                              PerformanceCounterType.AverageBase)]
    public PerformanceCounter AvgExecTimeBase;


}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\fd\findfromids.cs ===
// 
// findfromIds.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// xqry Front Door
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Diagnostics;
using System.Data.SqlClient;
using System.Text;
using System.Web;
using xonline.common.config;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.server.querylib;
using xonline.common.sql.sqlclient;

namespace xonline.server.query.fd 
{
    public class FindFromIds : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //      
        //      the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            FindFromIdsCounters counters = new FindFromIdsCounters();
            FindFromIdsRequest req = new FindFromIdsRequest();
            FindFromIdsResponse resp = new FindFromIdsResponse();
            string logline;
            HResult hr = HResult.XONLINE_E_QUERY_ERROR;
            SqlDataReader reader = null;
            SqlClient cmd = null;
            
            try
            {
                counters.StartRequest(0);
                
                // check and fetch the source of the call                                               
                string      viface = CallSource.Check(VirtualInterface.xqry, VirtualInterface.xqry_int);   
                Source      source = Dataset.SourceFromRequest(viface, ctx);
                
                
                // read request header
                //
                req.ReadFromRequest(ctx.Request);
                
                // start counters with the actual title id                                               
                counters.StartRequest(req.titleId);


                
                // run the search
                //
                hr = Dataset.InternalFindFromIds(source, req.titleId, req.datasetId, req.procIndex, req.entityIds, req.specs, out reader, out cmd);            
            
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Query, hr);

                if (HResult.Succeeded(hr))
                {
                    resp.returnedResults = (uint)req.entityIds.Length;
                    resp.attribCount = req.specCount * resp.returnedResults;
                    
                    if (resp.returnedResults > 0)
                    {
                        resp.attribs = Dataset.GetAttributesFromResults(req.titleId, reader, req.specs, resp.returnedResults);
                    }
                }
                
                // 
                // Write the response to the wire
                //    
                resp.WriteToResponse(ctx.Response);
                

                // make sure we got back the number of results
                // we were expecting
                //    
                if (resp.attribCount > 0)
                {
                    if (resp.attribs.Length != req.specCount * resp.returnedResults)
                    {
                        throw new XRLException(HResult.XONLINE_E_QUERY_ERROR, XEvent.Id.QUERY_BAD_DATA_9,
                                            "Unexpected number of rows returned!!\r\n" + 
                                            "expected: " + resp.returnedResults + "\r\n" + 
                                            "returned: " + resp.attribs.Length + "\r\n" + 
                                            "dataset: " + req.datasetId + "  procIndex: " + req.procIndex);
                    }
                }                
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
                
                if (null != reader)
                {
                    reader.Close();                    
                }
                
                logline = "FFI|" + 
                    hr + "|" +
                    req.titleId.ToString("x8") + "|" + 
                    req.datasetId.ToString()   + "|" + 
                    req.procIndex.ToString()   + "|" +
                    req.idCount.ToString()     + "|";
                    
                // add requested ids
                if (null != req.entityIds)
                {
                    for (int i = 0; i < req.entityIds.Length; i++)
                    {
                        if (i > 0) logline += ";";                
                        logline += req.entityIds[i].ToString();
                    }
                }
                
                logline += "|" + resp.returnedResults; 
                
                Xom.Log(XomAreaName.log, logline);
                
                counters.EndRequest(HResult.Failed(hr));            
            }            
        }
        
                      
        //-----------------------------------------------------
        // IsReusable (IHttpHandler)
        //
        //      this dll doesn't hold request-specific state, so 
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }
            
    }              
    
    
    public class FindFromIdsCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            FindFromIdsCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            FindFromIdsCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                FindFromIdsCountersCategory.Current(hexTitleId).FailuresPerSecond,
                FindFromIdsCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            FindFromIdsCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            FindFromIdsCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                FindFromIdsCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                FindFromIdsCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query FD: FindFromIds", "Query FD: FindFromIds" )]
	public class FindFromIdsCountersCategory : XomPerformanceCounterCategory
	{
		
        static public FindFromIdsCountersCategory _instance = new FindFromIdsCountersCategory();
        static public FindFromIdsCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (FindFromIdsCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // FindFromIds request counters

		[XomPerformanceCounterAttr(
			"FindFromIds requests/sec", 
			"FindFromIds requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"FindFromIds total", 
			"Total FindFromIds requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"FindFromIds failures/sec", 
			"Number of unsuccessful results returned by FindFromIds per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"FindFromIds total failures", 
			"Total number unsuccessful results returned by FindFromIds in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"FindFromIds avg. execution time", 
			"FindFromIds Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\fd\removeid.cs ===
// 
// RemoveId.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// xqry Front Door
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Web;
using System.Text;
using System.IO;
using System.Diagnostics;
using xonline.common.config;
using xonline.common.plugins;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.querylib;


namespace xonline.server.query.fd 
{
    public class RemoveId : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //      
        //      the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            RemoveIdCounters counters = new RemoveIdCounters();
            RemoveIdRequest req = new RemoveIdRequest();
            string logline;
            HResult hr = HResult.XONLINE_E_QUERY_ERROR;

            
            try
            {
                counters.StartRequest(0);
                
                
                // check and fetch the source of the call                                               
                string            viface = CallSource.Check(VirtualInterface.xqry, VirtualInterface.xqry_int);  
                Source            source = Dataset.SourceFromRequest(viface, ctx);

                // read request header
                //
                req.ReadFromRequest(ctx.Request);
                
                
                // start counters with the actual title id                                               
                counters.StartRequest(req.titleId);
                

                // only verify sg info when coming in as an internet call..
                if (viface == VirtualInterface.xqry)
                {
                    SGInfo.VerifyTitleId(req.titleId);
                    SGInfo.VerifyUserId(req.userId);
                }
                
                //
                // Verify team id
                //
                if ((req.teamId != 0) && (viface != VirtualInterface.xqry_int))
                {
                    TeamTickets teamTickets = new TeamTickets(new BinaryReader(ctx.Request.InputStream));
                    if (viface == VirtualInterface.xqry)
                    {
                        teamTickets.VerifyTickets();
                    }
                    teamTickets.VerifyMembershipThrow(req.userId, req.teamId);
                }

                hr = Dataset.InternalRemoveId(source, req.titleId, req.userId, req.teamId, req.datasetId, req.entityId);
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {                        
                logline = "RID|" + 
                    hr + "|" +
                    req.titleId.ToString("x8") + "|" + 
                    req.userId.ToString("x16") + "|" +
                    req.teamId.ToString("x16") + "|" + 
                    req.datasetId.ToString()   + "|" +
                    req.entityId.ToString("x16");
                
                Xom.Log(XomAreaName.log, logline);
                
                counters.EndRequest(HResult.Failed(hr));            
            }
            
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Query, hr);
        }
        
                      
        
        
        //-----------------------------------------------------
        // IsReusable (IHttpHandler)
        //
        //      this dll doesn't hold request-specific state, so 
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }
            
    }              
    
    
    public class RemoveIdCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            RemoveIdCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            RemoveIdCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                RemoveIdCountersCategory.Current(hexTitleId).FailuresPerSecond,
                RemoveIdCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            RemoveIdCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            RemoveIdCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                RemoveIdCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                RemoveIdCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query FD: RemoveId", "Query FD: RemoveId" )]
	public class RemoveIdCountersCategory : XomPerformanceCounterCategory
	{
		
        static public RemoveIdCountersCategory _instance = new RemoveIdCountersCategory();
        static public RemoveIdCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (RemoveIdCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // RemoveId request counters

		[XomPerformanceCounterAttr(
			"RemoveId requests/sec", 
			"RemoveId requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"RemoveId total", 
			"Total RemoveId requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"RemoveId failures/sec", 
			"Number of unsuccessful results returned by RemoveId per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"RemoveId total failures", 
			"Total number unsuccessful results returned by RemoveId in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"RemoveId avg. execution time", 
			"RemoveId Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\fd\updateid.cs ===
// 
// UpdateId.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// xqry Front Door
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Web;
using System.Text;
using System.IO;
using System.Diagnostics;
using xonline.common.config;
using xonline.common.plugins;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.protocol;
using xonline.server.querylib;


namespace xonline.server.query.fd 
{
    public class UpdateId : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //      
        //      the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            UpdateIdCounters counters = new UpdateIdCounters();
            UpdateIdRequest req = new UpdateIdRequest();
            string logline;
            int i;
            HResult hr = HResult.E_FAIL;
            
            try
            {
                counters.StartRequest(0);
                
                // check and fetch the source of the call                                               
                string            viface = CallSource.Check(VirtualInterface.xqry, VirtualInterface.xqry_int);  
                Source            source = Dataset.SourceFromRequest(viface, ctx);
                
                // read request header
                //
                req.ReadFromRequest(ctx.Request);
                                
                // start counters with the actual title id                                               
                counters.StartRequest(req.titleId);
                
                // only verify sg info when coming in as an internet call..
                if (viface == VirtualInterface.xqry)
                {
                    SGInfo.VerifyTitleId(req.titleId);
                    SGInfo.VerifyUserId(req.userId);
                }
                
                //
                // Verify team id
                //
                if ((req.teamId != 0) && (viface != VirtualInterface.xqry_int))
                {
                    TeamTickets teamTickets = new TeamTickets(new BinaryReader(ctx.Request.InputStream));
                    if (viface == VirtualInterface.xqry)
                    {
                        teamTickets.VerifyTickets();
                    }
                    teamTickets.VerifyMembershipThrow(req.userId, req.teamId);
                }
                
                hr = Dataset.InternalUpdateId(source, req.titleId, req.userId, req.teamId, req.datasetId, req.procIndex, req.entityId, req.attribs);
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {                        
                logline = "UPD|" + 
                    hr + "|" +
                    req.titleId.ToString("x8") + "|" + 
                    req.userId.ToString("x16") + "|" +
                    req.teamId.ToString("x16") + "|" + 
                    req.datasetId.ToString()   + "|" +
                    req.entityId.ToString("x16") + "|";
                    
                    
                // add attributes
                if (null != req.attribs)
                {
                    for (i = 0; i < req.attribs.Length; i++)
                    {
                        if (i > 0) logline += ";";                
                        logline += req.attribs[i].Id + ",";
                        switch(req.attribs[i].Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                        {
                        case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: logline += req.attribs[i].lValue; break;
                        case XOn.X_ATTRIBUTE_DATATYPE_STRING: logline += req.attribs[i].strValue; break;
                        case XOn.X_ATTRIBUTE_DATATYPE_BLOB: logline += ByteConvert.ToString(req.attribs[i].binValue); break;
                        }
                    }
                }
                
                Xom.Log(XomAreaName.log, logline);
                
                counters.EndRequest(HResult.Failed(hr));            
            }
            
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Query, hr);
        }
        
                      
        
        //-----------------------------------------------------
        // IsReusable (IHttpHandler)
        //
        //      this dll doesn't hold request-specific state, so 
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }
            
    }              
    
    
    public class UpdateIdCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            UpdateIdCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            UpdateIdCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                UpdateIdCountersCategory.Current(hexTitleId).FailuresPerSecond,
                UpdateIdCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            UpdateIdCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            UpdateIdCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                UpdateIdCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                UpdateIdCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query FD: UpdateId", "Query FD: UpdateId" )]
	public class UpdateIdCountersCategory : XomPerformanceCounterCategory
	{
		
        static public UpdateIdCountersCategory _instance = new UpdateIdCountersCategory();
        static public UpdateIdCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (UpdateIdCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Update request counters

		[XomPerformanceCounterAttr(
			"UpdateId requests/sec", 
			"UpdateId requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"UpdateId total", 
			"Total Update requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"UpdateId failures/sec", 
			"Number of unsuccessful results returned by Update per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"UpdateId total failures", 
			"Total number unsuccessful results returned by Update in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"UpdateId avg. execution time", 
			"UpdateId Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\fd\timewarp.cs ===
// 
// TimeWarp.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// xqry Front Door
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Web;
using System.Text;
using System.Diagnostics;
using xonline.common.config;
using xonline.common.plugins;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.protocol;
using xonline.server.querylib;


namespace xonline.server.query.fd 
{
    public class TimeWarp : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //      
        //      the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            QueryTimeWarpRequest req = new QueryTimeWarpRequest();

            //
            // Ensure this is a datacenter-only call
            //
            CallSource.Check(VirtualInterface.xqry_int);   

            
            // read request header
            //
            req.ReadFromRequest(ctx.Request);
            
            xonline.server.querylib.QueryUtil.TimeWarpAdjustment = req.offsetSeconds;
            
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Query, HResult.S_OK);
            
        }
        
        
        //-----------------------------------------------------
        // IsReusable (IHttpHandler)
        //
        //      this dll doesn't hold request-specific state, so 
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }
            
    }              
    
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\test\dvt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\test\plugins\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\fd\update.cs ===
// 
// Update.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// xqry Front Door
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Web;
using System.Text;
using System.IO;
using System.Diagnostics;
using xonline.common.config;
using xonline.common.plugins;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.protocol;
using xonline.server.querylib;


namespace xonline.server.query.fd 
{
    public class Update : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //      
        //      the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            UpdateCounters counters = new UpdateCounters();
            UpdateRequest req = new UpdateRequest();
            string logline;
            int i;
            HResult hr = HResult.XONLINE_E_QUERY_ERROR;

            
            try
            {
                counters.StartRequest(0);
                
                // check and fetch the source of the call                                               
                string            viface = CallSource.Check(VirtualInterface.xqry, VirtualInterface.xqry_int);  
                Source            source = Dataset.SourceFromRequest(viface, ctx);
                
                
                // read request header
                //
                req.ReadFromRequest(ctx.Request);                
                
                // start counters with the actual title id                                               
                counters.StartRequest(req.titleId);
                

                // only verify sg info when coming in as an internet call..
                if (viface == VirtualInterface.xqry)
                {
                    SGInfo.VerifyTitleId(req.titleId);
                    SGInfo.VerifyUserId(req.userId);
                }
                
                //
                // Verify team id
                //
                if ((req.teamId != 0) && (viface != VirtualInterface.xqry_int))
                {
                    TeamTickets teamTickets = new TeamTickets(new BinaryReader(ctx.Request.InputStream));
                    if (viface == VirtualInterface.xqry)
                    {
                        teamTickets.VerifyTickets();
                    }
                    teamTickets.VerifyMembershipThrow(req.userId, req.teamId);
                }
            
                hr = Dataset.InternalUpdate(source, req.titleId, req.userId, req.teamId, req.datasetId, req.procIndex, req.attribs);
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {            
                logline = "UPD|" + 
                    hr + "|" +
                    req.titleId.ToString("x8") + "|" + 
                    req.userId.ToString("x16") + "|" +
                    req.teamId.ToString("x16") + "|" + 
                    req.datasetId.ToString()   + "|";
                    
                // add attributes
                if (null != req.attribs)
                {
                    for (i = 0; i < req.attribs.Length; i++)
                    {
                        if (i > 0) logline += ";";                
                        logline += req.attribs[i].Id + ",";
                        switch(req.attribs[i].Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                        {
                        case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: logline += req.attribs[i].lValue; break;
                        case XOn.X_ATTRIBUTE_DATATYPE_STRING: logline += req.attribs[i].strValue; break;
                        case XOn.X_ATTRIBUTE_DATATYPE_BLOB: logline += ByteConvert.ToString(req.attribs[i].binValue); break;
                        }
                    }
                }
                
                Xom.Log(XomAreaName.log, logline);
                
                counters.EndRequest(HResult.Failed(hr));           
            }
            
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Query, hr);
        }
        
                      
        
        //-----------------------------------------------------
        // IsReusable (IHttpHandler)
        //
        //      this dll doesn't hold request-specific state, so 
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }
            
    }              
    
    
    public class UpdateCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            UpdateCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            UpdateCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                UpdateCountersCategory.Current(hexTitleId).FailuresPerSecond,
                UpdateCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            UpdateCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            UpdateCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                UpdateCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                UpdateCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query FD: Update", "Query FD: Update" )]
	public class UpdateCountersCategory : XomPerformanceCounterCategory
	{
		
        static public UpdateCountersCategory _instance = new UpdateCountersCategory();
        static public UpdateCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (UpdateCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Update request counters

		[XomPerformanceCounterAttr(
			"Update requests/sec", 
			"Update requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Update total", 
			"Total Update requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Update failures/sec", 
			"Number of unsuccessful results returned by Update per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Update total failures", 
			"Total number unsuccessful results returned by Update in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Update avg. execution time", 
			"Update Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\fd\xqryapp.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Caching;

using xonline.common.config;
using xonline.common.installer;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.server.querylib;

[assembly: XomIisInstallerAttribute( Interface.xqry )]
[assembly: XomIisInstallerAttribute( Interface.xqry_int )]
[assembly: ConfigAttribute(Component.xqry)]

namespace xonline.server.query.fd 
{
    public class QueryApp : FrontEndApp
    {
        protected override void OnApplicationStart()
        {
            DatasetInfo.FrontDoorAssembly = Assembly.GetExecutingAssembly();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\fd\search.cs ===
//
// search.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// xqry Front Door
// Xbox Online Service
//
// Author: slamb
//

using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Web;
using System.Text;
using System.Diagnostics;
using System.Data.SqlClient;
using xonline.common.config;
using xonline.common.plugins;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.protocol;
using xonline.server.querylib;
using xonline.common.sql.sqlclient;
using xonline.common.lsp;

namespace xonline.server.query.fd
{
    public class Search : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //
        //      the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            SearchCounters counters = new SearchCounters();
            SearchRequest req = new SearchRequest();
            SearchResponse resp = new SearchResponse();
            string logline;
            HResult hr = HResult.XONLINE_E_QUERY_ERROR;
            XEvent.Id eventId;
            bool retry = false;
            SqlDataReader reader = null;
            SqlClient cmd = null;
            bool isBackCompat = false;

            do
            {
                try
                {
                    counters.StartRequest(0);

                    // check and fetch the source of the call
                    string            viface = CallSource.Check(VirtualInterface.xqry, VirtualInterface.xqry_int);
                    Source            source = Dataset.SourceFromRequest(viface, ctx);

                    if (false == retry)
                    {
                        // read request header
                        //
                        req.ReadFromRequest(ctx.Request);
                    }

                    retry = false;

                    // start counters with the actual title id
                    counters.StartRequest(req.titleId);

                    // todo: put this in the XRLObject (once it supports it)
                    XRLUtil.VerifyParam(req.page <= XOn.XONLINE_QUERY_MAX_PAGE,                "Page " + req.page + " is greater than the max allowed " + XOn.XONLINE_QUERY_MAX_PAGE);
                    XRLUtil.VerifyParam(req.resultsPerPage > 0,                                 "Results per page cannot be zero ");
                    XRLUtil.VerifyParam(req.resultsPerPage <= XOn.XONLINE_QUERY_MAX_PAGE_SIZE, "Results per page " + req.resultsPerPage + " is greater than the max allowed " + XOn.XONLINE_QUERY_MAX_PAGE_SIZE);
                    
                    //
                    // based on the title-id and the dataset-id, determine if this is a 
                    // Lsp Query request that needs to be processed using the new Lsp 
                    // backend.
                    // 

                    isBackCompat = LspBackcompat.IsLspBackcompat(req.titleId, req.datasetId);
                    if(!isBackCompat)
                    {
                        hr = Dataset.InternalSearch(
                            source, 
                            req.titleId, 
                            req.datasetId, 
                            req.procIndex, 
                            req.page, 
                            req.resultsPerPage, 
                            req.attribs, 
                            req.specs, 
                            out resp.totalResults, 
                            out resp.returnedResults, 
                            out reader, 
                            out cmd);

                        XRLUtil.SetXRLResponse(ctx.Response, XOService.Query, hr);

                        if (HResult.Succeeded(hr))
                        {
                            resp.attribCount = 0;

                            if ((resp.returnedResults > 0) || (reader.HasRows))
                            {
                                resp.attribs = Dataset.GetAttributesFromResults(req.titleId, reader, req.specs, resp.returnedResults);
                            }

                            // It's ok for resp.returnedResults to be different than resp.attribs.Length. It was just a guess for optimization
                            if (null != resp.attribs)
                            {
                                resp.attribCount = (uint)resp.attribs.Length;
                                resp.returnedResults = (uint)resp.attribs.Length /req.specCount ;
                            }
                        }

                        //
                        // Write the response to the wire
                        //
                        resp.WriteToResponse(ctx.Response);
                    }
                    else
                    {
                        LspBackcompat.Enumerate(
                            req.titleId, 
                            req.datasetId, 
                            req.procIndex, 
                            req.page, 
                            req.resultsPerPage, 
                            req.attribs, 
                            req.specs, 
                            out resp.totalResults, 
                            out resp.returnedResults, 
                            out resp.attribs);

                        hr = HResult.S_OK;
                        XRLUtil.SetXRLResponse(ctx.Response, XOService.Query, HResult.S_OK);
                        resp.WriteToResponse(ctx.Response);
                    }
                }
                catch (Exception e)
                {
                    QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                    retry = (hr == HResult.XONLINE_E_QUERY_RETRY);

                    if (!retry)
                    {
                        throw;
                    }
                }
                finally
                {
                    if (null != cmd)
                    {
                        cmd.Close();
                    }

                    if (null != reader)
                    {
                        reader.Close();
                    }

                    // Since we're changing the format of the logline, we should change 
                    // the unique identifier to prevent confusion when looking at older 
                    // log lines.
                    logline = "SCH2|" +
                        hr + "|" +
                        req.titleId.ToString("x8") + "|" +
                        req.datasetId.ToString()   + "|" +
                        req.procIndex.ToString()   + "|" +
                        req.page.ToString()        + "|";

                    // add request attributes
                    if (null != req.attribs)
                    {
                        for (int i = 0; i < req.attribs.Length; i++)
                        {
                            if (i > 0) logline += ";";
                            logline += req.attribs[i].Id + ",";
                            switch(req.attribs[i].Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                            {
                            case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: logline += req.attribs[i].lValue; break;
                            case XOn.X_ATTRIBUTE_DATATYPE_STRING: logline += req.attribs[i].strValue; break;
                            case XOn.X_ATTRIBUTE_DATATYPE_BLOB: logline += ByteConvert.ToString(req.attribs[i].binValue); break;
                            }
                        }
                    }
                    logline += "|";

                    // add request specs, new to SCH2
                    if (null != req.specs)
                    {
                        for (int i = 0; i < req.specs.Length; i++)
                        {
                            if (i > 0) logline += ";";
                            logline += req.specs[i].type.ToString("x8");
                        }
                    }

                    logline += "|" +
                        (isBackCompat ? "1" : "0") + "|" +
                        resp.returnedResults       + "|" +
                        resp.totalResults;

                    Xom.Log(XomAreaName.log, logline);

                    counters.EndRequest(HResult.Failed(hr));
                }
            }

            while (true == retry);
        }


        //-----------------------------------------------------
        // IsReusable (IHttpHandler)
        //
        //      this dll doesn't hold request-specific state, so
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }

    }


    public class SearchCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;


        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();

            SearchCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            SearchCountersCategory.Current(hexTitleId).RequestsTotal.Increment();

            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                SearchCountersCategory.Current(hexTitleId).FailuresPerSecond,
                SearchCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }

        public void EndRequest(bool failed)
        {
            SearchCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            SearchCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();

            if (failed)
            {
                SearchCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                SearchCountersCategory.Current(hexTitleId).FailuresTotal.Increment();
            }
        }
    }




    [XomPerformanceCounterCategoryAttr( "Query FD: Search", "Query FD: Search" )]
    public class SearchCountersCategory : XomPerformanceCounterCategory
    {
        
        static public SearchCountersCategory _instance = new SearchCountersCategory();
        static public SearchCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (SearchCountersCategory)_instance.GetInstance(titleId);
        }


        // Search request counters

        [XomPerformanceCounterAttr(
            "Search requests/sec",
            "Search requests per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
            "Search total",
            "Total Search requests recorded in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsTotal;

        [XomPerformanceCounterAttr(
            "Search failures/sec",
            "Number of unsuccessful results returned by Search per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailuresPerSecond;

        [XomPerformanceCounterAttr(
            "Search total failures",
            "Total number unsuccessful results returned by Search in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
            "Search avg. execution time",
            "Search Total requests failed",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AvgExecTime;
    
        [XomPerformanceCounterAttr(
            "Avg waiting time base",
            "Avg waiting time base",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AvgExecTimeBase;

        
    }

    // LspBackcompat
    // Lsp used to use Query as the backend. Not anymore as it now has its own backend.  
    // But to support titles that shipped using Query and upgraded their servers to the 
    // new Queryless LSP, we'll rewire their Query calls to the Lsp backend. This is 
    // controlled by the setting query_LspBackcompTitles which contains a list of comma 
    // separated title-ids for which the rewiring should happen.
    // This class implements the functionality related to the rewiring.
    public class LspBackcompat
    {
        // IsLspBackcompat
        // return whether a request for a [titleId,datasetId] should be handled by the 
        // LspBackcompat class rather than by Query
        static public bool IsLspBackcompat(uint titleId, uint datasetId)
        {
            if(datasetId != LspProtocolConstants.XONLINE_LSP_DEFAULT_DATASET)
            {
                // 
                // Wrong datasetId. Don't even bother. This is a genuine, non-lsp, Query 
                // search request.
                //
                
                return false;
            }
            
            LazyInit();
            
            Hashtable backcompatTitlesReference;
            
            lock(typeof(LspBackcompat))
            {
                backcompatTitlesReference = _backcompatTitles;
            }

            return backcompatTitlesReference.ContainsKey(titleId);
        }

        // Enumerate
        // Process a Query-search request
        static public void Enumerate(
            uint titleId, 
            uint datasetId, 
            uint procIndex, 
            uint page, 
            uint resultsPerPage,
            QueryAttribute[] inputAttributes,
            QueryAttributeSpec[] specs,
            out uint totalResults,
            out uint returnedResults,
            out QueryAttribute[] outputAttributes
            )
        {
            LspLib.LspInfo[] lspInfo = null;

            if(resultsPerPage > LspProtocolConstants.XONLINE_LSP_MAX_LSP_INFO)
            {
                //
                // Query doesn't seem to have an upper boundary for the number of entries 
                // returned in one go but Lsp does. Instead of just returning a generic 
                // error, we'll take the liberty of adjusting their request.
                //
                
                resultsPerPage = LspProtocolConstants.XONLINE_LSP_MAX_LSP_INFO;
            }

            //
            // find the user-data input attribute. If it was specified, we'll filter the 
            // results using it. If it wasn't specified, we'll not filter and will return 
            // everything.
            //
            
            string userData = null;
            
            for(int i=0; i < inputAttributes.Length; i++)
            {
                if(inputAttributes[i].Id == 
                   LspProtocolConstants.XONLINE_LSP_ATTR_PARAM_USER)
                {
                    userData = inputAttributes[i].strValue;
                }
            }

            //
            // make the query
            //

            uint startingIndex = page * resultsPerPage;

            LspLib.Enumerate(titleId, userData, startingIndex, resultsPerPage, 
                             out lspInfo, out totalResults);

            //
            // transform results to the format used by Query. What we return is kinda like 
            // a table where the columns to be returned are specified in 'specs'
            //

            returnedResults   = (uint) lspInfo.Length;
            outputAttributes  = new QueryAttribute[returnedResults * specs.Length];

            for(int i=0; i < outputAttributes.Length; i++)
            {
                int specIndex = i % specs.Length;
                int infoIndex = i / specs.Length;
                QueryAttributeSpec spec  = specs[specIndex];
                QueryAttribute attribute = new QueryAttribute();

                outputAttributes[i] = attribute;

                attribute.Id = spec.type;
                
                switch(spec.type)
                {
                case XOn.X_ATTRIBUTE_DATATYPE_INTEGER:

                    //
                    // fake Query's entity id by OR'ing the title-id with the server ip
                    //

                    attribute.lValue = (long)
                        ((((ulong)titleId) << 32) |
                        ((ulong)lspInfo[infoIndex].ipSgLsp));
                    break;

                case LspProtocolConstants.XONLINE_LSP_ATTR_TSADDR:
                    attribute.binValue = BuildTsAddr(lspInfo[infoIndex].ipSgLsp);
                    break;

                case LspProtocolConstants.XONLINE_LSP_ATTR_XNKID:
                    attribute.binValue = lspInfo[infoIndex].xnkid;
                    break;

                case LspProtocolConstants.XONLINE_LSP_ATTR_KEK:
                    attribute.binValue = lspInfo[infoIndex].xnkey;
                    break;

                case LspProtocolConstants.XONLINE_LSP_ATTR_USER:
                    attribute.strValue = lspInfo[infoIndex].userData;
                    break;

                case XOn.X_ATTRIBUTE_DATATYPE_STRING:
                    // This is for PGR3/PDZ back compat. They actually want the userdata 
                    // returned as a X_ATTRIBUTE_DATATYPE_STRING, not the 
                    // XONLINE_LSP_ATTR_USER that we expected. 
                    attribute.strValue = lspInfo[infoIndex].userData;
                    break;

                default:

                    throw new XRLException(
                        HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE,
                        XEvent.Id.QUERY_LSP_BACKCOMPAT_UNSUPPORTED_ATTRIBUTE, string.Format(
                            "LspBackcompat.Enumerate received an unknown attribute-id "+
                            "0x{0}. It's very likely that the lsp-backcompat code does "+
                            "not support queries from this specific game. Title id is 0x{1:X8}",
                            spec.type,
                            titleId));
                }
            }
        }

        // BuildTsAddr
        // build a valid TSADDR based on a LSP server ip
        static protected byte[] BuildTsAddr(uint ip)
        {
            // the format of the TSADDR structure is as follows:
            // typedef struct {
            //     IN_ADDR     ina;           // IP address (zero if not static/DHCP)
            //     IN_ADDR     inaOnline;     // Online IP address (zero if not online)
            //     WORD        wPortOnline;   // Online port
            //     BYTE        abEnet[6];     // Ethernet MAC address
            //     BYTE        abOnline[20];  // Online identification
            // } XNADDR;
            // but we only need to fill out inaOnline and wPortOnline. Everything else 
            // should be zeros

            MemoryStream buffer = new MemoryStream(36);
            BinaryWriter bw = new BinaryWriter(buffer);

            // initialize it will all zeros
            buffer.SetLength(36);

            // move 'pointer' to inaOnline
            buffer.Seek(4, SeekOrigin.Begin);

            // write inaOnline
            bw.Write(IPAddress.HostToNetworkOrder((int)ip));
            
            // write wPortOnline
            bw.Write(IPAddress.HostToNetworkOrder((short)3074));

            // get the buffer from the stream
            byte[] tsAddr = buffer.ToArray();

            return tsAddr;
        }

        // LazyInit
        // Lazy initialize LspBackcompat static members.
        static protected void LazyInit()
        {
            if(_backcompatTitles == null)
            {
                lock(typeof(LspBackcompat))
                {
                    if(_backcompatTitles == null)
                    {
                        //
                        // parse list of backcompat title-ids from the common config 
                        // setting
                        //
                        
                        LoadList(Config.GetSetting(Setting.query_LspBackcompTitles));
                        
                        //
                        // subscribe to setting changes
                        //
                        
                        Config.SettingChange += 
                            new SettingChangeEventHandler(SettingsChanged);
                    }
                }
            }
        }
        
        // LoadList
        // Initialize list of backcompat LSP title-ids.
        // - titleIdList: string with comma-separated backcompat title-ids. It can be an 
        // empty string. The title-ids can be specified in decimal (no-prefix) or in hex 
        // (0x prefix). 
        static protected void LoadList(string titleIdList)
        {
            try
            {
                string[] titleIds = titleIdList.Split(',',';');
                Hashtable newBackcompatTitles = new Hashtable(titleIds.Length);

                for(int i=0; i < titleIds.Length; i++)
                {
                    uint titleId = ParseTitleId(titleIds[i]); 
                    
                    newBackcompatTitles[titleId] = true;
                }

                lock(typeof(LspBackcompat))
                {
                    _backcompatTitles = newBackcompatTitles;
                }
            }
            catch(Exception e)
            {
                throw new ExceptionWithEventId(
                    XEvent.Id.QUERY_INVALID_SETTING_LSPBACKCOMPTITLES,
                    "Failed to parse setting query_LspBackcompTitles. Please make "+
                    "sure that the setting is a well formed, comma-separated list of "+
                    "title-ids. Title-ids can be specified in decimal (no prefix) or "+
                    "in hexadecimal (0x prefix). The reason why the parsing failed "+
                    "is: " + e.Message, e);
            }
        }

        // ParseTitleId
        // Parse a title-id from a string and convert it to its UINT32 form
        static protected uint ParseTitleId(string titleIdString)
        {
            titleIdString = titleIdString.Trim().ToLower();

            uint titleId;

            if(titleIdString.StartsWith("0x"))
            {
                titleId = Convert.ToUInt32(titleIdString, 16);
            }
            else
            {
                titleId = Convert.ToUInt32(titleIdString, 10);
            }

            return titleId;
        }

        // SettingsChanged
        // Update backcompat title list when the common config setting changes
        static protected void SettingsChanged(
            object sender, 
            SettingChangeEventArgs eventArgs
            )
        {
            if(eventArgs.Setting == Setting.query_LspBackcompTitles)
            {
                LoadList(eventArgs.ValueNew);
            }
        }
        
        // hash table with list of backcompat titles
        static protected Hashtable _backcompatTitles = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\querylib\base.cs ===
// 
// Base.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Query Plugin base classes
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Collections;
using xonline.common.service;
using xonline.common.protocol;

namespace xonline.server.querylib 
{
    public interface IQueryAdd
    {
        HResult BeforeAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, Hashtable ctx);
        HResult AfterAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, ulong entityId, Hashtable ctx);
    }
    
    public interface IQueryUpdate
    {
        HResult BeforeUpdate(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx);
        void AfterUpdate(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx);
    }

    public interface IQueryUpdateId
    {
        HResult BeforeUpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, ulong entityId, Hashtable ctx);
        void AfterUpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, ulong entityId, Hashtable ctx);
    }

    public interface IQueryRemove
    {
        HResult BeforeRemove(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx);
        void AfterRemove(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx);
    }
    
    public interface IQueryRemoveId
    {
        HResult BeforeRemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, Hashtable ctx);
        void AfterRemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, Hashtable ctx);
    }
    
    public interface IQuerySelect
    {
        HResult Select(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint actionId, QueryAttribute[] attribs, Hashtable ctx);
    }
    
    public interface IQuerySearch
    {
        HResult BeforeSearch(Source source, uint titleId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx);
    }
    
    public interface IQueryFindFromIds
    {
        HResult BeforeFind(Source source, uint titleId, uint datasetId, uint procIndex, ulong [] entityIds, Hashtable ctx);
    }
    
    public interface IQueryCustom
    {
        HResult BeforeCustom(Source source, uint titleId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx);
    }


    [Flags]
    public enum Source
    {
        Xbox = 0x1,
        Server = 0x2,
        Plugin = 0x4,
        Web = 0x8
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\querylib\CronUtil.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.querylib 
{
    public class CronUtil
    {
        public static HResult AddJob(string name, uint titleId, string assembly, string className, uint execCount, uint timeoutSecs, DateTime nextExec, uint intervalSecs, Hashtable ctx, out int jobId)
        {
            return AddJob(name, titleId, assembly, className, execCount, timeoutSecs, nextExec, intervalSecs, PluginUtil.HashtableToXml(ctx), out jobId);
        }            
        
        public static HResult AddJob(string name, uint titleId, string assembly, string className, uint execCount, uint timeoutSecs, DateTime nextExec, uint intervalSecs, string ctxXml, out int jobId)
        {
            AddJobRequest  addCronJobReq  = new AddJobRequest();
            AddJobResponse addCronJobResp = new AddJobResponse();
            XRLObject2     xrlo           = (XRLObject2)addCronJobResp;
            HResult        hr;

            jobId = 0;            
            
            addCronJobReq.name         = name;
            addCronJobReq.titleId      = titleId;
            addCronJobReq.assembly     = assembly;
            addCronJobReq.className    = className;
            addCronJobReq.argsXml      = ctxXml;
            addCronJobReq.execCount    = execCount;
            addCronJobReq.timeoutSecs  = timeoutSecs;
            addCronJobReq.nextExec     = nextExec;
            addCronJobReq.intervalSecs = intervalSecs;
            
    
            hr = XRLUtil.PostXrlRequest(XOService.Cron, addCronJobReq.GetXRL(), addCronJobReq, ref xrlo);
            if (HResult.Succeeded(hr))
            {
                jobId = addCronJobResp.jobId;
            }
            
            return hr;
        }
        
        public static HResult RemoveJob(int jobId, uint titleId)
        {
            RemoveJobRequest req = new RemoveJobRequest();
            HResult hr;
            
            req.jobId = jobId;
            req.titleId = titleId;
            
            hr = XRLUtil.PostXrlRequest(XOService.Cron, req.GetXRL(), req);
            return hr;
        }
        
        public static HResult FindJobs(string search, out CronJobWire[] jobs)
        {
            FindJobsRequest req = new FindJobsRequest();
            FindJobsResponse resp = new FindJobsResponse();
            XRLObject2 xrlo = (XRLObject2)resp;
            HResult hr;
            
            req.search = search;
            jobs = new CronJobWire[0];
            
            hr = XRLUtil.PostXrlRequest(XOService.Cron, req.GetXRL(), req, ref xrlo);
            if (HResult.Succeeded(hr))
            {
                jobs = resp.jobs;
            }
            
            return hr;    
        }
            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\querylib\queryerror.cs ===
// 
// Add.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// xqry Front Door
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Web;
using System.Text;
using System.Diagnostics;
using System.Data.SqlClient;
using xonline.common.plugins;
using xonline.common.mgmt;
using xonline.common.service;


namespace xonline.server.querylib 
{
    public class QueryError
    {
        //-----------------------------------------------------
        // GetBetterHrAndEvent
        //      
        //      translates some exceptions into friendly HResults
        //
        public static void GetBetterHrAndEvent(Exception e, out HResult hr, out XEvent.Id eventId)
        {
            Exception       baseE;
            SqlException    sqlE;
            XRLException    xrlE = null;

            hr = HResult.XONLINE_E_QUERY_ERROR;
            eventId = XEvent.Id.QUERYLIB_CODE_0;
            
            if (e is XRLException)
            {
                xrlE = (XRLException)e;
            }
            
            baseE = e.GetBaseException();

            if (null != baseE && baseE is XRLException)
            {
                xrlE = (XRLException)baseE;
            }

            if (null != xrlE)
            {
                hr = xrlE.HResult;
                eventId = xrlE.EventId;
            }    

            if (null != baseE && baseE is SqlException)
            {
                sqlE = (SqlException)baseE;
                Xom.Trace(XomAreaName.xqry, LogLevel.L_LOW, "SQL Exception error #: " + sqlE.Number);
            
                switch (sqlE.Number)
                {
                case 8152:  // truncation
                    hr = HResult.XONLINE_E_QUERY_ATTRIBUTE_TOO_LONG;
                    eventId = XEvent.Id.QUERYLIB_CONFIG_13;
                    break;
                    
                case 8145:  // bad parameter
                case 8144:  // too many arguments
                case 8143:  // duplicate parameters
                case 201:   // too few or wrong attributes
                    hr = HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE;
                    eventId = XEvent.Id.QUERYLIB_CONFIG_14;
                    break;
                    
                case 2812:   // couldn't find procedure
                    hr = HResult.XONLINE_E_QUERY_PROCEDURE_NOT_FOUND;
                    eventId = XEvent.Id.QUERYLIB_CONFIG_15;
                    break;

                case 2601:   // duplicate key violation
                    hr = HResult.XONLINE_E_QUERY_DUPLICATE_ENTRY;
                    eventId = XEvent.Id.QUERYLIB_CONFIG_16;
                    break;
                
                case 601:   // data moved - retry if possible
                    hr = HResult.XONLINE_E_QUERY_RETRY;
                    break;
                    
                default:
                    // unexpected or unhandled SQL Error
                    break;
                }    
            }           
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\fd\select.cs ===
// 
// Select.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// xqry Front Door
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Web;
using System.Text;
using System.IO;
using System.Diagnostics;
using xonline.common.config;
using xonline.common.plugins;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.protocol;
using xonline.server.querylib;


namespace xonline.server.query.fd 
{
    public class Select : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //      
        //      the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            SelectCounters counters = new SelectCounters();
            SelectRequest req = new SelectRequest();
            string logline;
            HResult hr = HResult.XONLINE_E_QUERY_ERROR;

            
            try
            {
                counters.StartRequest(0);
                
                // check and fetch the source of the call                                               
                string            viface = CallSource.Check(VirtualInterface.xqry, VirtualInterface.xqry_int);  
                Source            source = Dataset.SourceFromRequest(viface, ctx);
                
                // read request header
                //
                req.ReadFromRequest(ctx.Request);
                

                // start counters with the actual title id                                               
                counters.StartRequest(req.titleId);



                // only verify sg info when coming in as an internet call..
                if (viface == VirtualInterface.xqry)
                {
                    SGInfo.VerifyTitleId(req.titleId);
                    SGInfo.VerifyUserId(req.userId);
                }

                string bundledAuthHeader = ctx.Request.Headers[XHttpHdr.BUNDLEDAUTHDATA];
                BundledAuthData bundledAuth = null;
                
                // For server calls, we may receive bundle auth data in the header. 
                if ((null != bundledAuthHeader) && (bundledAuthHeader.Length > 0) && (viface == VirtualInterface.xqry_int))
                {
                    bundledAuth = new BundledAuthData(bundledAuthHeader);
                    bundledAuth.VerifyTitleId(req.titleId);

                    // Force userId to 0 to tell the plugins that we have bundled auth data on this request. 
                    req.userId = 0;
                }

                
                //
                // Verify team id for non-Server originated requests. 
                //
                TeamTickets teamTickets = null;

                try
                {
                    // Potention arbitration initiated team request. This could be either for a user based
                    //  competition or a team based competition. We can't know for sure which, so we 
                    //  always attempt to load the team tickets. If they are not there, it will throw a
                    //  EndOfStreamException, which we subsequently catch and handle. 
                    // It would have been nice to do this without an exception in a mainline codepath, but 
                    //  doing so would have required a client QFE due to when we found this. #36775
                    if ( (req.teamId == 0) && (req.userId == 0) && (viface == VirtualInterface.xqry_int) ) 
                    {
                        teamTickets = new TeamTickets(new BinaryReader(ctx.Request.InputStream));                        
                    }

                    // User initiated team request
                    else if ( (req.teamId != 0) && (viface != VirtualInterface.xqry_int) && (0 == (source & Source.Web)) )
                    { 
                        teamTickets = new TeamTickets(new BinaryReader(ctx.Request.InputStream));
                        
                        if (req.userId != 0)
                        {
                            teamTickets.VerifyTickets();
                            teamTickets.VerifyMembershipThrow(req.userId, req.teamId);

                            // No need to pass these along in the common case
                            teamTickets = null;
                        }
                    }
                }
                catch (EndOfStreamException)
                {
                    teamTickets = null;
                }                
            
                hr = Dataset.InternalSelect(source, req.titleId, req.userId, req.teamId, req.datasetId, req.entityId, req.actionId, req.attribs, bundledAuth, teamTickets);
            }
            catch (XRLException e)
            {
                hr = e.HResult;
                throw;
            }
            finally
            {
                logline = "SEL|" + 
                    hr + "|" +
                    req.titleId.ToString("x8") + "|" + 
                    req.userId.ToString("x16") + "|" +
                    req.teamId.ToString("x16") + "|" + 
                    req.datasetId.ToString()   + "|" +
                    req.entityId.ToString("x16") + "|" +
                    req.actionId.ToString();
                    
                // add attributes
                if (null != req.attribs)
                {
                    for (int i = 0; i < req.attribs.Length; i++)
                    {
                        if (i > 0) logline += ";";                
                        logline += req.attribs[i].Id + ",";
                        switch(req.attribs[i].Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                        {
                        case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: logline += req.attribs[i].lValue; break;
                        case XOn.X_ATTRIBUTE_DATATYPE_STRING: logline += req.attribs[i].strValue; break;
                        case XOn.X_ATTRIBUTE_DATATYPE_BLOB: logline += ByteConvert.ToString(req.attribs[i].binValue); break;
                        }
                    }
                }
                
                Xom.Log(XomAreaName.log, logline);
                
                counters.EndRequest(HResult.Failed(hr));           
            }
            
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Query, hr);
        }
        
        
        //-----------------------------------------------------
        // IsReusable (IHttpHandler)
        //
        //      this dll doesn't hold request-specific state, so 
        //      it's fine to reuse the same instance.
        //
        public bool IsReusable
        {
            get { return true; }
        }
            
    }              
    
    
    public class SelectCounters
    {
        private XomRequestTimeElapsed timeElapsed;
        string hexTitleId;
        
        
        public void StartRequest(uint titleId)
        {
            if (titleId != 0) hexTitleId = titleId.ToString("x8");
            timeElapsed = new XomRequestTimeElapsed();
            
            SelectCountersCategory.Current(hexTitleId).RequestsPerSecond.Increment();
            SelectCountersCategory.Current(hexTitleId).RequestsTotal.Increment();
            
            XRLUtil.AddErrorPerfCounters(new PerformanceCounter[] {
                SelectCountersCategory.Current(hexTitleId).FailuresPerSecond,
                SelectCountersCategory.Current(hexTitleId).FailuresTotal
            });
        }
        
        public void EndRequest(bool failed)
        {
            SelectCountersCategory.Current(hexTitleId).AvgExecTime.IncrementBy(timeElapsed.TimeElapsed);
            SelectCountersCategory.Current(hexTitleId).AvgExecTimeBase.Increment();   
            
            if (failed)
            {
                SelectCountersCategory.Current(hexTitleId).FailuresPerSecond.Increment();
                SelectCountersCategory.Current(hexTitleId).FailuresTotal.Increment();                
            }                
        }
    }
    
    
    
    
	[XomPerformanceCounterCategoryAttr( "Query FD: Select", "Query FD: Select" )]
	public class SelectCountersCategory : XomPerformanceCounterCategory
	{
		
        static public SelectCountersCategory _instance = new SelectCountersCategory();
        static public SelectCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (SelectCountersCategory)_instance.GetInstance(titleId);
        }
        
       
        // Select request counters

		[XomPerformanceCounterAttr(
			"Select requests/sec", 
			"Select requests per second", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter RequestsPerSecond;

		[XomPerformanceCounterAttr(
			"Select total", 
			"Total Select requests recorded in the the current AppDomain.", 
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter RequestsTotal;
        
        [XomPerformanceCounterAttr(
			"Select failures/sec", 
			"Number of unsuccessful results returned by Select per second in the current AppDomain.", 
			 PerformanceCounterType.RateOfCountsPerSecond32)]
		public PerformanceCounter FailuresPerSecond;

		[XomPerformanceCounterAttr(
			"Select total failures", 
			"Total number unsuccessful results returned by Select in the current AppDomain.",  
			 PerformanceCounterType.NumberOfItems64)]
		public PerformanceCounter FailuresTotal;

        [XomPerformanceCounterAttr(
			"Select avg. execution time", 
			"Select Total requests failed", 
			 PerformanceCounterType.AverageTimer32)]
		public PerformanceCounter AvgExecTime;
	    
    	[XomPerformanceCounterAttr(
			"Avg waiting time base", 
			"Avg waiting time base", 
			 PerformanceCounterType.AverageBase)]
		public PerformanceCounter AvgExecTimeBase;

		        
  	}
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\test\dvt\queryutil.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;

using ServerTestFramework;
using stfls = ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Utilities;

using xonline.common.stfutil;
using xonline.common.diagnostics;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.comps.common;
using xonline.common.mgmt;


[assembly: XomAreaDefinition(XomAreaName.QueryTest)]


namespace xonline.server.query.test.dvt 
{
    public class QueryUtil
    {
        public static uint OutputResults(QueryAttribute[] results, uint height, uint width)
        {
            uint        hr = HResult.S_OK;

            for (int i = 0; i < height; i++)
            {
                String output = "";
                
                for (int j = 0; j < width; j++)
                {
                    int index = i * (int)width + j;
                    
                    switch (results[index].Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: 
                        output += results[index].lValue + " | "; 
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING: 
                        output += results[index].strValue + " | "; 
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB: 
                        output += ByteConvert.ToString(results[index].binValue) + " | "; 
                        break;
                    }                  
                }

                Console.WriteLine(output);
            }

            return hr;
        }

        
        public static uint AdvanceCompTime(uint titleId, uint datasetId, ulong compId, int seconds)
        {
            uint hr;
            
            Console.WriteLine("Adjusting time for comp id 0x" + compId.ToString("x") + " by " + seconds + " seconds.");
            
            QueryAttribute[] attribs = new QueryAttribute[1];
            attribs[0] = new QueryAttribute();
            attribs[0].Id = Comp.XONLINE_COMP_ATTR_DEBUG_ADVANCE_TIME;
            attribs[0].lValue = seconds;
            
            hr = SendSelectRequest(titleId, 0, 0, datasetId, compId, Comp.XONLINE_COMP_ACTION_DEBUG_ADVANCE_TIME, attribs, -1);
            return hr;
        }
        
        
        
        
        public static uint TimeWarpServices(uint seconds)
        {            
            uint             hr;
            MemoryStream     stream = new MemoryStream();
            BinaryWriter     writer = new BinaryWriter(stream);
            byte[]           respData;
           
            Console.WriteLine("Advancing time on query and cron services by " + seconds + " seconds.");


            // 
            // Query Service
            //
            xonline.common.protocol.QueryTimeWarpRequest  qTimeWarpReq = new xonline.common.protocol.QueryTimeWarpRequest ();
            
            qTimeWarpReq.offsetSeconds = seconds;    
            
            qTimeWarpReq.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            writer.Flush();
            

            hr = XRLUtil.PostXrlRequest(XOService.Query, qTimeWarpReq.GetXRL(), -1, GetSGInfoString(0, 0), stream.ToArray(), out respData);            
            if (HResult.Failed(hr))
            {
                goto error;
            }


            // 
            // Cron Service
            //
            xonline.common.protocol.CronTimeWarpRequest    cTimeWarpReq = new xonline.common.protocol.CronTimeWarpRequest();
            
            cTimeWarpReq.offsetSeconds = seconds;    
            
            cTimeWarpReq.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            writer.Flush();

            hr = XRLUtil.PostXrlRequest(XOService.Cron, cTimeWarpReq.GetXRL(), -1, GetSGInfoString(0, 0), stream.ToArray(), out respData);
            if (HResult.Failed(hr))
            {
                goto error;
            }
            
error:
            return hr;
        }

        
        public static uint SendAddRequest(uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, out ulong entityId)
        {
            return SendAddRequest(titleId, userId, teamId, datasetId, attribs, null, null, out entityId);
        }

        public static uint SendAddRequest(uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, WebHeaderCollection headers, out ulong entityId)
        {
            return SendAddRequest(titleId, userId, teamId, datasetId, attribs, headers, null, out entityId);
        }
        
        public static uint SendAddRequest(uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, WebHeaderCollection headers, TeamTickets tickets, out ulong entityId)
        {
            AddRequest       request = new AddRequest();
            AddResponse      resp = new AddResponse();
            MemoryStream     stream = new MemoryStream();
            BinaryWriter     writer = new BinaryWriter(stream);
            BinaryReader     reader;
            byte[]           respBuf;

            entityId = 0;

            request.titleId = titleId;
            request.userId = userId;
            request.teamId = teamId;
            request.datasetId = datasetId;
            request.attribCount = (uint)attribs.Length;

            request.attribs = attribs;
            
            request.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);

            if (tickets != null)
            {
                tickets.WriteStream(writer);
            }
            
            
            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.titleId = titleId;
            slot.userPuid0 = userId;
            
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Query, false, request.GetXRL(), stream.ToArray(), out respBuf);


            if (HResult.Succeeded(hr))
            {
                reader = new BinaryReader(new MemoryStream(respBuf));
                resp.ReadFromRequest(reader, (UTF8Encoding)Encoding.UTF8, respBuf.Length, null);
                entityId = resp.entityId;
            }

            return hr;
        }                


        public static uint SendUpdateRequest(uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            return SendUpdateRequest(titleId, userId, teamId, datasetId, procIndex, attribs, null);
        }
        
        public static uint SendUpdateRequest(uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, TeamTickets tickets)
        {
            UpdateRequest    request = new UpdateRequest();
            MemoryStream     stream = new MemoryStream();
            BinaryWriter     writer = new BinaryWriter(stream);
            String           url = String.Empty;
            byte[]           respBuf;

            request.titleId = titleId;
            request.userId = userId;
            request.teamId = teamId;
            request.datasetId = datasetId;            
            request.procIndex = procIndex;            
            request.attribCount = (uint)attribs.Length;
            request.attribs = attribs;
            
            request.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);

            if (tickets != null)
            {
                tickets.WriteStream(writer);
            }
            
            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.titleId = titleId;
            slot.userPuid0 = userId;
            
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Query, false, request.GetXRL(), stream.ToArray(), out respBuf);

            if (HResult.Failed(hr))
            {
                Console.WriteLine("RemoveId failed with hr = " + hr.ToString("x8"));
            }
            

            return hr;
        }                

        
        public static uint SendUpdateIdRequest(uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attribs)
        {
            return SendUpdateIdRequest(titleId, userId, teamId, datasetId, procIndex, entityId, attribs, null);
        }
        
        public static uint SendUpdateIdRequest(uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attribs, TeamTickets tickets)
        {
            UpdateIdRequest  request = new UpdateIdRequest();
            MemoryStream     stream = new MemoryStream();
            BinaryWriter     writer = new BinaryWriter(stream);
            String           url = String.Empty;
            byte[]           respBuf;

            request.titleId = titleId;
            request.userId = userId;
            request.teamId = teamId;
            request.datasetId = datasetId;            
            request.procIndex = procIndex;            
            request.entityId = entityId;            
            request.attribCount = (uint)attribs.Length;
            request.attribs = attribs;
            
            request.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);

            if (tickets != null)
            {
                tickets.WriteStream(writer);
            }
            
            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.titleId = titleId;
            slot.userPuid0 = userId;
            
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Query, false, request.GetXRL(), stream.ToArray(), out respBuf);

            if (HResult.Failed(hr))
            {
                Console.WriteLine("RemoveId failed with hr = " + hr.ToString("x8"));
            }

            return hr;
        }                

        public static uint SendSelectRequest(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint actionId, QueryAttribute[] attribs, int port)
        {
            return SendSelectRequest(titleId, userId, teamId, datasetId, entityId, actionId, attribs, port, null, null);
        }    
        
        public static uint SendSelectRequest(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint actionId, QueryAttribute[] attribs, int port, WebHeaderCollection headers)
        {
            return SendSelectRequest(titleId, userId, teamId, datasetId, entityId, actionId, attribs, port, headers, null);
        }    
        
        public static uint SendSelectRequest(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint actionId, QueryAttribute[] attribs, int port, WebHeaderCollection headers, TeamTickets tickets)
        {
            SelectRequest   request = new SelectRequest();
            uint            hr;
            MemoryStream    stream = new MemoryStream();
            BinaryWriter    writer = new BinaryWriter(stream);
            byte[]          respBuf;            
            
            request.titleId = titleId;
            request.userId = userId;
            request.teamId = teamId;
            request.datasetId = datasetId;
            request.entityId = entityId;
            request.actionId = actionId;

            if (null == attribs)
            {
                request.attribCount = 0;
                request.attribs = null;
            }
            else
            {
                request.attribCount = (uint)attribs.Length;
                request.attribs = attribs;
            }
            
            request.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);           

            if (tickets != null)
            {
                tickets.WriteStream(writer);
            }
            
            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.titleId = titleId;
            slot.userPuid0 = userId;
            
            hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Query, false, request.GetXRL(), stream.ToArray(), out respBuf);


            return hr;
        }                

        public static uint SendSearchRequest(uint titleId, uint datasetId, uint procIndex, uint page, uint resultsPerPage, QueryAttribute[] attribs, QueryAttributeSpec[] specs, out uint totalResults, out QueryAttribute[] results)
        {
            SearchRequest           request = new SearchRequest();
            SearchResponse          resp = new SearchResponse();
            uint                    hr;
            MemoryStream            stream = new MemoryStream();
            BinaryWriter            writer = new BinaryWriter(stream);
            BinaryReader            reader;
            byte[]                  respBuf;
            
            request.titleId = titleId;
            request.datasetId = datasetId;
            request.procIndex = procIndex;
            request.page = page;
            request.resultsPerPage = resultsPerPage;
            request.specCount = (uint)specs.Length;
            request.attribCount = (uint)attribs.Length;

            request.specs = specs;
            request.attribs = attribs;
            
            request.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            

            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.titleId = titleId;
            
            hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Query, false, request.GetXRL(), stream.ToArray(), out respBuf);

            totalResults = 0;
            results = null;
            

            if (HResult.Succeeded(hr))
            {
                reader = new BinaryReader(new MemoryStream(respBuf));
                resp.ReadFromRequest(reader, (UTF8Encoding)Encoding.UTF8, respBuf.Length, null);

                totalResults = resp.totalResults;
                results = resp.attribs;
            }
            
            return hr;
        }                


        public static uint SendFindFromIdsRequest(uint titleId, uint datasetId, uint procIndex, QueryAttributeSpec[] specs, ulong[] entityIds, out uint totalResults, out QueryAttribute[] results)
        {
            FindFromIdsRequest      request = new FindFromIdsRequest();
            FindFromIdsResponse     resp = new FindFromIdsResponse();
            uint                    hr;
            MemoryStream            stream = new MemoryStream();
            BinaryWriter            writer = new BinaryWriter(stream);
            BinaryReader            reader;
            byte[]                  respBuf;
            
            request.titleId = titleId;
            request.datasetId = datasetId;
            request.procIndex = procIndex;
            request.specCount = (uint)specs.Length;
            request.idCount = (uint)entityIds.Length;

            request.specs = specs;
            request.entityIds = entityIds;
            
            request.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            

            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.titleId = titleId;
            
            hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Query, false, request.GetXRL(), stream.ToArray(), out respBuf);

            totalResults = 0;
            results = null;
            
            if (HResult.Succeeded(hr))
            {
                reader = new BinaryReader(new MemoryStream(respBuf));
                resp.ReadFromRequest(reader, (UTF8Encoding)Encoding.UTF8, respBuf.Length, null);

                totalResults = resp.returnedResults;
                results = resp.attribs;
            }
            
            return hr;
        }                


        public static uint SendRemoveRequest(uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            return SendRemoveRequest(titleId, userId, teamId, datasetId, procIndex, attribs, null);
        }
        
        public static uint SendRemoveRequest(uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, TeamTickets tickets)
        {
            RemoveRequest           request = new RemoveRequest();
            uint                    hr;
            MemoryStream            stream = new MemoryStream();
            BinaryWriter            writer = new BinaryWriter(stream);
            byte[]                  respBuf;
            
            request.titleId = titleId;
            request.userId = userId;
            request.teamId = teamId;
            request.datasetId = datasetId;
            request.procIndex = procIndex;            
            request.attribs = attribs;
            
            request.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            
            if (tickets != null)
            {
                tickets.WriteStream(writer);
            }
            

            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.titleId = titleId;
            slot.userPuid0 = userId;
            
            hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Query, false, request.GetXRL(), stream.ToArray(), out respBuf);
            if (HResult.Failed(hr))
            {
                Console.WriteLine("RemoveId failed with hr = " + hr.ToString("x8"));
            }

            
            return hr;
        }    

        
        public static uint SendRemoveIdRequest(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return SendRemoveIdRequest(titleId, userId, teamId, datasetId, entityId, null);
        }
        
        public static uint SendRemoveIdRequest(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, TeamTickets tickets)
        {
            RemoveIdRequest         request = new RemoveIdRequest();
            uint                    hr;
            MemoryStream            stream = new MemoryStream();
            BinaryWriter            writer = new BinaryWriter(stream);
            byte[]                  respBuf;
            
            request.titleId = titleId;
            request.userId = userId;
            request.teamId = teamId;
            request.datasetId = datasetId;
            request.entityId = entityId;            
            
            request.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            
            if (tickets != null)
            {
                tickets.WriteStream(writer);
            }


            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.titleId = titleId;
            slot.userPuid0 = userId;
            
            hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Query, false, request.GetXRL(), stream.ToArray(), out respBuf);

            if (HResult.Failed(hr))
            {
                Console.WriteLine("RemoveId failed with hr = " + hr.ToString("x8"));
            }

            
            return hr;
        }         
        
        
        public static string GetSGInfoString(uint titleId, ulong userId)
        {
            HTTPAuthData authData = new HTTPAuthData(0, 0, 0, userId, titleId, 0, 0);
            return authData.ConstructBase64String();
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\querylib\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\querylib\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\test\dvt\000004d2.cs ===
// Autogenerated from \src\xonline\main\private\ops\query\000004d2.xqs on 8/4/2004 1:38:20 PM// DO NOT MAKE CHANGES TO THIS FILE!  They will not be reflected the next time 
// this file is generated.

using System;
using xonline.common.protocol;
using xonline.server.query.test.dvt;
using xonline.common.service;
using xonline.common;

namespace xonline.server.query.plugins.Sample2
{
    public class AddSmokeTestDataset
    {
        public QueryAttribute[] Attribs;
        public AddSmokeTestDataset()
        {
            Attribs = new QueryAttribute[5];
            Attribs[0] = new QueryAttribute(0x00000001);    // some number
            Attribs[1] = new QueryAttribute(0x00000002);    // some other number
            Attribs[2] = new QueryAttribute(0x00100003);    // a short string
            Attribs[3] = new QueryAttribute(0x00100004);    // a long string
            Attribs[4] = new QueryAttribute(0x00200005);    // a blob
        }

        public long SomeNumber
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long SomeOtherNumber
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public string AShortString
        {
            get { return (string)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public string ALongString
        {
            get { return (string)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public byte[] ABlob
        {
            get { return (byte[])Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return Dataset.Add(source, titleId, userId, teamId, datasetId, Attribs, out entityId);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return QueryUtil.SendAddRequest(titleId, userId, teamId, datasetId, Attribs, null, out entityId);        
        }
#endif
    }

    public class FindIds
    {
        public static QueryAttributeSpec[] Specs;

        static FindIds()
        {

            Specs = new QueryAttributeSpec[6];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x00000001, 30);    // some number
            Specs[2] = new QueryAttributeSpec(0x00000002, 30);    // some other number
            Specs[3] = new QueryAttributeSpec(0x00100003, 400);   // a short string
            Specs[4] = new QueryAttributeSpec(0x00100004, 400);   // a long string
            Specs[5] = new QueryAttributeSpec(0x00200005, 800);   // a blob
        }

#if XQRY
        public static uint Execute(Source source, uint titleId, uint datasetId, ulong[] entityIds, out FindIdsResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.FindFromIds(source, titleId, datasetId, 0x1, entityIds, Specs, out attribResults);

            if (HResult.Succeeded(hr))
            {
                results = new FindIdsResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new FindIdsResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public static uint Execute(uint titleId, uint datasetId, ulong[] entityIds, out FindIdsResults[] results)
        {
            uint totalResults;
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendFindFromIdsRequest(titleId, datasetId, 0x1, Specs, entityIds, out totalResults, out attribResults);
            if (HResult.Succeeded(hr))
            {
                results = new FindIdsResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new FindIdsResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class FindIdsResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public FindIdsResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public FindIdsResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long SomeNumber
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long SomeOtherNumber
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public string AShortString
        {
            get { return (string)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public string ALongString
        {
            get { return (string)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public byte[] ABlob
        {
            get { return (byte[])_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

    }

    public class Remove
    {
        public QueryAttribute[] Attribs;

         public Remove()
        {
            Attribs = new QueryAttribute[4];
            Attribs[0] = new QueryAttribute(0x02000002);          // some other number
            Attribs[1] = new QueryAttribute(0x02100003);          // a short string
            Attribs[2] = new QueryAttribute(0x02100004);          // a long string
            Attribs[3] = new QueryAttribute(0x02200005);          // a blob
        }

        public long SomeOtherNumber
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public string AShortString
        {
            get { return (string)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public string ALongString
        {
            get { return (string)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public byte[] ABlob
        {
            get { return (byte[])Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Remove(source, titleId, userId, teamId, datasetId, 0x1, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendRemoveRequest(titleId, userId, teamId, datasetId, 0x1, Attribs);        
        }
#endif
    }

    public class RemoveForUser
    {
        public QueryAttribute[] Attribs;

         public RemoveForUser()
        {
            Attribs = new QueryAttribute[0];
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Remove(source, titleId, userId, teamId, datasetId, 0x2, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendRemoveRequest(titleId, userId, teamId, datasetId, 0x2, Attribs);        
        }
#endif
    }

    public class Search
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public Search()
        {
            Attribs = new QueryAttribute[4];
            Attribs[0] = new QueryAttribute(0x02000002);          // some other number
            Attribs[1] = new QueryAttribute(0x02100003);          // a short string
            Attribs[2] = new QueryAttribute(0x02100004);          // a long string
            Attribs[3] = new QueryAttribute(0x02200005);          // a blob

            Specs = new QueryAttributeSpec[6];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x00000001, 30);    // some number
            Specs[2] = new QueryAttributeSpec(0x00000002, 30);    // some other number
            Specs[3] = new QueryAttributeSpec(0x00100003, 400);   // a short string
            Specs[4] = new QueryAttributeSpec(0x00100004, 400);   // a long string
            Specs[5] = new QueryAttributeSpec(0x00200005, 800);   // a blob
        }

        public long SomeOtherNumber
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public string AShortString
        {
            get { return (string)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public string ALongString
        {
            get { return (string)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public byte[] ABlob
        {
            get { return (byte[])Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out SearchResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out SearchResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x1, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new SearchResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new SearchResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out SearchResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out SearchResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x1, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new SearchResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new SearchResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class SearchResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public SearchResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public SearchResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long SomeNumber
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long SomeOtherNumber
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public string AShortString
        {
            get { return (string)_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public string ALongString
        {
            get { return (string)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

        public byte[] ABlob
        {
            get { return (byte[])_attribs[5 + _startIndex].Value; }
            set { _attribs[5 + _startIndex].Value = value; }
        }

    }

    public class UpdateId
    {
        public QueryAttribute[] Attribs;

         public UpdateId()
        {
            Attribs = new QueryAttribute[5];
            Attribs[0] = new QueryAttribute(0x02000001);          // some number
            Attribs[1] = new QueryAttribute(0x02000002);          // some other number
            Attribs[2] = new QueryAttribute(0x02100003);          // a short string
            Attribs[3] = new QueryAttribute(0x02100004);          // a long string
            Attribs[4] = new QueryAttribute(0x02200005);          // a blob
        }

        public long SomeNumber
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long SomeOtherNumber
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public string AShortString
        {
            get { return (string)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public string ALongString
        {
            get { return (string)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public byte[] ABlob
        {
            get { return (byte[])Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return Dataset.UpdateId(source, titleId, userId, teamId, datasetId, 0x1, entityId, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return QueryUtil.SendUpdateIdRequest(titleId, userId, teamId, datasetId, 0x1, entityId, Attribs);
        }
#endif
    }

    public class UpdateBluk
    {
        public QueryAttribute[] Attribs;

         public UpdateBluk()
        {
            Attribs = new QueryAttribute[5];
            Attribs[0] = new QueryAttribute(0x02000001);          // some number
            Attribs[1] = new QueryAttribute(0x02000002);          // some other number
            Attribs[2] = new QueryAttribute(0x02100003);          // a short string
            Attribs[3] = new QueryAttribute(0x02100004);          // a long string
            Attribs[4] = new QueryAttribute(0x02200005);          // a blob
        }

        public long SomeNumber
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long SomeOtherNumber
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public string AShortString
        {
            get { return (string)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public string ALongString
        {
            get { return (string)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public byte[] ABlob
        {
            get { return (byte[])Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Update(source, titleId, userId, teamId, datasetId, 0x1, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendUpdateRequest(titleId, userId, teamId, datasetId, 0x1, Attribs);
        }
#endif
    }

    public class AddTimingTestDataset
    {
        public QueryAttribute[] Attribs;
        public AddTimingTestDataset()
        {
            Attribs = new QueryAttribute[3];
            Attribs[0] = new QueryAttribute(0x00000001);    // nonce
            Attribs[1] = new QueryAttribute(0x00000002);    // start time
            Attribs[2] = new QueryAttribute(0x00000003);    // end time
        }

        public long Nonce
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long StartTime
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public long EndTime
        {
            get { return (long)Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return Dataset.Add(source, titleId, userId, teamId, datasetId, Attribs, out entityId);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return QueryUtil.SendAddRequest(titleId, userId, teamId, datasetId, Attribs, null, out entityId);        
        }
#endif
    }

    public class SearchForTestResults
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public SearchForTestResults()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x02000001);          // nonce

            Specs = new QueryAttributeSpec[3];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x00000002, 30);    // start time
            Specs[2] = new QueryAttributeSpec(0x00000003, 30);    // end time
        }

        public long Nonce
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out SearchForTestResultsResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out SearchForTestResultsResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x1, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new SearchForTestResultsResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new SearchForTestResultsResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out SearchForTestResultsResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out SearchForTestResultsResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x1, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new SearchForTestResultsResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new SearchForTestResultsResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class SearchForTestResultsResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public SearchForTestResultsResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public SearchForTestResultsResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public long StartTime
        {
            get { return (long)_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public long EndTime
        {
            get { return (long)_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

    }

    public class RemoveTimingEntries
    {
        public QueryAttribute[] Attribs;

         public RemoveTimingEntries()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x02000001);          // nonce
        }

        public long Nonce
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Remove(source, titleId, userId, teamId, datasetId, 0x1, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendRemoveRequest(titleId, userId, teamId, datasetId, 0x1, Attribs);        
        }
#endif
    }

    public class AddUniqueIndexDataset
    {
        public QueryAttribute[] Attribs;
        public AddUniqueIndexDataset()
        {
            Attribs = new QueryAttribute[2];
            Attribs[0] = new QueryAttribute(0x00000001);    // some number
            Attribs[1] = new QueryAttribute(0x00000002);    // some other number
        }

        public long SomeNumber
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public long SomeOtherNumber
        {
            get { return (long)Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return Dataset.Add(source, titleId, userId, teamId, datasetId, Attribs, out entityId);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return QueryUtil.SendAddRequest(titleId, userId, teamId, datasetId, Attribs, null, out entityId);        
        }
#endif
    }

    public class AddTitleServerAddresses
    {
        public QueryAttribute[] Attribs;
        public AddTitleServerAddresses()
        {
            Attribs = new QueryAttribute[5];
            Attribs[0] = new QueryAttribute(0x80200001);    // XONLINE_LSP_ATTR_TSADDR
            Attribs[1] = new QueryAttribute(0x80200002);    // XONLINE_LSP_ATTR_XNKID
            Attribs[2] = new QueryAttribute(0x80200003);    // XONLINE_LSP_ATTR_KEK
            Attribs[3] = new QueryAttribute(0x80100004);    // XONLINE_LSP_ATTR_USER
            Attribs[4] = new QueryAttribute(0x80000005);    // XONLINE_LSP_ATTR_EXTIME
        }

        public byte[] XonlineLspAttrTsaddr
        {
            get { return (byte[])Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

        public byte[] XonlineLspAttrXnkid
        {
            get { return (byte[])Attribs[1].Value; }
            set { Attribs[1].Value = value; }
        }

        public byte[] XonlineLspAttrKek
        {
            get { return (byte[])Attribs[2].Value; }
            set { Attribs[2].Value = value; }
        }

        public string XonlineLspAttrUser
        {
            get { return (string)Attribs[3].Value; }
            set { Attribs[3].Value = value; }
        }

        public long XonlineLspAttrExtime
        {
            get { return (long)Attribs[4].Value; }
            set { Attribs[4].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return Dataset.Add(source, titleId, userId, teamId, datasetId, Attribs, out entityId);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, out ulong entityId)
        {
            return QueryUtil.SendAddRequest(titleId, userId, teamId, datasetId, Attribs, null, out entityId);        
        }
#endif
    }

    public class AvailableTitleServers
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public AvailableTitleServers()
        {
            Attribs = new QueryAttribute[0];

            Specs = new QueryAttributeSpec[4];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80200001, 36);    // XONLINE_LSP_ATTR_TSADDR
            Specs[2] = new QueryAttributeSpec(0x80200002, 8);     // XONLINE_LSP_ATTR_XNKID
            Specs[3] = new QueryAttributeSpec(0x80200003, 16);    // XONLINE_LSP_ATTR_KEK
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out AvailableTitleServersResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out AvailableTitleServersResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x1, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new AvailableTitleServersResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new AvailableTitleServersResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out AvailableTitleServersResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out AvailableTitleServersResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x1, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new AvailableTitleServersResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new AvailableTitleServersResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class AvailableTitleServersResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public AvailableTitleServersResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public AvailableTitleServersResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public byte[] XonlineLspAttrTsaddr
        {
            get { return (byte[])_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public byte[] XonlineLspAttrXnkid
        {
            get { return (byte[])_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public byte[] XonlineLspAttrKek
        {
            get { return (byte[])_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

    }

    public class AvailableTitleServersFiltered
    {
        public QueryAttribute[] Attribs;
        public QueryAttributeSpec[] Specs;

         public AvailableTitleServersFiltered()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x02000001);          // currenttime

            Specs = new QueryAttributeSpec[5];
            Specs[0] = new QueryAttributeSpec(0x80000000);       // XONLINE_QUERY_ENTITY_ID
            Specs[1] = new QueryAttributeSpec(0x80200001, 36);    // XONLINE_LSP_ATTR_TSADDR
            Specs[2] = new QueryAttributeSpec(0x80200002, 8);     // XONLINE_LSP_ATTR_XNKID
            Specs[3] = new QueryAttributeSpec(0x80200003, 16);    // XONLINE_LSP_ATTR_KEK
            Specs[4] = new QueryAttributeSpec(0x80100004, 200);   // XONLINE_LSP_ATTR_USER
        }

        public long Currenttime
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, uint datasetId, out AvailableTitleServersFilteredResults[] results)
        {
            uint totalResults;
            return Execute(source, titleId, datasetId, 0, (uint)Int32.MaxValue, out totalResults, out results);
        }

        public uint Execute(Source source, uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out AvailableTitleServersFilteredResults[] results)
        {
            results = null;
            QueryAttribute[,] attribResults;
            uint hr = Dataset.Search(source, titleId, datasetId, 0x2, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);

            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new AvailableTitleServersFilteredResults[attribResults.GetLength(0)];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new AvailableTitleServersFilteredResults(attribResults, i);
                }
            }

            return hr;    
        }
#else
        public uint Execute(uint titleId, uint datasetId, out AvailableTitleServersFilteredResults[] results)
        {
            uint totalResults;
            return Execute(titleId, datasetId, 0, XOn.XONLINE_QUERY_MAX_PAGE_SIZE, out totalResults, out results);
        }

        public uint Execute(uint titleId, uint datasetId, uint page, uint resultsPerPage, out uint totalResults, out AvailableTitleServersFilteredResults[] results)
        {
            results = null;
            QueryAttribute[] attribResults;
            uint hr = QueryUtil.SendSearchRequest(titleId, datasetId, 0x2, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
            if (HResult.Succeeded(hr) && attribResults != null)
            {
                results = new AvailableTitleServersFilteredResults[attribResults.Length / Specs.Length];
                for (int i = 0; i < results.Length; i++)
                {
                    results[i] = new AvailableTitleServersFilteredResults(attribResults, i * Specs.Length);
                }
            }
            
            return hr;    
        }
#endif
    }

    public class AvailableTitleServersFilteredResults
    {
        QueryAttribute[] _attribs;
        int _startIndex;
        
        public AvailableTitleServersFilteredResults(QueryAttribute[] attribResults, int startIndex)
        {
            _attribs = attribResults;
            _startIndex = startIndex;
        }
        public AvailableTitleServersFilteredResults(QueryAttribute[,] attribResults, int index)
        {
            _attribs = new QueryAttribute[attribResults.GetLength(1)];
            for (int i = 0; i < _attribs.Length; i++)
            {
                _attribs[i] = attribResults[index, i];
            }    
            _startIndex = 0;
        }
        public ulong EntityId
        {
            get { return (ulong)((long)_attribs[0 + _startIndex].Value); }
            set { _attribs[0 + _startIndex].Value = value; }
        }

        public byte[] XonlineLspAttrTsaddr
        {
            get { return (byte[])_attribs[1 + _startIndex].Value; }
            set { _attribs[1 + _startIndex].Value = value; }
        }

        public byte[] XonlineLspAttrXnkid
        {
            get { return (byte[])_attribs[2 + _startIndex].Value; }
            set { _attribs[2 + _startIndex].Value = value; }
        }

        public byte[] XonlineLspAttrKek
        {
            get { return (byte[])_attribs[3 + _startIndex].Value; }
            set { _attribs[3 + _startIndex].Value = value; }
        }

        public string XonlineLspAttrUser
        {
            get { return (string)_attribs[4 + _startIndex].Value; }
            set { _attribs[4 + _startIndex].Value = value; }
        }

    }

    public class RemovePreviousServer
    {
        public QueryAttribute[] Attribs;

         public RemovePreviousServer()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82200001);          // XONLINE_LSP_ATTR_TSADDR
        }

        public byte[] XonlineLspAttrTsaddr
        {
            get { return (byte[])Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Remove(source, titleId, userId, teamId, datasetId, 0x1, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendRemoveRequest(titleId, userId, teamId, datasetId, 0x1, Attribs);        
        }
#endif
    }

    public class RemoveAllDeadServers
    {
        public QueryAttribute[] Attribs;

         public RemoveAllDeadServers()
        {
            Attribs = new QueryAttribute[1];
            Attribs[0] = new QueryAttribute(0x82000005);          // XONLINE_LSP_ATTR_EXTIME
        }

        public long XonlineLspAttrExtime
        {
            get { return (long)Attribs[0].Value; }
            set { Attribs[0].Value = value; }
        }

#if XQRY
        public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return Dataset.Remove(source, titleId, userId, teamId, datasetId, 0x2, Attribs);
        }
#else
        public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId)
        {
            return QueryUtil.SendRemoveRequest(titleId, userId, teamId, datasetId, 0x2, Attribs);        
        }
#endif
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\querylib\DatasetInfo.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Web;
using System.Diagnostics;
using System.Collections;
using System.Reflection;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.service;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.sql.sqlclient;

[assembly: XomAreaDefinition(XomAreaName.log)]
[assembly: XomAreaDefinition(XomAreaName.xqry)]


namespace xonline.server.querylib
{
    public class DatasetInfo
    {
        private static Assembly _fdAsm = Assembly.GetExecutingAssembly();

        public static Assembly FrontDoorAssembly
        {
            get { return _fdAsm; }
            set { _fdAsm = value; }
        }

        public static void EnsureDSInfoIsLoaded()
        {
        }

        public static DatasetInfo GetDSInfo(uint titleId, uint datasetId)
        {
            string key = titleId.ToString("x8") + "|" + datasetId.ToString("x");
            
            DatasetInfo info = (DatasetInfo)_dsInfo[key];
            
            if(info == null)
            {
                IBucketServer bucket;
                try
                {
                     bucket = Config.GetTitleBucketServer(Interface.querydb, titleId, datasetId);
                }
                catch(Exception bucketE)
                {
                    throw new XRLException(HResult.XONLINE_E_QUERY_DATASET_NOT_FOUND, XEvent.Id.QUERY_DATASET_CONFIG_ERROR, 
                                "Couldn't find querydb server for titleid " + titleId.ToString("x8") + ", dataset " + datasetId.ToString("x8") + "!" + 
                                "   Was titlemgr run for this title and dataset?", bucketE);
                }   
                
                int quota = 0;         
                
                try
                {
                    quota = Convert.ToInt32(bucket.Info1);
                }
                catch(Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_QUERY_ERROR, XEvent.Id.QUERY_DATASET_CONFIG_ERROR_1, 
                                            "Invalid value for Owner Quota (t_interface_buckets.vc_info_1): " + bucket.Info1 + "\r\n"+ 
                                            "TitleId: " + titleId.ToString("x8") + "\r\n" + 
                                            "DatasetId: " + datasetId.ToString("x8"), ex);
                }

                info = new DatasetInfo();
                                
                info.TitleId = titleId;
                info.DatasetId = datasetId;
                info.Partition = (int)datasetId;
                info.OwnerQuota = quota;
                
                // load plugin info
                SqlClient cmd = new SqlClient(Interface.npdb);
                cmd.StoredProc = "p_query_get_plugin_info";
                cmd.AddParameter("@i_title_id", titleId);
                cmd.AddParameter("@i_dataset_id", datasetId);
                
                SqlDataReader reader = cmd.Execute();
                while(reader.Read())
                {
                    string assemblyName = (string)reader["vc_assembly"];
                    string className = (string)reader["vc_class"];
                    Hashtable ctx = null;
                    object ob;

                    // strip .dll off the name
                    if (assemblyName.EndsWith(".dll"))
                    {
                        assemblyName = assemblyName.Substring(0, assemblyName.Length - 4);
                    }

                    // replace the old namespace convention with the new, for legacy applications
                    // created with XLAST
                    //
                    className = className.Replace("XBOX.Online.Competitions.Elimination", "xonline.server.comps.query");

                    try
                    {
                        // create the plugin class
                        Assembly asm = Assembly.Load(assemblyName);
                        ob = asm.CreateInstance(className, false);
                        if (ob == null)
                        {
                            throw new Exception("Type " + className + " not found in assembly " + assemblyName + "!");
                        }

                        try
                        {
                            // Change 268493 changed the behavior of RegisterAssembly. It 
                            // used to swallow exceptions, and now it throws them. I don't 
                            // fully understand the code here in Query, nor why this 
                            // function may throw an exception, so 100% 
                            // backwards-compatibility it is. But let's at least log an 
                            // event, k?
                            XomLoggingControl.RegisterAssembly(asm);
                        }
                        catch (Exception e)
                        {
                            Xom.NtEvent( XEvent.Id.QUERY_PLUGIN_CREATION_ERROR_2, e, "An error occurred while " + 
                                        "registering the assembly " + asm.ToString() + " for " + key + 
                                        " (titleId|datasetId) with XMGMT. This is likely not " + 
                                        "fatal but should still be investigated."
                            );
                        }
                        XomPerformanceCounterCategory.InitInstPerfCtrs(asm, titleId.ToString("x8"));

                        // create the context, if specified
                        string xmlctx = null;
                        if (reader["txt_context"] != DBNull.Value)
                        {
                            xmlctx = (string)reader["txt_context"];
                        }
                        ctx = PluginUtil.XmlToHashtable(xmlctx);


                    }
                    catch(Exception e)
                    {
                        Xom.NtEvent( XEvent.Id.QUERY_PLUGIN_CREATION_ERROR_1, e, "An error occured attempting to create the plugin for " + key + " (titleId|datasetId).");
                        continue;
                    }

                    DatasetPlugin pi = new DatasetPlugin();
                    pi.ob = ob;
                    pi.ctx = ctx;

                    info.PluginList.Add(pi);
                }    
                
                _dsInfo[key] = info;
            }

            return (DatasetInfo)_dsInfo[key];
        }

        static DatasetInfo()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(DatasetInfo.OnControlRequest);
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                switch (args.Command)
                {
                // note: no help, as this simply uses the same command provided by feapp.
                // we can't use the feapp flushcache event, because it may not be compliled into
                // this assembly!

                case "cacheflush":
                    OnFlushCache(args);
                    args.Handled = true;
                    break;
                }
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

        public static void OnFlushCache(EventArgs e)
        {
            _dsInfo = new Hashtable();
        }


        private static Hashtable _dsInfo = new Hashtable();

        public uint TitleId;
        public uint DatasetId;
        public int Partition;
        public int OwnerQuota;
        public int DatasetTypeId;

        public ArrayList PluginList = new ArrayList();


        public DatasetPlugin[] GetContextPluginList(uint datasetId)
        {
            DatasetPlugin[] plugins;

            // decorate key with assembly name, since calling from a different
            // assembly will result in a casting error
            string key = "dsPlugins|" + datasetId.ToString("x") + "|" + Assembly.GetExecutingAssembly().FullName;

            if (PluginList.Count == 0)
            {
                return null;
            }

            // if it dosen't already exist, copy list of dataset plugins to httpcontext
            // with a *cloned* copy of the context hashtable.
            plugins = (DatasetPlugin[])HttpContext.Current.Items[key];
            if (plugins == null)
            {
                plugins = new DatasetPlugin[PluginList.Count];
                for (int i = 0; i < plugins.Length; i++)
                {
                    DatasetPlugin dspi = (DatasetPlugin)PluginList[i];
                    plugins[i] = new DatasetPlugin();
                    plugins[i].ob = dspi.ob;
                    plugins[i].ctx = (Hashtable)dspi.ctx.Clone();
                }

                HttpContext.Current.Items[key] = plugins;
            }

            return plugins;
        }

        public HResult BeforeAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs)
        {
            uint hr = HResult.S_OK;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryAdd)
                    {
                        IQueryAdd pi = (IQueryAdd)plugins[i].ob;

                        hr = pi.BeforeAdd(source, titleId, userId, teamId, datasetId, attribs, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }

                }
            }


            return hr;
        }

        public HResult AfterAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, ulong entityId)
        {
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);
            uint hr = HResult.S_OK;

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryAdd)
                    {
                        IQueryAdd pi = (IQueryAdd)plugins[i].ob;
                        hr = pi.AfterAdd(source, titleId, userId, teamId, datasetId, attribs, entityId, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }
            }

            return hr;
        }

        public HResult BeforeUpdate(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            uint hr = HResult.S_OK;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryUpdate)
                    {
                        IQueryUpdate pi = (IQueryUpdate)plugins[i].ob;
                        hr = pi.BeforeUpdate(source, titleId, userId, teamId, datasetId, procIndex, attribs, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }
            }

            return hr;
        }

        public void AfterUpdate(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryUpdate)
                    {
                        IQueryUpdate pi = (IQueryUpdate)plugins[i].ob;
                        pi.AfterUpdate(source, titleId, userId, teamId, datasetId, procIndex, attribs, plugins[i].ctx);
                    }
                }
            }
            return;
        }

        public HResult BeforeUpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attribs)
        {
            uint hr = HResult.S_OK;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryUpdateId)
                    {
                        IQueryUpdateId pi = (IQueryUpdateId)plugins[i].ob;
                        hr = pi.BeforeUpdateId(source, titleId, userId, teamId, datasetId, procIndex, attribs, entityId, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }
            }

            return hr;
        }

        public void AfterUpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attribs)
        {
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryUpdateId)
                    {
                        IQueryUpdateId pi = (IQueryUpdateId)plugins[i].ob;
                        pi.AfterUpdateId(source, titleId, userId, teamId, datasetId, procIndex, attribs, entityId, plugins[i].ctx);
                    }
                }
            }
            return;
        }

        public HResult BeforeRemove(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            uint hr = HResult.S_OK;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryRemove)
                    {
                        IQueryRemove pi = (IQueryRemove)plugins[i].ob;
                        hr = pi.BeforeRemove(source, titleId, userId, teamId, datasetId, procIndex, attribs, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }
            }

            return hr;
        }

        public void AfterRemove(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryRemove)
                    {
                        IQueryRemove pi = (IQueryRemove)plugins[i].ob;
                        pi.AfterRemove(source, titleId, userId, teamId, datasetId, procIndex, attribs, plugins[i].ctx);
                    }
                }
            }

            return;
        }


        public HResult BeforeRemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            uint hr = HResult.S_OK;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryRemoveId)
                    {
                        IQueryRemoveId pi = (IQueryRemoveId)plugins[i].ob;
                        hr = pi.BeforeRemoveId(source, titleId, userId, teamId, datasetId, entityId, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }
            }

            return hr;
        }

        public void AfterRemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryRemoveId)
                    {
                        IQueryRemoveId pi = (IQueryRemoveId)plugins[i].ob;
                        pi.AfterRemoveId(source, titleId, userId, teamId, datasetId, entityId, plugins[i].ctx);
                    }
                }
            }
            return;
        }

        public HResult Select(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint actionId, QueryAttribute[] attribs, BundledAuthData bundledAuth, TeamTickets bundledTickets)
        {
            uint hr = HResult.XONLINE_E_QUERY_INVALID_ACTION;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQuerySelect)
                    {
                        IQuerySelect pi = (IQuerySelect)plugins[i].ob;

                        // Add auth data if any
                        if (null != bundledAuth)
                        {
                            plugins[i].ctx.Add("bundledAuth", bundledAuth);
                        }

                        // Add team tickets data if any
                        if (null != bundledTickets)
                        {
                            plugins[i].ctx.Add("bundledTickets", bundledTickets);
                        }

                        hr = pi.Select(source, titleId, userId, teamId, datasetId, entityId, actionId, attribs, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }

            }

            return hr;
        }



        public HResult BeforeSearch(Source source, uint titleId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            uint hr = HResult.S_OK;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQuerySearch)
                    {
                        IQuerySearch pi = (IQuerySearch)plugins[i].ob;
                        hr = pi.BeforeSearch(source, titleId, datasetId, procIndex, attribs, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }

            }

            return hr;
        }



        public HResult BeforeFindFromIds(Source source, uint titleId, uint datasetId, uint procIndex, ulong [] entityIds)
        {
            uint hr = HResult.S_OK;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryFindFromIds)
                    {
                        IQueryFindFromIds pi = (IQueryFindFromIds)plugins[i].ob;

                        hr = pi.BeforeFind(source, titleId, datasetId, procIndex, entityIds, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }

            }

            return hr;
        }


        public HResult BeforeCustom(Source source, uint titleId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            uint hr = HResult.S_OK;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryCustom)
                    {
                        IQueryCustom pi = (IQueryCustom)plugins[i].ob;

                        hr = pi.BeforeCustom(source, titleId, datasetId, procIndex, attribs, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }

            }

            return hr;
        }
    }

    public struct DatasetPlugin
    {
        public object ob;
        public Hashtable ctx;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\test\dvt\querytest.cs ===
using System;
using System.IO;
using System.Text;
using System.Threading;

using ServerTestFramework;
using xonline.common.diagnostics;
using xonline.common.nUnit;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.server.comps.common;
using xonline.common.mgmt;

using xonline.server.query.plugins.Sample2;

namespace xonline.server.query.test.dvt 
{
    [TestGroup, DVT]
    public class QueryDevTest : TestNode
    {    
        public const uint c_titleId = 0x00004d2;
        
        public const uint c_dsTest = 0x1;
        
        public const uint XONLINE_QUERY_ENTITY_ID                 = 0x80000000;
        public const uint XONLINE_QUERY_OWNER_PUID                = 0x80000001;
        
        public const uint XONLINE_QUERY_ATTR_INT1                 = 0x00000001;
        public const uint XONLINE_QUERY_ATTR_INT2                 = 0x00000002;
        public const uint XONLINE_QUERY_ATTR_STRING1              = 0x00100003;
        public const uint XONLINE_QUERY_ATTR_STRING2              = 0x00100004;
        public const uint XONLINE_QUERY_ATTR_BLOB1                = 0x00200005;
        
        /*
        
        public class SmokeTestDatsetAdd
        {
            public QueryAttribute[] Attribs;
            
            public SmokeTestDatsetAddParams
            {
                 Attribs = new QueryAttribute[5];
                 Attribs[0] = new QueryAttribute();
                 Attribs[0].Id = XONLINE_QUERY_ATTR_INT1;
                 Attribs[1] = new QueryAttribute();
                 Attribs[1].Id = XONLINE_QUERY_ATTR_INT2;
                 Attribs[2] = new QueryAttribute();
                 Attribs[2].Id = XONLINE_QUERY_ATTR_STRING1;
                 Attribs[3] = new QueryAttribute();
                 Attribs[3].Id = XONLINE_QUERY_ATTR_STRING2;
                 Attribs[4] = new QueryAttribute();
                 Attribs[4].Id = XONLINE_QUERY_ATTR_BLOB1;
            }
            
            public ulong Int1
            {
                get { return Attribs[0].lValue; }
                set { Attribs[0].lValue = value; }
            }
            
            
            
#ifdef XQRY
            public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, out entityId)
            {
                return Dataset.Add(source, titleId, userId, teamId, datasetId, attribs, out entityEntrant);
            }
#else
            public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, out entityId)
            {
                return QueryUtil.SendAddRequest(titleId, userId, teamId, datasetId, attribs, null, out entityId);        
            }
                
#endif
        }
        
        public class Test1Search
        {
        
            public QueryAttribute[] Attribs;
            
            public SmokeTestDtasetSearch
            {
                Attribs = new QueryAttribute[5];
                Attribs[0] = new QueryAttribute(XONLINE_QUERY_ATTR_INT1);
                Attribs[1] = new QueryAttribute(XONLINE_QUERY_ATTR_INT2);
                Attribs[2] = new QueryAttribute(XONLINE_QUERY_ATTR_STRING1);
                Attribs[3] = new QueryAttribute(XONLINE_QUERY_ATTR_STRING2);
                Attribs[4] = new QueryAttribute(XONLINE_QUERY_ATTR_BLOB1);
                
                Specs = new QueryAttributeSpec[6];
                Specs[0] = new QueryAttributeSpec(XONLINE_QUERY_ENTITY_ID);
                Specs[1] = new QueryAttributeSpec(XONLINE_QUERY_ATTR_INT1);
                Specs[2] = new QueryAttributeSpec(XONLINE_QUERY_ATTR_INT2);
                Specs[3] = new QueryAttributeSpec(XONLINE_QUERY_ATTR_STRING1, 400);
                Specs[4] = new QueryAttributeSpec(XONLINE_QUERY_ATTR_STRING2, 400);  
                Specs[5] = new QueryAttributeSpec(XONLINE_QUERY_ATTR_BLOB1, 800);
            }
            
            public ulong Int1
            {
                get { return Attribs[0].lValue; }
                set { Attribs[0].lValue = value; }
            }

            // etc..
            
            

#ifdef XQRY
            public uint Execute(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, out entityId)
#else
            public uint Execute(uint titleId, ulong userId, ulong teamId, uint datasetId, uint resultsPerPage, out TestOneSearchResults[] results)
#endif
            {
                QueryAttribute[] attribResults;
                
                results = null;
#ifdef XQRY
                hr = Dataset.Search(source, titleId, datasetId, 1, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
#else
                hr = QueryUtil.SendSearchRequest(titleId, userId, teamId, datasetId, 1, page, resultsPerPage, Attribs, Specs, out totalResults, out attribResults);
#endif                
                if (HResult.Succeeded(hr))
                {
                    results = new Test1SearchResults[attribResults.Length / Specs.Length];
                    for (i = 0; i < results.Length; i++)
                    {
                        results[i] = new Test1SearchResults(attribResults, i * Specs.Length);
                    }
                }
                
                return hr;    
            }
        }
        
        
        public class Test1SearchResults
        {
            QueryAttribute[] _attribs;
            int _startIndex;
            
            public Test1SearchResults(QueryAttribute[] attribResults, int startIndex)
            {
                _attribs = attribResults;
                _startIndex = startIndex;
            }                
                
            public ulong Int1
            {
                get { return Attribs[_startIndex + 0].lValue; }
                //set { Attribs[_startIndex + 0].lValue = value; }
            }
        }
        
                 
                 
        */         
                 
                
            
            
            

        public ulong Add(ulong userId)
        {
            return Add(userId, 0);
        }    

        public ulong Add(ulong userId, long r)
        {
            int                 i;
            ulong               entityId;
            QueryAttribute[]    attribs;
            
            Console.WriteLine("Calling Query.Add");
            Console.WriteLine();

            attribs = new QueryAttribute[5];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }


            //
            // Setup attributes
            //
            attribs[0].Id = XONLINE_QUERY_ATTR_INT1;
            attribs[0].Value = (long)userId;            
            attribs[1].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[1].Value = (long)r;            
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[2].Value = "Query WebService TestQueryAdd";
            attribs[3].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[3].Value = "Query WebService TestQueryAdd2";            
            attribs[4].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[4].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };

            uint hr = QueryUtil.SendAddRequest(c_titleId, userId, 0, c_dsTest, attribs, null, out entityId);
            
            Assert.AreEqual(hr, HResult.S_OK);
            
            Console.WriteLine("entity " + entityId + " added." );
            Console.WriteLine();

            return entityId;
        }
        
        public void RemoveForUser(ulong userId)
        {
            Console.WriteLine("Removing all entities for userid " + userId);
            
            uint hr = QueryUtil.SendRemoveRequest(c_titleId, userId, 0, c_dsTest, 2, null);
            Assert.IsTrue(hr == HResult.S_OK || hr == HResult.XONLINE_E_QUERY_PERMISSION_DENIED || hr == HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND);
        }
            


        public void RemoveId(ulong userId, ulong entityId)
        {
            Console.WriteLine("Calling Query.RemoveId");
            Console.WriteLine();

            uint hr = QueryUtil.SendRemoveIdRequest(c_titleId, userId, 0, c_dsTest, entityId);
            
            Assert.AreEqual(hr, HResult.S_OK);

            Console.WriteLine("entity " + entityId + " removed." );
            Console.WriteLine();
        }


        public void UpdateId(ulong userId, ulong entityId)
        {
            int                 i;
            QueryAttribute[]    attribs;

            Console.WriteLine("Calling Query.UpdateId");
            Console.WriteLine();

            attribs = new QueryAttribute[5];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }


            //
            // Setup attributes
            //
            attribs[0].Id = XONLINE_QUERY_ATTR_INT1;
            attribs[0].Value = (long)2;            
            attribs[1].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[1].Value = (long)6;            
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[2].Value = "A short update string";
            attribs[3].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[3].Value = "A really loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong string";            
            attribs[4].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[4].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7 };

            uint hr = QueryUtil.SendUpdateIdRequest(c_titleId, userId, 0, c_dsTest, 1, entityId, attribs);

            Assert.AreEqual(hr, HResult.S_OK);
            
            Console.WriteLine("entity " + entityId + " updated." );
            Console.WriteLine();

        }

        [TestCase]
        public void TestQueryAdd()
        {
            ulong               userId = User.GetRandomPuid();
            
            Add(userId);
        }
        

        [TestCase]
        public void TestQueryRemoveId()
        {
            ulong               userId = User.GetRandomPuid();
            ulong               entityId = Add(userId);
            
            RemoveId(userId, entityId);
        }

        
        [TestCase]
        public void TestQueryUpdate()
        {
            int                 i;
            QueryAttribute[]    attribs;

            // Ensure there is something to update
            ulong               userId = User.GetRandomPuid();
            ulong               entityId = Add(userId);
            
            Console.WriteLine("Calling Query.Update");
            Console.WriteLine();

            attribs = new QueryAttribute[5];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }


            //
            // Setup attributes
            //
            attribs[0].Id = XONLINE_QUERY_ATTR_INT1;
            attribs[0].Value = (long)2;            
            attribs[1].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[1].Value = (long)0x7FFFFFFF00000000;            
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[2].Value = "Update updates everything by this owner";
            attribs[3].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[3].Value = "See, we are all the same";            
            attribs[4].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[4].Value = new byte[] { 0x1 };

            uint hr = QueryUtil.SendUpdateRequest(c_titleId, userId, 0, c_dsTest, 1, attribs);
            Assert.AreEqual(hr, HResult.S_OK);

            Console.WriteLine("entities for owner " + userId + " updated." );
            Console.WriteLine();

            //
            // Cleanup
            //
            RemoveId(userId, entityId);
        }


        [TestCase]
        public void TestQueryUpdateId()
        {
            ulong               userId = User.GetRandomPuid();
            ulong               entityId = Add(userId);
            
            UpdateId(userId, entityId);

            //
            // Cleanup
            //
            RemoveId(userId, entityId);
        }


        [TestCase]
        public void TestQueryRemove()
        {
            int                 i;
            QueryAttribute[]    attribs, returnedAttribs;
            ulong               userId = User.GetRandomPuid();
            long r = (new Random()).Next();
            ulong               entityId = Add(userId, r);
            uint hr;

            
            
            Console.WriteLine("Calling Query.Remove");
            Console.WriteLine();

            attribs = new QueryAttribute[4];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }

            //
            // Setup attributes
            //
            attribs[0].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[0].Value = r;            
            attribs[1].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[1].Value = "Query WebService TestQueryAdd";
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[2].Value = "Query WebService TestQueryAdd2";            
            attribs[3].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[3].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };

            hr = QueryUtil.SendRemoveRequest(c_titleId, userId, 0, c_dsTest, 1, attribs);
            Assert.AreEqual(hr, HResult.S_OK);

            Console.WriteLine("Remove successful.  Verifying actual removal..");
            
            ulong[] entityIds = new ulong[] { entityId };
            
            QueryAttributeSpec[] specs = new QueryAttributeSpec[6];
            for (i = 0; i < specs.Length; i++)    { specs[i] = new QueryAttributeSpec(); }

            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[1].type = XONLINE_QUERY_ATTR_INT1;
            specs[2].type = XONLINE_QUERY_ATTR_INT2;    
            specs[3].type = XONLINE_QUERY_ATTR_STRING1;    
            specs[3].len = 400;
            specs[4].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[4].len = 400;            
            specs[5].type = XONLINE_QUERY_ATTR_BLOB1;   
            specs[5].len = 800;

            
            uint totalResults = 0;

            hr = QueryUtil.SendFindFromIdsRequest(c_titleId, c_dsTest, 1, specs, entityIds, out totalResults, out returnedAttribs);
            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND);
            
            Console.WriteLine("entities with int2 > 5 removed." );
            Console.WriteLine();


            Console.WriteLine("calling remove again, expecting XONLINE_E_QUERY_ENTITY_NOT_FOUND" );
            Console.WriteLine();

            hr = QueryUtil.SendRemoveRequest(c_titleId, userId, 0, c_dsTest, 1, attribs);
            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND);

            Console.WriteLine("Done.");
            

            
            Console.WriteLine("Calling Query.Remove on entry owned by a different user");
            Console.WriteLine();
            
            ulong               userId2 = User.GetRandomPuid();
            ulong               entityId2 = Add(userId2, r);
                        
            hr = QueryUtil.SendRemoveRequest(c_titleId, userId, 0, c_dsTest, 1, attribs);
            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_PERMISSION_DENIED);
            
            entityIds[0] = entityId2;
            hr = QueryUtil.SendFindFromIdsRequest(c_titleId, c_dsTest, 1, specs, entityIds, out totalResults, out returnedAttribs);
            Assert.AreEqual(hr, HResult.S_OK);
            Assert.IsTrue(totalResults >= 1);

            //
            // Cleanup
            //
            RemoveId(userId2, entityId2);
        
        }

        


        [TestCase]
        public void TestQuerySearch()
        {
            int                     i;
            uint                    totalResults;
            QueryAttribute[]        attribs;
            QueryAttributeSpec[]    specs;
            QueryAttribute[]        attribResults;
            
            
            // Add something so we have something to find. 
            ulong               userId = User.GetRandomPuid();
            ulong               entityId = Add(userId);
            
            Console.WriteLine("Calling Query.Search");
            Console.WriteLine();

            attribs = new QueryAttribute[4];
            for (i = 0; i < attribs.Length; i++)  { attribs[i] = new QueryAttribute(); }

            attribs[0].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[0].Value = (long)1;            
            attribs[1].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[1].Value = "Query WebService TestQueryAdd";
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[2].Value = "Query WebService TestQueryAdd2";            
            attribs[3].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[3].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };
            
            specs = new QueryAttributeSpec[6];
            for (i = 0; i < specs.Length; i++)    { specs[i] = new QueryAttributeSpec(); }

            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[0].len = 8;            
            specs[1].type = XONLINE_QUERY_ATTR_INT1;
            specs[1].len = 8;            
            specs[2].type = XONLINE_QUERY_ATTR_INT2;    
            specs[2].len = 8;            
            specs[3].type = XONLINE_QUERY_ATTR_STRING1;    
            specs[3].len = 400;
            specs[4].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[4].len = 400;            
            specs[5].type = XONLINE_QUERY_ATTR_BLOB1;   
            specs[5].len = 800;

            uint hr = QueryUtil.SendSearchRequest(c_titleId, c_dsTest, 1, 0, 20, attribs, specs, out totalResults, out attribResults);

            Assert.AreEqual(hr, HResult.S_OK);
            
            
            Console.WriteLine("Searched and found " + totalResults + " entities." );
            Console.WriteLine();

            //
            // Cleanup
            //
            RemoveId(userId, entityId);
        }
        
        [TestCase]
        public void TestQuerySearchPaging()
        {
            int                     i;
            uint                    totalResults;
            QueryAttribute[]        attribs;
            QueryAttributeSpec[]    specs;
            QueryAttribute[]        attribResults;
            ulong[]                 userIds = User.GetRandomPuids(5);
            ulong[]                 entityIds = new ulong[5];
            
            // come up with some random number to uniquely filter on the 
            // rows created with just this run
            long r = (new Random()).Next();
            
            for (i = 0; i < entityIds.Length; i++)
            {
                entityIds[i] = Add(userIds[i], r);
            }
            
            attribs = new QueryAttribute[4];
            for (i = 0; i < attribs.Length; i++)  { attribs[i] = new QueryAttribute(); }

            attribs[0].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[0].Value = r;            
            attribs[1].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[1].Value = "Query WebService TestQueryAdd";
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[2].Value = "Query WebService TestQueryAdd2";            
            attribs[3].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[3].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };
            
            specs = new QueryAttributeSpec[6];
            for (i = 0; i < specs.Length; i++)    { specs[i] = new QueryAttributeSpec(); }

            specs[0].type = XONLINE_QUERY_ENTITY_ID & XOn.X_ATTRIBUTE_DATATYPE_MASK;
            specs[0].len = 8;            
            specs[1].type = XONLINE_QUERY_ATTR_INT1 & XOn.X_ATTRIBUTE_DATATYPE_MASK;
            specs[1].len = 8;            
            specs[2].type = XONLINE_QUERY_ATTR_INT2 & XOn.X_ATTRIBUTE_DATATYPE_MASK;    
            specs[2].len = 8;            
            specs[3].type = XONLINE_QUERY_ATTR_STRING1 & XOn.X_ATTRIBUTE_DATATYPE_MASK;
            specs[3].len = 400;
            specs[4].type = XONLINE_QUERY_ATTR_STRING2 & XOn.X_ATTRIBUTE_DATATYPE_MASK;
            specs[4].len = 400;            
            specs[5].type = XONLINE_QUERY_ATTR_BLOB1 & XOn.X_ATTRIBUTE_DATATYPE_MASK;
            specs[5].len = 800;


            Console.WriteLine("Calling Query.Search, page 0");
            Console.WriteLine();

            uint hr = QueryUtil.SendSearchRequest(c_titleId, c_dsTest, 1, 0, 3, attribs, specs, out totalResults, out attribResults);
            Assert.AreEqual(hr, HResult.S_OK);
            

            Assert.AreEqual(hr, HResult.S_OK);
            Assert.IsTrue(attribResults != null);
            Console.WriteLine("Searched and found " + attribResults.Length/specs.Length + " rows." );
            Console.WriteLine();
            Assert.IsTrue(totalResults == 5);
            Assert.IsTrue(attribResults.Length/specs.Length == 3);
            
            
            Console.WriteLine("Calling Query.Search, page 1");
            Console.WriteLine();
            
            hr = QueryUtil.SendSearchRequest(c_titleId, c_dsTest, 1, 1, 3, attribs, specs, out totalResults, out attribResults);
            Assert.AreEqual(hr, HResult.S_OK);
            Assert.IsTrue(totalResults == 5);
            Assert.IsTrue(attribResults.Length/specs.Length == 2);
            
            
            Console.WriteLine("Searched and found " + attribResults.Length/specs.Length + " rows." );
            Console.WriteLine();


            Console.WriteLine("Calling Query.Search, page 2");
            Console.WriteLine();
            
            hr = QueryUtil.SendSearchRequest(c_titleId, c_dsTest, 1, 2, 3, attribs, specs, out totalResults, out attribResults);
            Assert.AreEqual(hr, HResult.S_OK);
            Assert.IsTrue(totalResults == 5);
            Assert.IsTrue(attribResults.Length == 0);
            
            Console.WriteLine("Searched and found 0 entities." );
            Console.WriteLine();

            Console.WriteLine("Calling Query.Search, page XONLINE_QUERY_MAX_PAGE");
            Console.WriteLine();
            
            hr = QueryUtil.SendSearchRequest(c_titleId, c_dsTest, 1, XOn.XONLINE_QUERY_MAX_PAGE, 3, attribs, specs, out totalResults, out attribResults);
            Assert.AreEqual(hr, HResult.S_OK);
            Assert.IsTrue(totalResults == 5);
            Assert.IsTrue(attribResults.Length == 0);
            
            Console.WriteLine("Searched and found 0 entities." );
            Console.WriteLine();


            Console.WriteLine("Calling Query.Search, page MAX_UINT");
            Console.WriteLine();
            
            hr = QueryUtil.SendSearchRequest(c_titleId, c_dsTest, 1, UInt32.MaxValue, 3, attribs, specs, out totalResults, out attribResults);
            Assert.AreEqual(hr, HResult.E_INVALIDARG);
            
            Console.WriteLine("Searched and got back E_INVALIDARG." );
            Console.WriteLine();

            
            //
            // Cleanup
            //
            for (i = 0; i < entityIds.Length; i++)
            {
                RemoveId(userIds[i], entityIds[i]);
            }    
        }
         

        [TestCase]
        public void TestQueryFind()
        {
            int                     i;
            ulong                   userId = User.GetRandomPuid();
            ulong[]                 entityIds;
            uint                    totalResults;
            QueryAttribute[]        attribResults;            
            QueryAttributeSpec[]    specs;
            
            Console.WriteLine("Calling Query.FindFromIds with one id");
            Console.WriteLine();

            entityIds = new ulong[1];
            entityIds[0] = Add(userId);
          
            specs = new QueryAttributeSpec[6];
            for (i = 0; i < specs.Length; i++)    { specs[i] = new QueryAttributeSpec(); }

            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[0].len = 8;            
            specs[1].type = XONLINE_QUERY_ATTR_INT1;
            specs[1].len = 8;            
            specs[2].type = XONLINE_QUERY_ATTR_INT2;    
            specs[2].len = 8;            
            specs[3].type = XONLINE_QUERY_ATTR_STRING1;    
            specs[3].len = 400;
            specs[4].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[4].len = 400;            
            specs[5].type = XONLINE_QUERY_ATTR_BLOB1;   
            specs[5].len = 800;

            uint hr = QueryUtil.SendFindFromIdsRequest(c_titleId, c_dsTest, 1, specs, entityIds, out totalResults, out attribResults);
            Assert.AreEqual(hr, HResult.S_OK);

            Console.WriteLine("FindFromIds found " + totalResults + " entities. (Expected 1)" );
            Console.WriteLine();
            
            RemoveId(userId, entityIds[0]);



            Console.WriteLine("Calling Query.FindFromIds with two ids");
            Console.WriteLine();

            entityIds = new ulong[2];
            entityIds[0] = Add(userId);
            entityIds[1] = Add(userId);
          
            hr = QueryUtil.SendFindFromIdsRequest(c_titleId, c_dsTest, 1, specs, entityIds, out totalResults, out attribResults);
            Assert.AreEqual(hr, HResult.S_OK);
            Assert.IsTrue(totalResults == 2);
            

            Console.WriteLine("FindFromIds found " + totalResults + " entities. (Expected 1)" );
            Console.WriteLine();

            
            //
            // Cleanup
            //
            RemoveId(userId, entityIds[0]);
            RemoveId(userId, entityIds[1]);
            
            
            hr = QueryUtil.SendFindFromIdsRequest(c_titleId, c_dsTest, 1, specs, entityIds, out totalResults, out attribResults);
            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_ENTITY_NOT_FOUND);
            
            
        }

        
        [TestCase]
        public void TestAddBoundryCases()
        {
            int                     i;
            uint                    hr;
            ulong                   userId = User.GetRandomPuid();
            ulong                   entityId;
            string                  overflow;
            byte[]                  rgOverflow;
            QueryAttribute[]        attribs;
        
            RemoveForUser(userId);
        
            // 
            // Add a row that succeeds
            //
            Console.WriteLine("Adding a row for user " + userId);

            attribs = new QueryAttribute[5];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }
            
            attribs[0].Id = XONLINE_QUERY_ATTR_INT1;
            attribs[0].lValue = 1;
            attribs[1].Id = XONLINE_QUERY_ATTR_INT2;
            attribs[1].lValue = 2;
            
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING1;    // string
            attribs[2].strValue = "short string 1";
            attribs[3].Id = XONLINE_QUERY_ATTR_STRING2;    // string
            attribs[3].strValue = "short string 2";
            
            attribs[4].Id = XONLINE_QUERY_ATTR_BLOB1;    // blob
            attribs[4].binValue = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };

            hr = QueryUtil.SendAddRequest(c_titleId, userId, 0, c_dsTest, attribs, null, out entityId);

            Assert.AreEqual(hr, HResult.S_OK);
            if (HResult.Succeeded(hr))
            {
                Console.WriteLine("Row " + entityId + " added Successfully");
            }            
            
            // 
            // Add a row with a string that is too big
            //
            overflow = "This string is going to be too big: ";      // 400 is max size for a string attribute
            for (i=0; i< 400; i++)
            {
                overflow += "a";
            }

            attribs[2].strValue = overflow;

            hr = QueryUtil.SendAddRequest(c_titleId, userId, 0, c_dsTest, attribs, null, out entityId);

            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_ATTRIBUTE_TOO_LONG);
            
            // 
            // Add a row with a blob that is too big
            //            
            rgOverflow = new byte[1000];    // 800 is max size for a blob

            for (i=0; i< 400; i++)
            {
                rgOverflow[i] = (byte)(i % 256);
            }

            attribs[2].strValue = overflow;
            attribs[4].binValue = rgOverflow;

            hr = QueryUtil.SendAddRequest(c_titleId, userId, 0, c_dsTest, attribs, null, out entityId);

            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_ATTRIBUTE_TOO_LONG);
            if (HResult.Succeeded(hr))
            {
                Console.WriteLine("Add operation rejected with XONLINE_E_QUERY_ATTRIBUTE_TOO_LONG");
            }            

            // 
            // Add a row with a string and blob that are just the right size
            //            
            rgOverflow = new byte[800];    // 800 is max size for a blob

            for (i=0; i < 800; i++)
            {
                rgOverflow[i] = (byte)(i % 256);
            }

            
            attribs[2].strValue = overflow.Substring(0, 400);
            attribs[4].binValue = rgOverflow;

            hr = QueryUtil.SendAddRequest(c_titleId, userId, 0, c_dsTest, attribs, null, out entityId);

            Assert.AreEqual(hr, HResult.S_OK);
            // 
            // TODO: cleanup
            //
                     


        }


        [TestCase]
        public void TestBadParams()
        {
            int                     i;
            uint                    hr;
            ulong                   userId = User.GetRandomPuid();
            ulong                   entityId;
            ulong[]                   entityIds;
            QueryAttribute[]        attribs;
            QueryAttributeSpec[]    specs;
            uint totalResults;
            QueryAttribute[]        attribResults;
        
            // 
            // add with an unexpected param
            //
            Console.WriteLine("Adding a row for user " + userId + " with a bad parameter");

            attribs = new QueryAttribute[5];
            for (i = 0; i < attribs.Length; i++)    { attribs[i] = new QueryAttribute(); }
            
            attribs[0].Id = XONLINE_QUERY_ATTR_INT1;
            attribs[0].lValue = 1;
            attribs[1].Id = XONLINE_QUERY_ATTR_INT2;
            attribs[1].lValue = 2;
            
            attribs[2].Id = 0x10123456;                   // random
            attribs[2].strValue = "short string 1";
            attribs[3].Id = XONLINE_QUERY_ATTR_STRING2;    // string
            attribs[3].strValue = "short string 2";
            
            attribs[4].Id = XONLINE_QUERY_ATTR_BLOB1;    // blob
            attribs[4].binValue = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };

            hr = QueryUtil.SendAddRequest(c_titleId, userId, 0, c_dsTest, attribs, null, out entityId);

            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE);
            if (hr == HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE)
            {
                Console.WriteLine("Bad parameter detected successfully. hr = XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE");
            }            
            
            
            //
            // search with too many attributes
            //
            
            Console.WriteLine("Calling Search with too many attributes");
            Console.WriteLine();

            attribs = new QueryAttribute[6];
            for (i = 0; i < attribs.Length; i++)  { attribs[i] = new QueryAttribute(); }

            attribs[0].Id = XONLINE_QUERY_ATTR_INT1;
            attribs[0].Value = (long)1234;            
            attribs[1].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[1].Value = (long)1;            
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[2].Value = "Query WebService TestQueryAdd";
            attribs[3].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[3].Value = "Query WebService TestQueryAdd2";            
            attribs[4].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[4].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };
            attribs[5].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[5].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };
            
            specs = new QueryAttributeSpec[5];
            for (i = 0; i < specs.Length; i++)    { specs[i] = new QueryAttributeSpec(); }

            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[0].len = 8;            
            specs[1].type = XONLINE_QUERY_ATTR_INT1;
            specs[1].len = 8;            
            specs[2].type = XONLINE_QUERY_ATTR_INT2;    
            specs[2].len = 8;            
            specs[3].type = XONLINE_QUERY_ATTR_STRING1;    
            specs[3].len = 400;
            specs[4].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[4].len = 400;            

            hr = QueryUtil.SendSearchRequest(c_titleId, c_dsTest, 1, 0, 20, attribs, specs, out totalResults, out attribResults);

            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE);
            

            //
            // search with too few attributes
            //
            
            Console.WriteLine("Calling Search with too few attributes");
            Console.WriteLine();

            attribs = new QueryAttribute[4];
            for (i = 0; i < attribs.Length; i++)  { attribs[i] = new QueryAttribute(); }

            attribs[0].Id = XONLINE_QUERY_ATTR_INT1;
            attribs[0].Value = (long)1234;            
            attribs[1].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[1].Value = (long)1;            
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[2].Value = "Query WebService TestQueryAdd";
            attribs[3].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[3].Value = "Query WebService TestQueryAdd2";            
            
            specs = new QueryAttributeSpec[5];
            for (i = 0; i < specs.Length; i++)    { specs[i] = new QueryAttributeSpec(); }

            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[0].len = 8;            
            specs[1].type = XONLINE_QUERY_ATTR_INT1;
            specs[1].len = 8;            
            specs[2].type = XONLINE_QUERY_ATTR_INT2;    
            specs[2].len = 8;            
            specs[3].type = XONLINE_QUERY_ATTR_STRING1;    
            specs[3].len = 400;
            specs[4].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[4].len = 400;            

            hr = QueryUtil.SendSearchRequest(c_titleId, c_dsTest, 1, 0, 20, attribs, specs, out totalResults, out attribResults);

            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE);

            
            //
            // search with too few specs
            //
            
            Console.WriteLine("Calling Search with too few specs");
            Console.WriteLine();

            attribs = new QueryAttribute[4];
            for (i = 0; i < attribs.Length; i++)  { attribs[i] = new QueryAttribute(); }

            attribs[0].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[0].Value = (long)1;            
            attribs[1].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[1].Value = "Query WebService TestQueryAdd";
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[2].Value = "Query WebService TestQueryAdd2";            
            attribs[3].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[3].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };
            
            specs = new QueryAttributeSpec[5];
            for (i = 0; i < specs.Length; i++)    { specs[i] = new QueryAttributeSpec(); }

            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[0].len = 8;            
            specs[1].type = XONLINE_QUERY_ATTR_INT1;
            specs[1].len = 8;            
            specs[2].type = XONLINE_QUERY_ATTR_INT2;    
            specs[2].len = 8;            
            specs[3].type = XONLINE_QUERY_ATTR_STRING1;    
            specs[3].len = 400;
            specs[4].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[4].len = 400;            

            hr = QueryUtil.SendSearchRequest(c_titleId, c_dsTest, 1, 0, 20, attribs, specs, out totalResults, out attribResults);

            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_SPEC_COUNT_MISMATCH);
            
            //
            // search with too many specs
            //
            
            Console.WriteLine("Calling Search with too many specs");
            Console.WriteLine();

            attribs = new QueryAttribute[4];
            for (i = 0; i < attribs.Length; i++)  { attribs[i] = new QueryAttribute(); }

            attribs[0].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[0].Value = (long)1;            
            attribs[1].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[1].Value = "Query WebService TestQueryAdd";
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[2].Value = "Query WebService TestQueryAdd2";            
            attribs[3].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[3].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };
            
            specs = new QueryAttributeSpec[7];
            for (i = 0; i < specs.Length; i++)    { specs[i] = new QueryAttributeSpec(); }

            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[0].len = 8;            
            specs[1].type = XONLINE_QUERY_ATTR_INT1;
            specs[1].len = 8;            
            specs[2].type = XONLINE_QUERY_ATTR_INT2;    
            specs[2].len = 8;            
            specs[3].type = XONLINE_QUERY_ATTR_STRING1;    
            specs[3].len = 400;
            specs[4].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[4].len = 400;            
            specs[5].type = XONLINE_QUERY_ATTR_BLOB1;   
            specs[5].len = 800;
            specs[6].type = XONLINE_QUERY_ATTR_BLOB1;   
            specs[6].len = 800;

            hr = QueryUtil.SendSearchRequest(c_titleId, c_dsTest, 1, 0, 20, attribs, specs, out totalResults, out attribResults);

            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_SPEC_COUNT_MISMATCH);


            //
            // search with wrong dataset id
            //
            
            Console.WriteLine("Calling search with invalid dataset id");
            Console.WriteLine();

            attribs = new QueryAttribute[5];
            for (i = 0; i < attribs.Length; i++)  { attribs[i] = new QueryAttribute(); }

            attribs[0].Id = XONLINE_QUERY_ATTR_INT1;
            attribs[0].Value = (long)1234;            
            attribs[1].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[1].Value = (long)1;            
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[2].Value = "Query WebService TestQueryAdd";
            attribs[3].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[3].Value = "Query WebService TestQueryAdd2";            
            attribs[4].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[4].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };
            
            specs = new QueryAttributeSpec[7];
            for (i = 0; i < specs.Length; i++)    { specs[i] = new QueryAttributeSpec(); }

            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[0].len = 8;            
            specs[1].type = XONLINE_QUERY_ATTR_INT1;
            specs[1].len = 8;            
            specs[2].type = XONLINE_QUERY_ATTR_INT2;    
            specs[2].len = 8;            
            specs[3].type = XONLINE_QUERY_ATTR_STRING1;    
            specs[3].len = 400;
            specs[4].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[4].len = 400;            
            specs[5].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[5].len = 400;            
            specs[6].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[6].len = 400;            

            hr = QueryUtil.SendSearchRequest(c_titleId, 0xbaad, 1, 0, 20, attribs, specs, out totalResults, out attribResults);

            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_DATASET_NOT_FOUND);


            //
            // search with wrong query id
            //
            
            Console.WriteLine("Calling search with invalid dataset id");
            Console.WriteLine();

            attribs = new QueryAttribute[5];
            for (i = 0; i < attribs.Length; i++)  { attribs[i] = new QueryAttribute(); }

            attribs[0].Id = XONLINE_QUERY_ATTR_INT1;
            attribs[0].Value = (long)1234;            
            attribs[1].Id = XONLINE_QUERY_ATTR_INT2;    
            attribs[1].Value = (long)1;            
            attribs[2].Id = XONLINE_QUERY_ATTR_STRING1;    
            attribs[2].Value = "Query WebService TestQueryAdd";
            attribs[3].Id = XONLINE_QUERY_ATTR_STRING2;    
            attribs[3].Value = "Query WebService TestQueryAdd2";            
            attribs[4].Id = XONLINE_QUERY_ATTR_BLOB1;    
            attribs[4].Value = new byte[] { 0x1, 0x2, 0x3, 0x4, 0x3, 0x2, 0x1 };
            
            specs = new QueryAttributeSpec[7];
            for (i = 0; i < specs.Length; i++)    { specs[i] = new QueryAttributeSpec(); }

            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[0].len = 8;            
            specs[1].type = XONLINE_QUERY_ATTR_INT1;
            specs[1].len = 8;            
            specs[2].type = XONLINE_QUERY_ATTR_INT2;    
            specs[2].len = 8;            
            specs[3].type = XONLINE_QUERY_ATTR_STRING1;    
            specs[3].len = 400;
            specs[4].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[4].len = 400;            
            specs[5].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[5].len = 400;            
            specs[6].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[6].len = 400;            

            hr = QueryUtil.SendSearchRequest(c_titleId, c_dsTest, 0xbaad, 0, 20, attribs, specs, out totalResults, out attribResults);

            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_PROCEDURE_NOT_FOUND);

            
            //
            // find with too few specs
            //
            
            Console.WriteLine("Calling FindFromIds with too few specs");
            Console.WriteLine();

            entityIds = new ulong[1];
            entityIds[0] = Add(userId);
          
            specs = new QueryAttributeSpec[5];
            for (i = 0; i < specs.Length; i++)    { specs[i] = new QueryAttributeSpec(); }

            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[0].len = 8;            
            specs[1].type = XONLINE_QUERY_ATTR_INT1;
            specs[1].len = 8;            
            specs[2].type = XONLINE_QUERY_ATTR_INT2;    
            specs[2].len = 8;            
            specs[3].type = XONLINE_QUERY_ATTR_STRING1;    
            specs[3].len = 400;
            specs[4].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[4].len = 400;            

            hr = QueryUtil.SendFindFromIdsRequest(c_titleId, c_dsTest, 1, specs, entityIds, out totalResults, out attribResults);
            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_SPEC_COUNT_MISMATCH);

            
            
            //
            // find with too many specs
            //
            
            Console.WriteLine("Calling FindFromIds with too many specs");
            Console.WriteLine();

          
            specs = new QueryAttributeSpec[7];
            for (i = 0; i < specs.Length; i++)    { specs[i] = new QueryAttributeSpec(); }

            specs[0].type = XONLINE_QUERY_ENTITY_ID;
            specs[0].len = 8;            
            specs[1].type = XONLINE_QUERY_ATTR_INT1;
            specs[1].len = 8;            
            specs[2].type = XONLINE_QUERY_ATTR_INT2;    
            specs[2].len = 8;            
            specs[3].type = XONLINE_QUERY_ATTR_STRING1;    
            specs[3].len = 400;
            specs[4].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[4].len = 400;            
            specs[5].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[5].len = 400;            
            specs[6].type = XONLINE_QUERY_ATTR_STRING2;  
            specs[6].len = 400;            

            hr = QueryUtil.SendFindFromIdsRequest(c_titleId, c_dsTest, 1, specs, entityIds, out totalResults, out attribResults);
            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_SPEC_COUNT_MISMATCH);


            Console.WriteLine("Calling FindFromIds with too many ids");
            Console.WriteLine();

            entityIds = new ulong[11];
            for (i = 0; i < entityIds.Length; i++)
            {
                entityIds[i] = (ulong)i;
            }    
          
            hr = QueryUtil.SendFindFromIdsRequest(c_titleId, c_dsTest, 1, specs, entityIds, out totalResults, out attribResults);
            Assert.AreEqual(hr, HResult.E_INVALIDARG);
            
            Console.WriteLine("Calling Add with duplicate entries");
            AddUniqueIndexDataset addUnique = new AddUniqueIndexDataset();
            addUnique.SomeNumber = new Random().Next();
            addUnique.SomeOtherNumber = new Random().Next();
            
            hr = addUnique.Execute(c_titleId, userId, 0, 3, out entityId);
            Assert.AreEqual(hr, HResult.S_OK);
            
            hr = addUnique.Execute(c_titleId, userId, 0, 3, out entityId);
            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_DUPLICATE_ENTRY);
        }

        [TestCase]
        public void TestQuerySelect()
        {
            // just make sure a bad select call returns E_INVALID_ACTION
            uint hr = QueryUtil.SendSelectRequest(c_titleId, 0, 0, c_dsTest, 0, 0xbad, null, -1);
            Assert.AreEqual(hr, HResult.XONLINE_E_QUERY_INVALID_ACTION);
        }

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\query\test\plugins\plugintest.cs ===
// 
// Base.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Query Plugin base classes
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.server.querylib;


[assembly: XomAreaDefinition(XomAreaName.plugintest)]

namespace xonline.server.query.test.plugins 
{
    public class PluginTest : IQueryAdd, IQuerySelect
    {
    
        public const uint PLUGINTEST_ATTR_PAUSE_SECS              = 0x00000001;
        public const uint PLUGINTEST_ATTR_NONCE                   = 0x00000002;
        public const uint PLUGINTEST_ATTR_START                   = 0x00000003;
        public const uint PLUGINTEST_ATTR_END                     = 0x00000004;

        public const uint PLUGINTEST_ACTION_TIMING_TEST           = 0x00000001;        
    
        
        
        public HResult BeforeAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, Hashtable ctx)
        {
            Trace.WriteLine("********* PluginTest.BeforeAdd Executed!!   attribs[0].value=" + attribs[0].lValue);
            ctx.Add("attribs0", attribs[0].lValue);
            return 0;
        }
        
        public HResult AfterAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, ulong entityId, Hashtable ctx)
        {
            Trace.WriteLine("********* PluginTest.AfterAdd Executed!!  ctx['attribs0']=" + (long)ctx["attribs0"]);
            return 0;
        }
        
        public HResult Select(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint actionId, QueryAttribute[] attribs, Hashtable ctx)
        {
            if (actionId == 0)
                return 0;
                
            return HResult.XONLINE_E_QUERY_INVALID_ACTION;
        }    
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\querylib\queryutil.cs ===
// 
// QueryUtil.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Query Plugin base classes
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Text;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.plugins;
using xonline.common.service;
using xonline.common.sql.sqlclient;
using xonline.common.mgmt;


namespace xonline.server.querylib 
{
    public class QueryUtil
    {
        //
        // Static method to init logging within our assembly
        //
        public static void InitLogging()
        {
            PluginUtil.InitLogging();
        }

    
        //
        // Small helper to find a value of an attribute in an a array of attributes.
        //
        public static long GetAttributeValueInt64(QueryAttribute[] attribs, uint id)
        {
            for (int i = 0; i < attribs.Length; i++)
            {
                if (attribs[i].Id == id)
                    return attribs[i].lValue;
            }
            
            // not found   
            return 0;
        }            

        public static string GetAttributeValueString(QueryAttribute[] attribs, uint id)
        {
            for (int i = 0; i < attribs.Length; i++)
            {
                if (attribs[i].Id == id)
                    return attribs[i].strValue;
            }
            
            // not found   
            return null;
        }          
        
        public static byte[] GetAttributeValueBytes(QueryAttribute[] attribs, uint id)
        {
            for (int i = 0; i < attribs.Length; i++)
            {
                if (attribs[i].Id == id)
                    return attribs[i].binValue;
            }
            
            // not found   
            return null;
        }            




        
        public static string DumpAttribs(QueryAttribute[] attribs)
        {
            StringBuilder b = new StringBuilder();
            
            b.Append("QueryAttributes:\r\n");
            b.Append("----------------\r\n");
            
            foreach (QueryAttribute attrib in attribs)
            {
                b.Append("0x" + attrib.Id.ToString("x") + " = ");
                switch(attrib.Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                {
                case XOn.X_ATTRIBUTE_DATATYPE_INTEGER:
                    b.Append(attrib.lValue);
                    break;
                    
                case XOn.X_ATTRIBUTE_DATATYPE_STRING:
                    b.Append(attrib.strValue);
                    break;
                    
                case XOn.X_ATTRIBUTE_DATATYPE_BLOB:
                    b.Append(ByteConvert.ToString(attrib.binValue));
                    break;
                }    
                
                b.Append("\r\n");
            }
            
            return b.ToString();
        }
        

        //
        // Private data
        //
        private static long _timeWarp = 0;


        //
        // Public accessors
        //        
        public static DateTime UtcNow
        {
            get 
            {
                return DateTime.UtcNow.AddSeconds(_timeWarp);
            }
        }
        
        public static long TimeWarpAdjustment
        {
            get { return _timeWarp; }
            set { _timeWarp = value; }
        }
    }        
                    

    public class QueryHealth
    {
        //
        // Private data
        //
        const int  c_checkInterval = 5 * 60;    // 5 minutes between checks
        

        private static DateTime _start = DateTime.MinValue;
        private static DateTime _end = DateTime.MinValue;

        private static ArrayList _startTimes = new ArrayList();
        private static ArrayList _endTimes = new ArrayList();

        
        public static bool ServiceDown
        {
            get 
            { 
                return WasServiceDown(DateTime.UtcNow, DateTime.UtcNow);
            }
        }

        public static bool WasServiceDown(DateTime start, DateTime end)
        {
            bool wasDown = false;
            
            RefreshDowntime(start, end);
            
            for (int i = 0; i < _startTimes.Count; i++)
            {
                DateTime outageStart = (DateTime)_startTimes[i];
                DateTime outageEnd = (DateTime)_endTimes[i];
                
                
                if (start <= outageStart && end <= outageStart)
                    continue;
                    
                if (start >= outageEnd && end >= outageEnd)
                {
                    // looking at past outages now, no need to continue
                    wasDown = false;
                    break;
                }
                    
                    
                // found an outage period!
                Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "Service was down between " + outageStart + " and " + outageEnd);            
                Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "Range of " + start + " to " + end + " includes downtime.");            
                wasDown = true;
                break;                
            }
            
            return wasDown;
        }
        
        public static void RefreshDowntime(DateTime start, DateTime end)
        {
            SqlClient cmd = null;
            SqlDataReader results = null;
            
            ArrayList startTimes;
            ArrayList endTimes;
            
            
            // Quick out without locks
            if (_start <= start && _end >= end)
            {
                return;
            }

            // Do the real check
            lock(typeof(QueryHealth))
            {
                if (_start <= start && _end >= end)
                {
                    return;
                }
                                 
                startTimes = new ArrayList();
                endTimes = new ArrayList();
                                 
                // make sure we use a reasonable range
                if (DateTime.UtcNow.AddDays(-1) > start)
                {
                    start = DateTime.UtcNow.AddDays(-1);
                }
                
                if (DateTime.UtcNow.AddSeconds(c_checkInterval) < end)
                {
                    end = DateTime.UtcNow.AddDays(c_checkInterval);
                }    
                
                try
                {
                    cmd = new SqlClient(Interface.npdb);
                    
                    cmd.StoredProc = "p_svc_get_downtime";
                    
                    cmd.AddParameter("@dt_start", start);
                    cmd.AddParameter("@dt_end", end);
                    
                    results = cmd.Execute();
                
                    while (results.Read())
                    {
                        startTimes.Add(results.GetDateTime(0));
                        endTimes.Add(results.GetDateTime(1));
                    }
                    
                    _startTimes = startTimes;
                    _endTimes = endTimes;
                    
                    _start = start;
                    _end = end;
                }    
                catch (Exception e)
                {
                    // Problem occurred! Log an event. 
                    Xom.NtEvent(XEvent.Id.QUERY_SERVER_HEALTH_ERROR, e, "Error contacting NPDB to detect service downtime. Service is marked DOWN."); 
                    
                    // all checks should return was/is DOWN                    
                    startTimes = new ArrayList();
                    endTimes = new ArrayList();
                    startTimes.Add(DateTime.MinValue);
                    endTimes.Add(DateTime.MaxValue);
                    
                    _startTimes = startTimes;
                    _endTimes = endTimes;
                   
                    // check again, next time someone asks.
                    _start = DateTime.MinValue;
                    _end = DateTime.MinValue;
                    
                }
                finally
                {
                    if (cmd != null)    
                        cmd.Close();
                }
            }
        }    
           
           
           
        // control stuff
        // 
        static QueryHealth()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(QueryHealth.OnControlRequest);
        }
        
        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                switch (args.Command)
                {
                // note: no help, as this simply uses the same command provided by feapp. 
                // we can't use the feapp flushcache event, because feapp may not be compliled into
                // this assembly!
                
                case "cacheflush":
                    OnFlushCache(args);
                    args.Handled = true;
                    break;
                }
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

        
        public static void OnFlushCache(EventArgs e)
        {
            Xom.Trace(XomAreaName.xqry, LogLevel.L_LOW, "Flushing service downtime cache..");
            
            lock(typeof(QueryHealth))
            {
                _start = DateTime.MinValue;
                _end = DateTime.MinValue;
            }
            
            Xom.Trace(XomAreaName.xqry, LogLevel.L_LOW, "Done, it'll be reloaded on the next relevant request.");
            
    
        }            

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\fd\PerfCounters.cs ===
/*
 * PerfCounters.cs
 *
 * Ratings Performance Counter objects
 *
 * Copyright (c) Microsoft Corporation. All Rights Reserved.
 */


using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.ratings.fd
{
    /// <summary>
    /// External service communication counters. The actual API counters are provided by FEAPP
    /// </summary>
    [XomPerformanceCounterCategoryAttr( "Rating FD: Service communication", "Xbox Live: Ratings Server (Catalog,UODB and MSN Service counters)" )]
    public class SvcCommunicationCounters : XomPerformanceCounterCategory
    {
        static public SvcCommunicationCounters Counters = new SvcCommunicationCounters();

        [XomPerformanceCounterAttr(
            "Catalog requests/sec",
            "Catalog requests per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CatalogRequestsPerSecond;

        [XomPerformanceCounterAttr(
          "Catalog requests total",
         "Total Catalog requests recorded in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CatalogRequestsTotal;


     
    }

    //TODO : Add client specific performance counters.
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\fd\Health.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;

using xonline.common.config;
using xonline.common.health;

using xonline.common.msnrr;
using xonline.common.venturarr;


namespace xonline.server.ratings.submitratings.fd
{    
    public class RatingsHealthBlock : IHealthBlock
    {
        public const string MSNRR_HEALTH_ITEMID = "HEALTH CHECK";
    
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Local; }
        }
        /// <summary>
        /// DoCheck implementation for Healthblock
        /// </summary>
        /// <param name="blockManager"></param>
        /// <param name="blockParams"></param>
        /// <param name="report"></param>
        public void DoCheck( HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report )
        {

            if(report != null)
            {
                MsnRRHealthCheckReport extendedReport = new MsnRRHealthCheckReport();
                report.ExtendedReport = extendedReport;

                extendedReport.MsnRRTestContentType = new Guid(Config.GetSetting("msnrr_testContentType"));
                extendedReport.VenturaRRTestUserPuidAsXuid = extendedReport.MsnRRTestUserPuid = Config.GetULongSetting("msnrr_testUserPuid");
                extendedReport.msnrr_ignorefdrequests = Config.GetBoolSetting("msnrr_ignorefdrequests");
                extendedReport.ratings_use_msnrr = Config.GetBoolSetting(Setting.ratings_use_msnrr);
                extendedReport.ratings_use_ventura = Config.GetBoolSetting(Setting.ratings_use_ventura);

                string itemId = MSNRR_HEALTH_ITEMID;
                // we are going to try and save a rating to MSN
                extendedReport.HealthCheckItemIdSavedToVentura = extendedReport.HealthCheckItemIdSavedToMsn = itemId;

                if (extendedReport.ratings_use_msnrr)
                {
                    //call the MSNrr wrapper
                    MsnRRClient.SaveRating(extendedReport.MsnRRTestContentType,
                        extendedReport.HealthCheckItemIdSavedToMsn,
                        extendedReport.MsnRRTestUserPuid,
                        2);
                }
                
                if (extendedReport.ratings_use_ventura)
                {
                    VenturaRRClient.SaveRating(extendedReport.HealthCheckItemIdSavedToVentura, 
                        extendedReport.VenturaRRTestUserPuidAsXuid, 
                        2);
                }
                
                // everything went well? Sweet! But did we cheat?
                if(extendedReport.msnrr_ignorefdrequests) 
                {
                    report.HealthStatus = HealthStatusEnum.Yellow;
                }
                else 
                {
                    report.HealthStatus = HealthStatusEnum.Green;
                }
            }

        
            
        }
    }

        // Custom Healthcheck report for the LiveInfoHealthCHeck block
    public class MsnRRHealthCheckReport : IExtendedHealthReport
    {
        public Guid MsnRRTestContentType;
        public ulong MsnRRTestUserPuid;
        
        public string HealthCheckItemIdSavedToMsn;

        public ulong VenturaRRTestUserPuidAsXuid;
                
        public string HealthCheckItemIdSavedToVentura;
        
        public bool msnrr_ignorefdrequests;
        public bool ratings_use_msnrr;
        public bool ratings_use_ventura;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\Emulator\MSNRR.NickNameListener.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.NickNameListener {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="RRListenerSoap", Namespace="http://www.msn.com/WebServices/SubscriberService/")]
    public partial class RRListener : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback OnNotificationReceiveOperationCompleted;
        
        /// <remarks/>
        public RRListener() {
            this.Url = "http://rr.msn-int.com/rrwebservice/rrnnlistener.asmx";
        }
        
        /// <remarks/>
        public event OnNotificationReceiveCompletedEventHandler OnNotificationReceiveCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/WebServices/SubscriberService/OnNotificationReceive", RequestNamespace="http://www.msn.com/WebServices/SubscriberService/", ResponseNamespace="http://www.msn.com/WebServices/SubscriberService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int OnNotificationReceive(System.Guid publisherID, int eventTypeID, string resourceID, string extendedAttributes, System.DateTime eventDateTime) {
            object[] results = this.Invoke("OnNotificationReceive", new object[] {
                        publisherID,
                        eventTypeID,
                        resourceID,
                        extendedAttributes,
                        eventDateTime});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginOnNotificationReceive(System.Guid publisherID, int eventTypeID, string resourceID, string extendedAttributes, System.DateTime eventDateTime, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("OnNotificationReceive", new object[] {
                        publisherID,
                        eventTypeID,
                        resourceID,
                        extendedAttributes,
                        eventDateTime}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndOnNotificationReceive(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void OnNotificationReceiveAsync(System.Guid publisherID, int eventTypeID, string resourceID, string extendedAttributes, System.DateTime eventDateTime) {
            this.OnNotificationReceiveAsync(publisherID, eventTypeID, resourceID, extendedAttributes, eventDateTime, null);
        }
        
        /// <remarks/>
        public void OnNotificationReceiveAsync(System.Guid publisherID, int eventTypeID, string resourceID, string extendedAttributes, System.DateTime eventDateTime, object userState) {
            if ((this.OnNotificationReceiveOperationCompleted == null)) {
                this.OnNotificationReceiveOperationCompleted = new System.Threading.SendOrPostCallback(this.OnOnNotificationReceiveOperationCompleted);
            }
            this.InvokeAsync("OnNotificationReceive", new object[] {
                        publisherID,
                        eventTypeID,
                        resourceID,
                        extendedAttributes,
                        eventDateTime}, this.OnNotificationReceiveOperationCompleted, userState);
        }
        
        private void OnOnNotificationReceiveOperationCompleted(object arg) {
            if ((this.OnNotificationReceiveCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.OnNotificationReceiveCompleted(this, new OnNotificationReceiveCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void OnNotificationReceiveCompletedEventHandler(object sender, OnNotificationReceiveCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class OnNotificationReceiveCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal OnNotificationReceiveCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\fd\RateMediaApps.cs ===
using System;
using System.Globalization;
using System.Xml;
using System.Text;
using System.IO;
using System.Diagnostics;
using System.Net;
using System.ServiceProcess;
using System.Web;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.utilities;
using xonline.common.health;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.user;
using xonline.common.rating;
using xonline.common.installer;
using xonline.common.msnrr;
using xonline.common.venturarr;
using xonline.server.ratings.fd;

[assembly: XomIisInstallerAttribute( Interface.ratings )]
[assembly: XomIisInstallerAttribute( Interface.ratings_int )]
[assembly: ConfigAttribute(Component.ratings)]
[assembly: XomAreaDefinition(XomAreaName.log)]
[assembly: XomAreaDefinition(XomAreaName.ratingstrace)]
[assembly: XomAreaDefinition(XomAreaName.Reporting)]

namespace xonline.server.ratings.submitratings.fd
{    
    /// <summary>
    /// Front end app implementation for RatingsApp
    /// </summary>
    public class RatingsApp:FrontEndApp
    {
        protected override void OnApplicationStart()
        {
            EventBuilder.ShowSGInfo = false;
            // Custom start code
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler( OnControlRequest2 );
            //Initialize the static data in Media class
            Ratings.StaticInit();
        }

        /// <summary>
        /// Event handler for the Xmgmt control request event
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        public void OnControlRequest2( object sender, ControlRequestEventArgs args )
        {
           //TODO add xmgmt control command parsing logic and code
           //Is there any thing to reload, cancel? 
        }
        /// <summary>
        /// Default constructor calling the base
        /// </summary>
    
        public RatingsApp():base()
        {
        }
        /// <summary>
        /// On application begin request overridden implementation
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="eventArgs"></param>
        public override void Application_BeginRequest(object sender, EventArgs eventArgs)
        {
            base.Application_BeginRequest(sender, eventArgs);
            
            HandleAlternateUrlBehaviourInjection();
         }
        /// <summary>
        /// This method handles the alternate url behaviour injection
        /// </summary>
        private void HandleAlternateUrlBehaviourInjection()
        {
             UrlRedirect alternateUrl = null;

            //reset and set the single session alternateurl
            MsnRRServiceWrapper.ResetSingleRatingSessionAlternateUrl();
            if (RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjection("AlternateSingleRatingSessionUrl", out alternateUrl))
            {
                if(!Ratings.IsUrlOverrideAllowed)
                {
                    throw new ExceptionWithEventId(XEvent.Id.XONLINE_E_RATINGS_HACK_1,
                        "Request contains 'AlternateSingleRatingSessionUrl' header even though msnrr_allowUrlOverride is set false");
                }
                MsnRRServiceWrapper.SetSingleRatingSessionAlternateUrl(alternateUrl.Url);
            }
        }
    }
    /// <summary>
    /// Ratings class
    /// </summary>
    public class Ratings
    {
        /// <summary>
        /// Static instance of Ratings class.
        /// </summary>
        private static Ratings _util = new Ratings();
        public static Ratings Util { get { return _util; } }
        /// <summary>
        /// Private static variable to hold the rateable mediatypes
        /// </summary>
        private static Dictionary<Int32,Int32> rateableMediaTypeCollection = null;
        /// <summary>
        /// private static variable to hold the content Types
        /// </summary>
        private static Dictionary<Int32,Guid> contentTypeMapping=null;
        /// <summary>
        /// Readonly object for synchronization of contentType Dicitonary
        /// </summary>
        private static readonly object lockcontentTypesyncRoot=new object();
        /// <summary>
        /// Readonly object for synchronization of ratings MediaType Dicitonary
        /// </summary>
        private static readonly object lockratingMediaTypesyncRoot=new object();
        /// <summary>
        /// private static variable for urloverride setting.defaults to false
        /// </summary>
        private static bool isUrlOverrideAllowed=false;
        /// <summary>
        ///  kill switch
        /// </summary>
        private static bool fdIsTurnedOff;

        public static void StaticInit()
        {        
            //Subscribe to multi setting change event handler for notifications from Config classes
            Config.MultiSettingChange += new MultiSettingChangeEventHandler(OnMultiSettingsChanged);
            Config.SettingChange+=new SettingChangeEventHandler(Config_SettingChange);
            StaticInit(null, null);
        }

        public static void StaticInit(string[] testOverrideMediaTypes, string testOverrideContentTypeMapping)
        {
            string[] rateableMediaTypes = testOverrideMediaTypes;
            string contentType = testOverrideContentTypeMapping;

            if(rateableMediaTypes == null || rateableMediaTypes.Length == 0)
            {
                rateableMediaTypes = Config.GetMultiSetting("ratings_mediatypes");
            }
            if(string.IsNullOrEmpty(contentType))
            {
                contentType = Config.GetSetting("ratings_contenttype_mapping");
            }
            
            if(rateableMediaTypeCollection==null)
            {
                rateableMediaTypeCollection = new Dictionary<Int32, Int32>();
            }
            if(contentTypeMapping==null)
            {
                contentTypeMapping=new Dictionary<int,Guid>(); 
            }

            fdIsTurnedOff = Config.GetBoolSetting("msnrr_ignorefdrequests");
            isUrlOverrideAllowed=Config.GetBoolSetting(Setting.msnrr_allowUrlOverride);
            
            LoadRateableMediaTypes(rateableMediaTypes);
            LoadContentTypeMapping(contentType);
        }
        
        /// <summary>
        /// Event handler for config setting change
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private static void  Config_SettingChange(object sender, SettingChangeEventArgs e)
        {
            switch (e.Setting)
            {
                case Setting.ratings_contenttype_mapping:
                    LoadContentTypeMapping(e.ValueNew);
                    Xom.NtEvent(XEvent.Id.RATINGS_CONFIG_MULTISETTINGS_LOAD,
                        "Successfully reloaded the setting ratings_contenttypemapping");
                    break;
                case Setting.msnrr_ignorefdrequests:
                    if(bool.TryParse(e.ValueNew, out fdIsTurnedOff)) 
                    {
                      Xom.NtEvent(XEvent.Id.RATINGS_CONFIG_MULTISETTINGS_LOAD,
                         "Successfully reloaded the setting msnrr_ignorefdrequests");
                    }
                    break;
                case Setting.msnrr_allowUrlOverride:
                    if(bool.TryParse(e.ValueNew, out isUrlOverrideAllowed)) 
                    {
                        Xom.NtEvent(XEvent.Id.RATINGS_CONFIG_MULTISETTINGS_LOAD,
                            "Successfully reloaded the setting msnrr_allowUrlOverride");
                    }
                    break;
            }
        }
        /// <summary>
        /// Loads the multisetting
        /// </summary>
        private static void LoadRateableMediaTypes(string [] multiSettings)
        {
            try
            {
                lock(lockratingMediaTypesyncRoot)
                {
                    rateableMediaTypeCollection.Clear();
                    foreach (string multiSetting in multiSettings)
                    {
                        int mediaType=Convert.ToInt32(multiSetting);
                        rateableMediaTypeCollection.Add(mediaType, mediaType);
                    }
                }
            }
            catch(Exception ex)
            {
                throw new XRLException(HResult.XONLINE_E_RATINGS_MULTISETTING_ERROR, 
                    XEvent.Id.RATINGS_FD_SUBMITRATING,
                    string.Format("Error converting the ratings values from Config.Exception Text is {0}:",ex.ToString()));
            }
        }
        /// <summary>
        /// Load the contentType XML into a dictionary
        /// </summary>
        /// <param name="contentTypeXml"></param>
        private static void LoadContentTypeMapping(string contentTypeXml)
        {
            try
            {
                lock(contentTypeMapping)
                {
                    contentTypeMapping.Clear();
                    XmlDataDocument xmlDoc = new XmlDataDocument();
                    xmlDoc.LoadXml(contentTypeXml);
                    XmlNodeList xmlNodeList= xmlDoc.SelectNodes("root/contentTypeMapping");
                    foreach (XmlNode var in xmlNodeList)
                    {
                        contentTypeMapping.Add(
                            Convert.ToInt32(var.Attributes["mediatype"].Value), 
                            new Guid(var.Attributes["contentTypeId"].Value));
                    }
                }
            }
            catch(Exception ex)
            {
                throw new XRLException(HResult.XONLINE_E_RATINGS_CONTENTTYPE_SETTING_ERROR, 
                    XEvent.Id.RATINGS_FD_SUBMITRATING,
                    string.Format("Error converting the contentTypeMapping values from Config.Exception Text is {0}:",ex.ToString()));
            }
        }
        /// <summary>
        /// Gets if the overriding of url is allowed
        /// </summary>
        public static bool IsUrlOverrideAllowed
        {
            get
            {
                return isUrlOverrideAllowed;
            }
        }
        /// <summary>
        /// returns the contenttype guid based on mediatype
        /// </summary>
        /// <param name="mediaType"></param>
        /// <returns></returns>
        private Guid GetContentTypeByMediaType(Int32 mediaType)
        {
            Guid contentTypeMap=Guid.Empty;
            lock(contentTypeMapping)
             {
               if(!contentTypeMapping.TryGetValue(mediaType , out contentTypeMap))
                 {
                     throw new XRLException(HResult.XONLINE_E_RATINGS_CONTENTTYPE_MAPPING_ERROR, 
                        XEvent.Id.RATINGS_FD_SUBMITRATING,
                        string.Format("Error retrieving mapping contentType for MediaTypeId {0}",mediaType.ToString()));
                 }
             }
            return contentTypeMap;
        }
        /// <summary>
        /// Checks the MediaType and determines if the Media can be rated
        /// </summary>
        /// <param name="mediaTypeId"></param>
        private bool IsRateable(int mediaTypeId)
        {
            try
            {
                lock(rateableMediaTypeCollection)
                {
                    return rateableMediaTypeCollection.ContainsKey(mediaTypeId);
                }
            }
            catch (Exception ex)
            {
                throw new XRLException(HResult.XONLINE_E_RATINGS_MEDIATYPE_VALIDATION, XEvent.Id.RATINGS_FD_SUBMITRATING,
                       string.Format("Error Validating MediaType .Exception Text:{0}",ex.ToString()));
            }
        }
        /// <summary>
        /// Eventhandler for multsettign change event
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="eventArgs"></param>
        private static void OnMultiSettingsChanged(object sender, MultiSettingChangeEventArgs eventArgs)
        {
            switch (eventArgs.MultiSetting)
            {
                case MultiSetting.ratings_mediatypes:
                    LoadRateableMediaTypes(eventArgs.ValueNew);
                    Xom.NtEvent(XEvent.Id.RATINGS_CONFIG_MULTISETTINGS_LOAD,
                        "Successfully reloaded the multisetting ratings_mediatypes");
                    break;
            }
        }

        /// <summary>
        /// Build a unique MSN RR Key for that object (made up of media id and country code)
        /// </summary>
        /// <param name="mediaId"></param>
        /// <param name="countryId"></param>
        private static string BuildUniqueMsnRRKey(Guid mediaId, String countryCode)
        {            
            // build up the string uniquely representing the rated object
            return string.Format("{0}_{1}", mediaId.ToString("D"), countryCode);
        }

        /// <summary>
        /// Validates parameters passed in - only validates those that can be validated without
        /// querying the catalog.
        /// </summary>
        /// <param name="userXuid"></param>
        /// <param name="mediaId"></param>
        /// <param name="countryId"></param>
        /// <param name="countryCode">Set to the 2 character country code derived from the countryId</param>
        private void BasicValidation( ulong userXuid, Guid mediaId, byte countryId, out String countryCode )
        {
            // make sure we dont allow unauthorized requests
            SGInfo.VerifyServiceId(XOService.Ratings);

            //make sure the user is valid and SG knows the user information
            SGInfo.VerifyUserId(userXuid);

            // make sure the country is valid
            SGInfo.VerifyUserCountryId(userXuid,countryId);
            countryCode = CountryDictionary.CountryCode( countryId );
            if (countryCode == null || countryCode.Length != 2)
            {
                throw new XRLException( HResult.XONLINE_E_RATINGS_INVALID_COUNTRY,
                                        XEvent.Id.RATINGS_INVALID_ARGS,
                                        string.Format("country code is expected to be 2 characters only" ));
            }
        }

        /// <summary>
        /// Validates values apssed in - performs validations that require media information to
        /// have been retrieved from the catalog
        /// </summary>
        /// <param name="userXuid">Users xuid</param>
        /// <param name="mediaId">Catalog media id for the media being rated</param>
        /// <param name="mediaTypeId">The type id of the media being rated</param>
        /// <param name="userPuid">The users puid (passport id)</param>
        private void ExtendedValidation( ulong userXuid,
                                            Guid mediaId,
                                            int mediaTypeId,
                                            out Puid userPuid )
        {
            // get the user info out of xcache
            XCacheUserResponseData xcurd = XCache.LookupUserByXUID(userXuid);
            if(xcurd == null || xcurd.qwPassportPUID == 0)
            {
             throw new XRLException(HResult.XONLINE_E_RATINGS_ERROR_GETUSER, XEvent.Id.RATINGS_FD_SUBMITRATING,
                     string.Format("Error retrieving User Details from XCache using LookupUserByXUID." ));
            }

            if (!IsRateable(mediaTypeId))
            {
                throw new XRLException(HResult.XONLINE_E_RATINGS_INVALID_MEDIATYPE, XEvent.Id.RATINGS_FD_SUBMITRATING,
                     string.Format("Media is not rateable.check the MediaType"));
            }

            // get the user's PUID
            userPuid = xcurd.qwPassportPUID;
        }


        /// <summary>
        /// wraps and rethrows exceptions if needed
        /// </summary>
        /// <param name="ex"></param>
        private void HandleError(Exception ex)
        {
            if(ex is WebException)
            {
                throw new XRLException(HResult.XONLINE_E_RATINGS_MSN_CONNECTION_ERROR, XEvent.Id.RATINGS_MSN_ERROR,
                     string.Format("Error connecting to MSN Ratings API.Actual Exception is : {0}",ex.ToString()));
            }

            throw new XRLException(HResult.XONLINE_E_RATINGS_UNKNOWNERROR, XEvent.Id.RATINGS_UNKNOWN_RATING_ERROR,
                     string.Format("Unknown error in Submit Rating API.Actual Exception is : {0}",ex.ToString()));
        }

        /// <summary>
        /// Retrives the basic media info
        /// </summary>
        /// <returns></returns>
        private Media GetMediaInfo( Media.GetMediaInfoOptions options, Guid mediaId, String countryCode)
        {
           //Load the media object
            Media m =null;
            HResult hr = HResult.S_OK;
            try
            {
                m = new Media();
                m = Media.GetMediaInfo( options, mediaId, countryCode );

                //Increment the Catalog Counters
                SvcCommunicationCounters.Counters.CatalogRequestsPerSecond.Increment();
                SvcCommunicationCounters.Counters.CatalogRequestsTotal.Increment();
            }
            catch(Exception ex)
            {
                if(ex is ExceptionWithHResult)
                {
                    hr=(uint)((ExceptionWithHResult)ex).HResult;
                }
                throw ex;
            }
            finally
            {
                //Log the api call
                 string szLog = string.Join("|", new string[]
                {
                    "GetMediaInfo",
                     hr.ToString(),
                     mediaId.ToString()
                });
                Xom.Log(XomAreaName.log, szLog);
            }
            return m;
        }


        /// <summary>
        /// Get Rating method
        /// </summary>
        /// <param name="userXuid"></param>
        /// <param name="mediaId"></param>
        /// <param name="userCountryId"></param>
        /// <param name="userValue"></param>
        /// <param name="ratingsAverage"></param>
        /// <param name="ratingsCount"></param>
        /// <returns></returns>
        public HResult GetRating(ulong userXuid,Guid mediaId,byte countryId,
            out int userRating, out double ratingsAverage, out int ratingsCount)
        {
            userRating = 0;
            ratingsAverage = 0.0F;
            ratingsCount = 0;
            
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();    
            HResult hr = HResult.S_OK;

            string countryCode = String.Empty;
            Puid userPuid;
            Guid contentTypeId = Guid.Empty;
            String msnRRMediaKey = null;

            if(fdIsTurnedOff)
            {
                return HResult.S_OK;
            }

            try
            {
                // Perform basic validation on the parameters passed in
                BasicValidation( userXuid, mediaId, countryId, out countryCode );

                // Load the basic media Information from Catalog
                Media media = GetMediaInfo( Media.GetMediaInfoOptions.AggregateRatingInfo, mediaId, countryCode);

                // If there was an aggregate rating for this media for this country in the catalog,
                // pull out the rounded average and the nuber of times that it was rated. Otherwise
                // leave the values as their defaults of zero.
                AggregateRating ar = media.AggregateRatingInfo;
                if ( ar != null )
                {
                    ratingsAverage = ar.RoundedAggregate;
                    ratingsCount = ar.NumberOfRatings;
                }

                // Perform extended validation (e.g. is this media type rateable?)
                ExtendedValidation( userXuid,
                                    media.MediaId,
                                    media.MediaTypeId,
                                    out userPuid );

                // Compute the id for this media-country combination, the content type id and then
                // get the users rating from MSN
                msnRRMediaKey = BuildUniqueMsnRRKey(mediaId, countryCode);
                contentTypeId = GetContentTypeByMediaType(media.MediaTypeId);
                
                bool venturaResourceNotFound = true;
                if (Config.GetBoolSetting(Setting.ratings_use_ventura))
                {
                    try
                    {
                        venturaResourceNotFound = false;

                        VenturaRRClient.GetRatingByUser(msnRRMediaKey,
                                                        userXuid,
                                                        userPuid,
                                                        out userRating);
                    }
                    catch (WebException wex)
                    {
                        // if we fail with 404, get the rating from MSN
                        if (wex.Response is HttpWebResponse
                            && ((HttpWebResponse)wex.Response).StatusCode == HttpStatusCode.NotFound)
                        {
                            venturaResourceNotFound = true;
                        }
                        else
                        {
                            throw;
                        }
                    }
                }

                if (Config.GetBoolSetting(Setting.ratings_use_msnrr) && venturaResourceNotFound)
                {
                    MsnRRClient.GetRatingByUser(contentTypeId,
                                msnRRMediaKey,
                                userPuid,
                                out userRating);
                }

                string szTrace = string.Format(
                    "GetRating submitted for userXuid {0}, object {1}, contenttypeid {2}. Got back user's rating {3}, average {4}, count {5}",
                    userXuid.ToString("x"),
                    msnRRMediaKey,
                    contentTypeId.ToString("D"),
                    userRating.ToString(),
                    ratingsAverage.ToString(),
                    ratingsCount.ToString()
                    );                
                Xom.Trace(XomAreaName.ratingstrace, LogLevel.L_NORMAL, szTrace);
            }
            catch(Exception ex)
            {
                if (ex is ExceptionWithHResult)
                {
                    hr = (ex as ExceptionWithHResult).HResult;
                }

                if (ex is ExceptionWithEvent || ex is ExceptionWithoutEvent || ex is ExceptionWithHResult) throw;
                HandleError(ex);
            }
            finally
            {
                 //Log the api call
                 string szLog = string.Join("|", new string[]
                {
                    "GetRating",
                     hr.ToString(),
                     timeElapsed.MillisecondsElapsed.ToString(),
                     userXuid.ToString("x"),
                     mediaId.ToString("D"),
                     countryId.ToString(),
                     userRating.ToString(),
                     ratingsAverage.ToString(),
                     ratingsCount.ToString()
                });
                Xom.Log(XomAreaName.log, szLog);
            }
            return hr;
        }

        
        /// <summary>
        /// Submit Ratings method
        /// </summary>
        /// <param name="userXuid"></param>
        /// <param name="mediaId"></param>
        /// <param name="ratingvalue"></param>
        /// <param name="countryId"></param>
        /// <returns></returns>
        public HResult SubmitRating(ulong userXuid, Guid mediaId, int ratingValue, byte countryId)
        {
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();    
            HResult hr = HResult.S_OK;

            Puid userPuid = 0L;
            String countryCode = null;
            Guid contentTypeId = Guid.Empty;
            String msnRRMediaKey = null;
            Media media = null;

            try
            {
                if(!fdIsTurnedOff)
                {
            
                    BasicValidation( userXuid, mediaId, countryId, out countryCode );

                    // Load the basic media Information from Catalog
                    media = GetMediaInfo( Media.GetMediaInfoOptions.AggregateRatingInfo, mediaId, countryCode);

                    // Perform extended validation (e.g. is this media type rateable?)
                    ExtendedValidation( userXuid,
                                        media.MediaId,
                                        media.MediaTypeId,
                                        out userPuid );

                    // Compute the id for this media-country combination, the content type id and then
                    // get the users rating from MSN
                    msnRRMediaKey = BuildUniqueMsnRRKey(mediaId, countryCode);
                    contentTypeId = GetContentTypeByMediaType(media.MediaTypeId);

                    if (ratingValue <= 0 || ratingValue > 5)
                    {
                        throw new XRLException(HResult.XONLINE_E_RATINGS_INVALID_RATING, XEvent.Id.RATINGS_INVALID_ARGS,
                             string.Format("rating value must be between 1 and 5"));
                    }

                    bool venturaResourceSaved = false;
                    //call the Venturarr wrapper
                    if (Config.GetBoolSetting(Setting.ratings_use_ventura))
                    {
                        VenturaRRClient.SaveRating(msnRRMediaKey,
                                                   userXuid,
                                                   ratingValue);

                        venturaResourceSaved = true;
                    }

                    //call the MSNrr wrapper
                    try
                    {
                        if (Config.GetBoolSetting(Setting.ratings_use_msnrr))
                        {
                            MsnRRClient.SaveRating(contentTypeId,
                                        msnRRMediaKey,
                                        userPuid,
                                        ratingValue);
                        }
                    }
                    catch (Exception)
                    {
                        if ( !venturaResourceSaved ) throw;
                    }

                    string szTrace = string.Format(
                        "MediaRating submitted for userXuid {0}, object {1}, rating {2}, contenttypeid {3}",
                        userXuid.ToString("x"),
                        msnRRMediaKey,
                        ratingValue.ToString(),
                        contentTypeId.ToString("D"));

                    Xom.Trace(XomAreaName.ratingstrace, LogLevel.L_NORMAL, szTrace);
                }
            }
            catch(Exception ex)
            {
                if (ex is ExceptionWithHResult)
                {
                    hr = (ex as ExceptionWithHResult).HResult;
                }

                if (ex is ExceptionWithEvent || ex is ExceptionWithoutEvent || ex is ExceptionWithHResult) throw;

                HandleError(ex);
            }
            finally
            {
                if(!fdIsTurnedOff)
                {
                     //Log the api call
                     string szLog = string.Join("|", new string[]
                    {
                         "SubmitRating",
                         hr.ToString(),
                         timeElapsed.MillisecondsElapsed.ToString(),
                         userXuid.ToString("x"),
                         mediaId.ToString("D"),
                         ratingValue.ToString(),
                         countryId.ToString(), 
                         contentTypeId.ToString("D"),
                         msnRRMediaKey,
                         ((ulong)userPuid).ToString("x")
                    });
                    
                    Xom.Log(XomAreaName.log, szLog);
                }

                // BI Reporting log format                
                // SubmitRating|userXuid|mediaId|countryId|UserRatingValue|TitleId|hr|KillSwitchOff                
                string szBizLog = string.Join("|", new string[]
                {
                    "SubmitRating",
                    userXuid.ToString("x"),
                    mediaId.ToString("D"),
                    countryId.ToString(),
                    ratingValue.ToString(),
                    SGInfo.Current.TitleId.ToString("x"),
                    hr.ToString(),
                    fdIsTurnedOff.ToString()
                });

                Xom.Log(XomAreaName.Reporting, szBizLog);
            }
            return hr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\fd\RateMedia.cs ===
using System;
using System.Globalization;
using System.Xml;
using System.Text;
using System.IO;
using System.Diagnostics;
using System.ServiceProcess;
using System.Web;
using xonline.common.rating;
using xonline.common.audit;
using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.utilities;



namespace xonline.server.ratings.submitratings.fd
{    
    /// <summary>
    ///The class represents HTTPHander to handle the requests to submit the rating
    /// </summary>
    public class SubmitRating:IHttpHandler
    {
        /// <summary>
        /// Process request implementation for Ihttp handler
        /// </summary>
        /// <param name="ctx"></param>
        public void ProcessRequest(HttpContext ctx)
        {
            HResult hr = HResult.S_OK;
            RateMediaRequest request = null;

            CallSource.Check(VirtualInterface.ratings, VirtualInterface.ratings_int);
            
            try
            {
                //Get the Ratemediarequest from request object
                request = new RateMediaRequest();
                request.SchemaVersion = WireData.GetSchemaVersion(ctx.Request);
                request.ValidateSchemaVersion();
                request.ReadFromRequest(ctx.Request);

                //Call the Utils to Submit the rating
                hr = Ratings.Util.SubmitRating(request.userXuid,request.mediaId ,request.ratingValue, request.userCountryId);
                //Set HResult response 
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Ratings, hr);
            }
            catch (Exception ex)
            {
                if (ex is ExceptionWithEventId || ex is ExceptionWithoutEvent || ex is ExceptionWithHResult) throw;

                throw new XRLException(HResult.XONLINE_E_RATINGS_UNKNOWNERROR , XEvent.Id.RATINGS_FD_SUBMITRATING,
                        string.Format("Unknown Error in Submit Ratings.Exception :{0}",ex.ToString()));
            }
        }
        /// <summary>
        /// Default set to true because no state information is stored.
        /// </summary>
        public bool IsReusable
        {
            get
            {
                return true;
            }
        }
    }

    public class GetRating : IHttpHandler
    {
        /// <summary>
        /// Process request implementation for Ihttp handler
        /// </summary>
        /// <param name="ctx"></param>
        public void ProcessRequest(HttpContext ctx)
        {
            HResult hr = HResult.S_OK;
            GetRatingRequest request = null;
            GetRatingResponse response = null;

            CallSource.Check(VirtualInterface.ratings, VirtualInterface.ratings_int);
            
            try
            {
                //Get the Ratemediarequest from request object
                request = new GetRatingRequest();
                request.SchemaVersion = WireData.GetSchemaVersion(ctx.Request);
                request.ValidateSchemaVersion();
                request.ReadFromRequest(ctx.Request);

                //Call the Utils to Submit the rating
                response = new GetRatingResponse();
                hr = Ratings.Util.GetRating(request.userXuid, request.mediaId, request.userCountryId, 
                    out response.userValue, out response.ratingsAverage, out response.ratingsCount);

                //Set HResult response 
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Ratings, hr, response);
            }
            catch (Exception ex)
            {
                if (ex is ExceptionWithEventId || ex is ExceptionWithoutEvent || ex is ExceptionWithHResult) throw;

                throw new XRLException(HResult.XONLINE_E_RATINGS_UNKNOWNERROR , XEvent.Id.RATINGS_FD_GETRATING,
                        string.Format("Unknown Error in Get Ratings.Exception :{0}",ex.ToString()));
            }
        }
        /// <summary>
        /// Default set to true because no state information is stored.
        /// </summary>
        public bool IsReusable
        {
            get
            {
                return true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\Emulator\MSNRREmulator.cs ===
﻿namespace Microsoft.XBox.Live.Server.Emulators.Client.MSNRR
{
    public class MSNRREmulator
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\Emulator\MSNRR.Aggregator.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.Aggregator {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="AggregatorSoap", Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class Aggregator : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback GetRatingAveragesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetDeltaRatingAveragesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUnauthRatingAveragesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetDeltaUnauthRatingAveragesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingAveragesWithReviewCountOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetDeltaRatingAveragesWithReviewCountOperationCompleted;
        
        /// <remarks/>
        public Aggregator() {
            this.Url = "http://rr.msn-int.com/rrwebservice/Aggregator.asmx";
        }
        
        /// <remarks/>
        public event GetRatingAveragesCompletedEventHandler GetRatingAveragesCompleted;
        
        /// <remarks/>
        public event GetDeltaRatingAveragesCompletedEventHandler GetDeltaRatingAveragesCompleted;
        
        /// <remarks/>
        public event GetUnauthRatingAveragesCompletedEventHandler GetUnauthRatingAveragesCompleted;
        
        /// <remarks/>
        public event GetDeltaUnauthRatingAveragesCompletedEventHandler GetDeltaUnauthRatingAveragesCompleted;
        
        /// <remarks/>
        public event GetRatingAveragesWithReviewCountCompletedEventHandler GetRatingAveragesWithReviewCountCompleted;
        
        /// <remarks/>
        public event GetDeltaRatingAveragesWithReviewCountCompletedEventHandler GetDeltaRatingAveragesWithReviewCountCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverages", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAverages(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken) {
            this.GetRatingAveragesAsync(contentTypeID, fromTime, returnRatingAttributes, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, object userState) {
            if ((this.GetRatingAveragesOperationCompleted == null)) {
                this.GetRatingAveragesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAveragesOperationCompleted);
            }
            this.InvokeAsync("GetRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, this.GetRatingAveragesOperationCompleted, userState);
        }
        
        private void OnGetRatingAveragesOperationCompleted(object arg) {
            if ((this.GetRatingAveragesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAveragesCompleted(this, new GetRatingAveragesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetDeltaRatingAverages", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetDeltaRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetDeltaRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetDeltaRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetDeltaRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetDeltaRatingAverages(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetDeltaRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken) {
            this.GetDeltaRatingAveragesAsync(contentTypeID, fromTime, returnRatingAttributes, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetDeltaRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, object userState) {
            if ((this.GetDeltaRatingAveragesOperationCompleted == null)) {
                this.GetDeltaRatingAveragesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetDeltaRatingAveragesOperationCompleted);
            }
            this.InvokeAsync("GetDeltaRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, this.GetDeltaRatingAveragesOperationCompleted, userState);
        }
        
        private void OnGetDeltaRatingAveragesOperationCompleted(object arg) {
            if ((this.GetDeltaRatingAveragesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetDeltaRatingAveragesCompleted(this, new GetDeltaRatingAveragesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetUnauthRatingAverages", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetUnauthRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUnauthRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetUnauthRatingAverages(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetUnauthRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken) {
            this.GetUnauthRatingAveragesAsync(contentTypeID, fromTime, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetUnauthRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken, object userState) {
            if ((this.GetUnauthRatingAveragesOperationCompleted == null)) {
                this.GetUnauthRatingAveragesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUnauthRatingAveragesOperationCompleted);
            }
            this.InvokeAsync("GetUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken}, this.GetUnauthRatingAveragesOperationCompleted, userState);
        }
        
        private void OnGetUnauthRatingAveragesOperationCompleted(object arg) {
            if ((this.GetUnauthRatingAveragesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUnauthRatingAveragesCompleted(this, new GetUnauthRatingAveragesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetDeltaUnauthRatingAverages", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetDeltaUnauthRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetDeltaUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetDeltaUnauthRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetDeltaUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetDeltaUnauthRatingAverages(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetDeltaUnauthRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken) {
            this.GetDeltaUnauthRatingAveragesAsync(contentTypeID, fromTime, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetDeltaUnauthRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken, object userState) {
            if ((this.GetDeltaUnauthRatingAveragesOperationCompleted == null)) {
                this.GetDeltaUnauthRatingAveragesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetDeltaUnauthRatingAveragesOperationCompleted);
            }
            this.InvokeAsync("GetDeltaUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken}, this.GetDeltaUnauthRatingAveragesOperationCompleted, userState);
        }
        
        private void OnGetDeltaUnauthRatingAveragesOperationCompleted(object arg) {
            if ((this.GetDeltaUnauthRatingAveragesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetDeltaUnauthRatingAveragesCompleted(this, new GetDeltaUnauthRatingAveragesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAveragesWithReviewCo" +
            "unt", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAveragesWithReviewCount(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAveragesWithReviewCount(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAveragesWithReviewCount(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetRatingAveragesWithReviewCountAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken) {
            this.GetRatingAveragesWithReviewCountAsync(contentTypeID, fromTime, returnRatingAttributes, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetRatingAveragesWithReviewCountAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, object userState) {
            if ((this.GetRatingAveragesWithReviewCountOperationCompleted == null)) {
                this.GetRatingAveragesWithReviewCountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAveragesWithReviewCountOperationCompleted);
            }
            this.InvokeAsync("GetRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, this.GetRatingAveragesWithReviewCountOperationCompleted, userState);
        }
        
        private void OnGetRatingAveragesWithReviewCountOperationCompleted(object arg) {
            if ((this.GetRatingAveragesWithReviewCountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAveragesWithReviewCountCompleted(this, new GetRatingAveragesWithReviewCountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetDeltaRatingAveragesWithRev" +
            "iewCount", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetDeltaRatingAveragesWithReviewCount(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetDeltaRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetDeltaRatingAveragesWithReviewCount(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetDeltaRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetDeltaRatingAveragesWithReviewCount(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetDeltaRatingAveragesWithReviewCountAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken) {
            this.GetDeltaRatingAveragesWithReviewCountAsync(contentTypeID, fromTime, returnRatingAttributes, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetDeltaRatingAveragesWithReviewCountAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, object userState) {
            if ((this.GetDeltaRatingAveragesWithReviewCountOperationCompleted == null)) {
                this.GetDeltaRatingAveragesWithReviewCountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetDeltaRatingAveragesWithReviewCountOperationCompleted);
            }
            this.InvokeAsync("GetDeltaRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, this.GetDeltaRatingAveragesWithReviewCountOperationCompleted, userState);
        }
        
        private void OnGetDeltaRatingAveragesWithReviewCountOperationCompleted(object arg) {
            if ((this.GetDeltaRatingAveragesWithReviewCountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetDeltaRatingAveragesWithReviewCountCompleted(this, new GetDeltaRatingAveragesWithReviewCountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAveragesCompletedEventHandler(object sender, GetRatingAveragesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAveragesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetRatingAveragesCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetDeltaRatingAveragesCompletedEventHandler(object sender, GetDeltaRatingAveragesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetDeltaRatingAveragesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetDeltaRatingAveragesCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUnauthRatingAveragesCompletedEventHandler(object sender, GetUnauthRatingAveragesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUnauthRatingAveragesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetUnauthRatingAveragesCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetDeltaUnauthRatingAveragesCompletedEventHandler(object sender, GetDeltaUnauthRatingAveragesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetDeltaUnauthRatingAveragesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetDeltaUnauthRatingAveragesCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAveragesWithReviewCountCompletedEventHandler(object sender, GetRatingAveragesWithReviewCountCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAveragesWithReviewCountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetRatingAveragesWithReviewCountCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetDeltaRatingAveragesWithReviewCountCompletedEventHandler(object sender, GetDeltaRatingAveragesWithReviewCountCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetDeltaRatingAveragesWithReviewCountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetDeltaRatingAveragesWithReviewCountCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\UserRatingsTest\MSNRatingServiceTest\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\querylib\Dataset.cs ===
using Microsoft.Webstore.WstClient;
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Reflection;
using System.Web;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

using xonline.common.sql.sqlclient;


namespace xonline.server.querylib 
{
    public class Dataset
    {
        public const ulong C_TEAM_PREFIX = 0xFEFE000000000000;
        

        public static bool IsTeamPuid(ulong puid)
        {
            return ((puid & C_TEAM_PREFIX) == C_TEAM_PREFIX);
        }

        
        // ******************************************************
        //
        //  Public methods
        //
        // ******************************************************
        public BundledAuthData bundledAuth;
        
        
        //-----------------------------------------------------
        // SourceFromRequest
        //
        //      Set the request source based on callsourceinfo from SGInfo and the http context. 
        //
        public static Source SourceFromRequest(string viface, HttpContext ctx)
        {
            Source      source = (viface == VirtualInterface.xqry ? Source.Xbox : 0) | (viface == VirtualInterface.xqry_int ? Source.Server : 0);            

            if (viface == VirtualInterface.xqry_int)
            {
                // Check to see if we have a header from the webcache boxes
                string sourceHint = ctx.Request.Headers[XHttpHdr.WEBCACHEREQUEST];

                if(sourceHint != null) 
                {
                    sourceHint = sourceHint.ToUpper();                    
                    if( sourceHint == "TRUE" || sourceHint == "ON" || sourceHint == "YES" || sourceHint == "1" ) 
                    {
                        // This treats web calls the same as xbox client calls. 
                        source = Source.Web;
                    }
                }
            }

            return source;
        }

        
        //-----------------------------------------------------
        // Add
        //
        //      Add a new entry to a dataset.  
        //
        public static HResult Add(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, out ulong entityId)
        {
            return InternalAdd(Source.Plugin | source, titleId, userId, teamId, datasetId, attribs, out entityId);
        }
        
        //-----------------------------------------------------
        // Update
        //
        //      Update a set of existing entries in a dataset.  
        //
        public static HResult Update(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            return InternalUpdate(Source.Plugin | source, titleId, userId, teamId, datasetId, procIndex, attribs);
        }
        
        //-----------------------------------------------------
        // UpdateId
        //
        //      Update an existing entry in a dataset.  
        //
        public static HResult UpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attribs)
        {
            return InternalUpdateId(Source.Plugin | source, titleId, userId, teamId, datasetId, procIndex, entityId, attribs);
        }
        
        //-----------------------------------------------------
        // Remove
        //
        //      Remove one or more entires based on provided
        //      attributes.  
        //
        public static HResult Remove(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            return InternalRemove(Source.Plugin | source, titleId, userId, teamId, datasetId, procIndex, attribs);
        }
        
        //-----------------------------------------------------
        // RemoveId
        //
        //      Remove a specific entry in a dataset.
        //
        public static HResult RemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return InternalRemoveId(Source.Plugin | source, titleId, userId, teamId, datasetId, entityId);
        }    
        
        //-----------------------------------------------------
        // Select
        //
        //      Execute a plugin-defined action on a dataset.  
        //
        public static HResult Select(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint actionId, QueryAttribute[] attribs)
        {
            return InternalSelect(Source.Plugin | source, titleId, userId, teamId, datasetId, entityId, actionId, attribs, null, null);
        }
        
        
        //-----------------------------------------------------
        // Search
        //
        //      Query for a list of entries according to the 
        //      provided attributes
        //
        public static HResult Search(Source source, uint titleId, 
                                  uint datasetId, 
                                  uint procIndex, 
                                  uint page, 
                                  uint resultsPerPage, 
                                  QueryAttribute[] attribs, 
                                  QueryAttributeSpec[] resultSpecs,
                                  out uint totalResults, 
                                  out QueryAttribute[,] results)
        {
            uint returnedResults;
            HResult hr;
            SqlDataReader reader = null;
            SqlClient cmd = null;

            try
            {
                hr = InternalSearch(Source.Plugin | source, titleId, datasetId, procIndex, page, resultsPerPage, attribs, resultSpecs, out totalResults, out returnedResults, out reader, out cmd);
                
                results = null;
                if ((returnedResults > 0) || (reader.HasRows))
                {
                    results = Get2DAttributesFromResults(titleId, reader, resultSpecs, returnedResults);

                    returnedResults = (uint)results.GetLength(0);
                }    
            }
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
                
                if (null != reader)
                {
                    reader.Close();
                }
            }
            

            return hr;
        }

        //-----------------------------------------------------
        // FindFromIds
        //
        //      Get one or more specific entities.
        //
        public static HResult FindFromIds(Source source, uint titleId, 
                                       uint datasetId, 
                                       uint procIndex,
                                       ulong[] entityIds, 
                                       QueryAttributeSpec[] resultSpecs,
                                       out QueryAttribute[,] results
                                       )
        {
            HResult hr;
            SqlDataReader reader = null;
            SqlClient cmd = null;

            try
            {
                hr = InternalFindFromIds(Source.Plugin | source, titleId, datasetId, procIndex, entityIds, resultSpecs, out reader, out cmd);
                
                if (HResult.Failed(hr))
                {
                    results = null;
                    return hr;
                }    
                
                results = Get2DAttributesFromResults(titleId, reader, resultSpecs, (uint)entityIds.Length);
            }
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
                
                if (null != reader)
                {
                    reader.Close();
                }
            }
            
            return hr;

        }
        
        //-----------------------------------------------------
        // ExecCustom
        //
        //      Execute a custom stored proc on a dataset.  
        //
        public static HResult ExecCustom(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attribs)
        {
            return InternalExecCustom(Source.Plugin | source, titleId, userId, teamId, datasetId, procIndex, entityId, attribs);
        }
        


        // ******************************************************
        //
        //  Internal methods
        //
        // ******************************************************
        
        
        public static HResult InternalAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, out ulong entityId)
        {
            DatasetInfo dsi;
            int i;
            SqlClient cmd = null;
            HResult hr;
            uint id;
            
            entityId = 0;
            
            
            dsi = DatasetInfo.GetDSInfo(titleId, datasetId);

            
            try
            {
                // call beforeadd on plugins
                //
                hr = dsi.BeforeAdd(source, titleId, userId, teamId, datasetId, attribs);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                // do database work
                //
                cmd = new SqlClient(Interface.querydb, titleId, (uint)dsi.Partition);
                cmd.StoredProc = "p_query_add_" + titleId.ToString("x8") + "_" + datasetId.ToString("x");
                
                cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);
                cmd.AddParameter("@bi_owner_id", teamId == 0 ? userId : teamId);                
                cmd.AddParameter("@i_owner_quota", titleId == userId ? -1 : dsi.OwnerQuota);
                
                
                for (i = 0; i < attribs.Length; i++)
                {
                    id = attribs[i].Id | XOn.X_ATTRIBUTE_DATAFLAG_PARAM;
                    switch(attribs[i].Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].lValue);
                        break;
    
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].strValue);
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].binValue);
                        break;
                    }
                }
                
                cmd.AddParameter(ParameterDirection.Output, "@bi_entity_id", (long)0);
                
                cmd.ExecuteNonQuery();
                
                entityId = (ulong)cmd.GetLongParameter("@bi_entity_id");
                hr = (uint)cmd.GetIntParameter("@ret");            
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                // call afteradd on plugins
                //
                // REVIEW: indeed, this error handling sucks.  Unfortunately much of the plugin work can only be done
                // once an entityId exists.     A better way might be to allocate the entityId before calling
                // beforeAdd. 
                //
                hr = dsi.AfterAdd(source, titleId, userId, teamId, datasetId, attribs, entityId);
                if (HResult.Failed(hr))
                {
                    // attempt to remove the just-added entity
                    Xom.Trace(XomAreaName.xqry, LogLevel.L_LOW, "AfterAdd call failed attempting to remove entity! hr = " + hr);
                    
                    try
                    {
                        // Calling RemoveId rather than InternalRemoveId to ensure permissions are set correctly
                        RemoveId(source, titleId, userId, teamId, datasetId, entityId);
                        Xom.Trace(XomAreaName.xqry, LogLevel.L_LOW, "entity removed successfully.");
                    }
                    catch
                    {
                        // make sure it's not removed again
                        entityId = 0;
                        throw;
                    }    
                    
                    goto end;
                }
            }
            catch (Exception e)
            {
                XEvent.Id eventId;
                QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                
                try
                {
                    
                    if (entityId != 0)
                    {
                        Xom.Trace(XomAreaName.xqry, LogLevel.L_LOW, "AfterAdd call threw an exception, attempting to remove entity!");

                        // Calling RemoveId rather than InternalRemoveId to ensure permissions are set correctly
                        RemoveId(source, titleId, userId, teamId, datasetId, entityId);
                        Xom.Trace(XomAreaName.xqry, LogLevel.L_LOW, "entity removed.");
                    }
                    
                }
                catch(Exception e2)
                {
                    throw new XRLException(hr, eventId, "ANOTHER error occrued trying to roll-back from Add error (see inner exception): " + e2.ToString(), e);
                }
                    
                throw new XRLException(hr, eventId, "Add failed, rollback successful.", e);
            }        
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
            }
            
end:
            return hr;
        }
        
        public static HResult InternalUpdate(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            DatasetInfo dsi;
            int i;
            SqlClient cmd = null;
            HResult hr = HResult.S_OK;
            uint id;
            
            try
            {
                dsi = DatasetInfo.GetDSInfo(titleId, datasetId);
                
                hr = dsi.BeforeUpdate(source, titleId, userId, teamId, datasetId, procIndex, attribs);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                cmd = new SqlClient(Interface.querydb, titleId, (uint)dsi.Partition);
                cmd.StoredProc = "p_query_update_" + titleId.ToString("x8") + "_" + datasetId.ToString("x") + "_" + procIndex.ToString("x");
                
                cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);
                cmd.AddParameter("@bi_owner_id", teamId == 0 ? userId : teamId);
                
                for (i = 0; i < attribs.Length; i++)
                {
                    id = attribs[i].Id | XOn.X_ATTRIBUTE_DATAFLAG_PARAM;
                    switch(id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].lValue);
                        break;
    
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].strValue);
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].binValue);
                        break;
                    }
                
                
                }
                
                cmd.ExecuteNonQuery();
                
                hr = (uint)cmd.GetIntParameter("@ret");
                
                
                dsi.AfterUpdate(source, titleId, userId, teamId, datasetId, procIndex, attribs);
            }
            catch (Exception e)
            {
                XEvent.Id eventId;
                QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                
                throw new XRLException(hr, eventId, "Update failed!", e);
            }
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
            }
            
            
end:            
            return hr;
        
        }
        
        public static HResult InternalUpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attribs)
        {
            DatasetInfo dsi;
            int i;
            SqlClient cmd = null;
            HResult hr = HResult.S_OK;
            uint id;
            
            try
            {
                dsi = DatasetInfo.GetDSInfo(titleId, datasetId);
                
                hr = dsi.BeforeUpdateId(source, titleId, userId, teamId, datasetId, procIndex, entityId, attribs);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                cmd = new SqlClient(Interface.querydb, titleId, (uint)dsi.Partition);
                
                
                cmd.StoredProc = "p_query_updateid_" + titleId.ToString("x8") + "_" + datasetId.ToString("x") + "_" + procIndex.ToString("x");
                
                cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);
                cmd.AddParameter("@bi_entity_id", entityId);
                cmd.AddParameter("@bi_owner_id", teamId == 0 ? userId : teamId);
                
                for (i = 0; i < attribs.Length; i++)
                {
                    id = attribs[i].Id | XOn.X_ATTRIBUTE_DATAFLAG_PARAM;
                    switch(id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].lValue);
                        break;
    
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].strValue);
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].binValue);
                        break;
                    }
                
                
                }
                
                cmd.ExecuteNonQuery();
                
                hr = (uint)cmd.GetIntParameter("@ret");
                
                
                dsi.AfterUpdateId(source, titleId, userId, teamId, datasetId, procIndex, entityId, attribs);
            }
            catch (Exception e)
            {
                XEvent.Id eventId;
                QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                
                throw new XRLException(hr, eventId, "UpdateId failed!", e);
            }
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
            }
                
            
end:            
            return hr;
        
        }
        
        public static HResult InternalRemove(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            DatasetInfo dsi;
            int i;
            SqlClient cmd = null;
            HResult hr;
            uint id;
            
            try
            {
                dsi = DatasetInfo.GetDSInfo(titleId, datasetId);
                
                // call BeforeRemove on plugin(s)
                //
                hr = dsi.BeforeRemove(source, titleId, userId, teamId, datasetId, procIndex, attribs);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
    
                            
                // do database work
                //
                cmd = new SqlClient(Interface.querydb, titleId, (uint)dsi.Partition);
                
                
                cmd.StoredProc = "p_query_remove_" + titleId.ToString("x8") + "_" + datasetId.ToString("x") + "_" + procIndex.ToString("x");
                cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);
                cmd.AddParameter("@bi_owner_id", teamId == 0 ? userId : teamId);
               
                for (i = 0; i < attribs.Length; i++)
                {
                    id = attribs[i].Id | XOn.X_ATTRIBUTE_DATAFLAG_PARAM;
                    switch(id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].lValue);
                        break;
    
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].strValue);
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].binValue);
                        break;
                    }
                
                
                }
                
                cmd.ExecuteNonQuery();
                
                hr = (uint)cmd.GetIntParameter("@ret");
                
                // call AfterRemove on plugin(s)
                //
                dsi.AfterRemove(source, titleId, userId, teamId, datasetId, procIndex, attribs);
            }    
            catch (Exception e)
            {
                XEvent.Id eventId;
                QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                
                throw new XRLException(hr, eventId, "Remove failed!", e);
            }
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
            }
            
end:
            return hr;        
        }
        
        public static HResult InternalRemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            DatasetInfo dsi;
            SqlClient cmd = null;
            HResult hr;
            
            try
            {
                dsi = DatasetInfo.GetDSInfo(titleId, datasetId);
                
                hr = dsi.BeforeRemoveId(source, titleId, userId, teamId, datasetId, entityId);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                cmd = new SqlClient(Interface.querydb, titleId, (uint)dsi.Partition);
                
                
                cmd.StoredProc = "p_query_removeId_" + titleId.ToString("x8") + "_" + datasetId.ToString("x");
                cmd.AddParameter("@bi_owner_id", teamId == 0 ? userId : teamId);
                cmd.AddParameter("@bi_entity_id", entityId);
                cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", hr);
                
                cmd.ExecuteNonQuery();
                
                hr = (uint)cmd.GetIntParameter("@ret");
                
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                dsi.AfterRemoveId(source, titleId, userId, teamId, datasetId, entityId);
            }
            catch (Exception e)
            {
                XEvent.Id eventId;
                QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                
                throw new XRLException(hr, eventId, "RemoveId failed!", e);
            }
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
            }
            
end:
            return hr;
        }   
        
        public static HResult InternalSelect(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint actionId, QueryAttribute[] attribs, BundledAuthData bundledAuth, TeamTickets bundledTickets)
        {
            DatasetInfo dsi;
            HResult hr;
            
            dsi = DatasetInfo.GetDSInfo(titleId, datasetId);
            hr = dsi.Select(source, titleId, userId, teamId, datasetId, entityId, actionId, attribs, bundledAuth, bundledTickets);
            
            return hr;
        }
        
        

        
        public static HResult InternalSearch(Source source, uint titleId, 
                                          uint datasetId, 
                                          uint procIndex, 
                                          uint page, 
                                          uint resultsPerPage, 
                                          QueryAttribute[] attribs, 
                                          QueryAttributeSpec[] resultSpecs,
                                          out uint totalResults, 
                                          out uint returnedResults,
                                          out SqlDataReader reader,
                                          out SqlClient cmd
                                          )
        {
            DatasetInfo dsi;
            HResult    hr;
            int i;
            uint id;

            try
            {
                totalResults = 0;
                returnedResults = 0;
                
                reader = null;
                cmd = null;
                
                // run the search
                //
                dsi = DatasetInfo.GetDSInfo(titleId, datasetId);
    
                // call BeforeSearch on plugin(s)
                //
                hr = dsi.BeforeSearch(source, titleId, datasetId, procIndex, attribs);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                cmd = new SqlClient(Interface.querydb, titleId, (uint)dsi.Partition);
                
                
                cmd.StoredProc = "p_query_search_" + titleId.ToString("x8") + "_" + datasetId.ToString("x") + "_" + procIndex.ToString("x");
    
                // REVIEW:  This asks for all rows up to the requested page,
                // would it be more performant to skip in the sp and have it only 
                // return the desired rows?
                // doing so would require first dumping this resultset into a 
                // temp table, then grabbing the correct page from it...
                //
                cmd.AddParameter("@i_max_results", (page+1) * resultsPerPage);
                
                for (i = 0; i < attribs.Length; i++)
                {
                    id = attribs[i].Id | XOn.X_ATTRIBUTE_DATAFLAG_PARAM;
                    switch(id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].lValue);
                        break;
    
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].strValue);
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].binValue);
                        break;
                    
                    case XOn.X_ATTRIBUTE_DATATYPE_NULL: 
                        // skip it, let the param default handle it
                        break;
                    }
                }
                
                reader = cmd.Execute();
                reader.Read();
                
                totalResults = (uint)reader.GetInt32(0);
                returnedResults = (uint)Math.Max(0, Math.Min((int)resultsPerPage, (int)(totalResults - (page * resultsPerPage))));
                
                reader.NextResult();
                
                if (reader.FieldCount != resultSpecs.Length && reader.FieldCount != -1)
                {
                    hr = HResult.XONLINE_E_QUERY_SPEC_COUNT_MISMATCH;
                }
                
                for (i = 0; i < page * resultsPerPage; i++)
                {
                    if (!reader.Read())
                        break;
                }
            }                    
            catch (Exception e)
            {
                XEvent.Id eventId;
                QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                
                throw new XRLException(hr, eventId, "Search failed!", e);
            }
            
end:            
            return hr;            
        }
            
        
        public static HResult InternalFindFromIds(Source source, uint titleId, 
                                               uint datasetId, 
                                               uint procIndex,
                                               ulong[] entityIds, 
                                               QueryAttributeSpec[] resultSpecs,
                                               out SqlDataReader reader,
                                               out SqlClient cmd
                                               )
        {
            DatasetInfo dsi;
            HResult hr;
            int i;

            cmd = null;
            reader = null;

            try
            {
                // run the search
                //
                dsi = DatasetInfo.GetDSInfo(titleId, datasetId);
    
    
                // call BeforeSearch on plugin(s)
                //
                hr = dsi.BeforeFindFromIds(source, titleId, datasetId, procIndex, entityIds);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
    
                cmd = new SqlClient(Interface.querydb, titleId, (uint)dsi.Partition);
                
                
                cmd.StoredProc = "p_query_find_ids_" + titleId.ToString("x8") + "_" + datasetId.ToString("x") + "_" + procIndex.ToString("x");
    
                cmd.AddParameter("@i_num_ids", entityIds.Length);
                
                
                for (i = 0; i < entityIds.Length; i++)
                {
                    cmd.AddParameter("@id" + i, (long)entityIds[i]);
                }
                
                reader = cmd.Execute();
                if (!reader.Read())
                {
                    throw new XRLException(HResult.XONLINE_E_QUERY_ERROR, XEvent.Id.QUERY_BAD_DATA_10, "1st resultset from FindIds has no rows!");
                }
                
                hr = (uint)reader.GetInt32(0);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                    
                reader.NextResult();
                
                if (reader.FieldCount != resultSpecs.Length && reader.FieldCount != -1)
                {
                    Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "FindFromIDs attempted with wrong list of specs!  reader.FieldCount: " + reader.FieldCount + " spec count: " + resultSpecs.Length);
                    hr = HResult.XONLINE_E_QUERY_SPEC_COUNT_MISMATCH;
                }
                
                
            }
            catch (Exception e)
            {
                XEvent.Id eventId;
                QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                
                throw new XRLException(hr, eventId, "FindFromIds failed!", e);
            }
                
end:            
            return hr;            
        }
            
        internal static HResult InternalExecCustom(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attribs)
        {
            DatasetInfo dsi;
            int i;
            SqlClient cmd = null;
            HResult hr;
            uint id;
            
            dsi = DatasetInfo.GetDSInfo(titleId, datasetId);
            

            try
            {
                // call BeforeSearch on plugin(s)
                //
                hr = dsi.BeforeCustom(source, titleId, datasetId, procIndex, attribs);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                
                cmd = new SqlClient(Interface.querydb, titleId, (uint)dsi.Partition);
                
                
                cmd.StoredProc = "p_query_custom_" + titleId.ToString("x8") + "_" + datasetId.ToString("x") + "_" + procIndex.ToString("x");
                
                cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);
                cmd.AddParameter("@bi_owner_id", teamId == 0 ? userId : teamId);
                cmd.AddParameter("@bi_entity_id", entityId);
                
                for (i = 0; i < attribs.Length; i++)
                {
                    id = attribs[i].Id | XOn.X_ATTRIBUTE_DATAFLAG_PARAM;
                    switch(id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].lValue);
                        break;
    
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].strValue);
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].binValue);
                        break;
                    }
                
                
                }
                
                cmd.ExecuteNonQuery();
                
                hr = (uint)cmd.GetIntParameter("@ret");
            }
            catch (Exception e)
            {
                XEvent.Id eventId;
                QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                
                throw new XRLException(hr, eventId, "ExecCustom failed!", e);
            }
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
            }
                
end:            
            return hr;
        }
        

        //
        // Map a user puid or team puid to the corresponding name. 
        //
        public static string MapPUIDToName(uint titleId, ulong puid)
        {
            string  name = "";

            if (0 != puid)
            {
                if (IsTeamPuid(puid))
                {
                    name = XCache.LookupTeamName(titleId, puid);
                }
                else
                {
                    name = XCache.LookupGamerTag(puid);
                }
            }
            return name;
        }

        
        //
        // Take a webstore resultset and return a flattened array of attributes that represents the results
        //
        public static QueryAttribute[] GetAttributesFromResults(uint titleId, SqlDataReader reader, QueryAttributeSpec[] resultSpecs, uint expectedCount)
        {
            QueryAttribute[] results;
            int r, j;
            int index;
            int len;
            byte[] buf;
            bool fNeedMapping = false;
            
            results = new QueryAttribute[expectedCount * resultSpecs.Length];
            
            // copy search results to results array 
            //            
            j = 0;
            r = 0;
            while(reader.Read())
            {
                // Check to ensure our hint is accurate
                if (r >= expectedCount)
                {
                    // There is more data than we expected!
                    // create a new results array with the actual count
                    QueryAttribute[] newResults = new QueryAttribute[(uint)(r + 1) * (resultSpecs.Length)];
                    Array.Copy(results, 0, newResults, 0, r * (resultSpecs.Length));
                    
                    results = newResults;
                    expectedCount = (uint)r + 1;
                }
                
                // read the list of attributes
                //
                for (j = 0; j < resultSpecs.Length; j++)
                {
                    index = r * resultSpecs.Length + j;
                    
                    results[index] = new QueryAttribute();
                    results[index].Id = resultSpecs[j].type;
                    
                    switch(resultSpecs[j].type & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER:
                        if (reader.GetFieldType(j) != typeof(long))
                        {
                            throw new XRLException(HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE, XEvent.Id.QUERY_BAD_DATA_11,
                                "Mismatched attribute types!\r\n" +
                                "column: " + j + "\r\n" + 
                                "spec: 0x" + resultSpecs[j].type.ToString("x8") + "\r\n" + 
                                "actual column name: " + reader.GetName(j) + "\r\n" +
                                "actual type: " + reader.GetFieldType(j).ToString());
                        }                                
                                
                        results[index].lValue = reader.GetInt64(j);
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING:
                        if (0 != (resultSpecs[j].type & XOn.X_ATTRIBUTE_DATAFLAG_MAPPED))
                        {
                            // Mapped PUID or TEAM value. The actual data from SQL is an integer
                            //  value, but we need to convert it to the value that the client expects. 
                            // For now, just read out the int value. We'll convert it later. 
                            results[index].lValue = reader.GetInt64(j);     

                            fNeedMapping = true;
                        }
                        else
                        {
                            if (reader.GetFieldType(j) != typeof(string))
                            {
                                throw new XRLException(HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE, XEvent.Id.QUERY_BAD_DATA_12,
                                    "Mismatched attribute types!\r\n" +
                                    "column: " + j + "\r\n" + 
                                    "spec: 0x" + resultSpecs[j].type.ToString("x8") + "\r\n" + 
                                    "actual column name: " + reader.GetName(j) + "\r\n" +
                                    "actual type: " + reader.GetFieldType(j).ToString());
                            }                                
                                                        
                            results[index].strValue = reader.GetString(j);

                            len = (results[index].strValue).Length;
                            
                            if (len > resultSpecs[j].len)
                            {
                                // should we be logging this as an NT event?
                                // ops can't exactly do anything about it..
                                //
                                Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "string value returned from db is longer than spec-allowed length!! Truncating.. (" + 
                                                len + " vs. " + resultSpecs[j].len + ") " + 
                                                "spec: " + j + "  entityId: 0x" + reader.GetInt64(0).ToString("x8"));
                            
                                results[index].strValue = (results[index].strValue).Substring(0, (int)resultSpecs[j].len);
                            }                        
                        }
                        
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB:
                        if (reader.GetFieldType(j) != typeof(byte[]))
                        {
                            throw new XRLException(HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE, XEvent.Id.QUERY_BAD_DATA_13,
                                "Mismatched attribute types!\r\n" +
                                "column: " + j + "\r\n" + 
                                "spec: 0x" + resultSpecs[j].type.ToString("x8") + "\r\n" + 
                                "actual column name: " + reader.GetName(j) + "\r\n" +
                                "actual type: " + reader.GetFieldType(j).ToString());
                        }                                
                        
                        results[index].binValue = reader.GetSqlBinary(j).Value;
                        len = (int)reader.GetSqlBinary(j).Length;
                        
                        if (len > resultSpecs[j].len)
                        {
                            // should we be logging this as an NT event?
                            // ops can't exactly do anything about it..
                            //
                            Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "blob value returned from db is longer than spec-allowed length!! Truncating.. (" + 
                                            len + " vs. " + resultSpecs[j].len + ") " + 
                                            "spec: " + j + "  entityId: 0x" + reader.GetInt64(0).ToString("x8"));
                        
                            len = (int)resultSpecs[j].len;
                            buf = new byte[len];
                            Array.Copy(results[index].binValue, buf, len);
                            results[index].binValue = buf;
                        }                        
                        break;
                    
                    default:
                        throw new XRLException(HResult.XONLINE_E_QUERY_ERROR, XEvent.Id.QUERY_BAD_DATA_14,
                                    "Unexpected attribute type! id: 0x" + resultSpecs[j].type.ToString("x8"));                  
                    }
                }   
                
                r++;
            }                   

            // Done with the reader. Dispose of it before we do attribute mapping, etc.
            reader.Close();

            // Do any attribute mapping required
            if (fNeedMapping)
            {
                for (int i=0; i<r; i++)
                {
                    for (j=0; j < resultSpecs.Length; j++)
                    {
                        if (0 != (resultSpecs[j].type & XOn.X_ATTRIBUTE_DATAFLAG_MAPPED))
                        {
                            index = i * resultSpecs.Length + j;
                            // data should be an int - convert it to the proper string representation
                            results[index].strValue = MapPUIDToName(titleId, (ulong)results[index].lValue);

                            len = (results[index].strValue).Length;
                            
                            if (len > resultSpecs[j].len)
                            {
                                // should we be logging this as an NT event?
                                // ops can't exactly do anything about it..
                                //
                                Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "string value returned from db is longer than spec-allowed length!! Truncating.. (" + 
                                                len + " vs. " + resultSpecs[j].len + ") " + 
                                                "spec: " + j + "  entityId: 0x" + reader.GetInt64(0).ToString("x8"));
                            
                                results[index].strValue = (results[index].strValue).Substring(0, (int)resultSpecs[j].len);
                            }                        
                        }
                    }
                }
            }
            
            if (r < expectedCount)
            {
                // create a new results array with the actual count
                QueryAttribute[] newResults = new QueryAttribute[r * (resultSpecs.Length)];
                Array.Copy(results, 0, newResults, 0, r * (resultSpecs.Length));
                
                results = newResults;
            }    
            
            return results;
        }

        
        //
        // Same as above, but return a 2 dimensional array
        //
        private static QueryAttribute[,] Get2DAttributesFromResults(uint titleId, SqlDataReader reader, QueryAttributeSpec[] resultSpecs, uint expectedCount)
        {
            QueryAttribute[,] results;
            int r, j;
            int len;
            byte[] buf;
            bool fNeedMapping = false;
            
            results = new QueryAttribute[expectedCount, resultSpecs.Length];
            
            // copy search results to results array 
            //            
            j = 0;
            r = 0;
            while(reader.Read())
            {
                // Check to ensure our hint is accurate
                if (r >= expectedCount)
                {
                    // There is more data than we expected!
                    // create a new results array with the actual count
                    QueryAttribute[,] newResults = new QueryAttribute[(uint)(r + 1),resultSpecs.Length];

                    Array.Copy(results, 0, newResults, 0, r * (resultSpecs.Length));
                    
                    results = newResults;
                    expectedCount = (uint)r + 1;
                }                
            
                // read the list of attributes
                //
                for (j = 0; j < resultSpecs.Length; j++)
                {
                    results[r,j] = new QueryAttribute();
                    results[r,j].Id = resultSpecs[j].type;
                    
                    switch(resultSpecs[j].type & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER:
                        if (reader.GetFieldType(j) != typeof(long))
                        {
                            throw new XRLException(HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE, XEvent.Id.QUERY_BAD_DATA_15,
                                "Mismatched attribute types!\r\n" +
                                "column: " + j + "\r\n" + 
                                "spec: 0x" + resultSpecs[j].type.ToString("x8") + "\r\n" + 
                                "actual column name: " + reader.GetName(j) + "\r\n" +
                                "actual type: " + reader.GetFieldType(j).ToString());
                        }                                
                                
                        results[r,j].lValue = reader.GetInt64(j);
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING:
                        if (0 != (resultSpecs[j].type & XOn.X_ATTRIBUTE_DATAFLAG_MAPPED))
                        {
                            // Mapped PUID or TEAM value. The actual data from SQL is an integer
                            //  value, but we need to convert it to the value that the client expects. 
                            // For now, just read out the int value. We'll convert it later. 
                            results[r,j].lValue = reader.GetInt64(j);
                            
                            fNeedMapping = true;                            
                        }
                        else
                        {
                            if (reader.GetFieldType(j) != typeof(string))
                            {
                                throw new XRLException(HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE, XEvent.Id.QUERY_BAD_DATA_16,
                                    "Mismatched attribute types!\r\n" +
                                    "column: " + j + "\r\n" + 
                                    "spec: 0x" + resultSpecs[j].type.ToString("x8") + "\r\n" + 
                                    "actual column name: " + reader.GetName(j) + "\r\n" +
                                    "actual type: " + reader.GetFieldType(j).ToString());
                            }                                
                                    
                            results[r,j].strValue = reader.GetString(j);
                            len = (results[r,j].strValue).Length;
                            
                            if (len > resultSpecs[j].len)
                            {
                                // should we be logging this as an NT event?
                                // ops can't exactly do anything about it..
                                //
                                Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "string value returned from db is longer than spec-allowed length!! Truncating.. (" + 
                                                len + " vs. " + resultSpecs[j].len + ") " + 
                                                "spec: " + j + "  entityId: 0x" + reader.GetInt64(0).ToString("x8"));
                            
                                results[r,j].strValue = (results[r,j].strValue).Substring(0, (int)resultSpecs[j].len);
                            }                        
                        }
                        
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB:
                        if (reader.GetFieldType(j) != typeof(byte[]))
                        {
                            throw new XRLException(HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE, XEvent.Id.QUERY_BAD_DATA_17,
                                "Mismatched attribute types!\r\n" +
                                "column: " + j + "\r\n" + 
                                "spec: 0x" + resultSpecs[j].type.ToString("x8") + "\r\n" + 
                                "actual column name: " + reader.GetName(j) + "\r\n" +
                                "actual type: " + reader.GetFieldType(j).ToString());
                        }                                
                                
                        results[r,j].binValue = reader.GetSqlBinary(j).Value;
                        len = (int)reader.GetSqlBinary(j).Length;
                        
                        if (len > resultSpecs[j].len)
                        {
                            // should we be logging this as an NT event?
                            // ops can't exactly do anything about it..
                            //
                            Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "blob value returned from db is longer than spec-allowed length!! Truncating.. (" + 
                                            len + " vs. " + resultSpecs[j].len + ") " + 
                                            "spec: " + j + "  entityId: 0x" + reader.GetInt64(0).ToString("x8"));
                        
                            len = (int)resultSpecs[j].len;
                            buf = new byte[len];
                            Array.Copy(results[r,j].binValue, buf, len);
                            results[r,j].binValue = buf;
                        }                        
                        break;
                    
                    default:
                        throw new XRLException(HResult.XONLINE_E_QUERY_ERROR, XEvent.Id.QUERY_BAD_DATA_18,
                                    "Unexpected attribute type! id: 0x" + resultSpecs[j].type.ToString("x8"));                    }
                }   
                
                r++;
            }                   
            
            // Done with the reader. Dispose of it before we do attribute mapping, etc.
            reader.Close();

            // Do any attribute mapping required
            if (fNeedMapping)
            {
                for (int i=0; i<r; i++)
                {
                    for (j=0; j < resultSpecs.Length; j++)
                    {
                        if (0 != (resultSpecs[j].type & XOn.X_ATTRIBUTE_DATAFLAG_MAPPED))
                        {
                            // data should be an int - convert it to the proper string representation
                            results[i, j].strValue = MapPUIDToName(titleId, (ulong)results[i, j].lValue);

                            len = (results[r,j].strValue).Length;
                            
                            if (len > resultSpecs[j].len)
                            {
                                // should we be logging this as an NT event?
                                // ops can't exactly do anything about it..
                                //
                                Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "string value returned from db is longer than spec-allowed length!! Truncating.. (" + 
                                                len + " vs. " + resultSpecs[j].len + ") " + 
                                                "spec: " + j + "  entityId: 0x" + reader.GetInt64(0).ToString("x8"));
                            
                                results[r,j].strValue = (results[r,j].strValue).Substring(0, (int)resultSpecs[j].len);
                            }                        
                        }
                    }
                }
            }
            
            if (r < expectedCount)
            {
                // create a new results array with the actual count
                QueryAttribute[,] newResults = new QueryAttribute[r,resultSpecs.Length];

                Array.Copy(results, 0, newResults, 0, r * (resultSpecs.Length));
                
                results = newResults;
            }    
            
            return results;
        }
        

        public static HResult UpdateQueryTrust(uint titleId, ulong userId, int addCompMatches, int addCompNoShows)
        {
            if ( (TrustToggle.Off) || (IsTeamPuid(userId)) )
            {
                return HResult.S_OK;
            }
            
            WSClient ws = null;
            HResult hr;
            
            // do database work
            //
            using(ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.Partition       = ws.CalcPartition(userId);
    
                ws.StoredProc = "dbo.p_xqry_update_user_trust";
                
                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@user_puid", userId);
                ws.AddParameter("@title_id", titleId);
                ws.AddParameter("@C12_change", (int)addCompMatches);   // Played a non-arbitrated competition match
                ws.AddParameter("@C13_change", (int)addCompNoShows);   // Did not show up for a competition match
                ws.AddParameter("@Hash_Bucket", (short) ws.Partition);
                
                ws.ExecuteNonQuery();
                
                hr = (uint)ws.GetIntParameter("@ret");            
            }            
            return hr;    
        }        
    }

    //
    //  TrustToggle: Wraps the guts of turning on/off SG auth checking by config file.
    // 
    public class TrustToggle
    {
        private static bool m_GotSetting = false;

        // static toggle saying whether to ignore auth data from SG
        // default to TRUE
        //     
        private static bool m_QueryTrustUpdates = true;

        // static constructor to get config settings for XBOS.
        private static void GetTrustToggle()
        {
            string r = Config.GetSetting(Setting.querylib_trustUpdates);            
            if(r != null) 
            {
                r = r.ToUpper();
                if( r == "FALSE" || r == "NO" || r == "OFF" ) 
                {
                  Xom.NtEvent( XEvent.Id.MC_QUERY_TRUST_IS_OFF,
                        "QUERY SERVICE TRUST INTEGRATION HAS BEEN TURNED OFF. This should NEVER happen in production." );

                    m_QueryTrustUpdates = false;
                } 
            }
            m_GotSetting = true;
        }

        public static bool On 
        {
            get 
            { 
                if(m_GotSetting == false) 
                {
                    GetTrustToggle(); 
                }
                return (m_QueryTrustUpdates == true);
            }
        }

        public static bool Off 
        {
            get 
            { 
                if(m_GotSetting == false) 
                {
                    GetTrustToggle(); 
                }
                return (m_QueryTrustUpdates == false);
            }
        }
    
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\UserRatingsTest\DebuggerAssistant\Program.cs ===
﻿using System;
using System.Text;
using System.Diagnostics;

namespace DebuggingAssistant
{
    class Program
    {
        static void Main(string[] args)
        {
            DebuggingAssistant da = new DebuggingAssistant();
            da.Go();
        }
    }

    public class DebuggingAssistant
    {
        public string dllToTest = @"Suites\MSNRatingServiceTest.dll";
        public string envToTest = @"Xblob";
        public string pathToSTFConsoleLive = @"D:\XONLINE_R2\drop\debug\test\stftests\stfconsolelive.exe";

        /// <summary>
        /// {0} == path to the STFConsoleLive.exe tool.
        /// {1} == Environment to test against.
        /// {2} == path to the dll to test, relative to the STFConsoleLive.exe location. (yes, I know, its dumb, but simple)
        /// </summary>
        public string cmdLineArgs;

        public DebuggingAssistant()
        {
            string cmdLineArgs = String.Format("{0} -e:{1} {2}", pathToSTFConsoleLive, envToTest, dllToTest);
        }



        public void Go()
        {
            Console.WriteLine("Attach the debugger now...");
            Console.WriteLine("  1) In Visual Studio, go to Tools --> Attach to Process...");
            Console.WriteLine("  2) Scroll down in the list, select STFConsoleLive.exe and hit enter.\n\n");
            Console.WriteLine("When the debugger is attached, press any key to continue...");
            Console.ReadKey();

            ProcessStartInfo psi = new ProcessStartInfo();
            psi.FileName = pathToSTFConsoleLive;
            psi.Arguments = cmdLineArgs;

            Process p = new Process();
            p.StartInfo = psi;
            p.Start();

            p.WaitForExit();
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\UserRatingsTest\DebuggerAssistant\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DebuggerAssistant")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("DebuggerAssistant")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f7da6204-36c9-4fe3-a358-0ce8e55b7ee2")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\UserRatingsTest\MSNRatingServiceTest\MSNRatingServiceTest.cs ===
﻿/******************************************************************************
*
* Copyright (C) Microsoft Corporation.  All rights reserved.
* 
* File: MSNRatingServiceTest.cs
*
* Description: Validates all the positive, negative and error
* cases for MSNRatingService Wrapper.
*
* Author: mattlec
* 
******************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;

using ServerTestFramework;
using xonline.common.diagnostics;

namespace xonline.server.ratings.test.ratingstest
{
    public enum MediaType
    {
        Xbox360FullGame = 1,
        XboxOriginalGame = 21,
        XboxLiveArcade = 23,
        XNACommunityGame = 37,
        InvalidMediaType = 9999
    }

    namespace MSNRatingServiceTest
    {
        [TestGroup, Owner("jeremyj"), EnvRequirement("Billing,Catalog"), TestTag("P1"), TestCasePriority(1), TestFrequency("daily")]
        public class P1_PositiveTestCases : TestNode
        {
            private static Report _Report = new Report(typeof(P1_PositiveTestCases).Name);

            /// <summary>
            /// Priority 1 (BVT)
            /// Functional Positive Test Case
            /// Verify that a call to the MSN RatingService using all valid parameters correctly succeeds.
            /// </summary>
            [TestCase, Owner("jeremyj"), EnvRequirement("Billing,Catalog"), ServerTestFramework.BVT(), ServerTestFramework.Description("P1 - Verifies that a call to MSNRatingService with valid parameters will succeed as expected.")]
            public void pVerifySuccessfulSubmittedRating()
            {
                _Report.Info("Test BEGIN");

                //
                // Setup Test Params
                // TODO: Update passportPuid and mediaID with real values.
                //
                Single ratingValue = 3;
                Guid passportPuid = new Guid("12345678-1234-1234-1234-123456789012");
                Guid mediaId = new Guid("87654321-4321-4321-4321-210987654321");
                Int32 mediaTypeId = (int)MediaType.XNACommunityGame;
                String countryCode = "US";

                int expectedExitCode = 0;
                int actualExitCode;
                double expectedExecTime = 10.0;
                double actualExecTime;

                //
                // Make the call to MSN R&R and measure how long it takes.
                //
                MSNRatingServiceMock ratingService = new MSNRatingServiceMock();

                _Report.Info("Calling MSNRatingService...");
                DateTime startTime = DateTime.Now;
                actualExitCode = ratingService.SaveMediaRatingFromUserWithFailure(FailureType.Success, passportPuid, mediaTypeId, mediaId, countryCode, ratingValue);
                DateTime finishTime = DateTime.Now;
                actualExecTime = (finishTime - startTime).TotalMilliseconds;
                _Report.Info("Execution time for MSNRatingService call: " + actualExecTime);
                _Report.Info("Completed call to MSNRatingService...");

                //
                // Validate
                //
                _Report.Info("Validating exit code...");
                Assert.AreEqual(expectedExitCode, actualExitCode);

                _Report.Info("Validating execution time...");
                Assert.IsTrue(actualExecTime <= expectedExecTime);
                _Report.Success("Test PASSED");
            }

            /// <summary>
            /// Priority 1 
            /// Functional Positive Test Case
            /// Verify that a call to the MSN RatingService using all valid parameters correctly succeeds.
            /// This tests the Resubmit Rating scenario in which the same user ID rates the same content.
            /// The new rating should be saved.
            /// </summary>
            [TestCase, Owner("jeremyj"), EnvRequirement("Billing,Catalog"), ServerTestFramework.Description("P1 - Verifies that a call to MSNRatingService with valid parameters and a user ID that has already rated the Media ID will succeed as expected.")]
            public void pVerifySuccessfulReSubmittedRating()
            {
                _Report.Info("Test BEGIN");
                //
                // Rate the content the first time.
                // Then rate it again.
                //

                Single ratingValue = 1;
                Guid passportPuid = new Guid("87654321-4321-4321-4321-210987654321");
                Guid mediaId = new Guid("87654321-4321-4321-4321-210987654321");
                Int32 mediaTypeId = (int)MediaType.XNACommunityGame;
                String countryCode = "US";

                int expectedExitCode = 0;
                int actualExitCode;
                double expectedExecTime = 10.0;
                double actualExecTime;

                //
                // Make the call to MSN R&R
                //
                MSNRatingServiceMock ratingService = new MSNRatingServiceMock();

                _Report.Info("Calling MSNRatingService...");
                DateTime startTime = DateTime.Now;
                actualExitCode = ratingService.SaveMediaRatingFromUserWithFailure(FailureType.Success, passportPuid, mediaTypeId, mediaId, countryCode, ratingValue);
                DateTime finishTime = DateTime.Now;
                actualExecTime = (finishTime - startTime).TotalMilliseconds;
                _Report.Info("Execution time for MSNRatingService call: " + actualExecTime);
                _Report.Info("Completed call to MSNRatingService...");

                //
                // Validate
                //
                _Report.Info("Validating first rating submission success...");
                Assert.AreEqual(expectedExitCode, actualExitCode);

                _Report.Info("Validating execution time...");
                Assert.IsTrue(actualExecTime <= expectedExecTime);

                _Report.Info("First rating submitted successfully...");

                //
                // Now re-submit with a different rating...
                //
                ratingValue = 4;

                _Report.Info("Calling MSNRatingService...");
                startTime = DateTime.Now;
                actualExitCode = ratingService.SaveMediaRatingFromUserWithFailure(FailureType.Success, passportPuid, mediaTypeId, mediaId, countryCode, ratingValue);
                finishTime = DateTime.Now;
                actualExecTime = (finishTime - startTime).TotalMilliseconds;
                _Report.Info("Execution time for MSNRatingService call: " + actualExecTime);
                _Report.Info("Completed call to MSNRatingService...");

                _Report.Info("Validating second rating submission success...");
                Assert.AreEqual(expectedExitCode, actualExitCode);

                _Report.Info("Validating execution time...");
                Assert.IsTrue(actualExecTime <= expectedExecTime);

                _Report.Success("Test PASSED");
            }

            /// <summary>
            /// Priority 1
            /// Functional Positive Test Case
            /// Verify that a call to the MSN RatingService using all valid parameters correctly succeeds.
            /// This tests the "First Time Rated" scenario in which the mediaId used will have never been rated before.
            /// The new rating should be saved.
            /// </summary>
            [TestCase, Owner("jeremyj"), EnvRequirement("Billing,Catalog"), ServerTestFramework.Description("P1 - Verifies that a call to the MSNRatingService with valid parameters and a Media ID that has never been rated will succeed as expected.")]
            public void pVerifySuccessfulNewRating()
            {
                _Report.Info("Test BEGIN");

                //
                // TODO: Update with a never-before-rated media ID and valid puid.
                //  Might need to look in the catalog to find something that isn't in there...
                //
                Single ratingValue = 1;
                Guid passportPuid = new Guid("87654321-4321-4321-4321-210987654321");
                Guid mediaId = new Guid("87654321-4321-4321-4321-210987654321");
                Int32 mediaTypeId = (int)MediaType.XNACommunityGame;
                String countryCode = "US";

                int expectedExitCode = 0;
                int actualExitCode;
                double expectedExecTime = 10.0;
                double actualExecTime;

                //
                // Make the call to MSN R&R
                //
                MSNRatingServiceMock ratingService = new MSNRatingServiceMock();

                _Report.Info("Calling MSNRatingService...");
                DateTime startTime = DateTime.Now;
                actualExitCode = ratingService.SaveMediaRatingFromUserWithFailure(FailureType.Success, passportPuid, mediaTypeId, mediaId, countryCode, ratingValue);
                DateTime finishTime = DateTime.Now;
                actualExecTime = (finishTime - startTime).TotalMilliseconds;
                _Report.Info("Execution time for MSNRatingService call: " + actualExecTime);
                _Report.Info("Completed call to MSNRatingService...");

                //
                // Validate
                //
                _Report.Info("Validating first rating submission success...");
                Assert.AreEqual(expectedExitCode, actualExitCode);

                _Report.Info("Validating execution time...");
                Assert.IsTrue(actualExecTime <= expectedExecTime);

                _Report.Info("Test PASSED");
            }
        }

        [TestGroup, Owner("jeremyj"), EnvRequirement("Billing,Catalog"), TestTag("P1")]
        public class P1_ErrorTestCases : TestNode
        {
            private static Report _Report = new Report(typeof(P1_ErrorTestCases).Name);

            /// <summary>
            /// Priority 1
            /// Negative Error Test Case
            /// Verify that a call to MSNRatingService with an invalid contentTypeID returns the correct error code.
            /// Since the MSNRatingServiceClass will take the information provided to it and generate a contentTypeID and itemID from it,
            /// we only need to pass in an invalid (or unsupported) mediaTypeID.  This will generate a ContentTypeID that is not mapped at MSN R&R.
            /// </summary>
            [TestCase, Owner("jeremyj"), EnvRequirement("Billing,Catalog"), ServerTestFramework.Description("P1 - Verifies that a call to MSNRatingService with an invalid contentTypeId (non-existing) will fail as expected.")]
            public void eVerifyNonExistingContentTypeIdError()
            {
                _Report.Info("Test BEGIN");

                //
                // Setup Test Params
                // TODO: Update passportPuid and mediaID with real values.
                //
                Single ratingValue = 3;
                Guid passportPuid = new Guid("12345678-1234-1234-1234-123456789012");
                Guid mediaId = new Guid("87654321-4321-4321-4321-210987654321");
                Int32 mediaTypeId = (int)MediaType.InvalidMediaType;
                String countryCode = "US";

                int expectedExitCode = (int)FailureType.InvalidContentTypeId;
                int actualExitCode;
                double expectedExecTime = 10.0;
                double actualExecTime;

                //
                // Make the call to MSN R&R
                //
                MSNRatingServiceMock ratingService = new MSNRatingServiceMock();

                _Report.Info("Calling MSNRatingService...");
                DateTime startTime = DateTime.Now;
                actualExitCode = ratingService.SaveMediaRatingFromUserWithFailure(FailureType.InvalidContentTypeId, passportPuid, mediaTypeId, mediaId, countryCode, ratingValue);
                DateTime finishTime = DateTime.Now;
                actualExecTime = (finishTime - startTime).TotalMilliseconds;
                _Report.Info("Execution time for MSNRatingService call: " + actualExecTime);
                _Report.Info("Completed call to MSNRatingService...");

                //
                // Validate
                //
                _Report.Info("Validating...");
                Assert.AreEqual(expectedExitCode, actualExitCode);

                _Report.Info("Validating execution time...");
                Assert.IsTrue(actualExecTime <= expectedExecTime);

                _Report.Info("Test PASSED");
            }

            /// <summary>
            /// Priority 1
            /// Negative Error Test Case
            /// Verify that a call to MSNRatingService with an invalid contentTypeID (zero) returns the correct error code.
            /// Since the MSNRatingServiceClass will take the information provided to it and generate a contentTypeID and itemID from it,
            /// we only need to pass in an invalid (or unsupported) mediaTypeID.  This will generate a ContentTypeID that is not mapped at MSN R&R.
            /// </summary>
            [TestCase, Owner("jeremyj"), EnvRequirement("Billing,Catalog"), ServerTestFramework.Description("P1 - Verifies that a call to MSNRatingService with an invalid contentTypeId (zero) will fail as expected.")]
            public void eVerifyZeroContentTypeIdError()
            {
                _Report.Info("Test BEGIN");

                //
                // Setup Test Params
                // TODO: Update passportPuid and mediaID with real values.
                //
                Single ratingValue = 3;
                Guid passportPuid = new Guid("12345678-1234-1234-1234-123456789012");
                Guid mediaId = new Guid("87654321-4321-4321-4321-210987654321");
                Int32 mediaTypeId = 0;
                String countryCode = "US";

                int expectedExitCode = (int)FailureType.InvalidContentTypeId;
                int actualExitCode;
                double expectedExecTime = 10.0;
                double actualExecTime;

                //
                // Make the call to MSN R&R
                //
                MSNRatingServiceMock ratingService = new MSNRatingServiceMock();

                _Report.Info("Calling MSNRatingService...");
                DateTime startTime = DateTime.Now;
                actualExitCode = ratingService.SaveMediaRatingFromUserWithFailure(FailureType.InvalidContentTypeId, passportPuid, mediaTypeId, mediaId, countryCode, ratingValue);
                DateTime finishTime = DateTime.Now;
                actualExecTime = (finishTime - startTime).TotalMilliseconds;
                _Report.Info("Execution time for MSNRatingService call: " + actualExecTime);
                _Report.Info("Completed call to MSNRatingService...");

                //
                // Validate
                //
                _Report.Info("Validating...");
                Assert.AreEqual(expectedExitCode, actualExitCode);

                _Report.Info("Validating execution time...");
                Assert.IsTrue(actualExecTime <= expectedExecTime);

                _Report.Info("Test PASSED");
            }

            /// <summary>
            /// Priority 1
            /// Negative Error Test Case
            /// Verify that a call to MSNRatingService with an invalid user ID (Guid.Empty) returns the correct error code.
            /// </summary>
            [TestCase, Owner("jeremyj"), EnvRequirement("Billing,Catalog"), ServerTestFramework.Description("P1 - Verifies that a call to MSNRatingService with an invalid userID (Guid.Empty) will fail as expected.")]
            public void eVerifyZeroUserIdError()
            {
                _Report.Info("Test BEGIN");

                //
                // Setup Test Params
                // TODO: Update passportPuid and mediaID with real values.
                //
                Single ratingValue = 3;
                Guid passportPuid = Guid.Empty;
                Guid mediaId = new Guid("87654321-4321-4321-4321-210987654321");
                Int32 mediaTypeId = (int)MediaType.XNACommunityGame;
                String countryCode = "US";

                int expectedExitCode = (int)FailureType.PuidCannotBeZero;
                int actualExitCode;
                double expectedExecTime = 10.0;
                double actualExecTime;

                //
                // Make the call to MSN R&R
                //
                MSNRatingServiceMock ratingService = new MSNRatingServiceMock();

                _Report.Info("Calling MSNRatingService...");
                DateTime startTime = DateTime.Now;
                actualExitCode = ratingService.SaveMediaRatingFromUserWithFailure(FailureType.PuidCannotBeZero, passportPuid, mediaTypeId, mediaId, countryCode, ratingValue);
                DateTime finishTime = DateTime.Now;
                actualExecTime = (finishTime - startTime).TotalMilliseconds;
                _Report.Info("Execution time for MSNRatingService call: " + actualExecTime);
                _Report.Info("Completed call to MSNRatingService...");

                //
                // Validate
                //
                _Report.Info("Validating...");
                Assert.AreEqual(expectedExitCode, actualExitCode);

                _Report.Info("Validating execution time...");
                Assert.IsTrue(actualExecTime <= expectedExecTime);

                _Report.Info("Test PASSED");
            }
        }

        [TestGroup, Owner("jeremyj"), EnvRequirement("Billing,Catalog"), Description("Stress Tests for MSN RR Client")]
        [StressInstantiate]
        public class StressTests : TestBase
        {
            private static Report _Report = new Report(typeof(StressTests).Name);

            /// <summary>
            /// Priority 1
            /// Stress Test Case
            /// Performs a call to MSNRatingService that should succeed.
            /// </summary>
            [StressTest, Owner("jeremyj"), EnvRequirement("Billing,Catalog"), ServerTestFramework.Description("Stresses a Submit Rating successfully scenario.")]
            public void sStressSubmitRatingSuccess()
            {
                _Report.Info("Test BEGIN");

                //
                // TODO: Update with a never-before-rated media ID and valid puid.
                //  Might need to look in the catalog to find something that isn't in there...
                //
                Single ratingValue = 1;
                Guid passportPuid = new Guid("87654321-4321-4321-4321-210987654321");
                Guid mediaId = new Guid("87654321-4321-4321-4321-210987654321");
                Int32 mediaTypeId = (int)MediaType.XNACommunityGame;
                String countryCode = "US";

                int expectedExitCode = 0;
                int actualExitCode;
                double expectedExecTime = 10.0;
                double actualExecTime;

                //
                // Make the call to MSN R&R
                //
                MSNRatingServiceMock ratingService = new MSNRatingServiceMock();

                _Report.Info("Calling MSNRatingService...");
                DateTime startTime = DateTime.Now;
                actualExitCode = ratingService.SaveMediaRatingFromUserWithFailure(FailureType.Success, passportPuid, mediaTypeId, mediaId, countryCode, ratingValue);
                DateTime finishTime = DateTime.Now;
                actualExecTime = (finishTime - startTime).TotalMilliseconds;
                _Report.Info("Execution time for MSNRatingService call: " + actualExecTime);
                _Report.Info("Completed call to MSNRatingService...");

                //
                // Validate
                //
                _Report.Info("Validating first rating submission success...");
                Assert.AreEqual(expectedExitCode, actualExitCode);

                _Report.Info("Validating execution time...");
                Assert.IsTrue(actualExecTime <= expectedExecTime);

                _Report.Info("Test PASSED");
            }

            /// <summary>
            /// Priority 1
            /// Stress Test Case
            /// Performs a call to MSNRatingService that will fail.
            /// </summary>
            [StressTest, Owner("jeremyj"), EnvRequirement("Billing,Catalog"), ServerTestFramework.Description("Stresses a Submit Rating failure scenario.")]
            public void sStressSubmitRatingFailure()
            {
                _Report.Info("Test BEGIN");

                //
                // Setup Test Params
                // TODO: Update passportPuid and mediaID with real values.
                //
                Single ratingValue = 3;
                Guid passportPuid = Guid.Empty;
                Guid mediaId = new Guid("87654321-4321-4321-4321-210987654321");
                Int32 mediaTypeId = (int)MediaType.XNACommunityGame;
                String countryCode = "US";

                int expectedExitCode = (int)FailureType.PuidCannotBeZero;
                int actualExitCode;
                double expectedExecTime = 10.0;
                double actualExecTime;

                //
                // Make the call to MSN R&R
                //
                MSNRatingServiceMock ratingService = new MSNRatingServiceMock();

                _Report.Info("Calling MSNRatingService...");
                DateTime startTime = DateTime.Now;
                actualExitCode = ratingService.SaveMediaRatingFromUserWithFailure(FailureType.PuidCannotBeZero, passportPuid, mediaTypeId, mediaId, countryCode, ratingValue);
                DateTime finishTime = DateTime.Now;
                actualExecTime = (finishTime - startTime).TotalMilliseconds;
                _Report.Info("Execution time for MSNRatingService call: " + actualExecTime);
                _Report.Info("Completed call to MSNRatingService...");

                //
                // Validate
                //
                _Report.Info("Validating...");
                Assert.AreEqual(expectedExitCode, actualExitCode);

                _Report.Info("Validating execution time...");
                Assert.IsTrue(actualExecTime <= expectedExecTime);

                _Report.Info("Test PASSED");
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\UserRatingsTest\MSNRatingServiceTest\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("RatingsTest")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("RatingsTest")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("51ed073a-1885-4b62-a191-ca00410b79c9")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\ratings\test\Emulator\MSNRR.SingleRating.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.SingleRating {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="SingleRatingSoap", Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RatingItem))]
    public partial class SingleRating : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback AdvanceStateOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetNicknameOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetNicknameSuggestionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingAverageOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingAverageRollupOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingByUserWithAverageOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetMultipleRatingsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsRollupOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUnauthRatingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveNicknameOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveRatingOperationCompleted;
        
        private System.Threading.SendOrPostCallback BulkSaveRatingOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReportViolationOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReviewOperationCompleted;
        
        private System.Threading.SendOrPostCallback BulkSaveReviewOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReviewHelpfulnessOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveUnauthRatingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback ValidateReviewOperationCompleted;
        
        /// <remarks/>
        public SingleRating() {
            this.Url = "http://rr.msn-int.com/rrwebservice/singlerating.asmx";
        }
        
        /// <remarks/>
        public event AdvanceStateCompletedEventHandler AdvanceStateCompleted;
        
        /// <remarks/>
        public event GetNicknameCompletedEventHandler GetNicknameCompleted;
        
        /// <remarks/>
        public event GetNicknameSuggestionsCompletedEventHandler GetNicknameSuggestionsCompleted;
        
        /// <remarks/>
        public event GetRatingAverageCompletedEventHandler GetRatingAverageCompleted;
        
        /// <remarks/>
        public event GetRatingAverageRollupCompletedEventHandler GetRatingAverageRollupCompleted;
        
        /// <remarks/>
        public event GetRatingByUserCompletedEventHandler GetRatingByUserCompleted;
        
        /// <remarks/>
        public event GetRatingByUserWithAverageCompletedEventHandler GetRatingByUserWithAverageCompleted;
        
        /// <remarks/>
        public event GetMultipleRatingsByUserCompletedEventHandler GetMultipleRatingsByUserCompleted;
        
        /// <remarks/>
        public event GetRatingsByUserCompletedEventHandler GetRatingsByUserCompleted;
        
        /// <remarks/>
        public event GetReviewByUserCompletedEventHandler GetReviewByUserCompleted;
        
        /// <remarks/>
        public event GetReviewsCompletedEventHandler GetReviewsCompleted;
        
        /// <remarks/>
        public event GetReviewsByUserCompletedEventHandler GetReviewsByUserCompleted;
        
        /// <remarks/>
        public event GetReviewsRollupCompletedEventHandler GetReviewsRollupCompleted;
        
        /// <remarks/>
        public event GetUnauthRatingsCompletedEventHandler GetUnauthRatingsCompleted;
        
        /// <remarks/>
        public event SaveNicknameCompletedEventHandler SaveNicknameCompleted;
        
        /// <remarks/>
        public event SaveRatingCompletedEventHandler SaveRatingCompleted;
        
        /// <remarks/>
        public event BulkSaveRatingCompletedEventHandler BulkSaveRatingCompleted;
        
        /// <remarks/>
        public event SaveReportViolationCompletedEventHandler SaveReportViolationCompleted;
        
        /// <remarks/>
        public event SaveReviewCompletedEventHandler SaveReviewCompleted;
        
        /// <remarks/>
        public event BulkSaveReviewCompletedEventHandler BulkSaveReviewCompleted;
        
        /// <remarks/>
        public event SaveReviewHelpfulnessCompletedEventHandler SaveReviewHelpfulnessCompleted;
        
        /// <remarks/>
        public event SaveUnauthRatingsCompletedEventHandler SaveUnauthRatingsCompleted;
        
        /// <remarks/>
        public event ValidateReviewCompletedEventHandler ValidateReviewCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/AdvanceState", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.Xml.XmlNode AdvanceState(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values) {
            object[] results = this.Invoke("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values});
            return ((System.Xml.XmlNode)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdvanceState(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.Xml.XmlNode EndAdvanceState(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.Xml.XmlNode)(results[0]));
        }
        
        /// <remarks/>
        public void AdvanceStateAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values) {
            this.AdvanceStateAsync(contentTypeID, itemID, puid, msnGuid, keys, values, null);
        }
        
        /// <remarks/>
        public void AdvanceStateAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values, object userState) {
            if ((this.AdvanceStateOperationCompleted == null)) {
                this.AdvanceStateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAdvanceStateOperationCompleted);
            }
            this.InvokeAsync("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values}, this.AdvanceStateOperationCompleted, userState);
        }
        
        private void OnAdvanceStateOperationCompleted(object arg) {
            if ((this.AdvanceStateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AdvanceStateCompleted(this, new AdvanceStateCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetNickname", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetNickname(long puid, System.Guid msnGuid, out string nickname) {
            object[] results = this.Invoke("GetNickname", new object[] {
                        puid,
                        msnGuid});
            nickname = ((string)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetNickname(long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetNickname", new object[] {
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetNickname(System.IAsyncResult asyncResult, out string nickname) {
            object[] results = this.EndInvoke(asyncResult);
            nickname = ((string)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetNicknameAsync(long puid, System.Guid msnGuid) {
            this.GetNicknameAsync(puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetNicknameAsync(long puid, System.Guid msnGuid, object userState) {
            if ((this.GetNicknameOperationCompleted == null)) {
                this.GetNicknameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetNicknameOperationCompleted);
            }
            this.InvokeAsync("GetNickname", new object[] {
                        puid,
                        msnGuid}, this.GetNicknameOperationCompleted, userState);
        }
        
        private void OnGetNicknameOperationCompleted(object arg) {
            if ((this.GetNicknameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetNicknameCompleted(this, new GetNicknameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetNicknameSuggestions", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetNicknameSuggestions(string seed, out string[] suggestionList) {
            object[] results = this.Invoke("GetNicknameSuggestions", new object[] {
                        seed});
            suggestionList = ((string[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetNicknameSuggestions(string seed, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetNicknameSuggestions", new object[] {
                        seed}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetNicknameSuggestions(System.IAsyncResult asyncResult, out string[] suggestionList) {
            object[] results = this.EndInvoke(asyncResult);
            suggestionList = ((string[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetNicknameSuggestionsAsync(string seed) {
            this.GetNicknameSuggestionsAsync(seed, null);
        }
        
        /// <remarks/>
        public void GetNicknameSuggestionsAsync(string seed, object userState) {
            if ((this.GetNicknameSuggestionsOperationCompleted == null)) {
                this.GetNicknameSuggestionsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetNicknameSuggestionsOperationCompleted);
            }
            this.InvokeAsync("GetNicknameSuggestions", new object[] {
                        seed}, this.GetNicknameSuggestionsOperationCompleted, userState);
        }
        
        private void OnGetNicknameSuggestionsOperationCompleted(object arg) {
            if ((this.GetNicknameSuggestionsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetNicknameSuggestionsCompleted(this, new GetNicknameSuggestionsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverage", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAverage(System.Guid contentTypeID, object itemID, out float rating, out int count) {
            object[] results = this.Invoke("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID});
            rating = ((float)(results[1]));
            count = ((int)(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAverage(System.Guid contentTypeID, object itemID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAverage(System.IAsyncResult asyncResult, out float rating, out int count) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((float)(results[1]));
            count = ((int)(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingAverageAsync(System.Guid contentTypeID, object itemID) {
            this.GetRatingAverageAsync(contentTypeID, itemID, null);
        }
        
        /// <remarks/>
        public void GetRatingAverageAsync(System.Guid contentTypeID, object itemID, object userState) {
            if ((this.GetRatingAverageOperationCompleted == null)) {
                this.GetRatingAverageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAverageOperationCompleted);
            }
            this.InvokeAsync("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID}, this.GetRatingAverageOperationCompleted, userState);
        }
        
        private void OnGetRatingAverageOperationCompleted(object arg) {
            if ((this.GetRatingAverageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAverageCompleted(this, new GetRatingAverageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverageRollup", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAverageRollup(System.Guid contentTypeID, object itemID, out float rating, out int count) {
            object[] results = this.Invoke("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID});
            rating = ((float)(results[1]));
            count = ((int)(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAverageRollup(System.Guid contentTypeID, object itemID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAverageRollup(System.IAsyncResult asyncResult, out float rating, out int count) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((float)(results[1]));
            count = ((int)(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingAverageRollupAsync(System.Guid contentTypeID, object itemID) {
            this.GetRatingAverageRollupAsync(contentTypeID, itemID, null);
        }
        
        /// <remarks/>
        public void GetRatingAverageRollupAsync(System.Guid contentTypeID, object itemID, object userState) {
            if ((this.GetRatingAverageRollupOperationCompleted == null)) {
                this.GetRatingAverageRollupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAverageRollupOperationCompleted);
            }
            this.InvokeAsync("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID}, this.GetRatingAverageRollupOperationCompleted, userState);
        }
        
        private void OnGetRatingAverageRollupOperationCompleted(object arg) {
            if ((this.GetRatingAverageRollupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAverageRollupCompleted(this, new GetRatingAverageRollupCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out int rating) {
            object[] results = this.Invoke("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            rating = ((int)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingByUser(System.IAsyncResult asyncResult, out int rating) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((int)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetRatingByUserAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetRatingByUserOperationCompleted == null)) {
                this.GetRatingByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingByUserOperationCompleted);
            }
            this.InvokeAsync("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetRatingByUserOperationCompleted, userState);
        }
        
        private void OnGetRatingByUserOperationCompleted(object arg) {
            if ((this.GetRatingByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingByUserCompleted(this, new GetRatingByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingByUserWithAverage", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingByUserWithAverage(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out int userRating, out float averageRating, out int count) {
            object[] results = this.Invoke("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            userRating = ((int)(results[1]));
            averageRating = ((float)(results[2]));
            count = ((int)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingByUserWithAverage(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingByUserWithAverage(System.IAsyncResult asyncResult, out int userRating, out float averageRating, out int count) {
            object[] results = this.EndInvoke(asyncResult);
            userRating = ((int)(results[1]));
            averageRating = ((float)(results[2]));
            count = ((int)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingByUserWithAverageAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetRatingByUserWithAverageAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingByUserWithAverageAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetRatingByUserWithAverageOperationCompleted == null)) {
                this.GetRatingByUserWithAverageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingByUserWithAverageOperationCompleted);
            }
            this.InvokeAsync("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetRatingByUserWithAverageOperationCompleted, userState);
        }
        
        private void OnGetRatingByUserWithAverageOperationCompleted(object arg) {
            if ((this.GetRatingByUserWithAverageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingByUserWithAverageCompleted(this, new GetRatingByUserWithAverageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetMultipleRatingsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetMultipleRatingsByUser(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, out int[] ratings) {
            object[] results = this.Invoke("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid});
            ratings = ((int[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMultipleRatingsByUser(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetMultipleRatingsByUser(System.IAsyncResult asyncResult, out int[] ratings) {
            object[] results = this.EndInvoke(asyncResult);
            ratings = ((int[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetMultipleRatingsByUserAsync(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid) {
            this.GetMultipleRatingsByUserAsync(contentTypeID, itemIDs, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetMultipleRatingsByUserAsync(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetMultipleRatingsByUserOperationCompleted == null)) {
                this.GetMultipleRatingsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetMultipleRatingsByUserOperationCompleted);
            }
            this.InvokeAsync("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid}, this.GetMultipleRatingsByUserOperationCompleted, userState);
        }
        
        private void OnGetMultipleRatingsByUserOperationCompleted(object arg) {
            if ((this.GetMultipleRatingsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetMultipleRatingsByUserCompleted(this, new GetMultipleRatingsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingsByUser(System.Guid contentTypeID, long puid, ref System.Guid userID, System.Guid msnGuid, out Rating[] ratings, out string nickname) {
            object[] results = this.Invoke("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid});
            userID = ((System.Guid)(results[1]));
            ratings = ((Rating[])(results[2]));
            nickname = ((string)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingsByUser(System.IAsyncResult asyncResult, out System.Guid userID, out Rating[] ratings, out string nickname) {
            object[] results = this.EndInvoke(asyncResult);
            userID = ((System.Guid)(results[1]));
            ratings = ((Rating[])(results[2]));
            nickname = ((string)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid) {
            this.GetRatingsByUserAsync(contentTypeID, puid, userID, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, object userState) {
            if ((this.GetRatingsByUserOperationCompleted == null)) {
                this.GetRatingsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingsByUserOperationCompleted);
            }
            this.InvokeAsync("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, this.GetRatingsByUserOperationCompleted, userState);
        }
        
        private void OnGetRatingsByUserOperationCompleted(object arg) {
            if ((this.GetRatingsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingsByUserCompleted(this, new GetRatingsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Review review) {
            object[] results = this.Invoke("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            review = ((Review)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewByUser(System.IAsyncResult asyncResult, out Review review) {
            object[] results = this.EndInvoke(asyncResult);
            review = ((Review)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetReviewByUserAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetReviewByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetReviewByUserOperationCompleted == null)) {
                this.GetReviewByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewByUserOperationCompleted);
            }
            this.InvokeAsync("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetReviewByUserOperationCompleted, userState);
        }
        
        private void OnGetReviewByUserOperationCompleted(object arg) {
            if ((this.GetReviewByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewByUserCompleted(this, new GetReviewByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviews", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviews(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder});
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviews(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviews(System.IAsyncResult asyncResult, out int pageSize, out int pageNum, out string sortBy, out string sortOrder, out int totalCount, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder) {
            this.GetReviewsAsync(contentTypeID, itemID, pageSize, pageNum, sortBy, sortOrder, null);
        }
        
        /// <remarks/>
        public void GetReviewsAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, object userState) {
            if ((this.GetReviewsOperationCompleted == null)) {
                this.GetReviewsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsOperationCompleted);
            }
            this.InvokeAsync("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, this.GetReviewsOperationCompleted, userState);
        }
        
        private void OnGetReviewsOperationCompleted(object arg) {
            if ((this.GetReviewsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsCompleted(this, new GetReviewsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid});
            Reviews = ((Review[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewsByUser(System.IAsyncResult asyncResult, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            Reviews = ((Review[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid) {
            this.GetReviewsByUserAsync(contentTypeID, puid, userID, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetReviewsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, object userState) {
            if ((this.GetReviewsByUserOperationCompleted == null)) {
                this.GetReviewsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsByUserOperationCompleted);
            }
            this.InvokeAsync("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, this.GetReviewsByUserOperationCompleted, userState);
        }
        
        private void OnGetReviewsByUserOperationCompleted(object arg) {
            if ((this.GetReviewsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsByUserCompleted(this, new GetReviewsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewsRollup", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewsRollup(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder});
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewsRollup(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewsRollup(System.IAsyncResult asyncResult, out int pageSize, out int pageNum, out string sortBy, out string sortOrder, out int totalCount, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsRollupAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder) {
            this.GetReviewsRollupAsync(contentTypeID, itemID, pageSize, pageNum, sortBy, sortOrder, null);
        }
        
        /// <remarks/>
        public void GetReviewsRollupAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, object userState) {
            if ((this.GetReviewsRollupOperationCompleted == null)) {
                this.GetReviewsRollupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsRollupOperationCompleted);
            }
            this.InvokeAsync("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, this.GetReviewsRollupOperationCompleted, userState);
        }
        
        private void OnGetReviewsRollupOperationCompleted(object arg) {
            if ((this.GetReviewsRollupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsRollupCompleted(this, new GetReviewsRollupCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetUnauthRatings", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetUnauthRatings(System.Guid contentTypeID, object itemID, int daysOfRatingsToUse, out int[] ratingScores, out long[] ratingCounts) {
            object[] results = this.Invoke("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        daysOfRatingsToUse});
            ratingScores = ((int[])(results[1]));
            ratingCounts = ((long[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUnauthRatings(System.Guid contentTypeID, object itemID, int daysOfRatingsToUse, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        daysOfRatingsToUse}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetUnauthRatings(System.IAsyncResult asyncResult, out int[] ratingScores, out long[] ratingCounts) {
            object[] results = this.EndInvoke(asyncResult);
            ratingScores = ((int[])(results[1]));
            ratingCounts = ((long[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetUnauthRatingsAsync(System.Guid contentTypeID, object itemID, int daysOfRatingsToUse) {
            this.GetUnauthRatingsAsync(contentTypeID, itemID, daysOfRatingsToUse, null);
        }
        
        /// <remarks/>
        public void GetUnauthRatingsAsync(System.Guid contentTypeID, object itemID, int daysOfRatingsToUse, object userState) {
            if ((this.GetUnauthRatingsOperationCompleted == null)) {
                this.GetUnauthRatingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUnauthRatingsOperationCompleted);
            }
            this.InvokeAsync("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        daysOfRatingsToUse}, this.GetUnauthRatingsOperationCompleted, userState);
        }
        
        private void OnGetUnauthRatingsOperationCompleted(object arg) {
            if ((this.GetUnauthRatingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUnauthRatingsCompleted(this, new GetUnauthRatingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveNickname", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveNickname(long puid, System.Guid msnGuid, string nickname, out string[] suggestionList, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname});
            suggestionList = ((string[])(results[1]));
            errors = ((ValidationError[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveNickname(long puid, System.Guid msnGuid, string nickname, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveNickname(System.IAsyncResult asyncResult, out string[] suggestionList, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            suggestionList = ((string[])(results[1]));
            errors = ((ValidationError[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveNicknameAsync(long puid, System.Guid msnGuid, string nickname) {
            this.SaveNicknameAsync(puid, msnGuid, nickname, null);
        }
        
        /// <remarks/>
        public void SaveNicknameAsync(long puid, System.Guid msnGuid, string nickname, object userState) {
            if ((this.SaveNicknameOperationCompleted == null)) {
                this.SaveNicknameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveNicknameOperationCompleted);
            }
            this.InvokeAsync("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname}, this.SaveNicknameOperationCompleted, userState);
        }
        
        private void OnSaveNicknameOperationCompleted(object arg) {
            if ((this.SaveNicknameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveNicknameCompleted(this, new SaveNicknameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveRating", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue) {
            object[] results = this.Invoke("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveRating(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue) {
            this.SaveRatingAsync(contentTypeID, itemID, puid, msnGuid, ratingValue, null);
        }
        
        /// <remarks/>
        public void SaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, object userState) {
            if ((this.SaveRatingOperationCompleted == null)) {
                this.SaveRatingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveRatingOperationCompleted);
            }
            this.InvokeAsync("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue}, this.SaveRatingOperationCompleted, userState);
        }
        
        private void OnSaveRatingOperationCompleted(object arg) {
            if ((this.SaveRatingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveRatingCompleted(this, new SaveRatingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/BulkSaveRating", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int BulkSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.DateTime updateDate) {
            object[] results = this.Invoke("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue,
                        updateDate});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBulkSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.DateTime updateDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue,
                        updateDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndBulkSaveRating(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void BulkSaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.DateTime updateDate) {
            this.BulkSaveRatingAsync(contentTypeID, itemID, puid, msnGuid, ratingValue, updateDate, null);
        }
        
        /// <remarks/>
        public void BulkSaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.DateTime updateDate, object userState) {
            if ((this.BulkSaveRatingOperationCompleted == null)) {
                this.BulkSaveRatingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBulkSaveRatingOperationCompleted);
            }
            this.InvokeAsync("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue,
                        updateDate}, this.BulkSaveRatingOperationCompleted, userState);
        }
        
        private void OnBulkSaveRatingOperationCompleted(object arg) {
            if ((this.BulkSaveRatingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BulkSaveRatingCompleted(this, new BulkSaveRatingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReportViolation", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReportViolation(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReportViolation(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReportViolation(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReportViolationAsync(object itemID, System.Guid reviewID, string name, string emailAddress, string comments) {
            this.SaveReportViolationAsync(itemID, reviewID, name, emailAddress, comments, null);
        }
        
        /// <remarks/>
        public void SaveReportViolationAsync(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, object userState) {
            if ((this.SaveReportViolationOperationCompleted == null)) {
                this.SaveReportViolationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReportViolationOperationCompleted);
            }
            this.InvokeAsync("SaveReportViolation", new object[] {
                        itemID,
   